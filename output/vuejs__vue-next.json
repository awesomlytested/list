{"repo":"vuejs/vue-next","url":"https://github.com/vuejs/vue-next","branch":"master","configs":[{"package":"@vue/compiler-core","lang":"ts","dir":"packages/compiler-core/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/compiler-dom","lang":"ts","dir":"packages/compiler-dom/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/compiler-sfc","lang":"ts","dir":"packages/compiler-sfc/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/compiler-ssr","lang":"ts","dir":"packages/compiler-ssr/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/reactivity-transform","lang":"ts","dir":"packages/reactivity-transform/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/reactivity","lang":"ts","dir":"packages/reactivity/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/runtime-core","lang":"ts","dir":"packages/runtime-core/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/runtime-dom","lang":"ts","dir":"packages/runtime-dom/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/runtime-test","lang":"ts","dir":"packages/runtime-test/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/server-renderer","lang":"ts","dir":"packages/server-renderer/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/shared","lang":"ts","dir":"packages/shared/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vue/compat","lang":"ts","dir":"packages/vue-compat/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vue","lang":"ts","dir":"packages/vue/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"module mode preamble","suites":["compiler: codegen"],"updatePoint":{"line":58,"column":28},"line":58,"code":"  test('module mode preamble', () => {\n    const root = createRoot({\n      helpers: new Set([CREATE_VNODE, RESOLVE_DIRECTIVE])\n    })\n    const { code } = generate(root, { mode: 'module' })\n    expect(code).toMatch(\n      `import { ${helperNameMap[CREATE_VNODE]} as _${helperNameMap[CREATE_VNODE]}, ${helperNameMap[RESOLVE_DIRECTIVE]} as _${helperNameMap[RESOLVE_DIRECTIVE]} } from \"vue\"`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"module mode preamble w/ optimizeImports: true","suites":["compiler: codegen"],"updatePoint":{"line":69,"column":53},"line":69,"code":"  test('module mode preamble w/ optimizeImports: true', () => {\n    const root = createRoot({\n      helpers: new Set([CREATE_VNODE, RESOLVE_DIRECTIVE])\n    })\n    const { code } = generate(root, { mode: 'module', optimizeImports: true })\n    expect(code).toMatch(\n      `import { ${helperNameMap[CREATE_VNODE]}, ${helperNameMap[RESOLVE_DIRECTIVE]} } from \"vue\"`\n    )\n    expect(code).toMatch(\n      `const _${helperNameMap[CREATE_VNODE]} = ${helperNameMap[CREATE_VNODE]}, _${helperNameMap[RESOLVE_DIRECTIVE]} = ${helperNameMap[RESOLVE_DIRECTIVE]}`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function mode preamble","suites":["compiler: codegen"],"updatePoint":{"line":83,"column":30},"line":83,"code":"  test('function mode preamble', () => {\n    const root = createRoot({\n      helpers: new Set([CREATE_VNODE, RESOLVE_DIRECTIVE])\n    })\n    const { code } = generate(root, { mode: 'function' })\n    expect(code).toMatch(`const _Vue = Vue`)\n    expect(code).toMatch(\n      `const { ${helperNameMap[CREATE_VNODE]}: _${helperNameMap[CREATE_VNODE]}, ${helperNameMap[RESOLVE_DIRECTIVE]}: _${helperNameMap[RESOLVE_DIRECTIVE]} } = _Vue`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function mode preamble w/ prefixIdentifiers: true","suites":["compiler: codegen"],"updatePoint":{"line":95,"column":57},"line":95,"code":"  test('function mode preamble w/ prefixIdentifiers: true', () => {\n    const root = createRoot({\n      helpers: new Set([CREATE_VNODE, RESOLVE_DIRECTIVE])\n    })\n    const { code } = generate(root, {\n      mode: 'function',\n      prefixIdentifiers: true\n    })\n    expect(code).not.toMatch(`const _Vue = Vue`)\n    expect(code).toMatch(\n      `const { ${helperNameMap[CREATE_VNODE]}: _${helperNameMap[CREATE_VNODE]}, ${helperNameMap[RESOLVE_DIRECTIVE]}: _${helperNameMap[RESOLVE_DIRECTIVE]} } = Vue`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"assets + temps","suites":["compiler: codegen"],"updatePoint":{"line":110,"column":22},"line":110,"code":"  test('assets + temps', () => {\n    const root = createRoot({\n      components: [`Foo`, `bar-baz`, `barbaz`, `Qux__self`],\n      directives: [`my_dir_0`, `my_dir_1`],\n      temps: 3\n    })\n    const { code } = generate(root, { mode: 'function' })\n    expect(code).toMatch(\n      `const _component_Foo = _${helperNameMap[RESOLVE_COMPONENT]}(\"Foo\")\\n`\n    )\n    expect(code).toMatch(\n      `const _component_bar_baz = _${helperNameMap[RESOLVE_COMPONENT]}(\"bar-baz\")\\n`\n    )\n    expect(code).toMatch(\n      `const _component_barbaz = _${helperNameMap[RESOLVE_COMPONENT]}(\"barbaz\")\\n`\n    )\n    // implicit self reference from SFC filename\n    expect(code).toMatch(\n      `const _component_Qux = _${helperNameMap[RESOLVE_COMPONENT]}(\"Qux\", true)\\n`\n    )\n    expect(code).toMatch(\n      `const _directive_my_dir_0 = _${helperNameMap[RESOLVE_DIRECTIVE]}(\"my_dir_0\")\\n`\n    )\n    expect(code).toMatch(\n      `const _directive_my_dir_1 = _${helperNameMap[RESOLVE_DIRECTIVE]}(\"my_dir_1\")\\n`\n    )\n    expect(code).toMatch(`let _temp0, _temp1, _temp2`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoists","suites":["compiler: codegen"],"updatePoint":{"line":140,"column":14},"line":140,"code":"  test('hoists', () => {\n    const root = createRoot({\n      hoists: [\n        createSimpleExpression(`hello`, false, locStub),\n        createObjectExpression(\n          [\n            createObjectProperty(\n              createSimpleExpression(`id`, true, locStub),\n              createSimpleExpression(`foo`, true, locStub)\n            )\n          ],\n          locStub\n        )\n      ]\n    })\n    const { code } = generate(root)\n    expect(code).toMatch(`const _hoisted_1 = hello`)\n    expect(code).toMatch(`const _hoisted_2 = { id: \"foo\" }`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"temps","suites":["compiler: codegen"],"updatePoint":{"line":161,"column":13},"line":161,"code":"  test('temps', () => {\n    const root = createRoot({\n      temps: 3\n    })\n    const { code } = generate(root)\n    expect(code).toMatch(`let _temp0, _temp1, _temp2`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"static text","suites":["compiler: codegen"],"updatePoint":{"line":170,"column":19},"line":170,"code":"  test('static text', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: {\n          type: NodeTypes.TEXT,\n          content: 'hello',\n          loc: locStub\n        }\n      })\n    )\n    expect(code).toMatch(`return \"hello\"`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"interpolation","suites":["compiler: codegen"],"updatePoint":{"line":184,"column":21},"line":184,"code":"  test('interpolation', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createInterpolation(`hello`, locStub)\n      })\n    )\n    expect(code).toMatch(`return _${helperNameMap[TO_DISPLAY_STRING]}(hello)`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"comment","suites":["compiler: codegen"],"updatePoint":{"line":194,"column":15},"line":194,"code":"  test('comment', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: {\n          type: NodeTypes.COMMENT,\n          content: 'foo',\n          loc: locStub\n        }\n      })\n    )\n    expect(code).toMatch(`return _${helperNameMap[CREATE_COMMENT]}(\"foo\")`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"compound expression","suites":["compiler: codegen"],"updatePoint":{"line":208,"column":27},"line":208,"code":"  test('compound expression', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createCompoundExpression([\n          `_ctx.`,\n          createSimpleExpression(`foo`, false, locStub),\n          ` + `,\n          {\n            type: NodeTypes.INTERPOLATION,\n            loc: locStub,\n            content: createSimpleExpression(`bar`, false, locStub)\n          },\n          // nested compound\n          createCompoundExpression([` + `, `nested`])\n        ])\n      })\n    )\n    expect(code).toMatch(\n      `return _ctx.foo + _${helperNameMap[TO_DISPLAY_STRING]}(bar) + nested`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"ifNode","suites":["compiler: codegen"],"updatePoint":{"line":231,"column":14},"line":231,"code":"  test('ifNode', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: {\n          type: NodeTypes.IF,\n          loc: locStub,\n          branches: [],\n          codegenNode: createConditionalExpression(\n            createSimpleExpression('foo', false),\n            createSimpleExpression('bar', false),\n            createSimpleExpression('baz', false)\n          ) as IfConditionalExpression\n        }\n      })\n    )\n    expect(code).toMatch(/return foo\\s+\\? bar\\s+: baz/)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"forNode","suites":["compiler: codegen"],"updatePoint":{"line":250,"column":15},"line":250,"code":"  test('forNode', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: {\n          type: NodeTypes.FOR,\n          loc: locStub,\n          source: createSimpleExpression('foo', false),\n          valueAlias: undefined,\n          keyAlias: undefined,\n          objectIndexAlias: undefined,\n          children: [],\n          parseResult: {} as any,\n          codegenNode: {\n            type: NodeTypes.VNODE_CALL,\n            tag: FRAGMENT,\n            isBlock: true,\n            disableTracking: true,\n            props: undefined,\n            children: createCallExpression(RENDER_LIST),\n            patchFlag: '1',\n            dynamicProps: undefined,\n            directives: undefined,\n            loc: locStub\n          } as ForCodegenNode\n        }\n      })\n    )\n    expect(code).toMatch(`openBlock(true)`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"forNode with constant expression","suites":["compiler: codegen"],"updatePoint":{"line":281,"column":40},"line":281,"code":"  test('forNode with constant expression', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: {\n          type: NodeTypes.FOR,\n          loc: locStub,\n          source: createSimpleExpression(\n            '1 + 2',\n            false,\n            locStub,\n            ConstantTypes.CAN_STRINGIFY\n          ),\n          valueAlias: undefined,\n          keyAlias: undefined,\n          objectIndexAlias: undefined,\n          children: [],\n          parseResult: {} as any,\n          codegenNode: {\n            type: NodeTypes.VNODE_CALL,\n            tag: FRAGMENT,\n            isBlock: true,\n            disableTracking: false,\n            props: undefined,\n            children: createCallExpression(RENDER_LIST),\n            patchFlag: genFlagText(PatchFlags.STABLE_FRAGMENT),\n            dynamicProps: undefined,\n            directives: undefined,\n            loc: locStub\n          } as ForCodegenNode\n        }\n      })\n    )\n    expect(code).toMatch(`openBlock()`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"Element (callExpression + objectExpression + TemplateChildNode[])","suites":["compiler: codegen"],"updatePoint":{"line":317,"column":73},"line":317,"code":"  test('Element (callExpression + objectExpression + TemplateChildNode[])', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createElementWithCodegen(\n          // string\n          `\"div\"`,\n          // ObjectExpression\n          createObjectExpression(\n            [\n              createObjectProperty(\n                createSimpleExpression(`id`, true, locStub),\n                createSimpleExpression(`foo`, true, locStub)\n              ),\n              createObjectProperty(\n                createSimpleExpression(`prop`, false, locStub),\n                createSimpleExpression(`bar`, false, locStub)\n              ),\n              // compound expression as computed key\n              createObjectProperty(\n                {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  loc: locStub,\n                  children: [\n                    `foo + `,\n                    createSimpleExpression(`bar`, false, locStub)\n                  ]\n                },\n                createSimpleExpression(`bar`, false, locStub)\n              )\n            ],\n            locStub\n          ),\n          // ChildNode[]\n          [\n            createElementWithCodegen(\n              `\"p\"`,\n              createObjectExpression(\n                [\n                  createObjectProperty(\n                    // should quote the key!\n                    createSimpleExpression(`some-key`, true, locStub),\n                    createSimpleExpression(`foo`, true, locStub)\n                  )\n                ],\n                locStub\n              )\n            )\n          ],\n          // flag\n          PatchFlags.FULL_PROPS + ''\n        )\n      })\n    )\n    expect(code).toMatch(`\n    return _${helperNameMap[CREATE_ELEMENT_VNODE]}(\"div\", {\n      id: \"foo\",\n      [prop]: bar,\n      [foo + bar]: bar\n    }, [\n      _${helperNameMap[CREATE_ELEMENT_VNODE]}(\"p\", { \"some-key\": \"foo\" })\n    ], ${PatchFlags.FULL_PROPS})`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"ArrayExpression","suites":["compiler: codegen"],"updatePoint":{"line":381,"column":23},"line":381,"code":"  test('ArrayExpression', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createArrayExpression([\n          createSimpleExpression(`foo`, false),\n          createCallExpression(`bar`, [`baz`])\n        ])\n      })\n    )\n    expect(code).toMatch(`return [\n      foo,\n      bar(baz)\n    ]`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"ConditionalExpression","suites":["compiler: codegen"],"updatePoint":{"line":397,"column":29},"line":397,"code":"  test('ConditionalExpression', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createConditionalExpression(\n          createSimpleExpression(`ok`, false),\n          createCallExpression(`foo`),\n          createConditionalExpression(\n            createSimpleExpression(`orNot`, false),\n            createCallExpression(`bar`),\n            createCallExpression(`baz`)\n          )\n        )\n      })\n    )\n    expect(code).toMatch(\n      `return ok\n      ? foo()\n      : orNot\n        ? bar()\n        : baz()`\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"CacheExpression","suites":["compiler: codegen"],"updatePoint":{"line":421,"column":23},"line":421,"code":"  test('CacheExpression', () => {\n    const { code } = generate(\n      createRoot({\n        cached: 1,\n        codegenNode: createCacheExpression(\n          1,\n          createSimpleExpression(`foo`, false)\n        )\n      }),\n      {\n        mode: 'module',\n        prefixIdentifiers: true\n      }\n    )\n    expect(code).toMatch(`_cache[1] || (_cache[1] = foo)`)\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"CacheExpression w/ isVNode: true","suites":["compiler: codegen"],"updatePoint":{"line":439,"column":40},"line":439,"code":"  test('CacheExpression w/ isVNode: true', () => {\n    const { code } = generate(\n      createRoot({\n        cached: 1,\n        codegenNode: createCacheExpression(\n          1,\n          createSimpleExpression(`foo`, false),\n          true\n        )\n      }),\n      {\n        mode: 'module',\n        prefixIdentifiers: true\n      }\n    )\n    expect(code).toMatch(\n      `\n  _cache[1] || (\n    _setBlockTracking(-1),\n    _cache[1] = foo,\n    _setBlockTracking(1),\n    _cache[1]\n  )\n    `.trim()\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"TemplateLiteral","suites":["compiler: codegen"],"updatePoint":{"line":467,"column":23},"line":467,"code":"  test('TemplateLiteral', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createCallExpression(`_push`, [\n          createTemplateLiteral([\n            `foo`,\n            createCallExpression(`_renderAttr`, ['id', 'foo']),\n            `bar`\n          ])\n        ])\n      }),\n      { ssr: true, mode: 'module' }\n    )\n    expect(code).toMatchInlineSnapshot(`\n      \"\n      export function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`foo\\${_renderAttr(id, foo)}bar\\`)\n      }\"\n    `)\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"if","suites":["compiler: codegen","IfStatement"],"updatePoint":{"line":489,"column":12},"line":489,"code":"    test('if', () => {\n      const { code } = generate(\n        createRoot({\n          codegenNode: createBlockStatement([\n            createIfStatement(\n              createSimpleExpression('foo', false),\n              createBlockStatement([createCallExpression(`ok`)])\n            )\n          ])\n        }),\n        { ssr: true, mode: 'module' }\n      )\n      expect(code).toMatchInlineSnapshot(`\n        \"\n        export function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (foo) {\n            ok()\n          }\n        }\"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"if/else","suites":["compiler: codegen","IfStatement"],"updatePoint":{"line":511,"column":17},"line":511,"code":"    test('if/else', () => {\n      const { code } = generate(\n        createRoot({\n          codegenNode: createBlockStatement([\n            createIfStatement(\n              createSimpleExpression('foo', false),\n              createBlockStatement([createCallExpression(`foo`)]),\n              createBlockStatement([createCallExpression('bar')])\n            )\n          ])\n        }),\n        { ssr: true, mode: 'module' }\n      )\n      expect(code).toMatchInlineSnapshot(`\n        \"\n        export function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (foo) {\n            foo()\n          } else {\n            bar()\n          }\n        }\"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"if/else-if","suites":["compiler: codegen","IfStatement"],"updatePoint":{"line":536,"column":20},"line":536,"code":"    test('if/else-if', () => {\n      const { code } = generate(\n        createRoot({\n          codegenNode: createBlockStatement([\n            createIfStatement(\n              createSimpleExpression('foo', false),\n              createBlockStatement([createCallExpression(`foo`)]),\n              createIfStatement(\n                createSimpleExpression('bar', false),\n                createBlockStatement([createCallExpression(`bar`)])\n              )\n            )\n          ])\n        }),\n        { ssr: true, mode: 'module' }\n      )\n      expect(code).toMatchInlineSnapshot(`\n        \"\n        export function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (foo) {\n            foo()\n          } else if (bar) {\n            bar()\n          }\n        }\"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"if/else-if/else","suites":["compiler: codegen","IfStatement"],"updatePoint":{"line":564,"column":25},"line":564,"code":"    test('if/else-if/else', () => {\n      const { code } = generate(\n        createRoot({\n          codegenNode: createBlockStatement([\n            createIfStatement(\n              createSimpleExpression('foo', false),\n              createBlockStatement([createCallExpression(`foo`)]),\n              createIfStatement(\n                createSimpleExpression('bar', false),\n                createBlockStatement([createCallExpression(`bar`)]),\n                createBlockStatement([createCallExpression('baz')])\n              )\n            )\n          ])\n        }),\n        { ssr: true, mode: 'module' }\n      )\n      expect(code).toMatchInlineSnapshot(`\n        \"\n        export function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (foo) {\n            foo()\n          } else if (bar) {\n            bar()\n          } else {\n            baz()\n          }\n        }\"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"AssignmentExpression","suites":["compiler: codegen","IfStatement"],"updatePoint":{"line":596,"column":28},"line":596,"code":"  test('AssignmentExpression', () => {\n    const { code } = generate(\n      createRoot({\n        codegenNode: createAssignmentExpression(\n          createSimpleExpression(`foo`, false),\n          createSimpleExpression(`bar`, false)\n        )\n      })\n    )\n    expect(code).toMatchInlineSnapshot(`\n      \"\n      return function render(_ctx, _cache) {\n        with (_ctx) {\n          return foo = bar\n        }\n      }\"\n    `)\n  })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"tag only","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":632,"column":18},"line":632,"code":"    test('tag only', () => {\n      expect(genCode(createVNodeCall(null, `\"div\"`))).toMatchInlineSnapshot(`\n        \"return _createElementVNode(\\\\\"div\\\\\")\n         \"\n      `)\n      expect(genCode(createVNodeCall(null, FRAGMENT))).toMatchInlineSnapshot(`\n              \"return _createElementVNode(_Fragment)\n               \"\n          `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with props","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":643,"column":20},"line":643,"code":"    test('with props', () => {\n      expect(genCode(createVNodeCall(null, `\"div\"`, mockProps)))\n        .toMatchInlineSnapshot(`\n          \"return _createElementVNode(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" })\n           \"\n        `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with children, no props","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":651,"column":33},"line":651,"code":"    test('with children, no props', () => {\n      expect(genCode(createVNodeCall(null, `\"div\"`, undefined, mockChildren)))\n        .toMatchInlineSnapshot(`\n          \"return _createElementVNode(\\\\\"div\\\\\", null, children)\n           \"\n        `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with children + props","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":659,"column":31},"line":659,"code":"    test('with children + props', () => {\n      expect(genCode(createVNodeCall(null, `\"div\"`, mockProps, mockChildren)))\n        .toMatchInlineSnapshot(`\n          \"return _createElementVNode(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" }, children)\n           \"\n        `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with patchFlag and no children/props","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":667,"column":46},"line":667,"code":"    test('with patchFlag and no children/props', () => {\n      expect(genCode(createVNodeCall(null, `\"div\"`, undefined, undefined, '1')))\n        .toMatchInlineSnapshot(`\n          \"return _createElementVNode(\\\\\"div\\\\\", null, null, 1)\n           \"\n        `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"as block","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":675,"column":18},"line":675,"code":"    test('as block', () => {\n      expect(\n        genCode(\n          createVNodeCall(\n            null,\n            `\"div\"`,\n            mockProps,\n            mockChildren,\n            undefined,\n            undefined,\n            undefined,\n            true\n          )\n        )\n      ).toMatchInlineSnapshot(`\n        \"return (_openBlock(), _createElementBlock(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" }, children))\n         \"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"as for block","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":695,"column":22},"line":695,"code":"    test('as for block', () => {\n      expect(\n        genCode(\n          createVNodeCall(\n            null,\n            `\"div\"`,\n            mockProps,\n            mockChildren,\n            undefined,\n            undefined,\n            undefined,\n            true,\n            true\n          )\n        )\n      ).toMatchInlineSnapshot(`\n        \"return (_openBlock(true), _createElementBlock(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" }, children))\n         \"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with directives","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":716,"column":25},"line":716,"code":"    test('with directives', () => {\n      expect(\n        genCode(\n          createVNodeCall(\n            null,\n            `\"div\"`,\n            mockProps,\n            mockChildren,\n            undefined,\n            undefined,\n            mockDirs\n          )\n        )\n      ).toMatchInlineSnapshot(`\n        \"return _withDirectives(_createElementVNode(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" }, children), [\n              [foo, bar]\n            ])\n         \"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"block + directives","suites":["compiler: codegen","VNodeCall"],"updatePoint":{"line":737,"column":28},"line":737,"code":"    test('block + directives', () => {\n      expect(\n        genCode(\n          createVNodeCall(\n            null,\n            `\"div\"`,\n            mockProps,\n            mockChildren,\n            undefined,\n            undefined,\n            mockDirs,\n            true\n          )\n        )\n      ).toMatchInlineSnapshot(`\n        \"return _withDirectives((_openBlock(), _createElementBlock(\\\\\"div\\\\\", { foo: \\\\\"bar\\\\\" }, children)), [\n              [foo, bar]\n            ])\n         \"\n      `)\n    })","file":"codegen.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function mode","suites":["compiler: integration tests"],"updatePoint":{"line":47,"column":21},"line":47,"code":"  test('function mode', () => {\n    const { code, map } = compile(source, {\n      sourceMap: true,\n      filename: `foo.vue`\n    })\n\n    expect(code).toMatchSnapshot()\n    expect(map!.sources).toEqual([`foo.vue`])\n    expect(map!.sourcesContent).toEqual([source])\n\n    const consumer = new SourceMapConsumer(map as RawSourceMap)\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `id`))\n    ).toMatchObject(getPositionInCode(source, `id`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `\"foo\"`))\n    ).toMatchObject(getPositionInCode(source, `\"foo\"`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `class:`))\n    ).toMatchObject(getPositionInCode(source, `class=`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `bar`))\n    ).toMatchObject(getPositionInCode(source, `bar`))\n\n    // without prefixIdentifiers: true, identifiers inside compound expressions\n    // are mapped to closest parent expression.\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `baz`))\n    ).toMatchObject(getPositionInCode(source, `bar`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `world`))\n    ).toMatchObject(getPositionInCode(source, `world`))\n\n    // without prefixIdentifiers: true, identifiers inside compound expressions\n    // are mapped to closest parent expression.\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `burn()`))\n    ).toMatchObject(getPositionInCode(source, `world`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `ok`))\n    ).toMatchObject(getPositionInCode(source, `ok`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `list`))\n    ).toMatchObject(getPositionInCode(source, `list`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value`))\n    ).toMatchObject(getPositionInCode(source, `value`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `index`))\n    ).toMatchObject(getPositionInCode(source, `index`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value + index`))\n    ).toMatchObject(getPositionInCode(source, `value + index`))\n  })","file":"compile.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function mode w/ prefixIdentifiers: true","suites":["compiler: integration tests"],"updatePoint":{"line":112,"column":48},"line":112,"code":"  test('function mode w/ prefixIdentifiers: true', () => {\n    const { code, map } = compile(source, {\n      sourceMap: true,\n      filename: `foo.vue`,\n      prefixIdentifiers: true\n    })\n\n    expect(code).toMatchSnapshot()\n    expect(map!.sources).toEqual([`foo.vue`])\n    expect(map!.sourcesContent).toEqual([source])\n\n    const consumer = new SourceMapConsumer(map as RawSourceMap)\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `id`))\n    ).toMatchObject(getPositionInCode(source, `id`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `\"foo\"`))\n    ).toMatchObject(getPositionInCode(source, `\"foo\"`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `class:`))\n    ).toMatchObject(getPositionInCode(source, `class=`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `bar`))\n    ).toMatchObject(getPositionInCode(source, `bar`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.bar`, `bar`))\n    ).toMatchObject(getPositionInCode(source, `bar`, true))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `baz`))\n    ).toMatchObject(getPositionInCode(source, `baz`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `world`, true))\n    ).toMatchObject(getPositionInCode(source, `world`, `world`))\n    expect(\n      consumer.originalPositionFor(\n        getPositionInCode(code, `_ctx.world`, `world`)\n      )\n    ).toMatchObject(getPositionInCode(source, `world`, `world`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `burn()`))\n    ).toMatchObject(getPositionInCode(source, `burn()`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `ok`))\n    ).toMatchObject(getPositionInCode(source, `ok`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.ok`, `ok`))\n    ).toMatchObject(getPositionInCode(source, `ok`, true))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `list`))\n    ).toMatchObject(getPositionInCode(source, `list`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.list`, `list`))\n    ).toMatchObject(getPositionInCode(source, `list`, true))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value`))\n    ).toMatchObject(getPositionInCode(source, `value`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `index`))\n    ).toMatchObject(getPositionInCode(source, `index`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value + index`))\n    ).toMatchObject(getPositionInCode(source, `value + index`))\n  })","file":"compile.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"module mode","suites":["compiler: integration tests"],"updatePoint":{"line":187,"column":19},"line":187,"code":"  test('module mode', () => {\n    const { code, map } = compile(source, {\n      mode: 'module',\n      sourceMap: true,\n      filename: `foo.vue`\n    })\n\n    expect(code).toMatchSnapshot()\n    expect(map!.sources).toEqual([`foo.vue`])\n    expect(map!.sourcesContent).toEqual([source])\n\n    const consumer = new SourceMapConsumer(map as RawSourceMap)\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `id`))\n    ).toMatchObject(getPositionInCode(source, `id`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `\"foo\"`))\n    ).toMatchObject(getPositionInCode(source, `\"foo\"`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `class:`))\n    ).toMatchObject(getPositionInCode(source, `class=`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `bar`))\n    ).toMatchObject(getPositionInCode(source, `bar`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.bar`, `bar`))\n    ).toMatchObject(getPositionInCode(source, `bar`, true))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `baz`))\n    ).toMatchObject(getPositionInCode(source, `baz`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `world`, true))\n    ).toMatchObject(getPositionInCode(source, `world`, `world`))\n    expect(\n      consumer.originalPositionFor(\n        getPositionInCode(code, `_ctx.world`, `world`)\n      )\n    ).toMatchObject(getPositionInCode(source, `world`, `world`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `burn()`))\n    ).toMatchObject(getPositionInCode(source, `burn()`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `ok`))\n    ).toMatchObject(getPositionInCode(source, `ok`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.ok`, `ok`))\n    ).toMatchObject(getPositionInCode(source, `ok`, true))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `list`))\n    ).toMatchObject(getPositionInCode(source, `list`))\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `_ctx.list`, `list`))\n    ).toMatchObject(getPositionInCode(source, `list`, true))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value`))\n    ).toMatchObject(getPositionInCode(source, `value`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `index`))\n    ).toMatchObject(getPositionInCode(source, `index`))\n\n    expect(\n      consumer.originalPositionFor(getPositionInCode(code, `value + index`))\n    ).toMatchObject(getPositionInCode(source, `value + index`))\n  })","file":"compile.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple text","suites":["compiler: parse","Text"],"updatePoint":{"line":19,"column":21},"line":19,"code":"    test('simple text', () => {\n      const ast = baseParse('some text')\n      const text = ast.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some text',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: 'some text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple text with invalid end tag","suites":["compiler: parse","Text"],"updatePoint":{"line":34,"column":42},"line":34,"code":"    test('simple text with invalid end tag', () => {\n      const onError = vi.fn()\n      const ast = baseParse('some text</div>', {\n        onError\n      })\n      const text = ast.children[0] as TextNode\n\n      expect(onError).toBeCalled()\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some text',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: 'some text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"text with interpolation","suites":["compiler: parse","Text"],"updatePoint":{"line":53,"column":33},"line":53,"code":"    test('text with interpolation', () => {\n      const ast = baseParse('some {{ foo + bar }} text')\n      const text1 = ast.children[0] as TextNode\n      const text2 = ast.children[2] as TextNode\n\n      expect(text1).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some ',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: 'some '\n        }\n      })\n      expect(text2).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: ' text',\n        loc: {\n          start: { offset: 20, line: 1, column: 21 },\n          end: { offset: 25, line: 1, column: 26 },\n          source: ' text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"text with interpolation which has `<`","suites":["compiler: parse","Text"],"updatePoint":{"line":78,"column":47},"line":78,"code":"    test('text with interpolation which has `<`', () => {\n      const ast = baseParse('some {{ a<b && c>d }} text')\n      const text1 = ast.children[0] as TextNode\n      const text2 = ast.children[2] as TextNode\n\n      expect(text1).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some ',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: 'some '\n        }\n      })\n      expect(text2).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: ' text',\n        loc: {\n          start: { offset: 21, line: 1, column: 22 },\n          end: { offset: 26, line: 1, column: 27 },\n          source: ' text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"text with mix of tags and interpolations","suites":["compiler: parse","Text"],"updatePoint":{"line":103,"column":50},"line":103,"code":"    test('text with mix of tags and interpolations', () => {\n      const ast = baseParse('some <span>{{ foo < bar + foo }} text</span>')\n      const text1 = ast.children[0] as TextNode\n      const text2 = (ast.children[1] as ElementNode).children![1] as TextNode\n\n      expect(text1).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some ',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: 'some '\n        }\n      })\n      expect(text2).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: ' text',\n        loc: {\n          start: { offset: 32, line: 1, column: 33 },\n          end: { offset: 37, line: 1, column: 38 },\n          source: ' text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"lonely \"<\" doesn't separate nodes","suites":["compiler: parse","Text"],"updatePoint":{"line":128,"column":44},"line":128,"code":"    test('lonely \"<\" doesn\\'t separate nodes', () => {\n      const ast = baseParse('a < b', {\n        onError: err => {\n          if (err.code !== ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME) {\n            throw err\n          }\n        }\n      })\n      const text = ast.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'a < b',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: 'a < b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"lonely \"{{\" doesn't separate nodes","suites":["compiler: parse","Text"],"updatePoint":{"line":149,"column":45},"line":149,"code":"    test('lonely \"{{\" doesn\\'t separate nodes', () => {\n      const ast = baseParse('a {{ b', {\n        onError: error => {\n          if (error.code !== ErrorCodes.X_MISSING_INTERPOLATION_END) {\n            throw error\n          }\n        }\n      })\n      const text = ast.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'a {{ b',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 6, line: 1, column: 7 },\n          source: 'a {{ b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple interpolation","suites":["compiler: parse","Interpolation"],"updatePoint":{"line":172,"column":30},"line":172,"code":"    test('simple interpolation', () => {\n      const ast = baseParse('{{message}}')\n      const interpolation = ast.children[0] as InterpolationNode\n\n      expect(interpolation).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `message`,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 2, line: 1, column: 3 },\n            end: { offset: 9, line: 1, column: 10 },\n            source: `message`\n          }\n        },\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 11, line: 1, column: 12 },\n          source: '{{message}}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"it can have tag-like notation","suites":["compiler: parse","Interpolation"],"updatePoint":{"line":197,"column":39},"line":197,"code":"    test('it can have tag-like notation', () => {\n      const ast = baseParse('{{ a<b }}')\n      const interpolation = ast.children[0] as InterpolationNode\n\n      expect(interpolation).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `a<b`,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 3, line: 1, column: 4 },\n            end: { offset: 6, line: 1, column: 7 },\n            source: 'a<b'\n          }\n        },\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: '{{ a<b }}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"it can have tag-like notation (2)","suites":["compiler: parse","Interpolation"],"updatePoint":{"line":222,"column":43},"line":222,"code":"    test('it can have tag-like notation (2)', () => {\n      const ast = baseParse('{{ a<b }}{{ c>d }}')\n      const interpolation1 = ast.children[0] as InterpolationNode\n      const interpolation2 = ast.children[1] as InterpolationNode\n\n      expect(interpolation1).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `a<b`,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 3, line: 1, column: 4 },\n            end: { offset: 6, line: 1, column: 7 },\n            source: 'a<b'\n          }\n        },\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: '{{ a<b }}'\n        }\n      })\n\n      expect(interpolation2).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          content: 'c>d',\n          loc: {\n            start: { offset: 12, line: 1, column: 13 },\n            end: { offset: 15, line: 1, column: 16 },\n            source: 'c>d'\n          }\n        },\n        loc: {\n          start: { offset: 9, line: 1, column: 10 },\n          end: { offset: 18, line: 1, column: 19 },\n          source: '{{ c>d }}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"it can have tag-like notation (3)","suites":["compiler: parse","Interpolation"],"updatePoint":{"line":268,"column":43},"line":268,"code":"    test('it can have tag-like notation (3)', () => {\n      const ast = baseParse('<div>{{ \"</div>\" }}</div>')\n      const element = ast.children[0] as ElementNode\n      const interpolation = element.children[0] as InterpolationNode\n\n      expect(interpolation).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          isStatic: false,\n          // The `constType` is the default value and will be determined in `transformExpression`.\n          constType: ConstantTypes.NOT_CONSTANT,\n          content: '\"</div>\"',\n          loc: {\n            start: { offset: 8, line: 1, column: 9 },\n            end: { offset: 16, line: 1, column: 17 },\n            source: '\"</div>\"'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 19, line: 1, column: 20 },\n          source: '{{ \"</div>\" }}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"custom delimiters","suites":["compiler: parse","Interpolation"],"updatePoint":{"line":295,"column":27},"line":295,"code":"    test('custom delimiters', () => {\n      const ast = baseParse('<p>{msg}</p>', {\n        delimiters: ['{', '}']\n      })\n      const element = ast.children[0] as ElementNode\n      const interpolation = element.children[0] as InterpolationNode\n\n      expect(interpolation).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `msg`,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 4, line: 1, column: 5 },\n            end: { offset: 7, line: 1, column: 8 },\n            source: 'msg'\n          }\n        },\n        loc: {\n          start: { offset: 3, line: 1, column: 4 },\n          end: { offset: 8, line: 1, column: 9 },\n          source: '{msg}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty comment","suites":["compiler: parse","Comment"],"updatePoint":{"line":325,"column":23},"line":325,"code":"    test('empty comment', () => {\n      const ast = baseParse('<!---->')\n      const comment = ast.children[0] as CommentNode\n\n      expect(comment).toStrictEqual({\n        type: NodeTypes.COMMENT,\n        content: '',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 7, line: 1, column: 8 },\n          source: '<!---->'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple comment","suites":["compiler: parse","Comment"],"updatePoint":{"line":340,"column":24},"line":340,"code":"    test('simple comment', () => {\n      const ast = baseParse('<!--abc-->')\n      const comment = ast.children[0] as CommentNode\n\n      expect(comment).toStrictEqual({\n        type: NodeTypes.COMMENT,\n        content: 'abc',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 10, line: 1, column: 11 },\n          source: '<!--abc-->'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"two comments","suites":["compiler: parse","Comment"],"updatePoint":{"line":355,"column":22},"line":355,"code":"    test('two comments', () => {\n      const ast = baseParse('<!--abc--><!--def-->')\n      const comment1 = ast.children[0] as CommentNode\n      const comment2 = ast.children[1] as CommentNode\n\n      expect(comment1).toStrictEqual({\n        type: NodeTypes.COMMENT,\n        content: 'abc',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 10, line: 1, column: 11 },\n          source: '<!--abc-->'\n        }\n      })\n      expect(comment2).toStrictEqual({\n        type: NodeTypes.COMMENT,\n        content: 'def',\n        loc: {\n          start: { offset: 10, line: 1, column: 11 },\n          end: { offset: 20, line: 1, column: 21 },\n          source: '<!--def-->'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"comments option","suites":["compiler: parse","Comment"],"updatePoint":{"line":380,"column":25},"line":380,"code":"    test('comments option', () => {\n      const astOptionNoComment = baseParse('<!--abc-->', { comments: false })\n      const astOptionWithComments = baseParse('<!--abc-->', { comments: true })\n\n      expect(astOptionNoComment.children).toHaveLength(0)\n      expect(astOptionWithComments.children).toHaveLength(1)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"comments in the <pre> tag should be removed when comments option requires it","suites":["compiler: parse","Comment"],"updatePoint":{"line":389,"column":86},"line":389,"code":"    test('comments in the <pre> tag should be removed when comments option requires it', () => {\n      const rawText = `<p/><!-- foo --><p/>`\n\n      const astWithComments = baseParse(`<pre>${rawText}</pre>`, {\n        comments: true\n      })\n      expect(\n        (astWithComments.children[0] as ElementNode).children\n      ).toMatchObject([\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'p'\n        },\n        {\n          type: NodeTypes.COMMENT\n        },\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'p'\n        }\n      ])\n\n      const astWithoutComments = baseParse(`<pre>${rawText}</pre>`, {\n        comments: false\n      })\n      expect(\n        (astWithoutComments.children[0] as ElementNode).children\n      ).toMatchObject([\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'p'\n        },\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'p'\n        }\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple div","suites":["compiler: parse","Element"],"updatePoint":{"line":430,"column":20},"line":430,"code":"    test('simple div', () => {\n      const ast = baseParse('<div>hello</div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [],\n        isSelfClosing: false,\n        children: [\n          {\n            type: NodeTypes.TEXT,\n            content: 'hello',\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 10, line: 1, column: 11 },\n              source: 'hello'\n            }\n          }\n        ],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 16, line: 1, column: 17 },\n          source: '<div>hello</div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty","suites":["compiler: parse","Element"],"updatePoint":{"line":461,"column":15},"line":461,"code":"    test('empty', () => {\n      const ast = baseParse('<div></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [],\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 11, line: 1, column: 12 },\n          source: '<div></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"self closing","suites":["compiler: parse","Element"],"updatePoint":{"line":482,"column":22},"line":482,"code":"    test('self closing', () => {\n      const ast = baseParse('<div/>after')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [],\n\n        isSelfClosing: true,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 6, line: 1, column: 7 },\n          source: '<div/>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"void element","suites":["compiler: parse","Element"],"updatePoint":{"line":504,"column":22},"line":504,"code":"    test('void element', () => {\n      const ast = baseParse('<img>after', {\n        isVoidTag: tag => tag === 'img'\n      })\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'img',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: '<img>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template element with directives","suites":["compiler: parse","Element"],"updatePoint":{"line":528,"column":42},"line":528,"code":"    test('template element with directives', () => {\n      const ast = baseParse('<template v-if=\"ok\"></template>')\n      const element = ast.children[0]\n      expect(element).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tagType: ElementTypes.TEMPLATE\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template element without directives","suites":["compiler: parse","Element"],"updatePoint":{"line":537,"column":45},"line":537,"code":"    test('template element without directives', () => {\n      const ast = baseParse('<template></template>')\n      const element = ast.children[0]\n      expect(element).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tagType: ElementTypes.ELEMENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"native element with `isNativeTag`","suites":["compiler: parse","Element"],"updatePoint":{"line":546,"column":43},"line":546,"code":"    test('native element with `isNativeTag`', () => {\n      const ast = baseParse('<div></div><comp></comp><Comp></Comp>', {\n        isNativeTag: tag => tag === 'div'\n      })\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'comp',\n        tagType: ElementTypes.COMPONENT\n      })\n\n      expect(ast.children[2]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"native element without `isNativeTag`","suites":["compiler: parse","Element"],"updatePoint":{"line":570,"column":46},"line":570,"code":"    test('native element without `isNativeTag`', () => {\n      const ast = baseParse('<div></div><comp></comp><Comp></Comp>')\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'comp',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[2]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-is with `isNativeTag`","suites":["compiler: parse","Element"],"updatePoint":{"line":592,"column":33},"line":592,"code":"    test('v-is with `isNativeTag`', () => {\n      const ast = baseParse(\n        `<div></div><div v-is=\"'foo'\"></div><Comp></Comp>`,\n        {\n          isNativeTag: tag => tag === 'div'\n        }\n      )\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.COMPONENT\n      })\n\n      expect(ast.children[2]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-is without `isNativeTag`","suites":["compiler: parse","Element"],"updatePoint":{"line":619,"column":36},"line":619,"code":"    test('v-is without `isNativeTag`', () => {\n      const ast = baseParse(`<div></div><div v-is=\"'foo'\"></div><Comp></Comp>`)\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.COMPONENT\n      })\n\n      expect(ast.children[2]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"custom element","suites":["compiler: parse","Element"],"updatePoint":{"line":641,"column":24},"line":641,"code":"    test('custom element', () => {\n      const ast = baseParse('<div></div><comp></comp>', {\n        isNativeTag: tag => tag === 'div',\n        isCustomElement: tag => tag === 'comp'\n      })\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'comp',\n        tagType: ElementTypes.ELEMENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"built-in component","suites":["compiler: parse","Element"],"updatePoint":{"line":660,"column":28},"line":660,"code":"    test('built-in component', () => {\n      const ast = baseParse('<div></div><comp></comp>', {\n        isBuiltInComponent: tag => (tag === 'comp' ? Symbol() : void 0)\n      })\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"slot element","suites":["compiler: parse","Element"],"updatePoint":{"line":678,"column":22},"line":678,"code":"    test('slot element', () => {\n      const ast = baseParse('<slot></slot><Comp></Comp>')\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'slot',\n        tagType: ElementTypes.SLOT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with no value","suites":["compiler: parse","Element"],"updatePoint":{"line":694,"column":33},"line":694,"code":"    test('attribute with no value', () => {\n      const ast = baseParse('<div id></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: undefined,\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 7, line: 1, column: 8 },\n              source: 'id'\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 14, line: 1, column: 15 },\n          source: '<div id></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with empty value, double quote","suites":["compiler: parse","Element"],"updatePoint":{"line":727,"column":50},"line":727,"code":"    test('attribute with empty value, double quote', () => {\n      const ast = baseParse('<div id=\"\"></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: '',\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 10, line: 1, column: 11 },\n                source: '\"\"'\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 10, line: 1, column: 11 },\n              source: 'id=\"\"'\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 17, line: 1, column: 18 },\n          source: '<div id=\"\"></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with empty value, single quote","suites":["compiler: parse","Element"],"updatePoint":{"line":768,"column":50},"line":768,"code":"    test('attribute with empty value, single quote', () => {\n      const ast = baseParse(\"<div id=''></div>\")\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: '',\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 10, line: 1, column: 11 },\n                source: \"''\"\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 10, line: 1, column: 11 },\n              source: \"id=''\"\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 17, line: 1, column: 18 },\n          source: \"<div id=''></div>\"\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with value, double quote","suites":["compiler: parse","Element"],"updatePoint":{"line":809,"column":44},"line":809,"code":"    test('attribute with value, double quote', () => {\n      const ast = baseParse('<div id=\">\\'\"></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: \">'\",\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 12, line: 1, column: 13 },\n                source: '\">\\'\"'\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 12, line: 1, column: 13 },\n              source: 'id=\">\\'\"'\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 19, line: 1, column: 20 },\n          source: '<div id=\">\\'\"></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with value, single quote","suites":["compiler: parse","Element"],"updatePoint":{"line":850,"column":44},"line":850,"code":"    test('attribute with value, single quote', () => {\n      const ast = baseParse(\"<div id='>\\\"'></div>\")\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: '>\"',\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 12, line: 1, column: 13 },\n                source: \"'>\\\"'\"\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 12, line: 1, column: 13 },\n              source: \"id='>\\\"'\"\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 19, line: 1, column: 20 },\n          source: \"<div id='>\\\"'></div>\"\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"attribute with value, unquoted","suites":["compiler: parse","Element"],"updatePoint":{"line":891,"column":40},"line":891,"code":"    test('attribute with value, unquoted', () => {\n      const ast = baseParse('<div id=a/></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: 'a/',\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 10, line: 1, column: 11 },\n                source: 'a/'\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 10, line: 1, column: 11 },\n              source: 'id=a/'\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 17, line: 1, column: 18 },\n          source: '<div id=a/></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple attributes","suites":["compiler: parse","Element"],"updatePoint":{"line":932,"column":29},"line":932,"code":"    test('multiple attributes', () => {\n      const ast = baseParse('<div id=a class=\"c\" inert style=\\'\\'></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: Namespaces.HTML,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        codegenNode: undefined,\n        props: [\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'id',\n            value: {\n              type: NodeTypes.TEXT,\n              content: 'a',\n              loc: {\n                start: { offset: 8, line: 1, column: 9 },\n                end: { offset: 9, line: 1, column: 10 },\n                source: 'a'\n              }\n            },\n            loc: {\n              start: { offset: 5, line: 1, column: 6 },\n              end: { offset: 9, line: 1, column: 10 },\n              source: 'id=a'\n            }\n          },\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'class',\n            value: {\n              type: NodeTypes.TEXT,\n              content: 'c',\n              loc: {\n                start: { offset: 16, line: 1, column: 17 },\n                end: { offset: 19, line: 1, column: 20 },\n                source: '\"c\"'\n              }\n            },\n            loc: {\n              start: { offset: 10, line: 1, column: 11 },\n              end: { offset: 19, line: 1, column: 20 },\n              source: 'class=\"c\"'\n            }\n          },\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'inert',\n            value: undefined,\n            loc: {\n              start: { offset: 20, line: 1, column: 21 },\n              end: { offset: 25, line: 1, column: 26 },\n              source: 'inert'\n            }\n          },\n          {\n            type: NodeTypes.ATTRIBUTE,\n            name: 'style',\n            value: {\n              type: NodeTypes.TEXT,\n              content: '',\n              loc: {\n                start: { offset: 32, line: 1, column: 33 },\n                end: { offset: 34, line: 1, column: 35 },\n                source: \"''\"\n              }\n            },\n            loc: {\n              start: { offset: 26, line: 1, column: 27 },\n              end: { offset: 34, line: 1, column: 35 },\n              source: \"style=''\"\n            }\n          }\n        ],\n\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 41, line: 1, column: 42 },\n          source: '<div id=a class=\"c\" inert style=\\'\\'></div>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"class attribute should ignore whitespace when parsed","suites":["compiler: parse","Element"],"updatePoint":{"line":1020,"column":62},"line":1020,"code":"    test('class attribute should ignore whitespace when parsed', () => {\n      const ast = baseParse('<div class=\" \\n\\t c \\t\\n \"></div>')\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        children: [],\n        codegenNode: undefined,\n        isSelfClosing: false,\n        loc: {\n          end: {\n            column: 10,\n            line: 3,\n            offset: 29\n          },\n          source: '<div class=\" \\n\\t c \\t\\n \"></div>',\n          start: {\n            column: 1,\n            line: 1,\n            offset: 0\n          }\n        },\n        ns: Namespaces.HTML,\n        props: [\n          {\n            loc: {\n              end: {\n                column: 3,\n                line: 3,\n                offset: 22\n              },\n              source: 'class=\" \\n\\t c \\t\\n \"',\n              start: {\n                column: 6,\n                line: 1,\n                offset: 5\n              }\n            },\n            name: 'class',\n            type: NodeTypes.ATTRIBUTE,\n            value: {\n              content: 'c',\n              loc: {\n                end: {\n                  column: 3,\n                  line: 3,\n                  offset: 22\n                },\n                source: '\" \\n\\t c \\t\\n \"',\n                start: {\n                  column: 12,\n                  line: 1,\n                  offset: 11\n                }\n              },\n              type: NodeTypes.TEXT\n            }\n          }\n        ],\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT,\n        type: NodeTypes.ELEMENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with no value","suites":["compiler: parse","Element"],"updatePoint":{"line":1084,"column":33},"line":1084,"code":"    test('directive with no value', () => {\n      const ast = baseParse('<div v-if/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'if',\n        arg: undefined,\n        modifiers: [],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: 'v-if'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with value","suites":["compiler: parse","Element"],"updatePoint":{"line":1102,"column":30},"line":1102,"code":"    test('directive with value', () => {\n      const ast = baseParse('<div v-if=\"a\"/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'if',\n        arg: undefined,\n        modifiers: [],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 11, line: 1, column: 12 },\n            end: { offset: 12, line: 1, column: 13 },\n            source: 'a'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 13, line: 1, column: 14 },\n          source: 'v-if=\"a\"'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with argument","suites":["compiler: parse","Element"],"updatePoint":{"line":1130,"column":33},"line":1130,"code":"    test('directive with argument', () => {\n      const ast = baseParse('<div v-on:click/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'click',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'click',\n            start: {\n              column: 11,\n              line: 1,\n              offset: 10\n            },\n            end: {\n              column: 16,\n              line: 1,\n              offset: 15\n            }\n          }\n        },\n        modifiers: [],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 15, line: 1, column: 16 },\n          source: 'v-on:click'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with dynamic argument","suites":["compiler: parse","Element"],"updatePoint":{"line":1167,"column":41},"line":1167,"code":"    test('directive with dynamic argument', () => {\n      const ast = baseParse('<div v-on:[event]/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'event',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            source: '[event]',\n            start: {\n              column: 11,\n              line: 1,\n              offset: 10\n            },\n            end: {\n              column: 18,\n              line: 1,\n              offset: 17\n            }\n          }\n        },\n        modifiers: [],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 17, line: 1, column: 18 },\n          source: 'v-on:[event]'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with a modifier","suites":["compiler: parse","Element"],"updatePoint":{"line":1204,"column":35},"line":1204,"code":"    test('directive with a modifier', () => {\n      const ast = baseParse('<div v-on.enter/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: undefined,\n        modifiers: ['enter'],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 15, line: 1, column: 16 },\n          source: 'v-on.enter'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with two modifiers","suites":["compiler: parse","Element"],"updatePoint":{"line":1222,"column":38},"line":1222,"code":"    test('directive with two modifiers', () => {\n      const ast = baseParse('<div v-on.enter.exact/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: undefined,\n        modifiers: ['enter', 'exact'],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 21, line: 1, column: 22 },\n          source: 'v-on.enter.exact'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with argument and modifiers","suites":["compiler: parse","Element"],"updatePoint":{"line":1240,"column":47},"line":1240,"code":"    test('directive with argument and modifiers', () => {\n      const ast = baseParse('<div v-on:click.enter.exact/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'click',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'click',\n            start: {\n              column: 11,\n              line: 1,\n              offset: 10\n            },\n            end: {\n              column: 16,\n              line: 1,\n              offset: 15\n            }\n          }\n        },\n        modifiers: ['enter', 'exact'],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 27, line: 1, column: 28 },\n          source: 'v-on:click.enter.exact'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with dynamic argument and modifiers","suites":["compiler: parse","Element"],"updatePoint":{"line":1277,"column":55},"line":1277,"code":"    test('directive with dynamic argument and modifiers', () => {\n      const ast = baseParse('<div v-on:[a.b].camel/>')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a.b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            source: '[a.b]',\n            start: {\n              column: 11,\n              line: 1,\n              offset: 10\n            },\n            end: {\n              column: 16,\n              line: 1,\n              offset: 15\n            }\n          }\n        },\n        modifiers: ['camel'],\n        exp: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 21, line: 1, column: 22 },\n          source: 'v-on:[a.b].camel'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive with no name","suites":["compiler: parse","Element"],"updatePoint":{"line":1313,"column":32},"line":1313,"code":"    test('directive with no name', () => {\n      let errorCode = -1\n      const ast = baseParse('<div v-/>', {\n        onError: err => {\n          errorCode = err.code as number\n        }\n      })\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(errorCode).toBe(ErrorCodes.X_MISSING_DIRECTIVE_NAME)\n      expect(directive).toStrictEqual({\n        type: NodeTypes.ATTRIBUTE,\n        name: 'v-',\n        value: undefined,\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 7, line: 1, column: 8 },\n          source: 'v-'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind shorthand","suites":["compiler: parse","Element"],"updatePoint":{"line":1335,"column":26},"line":1335,"code":"    test('v-bind shorthand', () => {\n      const ast = baseParse('<div :a=b />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'bind',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'a',\n            start: {\n              column: 7,\n              line: 1,\n              offset: 6\n            },\n            end: {\n              column: 8,\n              line: 1,\n              offset: 7\n            }\n          }\n        },\n        modifiers: [],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            start: { offset: 8, line: 1, column: 9 },\n            end: { offset: 9, line: 1, column: 10 },\n            source: 'b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: ':a=b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind .prop shorthand","suites":["compiler: parse","Element"],"updatePoint":{"line":1383,"column":32},"line":1383,"code":"    test('v-bind .prop shorthand', () => {\n      const ast = baseParse('<div .a=b />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'bind',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'a',\n            start: {\n              column: 7,\n              line: 1,\n              offset: 6\n            },\n            end: {\n              column: 8,\n              line: 1,\n              offset: 7\n            }\n          }\n        },\n        modifiers: ['prop'],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            start: { offset: 8, line: 1, column: 9 },\n            end: { offset: 9, line: 1, column: 10 },\n            source: 'b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: '.a=b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind shorthand with modifier","suites":["compiler: parse","Element"],"updatePoint":{"line":1431,"column":40},"line":1431,"code":"    test('v-bind shorthand with modifier', () => {\n      const ast = baseParse('<div :a.sync=b />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'bind',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'a',\n            start: {\n              column: 7,\n              line: 1,\n              offset: 6\n            },\n            end: {\n              column: 8,\n              line: 1,\n              offset: 7\n            }\n          }\n        },\n        modifiers: ['sync'],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            start: { offset: 13, line: 1, column: 14 },\n            end: { offset: 14, line: 1, column: 15 },\n            source: 'b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 14, line: 1, column: 15 },\n          source: ':a.sync=b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on shorthand","suites":["compiler: parse","Element"],"updatePoint":{"line":1479,"column":24},"line":1479,"code":"    test('v-on shorthand', () => {\n      const ast = baseParse('<div @a=b />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'a',\n            start: {\n              column: 7,\n              line: 1,\n              offset: 6\n            },\n            end: {\n              column: 8,\n              line: 1,\n              offset: 7\n            }\n          }\n        },\n        modifiers: [],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            start: { offset: 8, line: 1, column: 9 },\n            end: { offset: 9, line: 1, column: 10 },\n            source: 'b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 9, line: 1, column: 10 },\n          source: '@a=b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on shorthand with modifier","suites":["compiler: parse","Element"],"updatePoint":{"line":1527,"column":38},"line":1527,"code":"    test('v-on shorthand with modifier', () => {\n      const ast = baseParse('<div @a.enter=b />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'on',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n\n          loc: {\n            source: 'a',\n            start: {\n              column: 7,\n              line: 1,\n              offset: 6\n            },\n            end: {\n              column: 8,\n              line: 1,\n              offset: 7\n            }\n          }\n        },\n        modifiers: ['enter'],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'b',\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n\n          loc: {\n            start: { offset: 14, line: 1, column: 15 },\n            end: { offset: 15, line: 1, column: 16 },\n            source: 'b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 15, line: 1, column: 16 },\n          source: '@a.enter=b'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-slot shorthand","suites":["compiler: parse","Element"],"updatePoint":{"line":1575,"column":26},"line":1575,"code":"    test('v-slot shorthand', () => {\n      const ast = baseParse('<Comp #a=\"{ b }\" />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toStrictEqual({\n        type: NodeTypes.DIRECTIVE,\n        name: 'slot',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'a',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n          loc: {\n            source: 'a',\n            start: {\n              column: 8,\n              line: 1,\n              offset: 7\n            },\n            end: {\n              column: 9,\n              line: 1,\n              offset: 8\n            }\n          }\n        },\n        modifiers: [],\n        exp: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: '{ b }',\n          isStatic: false,\n          // The `constType` is the default value and will be determined in transformExpression\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 10, line: 1, column: 11 },\n            end: { offset: 15, line: 1, column: 16 },\n            source: '{ b }'\n          }\n        },\n        loc: {\n          start: { offset: 6, line: 1, column: 7 },\n          end: { offset: 16, line: 1, column: 17 },\n          source: '#a=\"{ b }\"'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-slot arg containing dots","suites":["compiler: parse","Element"],"updatePoint":{"line":1623,"column":36},"line":1623,"code":"    test('v-slot arg containing dots', () => {\n      const ast = baseParse('<Comp v-slot:foo.bar=\"{ a }\" />')\n      const directive = (ast.children[0] as ElementNode).props[0]\n\n      expect(directive).toMatchObject({\n        type: NodeTypes.DIRECTIVE,\n        name: 'slot',\n        arg: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: 'foo.bar',\n          isStatic: true,\n          constType: ConstantTypes.CAN_STRINGIFY,\n          loc: {\n            source: 'foo.bar',\n            start: {\n              column: 14,\n              line: 1,\n              offset: 13\n            },\n            end: {\n              column: 21,\n              line: 1,\n              offset: 20\n            }\n          }\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-pre","suites":["compiler: parse","Element"],"updatePoint":{"line":1652,"column":15},"line":1652,"code":"    test('v-pre', () => {\n      const ast = baseParse(\n        `<div v-pre :id=\"foo\"><Comp/>{{ bar }}</div>\\n` +\n          `<div :id=\"foo\"><Comp/>{{ bar }}</div>`\n      )\n\n      const divWithPre = ast.children[0] as ElementNode\n      expect(divWithPre.props).toMatchObject([\n        {\n          type: NodeTypes.ATTRIBUTE,\n          name: `:id`,\n          value: {\n            type: NodeTypes.TEXT,\n            content: `foo`\n          },\n          loc: {\n            source: `:id=\"foo\"`,\n            start: {\n              line: 1,\n              column: 12\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        }\n      ])\n      expect(divWithPre.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tagType: ElementTypes.ELEMENT,\n        tag: `Comp`\n      })\n      expect(divWithPre.children[1]).toMatchObject({\n        type: NodeTypes.TEXT,\n        content: `{{ bar }}`\n      })\n\n      // should not affect siblings after it\n      const divWithoutPre = ast.children[1] as ElementNode\n      expect(divWithoutPre.props).toMatchObject([\n        {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            isStatic: true,\n            content: `id`\n          },\n          exp: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            isStatic: false,\n            content: `foo`\n          },\n          loc: {\n            source: `:id=\"foo\"`,\n            start: {\n              line: 2,\n              column: 6\n            },\n            end: {\n              line: 2,\n              column: 15\n            }\n          }\n        }\n      ])\n      expect(divWithoutPre.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tagType: ElementTypes.COMPONENT,\n        tag: `Comp`\n      })\n      expect(divWithoutPre.children[1]).toMatchObject({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `bar`,\n          isStatic: false\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"self-closing v-pre","suites":["compiler: parse","Element"],"updatePoint":{"line":1734,"column":28},"line":1734,"code":"    test('self-closing v-pre', () => {\n      const ast = baseParse(\n        `<div v-pre/>\\n<div :id=\"foo\"><Comp/>{{ bar }}</div>`\n      )\n      // should not affect siblings after it\n      const divWithoutPre = ast.children[1] as ElementNode\n      expect(divWithoutPre.props).toMatchObject([\n        {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            isStatic: true,\n            content: `id`\n          },\n          exp: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            isStatic: false,\n            content: `foo`\n          },\n          loc: {\n            source: `:id=\"foo\"`,\n            start: {\n              line: 2,\n              column: 6\n            },\n            end: {\n              line: 2,\n              column: 15\n            }\n          }\n        }\n      ])\n      expect(divWithoutPre.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tagType: ElementTypes.COMPONENT,\n        tag: `Comp`\n      })\n      expect(divWithoutPre.children[1]).toMatchObject({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `bar`,\n          isStatic: false\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"end tags are case-insensitive.","suites":["compiler: parse","Element"],"updatePoint":{"line":1782,"column":40},"line":1782,"code":"    test('end tags are case-insensitive.', () => {\n      const ast = baseParse('<div>hello</DIV>after')\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'hello',\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 10, line: 1, column: 11 },\n          source: 'hello'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"self closing single tag","suites":["compiler: parse","Element"],"updatePoint":{"line":1799,"column":31},"line":1799,"code":"  test('self closing single tag', () => {\n    const ast = baseParse('<div :class=\"{ some: condition }\" />')\n\n    expect(ast.children).toHaveLength(1)\n    expect(ast.children[0]).toMatchObject({ tag: 'div' })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"self closing multiple tag","suites":["compiler: parse","Element"],"updatePoint":{"line":1806,"column":33},"line":1806,"code":"  test('self closing multiple tag', () => {\n    const ast = baseParse(\n      `<div :class=\"{ some: condition }\" />\\n` +\n        `<p v-bind:style=\"{ color: 'red' }\"/>`\n    )\n\n    expect(ast).toMatchSnapshot()\n\n    expect(ast.children).toHaveLength(2)\n    expect(ast.children[0]).toMatchObject({ tag: 'div' })\n    expect(ast.children[1]).toMatchObject({ tag: 'p' })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"valid html","suites":["compiler: parse","Element"],"updatePoint":{"line":1819,"column":18},"line":1819,"code":"  test('valid html', () => {\n    const ast = baseParse(\n      `<div :class=\"{ some: condition }\">\\n` +\n        `  <p v-bind:style=\"{ color: 'red' }\"/>\\n` +\n        `  <!-- a comment with <html> inside it -->\\n` +\n        `</div>`\n    )\n\n    expect(ast).toMatchSnapshot()\n\n    expect(ast.children).toHaveLength(1)\n    const el = ast.children[0] as any\n    expect(el).toMatchObject({\n      tag: 'div'\n    })\n    expect(el.children).toHaveLength(2)\n    expect(el.children[0]).toMatchObject({\n      tag: 'p'\n    })\n    expect(el.children[1]).toMatchObject({\n      type: NodeTypes.COMMENT\n    })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"invalid html","suites":["compiler: parse","Element"],"updatePoint":{"line":1843,"column":20},"line":1843,"code":"  test('invalid html', () => {\n    expect(() => {\n      baseParse(`<div>\\n<span>\\n</div>\\n</span>`)\n    }).toThrow('Element is missing end tag.')\n\n    const spy = vi.fn()\n    const ast = baseParse(`<div>\\n<span>\\n</div>\\n</span>`, {\n      onError: spy\n    })\n\n    expect(spy.mock.calls).toMatchObject([\n      [\n        {\n          code: ErrorCodes.X_MISSING_END_TAG,\n          loc: {\n            start: {\n              offset: 6,\n              line: 2,\n              column: 1\n            }\n          }\n        }\n      ],\n      [\n        {\n          code: ErrorCodes.X_INVALID_END_TAG,\n          loc: {\n            start: {\n              offset: 20,\n              line: 4,\n              column: 1\n            }\n          }\n        }\n      ]\n    ])\n\n    expect(ast).toMatchSnapshot()\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"parse with correct location info","suites":["compiler: parse","Element"],"updatePoint":{"line":1883,"column":40},"line":1883,"code":"  test('parse with correct location info', () => {\n    const [foo, bar, but, baz] = baseParse(\n      `\nfoo\n is {{ bar }} but {{ baz }}`.trim()\n    ).children\n\n    let offset = 0\n    expect(foo.loc.start).toEqual({ line: 1, column: 1, offset })\n    offset += foo.loc.source.length\n    expect(foo.loc.end).toEqual({ line: 2, column: 5, offset })\n\n    expect(bar.loc.start).toEqual({ line: 2, column: 5, offset })\n    const barInner = (bar as InterpolationNode).content\n    offset += 3\n    expect(barInner.loc.start).toEqual({ line: 2, column: 8, offset })\n    offset += barInner.loc.source.length\n    expect(barInner.loc.end).toEqual({ line: 2, column: 11, offset })\n    offset += 3\n    expect(bar.loc.end).toEqual({ line: 2, column: 14, offset })\n\n    expect(but.loc.start).toEqual({ line: 2, column: 14, offset })\n    offset += but.loc.source.length\n    expect(but.loc.end).toEqual({ line: 2, column: 19, offset })\n\n    expect(baz.loc.start).toEqual({ line: 2, column: 19, offset })\n    const bazInner = (baz as InterpolationNode).content\n    offset += 3\n    expect(bazInner.loc.start).toEqual({ line: 2, column: 22, offset })\n    offset += bazInner.loc.source.length\n    expect(bazInner.loc.end).toEqual({ line: 2, column: 25, offset })\n    offset += 3\n    expect(baz.loc.end).toEqual({ line: 2, column: 28, offset })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"use default map","suites":["compiler: parse","decodeEntities option"],"updatePoint":{"line":1919,"column":25},"line":1919,"code":"    test('use default map', () => {\n      const ast: any = baseParse('&gt;&lt;&amp;&apos;&quot;&foo;')\n\n      expect(ast.children.length).toBe(1)\n      expect(ast.children[0].type).toBe(NodeTypes.TEXT)\n      expect(ast.children[0].content).toBe('><&\\'\"&foo;')\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"use the given map","suites":["compiler: parse","decodeEntities option"],"updatePoint":{"line":1927,"column":27},"line":1927,"code":"    test('use the given map', () => {\n      const ast: any = baseParse('&amp;&cups;', {\n        decodeEntities: text => text.replace('&cups;', '\\u222A\\uFE00'),\n        onError: () => {} // Ignore errors\n      })\n\n      expect(ast.children.length).toBe(1)\n      expect(ast.children[0].type).toBe(NodeTypes.TEXT)\n      expect(ast.children[0].content).toBe('&amp;\\u222A\\uFE00')\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should remove whitespaces at start/end inside an element","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1946,"column":64},"line":1946,"code":"    it('should remove whitespaces at start/end inside an element', () => {\n      const ast = parse(`<div>   <span/>    </div>`)\n      expect((ast.children[0] as ElementNode).children.length).toBe(1)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should remove whitespaces w/ newline between elements","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1951,"column":61},"line":1951,"code":"    it('should remove whitespaces w/ newline between elements', () => {\n      const ast = parse(`<div/> \\n <div/> \\n <div/>`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children.every(c => c.type === NodeTypes.ELEMENT)).toBe(true)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should remove whitespaces adjacent to comments","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1957,"column":54},"line":1957,"code":"    it('should remove whitespaces adjacent to comments', () => {\n      const ast = parse(`<div/> \\n <!--foo--> <div/>`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect(ast.children[1].type).toBe(NodeTypes.COMMENT)\n      expect(ast.children[2].type).toBe(NodeTypes.ELEMENT)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should remove whitespaces w/ newline between comments and elements","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1965,"column":74},"line":1965,"code":"    it('should remove whitespaces w/ newline between comments and elements', () => {\n      const ast = parse(`<div/> \\n <!--foo--> \\n <div/>`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect(ast.children[1].type).toBe(NodeTypes.COMMENT)\n      expect(ast.children[2].type).toBe(NodeTypes.ELEMENT)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT remove whitespaces w/ newline between interpolations","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1973,"column":71},"line":1973,"code":"    it('should NOT remove whitespaces w/ newline between interpolations', () => {\n      const ast = parse(`{{ foo }} \\n {{ bar }}`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children[0].type).toBe(NodeTypes.INTERPOLATION)\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.TEXT,\n        content: ' '\n      })\n      expect(ast.children[2].type).toBe(NodeTypes.INTERPOLATION)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT remove whitespaces w/ newline between interpolation and comment","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1984,"column":82},"line":1984,"code":"    it('should NOT remove whitespaces w/ newline between interpolation and comment', () => {\n      const ast = parse(`<!-- foo --> \\n {{msg}}`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children[0].type).toBe(NodeTypes.COMMENT)\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.TEXT,\n        content: ' '\n      })\n      expect(ast.children[2].type).toBe(NodeTypes.INTERPOLATION)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT remove whitespaces w/o newline between elements","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":1995,"column":66},"line":1995,"code":"    it('should NOT remove whitespaces w/o newline between elements', () => {\n      const ast = parse(`<div/> <div/> <div/>`)\n      expect(ast.children.length).toBe(5)\n      expect(ast.children.map(c => c.type)).toMatchObject([\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should condense consecutive whitespaces in text","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":2007,"column":55},"line":2007,"code":"    it('should condense consecutive whitespaces in text', () => {\n      const ast = parse(`   foo  \\n    bar     baz     `)\n      expect((ast.children[0] as TextNode).content).toBe(` foo bar baz `)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should remove leading newline character immediately following the pre element start tag","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":2012,"column":95},"line":2012,"code":"    it('should remove leading newline character immediately following the pre element start tag', () => {\n      const ast = baseParse(`<pre>\\n  foo  bar  </pre>`, {\n        isPreTag: tag => tag === 'pre'\n      })\n      expect(ast.children).toHaveLength(1)\n      const preElement = ast.children[0] as ElementNode\n      expect(preElement.children).toHaveLength(1)\n      expect((preElement.children[0] as TextNode).content).toBe(`  foo  bar  `)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT remove leading newline character immediately following child-tag of pre element","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":2022,"column":98},"line":2022,"code":"    it('should NOT remove leading newline character immediately following child-tag of pre element', () => {\n      const ast = baseParse(`<pre><span></span>\\n  foo  bar  </pre>`, {\n        isPreTag: tag => tag === 'pre'\n      })\n      const preElement = ast.children[0] as ElementNode\n      expect(preElement.children).toHaveLength(2)\n      expect((preElement.children[1] as TextNode).content).toBe(\n        `\\n  foo  bar  `\n      )\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"self-closing pre tag","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":2033,"column":28},"line":2033,"code":"    it('self-closing pre tag', () => {\n      const ast = baseParse(`<pre/><span>\\n  foo   bar</span>`, {\n        isPreTag: tag => tag === 'pre'\n      })\n      const elementAfterPre = ast.children[1] as ElementNode\n      // should not affect the <span> and condense its whitespace inside\n      expect((elementAfterPre.children[0] as TextNode).content).toBe(` foo bar`)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT condense whitespaces in RCDATA text mode","suites":["compiler: parse","whitespace management when adopting strategy condense"],"updatePoint":{"line":2042,"column":59},"line":2042,"code":"    it('should NOT condense whitespaces in RCDATA text mode', () => {\n      const ast = baseParse(`<textarea>Text:\\n   foo</textarea>`, {\n        getTextMode: ({ tag }) =>\n          tag === 'textarea' ? TextModes.RCDATA : TextModes.DATA\n      })\n      const preElement = ast.children[0] as ElementNode\n      expect(preElement.children).toHaveLength(1)\n      expect((preElement.children[0] as TextNode).content).toBe(`Text:\\n   foo`)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should still remove whitespaces at start/end inside an element","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2060,"column":70},"line":2060,"code":"    it('should still remove whitespaces at start/end inside an element', () => {\n      const ast = parse(`<div>   <span/>    </div>`)\n      expect((ast.children[0] as ElementNode).children.length).toBe(1)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve whitespaces w/ newline between elements","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2065,"column":63},"line":2065,"code":"    it('should preserve whitespaces w/ newline between elements', () => {\n      const ast = parse(`<div/> \\n <div/> \\n <div/>`)\n      expect(ast.children.length).toBe(5)\n      expect(ast.children.map(c => c.type)).toMatchObject([\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve whitespaces adjacent to comments","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2077,"column":56},"line":2077,"code":"    it('should preserve whitespaces adjacent to comments', () => {\n      const ast = parse(`<div/> \\n <!--foo--> <div/>`)\n      expect(ast.children.length).toBe(5)\n      expect(ast.children.map(c => c.type)).toMatchObject([\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.COMMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve whitespaces w/ newline between comments and elements","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2089,"column":76},"line":2089,"code":"    it('should preserve whitespaces w/ newline between comments and elements', () => {\n      const ast = parse(`<div/> \\n <!--foo--> \\n <div/>`)\n      expect(ast.children.length).toBe(5)\n      expect(ast.children.map(c => c.type)).toMatchObject([\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.COMMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve whitespaces w/ newline between interpolations","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2101,"column":69},"line":2101,"code":"    it('should preserve whitespaces w/ newline between interpolations', () => {\n      const ast = parse(`{{ foo }} \\n {{ bar }}`)\n      expect(ast.children.length).toBe(3)\n      expect(ast.children[0].type).toBe(NodeTypes.INTERPOLATION)\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.TEXT,\n        content: ' '\n      })\n      expect(ast.children[2].type).toBe(NodeTypes.INTERPOLATION)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve whitespaces w/o newline between elements","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2112,"column":64},"line":2112,"code":"    it('should preserve whitespaces w/o newline between elements', () => {\n      const ast = parse(`<div/> <div/> <div/>`)\n      expect(ast.children.length).toBe(5)\n      expect(ast.children.map(c => c.type)).toMatchObject([\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT,\n        NodeTypes.TEXT,\n        NodeTypes.ELEMENT\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should preserve consecutive whitespaces in text","suites":["compiler: parse","whitespace management when adopting strategy preserve"],"updatePoint":{"line":2124,"column":55},"line":2124,"code":"    it('should preserve consecutive whitespaces in text', () => {\n      const content = `   foo  \\n    bar     baz     `\n      const ast = parse(content)\n      expect((ast.children[0] as TextNode).content).toBe(content)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should only work in module mode","suites":["scopeId compiler support"],"updatePoint":{"line":12,"column":39},"line":12,"code":"  test('should only work in module mode', () => {\n    expect(() => {\n      baseCompile(``, { scopeId: 'test' })\n    }).toThrow(`\"scopeId\" option is only supported in module mode`)\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should wrap default slot","suites":["scopeId compiler support"],"updatePoint":{"line":18,"column":32},"line":18,"code":"  test('should wrap default slot', () => {\n    const { code } = baseCompile(`<Child><div/></Child>`, {\n      mode: 'module',\n      scopeId: 'test'\n    })\n    expect(code).toMatch(`default: _withCtx(() => [`)\n    expect(code).toMatchSnapshot()\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should wrap named slots","suites":["scopeId compiler support"],"updatePoint":{"line":27,"column":31},"line":27,"code":"  test('should wrap named slots', () => {\n    const { code } = baseCompile(\n      `<Child>\n        <template #foo=\"{ msg }\">{{ msg }}</template>\n        <template #bar><div/></template>\n      </Child>\n      `,\n      {\n        mode: 'module',\n        scopeId: 'test'\n      }\n    )\n    expect(code).toMatch(`foo: _withCtx(({ msg }) => [`)\n    expect(code).toMatch(`bar: _withCtx(() => [`)\n    expect(code).toMatchSnapshot()\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should wrap dynamic slots","suites":["scopeId compiler support"],"updatePoint":{"line":44,"column":33},"line":44,"code":"  test('should wrap dynamic slots', () => {\n    const { code } = baseCompile(\n      `<Child>\n        <template #foo v-if=\"ok\"><div/></template>\n        <template v-for=\"i in list\" #[i]><div/></template>\n      </Child>\n      `,\n      {\n        mode: 'module',\n        scopeId: 'test'\n      }\n    )\n    expect(code).toMatch(/name: \"foo\",\\s+fn: _withCtx\\(/)\n    expect(code).toMatch(/name: i,\\s+fn: _withCtx\\(/)\n    expect(code).toMatchSnapshot()\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should push scopeId for hoisted nodes","suites":["scopeId compiler support"],"updatePoint":{"line":61,"column":45},"line":61,"code":"  test('should push scopeId for hoisted nodes', () => {\n    const { ast, code } = baseCompile(\n      `<div><div>hello</div>{{ foo }}<div>world</div></div>`,\n      {\n        mode: 'module',\n        scopeId: 'test',\n        hoistStatic: true\n      }\n    )\n    expect(ast.helpers).toContain(PUSH_SCOPE_ID)\n    expect(ast.helpers).toContain(POP_SCOPE_ID)\n    expect(ast.hoists.length).toBe(2)\n    ;[\n      `const _withScopeId = n => (_pushScopeId(\"test\"),n=n(),_popScopeId(),n)`,\n      `const _hoisted_1 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", null, \"hello\", ${genFlagText(\n        PatchFlags.HOISTED\n      )}))`,\n      `const _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", null, \"world\", ${genFlagText(\n        PatchFlags.HOISTED\n      )}))`\n    ].forEach(c => expect(code).toMatch(c))\n    expect(code).toMatchSnapshot()\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context state","suites":["compiler: transform"],"updatePoint":{"line":27,"column":21},"line":27,"code":"  test('context state', () => {\n    const ast = baseParse(`<div>hello {{ world }}</div>`)\n\n    // manually store call arguments because context is mutable and shared\n    // across calls\n    const calls: any[] = []\n    const plugin: NodeTransform = (node, context) => {\n      calls.push([node, { ...context }])\n    }\n\n    transform(ast, {\n      nodeTransforms: [plugin]\n    })\n\n    const div = ast.children[0] as ElementNode\n    expect(calls.length).toBe(4)\n    expect(calls[0]).toMatchObject([\n      ast,\n      {\n        parent: null,\n        currentNode: ast\n      }\n    ])\n    expect(calls[1]).toMatchObject([\n      div,\n      {\n        parent: ast,\n        currentNode: div\n      }\n    ])\n    expect(calls[2]).toMatchObject([\n      div.children[0],\n      {\n        parent: div,\n        currentNode: div.children[0]\n      }\n    ])\n    expect(calls[3]).toMatchObject([\n      div.children[1],\n      {\n        parent: div,\n        currentNode: div.children[1]\n      }\n    ])\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context.replaceNode","suites":["compiler: transform"],"updatePoint":{"line":73,"column":27},"line":73,"code":"  test('context.replaceNode', () => {\n    const ast = baseParse(`<div/><span/>`)\n    const plugin: NodeTransform = (node, context) => {\n      if (node.type === NodeTypes.ELEMENT && node.tag === 'div') {\n        // change the node to <p>\n        context.replaceNode(\n          Object.assign({}, node, {\n            tag: 'p',\n            children: [\n              {\n                type: NodeTypes.TEXT,\n                content: 'hello',\n                isEmpty: false\n              }\n            ]\n          })\n        )\n      }\n    }\n    const spy = vi.fn(plugin)\n    transform(ast, {\n      nodeTransforms: [spy]\n    })\n\n    expect(ast.children.length).toBe(2)\n    const newElement = ast.children[0] as ElementNode\n    expect(newElement.tag).toBe('p')\n    expect(spy).toHaveBeenCalledTimes(4)\n    // should traverse the children of replaced node\n    expect(spy.mock.calls[2][0]).toBe(newElement.children[0])\n    // should traverse the node after the replaced node\n    expect(spy.mock.calls[3][0]).toBe(ast.children[1])\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context.removeNode","suites":["compiler: transform"],"updatePoint":{"line":107,"column":26},"line":107,"code":"  test('context.removeNode', () => {\n    const ast = baseParse(`<span/><div>hello</div><span/>`)\n    const c1 = ast.children[0]\n    const c2 = ast.children[2]\n\n    const plugin: NodeTransform = (node, context) => {\n      if (node.type === NodeTypes.ELEMENT && node.tag === 'div') {\n        context.removeNode()\n      }\n    }\n    const spy = vi.fn(plugin)\n    transform(ast, {\n      nodeTransforms: [spy]\n    })\n\n    expect(ast.children.length).toBe(2)\n    expect(ast.children[0]).toBe(c1)\n    expect(ast.children[1]).toBe(c2)\n\n    // should not traverse children of remove node\n    expect(spy).toHaveBeenCalledTimes(4)\n    // should traverse nodes around removed\n    expect(spy.mock.calls[1][0]).toBe(c1)\n    expect(spy.mock.calls[3][0]).toBe(c2)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context.removeNode (prev sibling)","suites":["compiler: transform"],"updatePoint":{"line":133,"column":41},"line":133,"code":"  test('context.removeNode (prev sibling)', () => {\n    const ast = baseParse(`<span/><div/><span/>`)\n    const c1 = ast.children[0]\n    const c2 = ast.children[2]\n\n    const plugin: NodeTransform = (node, context) => {\n      if (node.type === NodeTypes.ELEMENT && node.tag === 'div') {\n        context.removeNode()\n        // remove previous sibling\n        context.removeNode(context.parent!.children[0])\n      }\n    }\n    const spy = vi.fn(plugin)\n    transform(ast, {\n      nodeTransforms: [spy]\n    })\n\n    expect(ast.children.length).toBe(1)\n    expect(ast.children[0]).toBe(c2)\n\n    expect(spy).toHaveBeenCalledTimes(4)\n    // should still traverse first span before removal\n    expect(spy.mock.calls[1][0]).toBe(c1)\n    // should still traverse last span\n    expect(spy.mock.calls[3][0]).toBe(c2)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context.removeNode (next sibling)","suites":["compiler: transform"],"updatePoint":{"line":160,"column":41},"line":160,"code":"  test('context.removeNode (next sibling)', () => {\n    const ast = baseParse(`<span/><div/><span/>`)\n    const c1 = ast.children[0]\n    const d1 = ast.children[1]\n\n    const plugin: NodeTransform = (node, context) => {\n      if (node.type === NodeTypes.ELEMENT && node.tag === 'div') {\n        context.removeNode()\n        // remove next sibling\n        context.removeNode(context.parent!.children[1])\n      }\n    }\n    const spy = vi.fn(plugin)\n    transform(ast, {\n      nodeTransforms: [spy]\n    })\n\n    expect(ast.children.length).toBe(1)\n    expect(ast.children[0]).toBe(c1)\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    // should still traverse first span before removal\n    expect(spy.mock.calls[1][0]).toBe(c1)\n    // should not traverse last span\n    expect(spy.mock.calls[2][0]).toBe(d1)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"context.hoist","suites":["compiler: transform"],"updatePoint":{"line":187,"column":21},"line":187,"code":"  test('context.hoist', () => {\n    const ast = baseParse(`<div :id=\"foo\"/><div :id=\"bar\"/>`)\n    const hoisted: ExpressionNode[] = []\n    const mock: NodeTransform = (node, context) => {\n      if (node.type === NodeTypes.ELEMENT) {\n        const dir = node.props[0] as DirectiveNode\n        hoisted.push(dir.exp!)\n        dir.exp = context.hoist(dir.exp!)\n      }\n    }\n    transform(ast, {\n      nodeTransforms: [mock]\n    })\n    expect(ast.hoists).toMatchObject(hoisted)\n    expect((ast as any).children[0].props[0].exp.content).toBe(`_hoisted_1`)\n    expect((ast as any).children[1].props[0].exp.content).toBe(`_hoisted_2`)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"onError option","suites":["compiler: transform"],"updatePoint":{"line":205,"column":22},"line":205,"code":"  test('onError option', () => {\n    const ast = baseParse(`<div/>`)\n    const loc = ast.children[0].loc\n    const plugin: NodeTransform = (node, context) => {\n      context.onError(\n        createCompilerError(ErrorCodes.X_INVALID_END_TAG, node.loc)\n      )\n    }\n    const spy = vi.fn()\n    transform(ast, {\n      nodeTransforms: [plugin],\n      onError: spy\n    })\n    expect(spy.mock.calls[0]).toMatchObject([\n      {\n        code: ErrorCodes.X_INVALID_END_TAG,\n        loc\n      }\n    ])\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should inject toString helper for interpolations","suites":["compiler: transform"],"updatePoint":{"line":226,"column":56},"line":226,"code":"  test('should inject toString helper for interpolations', () => {\n    const ast = baseParse(`{{ foo }}`)\n    transform(ast, {})\n    expect(ast.helpers).toContain(TO_DISPLAY_STRING)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should inject createVNode and Comment for comments","suites":["compiler: transform"],"updatePoint":{"line":232,"column":58},"line":232,"code":"  test('should inject createVNode and Comment for comments', () => {\n    const ast = baseParse(`<!--foo-->`)\n    transform(ast, {})\n    expect(ast.helpers).toContain(CREATE_COMMENT)\n  })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"no children","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":269,"column":21},"line":269,"code":"    test('no children', () => {\n      const ast = transformWithCodegen(``)\n      expect(ast.codegenNode).toBeUndefined()\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"single <slot/>","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":274,"column":24},"line":274,"code":"    test('single <slot/>', () => {\n      const ast = transformWithCodegen(`<slot/>`)\n      expect(ast.codegenNode).toMatchObject({\n        codegenNode: {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: RENDER_SLOT\n        }\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"single element","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":284,"column":24},"line":284,"code":"    test('single element', () => {\n      const ast = transformWithCodegen(`<div/>`)\n      expect(ast.codegenNode).toMatchObject(createBlockMatcher(`\"div\"`))\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"root v-if","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":289,"column":19},"line":289,"code":"    test('root v-if', () => {\n      const ast = transformWithCodegen(`<div v-if=\"ok\" />`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.IF\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"root v-for","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":296,"column":20},"line":296,"code":"    test('root v-for', () => {\n      const ast = transformWithCodegen(`<div v-for=\"i in list\" />`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.FOR\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"root element with custom directive","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":303,"column":44},"line":303,"code":"    test('root element with custom directive', () => {\n      const ast = transformWithCodegen(`<div v-foo/>`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        directives: { type: NodeTypes.JS_ARRAY_EXPRESSION }\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"single text","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":311,"column":21},"line":311,"code":"    test('single text', () => {\n      const ast = transformWithCodegen(`hello`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.TEXT\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"single interpolation","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":318,"column":30},"line":318,"code":"    test('single interpolation', () => {\n      const ast = transformWithCodegen(`{{ foo }}`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.INTERPOLATION\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"single CompoundExpression","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":325,"column":35},"line":325,"code":"    test('single CompoundExpression', () => {\n      const ast = transformWithCodegen(`{{ foo }} bar baz`)\n      expect(ast.codegenNode).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION\n      })\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple children","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":332,"column":27},"line":332,"code":"    test('multiple children', () => {\n      const ast = transformWithCodegen(`<div/><div/>`)\n      expect(ast.codegenNode).toMatchObject(\n        createBlockMatcher(\n          FRAGMENT,\n          undefined,\n          [\n            { type: NodeTypes.ELEMENT, tag: `div` },\n            { type: NodeTypes.ELEMENT, tag: `div` }\n          ] as any,\n          genFlagText(PatchFlags.STABLE_FRAGMENT)\n        )\n      )\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple children w/ single root + comments","suites":["compiler: transform","root codegenNode"],"updatePoint":{"line":347,"column":53},"line":347,"code":"    test('multiple children w/ single root + comments', () => {\n      const ast = transformWithCodegen(`<!--foo--><div/><!--bar-->`)\n      expect(ast.codegenNode).toMatchObject(\n        createBlockMatcher(\n          FRAGMENT,\n          undefined,\n          [\n            { type: NodeTypes.COMMENT },\n            { type: NodeTypes.ELEMENT, tag: `div` },\n            { type: NodeTypes.COMMENT }\n          ] as any,\n          genFlagText([\n            PatchFlags.STABLE_FRAGMENT,\n            PatchFlags.DEV_ROOT_FRAGMENT\n          ])\n        )\n      )\n    })","file":"transform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist root node","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":64,"column":34},"line":64,"code":"  test('should NOT hoist root node', () => {\n    // if the whole tree is static, the root still needs to be a block\n    // so that it's patched in optimized mode to skip children\n    const root = transformWithHoist(`<div/>`)\n    expect(root.hoists.length).toBe(0)\n    expect(root.codegenNode).toMatchObject({\n      tag: `\"div\"`\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist simple element","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":75,"column":28},"line":75,"code":"  test('hoist simple element', () => {\n    const root = transformWithHoist(\n      `<div><span class=\"inline\">hello</span></div>`\n    )\n    expect(root.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"span\"`,\n        props: createObjectMatcher({ class: 'inline' }),\n        children: {\n          type: NodeTypes.TEXT,\n          content: `hello`\n        }\n      },\n      hoistedChildrenArrayMatcher()\n    ])\n    expect(root.codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: undefined,\n      children: { content: `_hoisted_2` }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist nested static tree","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":99,"column":32},"line":99,"code":"  test('hoist nested static tree', () => {\n    const root = transformWithHoist(`<div><p><span/><span/></p></div>`)\n    expect(root.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"p\"`,\n        props: undefined,\n        children: [\n          { type: NodeTypes.ELEMENT, tag: `span` },\n          { type: NodeTypes.ELEMENT, tag: `span` }\n        ]\n      },\n      hoistedChildrenArrayMatcher()\n    ])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject({\n      content: '_hoisted_2'\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist nested static tree with comments","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":119,"column":46},"line":119,"code":"  test('hoist nested static tree with comments', () => {\n    const root = transformWithHoist(`<div><div><!--comment--></div></div>`)\n    expect(root.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`,\n        props: undefined,\n        children: [{ type: NodeTypes.COMMENT, content: `comment` }]\n      },\n      hoistedChildrenArrayMatcher()\n    ])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject({\n      content: `_hoisted_2`\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist siblings with common non-hoistable parent","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":136,"column":55},"line":136,"code":"  test('hoist siblings with common non-hoistable parent', () => {\n    const root = transformWithHoist(`<div><span/><div/></div>`)\n    expect(root.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"span\"`\n      },\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`\n      },\n      hoistedChildrenArrayMatcher(1, 2)\n    ])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject({\n      content: '_hoisted_3'\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist components","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":155,"column":35},"line":155,"code":"  test('should NOT hoist components', () => {\n    const root = transformWithHoist(`<div><Comp/></div>`)\n    expect(root.hoists.length).toBe(0)\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `_component_Comp`\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist element with dynamic props (but hoist the props list)","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":170,"column":78},"line":170,"code":"  test('should NOT hoist element with dynamic props (but hoist the props list)', () => {\n    const root = transformWithHoist(`<div><div :id=\"foo\"/></div>`)\n    expect(root.hoists.length).toBe(1)\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: createObjectMatcher({\n            id: `[foo]`\n          }),\n          children: undefined,\n          patchFlag: genFlagText(PatchFlags.PROPS),\n          dynamicProps: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `_hoisted_1`,\n            isStatic: false\n          }\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist element with static key","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":195,"column":37},"line":195,"code":"  test('hoist element with static key', () => {\n    const root = transformWithHoist(`<div><div key=\"foo\"/></div>`)\n    expect(root.hoists.length).toBe(2)\n    expect(root.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: 'foo' })\n      },\n      hoistedChildrenArrayMatcher()\n    ])\n    expect(root.codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: undefined,\n      children: { content: `_hoisted_2` }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist element with dynamic key","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":214,"column":49},"line":214,"code":"  test('should NOT hoist element with dynamic key', () => {\n    const root = transformWithHoist(`<div><div :key=\"foo\"/></div>`)\n    expect(root.hoists.length).toBe(0)\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: createObjectMatcher({\n            key: `[foo]`\n          })\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist element with dynamic ref","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":232,"column":49},"line":232,"code":"  test('should NOT hoist element with dynamic ref', () => {\n    const root = transformWithHoist(`<div><div :ref=\"foo\"/></div>`)\n    expect(root.hoists.length).toBe(0)\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: createObjectMatcher({\n            ref: `[foo]`\n          }),\n          children: undefined,\n          patchFlag: genFlagText(PatchFlags.NEED_PATCH)\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist static props for elements with directives","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":252,"column":55},"line":252,"code":"  test('hoist static props for elements with directives', () => {\n    const root = transformWithHoist(`<div><div id=\"foo\" v-foo/></div>`)\n    expect(root.hoists).toMatchObject([createObjectMatcher({ id: 'foo' })])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `_hoisted_1`\n          },\n          children: undefined,\n          patchFlag: genFlagText(PatchFlags.NEED_PATCH),\n          directives: {\n            type: NodeTypes.JS_ARRAY_EXPRESSION\n          }\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist static props for elements with dynamic text children","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":276,"column":66},"line":276,"code":"  test('hoist static props for elements with dynamic text children', () => {\n    const root = transformWithHoist(\n      `<div><div id=\"foo\">{{ hello }}</div></div>`\n    )\n    expect(root.hoists).toMatchObject([createObjectMatcher({ id: 'foo' })])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: { content: `_hoisted_1` },\n          children: { type: NodeTypes.INTERPOLATION },\n          patchFlag: genFlagText(PatchFlags.TEXT)\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist static props for elements with unhoistable children","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":296,"column":65},"line":296,"code":"  test('hoist static props for elements with unhoistable children', () => {\n    const root = transformWithHoist(`<div><div id=\"foo\"><Comp/></div></div>`)\n    expect(root.hoists).toMatchObject([createObjectMatcher({ id: 'foo' })])\n    expect((root.codegenNode as VNodeCall).children).toMatchObject([\n      {\n        type: NodeTypes.ELEMENT,\n        codegenNode: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"div\"`,\n          props: { content: `_hoisted_1` },\n          children: [{ type: NodeTypes.ELEMENT, tag: `Comp` }]\n        }\n      }\n    ])\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should hoist v-if props/children if static","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":313,"column":50},"line":313,"code":"  test('should hoist v-if props/children if static', () => {\n    const root = transformWithHoist(\n      `<div><div v-if=\"ok\" id=\"foo\"><span/></div></div>`\n    )\n    expect(root.hoists).toMatchObject([\n      createObjectMatcher({\n        key: `[0]`, // key injected by v-if branch\n        id: 'foo'\n      }),\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"span\"`\n      },\n      hoistedChildrenArrayMatcher(2)\n    ])\n    expect(\n      ((root.children[0] as ElementNode).children[0] as IfNode).codegenNode\n    ).toMatchObject({\n      type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n      consequent: {\n        // blocks should NOT be hoisted\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`,\n        props: { content: `_hoisted_1` },\n        children: { content: `_hoisted_3` }\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should hoist v-for children if static","suites":["compiler: hoistStatic transform"],"updatePoint":{"line":343,"column":45},"line":343,"code":"  test('should hoist v-for children if static', () => {\n    const root = transformWithHoist(\n      `<div><div v-for=\"i in list\" id=\"foo\"><span/></div></div>`\n    )\n    expect(root.hoists).toMatchObject([\n      createObjectMatcher({\n        id: 'foo'\n      }),\n      {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"span\"`\n      },\n      hoistedChildrenArrayMatcher(2)\n    ])\n    const forBlockCodegen = (\n      (root.children[0] as ElementNode).children[0] as ForNode\n    ).codegenNode\n    expect(forBlockCodegen).toMatchObject({\n      type: NodeTypes.VNODE_CALL,\n      tag: FRAGMENT,\n      props: undefined,\n      children: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: RENDER_LIST\n      },\n      patchFlag: genFlagText(PatchFlags.UNKEYED_FRAGMENT)\n    })\n    const innerBlockCodegen = forBlockCodegen!.children.arguments[1]\n    expect(innerBlockCodegen.returns).toMatchObject({\n      type: NodeTypes.VNODE_CALL,\n      tag: `\"div\"`,\n      props: { content: `_hoisted_1` },\n      children: { content: `_hoisted_3` }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist nested static tree with static interpolation","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":381,"column":60},"line":381,"code":"    test('hoist nested static tree with static interpolation', () => {\n      const root = transformWithHoist(\n        `<div><span>foo {{ 1 }} {{ true }}</span></div>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n      expect(root.hoists).toMatchObject([\n        {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"span\"`,\n          props: undefined,\n          children: {\n            type: NodeTypes.COMPOUND_EXPRESSION\n          }\n        },\n        hoistedChildrenArrayMatcher()\n      ])\n      expect(root.codegenNode).toMatchObject({\n        tag: `\"div\"`,\n        props: undefined,\n        children: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `_hoisted_2`\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist nested static tree with static prop value","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":410,"column":57},"line":410,"code":"    test('hoist nested static tree with static prop value', () => {\n      const root = transformWithHoist(\n        `<div><span :foo=\"0\">{{ 1 }}</span></div>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n\n      expect(root.hoists).toMatchObject([\n        {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"span\"`,\n          props: createObjectMatcher({ foo: `[0]` }),\n          children: {\n            type: NodeTypes.INTERPOLATION,\n            content: {\n              content: `1`,\n              isStatic: false,\n              constType: ConstantTypes.CAN_STRINGIFY\n            }\n          }\n        },\n        hoistedChildrenArrayMatcher()\n      ])\n      expect(root.codegenNode).toMatchObject({\n        tag: `\"div\"`,\n        props: undefined,\n        children: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `_hoisted_2`\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"hoist class with static object value","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":445,"column":46},"line":445,"code":"    test('hoist class with static object value', () => {\n      const root = transformWithHoist(\n        `<div><span :class=\"{ foo: true }\">{{ bar }}</span></div>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n\n      expect(root.hoists).toMatchObject([\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `class`,\n                isStatic: true,\n                constType: ConstantTypes.CAN_STRINGIFY\n              },\n              value: {\n                type: NodeTypes.JS_CALL_EXPRESSION,\n                callee: NORMALIZE_CLASS,\n                arguments: [\n                  {\n                    content: `{ foo: true }`,\n                    isStatic: false,\n                    constType: ConstantTypes.CAN_STRINGIFY\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ])\n      expect(root.codegenNode).toMatchObject({\n        tag: `\"div\"`,\n        props: undefined,\n        children: [\n          {\n            type: NodeTypes.ELEMENT,\n            codegenNode: {\n              type: NodeTypes.VNODE_CALL,\n              tag: `\"span\"`,\n              props: {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `_hoisted_1`\n              },\n              children: {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `_ctx.bar`,\n                  isStatic: false,\n                  constType: ConstantTypes.NOT_CONSTANT\n                }\n              },\n              patchFlag: `1 /* TEXT */`\n            }\n          }\n        ]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist expressions that refer scope variables","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":507,"column":65},"line":507,"code":"    test('should NOT hoist expressions that refer scope variables', () => {\n      const root = transformWithHoist(\n        `<div><p v-for=\"o in list\"><span>{{ o }}</span></p></div>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n\n      expect(root.hoists.length).toBe(0)\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist expressions that refer scope variables (2)","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":519,"column":69},"line":519,"code":"    test('should NOT hoist expressions that refer scope variables (2)', () => {\n      const root = transformWithHoist(\n        `<div><p v-for=\"o in list\"><span>{{ o + 'foo' }}</span></p></div>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n\n      expect(root.hoists.length).toBe(0)\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist expressions that refer scope variables (v-slot)","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":531,"column":74},"line":531,"code":"    test('should NOT hoist expressions that refer scope variables (v-slot)', () => {\n      const root = transformWithHoist(\n        `<Comp v-slot=\"{ foo }\">{{ foo }}</Comp>`,\n        {\n          prefixIdentifiers: true\n        }\n      )\n\n      expect(root.hoists.length).toBe(0)\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist elements with cached handlers","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":543,"column":56},"line":543,"code":"    test('should NOT hoist elements with cached handlers', () => {\n      const root = transformWithHoist(\n        `<div><div><div @click=\"foo\"/></div></div>`,\n        {\n          prefixIdentifiers: true,\n          cacheHandlers: true\n        }\n      )\n\n      expect(root.cached).toBe(1)\n      expect(root.hoists.length).toBe(0)\n      expect(\n        generate(root, {\n          mode: 'module',\n          prefixIdentifiers: true\n        }).code\n      ).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist elements with cached handlers + other bindings","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":562,"column":73},"line":562,"code":"    test('should NOT hoist elements with cached handlers + other bindings', () => {\n      const root = transformWithHoist(\n        `<div><div><div :class=\"{}\" @click=\"foo\"/></div></div>`,\n        {\n          prefixIdentifiers: true,\n          cacheHandlers: true\n        }\n      )\n\n      expect(root.cached).toBe(1)\n      expect(root.hoists.length).toBe(0)\n      expect(\n        generate(root, {\n          mode: 'module',\n          prefixIdentifiers: true\n        }).code\n      ).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist keyed template v-for with plain element child","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":581,"column":72},"line":581,"code":"    test('should NOT hoist keyed template v-for with plain element child', () => {\n      const root = transformWithHoist(\n        `<div><template v-for=\"item in items\" :key=\"item\"><span/></template></div>`\n      )\n      expect(root.hoists.length).toBe(0)\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT hoist SVG with directives","suites":["compiler: hoistStatic transform","prefixIdentifiers"],"updatePoint":{"line":589,"column":46},"line":589,"code":"    test('should NOT hoist SVG with directives', () => {\n      const root = transformWithHoist(\n        `<div><svg v-foo><path d=\"M2,3H5.5L12\"/></svg></div>`\n      )\n      expect(root.hoists.length).toBe(2)\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should add no props to DOM","suites":["compiler: noop directive transform"],"updatePoint":{"line":11,"column":34},"line":11,"code":"  test('should add no props to DOM', () => {\n    const ast = parse(`<div v-noop/>`)\n    transform(ast, {\n      nodeTransforms: [transformElement],\n      directiveTransforms: {\n        noop: noopDirectiveTransform\n      }\n    })\n    const node = ast.children[0] as ElementNode\n    // As v-noop adds no properties the codegen should be identical to\n    // rendering a div with no props or reactive data (so just the tag as the arg)\n    expect((node.codegenNode as VNodeCall).props).toBeUndefined()\n  })","file":"transforms/noopDirectiveTransform.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"import + resolve component","suites":["compiler: element transform"],"updatePoint":{"line":78,"column":34},"line":78,"code":"  test('import + resolve component', () => {\n    const { root } = parseWithElementTransform(`<Foo/>`)\n    expect(root.helpers).toContain(RESOLVE_COMPONENT)\n    expect(root.components).toContain(`Foo`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve implicitly self-referencing component","suites":["compiler: element transform"],"updatePoint":{"line":84,"column":53},"line":84,"code":"  test('resolve implicitly self-referencing component', () => {\n    const { root } = parseWithElementTransform(`<Example/>`, {\n      filename: `/foo/bar/Example.vue?vue&type=template`\n    })\n    expect(root.helpers).toContain(RESOLVE_COMPONENT)\n    expect(root.components).toContain(`Example__self`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve component from setup bindings","suites":["compiler: element transform"],"updatePoint":{"line":92,"column":45},"line":92,"code":"  test('resolve component from setup bindings', () => {\n    const { root, node } = parseWithElementTransform(`<Example/>`, {\n      bindingMetadata: {\n        Example: BindingTypes.SETUP_MAYBE_REF\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`$setup[\"Example\"]`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve component from setup bindings (inline)","suites":["compiler: element transform"],"updatePoint":{"line":102,"column":54},"line":102,"code":"  test('resolve component from setup bindings (inline)', () => {\n    const { root, node } = parseWithElementTransform(`<Example/>`, {\n      inline: true,\n      bindingMetadata: {\n        Example: BindingTypes.SETUP_MAYBE_REF\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`_unref(Example)`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve component from setup bindings (inline const)","suites":["compiler: element transform"],"updatePoint":{"line":113,"column":60},"line":113,"code":"  test('resolve component from setup bindings (inline const)', () => {\n    const { root, node } = parseWithElementTransform(`<Example/>`, {\n      inline: true,\n      bindingMetadata: {\n        Example: BindingTypes.SETUP_CONST\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`Example`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve namespaced component from setup bindings","suites":["compiler: element transform"],"updatePoint":{"line":124,"column":56},"line":124,"code":"  test('resolve namespaced component from setup bindings', () => {\n    const { root, node } = parseWithElementTransform(`<Foo.Example/>`, {\n      bindingMetadata: {\n        Foo: BindingTypes.SETUP_MAYBE_REF\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`$setup[\"Foo\"].Example`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve namespaced component from setup bindings (inline)","suites":["compiler: element transform"],"updatePoint":{"line":134,"column":65},"line":134,"code":"  test('resolve namespaced component from setup bindings (inline)', () => {\n    const { root, node } = parseWithElementTransform(`<Foo.Example/>`, {\n      inline: true,\n      bindingMetadata: {\n        Foo: BindingTypes.SETUP_MAYBE_REF\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`_unref(Foo).Example`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"resolve namespaced component from setup bindings (inline const)","suites":["compiler: element transform"],"updatePoint":{"line":145,"column":71},"line":145,"code":"  test('resolve namespaced component from setup bindings (inline const)', () => {\n    const { root, node } = parseWithElementTransform(`<Foo.Example/>`, {\n      inline: true,\n      bindingMetadata: {\n        Foo: BindingTypes.SETUP_CONST\n      }\n    })\n    expect(root.helpers).not.toContain(RESOLVE_COMPONENT)\n    expect(node.tag).toBe(`Foo.Example`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"do not resolve component from non-script-setup bindings","suites":["compiler: element transform"],"updatePoint":{"line":156,"column":63},"line":156,"code":"  test('do not resolve component from non-script-setup bindings', () => {\n    const bindingMetadata = {\n      Example: BindingTypes.SETUP_MAYBE_REF\n    }\n    Object.defineProperty(bindingMetadata, '__isScriptSetup', { value: false })\n    const { root } = parseWithElementTransform(`<Example/>`, {\n      bindingMetadata\n    })\n    expect(root.helpers).toContain(RESOLVE_COMPONENT)\n    expect(root.components).toContain(`Example`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"static props","suites":["compiler: element transform"],"updatePoint":{"line":168,"column":20},"line":168,"code":"  test('static props', () => {\n    const { node } = parseWithElementTransform(`<div id=\"foo\" class=\"bar\" />`)\n    expect(node).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        id: 'foo',\n        class: 'bar'\n      }),\n      children: undefined\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"props + children","suites":["compiler: element transform"],"updatePoint":{"line":180,"column":24},"line":180,"code":"  test('props + children', () => {\n    const { node } = parseWithElementTransform(`<div id=\"foo\"><span/></div>`)\n\n    expect(node).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        id: 'foo'\n      }),\n      children: [\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'span',\n          codegenNode: {\n            type: NodeTypes.VNODE_CALL,\n            tag: `\"span\"`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"0 placeholder for children with no props","suites":["compiler: element transform"],"updatePoint":{"line":201,"column":48},"line":201,"code":"  test('0 placeholder for children with no props', () => {\n    const { node } = parseWithElementTransform(`<div><span/></div>`)\n\n    expect(node).toMatchObject({\n      tag: `\"div\"`,\n      props: undefined,\n      children: [\n        {\n          type: NodeTypes.ELEMENT,\n          tag: 'span',\n          codegenNode: {\n            type: NodeTypes.VNODE_CALL,\n            tag: `\"span\"`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind=\"obj\"","suites":["compiler: element transform"],"updatePoint":{"line":220,"column":20},"line":220,"code":"  test('v-bind=\"obj\"', () => {\n    const { root, node } = parseWithElementTransform(`<div v-bind=\"obj\" />`)\n    // single v-bind doesn't need mergeProps\n    expect(root.helpers).not.toContain(MERGE_PROPS)\n    expect(root.helpers).toContain(NORMALIZE_PROPS)\n    expect(root.helpers).toContain(GUARD_REACTIVE_PROPS)\n\n    // should directly use `obj` in props position\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: GUARD_REACTIVE_PROPS,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `obj`\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind=\"obj\" after static prop","suites":["compiler: element transform"],"updatePoint":{"line":246,"column":38},"line":246,"code":"  test('v-bind=\"obj\" after static prop', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div id=\"foo\" v-bind=\"obj\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        createObjectMatcher({\n          id: 'foo'\n        }),\n        {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `obj`\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind=\"obj\" before static prop","suites":["compiler: element transform"],"updatePoint":{"line":267,"column":39},"line":267,"code":"  test('v-bind=\"obj\" before static prop', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div v-bind=\"obj\" id=\"foo\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `obj`\n        },\n        createObjectMatcher({\n          id: 'foo'\n        })\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-bind=\"obj\" between static props","suites":["compiler: element transform"],"updatePoint":{"line":288,"column":41},"line":288,"code":"  test('v-bind=\"obj\" between static props', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div id=\"foo\" v-bind=\"obj\" class=\"bar\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        createObjectMatcher({\n          id: 'foo'\n        }),\n        {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `obj`\n        },\n        createObjectMatcher({\n          class: 'bar'\n        })\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on=\"obj\"","suites":["compiler: element transform"],"updatePoint":{"line":312,"column":18},"line":312,"code":"  test('v-on=\"obj\"', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div id=\"foo\" v-on=\"obj\" class=\"bar\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        createObjectMatcher({\n          id: 'foo'\n        }),\n        {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: TO_HANDLERS,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `obj`\n            },\n            `true`\n          ]\n        },\n        createObjectMatcher({\n          class: 'bar'\n        })\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on=\"obj\" on component","suites":["compiler: element transform"],"updatePoint":{"line":343,"column":31},"line":343,"code":"  test('v-on=\"obj\" on component', () => {\n    const { root, node } = parseWithElementTransform(\n      `<Foo id=\"foo\" v-on=\"obj\" class=\"bar\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        createObjectMatcher({\n          id: 'foo'\n        }),\n        {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: TO_HANDLERS,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `obj`\n            }\n          ]\n        },\n        createObjectMatcher({\n          class: 'bar'\n        })\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on=\"obj\" + v-bind=\"obj\"","suites":["compiler: element transform"],"updatePoint":{"line":373,"column":33},"line":373,"code":"  test('v-on=\"obj\" + v-bind=\"obj\"', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div id=\"foo\" v-on=\"handlers\" v-bind=\"obj\" />`\n    )\n    expect(root.helpers).toContain(MERGE_PROPS)\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: MERGE_PROPS,\n      arguments: [\n        createObjectMatcher({\n          id: 'foo'\n        }),\n        {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: TO_HANDLERS,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `handlers`\n            },\n            `true`\n          ]\n        },\n        {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `obj`\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle plain <template> as normal element","suites":["compiler: element transform"],"updatePoint":{"line":405,"column":56},"line":405,"code":"  test('should handle plain <template> as normal element', () => {\n    const { node } = parseWithElementTransform(`<template id=\"foo\" />`)\n\n    expect(node).toMatchObject({\n      tag: `\"template\"`,\n      props: createObjectMatcher({\n        id: 'foo'\n      })\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle <Teleport> with normal children","suites":["compiler: element transform"],"updatePoint":{"line":416,"column":53},"line":416,"code":"  test('should handle <Teleport> with normal children', () => {\n    function assert(tag: string) {\n      const { root, node } = parseWithElementTransform(\n        `<${tag} target=\"#foo\"><span /></${tag}>`\n      )\n      expect(root.components.length).toBe(0)\n      expect(root.helpers).toContain(TELEPORT)\n\n      expect(node).toMatchObject({\n        tag: TELEPORT,\n        props: createObjectMatcher({\n          target: '#foo'\n        }),\n        children: [\n          {\n            type: NodeTypes.ELEMENT,\n            tag: 'span',\n            codegenNode: {\n              type: NodeTypes.VNODE_CALL,\n              tag: `\"span\"`\n            }\n          }\n        ]\n      })\n    }\n\n    assert(`teleport`)\n    assert(`Teleport`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle <Suspense>","suites":["compiler: element transform"],"updatePoint":{"line":446,"column":32},"line":446,"code":"  test('should handle <Suspense>', () => {\n    function assert(tag: string, content: string, hasFallback?: boolean) {\n      const { root, node } = parseWithElementTransform(\n        `<${tag}>${content}</${tag}>`\n      )\n      expect(root.components.length).toBe(0)\n      expect(root.helpers).toContain(SUSPENSE)\n\n      expect(node).toMatchObject({\n        tag: SUSPENSE,\n        props: undefined,\n        children: hasFallback\n          ? createObjectMatcher({\n              default: {\n                type: NodeTypes.JS_FUNCTION_EXPRESSION\n              },\n              fallback: {\n                type: NodeTypes.JS_FUNCTION_EXPRESSION\n              },\n              _: `[1 /* STABLE */]`\n            })\n          : createObjectMatcher({\n              default: {\n                type: NodeTypes.JS_FUNCTION_EXPRESSION\n              },\n              _: `[1 /* STABLE */]`\n            })\n      })\n    }\n\n    assert(`suspense`, `foo`)\n    assert(`suspense`, `<template #default>foo</template>`)\n    assert(\n      `suspense`,\n      `<template #default>foo</template><template #fallback>fallback</template>`,\n      true\n    )\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle <KeepAlive>","suites":["compiler: element transform"],"updatePoint":{"line":485,"column":33},"line":485,"code":"  test('should handle <KeepAlive>', () => {\n    function assert(tag: string) {\n      const root = parse(`<div><${tag}><span /></${tag}></div>`)\n      transform(root, {\n        nodeTransforms: [transformElement, transformText]\n      })\n      expect(root.components.length).toBe(0)\n      expect(root.helpers).toContain(KEEP_ALIVE)\n      const node = (root.children[0] as any).children[0].codegenNode\n      expect(node).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        tag: KEEP_ALIVE,\n        isBlock: true, // should be forced into a block\n        props: undefined,\n        // keep-alive should not compile content to slots\n        children: [{ type: NodeTypes.ELEMENT, tag: 'span' }],\n        // should get a dynamic slots flag to force updates\n        patchFlag: genFlagText(PatchFlags.DYNAMIC_SLOTS)\n      })\n    }\n\n    assert(`keep-alive`)\n    assert(`KeepAlive`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle <BaseTransition>","suites":["compiler: element transform"],"updatePoint":{"line":510,"column":38},"line":510,"code":"  test('should handle <BaseTransition>', () => {\n    function assert(tag: string) {\n      const { root, node } = parseWithElementTransform(\n        `<${tag}><span /></${tag}>`\n      )\n      expect(root.components.length).toBe(0)\n      expect(root.helpers).toContain(BASE_TRANSITION)\n\n      expect(node).toMatchObject({\n        tag: BASE_TRANSITION,\n        props: undefined,\n        children: createObjectMatcher({\n          default: {\n            type: NodeTypes.JS_FUNCTION_EXPRESSION\n          },\n          _: `[1 /* STABLE */]`\n        })\n      })\n    }\n\n    assert(`base-transition`)\n    assert(`BaseTransition`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on v-bind with no argument","suites":["compiler: element transform"],"updatePoint":{"line":534,"column":40},"line":534,"code":"  test('error on v-bind with no argument', () => {\n    const onError = vi.fn()\n    parseWithElementTransform(`<div v-bind/>`, { onError })\n    expect(onError.mock.calls[0]).toMatchObject([\n      {\n        code: ErrorCodes.X_V_BIND_NO_EXPRESSION\n      }\n    ])\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directiveTransforms","suites":["compiler: element transform"],"updatePoint":{"line":544,"column":27},"line":544,"code":"  test('directiveTransforms', () => {\n    let _dir: DirectiveNode\n    const { node } = parseWithElementTransform(`<div v-foo:bar=\"hello\" />`, {\n      directiveTransforms: {\n        foo(dir) {\n          _dir = dir\n          return {\n            props: [createObjectProperty(dir.arg!, dir.exp!)]\n          }\n        }\n      }\n    })\n\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: _dir!.arg,\n          value: _dir!.exp\n        }\n      ]\n    })\n    // should factor in props returned by custom directive transforms\n    // in patchFlag analysis\n    expect(node.patchFlag).toMatch(PatchFlags.PROPS + '')\n    expect(node.dynamicProps).toMatch(`\"bar\"`)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directiveTransform with needRuntime: true","suites":["compiler: element transform"],"updatePoint":{"line":573,"column":49},"line":573,"code":"  test('directiveTransform with needRuntime: true', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div v-foo:bar=\"hello\" />`,\n      {\n        directiveTransforms: {\n          foo() {\n            return {\n              props: [],\n              needRuntime: true\n            }\n          }\n        }\n      }\n    )\n    expect(root.helpers).toContain(RESOLVE_DIRECTIVE)\n    expect(root.directives).toContain(`foo`)\n    expect(node).toMatchObject({\n      tag: `\"div\"`,\n      props: undefined,\n      children: undefined,\n      patchFlag: genFlagText(PatchFlags.NEED_PATCH), // should generate appropriate flag\n      directives: {\n        type: NodeTypes.JS_ARRAY_EXPRESSION,\n        elements: [\n          {\n            type: NodeTypes.JS_ARRAY_EXPRESSION,\n            elements: [\n              `_directive_foo`,\n              // exp\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `hello`,\n                isStatic: false\n              },\n              // arg\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `bar`,\n                isStatic: true\n              }\n            ]\n          }\n        ]\n      }\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directiveTransform with needRuntime: Symbol","suites":["compiler: element transform"],"updatePoint":{"line":620,"column":51},"line":620,"code":"  test('directiveTransform with needRuntime: Symbol', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div v-foo:bar=\"hello\" />`,\n      {\n        directiveTransforms: {\n          foo() {\n            return {\n              props: [],\n              needRuntime: CREATE_VNODE\n            }\n          }\n        }\n      }\n    )\n\n    expect(root.helpers).toContain(CREATE_VNODE)\n    expect(root.helpers).not.toContain(RESOLVE_DIRECTIVE)\n    expect(root.directives.length).toBe(0)\n    expect(node.directives!.elements[0].elements[0]).toBe(\n      `_${helperNameMap[CREATE_VNODE]}`\n    )\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"runtime directives","suites":["compiler: element transform"],"updatePoint":{"line":643,"column":26},"line":643,"code":"  test('runtime directives', () => {\n    const { root, node } = parseWithElementTransform(\n      `<div v-foo v-bar=\"x\" v-baz:[arg].mod.mad=\"y\" />`\n    )\n    expect(root.helpers).toContain(RESOLVE_DIRECTIVE)\n    expect(root.directives).toContain(`foo`)\n    expect(root.directives).toContain(`bar`)\n    expect(root.directives).toContain(`baz`)\n\n    expect(node).toMatchObject({\n      directives: {\n        type: NodeTypes.JS_ARRAY_EXPRESSION,\n        elements: [\n          {\n            type: NodeTypes.JS_ARRAY_EXPRESSION,\n            elements: [`_directive_foo`]\n          },\n          {\n            type: NodeTypes.JS_ARRAY_EXPRESSION,\n            elements: [\n              `_directive_bar`,\n              // exp\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `x`\n              }\n            ]\n          },\n          {\n            type: NodeTypes.JS_ARRAY_EXPRESSION,\n            elements: [\n              `_directive_baz`,\n              // exp\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `y`,\n                isStatic: false\n              },\n              // arg\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `arg`,\n                isStatic: false\n              },\n              // modifiers\n              {\n                type: NodeTypes.JS_OBJECT_EXPRESSION,\n                properties: [\n                  {\n                    type: NodeTypes.JS_PROPERTY,\n                    key: {\n                      type: NodeTypes.SIMPLE_EXPRESSION,\n                      content: `mod`,\n                      isStatic: true\n                    },\n                    value: {\n                      type: NodeTypes.SIMPLE_EXPRESSION,\n                      content: `true`,\n                      isStatic: false\n                    }\n                  },\n                  {\n                    type: NodeTypes.JS_PROPERTY,\n                    key: {\n                      type: NodeTypes.SIMPLE_EXPRESSION,\n                      content: `mad`,\n                      isStatic: true\n                    },\n                    value: {\n                      type: NodeTypes.SIMPLE_EXPRESSION,\n                      content: `true`,\n                      isStatic: false\n                    }\n                  }\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"props merging: event handlers","suites":["compiler: element transform"],"updatePoint":{"line":726,"column":37},"line":726,"code":"  test(`props merging: event handlers`, () => {\n    const { node } = parseWithElementTransform(\n      `<div @click.foo=\"a\" @click.bar=\"b\" />`,\n      {\n        directiveTransforms: {\n          on: transformOn\n        }\n      }\n    )\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `onClick`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.JS_ARRAY_EXPRESSION,\n            elements: [\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `a`,\n                isStatic: false\n              },\n              {\n                type: NodeTypes.SIMPLE_EXPRESSION,\n                content: `b`,\n                isStatic: false\n              }\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"props merging: style","suites":["compiler: element transform"],"updatePoint":{"line":765,"column":28},"line":765,"code":"  test(`props merging: style`, () => {\n    const { node, root } = parseWithElementTransform(\n      `<div style=\"color: green\" :style=\"{ color: 'red' }\" />`,\n      {\n        nodeTransforms: [transformStyle, transformElement],\n        directiveTransforms: {\n          bind: transformBind\n        }\n      }\n    )\n    expect(root.helpers).toContain(NORMALIZE_STYLE)\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `style`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: NORMALIZE_STYLE,\n            arguments: [\n              {\n                type: NodeTypes.JS_ARRAY_EXPRESSION,\n                elements: [\n                  {\n                    type: NodeTypes.SIMPLE_EXPRESSION,\n                    content: `{\"color\":\"green\"}`,\n                    isStatic: false\n                  },\n                  {\n                    type: NodeTypes.SIMPLE_EXPRESSION,\n                    content: `{ color: 'red' }`,\n                    isStatic: false\n                  }\n                ]\n              }\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"props merging: style w/ transformExpression","suites":["compiler: element transform"],"updatePoint":{"line":812,"column":51},"line":812,"code":"  test(`props merging: style w/ transformExpression`, () => {\n    const { node, root } = parseWithElementTransform(\n      `<div style=\"color: green\" :style=\"{ color: 'red' }\" />`,\n      {\n        nodeTransforms: [transformExpression, transformStyle, transformElement],\n        directiveTransforms: {\n          bind: transformBind\n        },\n        prefixIdentifiers: true\n      }\n    )\n    expect(root.helpers).toContain(NORMALIZE_STYLE)\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `style`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: NORMALIZE_STYLE\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":":style with array literal","suites":["compiler: element transform"],"updatePoint":{"line":843,"column":33},"line":843,"code":"  test(':style with array literal', () => {\n    const { node, root } = parseWithElementTransform(\n      `<div :style=\"[{ color: 'red' }]\" />`,\n      {\n        nodeTransforms: [transformExpression, transformStyle, transformElement],\n        directiveTransforms: {\n          bind: transformBind\n        },\n        prefixIdentifiers: true\n      }\n    )\n    expect(root.helpers).toContain(NORMALIZE_STYLE)\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `style`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: NORMALIZE_STYLE\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"props merging: class","suites":["compiler: element transform"],"updatePoint":{"line":874,"column":28},"line":874,"code":"  test(`props merging: class`, () => {\n    const { node, root } = parseWithElementTransform(\n      `<div class=\"foo\" :class=\"{ bar: isBar }\" />`,\n      {\n        directiveTransforms: {\n          bind: transformBind\n        }\n      }\n    )\n    expect(root.helpers).toContain(NORMALIZE_CLASS)\n    expect(node.props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          type: NodeTypes.JS_PROPERTY,\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `class`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: NORMALIZE_CLASS,\n            arguments: [\n              {\n                type: NodeTypes.JS_ARRAY_EXPRESSION,\n                elements: [\n                  {\n                    type: NodeTypes.SIMPLE_EXPRESSION,\n                    content: `foo`,\n                    isStatic: true\n                  },\n                  {\n                    type: NodeTypes.SIMPLE_EXPRESSION,\n                    content: `{ bar: isBar }`,\n                    isStatic: false\n                  }\n                ]\n              }\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"TEXT","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":921,"column":14},"line":921,"code":"    test('TEXT', () => {\n      const { node } = parseWithBind(`<div>foo</div>`)\n      expect(node.patchFlag).toBeUndefined()\n\n      const { node: node2 } = parseWithBind(`<div>{{ foo }}</div>`)\n      expect(node2.patchFlag).toBe(genFlagText(PatchFlags.TEXT))\n\n      // multiple nodes, merged with optimize text\n      const { node: node3 } = parseWithBind(`<div>foo {{ bar }} baz</div>`)\n      expect(node3.patchFlag).toBe(genFlagText(PatchFlags.TEXT))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"CLASS","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":933,"column":15},"line":933,"code":"    test('CLASS', () => {\n      const { node } = parseWithBind(`<div :class=\"foo\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.CLASS))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"STYLE","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":938,"column":15},"line":938,"code":"    test('STYLE', () => {\n      const { node } = parseWithBind(`<div :style=\"foo\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.STYLE))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"PROPS","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":943,"column":15},"line":943,"code":"    test('PROPS', () => {\n      const { node } = parseWithBind(`<div id=\"foo\" :foo=\"bar\" :baz=\"qux\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.PROPS))\n      expect(node.dynamicProps).toBe(`[\"foo\", \"baz\"]`)\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"CLASS + STYLE + PROPS","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":949,"column":31},"line":949,"code":"    test('CLASS + STYLE + PROPS', () => {\n      const { node } = parseWithBind(\n        `<div id=\"foo\" :class=\"cls\" :style=\"styl\" :foo=\"bar\" :baz=\"qux\"/>`\n      )\n      expect(node.patchFlag).toBe(\n        genFlagText([PatchFlags.CLASS, PatchFlags.STYLE, PatchFlags.PROPS])\n      )\n      expect(node.dynamicProps).toBe(`[\"foo\", \"baz\"]`)\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"PROPS on component","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":960,"column":28},"line":960,"code":"    test('PROPS on component', () => {\n      const { node } = parseWithBind(\n        `<Foo :id=\"foo\" :class=\"cls\" :style=\"styl\" />`\n      )\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.PROPS))\n      expect(node.dynamicProps).toBe(`[\"id\", \"class\", \"style\"]`)\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"FULL_PROPS (v-bind)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":968,"column":29},"line":968,"code":"    test('FULL_PROPS (v-bind)', () => {\n      const { node } = parseWithBind(`<div v-bind=\"foo\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.FULL_PROPS))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"FULL_PROPS (dynamic key)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":973,"column":34},"line":973,"code":"    test('FULL_PROPS (dynamic key)', () => {\n      const { node } = parseWithBind(`<div :[foo]=\"bar\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.FULL_PROPS))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"FULL_PROPS (w/ others)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":978,"column":32},"line":978,"code":"    test('FULL_PROPS (w/ others)', () => {\n      const { node } = parseWithBind(\n        `<div id=\"foo\" v-bind=\"bar\" :class=\"cls\" />`\n      )\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.FULL_PROPS))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"NEED_PATCH (static ref)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":985,"column":33},"line":985,"code":"    test('NEED_PATCH (static ref)', () => {\n      const { node } = parseWithBind(`<div ref=\"foo\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.NEED_PATCH))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"NEED_PATCH (dynamic ref)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":990,"column":34},"line":990,"code":"    test('NEED_PATCH (dynamic ref)', () => {\n      const { node } = parseWithBind(`<div :ref=\"foo\" />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.NEED_PATCH))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"NEED_PATCH (custom directives)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":995,"column":40},"line":995,"code":"    test('NEED_PATCH (custom directives)', () => {\n      const { node } = parseWithBind(`<div v-foo />`)\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.NEED_PATCH))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"NEED_PATCH (vnode hooks)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1000,"column":34},"line":1000,"code":"    test('NEED_PATCH (vnode hooks)', () => {\n      const root = baseCompile(`<div @vue:updated=\"foo\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      }).ast\n      const node = (root as any).children[0].codegenNode\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.NEED_PATCH))\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"script setup inline mode template ref (binding exists)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1009,"column":64},"line":1009,"code":"    test('script setup inline mode template ref (binding exists)', () => {\n      const { node } = parseWithElementTransform(`<input ref=\"input\"/>`, {\n        inline: true,\n        bindingMetadata: {\n          input: BindingTypes.SETUP_REF\n        }\n      })\n      expect(node.props).toMatchObject({\n        type: NodeTypes.JS_OBJECT_EXPRESSION,\n        properties: [\n          {\n            type: NodeTypes.JS_PROPERTY,\n            key: {\n              content: 'ref_key',\n              isStatic: true\n            },\n            value: {\n              content: 'input',\n              isStatic: true\n            }\n          },\n          {\n            type: NodeTypes.JS_PROPERTY,\n            key: {\n              content: 'ref',\n              isStatic: true\n            },\n            value: {\n              content: 'input',\n              isStatic: false\n            }\n          }\n        ]\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"script setup inline mode template ref (binding does not exist)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1045,"column":72},"line":1045,"code":"    test('script setup inline mode template ref (binding does not exist)', () => {\n      const { node } = parseWithElementTransform(`<input ref=\"input\"/>`, {\n        inline: true\n      })\n      expect(node.props).toMatchObject({\n        type: NodeTypes.JS_OBJECT_EXPRESSION,\n        properties: [\n          {\n            type: NodeTypes.JS_PROPERTY,\n            key: {\n              content: 'ref',\n              isStatic: true\n            },\n            value: {\n              content: 'input',\n              isStatic: true\n            }\n          }\n        ]\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"script setup inline mode template ref (binding does not exist but props with the same name exist)","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1067,"column":107},"line":1067,"code":"    test('script setup inline mode template ref (binding does not exist but props with the same name exist)', () => {\n      const { node } = parseWithElementTransform(`<input ref=\"msg\"/>`, {\n        inline: true,\n        bindingMetadata: {\n          msg: BindingTypes.PROPS,\n          ref: BindingTypes.SETUP_CONST\n        }\n      })\n      expect(node.props).toMatchObject({\n        type: NodeTypes.JS_OBJECT_EXPRESSION,\n        properties: [\n          {\n            type: NodeTypes.JS_PROPERTY,\n            key: {\n              content: 'ref',\n              isStatic: true\n            },\n            value: {\n              content: 'msg',\n              isStatic: true\n            }\n          }\n        ]\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"HYDRATE_EVENTS","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1093,"column":24},"line":1093,"code":"    test('HYDRATE_EVENTS', () => {\n      // ignore click events (has dedicated fast path)\n      const { node } = parseWithElementTransform(`<div @click=\"foo\" />`, {\n        directiveTransforms: {\n          on: transformOn\n        }\n      })\n      // should only have props flag\n      expect(node.patchFlag).toBe(genFlagText(PatchFlags.PROPS))\n\n      const { node: node2 } = parseWithElementTransform(\n        `<div @keyup=\"foo\" />`,\n        {\n          directiveTransforms: {\n            on: transformOn\n          }\n        }\n      )\n      expect(node2.patchFlag).toBe(\n        genFlagText([PatchFlags.PROPS, PatchFlags.HYDRATE_EVENTS])\n      )\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"HYDRATE_EVENTS on dynamic component","suites":["compiler: element transform","patchFlag analysis"],"updatePoint":{"line":1117,"column":45},"line":1117,"code":"    test('HYDRATE_EVENTS on dynamic component', () => {\n      const { node } = parseWithElementTransform(\n        `<component :is=\"foo\" @input=\"foo\" />`,\n        {\n          directiveTransforms: {\n            on: transformOn\n          }\n        }\n      )\n      expect(node.patchFlag).toBe(\n        genFlagText([PatchFlags.PROPS, PatchFlags.HYDRATE_EVENTS])\n      )\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"static binding","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1133,"column":24},"line":1133,"code":"    test('static binding', () => {\n      const { node, root } = parseWithBind(`<component is=\"foo\" />`)\n      expect(root.helpers).toContain(RESOLVE_DYNAMIC_COMPONENT)\n      expect(node).toMatchObject({\n        isBlock: true,\n        tag: {\n          callee: RESOLVE_DYNAMIC_COMPONENT,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'foo',\n              isStatic: true\n            }\n          ]\n        }\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"capitalized version w/ static binding","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1151,"column":47},"line":1151,"code":"    test('capitalized version w/ static binding', () => {\n      const { node, root } = parseWithBind(`<Component is=\"foo\" />`)\n      expect(root.helpers).toContain(RESOLVE_DYNAMIC_COMPONENT)\n      expect(node).toMatchObject({\n        isBlock: true,\n        tag: {\n          callee: RESOLVE_DYNAMIC_COMPONENT,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'foo',\n              isStatic: true\n            }\n          ]\n        }\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic binding","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1169,"column":25},"line":1169,"code":"    test('dynamic binding', () => {\n      const { node, root } = parseWithBind(`<component :is=\"foo\" />`)\n      expect(root.helpers).toContain(RESOLVE_DYNAMIC_COMPONENT)\n      expect(node).toMatchObject({\n        isBlock: true,\n        tag: {\n          callee: RESOLVE_DYNAMIC_COMPONENT,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'foo',\n              isStatic: false\n            }\n          ]\n        }\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-is","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1188,"column":14},"line":1188,"code":"    test('v-is', () => {\n      const { node, root } = parseWithBind(`<div v-is=\"'foo'\" />`)\n      expect(root.helpers).toContain(RESOLVE_DYNAMIC_COMPONENT)\n      expect(node).toMatchObject({\n        tag: {\n          callee: RESOLVE_DYNAMIC_COMPONENT,\n          arguments: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `'foo'`,\n              isStatic: false\n            }\n          ]\n        },\n        // should skip v-is runtime check\n        directives: undefined\n      })\n      expect('v-is=\"component-name\" has been deprecated').toHaveBeenWarned()\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"normal component with is prop","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1209,"column":39},"line":1209,"code":"    test('normal component with is prop', () => {\n      const { node, root } = parseWithBind(`<custom-input is=\"foo\" />`, {\n        isNativeTag: () => false\n      })\n      expect(root.helpers).toContain(RESOLVE_COMPONENT)\n      expect(root.helpers).not.toContain(RESOLVE_DYNAMIC_COMPONENT)\n      expect(node).toMatchObject({\n        tag: '_component_custom_input'\n      })\n    })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<svg> should be forced into blocks","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1221,"column":42},"line":1221,"code":"  test('<svg> should be forced into blocks', () => {\n    const ast = parse(`<div><svg/></div>`)\n    transform(ast, {\n      nodeTransforms: [transformElement]\n    })\n    expect((ast as any).children[0].children[0].codegenNode).toMatchObject({\n      type: NodeTypes.VNODE_CALL,\n      tag: `\"svg\"`,\n      isBlock: true\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"force block for runtime custom directive w/ children","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1233,"column":60},"line":1233,"code":"  test('force block for runtime custom directive w/ children', () => {\n    const { node } = parseWithElementTransform(`<div v-foo>hello</div>`)\n    expect(node.isBlock).toBe(true)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"force block for inline before-update handlers w/ children","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1238,"column":65},"line":1238,"code":"  test('force block for inline before-update handlers w/ children', () => {\n    expect(\n      parseWithElementTransform(`<div @vue:before-update>hello</div>`).node\n        .isBlock\n    ).toBe(true)\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"element with dynamic keys should be forced into blocks","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1246,"column":62},"line":1246,"code":"  test('element with dynamic keys should be forced into blocks', () => {\n    const ast = parse(`<div><div :key=\"foo\" /></div>`)\n    transform(ast, {\n      nodeTransforms: [transformElement]\n    })\n    expect((ast as any).children[0].children[0].codegenNode).toMatchObject({\n      type: NodeTypes.VNODE_CALL,\n      tag: `\"div\"`,\n      isBlock: true\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should process node when node has been replaced","suites":["compiler: element transform","dynamic component"],"updatePoint":{"line":1258,"column":55},"line":1258,"code":"  test('should process node when node has been replaced', () => {\n    // a NodeTransform that swaps out <div id=\"foo\" /> with <span id=\"foo\" />\n    const customNodeTransform: NodeTransform = (node, context) => {\n      if (\n        node.type === NodeTypes.ELEMENT &&\n        node.tag === 'div' &&\n        node.props.some(\n          prop =>\n            prop.type === NodeTypes.ATTRIBUTE &&\n            prop.name === 'id' &&\n            prop.value &&\n            prop.value.content === 'foo'\n        )\n      ) {\n        context.replaceNode({\n          ...node,\n          tag: 'span'\n        })\n      }\n    }\n    const ast = parse(`<div><div id=\"foo\" /></div>`)\n    transform(ast, {\n      nodeTransforms: [transformElement, transformText, customNodeTransform]\n    })\n    expect((ast as any).children[0].children[0].codegenNode).toMatchObject({\n      type: NodeTypes.VNODE_CALL,\n      tag: '\"span\"',\n      isBlock: false\n    })\n  })","file":"transforms/transformElement.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"interpolation (root)","suites":["compiler: expression transform"],"updatePoint":{"line":32,"column":28},"line":32,"code":"  test('interpolation (root)', () => {\n    const node = parseWithExpressionTransform(`{{ foo }}`) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `_ctx.foo`\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty interpolation","suites":["compiler: expression transform"],"updatePoint":{"line":40,"column":27},"line":40,"code":"  test('empty interpolation', () => {\n    const node = parseWithExpressionTransform(`{{}}`) as InterpolationNode\n    const node2 = parseWithExpressionTransform(`{{ }}`) as InterpolationNode\n    const node3 = parseWithExpressionTransform(\n      `<div>{{ }}</div>`\n    ) as ElementNode\n\n    const objectToBeMatched = {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: ``\n    }\n    expect(node.content).toMatchObject(objectToBeMatched)\n    expect(node2.content).toMatchObject(objectToBeMatched)\n    expect((node3.children[0] as InterpolationNode).content).toMatchObject(\n      objectToBeMatched\n    )\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"interpolation (children)","suites":["compiler: expression transform"],"updatePoint":{"line":58,"column":32},"line":58,"code":"  test('interpolation (children)', () => {\n    const el = parseWithExpressionTransform(\n      `<div>{{ foo }}</div>`\n    ) as ElementNode\n    const node = el.children[0] as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `_ctx.foo`\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"interpolation (complex)","suites":["compiler: expression transform"],"updatePoint":{"line":69,"column":31},"line":69,"code":"  test('interpolation (complex)', () => {\n    const el = parseWithExpressionTransform(\n      `<div>{{ foo + bar(baz.qux) }}</div>`\n    ) as ElementNode\n    const node = el.children[0] as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { content: `_ctx.foo` },\n        ` + `,\n        { content: `_ctx.bar` },\n        `(`,\n        { content: `_ctx.baz` },\n        `.`,\n        { content: `qux` },\n        `)`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"directive value","suites":["compiler: expression transform"],"updatePoint":{"line":89,"column":23},"line":89,"code":"  test('directive value', () => {\n    const node = parseWithExpressionTransform(\n      `<div v-foo:arg=\"baz\"/>`\n    ) as ElementNode\n    const arg = (node.props[0] as DirectiveNode).arg!\n    expect(arg).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `arg`\n    })\n    const exp = (node.props[0] as DirectiveNode).exp!\n    expect(exp).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `_ctx.baz`\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic directive arg","suites":["compiler: expression transform"],"updatePoint":{"line":105,"column":29},"line":105,"code":"  test('dynamic directive arg', () => {\n    const node = parseWithExpressionTransform(\n      `<div v-foo:[arg]=\"baz\"/>`\n    ) as ElementNode\n    const arg = (node.props[0] as DirectiveNode).arg!\n    expect(arg).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `_ctx.arg`\n    })\n    const exp = (node.props[0] as DirectiveNode).exp!\n    expect(exp).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `_ctx.baz`\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix complex expressions","suites":["compiler: expression transform"],"updatePoint":{"line":121,"column":41},"line":121,"code":"  test('should prefix complex expressions', () => {\n    const node = parseWithExpressionTransform(\n      `{{ foo(baz + 1, { key: kuz }) }}`\n    ) as InterpolationNode\n    // should parse into compound expression\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        {\n          content: `_ctx.foo`,\n          loc: {\n            source: `foo`,\n            start: {\n              offset: 3,\n              line: 1,\n              column: 4\n            },\n            end: {\n              offset: 6,\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        `(`,\n        {\n          content: `_ctx.baz`,\n          loc: {\n            source: `baz`,\n            start: {\n              offset: 7,\n              line: 1,\n              column: 8\n            },\n            end: {\n              offset: 10,\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        ` + 1, { key: `,\n        {\n          content: `_ctx.kuz`,\n          loc: {\n            source: `kuz`,\n            start: {\n              offset: 23,\n              line: 1,\n              column: 24\n            },\n            end: {\n              offset: 26,\n              line: 1,\n              column: 27\n            }\n          }\n        },\n        ` })`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix whitelisted globals","suites":["compiler: expression transform"],"updatePoint":{"line":184,"column":45},"line":184,"code":"  test('should not prefix whitelisted globals', () => {\n    const node = parseWithExpressionTransform(\n      `{{ Math.max(1, 2) }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [{ content: `Math` }, `.`, { content: `max` }, `(1, 2)`]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix reserved literals","suites":["compiler: expression transform"],"updatePoint":{"line":194,"column":43},"line":194,"code":"  test('should not prefix reserved literals', () => {\n    function assert(exp: string) {\n      const node = parseWithExpressionTransform(\n        `{{ ${exp} }}`\n      ) as InterpolationNode\n      expect(node.content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: exp\n      })\n    }\n    assert(`true`)\n    assert(`false`)\n    assert(`null`)\n    assert(`this`)\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix id of a function declaration","suites":["compiler: expression transform"],"updatePoint":{"line":210,"column":54},"line":210,"code":"  test('should not prefix id of a function declaration', () => {\n    const node = parseWithExpressionTransform(\n      `{{ function foo() { return bar } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `function `,\n        { content: `foo` },\n        `() { return `,\n        { content: `_ctx.bar` },\n        ` }`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix params of a function expression","suites":["compiler: expression transform"],"updatePoint":{"line":226,"column":57},"line":226,"code":"  test('should not prefix params of a function expression', () => {\n    const node = parseWithExpressionTransform(\n      `{{ foo => foo + bar }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { content: `foo` },\n        ` => `,\n        { content: `foo` },\n        ` + `,\n        { content: `_ctx.bar` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix default value of a function expression param","suites":["compiler: expression transform"],"updatePoint":{"line":242,"column":66},"line":242,"code":"  test('should prefix default value of a function expression param', () => {\n    const node = parseWithExpressionTransform(\n      `{{ (foo = baz) => foo + bar }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `(`,\n        { content: `foo` },\n        ` = `,\n        { content: `_ctx.baz` },\n        `) => `,\n        { content: `foo` },\n        ` + `,\n        { content: `_ctx.bar` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix function param destructuring","suites":["compiler: expression transform"],"updatePoint":{"line":261,"column":54},"line":261,"code":"  test('should not prefix function param destructuring', () => {\n    const node = parseWithExpressionTransform(\n      `{{ ({ foo }) => foo + bar }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `({ `,\n        { content: `foo` },\n        ` }) => `,\n        { content: `foo` },\n        ` + `,\n        { content: `_ctx.bar` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function params should not affect out of scope identifiers","suites":["compiler: expression transform"],"updatePoint":{"line":278,"column":66},"line":278,"code":"  test('function params should not affect out of scope identifiers', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { a: foo => foo, b: foo } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `{ a: `,\n        { content: `foo` },\n        ` => `,\n        { content: `foo` },\n        `, b: `,\n        { content: `_ctx.foo` },\n        ` }`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix default value of function param destructuring","suites":["compiler: expression transform"],"updatePoint":{"line":296,"column":67},"line":296,"code":"  test('should prefix default value of function param destructuring', () => {\n    const node = parseWithExpressionTransform(\n      `{{ ({ foo = bar }) => foo + bar }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `({ `,\n        { content: `foo` },\n        ` = `,\n        { content: `_ctx.bar` },\n        ` }) => `,\n        { content: `foo` },\n        ` + `,\n        { content: `_ctx.bar` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix an object property key","suites":["compiler: expression transform"],"updatePoint":{"line":314,"column":48},"line":314,"code":"  test('should not prefix an object property key', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { foo() { baz() }, value: bar } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `{ foo() { `,\n        { content: `_ctx.baz` },\n        `() }, value: `,\n        { content: `_ctx.bar` },\n        ` }`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not duplicate object key with same name as value","suites":["compiler: expression transform"],"updatePoint":{"line":330,"column":63},"line":330,"code":"  test('should not duplicate object key with same name as value', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { foo: foo } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [`{ foo: `, { content: `_ctx.foo` }, ` }`]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix a computed object property key","suites":["compiler: expression transform"],"updatePoint":{"line":340,"column":52},"line":340,"code":"  test('should prefix a computed object property key', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { [foo]: bar } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `{ [`,\n        { content: `_ctx.foo` },\n        `]: `,\n        { content: `_ctx.bar` },\n        ` }`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix object property shorthand value","suites":["compiler: expression transform"],"updatePoint":{"line":356,"column":53},"line":356,"code":"  test('should prefix object property shorthand value', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { foo } }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [`{ foo: `, { content: `_ctx.foo` }, ` }`]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix id in a member expression","suites":["compiler: expression transform"],"updatePoint":{"line":366,"column":51},"line":366,"code":"  test('should not prefix id in a member expression', () => {\n    const node = parseWithExpressionTransform(\n      `{{ foo.bar.baz }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { content: `_ctx.foo` },\n        `.`,\n        { content: `bar` },\n        `.`,\n        { content: `baz` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix computed id in a member expression","suites":["compiler: expression transform"],"updatePoint":{"line":382,"column":56},"line":382,"code":"  test('should prefix computed id in a member expression', () => {\n    const node = parseWithExpressionTransform(\n      `{{ foo[bar][baz] }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { content: `_ctx.foo` },\n        `[`,\n        { content: `_ctx.bar` },\n        `][`,\n        { content: '_ctx.baz' },\n        `]`\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle parse error","suites":["compiler: expression transform"],"updatePoint":{"line":399,"column":33},"line":399,"code":"  test('should handle parse error', () => {\n    const onError = vi.fn()\n    parseWithExpressionTransform(`{{ a( }}`, { onError })\n    expect(onError.mock.calls[0][0].message).toMatch(\n      `Error parsing JavaScript expression: Unexpected token`\n    )\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix in assignment","suites":["compiler: expression transform"],"updatePoint":{"line":407,"column":35},"line":407,"code":"  test('should prefix in assignment', () => {\n    const node = parseWithExpressionTransform(\n      `{{ x = 1 }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [{ content: `_ctx.x` }, ` = 1`]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix in assignment pattern","suites":["compiler: expression transform"],"updatePoint":{"line":417,"column":43},"line":417,"code":"  test('should prefix in assignment pattern', () => {\n    const node = parseWithExpressionTransform(\n      `{{ { x, y: [z] } = obj }}`\n    ) as InterpolationNode\n    expect(node.content).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `{ x: `,\n        { content: `_ctx.x` },\n        `, y: [`,\n        { content: `_ctx.z` },\n        `] } = `,\n        { content: `_ctx.obj` }\n      ]\n    })\n  })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"bigInt","suites":["compiler: expression transform","ES Proposals support"],"updatePoint":{"line":435,"column":16},"line":435,"code":"    test('bigInt', () => {\n      const node = parseWithExpressionTransform(\n        `{{ 13000n }}`\n      ) as InterpolationNode\n      expect(node.content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `13000n`,\n        isStatic: false,\n        constType: ConstantTypes.CAN_STRINGIFY\n      })\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"nullish coalescing","suites":["compiler: expression transform","ES Proposals support"],"updatePoint":{"line":447,"column":28},"line":447,"code":"    test('nullish coalescing', () => {\n      const node = parseWithExpressionTransform(\n        `{{ a ?? b }}`\n      ) as InterpolationNode\n      expect(node.content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [{ content: `_ctx.a` }, ` ?? `, { content: `_ctx.b` }]\n      })\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"optional chaining","suites":["compiler: expression transform","ES Proposals support"],"updatePoint":{"line":457,"column":27},"line":457,"code":"    test('optional chaining', () => {\n      const node = parseWithExpressionTransform(\n        `{{ a?.b?.c }}`\n      ) as InterpolationNode\n      expect(node.content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [\n          { content: `_ctx.a` },\n          `?.`,\n          { content: `b` },\n          `?.`,\n          { content: `c` }\n        ]\n      })\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"Enabling additional plugins","suites":["compiler: expression transform","ES Proposals support"],"updatePoint":{"line":473,"column":37},"line":473,"code":"    test('Enabling additional plugins', () => {\n      // enabling pipeline operator to replace filters:\n      const node = parseWithExpressionTransform(`{{ a |> uppercase }}`, {\n        expressionPlugins: [\n          [\n            'pipelineOperator',\n            {\n              proposal: 'minimal'\n            }\n          ]\n        ]\n      }) as InterpolationNode\n      expect(node.content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [{ content: `_ctx.a` }, ` |> `, { content: `_ctx.uppercase` }]\n      })\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"non-inline mode","suites":["compiler: expression transform","bindingMetadata"],"updatePoint":{"line":514,"column":25},"line":514,"code":"    test('non-inline mode', () => {\n      const { code } = compileWithBindingMetadata(\n        `<div>{{ props }} {{ setup }} {{ data }} {{ options }}</div>`\n      )\n      expect(code).toMatch(`$props.props`)\n      expect(code).toMatch(`$setup.setup`)\n      expect(code).toMatch(`$data.data`)\n      expect(code).toMatch(`$options.options`)\n      expect(code).toMatch(`_ctx, _cache, $props, $setup, $data, $options`)\n      expect(code).toMatchSnapshot()\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline mode","suites":["compiler: expression transform","bindingMetadata"],"updatePoint":{"line":526,"column":21},"line":526,"code":"    test('inline mode', () => {\n      const { code } = compileWithBindingMetadata(\n        `<div>{{ props }} {{ setup }} {{ setupConst }} {{ data }} {{ options }}</div>`,\n        { inline: true }\n      )\n      expect(code).toMatch(`__props.props`)\n      expect(code).toMatch(`_unref(setup)`)\n      expect(code).toMatch(`_toDisplayString(setupConst)`)\n      expect(code).toMatch(`_ctx.data`)\n      expect(code).toMatch(`_ctx.options`)\n      expect(code).toMatchSnapshot()\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"literal const handling","suites":["compiler: expression transform","bindingMetadata"],"updatePoint":{"line":539,"column":32},"line":539,"code":"    test('literal const handling', () => {\n      const { code } = compileWithBindingMetadata(`<div>{{ literal }}</div>`, {\n        inline: true\n      })\n      expect(code).toMatch(`toDisplayString(literal)`)\n      // #7973 should skip patch for literal const\n      expect(code).not.toMatch(\n        `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n      )\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"literal const handling non-inline mode","suites":["compiler: expression transform","bindingMetadata"],"updatePoint":{"line":550,"column":49},"line":550,"code":"    test('literal const handling non-inline mode', () => {\n      const { code } = compileWithBindingMetadata(`<div>{{ literal }}</div>`)\n      expect(code).toMatch(`toDisplayString($setup.literal)`)\n      // #7973 should skip patch for literal const\n      expect(code).not.toMatch(\n        `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n      )\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"reactive const handling","suites":["compiler: expression transform","bindingMetadata"],"updatePoint":{"line":559,"column":33},"line":559,"code":"    test('reactive const handling', () => {\n      const { code } = compileWithBindingMetadata(`<div>{{ reactive }}</div>`, {\n        inline: true\n      })\n      // #7973 should not skip patch for reactive const\n      expect(code).toMatch(\n        `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n      )\n    })","file":"transforms/transformExpressions.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"default slot outlet","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":35,"column":27},"line":35,"code":"  test('default slot outlet', () => {\n    const ast = parseWithSlots(`<slot/>`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [`$slots`, `\"default\"`]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"statically named slot outlet","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":44,"column":36},"line":44,"code":"  test('statically named slot outlet', () => {\n    const ast = parseWithSlots(`<slot name=\"foo\" />`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [`$slots`, `\"foo\"`]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamically named slot outlet","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":53,"column":37},"line":53,"code":"  test('dynamically named slot outlet', () => {\n    const ast = parseWithSlots(`<slot :name=\"foo\" />`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `foo`,\n          isStatic: false\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamically named slot outlet w/ prefixIdentifiers: true","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":69,"column":64},"line":69,"code":"  test('dynamically named slot outlet w/ prefixIdentifiers: true', () => {\n    const ast = parseWithSlots(`<slot :name=\"foo + bar\" />`, {\n      prefixIdentifiers: true\n    })\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `_ctx.$slots`,\n        {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `_ctx.foo`,\n              isStatic: false\n            },\n            ` + `,\n            {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `_ctx.bar`,\n              isStatic: false\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"default slot outlet with props","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":98,"column":38},"line":98,"code":"  test('default slot outlet with props', () => {\n    const ast = parseWithSlots(\n      `<slot foo=\"bar\" :baz=\"qux\" :foo-bar=\"foo-bar\" />`\n    )\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"default\"`,\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `foo`,\n                isStatic: true\n              },\n              value: {\n                content: `bar`,\n                isStatic: true\n              }\n            },\n            {\n              key: {\n                content: `baz`,\n                isStatic: true\n              },\n              value: {\n                content: `qux`,\n                isStatic: false\n              }\n            },\n            {\n              key: {\n                content: `fooBar`,\n                isStatic: true\n              },\n              value: {\n                content: `foo-bar`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"statically named slot outlet with props","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":147,"column":47},"line":147,"code":"  test('statically named slot outlet with props', () => {\n    const ast = parseWithSlots(`<slot name=\"foo\" foo=\"bar\" :baz=\"qux\" />`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"foo\"`,\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          // props should not include name\n          properties: [\n            {\n              key: {\n                content: `foo`,\n                isStatic: true\n              },\n              value: {\n                content: `bar`,\n                isStatic: true\n              }\n            },\n            {\n              key: {\n                content: `baz`,\n                isStatic: true\n              },\n              value: {\n                content: `qux`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamically named slot outlet with props","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":185,"column":48},"line":185,"code":"  test('dynamically named slot outlet with props', () => {\n    const ast = parseWithSlots(`<slot :name=\"foo\" foo=\"bar\" :baz=\"qux\" />`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        { content: `foo`, isStatic: false },\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          // props should not include name\n          properties: [\n            {\n              key: {\n                content: `foo`,\n                isStatic: true\n              },\n              value: {\n                content: `bar`,\n                isStatic: true\n              }\n            },\n            {\n              key: {\n                content: `baz`,\n                isStatic: true\n              },\n              value: {\n                content: `qux`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"default slot outlet with fallback","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":223,"column":41},"line":223,"code":"  test('default slot outlet with fallback', () => {\n    const ast = parseWithSlots(`<slot><div/></slot>`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"default\"`,\n        `{}`,\n        {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: [],\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `div`\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot outlet with fallback","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":246,"column":39},"line":246,"code":"  test('named slot outlet with fallback', () => {\n    const ast = parseWithSlots(`<slot name=\"foo\"><div/></slot>`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"foo\"`,\n        `{}`,\n        {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: [],\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `div`\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"default slot outlet with props & fallback","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":269,"column":49},"line":269,"code":"  test('default slot outlet with props & fallback', () => {\n    const ast = parseWithSlots(`<slot :foo=\"bar\"><div/></slot>`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"default\"`,\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `foo`,\n                isStatic: true\n              },\n              value: {\n                content: `bar`,\n                isStatic: false\n              }\n            }\n          ]\n        },\n        {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: [],\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `div`\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot outlet with props & fallback","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":306,"column":47},"line":306,"code":"  test('named slot outlet with props & fallback', () => {\n    const ast = parseWithSlots(`<slot name=\"foo\" :foo=\"bar\"><div/></slot>`)\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [\n        `$slots`,\n        `\"foo\"`,\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `foo`,\n                isStatic: true\n              },\n              value: {\n                content: `bar`,\n                isStatic: false\n              }\n            }\n          ]\n        },\n        {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: [],\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `div`\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"slot with slotted: false","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":343,"column":32},"line":343,"code":"  test('slot with slotted: false', async () => {\n    const ast = parseWithSlots(`<slot/>`, { slotted: false, scopeId: 'foo' })\n    expect((ast.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [`$slots`, `\"default\"`, `{}`, `undefined`, `true`]\n    })\n    const fallback = parseWithSlots(`<slot>fallback</slot>`, {\n      slotted: false,\n      scopeId: 'foo'\n    })\n\n    const child = {\n      type: NodeTypes.JS_FUNCTION_EXPRESSION,\n      params: [],\n      returns: [\n        {\n          type: NodeTypes.TEXT,\n          content: `fallback`\n        }\n      ]\n    }\n    expect((fallback.children[0] as ElementNode).codegenNode).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: RENDER_SLOT,\n      arguments: [`$slots`, `\"default\"`, `{}`, child, `true`]\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on unexpected custom directive on <slot>","suites":["compiler: transform <slot> outlets"],"updatePoint":{"line":372,"column":54},"line":372,"code":"  test(`error on unexpected custom directive on <slot>`, () => {\n    const onError = vi.fn()\n    const source = `<slot v-foo />`\n    parseWithSlots(source, { onError })\n    const index = source.indexOf('v-foo')\n    expect(onError.mock.calls[0][0]).toMatchObject({\n      code: ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n      loc: {\n        source: `v-foo`,\n        start: {\n          offset: index,\n          line: 1,\n          column: index + 1\n        },\n        end: {\n          offset: index + 5,\n          line: 1,\n          column: index + 6\n        }\n      }\n    })\n  })","file":"transforms/transformSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"no consecutive text","suites":["compiler: transform text"],"updatePoint":{"line":33,"column":27},"line":33,"code":"  test('no consecutive text', () => {\n    const root = transformWithTextOpt(`{{ foo }}`)\n    expect(root.children[0]).toMatchObject({\n      type: NodeTypes.INTERPOLATION,\n      content: {\n        content: `foo`\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"consecutive text","suites":["compiler: transform text"],"updatePoint":{"line":44,"column":24},"line":44,"code":"  test('consecutive text', () => {\n    const root = transformWithTextOpt(`{{ foo }} bar {{ baz }}`)\n    expect(root.children.length).toBe(1)\n    expect(root.children[0]).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { type: NodeTypes.INTERPOLATION, content: { content: `foo` } },\n        ` + `,\n        { type: NodeTypes.TEXT, content: ` bar ` },\n        ` + `,\n        { type: NodeTypes.INTERPOLATION, content: { content: `baz` } }\n      ]\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"consecutive text between elements","suites":["compiler: transform text"],"updatePoint":{"line":60,"column":41},"line":60,"code":"  test('consecutive text between elements', () => {\n    const root = transformWithTextOpt(`<div/>{{ foo }} bar {{ baz }}<div/>`)\n    expect(root.children.length).toBe(3)\n    expect(root.children[0].type).toBe(NodeTypes.ELEMENT)\n    expect(root.children[1]).toMatchObject({\n      // when mixed with elements, should convert it into a text node call\n      type: NodeTypes.TEXT_CALL,\n      codegenNode: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_TEXT,\n        arguments: [\n          {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              { type: NodeTypes.INTERPOLATION, content: { content: `foo` } },\n              ` + `,\n              { type: NodeTypes.TEXT, content: ` bar ` },\n              ` + `,\n              { type: NodeTypes.INTERPOLATION, content: { content: `baz` } }\n            ]\n          },\n          genFlagText(PatchFlags.TEXT)\n        ]\n      }\n    })\n    expect(root.children[2].type).toBe(NodeTypes.ELEMENT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"text between elements (static)","suites":["compiler: transform text"],"updatePoint":{"line":89,"column":38},"line":89,"code":"  test('text between elements (static)', () => {\n    const root = transformWithTextOpt(`<div/>hello<div/>`)\n    expect(root.children.length).toBe(3)\n    expect(root.children[0].type).toBe(NodeTypes.ELEMENT)\n    expect(root.children[1]).toMatchObject({\n      // when mixed with elements, should convert it into a text node call\n      type: NodeTypes.TEXT_CALL,\n      codegenNode: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_TEXT,\n        arguments: [\n          {\n            type: NodeTypes.TEXT,\n            content: `hello`\n          }\n          // should have no flag\n        ]\n      }\n    })\n    expect(root.children[2].type).toBe(NodeTypes.ELEMENT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"consecutive text mixed with elements","suites":["compiler: transform text"],"updatePoint":{"line":112,"column":44},"line":112,"code":"  test('consecutive text mixed with elements', () => {\n    const root = transformWithTextOpt(\n      `<div/>{{ foo }} bar {{ baz }}<div/>hello<div/>`\n    )\n    expect(root.children.length).toBe(5)\n    expect(root.children[0].type).toBe(NodeTypes.ELEMENT)\n    expect(root.children[1]).toMatchObject({\n      type: NodeTypes.TEXT_CALL,\n      codegenNode: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_TEXT,\n        arguments: [\n          {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              { type: NodeTypes.INTERPOLATION, content: { content: `foo` } },\n              ` + `,\n              { type: NodeTypes.TEXT, content: ` bar ` },\n              ` + `,\n              { type: NodeTypes.INTERPOLATION, content: { content: `baz` } }\n            ]\n          },\n          genFlagText(PatchFlags.TEXT)\n        ]\n      }\n    })\n    expect(root.children[2].type).toBe(NodeTypes.ELEMENT)\n    expect(root.children[3]).toMatchObject({\n      type: NodeTypes.TEXT_CALL,\n      codegenNode: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_TEXT,\n        arguments: [\n          {\n            type: NodeTypes.TEXT,\n            content: `hello`\n          }\n        ]\n      }\n    })\n    expect(root.children[4].type).toBe(NodeTypes.ELEMENT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<template v-for>","suites":["compiler: transform text"],"updatePoint":{"line":156,"column":24},"line":156,"code":"  test('<template v-for>', () => {\n    const root = transformWithTextOpt(\n      `<template v-for=\"i in list\">foo</template>`\n    )\n    expect(root.children[0].type).toBe(NodeTypes.FOR)\n    const forNode = root.children[0] as ForNode\n    // should convert template v-for text children because they are inside\n    // fragments\n    expect(forNode.children[0]).toMatchObject({\n      type: NodeTypes.TEXT_CALL\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with prefixIdentifiers: true","suites":["compiler: transform text"],"updatePoint":{"line":170,"column":36},"line":170,"code":"  test('with prefixIdentifiers: true', () => {\n    const root = transformWithTextOpt(`{{ foo }} bar {{ baz + qux }}`, {\n      prefixIdentifiers: true\n    })\n    expect(root.children.length).toBe(1)\n    expect(root.children[0]).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        { type: NodeTypes.INTERPOLATION, content: { content: `_ctx.foo` } },\n        ` + `,\n        { type: NodeTypes.TEXT, content: ` bar ` },\n        ` + `,\n        {\n          type: NodeTypes.INTERPOLATION,\n          content: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [{ content: `_ctx.baz` }, ` + `, { content: `_ctx.qux` }]\n          }\n        }\n      ]\n    })\n    expect(\n      generate(root, {\n        prefixIdentifiers: true\n      }).code\n    ).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"element with custom directives and only one text child node","suites":["compiler: transform text"],"updatePoint":{"line":199,"column":67},"line":199,"code":"  test('element with custom directives and only one text child node', () => {\n    const root = transformWithTextOpt(`<p v-foo>{{ foo }}</p>`)\n    expect(root.children.length).toBe(1)\n    expect(root.children[0].type).toBe(NodeTypes.ELEMENT)\n    expect((root.children[0] as ElementNode).children[0]).toMatchObject({\n      type: NodeTypes.TEXT_CALL,\n      codegenNode: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_TEXT,\n        arguments: [\n          {\n            type: NodeTypes.INTERPOLATION,\n            content: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'foo'\n            }\n          },\n          genFlagText(PatchFlags.TEXT)\n        ]\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/transformText.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"basic","suites":["compiler: transform v-bind"],"updatePoint":{"line":41,"column":13},"line":41,"code":"  test('basic', () => {\n    const node = parseWithVBind(`<div v-bind:id=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `id`,\n        isStatic: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      value: {\n        content: `id`,\n        isStatic: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 17\n          },\n          end: {\n            line: 1,\n            column: 19\n          }\n        }\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic arg","suites":["compiler: transform v-bind"],"updatePoint":{"line":76,"column":19},"line":76,"code":"  test('dynamic arg', () => {\n    const node = parseWithVBind(`<div v-bind:[id]=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as CallExpression\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `id || \"\"`,\n                isStatic: false\n              },\n              value: {\n                content: `id`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should error if no expression","suites":["compiler: transform v-bind"],"updatePoint":{"line":102,"column":37},"line":102,"code":"  test('should error if no expression', () => {\n    const onError = vi.fn()\n    const node = parseWithVBind(`<div v-bind:arg />`, { onError })\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(onError.mock.calls[0][0]).toMatchObject({\n      code: ErrorCodes.X_V_BIND_NO_EXPRESSION,\n      loc: {\n        start: {\n          line: 1,\n          column: 6\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    })\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `arg`,\n        isStatic: true\n      },\n      value: {\n        content: ``,\n        isStatic: true\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".camel modifier","suites":["compiler: transform v-bind"],"updatePoint":{"line":131,"column":23},"line":131,"code":"  test('.camel modifier', () => {\n    const node = parseWithVBind(`<div v-bind:foo-bar.camel=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `fooBar`,\n        isStatic: true\n      },\n      value: {\n        content: `id`,\n        isStatic: false\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".camel modifier w/ dynamic arg","suites":["compiler: transform v-bind"],"updatePoint":{"line":146,"column":38},"line":146,"code":"  test('.camel modifier w/ dynamic arg', () => {\n    const node = parseWithVBind(`<div v-bind:[foo].camel=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as CallExpression\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: `_${helperNameMap[CAMELIZE]}(foo || \"\")`,\n                isStatic: false\n              },\n              value: {\n                content: `id`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".camel modifier w/ dynamic arg + prefixIdentifiers","suites":["compiler: transform v-bind"],"updatePoint":{"line":172,"column":58},"line":172,"code":"  test('.camel modifier w/ dynamic arg + prefixIdentifiers', () => {\n    const node = parseWithVBind(`<div v-bind:[foo(bar)].camel=\"id\"/>`, {\n      prefixIdentifiers: true\n    })\n    const props = (node.codegenNode as VNodeCall).props as CallExpression\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                children: [\n                  `_${helperNameMap[CAMELIZE]}(`,\n                  `(`,\n                  { content: `_ctx.foo` },\n                  `(`,\n                  { content: `_ctx.bar` },\n                  `)`,\n                  `) || \"\"`,\n                  `)`\n                ]\n              },\n              value: {\n                content: `_ctx.id`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".prop modifier","suites":["compiler: transform v-bind"],"updatePoint":{"line":208,"column":22},"line":208,"code":"  test('.prop modifier', () => {\n    const node = parseWithVBind(`<div v-bind:fooBar.prop=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `.fooBar`,\n        isStatic: true\n      },\n      value: {\n        content: `id`,\n        isStatic: false\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".prop modifier w/ dynamic arg","suites":["compiler: transform v-bind"],"updatePoint":{"line":223,"column":37},"line":223,"code":"  test('.prop modifier w/ dynamic arg', () => {\n    const node = parseWithVBind(`<div v-bind:[fooBar].prop=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as CallExpression\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: '`.${fooBar || \"\"}`',\n                isStatic: false\n              },\n              value: {\n                content: `id`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".prop modifier w/ dynamic arg + prefixIdentifiers","suites":["compiler: transform v-bind"],"updatePoint":{"line":249,"column":57},"line":249,"code":"  test('.prop modifier w/ dynamic arg + prefixIdentifiers', () => {\n    const node = parseWithVBind(`<div v-bind:[foo(bar)].prop=\"id\"/>`, {\n      prefixIdentifiers: true\n    })\n    const props = (node.codegenNode as VNodeCall).props as CallExpression\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                children: [\n                  `'.' + (`,\n                  `(`,\n                  { content: `_ctx.foo` },\n                  `(`,\n                  { content: `_ctx.bar` },\n                  `)`,\n                  `) || \"\"`,\n                  `)`\n                ]\n              },\n              value: {\n                content: `_ctx.id`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".prop modifier (shorthand)","suites":["compiler: transform v-bind"],"updatePoint":{"line":285,"column":34},"line":285,"code":"  test('.prop modifier (shorthand)', () => {\n    const node = parseWithVBind(`<div .fooBar=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `.fooBar`,\n        isStatic: true\n      },\n      value: {\n        content: `id`,\n        isStatic: false\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":".attr modifier","suites":["compiler: transform v-bind"],"updatePoint":{"line":300,"column":22},"line":300,"code":"  test('.attr modifier', () => {\n    const node = parseWithVBind(`<div v-bind:foo-bar.attr=\"id\"/>`)\n    const props = (node.codegenNode as VNodeCall).props as ObjectExpression\n    expect(props.properties[0]).toMatchObject({\n      key: {\n        content: `^foo-bar`,\n        isStatic: true\n      },\n      value: {\n        content: `id`,\n        isStatic: false\n      }\n    })\n  })","file":"transforms/vBind.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"number expression","suites":["compiler: v-for","transform"],"updatePoint":{"line":51,"column":27},"line":51,"code":"    test('number expression', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"index in 5\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('index')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('5')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"value","suites":["compiler: v-for","transform"],"updatePoint":{"line":61,"column":15},"line":61,"code":"    test('value', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"(item) in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('item')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"object de-structured value","suites":["compiler: v-for","transform"],"updatePoint":{"line":71,"column":36},"line":71,"code":"    test('object de-structured value', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"({ id, value }) in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe(\n        '{ id, value }'\n      )\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"array de-structured value","suites":["compiler: v-for","transform"],"updatePoint":{"line":83,"column":35},"line":83,"code":"    test('array de-structured value', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"([ id, value ]) in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe(\n        '[ id, value ]'\n      )\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"value and key","suites":["compiler: v-for","transform"],"updatePoint":{"line":95,"column":23},"line":95,"code":"    test('value and key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"(item, key) in items\" />'\n      )\n      expect(forNode.keyAlias).not.toBeUndefined()\n      expect((forNode.keyAlias as SimpleExpressionNode).content).toBe('key')\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('item')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"value, key and index","suites":["compiler: v-for","transform"],"updatePoint":{"line":106,"column":30},"line":106,"code":"    test('value, key and index', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"(value, key, index) in items\" />'\n      )\n      expect(forNode.keyAlias).not.toBeUndefined()\n      expect((forNode.keyAlias as SimpleExpressionNode).content).toBe('key')\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('value')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped key","suites":["compiler: v-for","transform"],"updatePoint":{"line":120,"column":21},"line":120,"code":"    test('skipped key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"(value,,index) in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('value')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped value and key","suites":["compiler: v-for","transform"],"updatePoint":{"line":133,"column":31},"line":133,"code":"    test('skipped value and key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"(,,index) in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect(forNode.valueAlias).toBeUndefined()\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"unbracketed value","suites":["compiler: v-for","transform"],"updatePoint":{"line":146,"column":27},"line":146,"code":"    test('unbracketed value', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"item in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('item')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"unbracketed value and key","suites":["compiler: v-for","transform"],"updatePoint":{"line":156,"column":35},"line":156,"code":"    test('unbracketed value and key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"item, key in items\" />'\n      )\n      expect(forNode.keyAlias).not.toBeUndefined()\n      expect((forNode.keyAlias as SimpleExpressionNode).content).toBe('key')\n      expect(forNode.objectIndexAlias).toBeUndefined()\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('item')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"unbracketed value, key and index","suites":["compiler: v-for","transform"],"updatePoint":{"line":167,"column":42},"line":167,"code":"    test('unbracketed value, key and index', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"value, key, index in items\" />'\n      )\n      expect(forNode.keyAlias).not.toBeUndefined()\n      expect((forNode.keyAlias as SimpleExpressionNode).content).toBe('key')\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('value')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"unbracketed skipped key","suites":["compiler: v-for","transform"],"updatePoint":{"line":181,"column":33},"line":181,"code":"    test('unbracketed skipped key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\"value, , index in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('value')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"unbracketed skipped value and key","suites":["compiler: v-for","transform"],"updatePoint":{"line":194,"column":43},"line":194,"code":"    test('unbracketed skipped value and key', () => {\n      const { node: forNode } = parseWithForTransform(\n        '<span v-for=\", , index in items\" />'\n      )\n      expect(forNode.keyAlias).toBeUndefined()\n      expect(forNode.objectIndexAlias).not.toBeUndefined()\n      expect((forNode.objectIndexAlias as SimpleExpressionNode).content).toBe(\n        'index'\n      )\n      expect(forNode.valueAlias).toBeUndefined()\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"missing expression","suites":["compiler: v-for","errors"],"updatePoint":{"line":209,"column":28},"line":209,"code":"    test('missing expression', () => {\n      const onError = vi.fn()\n      parseWithForTransform('<span v-for />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_NO_EXPRESSION\n        })\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty expression","suites":["compiler: v-for","errors"],"updatePoint":{"line":221,"column":26},"line":221,"code":"    test('empty expression', () => {\n      const onError = vi.fn()\n      parseWithForTransform('<span v-for=\"\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"invalid expression","suites":["compiler: v-for","errors"],"updatePoint":{"line":233,"column":28},"line":233,"code":"    test('invalid expression', () => {\n      const onError = vi.fn()\n      parseWithForTransform('<span v-for=\"items\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"missing source","suites":["compiler: v-for","errors"],"updatePoint":{"line":245,"column":24},"line":245,"code":"    test('missing source', () => {\n      const onError = vi.fn()\n      parseWithForTransform('<span v-for=\"item in\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"missing value","suites":["compiler: v-for","errors"],"updatePoint":{"line":257,"column":23},"line":257,"code":"    test('missing value', () => {\n      const onError = vi.fn()\n      parseWithForTransform('<span v-for=\"in items\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<template v-for> key placement","suites":["compiler: v-for","errors"],"updatePoint":{"line":269,"column":40},"line":269,"code":"    test('<template v-for> key placement', () => {\n      const onError = vi.fn()\n      parseWithForTransform(\n        `\n      <template v-for=\"item in items\">\n        <div :key=\"item.id\"/>\n      </template>`,\n        { onError }\n      )\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT\n        })\n      )\n\n      // should not warn on nested v-for keys\n      parseWithForTransform(\n        `\n      <template v-for=\"item in items\">\n        <div v-for=\"c in item.children\" :key=\"c.id\"/>\n      </template>`,\n        { onError }\n      )\n      expect(onError).toHaveBeenCalledTimes(1)\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"value & source","suites":["compiler: v-for","source location"],"updatePoint":{"line":299,"column":24},"line":299,"code":"    test('value & source', () => {\n      const source = '<span v-for=\"item in items\" />'\n      const { node: forNode } = parseWithForTransform(source)\n\n      const itemOffset = source.indexOf('item')\n      const value = forNode.valueAlias as SimpleExpressionNode\n      expect((forNode.valueAlias as SimpleExpressionNode).content).toBe('item')\n      expect(value.loc.start.offset).toBe(itemOffset)\n      expect(value.loc.start.line).toBe(1)\n      expect(value.loc.start.column).toBe(itemOffset + 1)\n      expect(value.loc.end.line).toBe(1)\n      expect(value.loc.end.column).toBe(itemOffset + 1 + `item`.length)\n\n      const itemsOffset = source.indexOf('items')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n      expect(forNode.source.loc.start.offset).toBe(itemsOffset)\n      expect(forNode.source.loc.start.line).toBe(1)\n      expect(forNode.source.loc.start.column).toBe(itemsOffset + 1)\n      expect(forNode.source.loc.end.line).toBe(1)\n      expect(forNode.source.loc.end.column).toBe(\n        itemsOffset + 1 + `items`.length\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"bracketed value","suites":["compiler: v-for","source location"],"updatePoint":{"line":323,"column":25},"line":323,"code":"    test('bracketed value', () => {\n      const source = '<span v-for=\"( item ) in items\" />'\n      const { node: forNode } = parseWithForTransform(source)\n\n      const itemOffset = source.indexOf('item')\n      const value = forNode.valueAlias as SimpleExpressionNode\n      expect(value.content).toBe('item')\n      expect(value.loc.start.offset).toBe(itemOffset)\n      expect(value.loc.start.line).toBe(1)\n      expect(value.loc.start.column).toBe(itemOffset + 1)\n      expect(value.loc.end.line).toBe(1)\n      expect(value.loc.end.column).toBe(itemOffset + 1 + `item`.length)\n\n      const itemsOffset = source.indexOf('items')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n      expect(forNode.source.loc.start.offset).toBe(itemsOffset)\n      expect(forNode.source.loc.start.line).toBe(1)\n      expect(forNode.source.loc.start.column).toBe(itemsOffset + 1)\n      expect(forNode.source.loc.end.line).toBe(1)\n      expect(forNode.source.loc.end.column).toBe(\n        itemsOffset + 1 + `items`.length\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"de-structured value","suites":["compiler: v-for","source location"],"updatePoint":{"line":347,"column":29},"line":347,"code":"    test('de-structured value', () => {\n      const source = '<span v-for=\"(  { id, key }) in items\" />'\n      const { node: forNode } = parseWithForTransform(source)\n\n      const value = forNode.valueAlias as SimpleExpressionNode\n      const valueIndex = source.indexOf('{ id, key }')\n      expect(value.content).toBe('{ id, key }')\n      expect(value.loc.start.offset).toBe(valueIndex)\n      expect(value.loc.start.line).toBe(1)\n      expect(value.loc.start.column).toBe(valueIndex + 1)\n      expect(value.loc.end.line).toBe(1)\n      expect(value.loc.end.column).toBe(valueIndex + 1 + '{ id, key }'.length)\n\n      const itemsOffset = source.indexOf('items')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n      expect(forNode.source.loc.start.offset).toBe(itemsOffset)\n      expect(forNode.source.loc.start.line).toBe(1)\n      expect(forNode.source.loc.start.column).toBe(itemsOffset + 1)\n      expect(forNode.source.loc.end.line).toBe(1)\n      expect(forNode.source.loc.end.column).toBe(\n        itemsOffset + 1 + `items`.length\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"bracketed value, key, index","suites":["compiler: v-for","source location"],"updatePoint":{"line":371,"column":37},"line":371,"code":"    test('bracketed value, key, index', () => {\n      const source = '<span v-for=\"( item, key, index ) in items\" />'\n      const { node: forNode } = parseWithForTransform(source)\n\n      const itemOffset = source.indexOf('item')\n      const value = forNode.valueAlias as SimpleExpressionNode\n      expect(value.content).toBe('item')\n      expect(value.loc.start.offset).toBe(itemOffset)\n      expect(value.loc.start.line).toBe(1)\n      expect(value.loc.start.column).toBe(itemOffset + 1)\n      expect(value.loc.end.line).toBe(1)\n      expect(value.loc.end.column).toBe(itemOffset + 1 + `item`.length)\n\n      const keyOffset = source.indexOf('key')\n      const key = forNode.keyAlias as SimpleExpressionNode\n      expect(key.content).toBe('key')\n      expect(key.loc.start.offset).toBe(keyOffset)\n      expect(key.loc.start.line).toBe(1)\n      expect(key.loc.start.column).toBe(keyOffset + 1)\n      expect(key.loc.end.line).toBe(1)\n      expect(key.loc.end.column).toBe(keyOffset + 1 + `key`.length)\n\n      const indexOffset = source.indexOf('index')\n      const index = forNode.objectIndexAlias as SimpleExpressionNode\n      expect(index.content).toBe('index')\n      expect(index.loc.start.offset).toBe(indexOffset)\n      expect(index.loc.start.line).toBe(1)\n      expect(index.loc.start.column).toBe(indexOffset + 1)\n      expect(index.loc.end.line).toBe(1)\n      expect(index.loc.end.column).toBe(indexOffset + 1 + `index`.length)\n\n      const itemsOffset = source.indexOf('items')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n      expect(forNode.source.loc.start.offset).toBe(itemsOffset)\n      expect(forNode.source.loc.start.line).toBe(1)\n      expect(forNode.source.loc.start.column).toBe(itemsOffset + 1)\n      expect(forNode.source.loc.end.line).toBe(1)\n      expect(forNode.source.loc.end.column).toBe(\n        itemsOffset + 1 + `items`.length\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped key","suites":["compiler: v-for","source location"],"updatePoint":{"line":413,"column":21},"line":413,"code":"    test('skipped key', () => {\n      const source = '<span v-for=\"( item,, index ) in items\" />'\n      const { node: forNode } = parseWithForTransform(source)\n\n      const itemOffset = source.indexOf('item')\n      const value = forNode.valueAlias as SimpleExpressionNode\n      expect(value.content).toBe('item')\n      expect(value.loc.start.offset).toBe(itemOffset)\n      expect(value.loc.start.line).toBe(1)\n      expect(value.loc.start.column).toBe(itemOffset + 1)\n      expect(value.loc.end.line).toBe(1)\n      expect(value.loc.end.column).toBe(itemOffset + 1 + `item`.length)\n\n      const indexOffset = source.indexOf('index')\n      const index = forNode.objectIndexAlias as SimpleExpressionNode\n      expect(index.content).toBe('index')\n      expect(index.loc.start.offset).toBe(indexOffset)\n      expect(index.loc.start.line).toBe(1)\n      expect(index.loc.start.column).toBe(indexOffset + 1)\n      expect(index.loc.end.line).toBe(1)\n      expect(index.loc.end.column).toBe(indexOffset + 1 + `index`.length)\n\n      const itemsOffset = source.indexOf('items')\n      expect((forNode.source as SimpleExpressionNode).content).toBe('items')\n      expect(forNode.source.loc.start.offset).toBe(itemsOffset)\n      expect(forNode.source.loc.start.line).toBe(1)\n      expect(forNode.source.loc.start.column).toBe(itemsOffset + 1)\n      expect(forNode.source.loc.end.line).toBe(1)\n      expect(forNode.source.loc.end.column).toBe(\n        itemsOffset + 1 + `items`.length\n      )\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix v-for source","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":448,"column":36},"line":448,"code":"    test('should prefix v-for source', () => {\n      const { node } = parseWithForTransform(`<div v-for=\"i in list\"/>`, {\n        prefixIdentifiers: true\n      })\n      expect(node.source).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `_ctx.list`\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix v-for source w/ complex expression","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":458,"column":58},"line":458,"code":"    test('should prefix v-for source w/ complex expression', () => {\n      const { node } = parseWithForTransform(\n        `<div v-for=\"i in list.concat([foo])\"/>`,\n        { prefixIdentifiers: true }\n      )\n      expect(node.source).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [\n          { content: `_ctx.list` },\n          `.`,\n          { content: `concat` },\n          `([`,\n          { content: `_ctx.foo` },\n          `])`\n        ]\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix v-for alias","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":476,"column":39},"line":476,"code":"    test('should not prefix v-for alias', () => {\n      const { node } = parseWithForTransform(\n        `<div v-for=\"i in list\">{{ i }}{{ j }}</div>`,\n        { prefixIdentifiers: true }\n      )\n      const div = node.children[0] as ElementNode\n      expect((div.children[0] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `i`\n      })\n      expect((div.children[1] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `_ctx.j`\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not prefix v-for aliases (multiple)","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":492,"column":52},"line":492,"code":"    test('should not prefix v-for aliases (multiple)', () => {\n      const { node } = parseWithForTransform(\n        `<div v-for=\"(i, j, k) in list\">{{ i + j + k }}{{ l }}</div>`,\n        { prefixIdentifiers: true }\n      )\n      const div = node.children[0] as ElementNode\n      expect((div.children[0] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [\n          { content: `i` },\n          ` + `,\n          { content: `j` },\n          ` + `,\n          { content: `k` }\n        ]\n      })\n      expect((div.children[1] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `_ctx.l`\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix id outside of v-for","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":514,"column":43},"line":514,"code":"    test('should prefix id outside of v-for', () => {\n      const { node } = parseWithForTransform(\n        `<div><div v-for=\"i in list\" />{{ i }}</div>`,\n        { prefixIdentifiers: true }\n      )\n      expect((node.children[1] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `_ctx.i`\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"nested v-for","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":525,"column":22},"line":525,"code":"    test('nested v-for', () => {\n      const { node } = parseWithForTransform(\n        `<div v-for=\"i in list\">\n          <div v-for=\"i in list\">{{ i + j }}</div>{{ i }}\n        </div>`,\n        { prefixIdentifiers: true }\n      )\n      const outerDiv = node.children[0] as ElementNode\n      const innerFor = outerDiv.children[0] as ForNode\n      const innerExp = (innerFor.children[0] as ElementNode)\n        .children[0] as InterpolationNode\n      expect(innerExp.content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [{ content: 'i' }, ` + `, { content: `_ctx.j` }]\n      })\n\n      // when an inner v-for shadows a variable of an outer v-for and exit,\n      // it should not cause the outer v-for's alias to be removed from known ids\n      const outerExp = outerDiv.children[1] as InterpolationNode\n      expect(outerExp.content).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `i`\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-for aliases w/ complex expressions","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":550,"column":46},"line":550,"code":"    test('v-for aliases w/ complex expressions', () => {\n      const { node } = parseWithForTransform(\n        `<div v-for=\"({ foo = bar, baz: [qux = quux] }) in list\">\n          {{ foo + bar + baz + qux + quux }}\n        </div>`,\n        { prefixIdentifiers: true }\n      )\n      expect(node.valueAlias!).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [\n          `{ `,\n          { content: `foo` },\n          ` = `,\n          { content: `_ctx.bar` },\n          `, baz: [`,\n          { content: `qux` },\n          ` = `,\n          { content: `_ctx.quux` },\n          `] }`\n        ]\n      })\n      const div = node.children[0] as ElementNode\n      expect((div.children[0] as InterpolationNode).content).toMatchObject({\n        type: NodeTypes.COMPOUND_EXPRESSION,\n        children: [\n          { content: `foo` },\n          ` + `,\n          { content: `_ctx.bar` },\n          ` + `,\n          { content: `_ctx.baz` },\n          ` + `,\n          { content: `qux` },\n          ` + `,\n          { content: `_ctx.quux` }\n        ]\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"element v-for key expression prefixing","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":588,"column":48},"line":588,"code":"    test('element v-for key expression prefixing', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<div v-for=\"item in items\" :key=\"itemKey(item)\">test</div>',\n        { prefixIdentifiers: true }\n      )\n      const innerBlock = codegenNode.children.arguments[1].returns\n      expect(innerBlock).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`,\n        props: createObjectMatcher({\n          key: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              // should prefix outer scope references\n              { content: `_ctx.itemKey` },\n              `(`,\n              // should NOT prefix in scope variables\n              { content: `item` },\n              `)`\n            ]\n          }\n        })\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-for key expression prefixing","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":616,"column":49},"line":616,"code":"    test('template v-for key expression prefixing', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\" :key=\"itemKey(item)\">test</template>',\n        { prefixIdentifiers: true }\n      )\n      const innerBlock = codegenNode.children.arguments[1].returns\n      expect(innerBlock).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        tag: FRAGMENT,\n        props: createObjectMatcher({\n          key: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              // should prefix outer scope references\n              { content: `_ctx.itemKey` },\n              `(`,\n              // should NOT prefix in scope variables\n              { content: `item` },\n              `)`\n            ]\n          }\n        })\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-for key no prefixing on attribute key","suites":["compiler: v-for","prefixIdentifiers: true"],"updatePoint":{"line":643,"column":58},"line":643,"code":"    test('template v-for key no prefixing on attribute key', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\" key=\"key\">test</template>',\n        { prefixIdentifiers: true }\n      )\n      const innerBlock = codegenNode.children.arguments[1].returns\n      expect(innerBlock).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        tag: FRAGMENT,\n        props: createObjectMatcher({\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: 'key'\n          }\n        })\n      })\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"basic v-for","suites":["compiler: v-for","codegen"],"updatePoint":{"line":706,"column":21},"line":706,"code":"    test('basic v-for', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(item) in items\" />')\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          tag: `\"span\"`\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"value + key + index","suites":["compiler: v-for","codegen"],"updatePoint":{"line":721,"column":29},"line":721,"code":"    test('value + key + index', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(item, key, index) in items\" />')\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }, { content: `key` }, { content: `index` }]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped value","suites":["compiler: v-for","codegen"],"updatePoint":{"line":733,"column":23},"line":733,"code":"    test('skipped value', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(, key, index) in items\" />')\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `_` }, { content: `key` }, { content: `index` }]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped key","suites":["compiler: v-for","codegen"],"updatePoint":{"line":745,"column":21},"line":745,"code":"    test('skipped key', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(item,,index) in items\" />')\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }, { content: `__` }, { content: `index` }]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"skipped value & key","suites":["compiler: v-for","codegen"],"updatePoint":{"line":757,"column":29},"line":757,"code":"    test('skipped value & key', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(,,index) in items\" />')\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `_` }, { content: `__` }, { content: `index` }]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-for with constant expression","suites":["compiler: v-for","codegen"],"updatePoint":{"line":769,"column":40},"line":769,"code":"    test('v-for with constant expression', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<p v-for=\"item in 10\">{{item}}</p>', {\n        prefixIdentifiers: true\n      })\n\n      expect(\n        assertSharedCodegen(\n          codegenNode,\n          false /* keyed */,\n          false /* customReturn */,\n          false /* disableTracking */\n        )\n      ).toMatchObject({\n        source: { content: `10`, constType: ConstantTypes.CAN_STRINGIFY },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          tag: `\"p\"`,\n          props: undefined,\n          isBlock: false,\n          children: {\n            type: NodeTypes.INTERPOLATION,\n            content: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'item',\n              isStatic: false,\n              constType: ConstantTypes.NOT_CONSTANT\n            }\n          },\n          patchFlag: genFlagText(PatchFlags.TEXT)\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-for","suites":["compiler: v-for","codegen"],"updatePoint":{"line":806,"column":24},"line":806,"code":"    test('template v-for', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\">hello<span/></template>'\n      )\n      expect(assertSharedCodegen(codegenNode)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          tag: FRAGMENT,\n          props: undefined,\n          isBlock: true,\n          children: [\n            { type: NodeTypes.TEXT, content: `hello` },\n            { type: NodeTypes.ELEMENT, tag: `span` }\n          ],\n          patchFlag: genFlagText(PatchFlags.STABLE_FRAGMENT)\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-for w/ <slot/>","suites":["compiler: v-for","codegen"],"updatePoint":{"line":830,"column":35},"line":830,"code":"    test('template v-for w/ <slot/>', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\"><slot/></template>'\n      )\n      expect(\n        assertSharedCodegen(codegenNode, false, true /* custom return */)\n      ).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        returns: {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: RENDER_SLOT\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-for key injection with single child","suites":["compiler: v-for","codegen"],"updatePoint":{"line":851,"column":56},"line":851,"code":"    test('template v-for key injection with single child', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\" :key=\"item.id\"><span :id=\"item.id\" /></template>'\n      )\n      expect(assertSharedCodegen(codegenNode, true)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          type: NodeTypes.VNODE_CALL,\n          tag: `\"span\"`,\n          props: createObjectMatcher({\n            key: '[item.id]',\n            id: '[item.id]'\n          })\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-for on <slot/>","suites":["compiler: v-for","codegen"],"updatePoint":{"line":873,"column":26},"line":873,"code":"    test('v-for on <slot/>', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<slot v-for=\"item in items\"></slot>')\n      expect(\n        assertSharedCodegen(codegenNode, false, true /* custom return */)\n      ).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        returns: {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: RENDER_SLOT\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"keyed v-for","suites":["compiler: v-for","codegen"],"updatePoint":{"line":891,"column":21},"line":891,"code":"    test('keyed v-for', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<span v-for=\"(item) in items\" :key=\"item\" />')\n      expect(assertSharedCodegen(codegenNode, true)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          tag: `\"span\"`,\n          props: createObjectMatcher({\n            key: `[item]`\n          })\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"keyed template v-for","suites":["compiler: v-for","codegen"],"updatePoint":{"line":909,"column":30},"line":909,"code":"    test('keyed template v-for', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(\n        '<template v-for=\"item in items\" :key=\"item\">hello<span/></template>'\n      )\n      expect(assertSharedCodegen(codegenNode, true)).toMatchObject({\n        source: { content: `items` },\n        params: [{ content: `item` }],\n        innerVNodeCall: {\n          tag: FRAGMENT,\n          props: createObjectMatcher({\n            key: `[item]`\n          }),\n          children: [\n            { type: NodeTypes.TEXT, content: `hello` },\n            { type: NodeTypes.ELEMENT, tag: `span` }\n          ],\n          patchFlag: genFlagText(PatchFlags.STABLE_FRAGMENT)\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-for","suites":["compiler: v-for","codegen"],"updatePoint":{"line":934,"column":22},"line":934,"code":"    test('v-if + v-for', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(`<div v-if=\"ok\" v-for=\"i in list\"/>`)\n      expect(codegenNode).toMatchObject({\n        type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n        test: { content: `ok` },\n        consequent: {\n          type: NodeTypes.VNODE_CALL,\n          props: createObjectMatcher({\n            key: `[0]`\n          }),\n          isBlock: true,\n          disableTracking: true,\n          patchFlag: genFlagText(PatchFlags.UNKEYED_FRAGMENT),\n          children: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: RENDER_LIST,\n            arguments: [\n              { content: `list` },\n              {\n                type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                params: [{ content: `i` }],\n                returns: {\n                  type: NodeTypes.VNODE_CALL,\n                  tag: `\"div\"`,\n                  isBlock: true\n                }\n              }\n            ]\n          }\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-for on <template>","suites":["compiler: v-for","codegen"],"updatePoint":{"line":972,"column":36},"line":972,"code":"    test('v-if + v-for on <template>', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform(`<template v-if=\"ok\" v-for=\"i in list\"/>`)\n      expect(codegenNode).toMatchObject({\n        type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n        test: { content: `ok` },\n        consequent: {\n          type: NodeTypes.VNODE_CALL,\n          props: createObjectMatcher({\n            key: `[0]`\n          }),\n          isBlock: true,\n          disableTracking: true,\n          patchFlag: genFlagText(PatchFlags.UNKEYED_FRAGMENT),\n          children: {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: RENDER_LIST,\n            arguments: [\n              { content: `list` },\n              {\n                type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                params: [{ content: `i` }],\n                returns: {\n                  type: NodeTypes.VNODE_CALL,\n                  tag: FRAGMENT,\n                  isBlock: true\n                }\n              }\n            ]\n          }\n        }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-for on element with custom directive","suites":["compiler: v-for","codegen"],"updatePoint":{"line":1009,"column":48},"line":1009,"code":"    test('v-for on element with custom directive', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithForTransform('<div v-for=\"i in list\" v-foo/>')\n      const { returns } = assertSharedCodegen(codegenNode, false, true)\n      expect(returns).toMatchObject({\n        type: NodeTypes.VNODE_CALL,\n        directives: { type: NodeTypes.JS_ARRAY_EXPRESSION }\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vFor.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"basic v-if","suites":["compiler: v-if","transform"],"updatePoint":{"line":58,"column":20},"line":58,"code":"    test('basic v-if', () => {\n      const { node } = parseWithIfTransform(`<div v-if=\"ok\"/>`)\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(1)\n      expect((node.branches[0].condition as SimpleExpressionNode).content).toBe(\n        `ok`\n      )\n      expect(node.branches[0].children.length).toBe(1)\n      expect(node.branches[0].children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((node.branches[0].children[0] as ElementNode).tag).toBe(`div`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-if","suites":["compiler: v-if","transform"],"updatePoint":{"line":70,"column":23},"line":70,"code":"    test('template v-if', () => {\n      const { node } = parseWithIfTransform(\n        `<template v-if=\"ok\"><div/>hello<p/></template>`\n      )\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(1)\n      expect((node.branches[0].condition as SimpleExpressionNode).content).toBe(\n        `ok`\n      )\n      expect(node.branches[0].children.length).toBe(3)\n      expect(node.branches[0].children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((node.branches[0].children[0] as ElementNode).tag).toBe(`div`)\n      expect(node.branches[0].children[1].type).toBe(NodeTypes.TEXT)\n      expect((node.branches[0].children[1] as TextNode).content).toBe(`hello`)\n      expect(node.branches[0].children[2].type).toBe(NodeTypes.ELEMENT)\n      expect((node.branches[0].children[2] as ElementNode).tag).toBe(`p`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"component v-if","suites":["compiler: v-if","transform"],"updatePoint":{"line":88,"column":24},"line":88,"code":"    test('component v-if', () => {\n      const { node } = parseWithIfTransform(`<Component v-if=\"ok\"></Component>`)\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(1)\n      expect((node.branches[0].children[0] as ElementNode).tag).toBe(\n        `Component`\n      )\n      expect((node.branches[0].children[0] as ElementNode).tagType).toBe(\n        ElementTypes.COMPONENT\n      )\n      // #2058 since a component may fail to resolve and fallback to a plain\n      // element, it still needs to be made a block\n      expect(\n        ((node.branches[0].children[0] as ElementNode)!\n          .codegenNode as VNodeCall)!.isBlock\n      ).toBe(true)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else","suites":["compiler: v-if","transform"],"updatePoint":{"line":106,"column":23},"line":106,"code":"    test('v-if + v-else', () => {\n      const { node } = parseWithIfTransform(`<div v-if=\"ok\"/><p v-else/>`)\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(2)\n\n      const b1 = node.branches[0]\n      expect((b1.condition as SimpleExpressionNode).content).toBe(`ok`)\n      expect(b1.children.length).toBe(1)\n      expect(b1.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b1.children[0] as ElementNode).tag).toBe(`div`)\n\n      const b2 = node.branches[1]\n      expect(b2.condition).toBeUndefined()\n      expect(b2.children.length).toBe(1)\n      expect(b2.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b2.children[0] as ElementNode).tag).toBe(`p`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else-if","suites":["compiler: v-if","transform"],"updatePoint":{"line":124,"column":26},"line":124,"code":"    test('v-if + v-else-if', () => {\n      const { node } = parseWithIfTransform(\n        `<div v-if=\"ok\"/><p v-else-if=\"orNot\"/>`\n      )\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(2)\n\n      const b1 = node.branches[0]\n      expect((b1.condition as SimpleExpressionNode).content).toBe(`ok`)\n      expect(b1.children.length).toBe(1)\n      expect(b1.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b1.children[0] as ElementNode).tag).toBe(`div`)\n\n      const b2 = node.branches[1]\n      expect((b2.condition as SimpleExpressionNode).content).toBe(`orNot`)\n      expect(b2.children.length).toBe(1)\n      expect(b2.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b2.children[0] as ElementNode).tag).toBe(`p`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else-if + v-else","suites":["compiler: v-if","transform"],"updatePoint":{"line":144,"column":35},"line":144,"code":"    test('v-if + v-else-if + v-else', () => {\n      const { node } = parseWithIfTransform(\n        `<div v-if=\"ok\"/><p v-else-if=\"orNot\"/><template v-else>fine</template>`\n      )\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(3)\n\n      const b1 = node.branches[0]\n      expect((b1.condition as SimpleExpressionNode).content).toBe(`ok`)\n      expect(b1.children.length).toBe(1)\n      expect(b1.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b1.children[0] as ElementNode).tag).toBe(`div`)\n\n      const b2 = node.branches[1]\n      expect((b2.condition as SimpleExpressionNode).content).toBe(`orNot`)\n      expect(b2.children.length).toBe(1)\n      expect(b2.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b2.children[0] as ElementNode).tag).toBe(`p`)\n\n      const b3 = node.branches[2]\n      expect(b3.condition).toBeUndefined()\n      expect(b3.children.length).toBe(1)\n      expect(b3.children[0].type).toBe(NodeTypes.TEXT)\n      expect((b3.children[0] as TextNode).content).toBe(`fine`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"comment between branches","suites":["compiler: v-if","transform"],"updatePoint":{"line":170,"column":34},"line":170,"code":"    test('comment between branches', () => {\n      const { node } = parseWithIfTransform(`\n        <div v-if=\"ok\"/>\n        <!--foo-->\n        <p v-else-if=\"orNot\"/>\n        <!--bar-->\n        <template v-else>fine</template>\n      `)\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(3)\n\n      const b1 = node.branches[0]\n      expect((b1.condition as SimpleExpressionNode).content).toBe(`ok`)\n      expect(b1.children.length).toBe(1)\n      expect(b1.children[0].type).toBe(NodeTypes.ELEMENT)\n      expect((b1.children[0] as ElementNode).tag).toBe(`div`)\n\n      const b2 = node.branches[1]\n      expect((b2.condition as SimpleExpressionNode).content).toBe(`orNot`)\n      expect(b2.children.length).toBe(2)\n      expect(b2.children[0].type).toBe(NodeTypes.COMMENT)\n      expect((b2.children[0] as CommentNode).content).toBe(`foo`)\n      expect(b2.children[1].type).toBe(NodeTypes.ELEMENT)\n      expect((b2.children[1] as ElementNode).tag).toBe(`p`)\n\n      const b3 = node.branches[2]\n      expect(b3.condition).toBeUndefined()\n      expect(b3.children.length).toBe(2)\n      expect(b3.children[0].type).toBe(NodeTypes.COMMENT)\n      expect((b3.children[0] as CommentNode).content).toBe(`bar`)\n      expect(b3.children[1].type).toBe(NodeTypes.TEXT)\n      expect((b3.children[1] as TextNode).content).toBe(`fine`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should prefix v-if condition","suites":["compiler: v-if","transform"],"updatePoint":{"line":204,"column":38},"line":204,"code":"    test('should prefix v-if condition', () => {\n      const { node } = parseWithIfTransform(`<div v-if=\"ok\"/>`, {\n        prefixIdentifiers: true\n      })\n      expect(node.branches[0].condition).toMatchObject({\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `_ctx.ok`\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on v-else missing adjacent v-if","suites":["compiler: v-if","errors"],"updatePoint":{"line":216,"column":47},"line":216,"code":"    test('error on v-else missing adjacent v-if', () => {\n      const onError = vi.fn()\n\n      const { node: node1 } = parseWithIfTransform(`<div v-else/>`, { onError })\n      expect(onError.mock.calls[0]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node1.loc\n        }\n      ])\n\n      const { node: node2 } = parseWithIfTransform(\n        `<div/><div v-else/>`,\n        { onError },\n        1\n      )\n      expect(onError.mock.calls[1]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node2.loc\n        }\n      ])\n\n      const { node: node3 } = parseWithIfTransform(\n        `<div/>foo<div v-else/>`,\n        { onError },\n        2\n      )\n      expect(onError.mock.calls[2]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node3.loc\n        }\n      ])\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on v-else-if missing adjacent v-if or v-else-if","suites":["compiler: v-if","errors"],"updatePoint":{"line":252,"column":63},"line":252,"code":"    test('error on v-else-if missing adjacent v-if or v-else-if', () => {\n      const onError = vi.fn()\n\n      const { node: node1 } = parseWithIfTransform(`<div v-else-if=\"foo\"/>`, {\n        onError\n      })\n      expect(onError.mock.calls[0]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node1.loc\n        }\n      ])\n\n      const { node: node2 } = parseWithIfTransform(\n        `<div/><div v-else-if=\"foo\"/>`,\n        { onError },\n        1\n      )\n      expect(onError.mock.calls[1]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node2.loc\n        }\n      ])\n\n      const { node: node3 } = parseWithIfTransform(\n        `<div/>foo<div v-else-if=\"foo\"/>`,\n        { onError },\n        2\n      )\n      expect(onError.mock.calls[2]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: node3.loc\n        }\n      ])\n\n      const {\n        node: { branches }\n      } = parseWithIfTransform(\n        `<div v-if=\"notOk\"/><div v-else/><div v-else-if=\"ok\"/>`,\n        { onError },\n        0\n      )\n\n      expect(onError.mock.calls[3]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,\n          loc: branches[branches.length - 1].loc\n        }\n      ])\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on user key","suites":["compiler: v-if","errors"],"updatePoint":{"line":305,"column":27},"line":305,"code":"    test('error on user key', () => {\n      const onError = vi.fn()\n      // dynamic\n      parseWithIfTransform(\n        `<div v-if=\"ok\" :key=\"a + 1\" /><div v-else :key=\"a + 1\" />`,\n        { onError }\n      )\n      expect(onError.mock.calls[0]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_IF_SAME_KEY\n        }\n      ])\n      // static\n      parseWithIfTransform(`<div v-if=\"ok\" key=\"1\" /><div v-else key=\"1\" />`, {\n        onError\n      })\n      expect(onError.mock.calls[1]).toMatchObject([\n        {\n          code: ErrorCodes.X_V_IF_SAME_KEY\n        }\n      ])\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"basic v-if","suites":["compiler: v-if","codegen"],"updatePoint":{"line":377,"column":20},"line":377,"code":"    test('basic v-if', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\"/>`)\n      assertSharedCodegen(codegenNode)\n      expect(codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      expect(codegenNode.alternate).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_COMMENT\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-if","suites":["compiler: v-if","codegen"],"updatePoint":{"line":394,"column":23},"line":394,"code":"    test('template v-if', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<template v-if=\"ok\"><div/>hello<p/></template>`)\n      assertSharedCodegen(codegenNode)\n      expect(codegenNode.consequent).toMatchObject({\n        tag: FRAGMENT,\n        props: createObjectMatcher({ key: `[0]` }),\n        children: [\n          { type: NodeTypes.ELEMENT, tag: 'div' },\n          { type: NodeTypes.TEXT, content: `hello` },\n          { type: NodeTypes.ELEMENT, tag: 'p' }\n        ]\n      })\n      expect(codegenNode.alternate).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_COMMENT\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template v-if w/ single <slot/> child","suites":["compiler: v-if","codegen"],"updatePoint":{"line":416,"column":47},"line":416,"code":"    test('template v-if w/ single <slot/> child', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<template v-if=\"ok\"><slot/></template>`)\n      expect(codegenNode.consequent).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: RENDER_SLOT,\n        arguments: ['$slots', '\"default\"', createObjectMatcher({ key: `[0]` })]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if on <slot/>","suites":["compiler: v-if","codegen"],"updatePoint":{"line":429,"column":25},"line":429,"code":"    test('v-if on <slot/>', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<slot v-if=\"ok\"></slot>`)\n      expect(codegenNode.consequent).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: RENDER_SLOT,\n        arguments: ['$slots', '\"default\"', createObjectMatcher({ key: `[0]` })]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else","suites":["compiler: v-if","codegen"],"updatePoint":{"line":442,"column":23},"line":442,"code":"    test('v-if + v-else', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\"/><p v-else/>`)\n      assertSharedCodegen(codegenNode, 0, true)\n      expect(codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      expect(codegenNode.alternate).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else-if","suites":["compiler: v-if","codegen"],"updatePoint":{"line":459,"column":26},"line":459,"code":"    test('v-if + v-else-if', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\"/><p v-else-if=\"orNot\" />`)\n      assertSharedCodegen(codegenNode, 1)\n      expect(codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      const branch2 = codegenNode.alternate as ConditionalExpression\n      expect(branch2.consequent).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-if + v-else-if + v-else","suites":["compiler: v-if","codegen"],"updatePoint":{"line":477,"column":35},"line":477,"code":"    test('v-if + v-else-if + v-else', () => {\n      const {\n        root,\n        node: { codegenNode }\n      } = parseWithIfTransform(\n        `<div v-if=\"ok\"/><p v-else-if=\"orNot\"/><template v-else>fine</template>`\n      )\n      assertSharedCodegen(codegenNode, 1, true)\n      expect(codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      const branch2 = codegenNode.alternate as ConditionalExpression\n      expect(branch2.consequent).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      expect(branch2.alternate).toMatchObject({\n        tag: FRAGMENT,\n        props: createObjectMatcher({ key: `[2]` }),\n        children: [\n          {\n            type: NodeTypes.TEXT,\n            content: `fine`\n          }\n        ]\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple v-if that are sibling nodes should have different keys","suites":["compiler: v-if","codegen"],"updatePoint":{"line":507,"column":73},"line":507,"code":"    test('multiple v-if that are sibling nodes should have different keys', () => {\n      const { root } = parseWithIfTransform(\n        `<div v-if=\"ok\"/><p v-if=\"orNot\"/>`,\n        {},\n        0 /* returnIndex, just give the default value */,\n        2 /* childrenLen */\n      )\n\n      const ifNode = root.children[0] as IfNode & {\n        codegenNode: IfConditionalExpression\n      }\n      expect(ifNode.codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      const ifNode2 = root.children[1] as IfNode & {\n        codegenNode: IfConditionalExpression\n      }\n      expect(ifNode2.codegenNode.consequent).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"increasing key: v-if + v-else-if + v-else","suites":["compiler: v-if","codegen"],"updatePoint":{"line":532,"column":51},"line":532,"code":"    test('increasing key: v-if + v-else-if + v-else', () => {\n      const { root } = parseWithIfTransform(\n        `<div v-if=\"ok\"/><p v-else/><div v-if=\"another\"/><p v-else-if=\"orNot\"/><p v-else/>`,\n        {},\n        0 /* returnIndex, just give the default value */,\n        2 /* childrenLen */\n      )\n      const ifNode = root.children[0] as IfNode & {\n        codegenNode: IfConditionalExpression\n      }\n      expect(ifNode.codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      expect(ifNode.codegenNode.alternate).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      const ifNode2 = root.children[1] as IfNode & {\n        codegenNode: IfConditionalExpression\n      }\n      expect(ifNode2.codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[2]` })\n      })\n      const branch = ifNode2.codegenNode.alternate as IfConditionalExpression\n      expect(branch.consequent).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[3]` })\n      })\n      expect(branch.alternate).toMatchObject({\n        tag: `\"p\"`,\n        props: createObjectMatcher({ key: `[4]` })\n      })\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"key injection (only v-bind)","suites":["compiler: v-if","codegen"],"updatePoint":{"line":569,"column":37},"line":569,"code":"    test('key injection (only v-bind)', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\" v-bind=\"obj\"/>`)\n      const branch1 = codegenNode.consequent as VNodeCall\n      expect(branch1.props).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: NORMALIZE_PROPS,\n        arguments: [\n          {\n            type: NodeTypes.JS_CALL_EXPRESSION,\n            callee: MERGE_PROPS,\n            arguments: [createObjectMatcher({ key: `[0]` }), { content: `obj` }]\n          }\n        ]\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"key injection (before v-bind)","suites":["compiler: v-if","codegen"],"updatePoint":{"line":587,"column":39},"line":587,"code":"    test('key injection (before v-bind)', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\" id=\"foo\" v-bind=\"obj\"/>`)\n      const branch1 = codegenNode.consequent as VNodeCall\n      expect(branch1.props).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: MERGE_PROPS,\n        arguments: [\n          createObjectMatcher({\n            key: '[0]',\n            id: 'foo'\n          }),\n          { content: `obj` }\n        ]\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"key injection (after v-bind)","suites":["compiler: v-if","codegen"],"updatePoint":{"line":605,"column":38},"line":605,"code":"    test('key injection (after v-bind)', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\" v-bind=\"obj\" id=\"foo\"/>`)\n      const branch1 = codegenNode.consequent as VNodeCall\n      expect(branch1.props).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: MERGE_PROPS,\n        arguments: [\n          createObjectMatcher({ key: `[0]` }),\n          { content: `obj` },\n          createObjectMatcher({\n            id: 'foo'\n          })\n        ]\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"key injection (w/ custom directive)","suites":["compiler: v-if","codegen"],"updatePoint":{"line":623,"column":45},"line":623,"code":"    test('key injection (w/ custom directive)', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\" v-foo />`)\n      const branch1 = codegenNode.consequent as VNodeCall\n      expect(branch1.directives).not.toBeUndefined()\n      expect(branch1.props).toMatchObject(createObjectMatcher({ key: `[0]` }))\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"avoid duplicate keys","suites":["compiler: v-if","codegen"],"updatePoint":{"line":633,"column":30},"line":633,"code":"    test('avoid duplicate keys', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(`<div v-if=\"ok\" key=\"custom_key\" v-bind=\"obj\"/>`)\n      const branch1 = codegenNode.consequent as VNodeCall\n      expect(branch1.props).toMatchObject({\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: MERGE_PROPS,\n        arguments: [\n          createObjectMatcher({\n            key: 'custom_key'\n          }),\n          { content: `obj` }\n        ]\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with spaces between branches","suites":["compiler: v-if","codegen"],"updatePoint":{"line":650,"column":38},"line":650,"code":"    test('with spaces between branches', () => {\n      const {\n        node: { codegenNode }\n      } = parseWithIfTransform(\n        `<div v-if=\"ok\"/> <div v-else-if=\"no\"/> <div v-else/>`\n      )\n      expect(codegenNode.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[0]` })\n      })\n      const branch = codegenNode.alternate as ConditionalExpression\n      expect(branch.consequent).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[1]` })\n      })\n      expect(branch.alternate).toMatchObject({\n        tag: `\"div\"`,\n        props: createObjectMatcher({ key: `[2]` })\n      })\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with comments","suites":["compiler: v-if","codegen"],"updatePoint":{"line":671,"column":23},"line":671,"code":"    test('with comments', () => {\n      const { node } = parseWithIfTransform(`\n          <template v-if=\"ok\">\n            <!--comment1-->\n            <div v-if=\"ok2\">\n              <!--comment2-->\n            </div>\n            <!--comment3-->\n            <b v-else/>\n            <!--comment4-->\n            <p/>\n          </template>\n        `)\n      expect(node.type).toBe(NodeTypes.IF)\n      expect(node.branches.length).toBe(1)\n\n      const b1 = node.branches[0]\n      expect((b1.condition as SimpleExpressionNode).content).toBe(`ok`)\n      expect(b1.children.length).toBe(4)\n\n      expect(b1.children[0].type).toBe(NodeTypes.COMMENT)\n      expect((b1.children[0] as CommentNode).content).toBe(`comment1`)\n\n      expect(b1.children[1].type).toBe(NodeTypes.IF)\n      expect((b1.children[1] as IfNode).branches.length).toBe(2)\n      const b1b1: ElementNode = (b1.children[1] as IfNode).branches[0]\n        .children[0] as ElementNode\n      expect(b1b1.type).toBe(NodeTypes.ELEMENT)\n      expect(b1b1.tag).toBe('div')\n      expect(b1b1.children[0].type).toBe(NodeTypes.COMMENT)\n      expect((b1b1.children[0] as CommentNode).content).toBe('comment2')\n\n      const b1b2: IfBranchNode = (b1.children[1] as IfNode)\n        .branches[1] as IfBranchNode\n      expect(b1b2.children[0].type).toBe(NodeTypes.COMMENT)\n      expect((b1b2.children[0] as CommentNode).content).toBe(`comment3`)\n      expect(b1b2.children[1].type).toBe(NodeTypes.ELEMENT)\n      expect((b1b2.children[1] as ElementNode).tag).toBe(`b`)\n\n      expect(b1.children[2].type).toBe(NodeTypes.COMMENT)\n      expect((b1.children[2] as CommentNode).content).toBe(`comment4`)\n\n      expect(b1.children[3].type).toBe(NodeTypes.ELEMENT)\n      expect((b1.children[3] as ElementNode).tag).toBe(`p`)\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should parse correctly with comments: true in prod","suites":["compiler: v-if","codegen"],"updatePoint":{"line":718,"column":60},"line":718,"code":"    test('should parse correctly with comments: true in prod', () => {\n      __DEV__ = false\n      parseWithIfTransform(\n        `\n          <template v-if=\"ok\">\n            <!--comment1-->\n            <div v-if=\"ok2\">\n              <!--comment2-->\n            </div>\n            <!--comment3-->\n            <b v-else/>\n            <!--comment4-->\n            <p/>\n          </template>\n        `,\n        { comments: true }\n      )\n      __DEV__ = true\n    })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"v-on with v-if","suites":["compiler: v-if","codegen"],"updatePoint":{"line":739,"column":22},"line":739,"code":"  test('v-on with v-if', () => {\n    const {\n      node: { codegenNode }\n    } = parseWithIfTransform(\n      `<button v-on=\"{ click: clickEvent }\" v-if=\"true\">w/ v-if</button>`\n    )\n\n    expect((codegenNode.consequent as any).props.type).toBe(\n      NodeTypes.JS_CALL_EXPRESSION\n    )\n    expect((codegenNode.consequent as any).props.callee).toBe(MERGE_PROPS)\n    expect(\n      (codegenNode.consequent as any).props.arguments[0].properties[0].value\n        .content\n    ).toBe('0')\n    expect((codegenNode.consequent as any).props.arguments[1].callee).toBe(\n      TO_HANDLERS\n    )\n  })","file":"transforms/vIf.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on root element","suites":["compiler: v-memo transform"],"updatePoint":{"line":11,"column":23},"line":11,"code":"  test('on root element', () => {\n    expect(\n      baseCompile(`<div v-memo=\"[x]\"></div>`, {\n        mode: 'module',\n        prefixIdentifiers: true\n      }).code\n    ).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on normal element","suites":["compiler: v-memo transform"],"updatePoint":{"line":20,"column":25},"line":20,"code":"  test('on normal element', () => {\n    expect(compile(`<div v-memo=\"[x]\"></div>`)).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on component","suites":["compiler: v-memo transform"],"updatePoint":{"line":24,"column":20},"line":24,"code":"  test('on component', () => {\n    expect(compile(`<Comp v-memo=\"[x]\"></Comp>`)).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on v-if","suites":["compiler: v-memo transform"],"updatePoint":{"line":28,"column":15},"line":28,"code":"  test('on v-if', () => {\n    expect(\n      compile(\n        `<div v-if=\"ok\" v-memo=\"[x]\"><span>foo</span>bar</div>\n        <Comp v-else v-memo=\"[x]\"></Comp>`\n      )\n    ).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on v-for","suites":["compiler: v-memo transform"],"updatePoint":{"line":37,"column":16},"line":37,"code":"  test('on v-for', () => {\n    expect(\n      compile(\n        `<div v-for=\"{ x, y } in list\" :key=\"x\" v-memo=\"[x, y === z]\">\n          <span>foobar</span>\n        </div>`\n      )\n    ).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on template v-for","suites":["compiler: v-memo transform"],"updatePoint":{"line":47,"column":25},"line":47,"code":"  test('on template v-for', () => {\n    expect(\n      compile(\n        `<template v-for=\"{ x, y } in list\" :key=\"x\" v-memo=\"[x, y === z]\">\n          <span>foobar</span>\n        </template>`\n      )\n    ).toMatchSnapshot()\n  })","file":"transforms/vMemo.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple expression","suites":["compiler: transform v-model"],"updatePoint":{"line":46,"column":25},"line":46,"code":"  test('simple expression', () => {\n    const root = parseWithVModel('<input v-model=\"model\" />')\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'modelValue',\n        isStatic: true\n      },\n      value: {\n        content: 'model',\n        isStatic: false\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            content: 'model',\n            isStatic: false\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple expression (with prefixIdentifiers)","suites":["compiler: transform v-model"],"updatePoint":{"line":83,"column":50},"line":83,"code":"  test('simple expression (with prefixIdentifiers)', () => {\n    const root = parseWithVModel('<input v-model=\"model\" />', {\n      prefixIdentifiers: true\n    })\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'modelValue',\n        isStatic: true\n      },\n      value: {\n        content: '_ctx.model',\n        isStatic: false\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            content: '_ctx.model',\n            isStatic: false\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root, { mode: 'module' }).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"simple expression (with multilines)","suites":["compiler: transform v-model"],"updatePoint":{"line":123,"column":43},"line":123,"code":"  test('simple expression (with multilines)', () => {\n    const root = parseWithVModel('<input v-model=\"\\n model\\n.\\nfoo \\n\" />')\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'modelValue',\n        isStatic: true\n      },\n      value: {\n        content: '\\n model\\n.\\nfoo \\n',\n        isStatic: false\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            content: '\\n model\\n.\\nfoo \\n',\n            isStatic: false\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"compound expression","suites":["compiler: transform v-model"],"updatePoint":{"line":160,"column":27},"line":160,"code":"  test('compound expression', () => {\n    const root = parseWithVModel('<input v-model=\"model[index]\" />')\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'modelValue',\n        isStatic: true\n      },\n      value: {\n        content: 'model[index]',\n        isStatic: false\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            content: 'model[index]',\n            isStatic: false\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"compound expression (with prefixIdentifiers)","suites":["compiler: transform v-model"],"updatePoint":{"line":197,"column":52},"line":197,"code":"  test('compound expression (with prefixIdentifiers)', () => {\n    const root = parseWithVModel('<input v-model=\"model[index]\" />', {\n      prefixIdentifiers: true\n    })\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          {\n            content: '_ctx.model',\n            isStatic: false\n          },\n          '[',\n          {\n            content: '_ctx.index',\n            isStatic: false\n          },\n          ']'\n        ]\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:modelValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            children: [\n              {\n                content: '_ctx.model',\n                isStatic: false\n              },\n              '[',\n              {\n                content: '_ctx.index',\n                isStatic: false\n              },\n              ']'\n            ]\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root, { mode: 'module' }).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with argument","suites":["compiler: transform v-model"],"updatePoint":{"line":256,"column":21},"line":256,"code":"  test('with argument', () => {\n    const root = parseWithVModel('<input v-model:foo-value=\"model\" />')\n    const node = root.children[0] as ElementNode\n    const props = ((node.codegenNode as VNodeCall).props as ObjectExpression)\n      .properties\n    expect(props[0]).toMatchObject({\n      key: {\n        content: 'foo-value',\n        isStatic: true\n      },\n      value: {\n        content: 'model',\n        isStatic: false\n      }\n    })\n\n    expect(props[1]).toMatchObject({\n      key: {\n        content: 'onUpdate:fooValue',\n        isStatic: true\n      },\n      value: {\n        children: [\n          '$event => ((',\n          {\n            content: 'model',\n            isStatic: false\n          },\n          ') = $event)'\n        ]\n      }\n    })\n\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with dynamic argument","suites":["compiler: transform v-model"],"updatePoint":{"line":292,"column":29},"line":292,"code":"  test('with dynamic argument', () => {\n    const root = parseWithVModel('<input v-model:[value]=\"model\" />')\n    const node = root.children[0] as ElementNode\n    const props = (node.codegenNode as VNodeCall)\n      .props as unknown as CallExpression\n\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: 'value',\n                isStatic: false\n              },\n              value: {\n                content: 'model',\n                isStatic: false\n              }\n            },\n            {\n              key: {\n                children: [\n                  '\"onUpdate:\" + ',\n                  {\n                    content: 'value',\n                    isStatic: false\n                  }\n                ]\n              },\n              value: {\n                children: [\n                  '$event => ((',\n                  {\n                    content: 'model',\n                    isStatic: false\n                  },\n                  ') = $event)'\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    })\n\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with dynamic argument (with prefixIdentifiers)","suites":["compiler: transform v-model"],"updatePoint":{"line":344,"column":54},"line":344,"code":"  test('with dynamic argument (with prefixIdentifiers)', () => {\n    const root = parseWithVModel('<input v-model:[value]=\"model\" />', {\n      prefixIdentifiers: true\n    })\n    const node = root.children[0] as ElementNode\n    const props = (node.codegenNode as VNodeCall)\n      .props as unknown as CallExpression\n\n    expect(props).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: NORMALIZE_PROPS,\n      arguments: [\n        {\n          type: NodeTypes.JS_OBJECT_EXPRESSION,\n          properties: [\n            {\n              key: {\n                content: '_ctx.value',\n                isStatic: false\n              },\n              value: {\n                content: '_ctx.model',\n                isStatic: false\n              }\n            },\n            {\n              key: {\n                children: [\n                  '\"onUpdate:\" + ',\n                  {\n                    content: '_ctx.value',\n                    isStatic: false\n                  }\n                ]\n              },\n              value: {\n                children: [\n                  '$event => ((',\n                  {\n                    content: '_ctx.model',\n                    isStatic: false\n                  },\n                  ') = $event)'\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    })\n\n    expect(generate(root, { mode: 'module' }).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should cache update handler w/ cacheHandlers: true","suites":["compiler: transform v-model"],"updatePoint":{"line":398,"column":58},"line":398,"code":"  test('should cache update handler w/ cacheHandlers: true', () => {\n    const root = parseWithVModel('<input v-model=\"foo\" />', {\n      prefixIdentifiers: true,\n      cacheHandlers: true\n    })\n    expect(root.cached).toBe(1)\n    const codegen = (root.children[0] as PlainElementNode)\n      .codegenNode as VNodeCall\n    // should not list cached prop in dynamicProps\n    expect(codegen.dynamicProps).toBe(`[\"modelValue\"]`)\n    expect((codegen.props as ObjectExpression).properties[1].value.type).toBe(\n      NodeTypes.JS_CACHE_EXPRESSION\n    )\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not cache update handler if it refers v-for scope variables","suites":["compiler: transform v-model"],"updatePoint":{"line":413,"column":74},"line":413,"code":"  test('should not cache update handler if it refers v-for scope variables', () => {\n    const root = parseWithVModel(\n      '<input v-for=\"i in list\" v-model=\"foo[i]\" />',\n      {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      }\n    )\n    expect(root.cached).toBe(0)\n    const codegen = (\n      (root.children[0] as ForNode).children[0] as PlainElementNode\n    ).codegenNode as VNodeCall\n    expect(codegen.dynamicProps).toBe(`[\"modelValue\", \"onUpdate:modelValue\"]`)\n    expect(\n      (codegen.props as ObjectExpression).properties[1].value.type\n    ).not.toBe(NodeTypes.JS_CACHE_EXPRESSION)\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not cache update handler if it inside v-once","suites":["compiler: transform v-model"],"updatePoint":{"line":431,"column":59},"line":431,"code":"  test('should not cache update handler if it inside v-once', () => {\n    const root = parseWithVModel('<div v-once><input v-model=\"foo\" /></div>', {\n      prefixIdentifiers: true,\n      cacheHandlers: true\n    })\n    expect(root.cached).not.toBe(2)\n    expect(root.cached).toBe(1)\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should mark update handler dynamic if it refers slot scope variables","suites":["compiler: transform v-model"],"updatePoint":{"line":440,"column":76},"line":440,"code":"  test('should mark update handler dynamic if it refers slot scope variables', () => {\n    const root = parseWithVModel(\n      '<Comp v-slot=\"{ foo }\"><input v-model=\"foo.bar\"/></Comp>',\n      {\n        prefixIdentifiers: true\n      }\n    )\n    const codegen = (\n      (root.children[0] as ComponentNode).children[0] as PlainElementNode\n    ).codegenNode as VNodeCall\n    expect(codegen.dynamicProps).toBe(`[\"modelValue\", \"onUpdate:modelValue\"]`)\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should generate modelModifiers for component v-model","suites":["compiler: transform v-model"],"updatePoint":{"line":453,"column":60},"line":453,"code":"  test('should generate modelModifiers for component v-model', () => {\n    const root = parseWithVModel('<Comp v-model.trim.bar-baz=\"foo\" />', {\n      prefixIdentifiers: true\n    })\n    const vnodeCall = (root.children[0] as ComponentNode)\n      .codegenNode as VNodeCall\n    // props\n    expect(vnodeCall.props).toMatchObject({\n      properties: [\n        { key: { content: `modelValue` } },\n        { key: { content: `onUpdate:modelValue` } },\n        {\n          key: { content: 'modelModifiers' },\n          value: { content: `{ trim: true, \"bar-baz\": true }`, isStatic: false }\n        }\n      ]\n    })\n    // should NOT include modelModifiers in dynamicPropNames because it's never\n    // gonna change\n    expect(vnodeCall.dynamicProps).toBe(`[\"modelValue\", \"onUpdate:modelValue\"]`)\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should generate modelModifiers for component v-model with arguments","suites":["compiler: transform v-model"],"updatePoint":{"line":475,"column":75},"line":475,"code":"  test('should generate modelModifiers for component v-model with arguments', () => {\n    const root = parseWithVModel(\n      '<Comp v-model:foo.trim=\"foo\" v-model:bar.number=\"bar\" />',\n      {\n        prefixIdentifiers: true\n      }\n    )\n    const vnodeCall = (root.children[0] as ComponentNode)\n      .codegenNode as VNodeCall\n    // props\n    expect(vnodeCall.props).toMatchObject({\n      properties: [\n        { key: { content: `foo` } },\n        { key: { content: `onUpdate:foo` } },\n        {\n          key: { content: 'fooModifiers' },\n          value: { content: `{ trim: true }`, isStatic: false }\n        },\n        { key: { content: `bar` } },\n        { key: { content: `onUpdate:bar` } },\n        {\n          key: { content: 'barModifiers' },\n          value: { content: `{ number: true }`, isStatic: false }\n        }\n      ]\n    })\n    // should NOT include modelModifiers in dynamicPropNames because it's never\n    // gonna change\n    expect(vnodeCall.dynamicProps).toBe(\n      `[\"foo\", \"onUpdate:foo\", \"bar\", \"onUpdate:bar\"]`\n    )\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"missing expression","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":509,"column":28},"line":509,"code":"    test('missing expression', () => {\n      const onError = vi.fn()\n      parseWithVModel('<span v-model />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_MODEL_NO_EXPRESSION\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty expression","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":521,"column":26},"line":521,"code":"    test('empty expression', () => {\n      const onError = vi.fn()\n      parseWithVModel('<span v-model=\"\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"mal-formed expression","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":533,"column":31},"line":533,"code":"    test('mal-formed expression', () => {\n      const onError = vi.fn()\n      parseWithVModel('<span v-model=\"a + b\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"allow unicode","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":545,"column":23},"line":545,"code":"    test('allow unicode', () => {\n      const onError = vi.fn()\n      parseWithVModel('<span v-model=\".\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(0)\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"used on scope variable","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":552,"column":32},"line":552,"code":"    test('used on scope variable', () => {\n      const onError = vi.fn()\n      parseWithVModel('<span v-for=\"i in list\" v-model=\"i\" />', {\n        onError,\n        prefixIdentifiers: true\n      })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"used on props","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":567,"column":23},"line":567,"code":"    test('used on props', () => {\n      const onError = vi.fn()\n      parseWithVModel('<div v-model=\"p\" />', {\n        onError,\n        bindingMetadata: {\n          p: BindingTypes.PROPS\n        }\n      })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: ErrorCodes.X_V_MODEL_ON_PROPS\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"basic","suites":["compiler: transform v-on"],"updatePoint":{"line":34,"column":13},"line":34,"code":"  test('basic', () => {\n    const { node } = parseWithVOn(`<div v-on:click=\"onClick\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            content: `onClick`,\n            isStatic: true,\n            loc: {\n              start: {\n                line: 1,\n                column: 11\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          value: {\n            content: `onClick`,\n            isStatic: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic arg","suites":["compiler: transform v-on"],"updatePoint":{"line":72,"column":19},"line":72,"code":"  test('dynamic arg', () => {\n    const { node } = parseWithVOn(`<div v-on:[event]=\"handler\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              `_${helperNameMap[TO_HANDLER_KEY]}(`,\n              { content: `event` },\n              `)`\n            ]\n          },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `handler`,\n            isStatic: false\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic arg with prefixing","suites":["compiler: transform v-on"],"updatePoint":{"line":95,"column":34},"line":95,"code":"  test('dynamic arg with prefixing', () => {\n    const { node } = parseWithVOn(`<div v-on:[event]=\"handler\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              `_${helperNameMap[TO_HANDLER_KEY]}(`,\n              { content: `_ctx.event` },\n              `)`\n            ]\n          },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `_ctx.handler`,\n            isStatic: false\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamic arg with complex exp prefixing","suites":["compiler: transform v-on"],"updatePoint":{"line":120,"column":46},"line":120,"code":"  test('dynamic arg with complex exp prefixing', () => {\n    const { node } = parseWithVOn(`<div v-on:[event(foo)]=\"handler\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              `_${helperNameMap[TO_HANDLER_KEY]}(`,\n              { content: `_ctx.event` },\n              `(`,\n              { content: `_ctx.foo` },\n              `)`,\n              `)`\n            ]\n          },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `_ctx.handler`,\n            isStatic: false\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should wrap as function if expression is inline statement","suites":["compiler: transform v-on"],"updatePoint":{"line":148,"column":65},"line":148,"code":"  test('should wrap as function if expression is inline statement', () => {\n    const { node } = parseWithVOn(`<div @click=\"i++\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`$event => (`, { content: `i++` }, `)`]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle multiple inline statement","suites":["compiler: transform v-on"],"updatePoint":{"line":163,"column":47},"line":163,"code":"  test('should handle multiple inline statement', () => {\n    const { node } = parseWithVOn(`<div @click=\"foo();bar()\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            // should wrap with `{` for multiple statements\n            // in this case the return value is discarded and the behavior is\n            // consistent with 2.x\n            children: [`$event => {`, { content: `foo();bar()` }, `}`]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should handle multi-line statement","suites":["compiler: transform v-on"],"updatePoint":{"line":181,"column":42},"line":181,"code":"  test('should handle multi-line statement', () => {\n    const { node } = parseWithVOn(`<div @click=\"\\nfoo();\\nbar()\\n\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            // should wrap with `{` for multiple statements\n            // in this case the return value is discarded and the behavior is\n            // consistent with 2.x\n            children: [`$event => {`, { content: `\\nfoo();\\nbar()\\n` }, `}`]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline statement w/ prefixIdentifiers: true","suites":["compiler: transform v-on"],"updatePoint":{"line":199,"column":51},"line":199,"code":"  test('inline statement w/ prefixIdentifiers: true', () => {\n    const { node } = parseWithVOn(`<div @click=\"foo($event)\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              `$event => (`,\n              {\n                type: NodeTypes.COMPOUND_EXPRESSION,\n                children: [\n                  { content: `_ctx.foo` },\n                  `(`,\n                  // should NOT prefix $event\n                  { content: `$event` },\n                  `)`\n                ]\n              },\n              `)`\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple inline statements w/ prefixIdentifiers: true","suites":["compiler: transform v-on"],"updatePoint":{"line":229,"column":61},"line":229,"code":"  test('multiple inline statements w/ prefixIdentifiers: true', () => {\n    const { node } = parseWithVOn(`<div @click=\"foo($event);bar()\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              `$event => {`,\n              {\n                children: [\n                  { content: `_ctx.foo` },\n                  `(`,\n                  // should NOT prefix $event\n                  { content: `$event` },\n                  `);`,\n                  { content: `_ctx.bar` },\n                  `()`\n                ]\n              },\n              `}`\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT wrap as function if expression is already function expression","suites":["compiler: transform v-on"],"updatePoint":{"line":260,"column":80},"line":260,"code":"  test('should NOT wrap as function if expression is already function expression', () => {\n    const { node } = parseWithVOn(`<div @click=\"$event => foo($event)\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `$event => foo($event)`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT wrap as function if expression is already function expression (with Typescript)","suites":["compiler: transform v-on"],"updatePoint":{"line":275,"column":98},"line":275,"code":"  test('should NOT wrap as function if expression is already function expression (with Typescript)', () => {\n    const { node } = parseWithVOn(`<div @click=\"(e: any): any => foo(e)\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `(e: any): any => foo(e)`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT wrap as function if expression is already function expression (with newlines)","suites":["compiler: transform v-on"],"updatePoint":{"line":290,"column":96},"line":290,"code":"  test('should NOT wrap as function if expression is already function expression (with newlines)', () => {\n    const { node } = parseWithVOn(\n      `<div @click=\"\n      $event => {\n        foo($event)\n      }\n    \"/>`\n    )\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `\n      $event => {\n        foo($event)\n      }\n    `\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT wrap as function if expression is already function expression (with newlines + function keyword)","suites":["compiler: transform v-on"],"updatePoint":{"line":315,"column":115},"line":315,"code":"  test('should NOT wrap as function if expression is already function expression (with newlines + function keyword)', () => {\n    const { node } = parseWithVOn(\n      `<div @click=\"\n      function($event) {\n        foo($event)\n      }\n    \"/>`\n    )\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `\n      function($event) {\n        foo($event)\n      }\n    `\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT wrap as function if expression is complex member expression","suites":["compiler: transform v-on"],"updatePoint":{"line":340,"column":78},"line":340,"code":"  test('should NOT wrap as function if expression is complex member expression', () => {\n    const { node } = parseWithVOn(`<div @click=\"a['b' + c]\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `a['b' + c]`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"complex member expression w/ prefixIdentifiers: true","suites":["compiler: transform v-on"],"updatePoint":{"line":355,"column":60},"line":355,"code":"  test('complex member expression w/ prefixIdentifiers: true', () => {\n    const { node } = parseWithVOn(`<div @click=\"a['b' + c]\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              { content: `_ctx.a` },\n              `['b' + `,\n              { content: `_ctx.c` },\n              `]`\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"function expression w/ prefixIdentifiers: true","suites":["compiler: transform v-on"],"updatePoint":{"line":377,"column":54},"line":377,"code":"  test('function expression w/ prefixIdentifiers: true', () => {\n    const { node } = parseWithVOn(`<div @click=\"e => foo(e)\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: { content: `onClick` },\n          value: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [\n              { content: `e` },\n              ` => `,\n              { content: `_ctx.foo` },\n              `(`,\n              { content: `e` },\n              `)`\n            ]\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should error if no expression AND no modifier","suites":["compiler: transform v-on"],"updatePoint":{"line":401,"column":53},"line":401,"code":"  test('should error if no expression AND no modifier', () => {\n    const onError = vi.fn()\n    parseWithVOn(`<div v-on:click />`, { onError })\n    expect(onError.mock.calls[0][0]).toMatchObject({\n      code: ErrorCodes.X_V_ON_NO_EXPRESSION,\n      loc: {\n        start: {\n          line: 1,\n          column: 6\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should NOT error if no expression but has modifier","suites":["compiler: transform v-on"],"updatePoint":{"line":419,"column":58},"line":419,"code":"  test('should NOT error if no expression but has modifier', () => {\n    const onError = vi.fn()\n    parseWithVOn(`<div v-on:click.prevent />`, { onError })\n    expect(onError).not.toHaveBeenCalled()\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"case conversion for kebab-case events","suites":["compiler: transform v-on"],"updatePoint":{"line":425,"column":45},"line":425,"code":"  test('case conversion for kebab-case events', () => {\n    const { node } = parseWithVOn(`<div v-on:foo-bar=\"onMount\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            content: `onFooBar`\n          },\n          value: {\n            content: `onMount`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"case conversion for vnode hooks","suites":["compiler: transform v-on"],"updatePoint":{"line":442,"column":39},"line":442,"code":"  test('case conversion for vnode hooks', () => {\n    const { node } = parseWithVOn(`<div v-on:vnode-mounted=\"onMount\"/>`)\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            content: `onVnodeMounted`\n          },\n          value: {\n            content: `onMount`\n          }\n        }\n      ]\n    })\n    expect('@vnode-* hooks in templates are deprecated').toHaveBeenWarned()\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"vue: prefixed events","suites":["compiler: transform v-on"],"updatePoint":{"line":459,"column":28},"line":459,"code":"  test('vue: prefixed events', () => {\n    const { node } = parseWithVOn(\n      `<div v-on:vue:mounted=\"onMount\" @vue:before-update=\"onBeforeUpdate\" />`\n    )\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      properties: [\n        {\n          key: {\n            content: `onVnodeMounted`\n          },\n          value: {\n            content: `onMount`\n          }\n        },\n        {\n          key: {\n            content: `onVnodeBeforeUpdate`\n          },\n          value: {\n            content: `onBeforeUpdate`\n          }\n        }\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"empty handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":486,"column":23},"line":486,"code":"    test('empty handler', () => {\n      const { root, node } = parseWithVOn(`<div v-on:click.prevent />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      })\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `() => {}`\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"member expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":507,"column":35},"line":507,"code":"    test('member expression handler', () => {\n      const { root, node } = parseWithVOn(`<div v-on:click=\"foo\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      })\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [\n            `(...args) => (`,\n            { content: `_ctx.foo && _ctx.foo(...args)` },\n            `)`\n          ]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"compound member expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":532,"column":44},"line":532,"code":"    test('compound member expression handler', () => {\n      const { root, node } = parseWithVOn(`<div v-on:click=\"foo.bar\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      })\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [\n            `(...args) => (`,\n            {\n              children: [\n                { content: `_ctx.foo` },\n                `.`,\n                { content: `bar` },\n                ` && `,\n                { content: `_ctx.foo` },\n                `.`,\n                { content: `bar` },\n                `(...args)`\n              ]\n            },\n            `)`\n          ]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"bail on component member expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":568,"column":53},"line":568,"code":"    test('bail on component member expression handler', () => {\n      const { root } = parseWithVOn(`<comp v-on:click=\"foo\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true,\n        isNativeTag: tag => tag === 'div'\n      })\n      expect(root.cached).toBe(0)\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not be cached inside v-once","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":577,"column":44},"line":577,"code":"    test('should not be cached inside v-once', () => {\n      const { root } = parseWithVOn(\n        `<div v-once><div v-on:click=\"foo\"/></div>`,\n        {\n          prefixIdentifiers: true,\n          cacheHandlers: true\n        }\n      )\n      expect(root.cached).not.toBe(2)\n      expect(root.cached).toBe(1)\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline function expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":589,"column":44},"line":589,"code":"    test('inline function expression handler', () => {\n      const { root, node } = parseWithVOn(`<div v-on:click=\"() => foo()\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      })\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [`() => `, { content: `_ctx.foo` }, `()`]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline async arrow function expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":610,"column":56},"line":610,"code":"    test('inline async arrow function expression handler', () => {\n      const { root, node } = parseWithVOn(\n        `<div v-on:click=\"async () => await foo()\" />`,\n        {\n          prefixIdentifiers: true,\n          cacheHandlers: true\n        }\n      )\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [`async () => await `, { content: `_ctx.foo` }, `()`]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline async function expression handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":634,"column":50},"line":634,"code":"    test('inline async function expression handler', () => {\n      const { root, node } = parseWithVOn(\n        `<div v-on:click=\"async function () { await foo() } \" />`,\n        {\n          prefixIdentifiers: true,\n          cacheHandlers: true\n        }\n      )\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [\n            `async function () { await `,\n            { content: `_ctx.foo` },\n            `() } `\n          ]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inline statement handler","suites":["compiler: transform v-on","cacheHandler"],"updatePoint":{"line":662,"column":34},"line":662,"code":"    test('inline statement handler', () => {\n      const { root, node } = parseWithVOn(`<div v-on:click=\"foo++\" />`, {\n        prefixIdentifiers: true,\n        cacheHandlers: true\n      })\n      expect(root.cached).toBe(1)\n      expect(root.cached).toBe(1)\n      const vnodeCall = node.codegenNode as VNodeCall\n      // should not treat cached handler as dynamicProp, so no flags\n      expect(vnodeCall.patchFlag).toBeUndefined()\n      expect(\n        (vnodeCall.props as ObjectExpression).properties[0].value\n      ).toMatchObject({\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.COMPOUND_EXPRESSION,\n          children: [\n            `$event => (`,\n            { children: [{ content: `_ctx.foo` }, `++`] },\n            `)`\n          ]\n        }\n      })\n    })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"as root node","suites":["compiler: v-once transform"],"updatePoint":{"line":23,"column":20},"line":23,"code":"  test('as root node', () => {\n    const root = transformWithOnce(`<div :id=\"foo\" v-once />`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect(root.codegenNode).toMatchObject({\n      type: NodeTypes.JS_CACHE_EXPRESSION,\n      index: 0,\n      value: {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on nested plain element","suites":["compiler: v-once transform"],"updatePoint":{"line":38,"column":31},"line":38,"code":"  test('on nested plain element', () => {\n    const root = transformWithOnce(`<div><div :id=\"foo\" v-once /></div>`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect((root.children[0] as any).children[0].codegenNode).toMatchObject({\n      type: NodeTypes.JS_CACHE_EXPRESSION,\n      index: 0,\n      value: {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on component","suites":["compiler: v-once transform"],"updatePoint":{"line":53,"column":20},"line":53,"code":"  test('on component', () => {\n    const root = transformWithOnce(`<div><Comp :id=\"foo\" v-once /></div>`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect((root.children[0] as any).children[0].codegenNode).toMatchObject({\n      type: NodeTypes.JS_CACHE_EXPRESSION,\n      index: 0,\n      value: {\n        type: NodeTypes.VNODE_CALL,\n        tag: `_component_Comp`\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on slot outlet","suites":["compiler: v-once transform"],"updatePoint":{"line":68,"column":22},"line":68,"code":"  test('on slot outlet', () => {\n    const root = transformWithOnce(`<div><slot v-once /></div>`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect((root.children[0] as any).children[0].codegenNode).toMatchObject({\n      type: NodeTypes.JS_CACHE_EXPRESSION,\n      index: 0,\n      value: {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: RENDER_SLOT\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"inside v-once","suites":["compiler: v-once transform"],"updatePoint":{"line":84,"column":21},"line":84,"code":"  test('inside v-once', () => {\n    const root = transformWithOnce(`<div v-once><div v-once/></div>`)\n    expect(root.cached).not.toBe(2)\n    expect(root.cached).toBe(1)\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with hoistStatic: true","suites":["compiler: v-once transform"],"updatePoint":{"line":91,"column":30},"line":91,"code":"  test('with hoistStatic: true', () => {\n    const root = transformWithOnce(`<div><div v-once /></div>`, {\n      hoistStatic: true\n    })\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect(root.hoists.length).toBe(0)\n    expect((root.children[0] as any).children[0].codegenNode).toMatchObject({\n      type: NodeTypes.JS_CACHE_EXPRESSION,\n      index: 0,\n      value: {\n        type: NodeTypes.VNODE_CALL,\n        tag: `\"div\"`\n      }\n    })\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with v-if/else","suites":["compiler: v-once transform"],"updatePoint":{"line":109,"column":22},"line":109,"code":"  test('with v-if/else', () => {\n    const root = transformWithOnce(`<div v-if=\"BOOLEAN\" v-once /><p v-else/>`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect(root.children[0]).toMatchObject({\n      type: NodeTypes.IF,\n      // should cache the entire v-if/else-if/else expression, not just a single branch\n      codegenNode: {\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        value: {\n          type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n          consequent: {\n            type: NodeTypes.VNODE_CALL,\n            tag: `\"div\"`\n          },\n          alternate: {\n            type: NodeTypes.VNODE_CALL,\n            tag: `\"p\"`\n          }\n        }\n      }\n    })\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"with v-for","suites":["compiler: v-once transform"],"updatePoint":{"line":133,"column":18},"line":133,"code":"  test('with v-for', () => {\n    const root = transformWithOnce(`<div v-for=\"i in list\" v-once />`)\n    expect(root.cached).toBe(1)\n    expect(root.helpers).toContain(SET_BLOCK_TRACKING)\n    expect(root.children[0]).toMatchObject({\n      type: NodeTypes.FOR,\n      // should cache the entire v-for expression, not just a single branch\n      codegenNode: {\n        type: NodeTypes.JS_CACHE_EXPRESSION\n      }\n    })\n  })","file":"transforms/vOnce.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"implicit default slot","suites":["compiler: transform component slots"],"updatePoint":{"line":90,"column":29},"line":90,"code":"  test('implicit default slot', () => {\n    const { root, slots } = parseWithSlots(`<Comp><div/></Comp>`, {\n      prefixIdentifiers: true\n    })\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        default: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: undefined,\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `div`\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on-component default slot","suites":["compiler: transform component slots"],"updatePoint":{"line":111,"column":33},"line":111,"code":"  test('on-component default slot', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp v-slot=\"{ foo }\">{{ foo }}{{ bar }}</Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        default: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`{ `, { content: `foo` }, ` }`]\n          },\n          returns: [\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `foo`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.bar`\n              }\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on component named slot","suites":["compiler: transform component slots"],"updatePoint":{"line":144,"column":31},"line":144,"code":"  test('on component named slot', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp v-slot:named=\"{ foo }\">{{ foo }}{{ bar }}</Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        named: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`{ `, { content: `foo` }, ` }`]\n          },\n          returns: [\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `foo`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.bar`\n              }\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"template named slots","suites":["compiler: transform component slots"],"updatePoint":{"line":177,"column":28},"line":177,"code":"  test('template named slots', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template v-slot:one=\"{ foo }\">\n          {{ foo }}{{ bar }}\n        </template>\n        <template #two=\"{ bar }\">\n          {{ foo }}{{ bar }}\n        </template>\n      </Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        one: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`{ `, { content: `foo` }, ` }`]\n          },\n          returns: [\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `foo`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.bar`\n              }\n            }\n          ]\n        },\n        two: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`{ `, { content: `bar` }, ` }`]\n          },\n          returns: [\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.foo`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `bar`\n              }\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"on component dynamically named slot","suites":["compiler: transform component slots"],"updatePoint":{"line":238,"column":43},"line":238,"code":"  test('on component dynamically named slot', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp v-slot:[named]=\"{ foo }\">{{ foo }}{{ bar }}</Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher(\n        {\n          '[_ctx.named]': {\n            type: NodeTypes.JS_FUNCTION_EXPRESSION,\n            params: {\n              type: NodeTypes.COMPOUND_EXPRESSION,\n              children: [`{ `, { content: `foo` }, ` }`]\n            },\n            returns: [\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `foo`\n                }\n              },\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `_ctx.bar`\n                }\n              }\n            ]\n          }\n        },\n        true\n      )\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slots w/ implicit default slot","suites":["compiler: transform component slots"],"updatePoint":{"line":274,"column":44},"line":274,"code":"  test('named slots w/ implicit default slot', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template #one>foo</template>bar<span/>\n      </Comp>`\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        one: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: undefined,\n          returns: [\n            {\n              type: NodeTypes.TEXT,\n              content: `foo`\n            }\n          ]\n        },\n        default: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: undefined,\n          returns: [\n            {\n              type: NodeTypes.TEXT,\n              content: `bar`\n            },\n            {\n              type: NodeTypes.ELEMENT,\n              tag: `span`\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"dynamically named slots","suites":["compiler: transform component slots"],"updatePoint":{"line":311,"column":31},"line":311,"code":"  test('dynamically named slots', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template v-slot:[one]=\"{ foo }\">\n          {{ foo }}{{ bar }}\n        </template>\n        <template #[two]=\"{ bar }\">\n          {{ foo }}{{ bar }}\n        </template>\n      </Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher(\n        {\n          '[_ctx.one]': {\n            type: NodeTypes.JS_FUNCTION_EXPRESSION,\n            params: {\n              type: NodeTypes.COMPOUND_EXPRESSION,\n              children: [`{ `, { content: `foo` }, ` }`]\n            },\n            returns: [\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `foo`\n                }\n              },\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `_ctx.bar`\n                }\n              }\n            ]\n          },\n          '[_ctx.two]': {\n            type: NodeTypes.JS_FUNCTION_EXPRESSION,\n            params: {\n              type: NodeTypes.COMPOUND_EXPRESSION,\n              children: [`{ `, { content: `bar` }, ` }`]\n            },\n            returns: [\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `_ctx.foo`\n                }\n              },\n              {\n                type: NodeTypes.INTERPOLATION,\n                content: {\n                  content: `bar`\n                }\n              }\n            ]\n          }\n        },\n        true\n      )\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"nested slots scoping","suites":["compiler: transform component slots"],"updatePoint":{"line":375,"column":28},"line":375,"code":"  test('nested slots scoping', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template #default=\"{ foo }\">\n          <Inner v-slot=\"{ bar }\">\n            {{ foo }}{{ bar }}{{ baz }}\n          </Inner>\n          {{ foo }}{{ bar }}{{ baz }}\n        </template>\n      </Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject(\n      createSlotMatcher({\n        default: {\n          type: NodeTypes.JS_FUNCTION_EXPRESSION,\n          params: {\n            type: NodeTypes.COMPOUND_EXPRESSION,\n            children: [`{ `, { content: `foo` }, ` }`]\n          },\n          returns: [\n            {\n              type: NodeTypes.ELEMENT,\n              codegenNode: {\n                type: NodeTypes.VNODE_CALL,\n                tag: `_component_Inner`,\n                props: undefined,\n                children: createSlotMatcher(\n                  {\n                    default: {\n                      type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                      params: {\n                        type: NodeTypes.COMPOUND_EXPRESSION,\n                        children: [`{ `, { content: `bar` }, ` }`]\n                      },\n                      returns: [\n                        {\n                          type: NodeTypes.INTERPOLATION,\n                          content: {\n                            content: `foo`\n                          }\n                        },\n                        {\n                          type: NodeTypes.INTERPOLATION,\n                          content: {\n                            content: `bar`\n                          }\n                        },\n                        {\n                          type: NodeTypes.INTERPOLATION,\n                          content: {\n                            content: `_ctx.baz`\n                          }\n                        }\n                      ]\n                    }\n                  },\n                  true\n                ),\n                // nested slot should be forced dynamic, since scope variables\n                // are not tracked as dependencies of the slot.\n                patchFlag: genFlagText(PatchFlags.DYNAMIC_SLOTS)\n              }\n            },\n            // test scope\n            {\n              type: NodeTypes.TEXT,\n              content: ` `\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `foo`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.bar`\n              }\n            },\n            {\n              type: NodeTypes.INTERPOLATION,\n              content: {\n                content: `_ctx.baz`\n              }\n            }\n          ]\n        }\n      })\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should force dynamic when inside v-for","suites":["compiler: transform component slots"],"updatePoint":{"line":469,"column":46},"line":469,"code":"  test('should force dynamic when inside v-for', () => {\n    const { root } = parseWithSlots(\n      `<div v-for=\"i in list\">\n        <Comp v-slot=\"bar\">foo</Comp>\n      </div>`\n    )\n    const div = ((root.children[0] as ForNode).children[0] as ElementNode)\n      .codegenNode as any\n    const comp = div.children[0]\n    expect(comp.codegenNode.patchFlag).toBe(\n      genFlagText(PatchFlags.DYNAMIC_SLOTS)\n    )\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should only force dynamic slots when actually using scope vars w/ prefixIdentifiers: true","suites":["compiler: transform component slots"],"updatePoint":{"line":483,"column":97},"line":483,"code":"  test('should only force dynamic slots when actually using scope vars w/ prefixIdentifiers: true', () => {\n    function assertDynamicSlots(template: string, shouldForce: boolean) {\n      const { root } = parseWithSlots(template, { prefixIdentifiers: true })\n      let flag: any\n      if (root.children[0].type === NodeTypes.FOR) {\n        const div = (root.children[0].children[0] as ElementNode)\n          .codegenNode as any\n        const comp = div.children[0]\n        flag = comp.codegenNode.patchFlag\n      } else {\n        const innerComp = (root.children[0] as ComponentNode)\n          .children[0] as ComponentNode\n        flag = (innerComp.codegenNode as VNodeCall).patchFlag\n      }\n      if (shouldForce) {\n        expect(flag).toBe(genFlagText(PatchFlags.DYNAMIC_SLOTS))\n      } else {\n        expect(flag).toBeUndefined()\n      }\n    }\n\n    assertDynamicSlots(\n      `<div v-for=\"i in list\">\n        <Comp v-slot=\"bar\">foo</Comp>\n      </div>`,\n      false\n    )\n\n    assertDynamicSlots(\n      `<div v-for=\"i in list\">\n        <Comp v-slot=\"bar\">{{ i }}</Comp>\n      </div>`,\n      true\n    )\n\n    // reference the component's own slot variable should not force dynamic slots\n    assertDynamicSlots(\n      `<Comp v-slot=\"foo\">\n        <Comp v-slot=\"bar\">{{ bar }}</Comp>\n      </Comp>`,\n      false\n    )\n\n    assertDynamicSlots(\n      `<Comp v-slot=\"foo\">\n        <Comp v-slot=\"bar\">{{ foo }}</Comp>\n      </Comp>`,\n      true\n    )\n\n    // #2564\n    assertDynamicSlots(\n      `<div v-for=\"i in list\">\n        <Comp v-slot=\"bar\"><button @click=\"fn(i)\" /></Comp>\n      </div>`,\n      true\n    )\n\n    assertDynamicSlots(\n      `<div v-for=\"i in list\">\n        <Comp v-slot=\"bar\"><button @click=\"fn()\" /></Comp>\n      </div>`,\n      false\n    )\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot with v-if","suites":["compiler: transform component slots"],"updatePoint":{"line":549,"column":28},"line":549,"code":"  test('named slot with v-if', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template #one v-if=\"ok\">hello</template>\n      </Comp>`\n    )\n    expect(slots).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_SLOTS,\n      arguments: [\n        createObjectMatcher({\n          _: `[2 /* DYNAMIC */]`\n        }),\n        {\n          type: NodeTypes.JS_ARRAY_EXPRESSION,\n          elements: [\n            {\n              type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n              test: { content: `ok` },\n              consequent: createObjectMatcher({\n                name: `one`,\n                fn: {\n                  type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                  returns: [{ type: NodeTypes.TEXT, content: `hello` }]\n                },\n                key: `0`\n              }),\n              alternate: {\n                content: `undefined`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n    expect((root as any).children[0].codegenNode.patchFlag).toMatch(\n      PatchFlags.DYNAMIC_SLOTS + ''\n    )\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot with v-if + prefixIdentifiers: true","suites":["compiler: transform component slots"],"updatePoint":{"line":591,"column":54},"line":591,"code":"  test('named slot with v-if + prefixIdentifiers: true', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template #one=\"props\" v-if=\"ok\">{{ props }}</template>\n      </Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_SLOTS,\n      arguments: [\n        createObjectMatcher({\n          _: `[2 /* DYNAMIC */]`\n        }),\n        {\n          type: NodeTypes.JS_ARRAY_EXPRESSION,\n          elements: [\n            {\n              type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n              test: { content: `_ctx.ok` },\n              consequent: createObjectMatcher({\n                name: `one`,\n                fn: {\n                  type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                  params: { content: `props` },\n                  returns: [\n                    {\n                      type: NodeTypes.INTERPOLATION,\n                      content: { content: `props` }\n                    }\n                  ]\n                },\n                key: `0`\n              }),\n              alternate: {\n                content: `undefined`,\n                isStatic: false\n              }\n            }\n          ]\n        }\n      ]\n    })\n    expect((root as any).children[0].codegenNode.patchFlag).toMatch(\n      PatchFlags.DYNAMIC_SLOTS + ''\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot with v-if + v-else-if + v-else","suites":["compiler: transform component slots"],"updatePoint":{"line":640,"column":49},"line":640,"code":"  test('named slot with v-if + v-else-if + v-else', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template #one v-if=\"ok\">foo</template>\n        <template #two=\"props\" v-else-if=\"orNot\">bar</template>\n        <template #one v-else>baz</template>\n      </Comp>`\n    )\n    expect(slots).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_SLOTS,\n      arguments: [\n        createObjectMatcher({\n          _: `[2 /* DYNAMIC */]`\n        }),\n        {\n          type: NodeTypes.JS_ARRAY_EXPRESSION,\n          elements: [\n            {\n              type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n              test: { content: `ok` },\n              consequent: createObjectMatcher({\n                name: `one`,\n                fn: {\n                  type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                  params: undefined,\n                  returns: [{ type: NodeTypes.TEXT, content: `foo` }]\n                },\n                key: `0`\n              }),\n              alternate: {\n                type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n                test: { content: `orNot` },\n                consequent: createObjectMatcher({\n                  name: `two`,\n                  fn: {\n                    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                    params: { content: `props` },\n                    returns: [{ type: NodeTypes.TEXT, content: `bar` }]\n                  },\n                  key: `1`\n                }),\n                alternate: createObjectMatcher({\n                  name: `one`,\n                  fn: {\n                    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                    params: undefined,\n                    returns: [{ type: NodeTypes.TEXT, content: `baz` }]\n                  },\n                  key: `2`\n                })\n              }\n            }\n          ]\n        }\n      ]\n    })\n    expect((root as any).children[0].codegenNode.patchFlag).toMatch(\n      PatchFlags.DYNAMIC_SLOTS + ''\n    )\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named slot with v-for w/ prefixIdentifiers: true","suites":["compiler: transform component slots"],"updatePoint":{"line":703,"column":56},"line":703,"code":"  test('named slot with v-for w/ prefixIdentifiers: true', () => {\n    const { root, slots } = parseWithSlots(\n      `<Comp>\n        <template v-for=\"name in list\" #[name]>{{ name }}</template>\n      </Comp>`,\n      { prefixIdentifiers: true }\n    )\n    expect(slots).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_SLOTS,\n      arguments: [\n        createObjectMatcher({\n          _: `[2 /* DYNAMIC */]`\n        }),\n        {\n          type: NodeTypes.JS_ARRAY_EXPRESSION,\n          elements: [\n            {\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              callee: RENDER_LIST,\n              arguments: [\n                { content: `_ctx.list` },\n                {\n                  type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                  params: [{ content: `name` }],\n                  returns: createObjectMatcher({\n                    name: `[name]`,\n                    fn: {\n                      type: NodeTypes.JS_FUNCTION_EXPRESSION,\n                      returns: [\n                        {\n                          type: NodeTypes.INTERPOLATION,\n                          content: { content: `name`, isStatic: false }\n                        }\n                      ]\n                    }\n                  })\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    })\n    expect((root as any).children[0].codegenNode.patchFlag).toMatch(\n      PatchFlags.DYNAMIC_SLOTS + ''\n    )\n    expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n  })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<slot> tag only","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":767,"column":25},"line":767,"code":"    test('<slot> tag only', () => {\n      const { slots } = parseWithSlots(`<Comp><slot/></Comp>`)\n      expect(slots).toMatchObject(toMatch)\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<slot> tag w/ v-if","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":772,"column":28},"line":772,"code":"    test('<slot> tag w/ v-if', () => {\n      const { slots } = parseWithSlots(`<Comp><slot v-if=\"ok\"/></Comp>`)\n      expect(slots).toMatchObject(toMatch)\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<slot> tag w/ v-for","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":777,"column":29},"line":777,"code":"    test('<slot> tag w/ v-for', () => {\n      const { slots } = parseWithSlots(`<Comp><slot v-for=\"a in b\"/></Comp>`)\n      expect(slots).toMatchObject(toMatch)\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<slot> tag w/ template","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":782,"column":32},"line":782,"code":"    test('<slot> tag w/ template', () => {\n      const { slots } = parseWithSlots(\n        `<Comp><template #default><slot/></template></Comp>`\n      )\n      expect(slots).toMatchObject(toMatch)\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"<slot w/ nested component>","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":789,"column":36},"line":789,"code":"    test('<slot w/ nested component>', () => {\n      const { slots } = parseWithSlots(`<Comp><Comp><slot/></Comp></Comp>`)\n      expect(slots).toMatchObject(toMatch)\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"consistent behavior of @xxx:modelValue and @xxx:model-value","suites":["compiler: transform component slots","forwarded slots"],"updatePoint":{"line":795,"column":69},"line":795,"code":"    test('consistent behavior of @xxx:modelValue and @xxx:model-value', () => {\n      const { root: rootUpper } = parseWithSlots(\n        `<div><slot @foo:modelValue=\"handler\" /></div>`\n      )\n      const slotNodeUpper = (rootUpper.codegenNode! as VNodeCall)\n        .children as ElementNode[]\n      const propertiesObjUpper = (\n        slotNodeUpper[0].codegenNode! as RenderSlotCall\n      ).arguments[2]\n      expect(propertiesObjUpper).toMatchObject({\n        properties: [\n          {\n            key: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'onFoo:modelValue'\n            },\n            value: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `handler`,\n              isStatic: false\n            }\n          }\n        ]\n      })\n\n      const { root } = parseWithSlots(\n        `<div><slot @foo:model-Value=\"handler\" /></div>`\n      )\n      const slotNode = (root.codegenNode! as VNodeCall)\n        .children as ElementNode[]\n      const propertiesObj = (slotNode[0].codegenNode! as RenderSlotCall)\n        .arguments[2]\n      expect(propertiesObj).toMatchObject({\n        properties: [\n          {\n            key: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: 'onFoo:modelValue'\n            },\n            value: {\n              type: NodeTypes.SIMPLE_EXPRESSION,\n              content: `handler`,\n              isStatic: false\n            }\n          }\n        ]\n      })\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on extraneous children w/ named default slot","suites":["compiler: transform component slots","errors"],"updatePoint":{"line":846,"column":60},"line":846,"code":"    test('error on extraneous children w/ named default slot', () => {\n      const onError = vi.fn()\n      const source = `<Comp><template #default>foo</template>bar</Comp>`\n      parseWithSlots(source, { onError })\n      const index = source.indexOf('bar')\n      expect(onError.mock.calls[0][0]).toMatchObject({\n        code: ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\n        loc: {\n          source: `bar`,\n          start: {\n            offset: index,\n            line: 1,\n            column: index + 1\n          },\n          end: {\n            offset: index + 3,\n            line: 1,\n            column: index + 4\n          }\n        }\n      })\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on duplicated slot names","suites":["compiler: transform component slots","errors"],"updatePoint":{"line":869,"column":40},"line":869,"code":"    test('error on duplicated slot names', () => {\n      const onError = vi.fn()\n      const source = `<Comp><template #foo></template><template #foo></template></Comp>`\n      parseWithSlots(source, { onError })\n      const index = source.lastIndexOf('#foo')\n      expect(onError.mock.calls[0][0]).toMatchObject({\n        code: ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n        loc: {\n          source: `#foo`,\n          start: {\n            offset: index,\n            line: 1,\n            column: index + 1\n          },\n          end: {\n            offset: index + 4,\n            line: 1,\n            column: index + 5\n          }\n        }\n      })\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on invalid mixed slot usage","suites":["compiler: transform component slots","errors"],"updatePoint":{"line":892,"column":43},"line":892,"code":"    test('error on invalid mixed slot usage', () => {\n      const onError = vi.fn()\n      const source = `<Comp v-slot=\"foo\"><template #foo></template></Comp>`\n      parseWithSlots(source, { onError })\n      const index = source.lastIndexOf('#foo')\n      expect(onError.mock.calls[0][0]).toMatchObject({\n        code: ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE,\n        loc: {\n          source: `#foo`,\n          start: {\n            offset: index,\n            line: 1,\n            column: index + 1\n          },\n          end: {\n            offset: index + 4,\n            line: 1,\n            column: index + 5\n          }\n        }\n      })\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"error on v-slot usage on plain elements","suites":["compiler: transform component slots","errors"],"updatePoint":{"line":915,"column":49},"line":915,"code":"    test('error on v-slot usage on plain elements', () => {\n      const onError = vi.fn()\n      const source = `<div v-slot/>`\n      parseWithSlots(source, { onError })\n      const index = source.indexOf('v-slot')\n      expect(onError.mock.calls[0][0]).toMatchObject({\n        code: ErrorCodes.X_V_SLOT_MISPLACED,\n        loc: {\n          source: `v-slot`,\n          start: {\n            offset: index,\n            line: 1,\n            column: index + 1\n          },\n          end: {\n            offset: index + 6,\n            line: 1,\n            column: index + 7\n          }\n        }\n      })\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"named default slot + implicit whitespace content","suites":["compiler: transform component slots","with whitespace: 'preserve'"],"updatePoint":{"line":940,"column":58},"line":940,"code":"    test('named default slot + implicit whitespace content', () => {\n      const source = `\n      <Comp>\n        <template #header> Header </template>\n        <template #default> Default </template>\n      </Comp>\n      `\n      const { root } = parseWithSlots(source, {\n        whitespace: 'preserve'\n      })\n\n      expect(\n        `Extraneous children found when component already has explicitly named default slot.`\n      ).not.toHaveBeenWarned()\n      expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"implicit default slot","suites":["compiler: transform component slots","with whitespace: 'preserve'"],"updatePoint":{"line":957,"column":31},"line":957,"code":"    test('implicit default slot', () => {\n      const source = `\n      <Comp>\n        <template #header> Header </template>\n        <p/>\n      </Comp>\n      `\n      const { root } = parseWithSlots(source, {\n        whitespace: 'preserve'\n      })\n\n      expect(\n        `Extraneous children found when component already has explicitly named default slot.`\n      ).not.toHaveBeenWarned()\n      expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should not generate whitespace only default slot","suites":["compiler: transform component slots","with whitespace: 'preserve'"],"updatePoint":{"line":974,"column":58},"line":974,"code":"    test('should not generate whitespace only default slot', () => {\n      const source = `\n      <Comp>\n        <template #header> Header </template>\n        <template #footer> Footer </template>\n      </Comp>\n      `\n      const { root } = parseWithSlots(source, {\n        whitespace: 'preserve'\n      })\n\n      // slots is vnodeCall's children as an ObjectExpression\n      const slots = (root as any).children[0].codegenNode.children\n        .properties as ObjectExpression['properties']\n\n      // should be: header, footer, _ (no default)\n      expect(slots.length).toBe(3)\n      expect(\n        slots.some(p => (p.key as SimpleExpressionNode).content === 'default')\n      ).toBe(false)\n\n      expect(generate(root, { prefixIdentifiers: true }).code).toMatchSnapshot()\n    })","file":"transforms/vSlot.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"same line","suites":["advancePositionWithClone"],"updatePoint":{"line":16,"column":17},"line":16,"code":"  test('same line', () => {\n    const pos = p(1, 1, 0)\n    const newPos = advancePositionWithClone(pos, 'foo\\nbar', 2)\n\n    expect(newPos.column).toBe(3)\n    expect(newPos.line).toBe(1)\n    expect(newPos.offset).toBe(2)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"same line","suites":["advancePositionWithClone"],"updatePoint":{"line":25,"column":17},"line":25,"code":"  test('same line', () => {\n    const pos = p(1, 1, 0)\n    const newPos = advancePositionWithClone(pos, 'foo\\nbar', 4)\n\n    expect(newPos.column).toBe(1)\n    expect(newPos.line).toBe(2)\n    expect(newPos.offset).toBe(4)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"multiple lines","suites":["advancePositionWithClone"],"updatePoint":{"line":34,"column":22},"line":34,"code":"  test('multiple lines', () => {\n    const pos = p(1, 1, 0)\n    const newPos = advancePositionWithClone(pos, 'foo\\nbar\\nbaz', 10)\n\n    expect(newPos.column).toBe(3)\n    expect(newPos.line).toBe(3)\n    expect(newPos.offset).toBe(10)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"at start","suites":["getInnerRange"],"updatePoint":{"line":51,"column":16},"line":51,"code":"  test('at start', () => {\n    const loc2 = getInnerRange(loc1, 0, 4)\n    expect(loc2.start).toEqual(loc1.start)\n    expect(loc2.end.column).toBe(1)\n    expect(loc2.end.line).toBe(2)\n    expect(loc2.end.offset).toBe(4)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"in between","suites":["getInnerRange"],"updatePoint":{"line":59,"column":18},"line":59,"code":"  test('in between', () => {\n    const loc2 = getInnerRange(loc1, 4, 3)\n    expect(loc2.start.column).toBe(1)\n    expect(loc2.start.line).toBe(2)\n    expect(loc2.start.offset).toBe(4)\n    expect(loc2.end.column).toBe(4)\n    expect(loc2.end.line).toBe(2)\n    expect(loc2.end.offset).toBe(7)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"browser","suites":["isMemberExpression"],"updatePoint":{"line":106,"column":15},"line":106,"code":"  test('browser', () => {\n    commonAssertions(isMemberExpressionBrowser)\n    expect(isMemberExpressionBrowser('123[a]')).toBe(false)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"node","suites":["isMemberExpression"],"updatePoint":{"line":111,"column":12},"line":111,"code":"  test('node', () => {\n    const ctx = { expressionPlugins: ['typescript'] } as any as TransformContext\n    const fn = (str: string) => isMemberExpressionNode(str, ctx)\n    commonAssertions(fn)\n\n    // TS-specific checks\n    expect(fn('foo as string')).toBe(true)\n    expect(fn(`foo.bar as string`)).toBe(true)\n    expect(fn(`foo['bar'] as string`)).toBe(true)\n    expect(fn(`foo[bar as string]`)).toBe(true)\n    expect(fn(`(foo as string)`)).toBe(true)\n    expect(fn(`123[a]`)).toBe(true)\n    expect(fn(`foo() as string`)).toBe(false)\n    expect(fn(`a + b as string`)).toBe(false)\n  })","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"toValidAssetId","suites":["isMemberExpression"],"updatePoint":{"line":128,"column":20},"line":128,"code":"test('toValidAssetId', () => {\n  expect(toValidAssetId('foo', 'component')).toBe('_component_foo')\n  expect(toValidAssetId('p', 'directive')).toBe('_directive_p')\n  expect(toValidAssetId('div', 'filter')).toBe('_filter_div')\n  expect(toValidAssetId('foo-bar', 'component')).toBe('_component_foo_bar')\n  expect(toValidAssetId('test--1', 'component')).toBe(\n    '_component_test_2797935797_1'\n  )\n})","file":"utils.spec.ts","skipped":false,"dir":"packages/compiler-core/__tests__"},{"name":"should decode HTML correctly","suites":["decodeHtmlBrowser"],"updatePoint":{"line":7,"column":34},"line":7,"code":"  it('should decode HTML correctly', () => {\n    expect(decodeHtmlBrowser(' abc  123 ')).toBe(' abc  123 ')\n\n    expect(decodeHtmlBrowser('&')).toBe('&')\n    expect(decodeHtmlBrowser('&amp;')).toBe('&')\n    expect(decodeHtmlBrowser('&amp;amp;')).toBe('&amp;')\n\n    expect(decodeHtmlBrowser('<')).toBe('<')\n    expect(decodeHtmlBrowser('&lt;')).toBe('<')\n    expect(decodeHtmlBrowser('&amp;lt;')).toBe('&lt;')\n\n    expect(decodeHtmlBrowser('>')).toBe('>')\n    expect(decodeHtmlBrowser('&gt;')).toBe('>')\n    expect(decodeHtmlBrowser('&amp;gt;')).toBe('&gt;')\n\n    expect(decodeHtmlBrowser('&nbsp;')).toBe('\\u00a0')\n    expect(decodeHtmlBrowser('&quot;')).toBe('\"')\n    expect(decodeHtmlBrowser('&apos;')).toBe(\"'\")\n\n    expect(decodeHtmlBrowser('&Eacute;')).toBe('\\u00c9')\n    expect(decodeHtmlBrowser('&#xc9;')).toBe('\\u00c9')\n    expect(decodeHtmlBrowser('&#201;')).toBe('\\u00c9')\n\n    // #3001 html tags inside attribute values\n    expect(decodeHtmlBrowser('<strong>Text</strong>', true)).toBe(\n      '<strong>Text</strong>'\n    )\n    expect(decodeHtmlBrowser('<strong>&amp;</strong>', true)).toBe(\n      '<strong>&</strong>'\n    )\n    expect(\n      decodeHtmlBrowser(\n        '<strong>&lt;strong&gt;&amp;&lt;/strong&gt;</strong>',\n        true\n      )\n    ).toBe('<strong><strong>&</strong></strong>')\n  })","file":"decoderHtmlBrowser.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should contain standard transforms","suites":["compile"],"updatePoint":{"line":4,"column":40},"line":4,"code":"  it('should contain standard transforms', () => {\n    const { code } = compile(`<div v-text=\"text\"></div>\n        <div v-html=\"html\"></div>\n        <div v-cloak>test</div>\n        <div style=\"color:red\">red</div>\n        <div :style=\"{color: 'green'}\"></div>`)\n\n    expect(code).toMatchSnapshot()\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"textarea handles comments/elements as just text","suites":["DOM parser","Text"],"updatePoint":{"line":16,"column":57},"line":16,"code":"    test('textarea handles comments/elements as just text', () => {\n      const ast = parse(\n        '<textarea>some<div>text</div>and<!--comment--></textarea>',\n        parserOptions\n      )\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some<div>text</div>and<!--comment-->',\n        loc: {\n          start: { offset: 10, line: 1, column: 11 },\n          end: { offset: 46, line: 1, column: 47 },\n          source: 'some<div>text</div>and<!--comment-->'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"textarea handles character references","suites":["DOM parser","Text"],"updatePoint":{"line":35,"column":47},"line":35,"code":"    test('textarea handles character references', () => {\n      const ast = parse('<textarea>&amp;</textarea>', parserOptions)\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&',\n        loc: {\n          start: { offset: 10, line: 1, column: 11 },\n          end: { offset: 15, line: 1, column: 16 },\n          source: '&amp;'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"textarea support interpolation","suites":["DOM parser","Text"],"updatePoint":{"line":51,"column":40},"line":51,"code":"    test('textarea support interpolation', () => {\n      const ast = parse('<textarea><div>{{ foo }}</textarea>', parserOptions)\n      const element = ast.children[0] as ElementNode\n      expect(element.children).toMatchObject([\n        { type: NodeTypes.TEXT, content: `<div>` },\n        {\n          type: NodeTypes.INTERPOLATION,\n          content: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `foo`,\n            isStatic: false\n          }\n        }\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"style handles comments/elements as just a text","suites":["DOM parser","Text"],"updatePoint":{"line":67,"column":56},"line":67,"code":"    test('style handles comments/elements as just a text', () => {\n      const ast = parse(\n        '<style>some<div>text</div>and<!--comment--></style>',\n        parserOptions\n      )\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some<div>text</div>and<!--comment-->',\n        loc: {\n          start: { offset: 7, line: 1, column: 8 },\n          end: { offset: 43, line: 1, column: 44 },\n          source: 'some<div>text</div>and<!--comment-->'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"style doesn't handle character references","suites":["DOM parser","Text"],"updatePoint":{"line":86,"column":51},"line":86,"code":"    test(\"style doesn't handle character references\", () => {\n      const ast = parse('<style>&amp;</style>', parserOptions)\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&amp;',\n        loc: {\n          start: { offset: 7, line: 1, column: 8 },\n          end: { offset: 12, line: 1, column: 13 },\n          source: '&amp;'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"CDATA","suites":["DOM parser","Text"],"updatePoint":{"line":102,"column":15},"line":102,"code":"    test('CDATA', () => {\n      const ast = parse('<svg><![CDATA[some text]]></svg>', parserOptions)\n      const text = (ast.children[0] as ElementNode).children![0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'some text',\n        loc: {\n          start: { offset: 14, line: 1, column: 15 },\n          end: { offset: 23, line: 1, column: 24 },\n          source: 'some text'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"<pre> tag should preserve raw whitespace","suites":["DOM parser","Text"],"updatePoint":{"line":117,"column":50},"line":117,"code":"    test('<pre> tag should preserve raw whitespace', () => {\n      const rawText = `  \\na   <div>foo \\n bar</div>   \\n   c`\n      const ast = parse(`<pre>${rawText}</pre>`, parserOptions)\n      expect((ast.children[0] as ElementNode).children).toMatchObject([\n        {\n          type: NodeTypes.TEXT,\n          content: `  \\na   `\n        },\n        {\n          type: NodeTypes.ELEMENT,\n          children: [\n            {\n              type: NodeTypes.TEXT,\n              content: `foo \\n bar`\n            }\n          ]\n        },\n        {\n          type: NodeTypes.TEXT,\n          content: `   \\n   c`\n        }\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"<pre> tag should remove leading newline","suites":["DOM parser","Text"],"updatePoint":{"line":142,"column":49},"line":142,"code":"    test('<pre> tag should remove leading newline', () => {\n      const rawText = `\\nhello<div>\\nbye</div>`\n      const ast = parse(`<pre>${rawText}</pre>`, parserOptions)\n      expect((ast.children[0] as ElementNode).children).toMatchObject([\n        {\n          type: NodeTypes.TEXT,\n          content: `hello`\n        },\n        {\n          type: NodeTypes.ELEMENT,\n          children: [\n            {\n              type: NodeTypes.TEXT,\n              // should not remove the leading newline for nested elements\n              content: `\\nbye`\n            }\n          ]\n        }\n      ])\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"&nbsp; should not be condensed","suites":["DOM parser","Text"],"updatePoint":{"line":164,"column":40},"line":164,"code":"    test('&nbsp; should not be condensed', () => {\n      const nbsp = String.fromCharCode(160)\n      const ast = parse(`foo&nbsp;&nbsp;bar`, parserOptions)\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.TEXT,\n        content: `foo${nbsp}${nbsp}bar`\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"HTML entities compatibility in text","suites":["DOM parser","Text"],"updatePoint":{"line":174,"column":45},"line":174,"code":"    test('HTML entities compatibility in text', () => {\n      const ast = parse('&ampersand;', parserOptions)\n      const text = ast.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&ersand;',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 11, line: 1, column: 12 },\n          source: '&ampersand;'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"HTML entities compatibility in attribute","suites":["DOM parser","Text"],"updatePoint":{"line":190,"column":50},"line":190,"code":"    test('HTML entities compatibility in attribute', () => {\n      const ast = parse(\n        '<div a=\"&ampersand;\" b=\"&amp;ersand;\" c=\"&amp!\"></div>',\n        parserOptions\n      )\n      const element = ast.children[0] as ElementNode\n      const text1 = (element.props[0] as AttributeNode).value\n      const text2 = (element.props[1] as AttributeNode).value\n      const text3 = (element.props[2] as AttributeNode).value\n\n      expect(text1).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&ampersand;',\n        loc: {\n          start: { offset: 7, line: 1, column: 8 },\n          end: { offset: 20, line: 1, column: 21 },\n          source: '\"&ampersand;\"'\n        }\n      })\n      expect(text2).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&ersand;',\n        loc: {\n          start: { offset: 23, line: 1, column: 24 },\n          end: { offset: 37, line: 1, column: 38 },\n          source: '\"&amp;ersand;\"'\n        }\n      })\n      expect(text3).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '&!',\n        loc: {\n          start: { offset: 40, line: 1, column: 41 },\n          end: { offset: 47, line: 1, column: 48 },\n          source: '\"&amp!\"'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"Some control character reference should be replaced.","suites":["DOM parser","Text"],"updatePoint":{"line":229,"column":62},"line":229,"code":"    test('Some control character reference should be replaced.', () => {\n      const ast = parse('&#x86;', parserOptions)\n      const text = ast.children[0] as TextNode\n\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: '',\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 6, line: 1, column: 7 },\n          source: '&#x86;'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"HTML entities in interpolation should be translated for backward compatibility.","suites":["DOM parser","Interpolation"],"updatePoint":{"line":246,"column":89},"line":246,"code":"    test('HTML entities in interpolation should be translated for backward compatibility.', () => {\n      const ast = parse('<div>{{ a &lt; b }}</div>', parserOptions)\n      const element = ast.children[0] as ElementNode\n      const interpolation = element.children[0] as InterpolationNode\n\n      expect(interpolation).toStrictEqual({\n        type: NodeTypes.INTERPOLATION,\n        content: {\n          type: NodeTypes.SIMPLE_EXPRESSION,\n          content: `a < b`,\n          isStatic: false,\n          constType: ConstantTypes.NOT_CONSTANT,\n          loc: {\n            start: { offset: 8, line: 1, column: 9 },\n            end: { offset: 16, line: 1, column: 17 },\n            source: 'a &lt; b'\n          }\n        },\n        loc: {\n          start: { offset: 5, line: 1, column: 6 },\n          end: { offset: 19, line: 1, column: 20 },\n          source: '{{ a &lt; b }}'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"void element","suites":["DOM parser","Element"],"updatePoint":{"line":274,"column":22},"line":274,"code":"    test('void element', () => {\n      const ast = parse('<img>after', parserOptions)\n      const element = ast.children[0] as ElementNode\n\n      expect(element).toStrictEqual({\n        type: NodeTypes.ELEMENT,\n        ns: DOMNamespaces.HTML,\n        tag: 'img',\n        tagType: ElementTypes.ELEMENT,\n        props: [],\n        isSelfClosing: false,\n        children: [],\n        loc: {\n          start: { offset: 0, line: 1, column: 1 },\n          end: { offset: 5, line: 1, column: 6 },\n          source: '<img>'\n        },\n        codegenNode: undefined\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"native element","suites":["DOM parser","Element"],"updatePoint":{"line":295,"column":24},"line":295,"code":"    test('native element', () => {\n      const ast = parse('<div></div><comp></comp><Comp></Comp>', parserOptions)\n\n      expect(ast.children[0]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'div',\n        tagType: ElementTypes.ELEMENT\n      })\n\n      expect(ast.children[1]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'comp',\n        tagType: ElementTypes.COMPONENT\n      })\n\n      expect(ast.children[2]).toMatchObject({\n        type: NodeTypes.ELEMENT,\n        tag: 'Comp',\n        tagType: ElementTypes.COMPONENT\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"Strict end tag detection for textarea.","suites":["DOM parser","Element"],"updatePoint":{"line":317,"column":48},"line":317,"code":"    test('Strict end tag detection for textarea.', () => {\n      const ast = parse(\n        '<textarea>hello</textarea</textarea0></texTArea a=\"<>\">',\n        {\n          ...parserOptions,\n          onError: err => {\n            if (err.code !== ErrorCodes.END_TAG_WITH_ATTRIBUTES) {\n              throw err\n            }\n          }\n        }\n      )\n      const element = ast.children[0] as ElementNode\n      const text = element.children[0] as TextNode\n\n      expect(ast.children.length).toBe(1)\n      expect(text).toStrictEqual({\n        type: NodeTypes.TEXT,\n        content: 'hello</textarea</textarea0>',\n        loc: {\n          start: { offset: 10, line: 1, column: 11 },\n          end: { offset: 37, line: 1, column: 38 },\n          source: 'hello</textarea</textarea0>'\n        }\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"HTML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":346,"column":24},"line":346,"code":"    test('HTML namespace', () => {\n      const ast = parse('<html>test</html>', parserOptions)\n      const element = ast.children[0] as ElementNode\n\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"SVG namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":353,"column":23},"line":353,"code":"    test('SVG namespace', () => {\n      const ast = parse('<svg>test</svg>', parserOptions)\n      const element = ast.children[0] as ElementNode\n\n      expect(element.ns).toBe(DOMNamespaces.SVG)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":360,"column":27},"line":360,"code":"    test('MATH_ML namespace', () => {\n      const ast = parse('<math>test</math>', parserOptions)\n      const element = ast.children[0] as ElementNode\n\n      expect(element.ns).toBe(DOMNamespaces.MATH_ML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"SVG in MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":367,"column":34},"line":367,"code":"    test('SVG in MATH_ML namespace', () => {\n      const ast = parse(\n        '<math><annotation-xml><svg></svg></annotation-xml></math>',\n        parserOptions\n      )\n      const elementMath = ast.children[0] as ElementNode\n      const elementAnnotation = elementMath.children[0] as ElementNode\n      const elementSvg = elementAnnotation.children[0] as ElementNode\n\n      expect(elementMath.ns).toBe(DOMNamespaces.MATH_ML)\n      expect(elementSvg.ns).toBe(DOMNamespaces.SVG)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"html text/html in MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":380,"column":45},"line":380,"code":"    test('html text/html in MATH_ML namespace', () => {\n      const ast = parse(\n        '<math><annotation-xml encoding=\"text/html\"><test/></annotation-xml></math>',\n        parserOptions\n      )\n\n      const elementMath = ast.children[0] as ElementNode\n      const elementAnnotation = elementMath.children[0] as ElementNode\n      const element = elementAnnotation.children[0] as ElementNode\n\n      expect(elementMath.ns).toBe(DOMNamespaces.MATH_ML)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"html application/xhtml+xml in MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":394,"column":57},"line":394,"code":"    test('html application/xhtml+xml in MATH_ML namespace', () => {\n      const ast = parse(\n        '<math><annotation-xml encoding=\"application/xhtml+xml\"><test/></annotation-xml></math>',\n        parserOptions\n      )\n      const elementMath = ast.children[0] as ElementNode\n      const elementAnnotation = elementMath.children[0] as ElementNode\n      const element = elementAnnotation.children[0] as ElementNode\n\n      expect(elementMath.ns).toBe(DOMNamespaces.MATH_ML)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"mtext malignmark in MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":407,"column":47},"line":407,"code":"    test('mtext malignmark in MATH_ML namespace', () => {\n      const ast = parse(\n        '<math><mtext><malignmark/></mtext></math>',\n        parserOptions\n      )\n      const elementMath = ast.children[0] as ElementNode\n      const elementText = elementMath.children[0] as ElementNode\n      const element = elementText.children[0] as ElementNode\n\n      expect(elementMath.ns).toBe(DOMNamespaces.MATH_ML)\n      expect(element.ns).toBe(DOMNamespaces.MATH_ML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"mtext and not malignmark tag in MATH_ML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":420,"column":59},"line":420,"code":"    test('mtext and not malignmark tag in MATH_ML namespace', () => {\n      const ast = parse('<math><mtext><test/></mtext></math>', parserOptions)\n      const elementMath = ast.children[0] as ElementNode\n      const elementText = elementMath.children[0] as ElementNode\n      const element = elementText.children[0] as ElementNode\n\n      expect(elementMath.ns).toBe(DOMNamespaces.MATH_ML)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"foreignObject tag in SVG namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":430,"column":44},"line":430,"code":"    test('foreignObject tag in SVG namespace', () => {\n      const ast = parse(\n        '<svg><foreignObject><test/></foreignObject></svg>',\n        parserOptions\n      )\n      const elementSvg = ast.children[0] as ElementNode\n      const elementForeignObject = elementSvg.children[0] as ElementNode\n      const element = elementForeignObject.children[0] as ElementNode\n\n      expect(elementSvg.ns).toBe(DOMNamespaces.SVG)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"desc tag in SVG namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":443,"column":35},"line":443,"code":"    test('desc tag in SVG namespace', () => {\n      const ast = parse('<svg><desc><test/></desc></svg>', parserOptions)\n      const elementSvg = ast.children[0] as ElementNode\n      const elementDesc = elementSvg.children[0] as ElementNode\n      const element = elementDesc.children[0] as ElementNode\n\n      expect(elementSvg.ns).toBe(DOMNamespaces.SVG)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"title tag in SVG namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":453,"column":36},"line":453,"code":"    test('title tag in SVG namespace', () => {\n      const ast = parse('<svg><title><test/></title></svg>', parserOptions)\n      const elementSvg = ast.children[0] as ElementNode\n      const elementTitle = elementSvg.children[0] as ElementNode\n      const element = elementTitle.children[0] as ElementNode\n\n      expect(elementSvg.ns).toBe(DOMNamespaces.SVG)\n      expect(element.ns).toBe(DOMNamespaces.HTML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"SVG in HTML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":463,"column":31},"line":463,"code":"    test('SVG in HTML namespace', () => {\n      const ast = parse('<html><svg></svg></html>', parserOptions)\n      const elementHtml = ast.children[0] as ElementNode\n      const element = elementHtml.children[0] as ElementNode\n\n      expect(elementHtml.ns).toBe(DOMNamespaces.HTML)\n      expect(element.ns).toBe(DOMNamespaces.SVG)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"MATH in HTML namespace","suites":["DOM parser","Namespaces"],"updatePoint":{"line":472,"column":32},"line":472,"code":"    test('MATH in HTML namespace', () => {\n      const ast = parse('<html><math></math></html>', parserOptions)\n      const elementHtml = ast.children[0] as ElementNode\n      const element = elementHtml.children[0] as ElementNode\n\n      expect(elementHtml.ns).toBe(DOMNamespaces.HTML)\n      expect(element.ns).toBe(DOMNamespaces.MATH_ML)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should ignore script","suites":["compiler: ignore side effect tags"],"updatePoint":{"line":4,"column":26},"line":4,"code":"  it('should ignore script', () => {\n    let err: CompilerError | undefined\n    const { code } = compile(`<script>console.log(1)</script>`, {\n      onError(e) {\n        err = e\n      }\n    })\n    expect(code).not.toMatch('script')\n    expect(err).toBeDefined()\n    expect(err!.message).toMatch(`Tags with side effect`)\n  })","file":"transforms/ignoreSideEffectTags.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should ignore style","suites":["compiler: ignore side effect tags"],"updatePoint":{"line":16,"column":25},"line":16,"code":"  it('should ignore style', () => {\n    let err: CompilerError | undefined\n    const { code } = compile(`<style>h1 { color: red }</style>`, {\n      onError(e) {\n        err = e\n      }\n    })\n    expect(code).not.toMatch('style')\n    expect(err).toBeDefined()\n    expect(err!.message).toMatch(`Tags with side effect`)\n  })","file":"transforms/ignoreSideEffectTags.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail on non-eligible static trees","suites":["stringify static html"],"updatePoint":{"line":29,"column":48},"line":29,"code":"  test('should bail on non-eligible static trees', () => {\n    const { ast } = compileWithStringify(\n      `<div><div><div>hello</div><div>hello</div></div></div>`\n    )\n    // should be a normal vnode call\n    expect(ast.hoists[0]!.type).toBe(NodeTypes.VNODE_CALL)\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should work on eligible content (elements with binding > 5)","suites":["stringify static html"],"updatePoint":{"line":37,"column":67},"line":37,"code":"  test('should work on eligible content (elements with binding > 5)', () => {\n    const { ast } = compileWithStringify(\n      `<div><div>${repeat(\n        `<span class=\"foo\"/>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div></div>`\n    )\n    // should be optimized now\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_STATIC,\n        arguments: [\n          JSON.stringify(\n            `<div>${repeat(\n              `<span class=\"foo\"></span>`,\n              StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n            )}</div>`\n          ),\n          '1'\n        ]\n      }, // the children array is hoisted as well\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should work on eligible content (elements > 20)","suites":["stringify static html"],"updatePoint":{"line":65,"column":55},"line":65,"code":"  test('should work on eligible content (elements > 20)', () => {\n    const { ast } = compileWithStringify(\n      `<div><div>${repeat(\n        `<span/>`,\n        StringifyThresholds.NODE_COUNT\n      )}</div></div>`\n    )\n    // should be optimized now\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_STATIC,\n        arguments: [\n          JSON.stringify(\n            `<div>${repeat(\n              `<span></span>`,\n              StringifyThresholds.NODE_COUNT\n            )}</div>`\n          ),\n          '1'\n        ]\n      },\n      // the children array is hoisted as well\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should work for multiple adjacent nodes","suites":["stringify static html"],"updatePoint":{"line":94,"column":47},"line":94,"code":"  test('should work for multiple adjacent nodes', () => {\n    const { ast } = compileWithStringify(\n      `<div>${repeat(\n        `<span class=\"foo\"/>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div>`\n    )\n    // should have 6 hoisted nodes (including the entire array),\n    // but 2~5 should be null because they are merged into 1\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_STATIC,\n        arguments: [\n          JSON.stringify(\n            repeat(\n              `<span class=\"foo\"></span>`,\n              StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n            )\n          ),\n          '5'\n        ]\n      },\n      null,\n      null,\n      null,\n      null,\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"serializing constant bindings","suites":["stringify static html"],"updatePoint":{"line":127,"column":37},"line":127,"code":"  test('serializing constant bindings', () => {\n    const { ast } = compileWithStringify(\n      `<div><div :style=\"{ color: 'red' }\">${repeat(\n        `<span :class=\"[{ foo: true }, { bar: true }]\">{{ 1 }} + {{ false }}</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div></div>`\n    )\n    // should be optimized now\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_STATIC,\n        arguments: [\n          JSON.stringify(\n            `<div style=\"color:red;\">${repeat(\n              `<span class=\"foo bar\">1 + false</span>`,\n              StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n            )}</div>`\n          ),\n          '1'\n        ]\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"escape","suites":["stringify static html"],"updatePoint":{"line":155,"column":14},"line":155,"code":"  test('escape', () => {\n    const { ast } = compileWithStringify(\n      `<div><div>${repeat(\n        `<span :class=\"'foo' + '&gt;ar'\">{{ 1 }} + {{ '<' }}</span>` +\n          `<span>&amp;</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div></div>`\n    )\n    // should be optimized now\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee: CREATE_STATIC,\n        arguments: [\n          JSON.stringify(\n            `<div>${repeat(\n              `<span class=\"foo&gt;ar\">1 + &lt;</span>` + `<span>&amp;</span>`,\n              StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n            )}</div>`\n          ),\n          '1'\n        ]\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail on bindings that are hoisted but not stringifiable","suites":["stringify static html"],"updatePoint":{"line":184,"column":70},"line":184,"code":"  test('should bail on bindings that are hoisted but not stringifiable', () => {\n    const { ast, code } = compile(\n      `<div><div>${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}<img src=\"./foo\" /></div></div>`,\n      {\n        hoistStatic: true,\n        prefixIdentifiers: true,\n        transformHoist: stringifyStatic,\n        nodeTransforms: [\n          node => {\n            if (node.type === NodeTypes.ELEMENT && node.tag === 'img') {\n              const exp = createSimpleExpression(\n                '_imports_0_',\n                false,\n                node.loc,\n                ConstantTypes.CAN_HOIST\n              )\n              node.props[0] = {\n                type: NodeTypes.DIRECTIVE,\n                name: 'bind',\n                arg: createSimpleExpression('src', true),\n                exp,\n                modifiers: [],\n                loc: node.loc\n              }\n            }\n          }\n        ]\n      }\n    )\n    expect(ast.hoists).toMatchObject([\n      {\n        // the expression and the tree are still hoistable\n        // but should stay NodeTypes.VNODE_CALL\n        // if it's stringified it will be NodeTypes.JS_CALL_EXPRESSION\n        type: NodeTypes.VNODE_CALL\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n    expect(code).toMatchSnapshot()\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should work with bindings that are non-static but stringifiable","suites":["stringify static html"],"updatePoint":{"line":230,"column":71},"line":230,"code":"  test('should work with bindings that are non-static but stringifiable', () => {\n    // if a binding is non-static but marked as CAN_STRINGIFY, it means it's\n    // a known reference to a constant string.\n    const { ast, code } = compile(\n      `<div><div>${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}<img src=\"./foo\" /></div></div>`,\n      {\n        hoistStatic: true,\n        prefixIdentifiers: true,\n        transformHoist: stringifyStatic,\n        nodeTransforms: [\n          node => {\n            if (node.type === NodeTypes.ELEMENT && node.tag === 'img') {\n              const exp = createSimpleExpression(\n                '_imports_0_',\n                false,\n                node.loc,\n                ConstantTypes.CAN_STRINGIFY\n              )\n              node.props[0] = {\n                type: NodeTypes.DIRECTIVE,\n                name: 'bind',\n                arg: createSimpleExpression('src', true),\n                exp,\n                modifiers: [],\n                loc: node.loc\n              }\n            }\n          }\n        ]\n      }\n    )\n    expect(ast.hoists).toMatchObject([\n      {\n        // the hoisted node should be NodeTypes.JS_CALL_EXPRESSION\n        // of `createStaticVNode()` instead of dynamic NodeTypes.VNODE_CALL\n        type: NodeTypes.JS_CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n    expect(code).toMatchSnapshot()\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail on non attribute bindings","suites":["stringify static html"],"updatePoint":{"line":278,"column":45},"line":278,"code":"  test('should bail on non attribute bindings', () => {\n    const { ast } = compileWithStringify(\n      `<div><div><input indeterminate>${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div></div>`\n    )\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n\n    const { ast: ast2 } = compileWithStringify(\n      `<div><div><input :indeterminate=\"true\">${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div></div>`\n    )\n    expect(ast2.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail on non attribute bindings","suites":["stringify static html"],"updatePoint":{"line":310,"column":45},"line":310,"code":"  test('should bail on non attribute bindings', () => {\n    const { ast } = compileWithStringify(\n      `<div><div>${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}<input indeterminate></div></div>`\n    )\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n\n    const { ast: ast2 } = compileWithStringify(\n      `<div><div>${repeat(\n        `<span class=\"foo\">foo</span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}<input :indeterminate=\"true\"></div></div>`\n    )\n    expect(ast2.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail on tags that has placement constraints (eg.tables related tags)","suites":["stringify static html"],"updatePoint":{"line":342,"column":83},"line":342,"code":"  test('should bail on tags that has placement constraints (eg.tables related tags)', () => {\n    const { ast } = compileWithStringify(\n      `<table><tbody>${repeat(\n        `<tr class=\"foo\"><td>foo</td></tr>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</tbody></table>`\n    )\n    expect(ast.hoists).toMatchObject([\n      {\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      },\n      {\n        type: NodeTypes.JS_ARRAY_EXPRESSION\n      }\n    ])\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should bail inside slots","suites":["stringify static html"],"updatePoint":{"line":359,"column":32},"line":359,"code":"  test('should bail inside slots', () => {\n    const { ast } = compileWithStringify(\n      `<foo>${repeat(\n        `<div class=\"foo\"></div>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</foo>`\n    )\n    expect(ast.hoists.length).toBe(\n      StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n    )\n    ast.hoists.forEach(node => {\n      expect(node).toMatchObject({\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      })\n    })\n\n    const { ast: ast2 } = compileWithStringify(\n      `<foo><template #foo>${repeat(\n        `<div class=\"foo\"></div>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</template></foo>`\n    )\n    expect(ast2.hoists.length).toBe(\n      StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n    )\n    ast2.hoists.forEach(node => {\n      expect(node).toMatchObject({\n        type: NodeTypes.VNODE_CALL // not CALL_EXPRESSION\n      })\n    })\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should remove attribute for `null`","suites":["stringify static html"],"updatePoint":{"line":391,"column":42},"line":391,"code":"  test('should remove attribute for `null`', () => {\n    const { ast } = compileWithStringify(\n      `<div>${repeat(\n        `<span :title=\"null\"></span>`,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</div>`\n    )\n    expect(ast.hoists[0]).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_STATIC,\n      arguments: [\n        JSON.stringify(\n          `${repeat(\n            `<span></span>`,\n            StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n          )}`\n        ),\n        '5'\n      ]\n    })\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should remove boolean attribute for `false`","suites":["stringify static html"],"updatePoint":{"line":414,"column":51},"line":414,"code":"  test('should remove boolean attribute for `false`', () => {\n    const { ast } = compileWithStringify(\n      `<button :disabled=\"false\">enable</button>${repeat(\n        `<div></div>`,\n        StringifyThresholds.NODE_COUNT\n      )}`\n    )\n    expect(ast.hoists[0]).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_STATIC,\n      arguments: [\n        JSON.stringify(\n          `<button>enable</button>${repeat(\n            `<div></div>`,\n            StringifyThresholds.NODE_COUNT\n          )}`\n        ),\n        '21'\n      ]\n    })\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should stringify svg","suites":["stringify static html"],"updatePoint":{"line":436,"column":28},"line":436,"code":"  test('should stringify svg', () => {\n    const svg = `<svg width=\"50\" height=\"50\" viewBox=\"0 0 50 50\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">`\n    const repeated = `<rect width=\"50\" height=\"50\" fill=\"#C4C4C4\"></rect>`\n    const { ast } = compileWithStringify(\n      `<div>${svg}${repeat(\n        repeated,\n        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n      )}</svg></div>`\n    )\n    expect(ast.hoists[0]).toMatchObject({\n      type: NodeTypes.JS_CALL_EXPRESSION,\n      callee: CREATE_STATIC,\n      arguments: [\n        JSON.stringify(\n          `${svg}${repeat(\n            repeated,\n            StringifyThresholds.ELEMENT_WITH_BINDING_COUNT\n          )}</svg>`\n        ),\n        '1'\n      ]\n    })\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"stringify v-html","suites":["stringify static html"],"updatePoint":{"line":461,"column":24},"line":461,"code":"  test('stringify v-html', () => {\n    const { code } = compileWithStringify(`\n      <pre  data-type=\"js\"><code v-html=\"'&lt;span&gt;show-it &lt;/span&gt;'\"></code></pre>\n      <div class>\n        <span class>1</span><span class>2</span>\n      </div>`)\n    expect(code).toMatch(`<code><span>show-it </span></code>`)\n    expect(code).toMatchSnapshot()\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"stringify v-text","suites":["stringify static html"],"updatePoint":{"line":471,"column":24},"line":471,"code":"  test('stringify v-text', () => {\n    const { code } = compileWithStringify(`\n      <pre  data-type=\"js\"><code v-text=\"'&lt;span&gt;show-it &lt;/span&gt;'\"></code></pre>\n      <div class>\n        <span class>1</span><span class>2</span>\n      </div>`)\n    expect(code).toMatch(`<code>&lt;span&gt;show-it &lt;/span&gt;</code>`)\n    expect(code).toMatchSnapshot()\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"stringify v-text with escape","suites":["stringify static html"],"updatePoint":{"line":481,"column":36},"line":481,"code":"  test('stringify v-text with escape', () => {\n    const { code } = compileWithStringify(`\n      <pre  data-type=\"js\"><code v-text=\"\n                \\`text1\\`\"></code></pre>\n      <div class>\n        <span class>1</span><span class>2</span>\n      </div>`)\n    expect(code).toMatch(`<code>text1</code>`)\n    expect(code).toMatchSnapshot()\n  })","file":"transforms/stringifyStatic.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should transform into directive node","suites":["compiler: style transform"],"updatePoint":{"line":29,"column":44},"line":29,"code":"  test('should transform into directive node', () => {\n    const { node } = transformWithStyleTransform(`<div style=\"color: red\"/>`)\n    expect(node.props[0]).toMatchObject({\n      type: NodeTypes.DIRECTIVE,\n      name: `bind`,\n      arg: {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `style`,\n        isStatic: true\n      },\n      exp: {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: `{\"color\":\"red\"}`,\n        isStatic: false\n      }\n    })\n  })","file":"transforms/transformStyle.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"working with v-bind transform","suites":["compiler: style transform"],"updatePoint":{"line":47,"column":37},"line":47,"code":"  test('working with v-bind transform', () => {\n    const { node } = transformWithStyleTransform(`<div style=\"color: red\"/>`, {\n      nodeTransforms: [transformStyle, transformElement],\n      directiveTransforms: {\n        bind: transformBind\n      }\n    })\n    expect((node.codegenNode as VNodeCall).props).toMatchObject({\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\n      properties: [\n        {\n          key: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `style`,\n            isStatic: true\n          },\n          value: {\n            type: NodeTypes.SIMPLE_EXPRESSION,\n            content: `{\"color\":\"red\"}`,\n            isStatic: false\n          }\n        }\n      ]\n    })\n    // should not cause the STYLE patchFlag to be attached\n    expect((node.codegenNode as VNodeCall).patchFlag).toBeUndefined()\n  })","file":"transforms/transformStyle.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns if multiple children","suites":["Transition multi children warnings"],"updatePoint":{"line":23,"column":34},"line":23,"code":"  test('warns if multiple children', () => {\n    checkWarning(\n      `\n      <transition>\n        <div>hey</div>\n        <div>hey</div>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns with v-for","suites":["Transition multi children warnings"],"updatePoint":{"line":35,"column":24},"line":35,"code":"  test('warns with v-for', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-for=\"i in items\">hey</div>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns with multiple v-if + v-for","suites":["Transition multi children warnings"],"updatePoint":{"line":46,"column":40},"line":46,"code":"  test('warns with multiple v-if + v-for', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-if=\"a\" v-for=\"i in items\">hey</div>\n        <div v-else v-for=\"i in items\">hey</div>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns with template v-if","suites":["Transition multi children warnings"],"updatePoint":{"line":58,"column":32},"line":58,"code":"  test('warns with template v-if', () => {\n    checkWarning(\n      `\n      <transition>\n        <template v-if=\"ok\"></template>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns with multiple templates","suites":["Transition multi children warnings"],"updatePoint":{"line":69,"column":37},"line":69,"code":"  test('warns with multiple templates', () => {\n    checkWarning(\n      `\n      <transition>\n        <template v-if=\"a\"></template>\n        <template v-else></template>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"warns if multiple children with v-if","suites":["Transition multi children warnings"],"updatePoint":{"line":81,"column":44},"line":81,"code":"  test('warns if multiple children with v-if', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-if=\"one\">hey</div>\n        <div v-if=\"other\">hey</div>\n      </transition>\n      `,\n      true\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"does not warn with regular element","suites":["Transition multi children warnings"],"updatePoint":{"line":93,"column":42},"line":93,"code":"  test('does not warn with regular element', () => {\n    checkWarning(\n      `\n      <transition>\n        <div>hey</div>\n      </transition>\n      `,\n      false\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"does not warn with one single v-if","suites":["Transition multi children warnings"],"updatePoint":{"line":104,"column":42},"line":104,"code":"  test('does not warn with one single v-if', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-if=\"a\">hey</div>\n      </transition>\n      `,\n      false\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"does not warn with v-if v-else-if v-else","suites":["Transition multi children warnings"],"updatePoint":{"line":115,"column":48},"line":115,"code":"  test('does not warn with v-if v-else-if v-else', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-if=\"a\">hey</div>\n        <div v-else-if=\"b\">hey</div>\n        <div v-else>hey</div>\n      </transition>\n      `,\n      false\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"does not warn with v-if v-else","suites":["Transition multi children warnings"],"updatePoint":{"line":128,"column":38},"line":128,"code":"  test('does not warn with v-if v-else', () => {\n    checkWarning(\n      `\n      <transition>\n        <div v-if=\"a\">hey</div>\n        <div v-else>hey</div>\n      </transition>\n      `,\n      false\n    )\n  })","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"inject persisted when child has v-show","suites":["Transition multi children warnings"],"updatePoint":{"line":141,"column":44},"line":141,"code":"test('inject persisted when child has v-show', () => {\n  expect(\n    compile(`\n    <transition>\n      <div v-show=\"ok\" />\n    </transition>\n    `).code\n  ).toMatchSnapshot()\n})","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"the v-if/else-if/else branches in Transition should ignore comments","suites":["Transition multi children warnings"],"updatePoint":{"line":151,"column":73},"line":151,"code":"test('the v-if/else-if/else branches in Transition should ignore comments', () => {\n  expect(\n    compile(`\n    <transition>\n      <div v-if=\"a\">hey</div>\n      <!-- this should be ignored -->\n      <div v-else-if=\"b\">hey</div>\n      <!-- this should be ignored -->\n      <div v-else>\n        <p v-if=\"c\"/>\n        <!-- this should not be ignored -->\n        <p v-else/>\n      </div>\n    </transition>\n    `).code\n  ).toMatchSnapshot()\n})","file":"transforms/Transition.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should convert v-html to innerHTML","suites":["compiler: v-html transform"],"updatePoint":{"line":30,"column":40},"line":30,"code":"  it('should convert v-html to innerHTML', () => {\n    const ast = transformWithVHtml(`<div v-html=\"test\"/>`)\n    expect((ast.children[0] as PlainElementNode).codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        innerHTML: `[test]`\n      }),\n      children: undefined,\n      patchFlag: genFlagText(PatchFlags.PROPS),\n      dynamicProps: `[\"innerHTML\"]`\n    })\n  })","file":"transforms/vHtml.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error and ignore children when v-html is present","suites":["compiler: v-html transform"],"updatePoint":{"line":43,"column":67},"line":43,"code":"  it('should raise error and ignore children when v-html is present', () => {\n    const onError = vi.fn()\n    const ast = transformWithVHtml(`<div v-html=\"test\">hello</div>`, {\n      onError\n    })\n    expect(onError.mock.calls).toMatchObject([\n      [{ code: DOMErrorCodes.X_V_HTML_WITH_CHILDREN }]\n    ])\n    expect((ast.children[0] as PlainElementNode).codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        innerHTML: `[test]`\n      }),\n      children: undefined, // <-- children should have been removed\n      patchFlag: genFlagText(PatchFlags.PROPS),\n      dynamicProps: `[\"innerHTML\"]`\n    })\n  })","file":"transforms/vHtml.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error if has no expression","suites":["compiler: v-html transform"],"updatePoint":{"line":62,"column":45},"line":62,"code":"  it('should raise error if has no expression', () => {\n    const onError = vi.fn()\n    transformWithVHtml(`<div v-html></div>`, {\n      onError\n    })\n    expect(onError.mock.calls).toMatchObject([\n      [{ code: DOMErrorCodes.X_V_HTML_NO_EXPRESSION }]\n    ])\n  })","file":"transforms/vHtml.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression","suites":["compiler: transform v-model"],"updatePoint":{"line":32,"column":25},"line":32,"code":"  test('simple expression', () => {\n    const root = transformWithModel('<input v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_TEXT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for input (text)","suites":["compiler: transform v-model"],"updatePoint":{"line":39,"column":42},"line":39,"code":"  test('simple expression for input (text)', () => {\n    const root = transformWithModel('<input type=\"text\" v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_TEXT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for input (radio)","suites":["compiler: transform v-model"],"updatePoint":{"line":46,"column":43},"line":46,"code":"  test('simple expression for input (radio)', () => {\n    const root = transformWithModel('<input type=\"radio\" v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_RADIO)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for input (checkbox)","suites":["compiler: transform v-model"],"updatePoint":{"line":53,"column":46},"line":53,"code":"  test('simple expression for input (checkbox)', () => {\n    const root = transformWithModel('<input type=\"checkbox\" v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_CHECKBOX)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for input (dynamic type)","suites":["compiler: transform v-model"],"updatePoint":{"line":60,"column":50},"line":60,"code":"  test('simple expression for input (dynamic type)', () => {\n    const root = transformWithModel('<input :type=\"foo\" v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_DYNAMIC)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"input w/ dynamic v-bind","suites":["compiler: transform v-model"],"updatePoint":{"line":67,"column":31},"line":67,"code":"  test('input w/ dynamic v-bind', () => {\n    const root = transformWithModel('<input v-bind=\"obj\" v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_DYNAMIC)\n    expect(generate(root).code).toMatchSnapshot()\n\n    const root2 = transformWithModel(\n      '<input v-bind:[key]=\"val\" v-model=\"model\" />'\n    )\n    expect(root2.helpers).toContain(V_MODEL_DYNAMIC)\n    expect(generate(root2).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for select","suites":["compiler: transform v-model"],"updatePoint":{"line":80,"column":36},"line":80,"code":"  test('simple expression for select', () => {\n    const root = transformWithModel('<select v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_SELECT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression for textarea","suites":["compiler: transform v-model"],"updatePoint":{"line":87,"column":38},"line":87,"code":"  test('simple expression for textarea', () => {\n    const root = transformWithModel('<textarea v-model=\"model\" />')\n\n    expect(root.helpers).toContain(V_MODEL_TEXT)\n    expect(generate(root).code).toMatchSnapshot()\n  })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"plain elements with argument","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":95,"column":38},"line":95,"code":"    test('plain elements with argument', () => {\n      const onError = vi.fn()\n      transformWithModel('<input v-model:value=\"model\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"invalid element","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":107,"column":25},"line":107,"code":"    test('invalid element', () => {\n      const onError = vi.fn()\n      transformWithModel('<span v-model=\"model\" />', { onError })\n\n      expect(onError).toHaveBeenCalledTimes(1)\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should allow usage on custom element","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":119,"column":46},"line":119,"code":"    test('should allow usage on custom element', () => {\n      const onError = vi.fn()\n      const root = transformWithModel('<my-input v-model=\"model\" />', {\n        onError,\n        isCustomElement: tag => tag.startsWith('my-')\n      })\n      expect(root.helpers).toContain(V_MODEL_TEXT)\n      expect(onError).not.toHaveBeenCalled()\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error if used file input element","suites":["compiler: transform v-model","errors"],"updatePoint":{"line":130,"column":55},"line":130,"code":"    test('should raise error if used file input element', () => {\n      const onError = vi.fn()\n      transformWithModel(`<input type=\"file\" v-model=\"test\"/>`, {\n        onError\n      })\n      expect(onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          code: DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT\n        })\n      )\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":".number","suites":["compiler: transform v-model","modifiers"],"updatePoint":{"line":144,"column":17},"line":144,"code":"    test('.number', () => {\n      const root = transformWithModel('<input  v-model.number=\"model\" />')\n\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":".trim","suites":["compiler: transform v-model","modifiers"],"updatePoint":{"line":150,"column":15},"line":150,"code":"    test('.trim', () => {\n      const root = transformWithModel('<input  v-model.trim=\"model\" />')\n\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":".lazy","suites":["compiler: transform v-model","modifiers"],"updatePoint":{"line":156,"column":15},"line":156,"code":"    test('.lazy', () => {\n      const root = transformWithModel('<input  v-model.lazy=\"model\" />')\n\n      expect(generate(root).code).toMatchSnapshot()\n    })","file":"transforms/vModel.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should support multiple modifiers w/ prefixIdentifiers: true","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":38,"column":66},"line":38,"code":"  it('should support multiple modifiers w/ prefixIdentifiers: true', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @click.stop.prevent=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_MODIFIERS,\n        arguments: [{ content: '_ctx.test' }, '[\"stop\",\"prevent\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should support multiple events and modifiers options w/ prefixIdentifiers: true","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":53,"column":85},"line":53,"code":"  it('should support multiple events and modifiers options w/ prefixIdentifiers: true', () => {\n    const { props } = parseWithVOn(\n      `<div @click.stop=\"test\" @keyup.enter=\"test\" />`,\n      {\n        prefixIdentifiers: true\n      }\n    )\n    const [clickProp, keyUpProp] = props\n\n    expect(props).toHaveLength(2)\n    expect(clickProp).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_MODIFIERS,\n        arguments: [{ content: '_ctx.test' }, '[\"stop\"]']\n      }\n    })\n    expect(keyUpProp).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_KEYS,\n        arguments: [{ content: '_ctx.test' }, '[\"enter\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should support multiple modifiers and event options w/ prefixIdentifiers: true","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":79,"column":84},"line":79,"code":"  it('should support multiple modifiers and event options w/ prefixIdentifiers: true', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @click.stop.capture.once=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      key: {\n        content: `onClickCaptureOnce`\n      },\n      value: {\n        callee: V_ON_WITH_MODIFIERS,\n        arguments: [{ content: '_ctx.test' }, '[\"stop\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should wrap keys guard for keyboard events or dynamic events","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":97,"column":66},"line":97,"code":"  it('should wrap keys guard for keyboard events or dynamic events', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @keydown.stop.capture.ctrl.a=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      key: {\n        content: `onKeydownCapture`\n      },\n      value: {\n        callee: V_ON_WITH_KEYS,\n        arguments: [\n          {\n            callee: V_ON_WITH_MODIFIERS,\n            arguments: [{ content: '_ctx.test' }, '[\"stop\",\"ctrl\"]']\n          },\n          '[\"a\"]'\n        ]\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should not wrap keys guard if no key modifier is present","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":121,"column":62},"line":121,"code":"  it('should not wrap keys guard if no key modifier is present', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @keyup.exact=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_MODIFIERS,\n        arguments: [{ content: '_ctx.test' }, '[\"exact\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should wrap keys guard for static key event w/ left/right modifiers","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":136,"column":73},"line":136,"code":"  it('should wrap keys guard for static key event w/ left/right modifiers', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @keyup.left=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_KEYS,\n        arguments: [{ content: '_ctx.test' }, '[\"left\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should wrap both for dynamic key event w/ left/right modifiers","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":151,"column":68},"line":151,"code":"  it('should wrap both for dynamic key event w/ left/right modifiers', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @[e].left=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_KEYS,\n        arguments: [\n          {\n            callee: V_ON_WITH_MODIFIERS,\n            arguments: [{ content: `_ctx.test` }, `[\"left\"]`]\n          },\n          '[\"left\"]'\n        ]\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should not wrap normal guard if there is only keys guard","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":172,"column":62},"line":172,"code":"  it('should not wrap normal guard if there is only keys guard', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @keyup.enter=\"test\"/>`, {\n      prefixIdentifiers: true\n    })\n    expect(prop).toMatchObject({\n      type: NodeTypes.JS_PROPERTY,\n      value: {\n        callee: V_ON_WITH_KEYS,\n        arguments: [{ content: '_ctx.test' }, '[\"enter\"]']\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should transform click.right","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":187,"column":36},"line":187,"code":"  test('should transform click.right', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @click.right=\"test\"/>`)\n    expect(prop.key).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `onContextmenu`\n    })\n\n    // dynamic\n    const {\n      props: [prop2]\n    } = parseWithVOn(`<div @[event].right=\"test\"/>`)\n    // (_toHandlerKey(event)).toLowerCase() === \"onclick\" ? \"onContextmenu\" : (_toHandlerKey(event))\n    expect(prop2.key).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `(`,\n        {\n          children: [\n            `_${helperNameMap[TO_HANDLER_KEY]}(`,\n            { content: 'event' },\n            `)`\n          ]\n        },\n        `) === \"onClick\" ? \"onContextmenu\" : (`,\n        {\n          children: [\n            `_${helperNameMap[TO_HANDLER_KEY]}(`,\n            { content: 'event' },\n            `)`\n          ]\n        },\n        `)`\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should transform click.middle","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":225,"column":37},"line":225,"code":"  test('should transform click.middle', () => {\n    const {\n      props: [prop]\n    } = parseWithVOn(`<div @click.middle=\"test\"/>`)\n    expect(prop.key).toMatchObject({\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content: `onMouseup`\n    })\n\n    // dynamic\n    const {\n      props: [prop2]\n    } = parseWithVOn(`<div @[event].middle=\"test\"/>`)\n    // (_eventNaming(event)).toLowerCase() === \"onclick\" ? \"onMouseup\" : (_eventNaming(event))\n    expect(prop2.key).toMatchObject({\n      type: NodeTypes.COMPOUND_EXPRESSION,\n      children: [\n        `(`,\n        {\n          children: [\n            `_${helperNameMap[TO_HANDLER_KEY]}(`,\n            { content: 'event' },\n            `)`\n          ]\n        },\n        `) === \"onClick\" ? \"onMouseup\" : (`,\n        {\n          children: [\n            `_${helperNameMap[TO_HANDLER_KEY]}(`,\n            { content: 'event' },\n            `)`\n          ]\n        },\n        `)`\n      ]\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"cache handler w/ modifiers","suites":["compiler-dom: transform v-on"],"updatePoint":{"line":263,"column":34},"line":263,"code":"  test('cache handler w/ modifiers', () => {\n    const {\n      root,\n      props: [prop]\n    } = parseWithVOn(`<div @keyup.enter.capture=\"foo\" />`, {\n      prefixIdentifiers: true,\n      cacheHandlers: true\n    })\n    expect(root.cached).toBe(1)\n    // should not treat cached handler as dynamicProp, so it should have no\n    // dynamicProps flags and only the hydration flag\n    expect((root as any).children[0].codegenNode.patchFlag).toBe(\n      genFlagText(PatchFlags.HYDRATE_EVENTS)\n    )\n    expect(prop).toMatchObject({\n      key: {\n        content: `onKeyupCapture`\n      },\n      value: {\n        type: NodeTypes.JS_CACHE_EXPRESSION,\n        index: 0,\n        value: {\n          type: NodeTypes.JS_CALL_EXPRESSION,\n          callee: V_ON_WITH_KEYS\n        }\n      }\n    })\n  })","file":"transforms/vOn.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"simple expression","suites":["compiler: v-show transform"],"updatePoint":{"line":25,"column":25},"line":25,"code":"  test('simple expression', () => {\n    const ast = transformWithShow(`<div v-show=\"a\"/>`)\n\n    expect(generate(ast).code).toMatchSnapshot()\n  })","file":"transforms/vShow.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error if has no expression","suites":["compiler: v-show transform"],"updatePoint":{"line":31,"column":47},"line":31,"code":"  test('should raise error if has no expression', () => {\n    const onError = vi.fn()\n    transformWithShow(`<div v-show/>`, { onError })\n\n    expect(onError).toHaveBeenCalledTimes(1)\n    expect(onError).toHaveBeenCalledWith(\n      expect.objectContaining({\n        code: DOMErrorCodes.X_V_SHOW_NO_EXPRESSION\n      })\n    )\n  })","file":"transforms/vShow.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should convert v-text to textContent","suites":["compiler: v-text transform"],"updatePoint":{"line":30,"column":42},"line":30,"code":"  it('should convert v-text to textContent', () => {\n    const ast = transformWithVText(`<div v-text=\"test\"/>`)\n    expect((ast.children[0] as PlainElementNode).codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        textContent: {\n          arguments: [{ content: 'test' }]\n        }\n      }),\n      children: undefined,\n      patchFlag: genFlagText(PatchFlags.PROPS),\n      dynamicProps: `[\"textContent\"]`\n    })\n  })","file":"transforms/vText.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error and ignore children when v-text is present","suites":["compiler: v-text transform"],"updatePoint":{"line":45,"column":67},"line":45,"code":"  it('should raise error and ignore children when v-text is present', () => {\n    const onError = vi.fn()\n    const ast = transformWithVText(`<div v-text=\"test\">hello</div>`, {\n      onError\n    })\n    expect(onError.mock.calls).toMatchObject([\n      [{ code: DOMErrorCodes.X_V_TEXT_WITH_CHILDREN }]\n    ])\n    expect((ast.children[0] as PlainElementNode).codegenNode).toMatchObject({\n      tag: `\"div\"`,\n      props: createObjectMatcher({\n        textContent: {\n          arguments: [{ content: 'test' }]\n        }\n      }),\n      children: undefined, // <-- children should have been removed\n      patchFlag: genFlagText(PatchFlags.PROPS),\n      dynamicProps: `[\"textContent\"]`\n    })\n  })","file":"transforms/vText.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should raise error if has no expression","suites":["compiler: v-text transform"],"updatePoint":{"line":66,"column":45},"line":66,"code":"  it('should raise error if has no expression', () => {\n    const onError = vi.fn()\n    transformWithVText(`<div v-text></div>`, {\n      onError\n    })\n    expect(onError.mock.calls).toMatchObject([\n      [{ code: DOMErrorCodes.X_V_TEXT_NO_EXPRESSION }]\n    ])\n  })","file":"transforms/vText.spec.ts","skipped":false,"dir":"packages/compiler-dom/__tests__"},{"name":"should compile JS syntax","suites":["SFC compile <script setup>"],"updatePoint":{"line":5,"column":32},"line":5,"code":"  test('should compile JS syntax', () => {\n    const { content } = compile(`\n      <script setup lang='js'>\n      const a = 1\n      const b = 2\n      </script>\n    `)\n    expect(content).toMatch(`return { a, b }`)\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should expose top level declarations","suites":["SFC compile <script setup>"],"updatePoint":{"line":16,"column":44},"line":16,"code":"  test('should expose top level declarations', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      import { x } from './x'\n      let a = 1\n      const b = 2\n      function c() {}\n      class d {}\n      </script>\n\n      <script>\n      import { xx } from './x'\n      let aa = 1\n      const bb = 2\n      function cc() {}\n      class dd {}\n      </script>\n      `)\n    expect(content).toMatch(\n      `return { get aa() { return aa }, set aa(v) { aa = v }, ` +\n        `bb, cc, dd, get a() { return a }, set a(v) { a = v }, b, c, d, ` +\n        `get xx() { return xx }, get x() { return x } }`\n    )\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.SETUP_MAYBE_REF,\n      a: BindingTypes.SETUP_LET,\n      b: BindingTypes.SETUP_CONST,\n      c: BindingTypes.SETUP_CONST,\n      d: BindingTypes.SETUP_CONST,\n      xx: BindingTypes.SETUP_MAYBE_REF,\n      aa: BindingTypes.SETUP_LET,\n      bb: BindingTypes.LITERAL_CONST,\n      cc: BindingTypes.SETUP_CONST,\n      dd: BindingTypes.SETUP_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"binding analysis for destructure","suites":["SFC compile <script setup>"],"updatePoint":{"line":54,"column":40},"line":54,"code":"  test('binding analysis for destructure', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { foo, b: bar, ['x' + 'y']: baz, x: { y, zz: { z }}} = {}\n      </script>\n      `)\n    expect(content).toMatch('return { foo, bar, baz, y, z }')\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_MAYBE_REF,\n      bar: BindingTypes.SETUP_MAYBE_REF,\n      baz: BindingTypes.SETUP_MAYBE_REF,\n      y: BindingTypes.SETUP_MAYBE_REF,\n      z: BindingTypes.SETUP_MAYBE_REF\n    })\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/defineEmits in multi-variable declaration","suites":["SFC compile <script setup>"],"updatePoint":{"line":71,"column":61},"line":71,"code":"  test('defineProps/defineEmits in multi-variable declaration', () => {\n    const { content } = compile(`\n    <script setup>\n    const props = defineProps(['item']),\n      a = 1,\n      emit = defineEmits(['a']);\n    </script>\n  `)\n    assertCode(content)\n    expect(content).toMatch(`const a = 1;`) // test correct removal\n    expect(content).toMatch(`props: ['item'],`)\n    expect(content).toMatch(`emits: ['a'],`)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/defineEmits in multi-variable declaration fix #6757 ","suites":["SFC compile <script setup>"],"updatePoint":{"line":86,"column":72},"line":86,"code":"  test('defineProps/defineEmits in multi-variable declaration fix #6757 ', () => {\n    const { content } = compile(`\n    <script setup>\n    const a = 1,\n          props = defineProps(['item']),\n          emit = defineEmits(['a']);\n    </script>\n  `)\n    assertCode(content)\n    expect(content).toMatch(`const a = 1;`) // test correct removal\n    expect(content).toMatch(`props: ['item'],`)\n    expect(content).toMatch(`emits: ['a'],`)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/defineEmits in multi-variable declaration fix #7422","suites":["SFC compile <script setup>"],"updatePoint":{"line":101,"column":71},"line":101,"code":"  test('defineProps/defineEmits in multi-variable declaration fix #7422', () => {\n    const { content } = compile(`\n    <script setup>\n    const props = defineProps(['item']),\n          emits = defineEmits(['foo']),\n          a = 0,\n          b = 0;\n    </script>\n  `)\n    assertCode(content)\n    expect(content).toMatch(`props: ['item'],`)\n    expect(content).toMatch(`emits: ['foo'],`)\n    expect(content).toMatch(`const a = 0,`)\n    expect(content).toMatch(`b = 0;`)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/defineEmits in multi-variable declaration (full removal)","suites":["SFC compile <script setup>"],"updatePoint":{"line":117,"column":76},"line":117,"code":"  test('defineProps/defineEmits in multi-variable declaration (full removal)', () => {\n    const { content } = compile(`\n    <script setup>\n    const props = defineProps(['item']),\n          emit = defineEmits(['a']);\n    </script>\n  `)\n    assertCode(content)\n    expect(content).toMatch(`props: ['item'],`)\n    expect(content).toMatch(`emits: ['a'],`)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"script first","suites":["SFC compile <script setup>","<script> and <script setup> co-usage"],"updatePoint":{"line":130,"column":22},"line":130,"code":"    test('script first', () => {\n      const { content } = compile(`\n      <script>\n      export const n = 1\n\n      export default {}\n      </script>\n      <script setup>\n      import { x } from './x'\n      x()\n      </script>\n      `)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"script setup first","suites":["SFC compile <script setup>","<script> and <script setup> co-usage"],"updatePoint":{"line":145,"column":28},"line":145,"code":"    test('script setup first', () => {\n      const { content } = compile(`\n      <script setup>\n      import { x } from './x'\n      x()\n      </script>\n      <script>\n      export const n = 1\n      export default {}\n      </script>\n      `)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"script setup first, named default export","suites":["SFC compile <script setup>","<script> and <script setup> co-usage"],"updatePoint":{"line":159,"column":50},"line":159,"code":"    test('script setup first, named default export', () => {\n      const { content } = compile(`\n      <script setup>\n      import { x } from './x'\n      x()\n      </script>\n      <script>\n      export const n = 1\n      const def = {}\n      export { def as default }\n      </script>\n      `)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"script setup first, lang=\"ts\", script block content export default","suites":["SFC compile <script setup>","<script> and <script setup> co-usage"],"updatePoint":{"line":175,"column":76},"line":175,"code":"    test('script setup first, lang=\"ts\", script block content export default', () => {\n      const { content } = compile(`\n      <script setup lang=\"ts\">\n      import { x } from './x'\n      x()\n      </script>\n      <script lang=\"ts\">\n      export default {\n        name: \"test\"\n      }\n      </script>\n      `)\n      // ensure __default__ is declared before used\n      expect(content).toMatch(/const __default__[\\S\\s]*\\.\\.\\.__default__/m)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"with many spaces and newline","suites":["SFC compile <script setup>","<script> and <script setup> co-usage","spaces in ExportDefaultDeclaration node"],"updatePoint":{"line":194,"column":40},"line":194,"code":"      test('with many spaces and newline', () => {\n        // #4371\n        const { content } = compile(`\n        <script>\n        export const n = 1\n        export        default\n        {\n          some:'option'\n        }\n        </script>\n        <script setup>\n        import { x } from './x'\n        x()\n        </script>\n        `)\n        assertCode(content)\n      })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"with minimal spaces","suites":["SFC compile <script setup>","<script> and <script setup> co-usage","spaces in ExportDefaultDeclaration node"],"updatePoint":{"line":212,"column":31},"line":212,"code":"      test('with minimal spaces', () => {\n        const { content } = compile(`\n        <script>\n        export const n = 1\n        export default{\n          some:'option'\n        }\n        </script>\n        <script setup>\n        import { x } from './x'\n        x()\n        </script>\n        `)\n        assertCode(content)\n      })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export call expression as default","suites":["SFC compile <script setup>","<script> and <script setup> co-usage","spaces in ExportDefaultDeclaration node"],"updatePoint":{"line":229,"column":43},"line":229,"code":"    test('export call expression as default', () => {\n      const { content } = compile(`\n      <script>\n      function fn() {\n        return \"hello, world\";\n      }\n      export default fn();\n      </script>\n\n      <script setup>\n      console.log('foo')\n      </script>\n      `)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should hoist and expose imports","suites":["SFC compile <script setup>","imports"],"updatePoint":{"line":247,"column":41},"line":247,"code":"    test('should hoist and expose imports', () => {\n      assertCode(\n        compile(`<script setup>\n          import { ref } from 'vue'\n          import 'foo/css'\n        </script>`).content\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should extract comment for import or type declarations","suites":["SFC compile <script setup>","imports"],"updatePoint":{"line":256,"column":64},"line":256,"code":"    test('should extract comment for import or type declarations', () => {\n      assertCode(\n        compile(`\n        <script setup>\n        import a from 'a' // comment\n        import b from 'b'\n        </script>\n        `).content\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow defineProps/Emit at the start of imports","suites":["SFC compile <script setup>","imports"],"updatePoint":{"line":268,"column":63},"line":268,"code":"    test('should allow defineProps/Emit at the start of imports', () => {\n      assertCode(\n        compile(`<script setup>\n      import { ref } from 'vue'\n      defineProps(['foo'])\n      defineEmits(['bar'])\n      const r = ref(0)\n      </script>`).content\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"dedupe between user & helper","suites":["SFC compile <script setup>","imports"],"updatePoint":{"line":279,"column":38},"line":279,"code":"    test('dedupe between user & helper', () => {\n      const { content } = compile(\n        `\n      <script setup>\n      import { ref } from 'vue'\n      let foo = $ref(1)\n      </script>\n      `,\n        { reactivityTransform: true }\n      )\n      assertCode(content)\n      expect(content).toMatch(`import { ref } from 'vue'`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"import dedupe between <script> and <script setup>","suites":["SFC compile <script setup>","imports"],"updatePoint":{"line":293,"column":59},"line":293,"code":"    test('import dedupe between <script> and <script setup>', () => {\n      const { content } = compile(`\n        <script>\n        import { x } from './x'\n        </script>\n        <script setup>\n        import { x } from './x'\n        x()\n        </script>\n        `)\n      assertCode(content)\n      expect(content.indexOf(`import { x }`)).toEqual(\n        content.lastIndexOf(`import { x }`)\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"import directly","suites":["SFC compile <script setup>","imports","import ref/reactive function from other place"],"updatePoint":{"line":310,"column":27},"line":310,"code":"      test('import directly', () => {\n        const { bindings } = compile(`\n        <script setup>\n          import { ref, reactive } from './foo'\n\n          const foo = ref(1)\n          const bar = reactive(1)\n        </script>\n      `)\n        expect(bindings).toStrictEqual({\n          ref: BindingTypes.SETUP_MAYBE_REF,\n          reactive: BindingTypes.SETUP_MAYBE_REF,\n          foo: BindingTypes.SETUP_MAYBE_REF,\n          bar: BindingTypes.SETUP_MAYBE_REF\n        })\n      })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"import w/ alias","suites":["SFC compile <script setup>","imports","import ref/reactive function from other place"],"updatePoint":{"line":327,"column":27},"line":327,"code":"      test('import w/ alias', () => {\n        const { bindings } = compile(`\n        <script setup>\n          import { ref as _ref, reactive as _reactive } from './foo'\n\n          const foo = ref(1)\n          const bar = reactive(1)\n        </script>\n      `)\n        expect(bindings).toStrictEqual({\n          _reactive: BindingTypes.SETUP_MAYBE_REF,\n          _ref: BindingTypes.SETUP_MAYBE_REF,\n          foo: BindingTypes.SETUP_MAYBE_REF,\n          bar: BindingTypes.SETUP_MAYBE_REF\n        })\n      })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"aliased usage before import site","suites":["SFC compile <script setup>","imports","import ref/reactive function from other place"],"updatePoint":{"line":344,"column":44},"line":344,"code":"      test('aliased usage before import site', () => {\n        const { bindings } = compile(`\n        <script setup>\n          const bar = x(1)\n          import { reactive as x } from 'vue'\n        </script>\n      `)\n        expect(bindings).toStrictEqual({\n          bar: BindingTypes.SETUP_REACTIVE_CONST,\n          x: BindingTypes.SETUP_CONST\n        })\n      })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should support module string names syntax","suites":["SFC compile <script setup>","imports","import ref/reactive function from other place"],"updatePoint":{"line":358,"column":51},"line":358,"code":"    test('should support module string names syntax', () => {\n      const { content, bindings } = compile(`\n      <script>\n        import { \"\" as foo } from './foo'\n      </script>\n      <script setup>\n        import { \"\" as foo } from './foo'\n      </script>\n    `)\n      assertCode(content)\n      expect(bindings).toStrictEqual({\n        foo: BindingTypes.SETUP_MAYBE_REF\n      })\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"components","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":379,"column":20},"line":379,"code":"    test('components', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { FooBar, FooBaz, FooQux, foo } from './x'\n        const fooBar: FooBar = 1\n        </script>\n        <template>\n          <FooBaz></FooBaz>\n          <foo-qux/>\n          <foo/>\n          FooBar\n        </template>\n        `)\n      // FooBar: should not be matched by plain text or incorrect case\n      // FooBaz: used as PascalCase component\n      // FooQux: used as kebab-case component\n      // foo: lowercase component\n      expect(content).toMatch(\n        `return { fooBar, get FooBaz() { return FooBaz }, ` +\n          `get FooQux() { return FooQux }, get foo() { return foo } }`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"directive","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":403,"column":19},"line":403,"code":"    test('directive', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { vMyDir } from './x'\n        </script>\n        <template>\n          <div v-my-dir></div>\n        </template>\n        `)\n      expect(content).toMatch(`return { get vMyDir() { return vMyDir } }`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"attribute expressions","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":417,"column":31},"line":417,"code":"    test('attribute expressions', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { bar, baz } from './x'\n        const cond = true\n        </script>\n        <template>\n          <div :class=\"[cond ? '' : bar(), 'default']\" :style=\"baz\"></div>\n        </template>\n        `)\n      expect(content).toMatch(\n        `return { cond, get bar() { return bar }, get baz() { return baz } }`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"vue interpolations","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":433,"column":28},"line":433,"code":"    test('vue interpolations', () => {\n      const { content } = compile(`\n      <script setup lang=\"ts\">\n      import { x, y, z, x$y } from './x'\n      </script>\n      <template>\n        <div :id=\"z + 'y'\">{{ x }} {{ yy }} {{ x$y }}</div>\n      </template>\n      `)\n      // x: used in interpolation\n      // y: should not be matched by {{ yy }} or 'y' in binding exps\n      // x$y: #4274 should escape special chars when creating Regex\n      expect(content).toMatch(\n        `return { get x() { return x }, get z() { return z }, get x$y() { return x$y } }`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"js template string interpolations","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":452,"column":43},"line":452,"code":"    test('js template string interpolations', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { VAR, VAR2, VAR3 } from './x'\n        </script>\n        <template>\n          {{ \\`\\${VAR}VAR2\\${VAR3}\\` }}\n        </template>\n        `)\n      // VAR2 should not be matched\n      expect(content).toMatch(\n        `return { get VAR() { return VAR }, get VAR3() { return VAR3 } }`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"last tag","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":469,"column":18},"line":469,"code":"    test('last tag', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { FooBaz, Last } from './x'\n        </script>\n        <template>\n          <FooBaz></FooBaz>\n          <Last/>\n        </template>\n        `)\n      expect(content).toMatch(\n        `return { get FooBaz() { return FooBaz }, get Last() { return Last } }`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"TS annotations","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":485,"column":24},"line":485,"code":"    test('TS annotations', () => {\n      const { content } = compile(`\n        <script setup lang=\"ts\">\n        import { Foo, Bar, Baz, Qux, Fred } from './x'\n        const a = 1\n        function b() {}\n        </script>\n        <template>\n          {{ a as Foo }}\n          {{ b<Bar>() }}\n          {{ Baz }}\n          <Comp v-slot=\"{ data }: Qux\">{{ data }}</Comp>\n          <div v-for=\"{ z = x as Qux } in list as Fred\"/>\n        </template>\n        `)\n      expect(content).toMatch(`return { a, b, get Baz() { return Baz } }`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"v-on inline statement","suites":["SFC compile <script setup>","dev mode import usage check"],"updatePoint":{"line":505,"column":31},"line":505,"code":"    test('v-on inline statement', () => {\n      // should not error\n      compile(`\n      <script setup lang=\"ts\">\n        import { foo } from './foo'\n      </script>\n      <template>\n        <div @click=\"$emit('update:a');\"></div>\n      </template>\n      `)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should work","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":519,"column":21},"line":519,"code":"    test('should work', () => {\n      const { content } = compile(\n        `\n        <script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        </script>\n        <template>\n          <div>{{ count }}</div>\n          <div>static</div>\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // check snapshot and make sure helper imports and\n      // hoists are placed correctly.\n      assertCode(content)\n      // in inline mode, no need to call expose() since nothing is exposed\n      // anyway!\n      expect(content).not.toMatch(`expose()`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"with defineExpose()","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":541,"column":29},"line":541,"code":"    test('with defineExpose()', () => {\n      const { content } = compile(\n        `\n        <script setup>\n        const count = ref(0)\n        defineExpose({ count })\n        </script>\n        `,\n        { inlineTemplate: true }\n      )\n      assertCode(content)\n      expect(content).toMatch(`setup(__props, { expose: __expose })`)\n      expect(content).toMatch(`expose({ count })`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"referencing scope components and directives","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":556,"column":53},"line":556,"code":"    test('referencing scope components and directives', () => {\n      const { content } = compile(\n        `\n        <script setup>\n        import ChildComp from './Child.vue'\n        import SomeOtherComp from './Other.vue'\n        import vMyDir from './my-dir'\n        </script>\n        <template>\n          <div v-my-dir></div>\n          <ChildComp/>\n          <some-other-comp/>\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      expect(content).toMatch('[_unref(vMyDir)]')\n      expect(content).toMatch('_createVNode(ChildComp)')\n      // kebab-case component support\n      expect(content).toMatch('_createVNode(SomeOtherComp)')\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"avoid unref() when necessary","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":579,"column":38},"line":579,"code":"    test('avoid unref() when necessary', () => {\n      // function, const, component import\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        import Foo, { bar } from './Foo.vue'\n        import other from './util'\n        import * as tree from './tree'\n        const count = ref(0)\n        const constant = {}\n        const maybe = foo()\n        let lett = 1\n        function fn() {}\n        </script>\n        <template>\n          <Foo>{{ bar }}</Foo>\n          <div @click=\"fn\">{{ count }} {{ constant }} {{ maybe }} {{ lett }} {{ other }}</div>\n          {{ tree.foo() }}\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // no need to unref vue component import\n      expect(content).toMatch(`createVNode(Foo,`)\n      // #2699 should unref named imports from .vue\n      expect(content).toMatch(`unref(bar)`)\n      // should unref other imports\n      expect(content).toMatch(`unref(other)`)\n      // no need to unref constant literals\n      expect(content).not.toMatch(`unref(constant)`)\n      // should directly use .value for known refs\n      expect(content).toMatch(`count.value`)\n      // should unref() on const bindings that may be refs\n      expect(content).toMatch(`unref(maybe)`)\n      // should unref() on let bindings\n      expect(content).toMatch(`unref(lett)`)\n      // no need to unref namespace import (this also preserves tree-shaking)\n      expect(content).toMatch(`tree.foo()`)\n      // no need to unref function declarations\n      expect(content).toMatch(`{ onClick: fn }`)\n      // no need to mark constant fns in patch flag\n      expect(content).not.toMatch(`PROPS`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"v-model codegen","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":624,"column":25},"line":624,"code":"    test('v-model codegen', () => {\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        const maybe = foo()\n        let lett = 1\n        </script>\n        <template>\n          <input v-model=\"count\">\n          <input v-model=\"maybe\">\n          <input v-model=\"lett\">\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // known const ref: set value\n      expect(content).toMatch(`(count).value = $event`)\n      // const but maybe ref: assign if ref, otherwise do nothing\n      expect(content).toMatch(`_isRef(maybe) ? (maybe).value = $event : null`)\n      // let: handle both cases\n      expect(content).toMatch(\n        `_isRef(lett) ? (lett).value = $event : lett = $event`\n      )\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"v-model should not generate ref assignment code for non-setup bindings","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":651,"column":80},"line":651,"code":"    test('v-model should not generate ref assignment code for non-setup bindings', () => {\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        </script>\n        <script>\n        export default {\n          data() { return { foo: 123 } }\n        }\n        </script>\n        <template>\n          <input v-model=\"foo\">\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      expect(content).not.toMatch(`_isRef(foo)`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template assignment expression codegen","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":671,"column":48},"line":671,"code":"    test('template assignment expression codegen', () => {\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        const maybe = foo()\n        let lett = 1\n        let v = ref(1)\n        </script>\n        <template>\n          <div @click=\"count = 1\"/>\n          <div @click=\"maybe = count\"/>\n          <div @click=\"lett = count\"/>\n          <div @click=\"v += 1\"/>\n          <div @click=\"v -= 1\"/>\n          <div @click=\"() => {\n              let a = '' + lett\n              v = a\n           }\"/>\n           <div @click=\"() => {\n              // nested scopes\n              (()=>{\n                let x = a\n                (()=>{\n                  let z = x\n                  let z2 = z\n                })\n                let lz = z\n              })\n              v = a\n           }\"/>\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // known const ref: set value\n      expect(content).toMatch(`count.value = 1`)\n      // const but maybe ref: only assign after check\n      expect(content).toMatch(`maybe.value = count.value`)\n      // let: handle both cases\n      expect(content).toMatch(\n        `_isRef(lett) ? lett.value = count.value : lett = count.value`\n      )\n      expect(content).toMatch(`_isRef(v) ? v.value += 1 : v += 1`)\n      expect(content).toMatch(`_isRef(v) ? v.value -= 1 : v -= 1`)\n      expect(content).toMatch(`_isRef(v) ? v.value = a : v = a`)\n      expect(content).toMatch(`_isRef(v) ? v.value = _ctx.a : v = _ctx.a`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template update expression codegen","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":721,"column":44},"line":721,"code":"    test('template update expression codegen', () => {\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        const maybe = foo()\n        let lett = 1\n        </script>\n        <template>\n          <div @click=\"count++\"/>\n          <div @click=\"--count\"/>\n          <div @click=\"maybe++\"/>\n          <div @click=\"--maybe\"/>\n          <div @click=\"lett++\"/>\n          <div @click=\"--lett\"/>\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // known const ref: set value\n      expect(content).toMatch(`count.value++`)\n      expect(content).toMatch(`--count.value`)\n      // const but maybe ref (non-ref case ignored)\n      expect(content).toMatch(`maybe.value++`)\n      expect(content).toMatch(`--maybe.value`)\n      // let: handle both cases\n      expect(content).toMatch(`_isRef(lett) ? lett.value++ : lett++`)\n      expect(content).toMatch(`_isRef(lett) ? --lett.value : --lett`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template destructure assignment codegen","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":752,"column":49},"line":752,"code":"    test('template destructure assignment codegen', () => {\n      const { content } = compile(\n        `<script setup>\n        import { ref } from 'vue'\n        const val = {}\n        const count = ref(0)\n        const maybe = foo()\n        let lett = 1\n        </script>\n        <template>\n          <div @click=\"({ count } = val)\"/>\n          <div @click=\"[maybe] = val\"/>\n          <div @click=\"({ lett } = val)\"/>\n        </template>\n        `,\n        { inlineTemplate: true }\n      )\n      // known const ref: set value\n      expect(content).toMatch(`({ count: count.value } = val)`)\n      // const but maybe ref (non-ref case ignored)\n      expect(content).toMatch(`[maybe.value] = val`)\n      // let: assumes non-ref\n      expect(content).toMatch(`{ lett: lett } = val`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ssr codegen","suites":["SFC compile <script setup>","inlineTemplate mode"],"updatePoint":{"line":778,"column":21},"line":778,"code":"    test('ssr codegen', () => {\n      const { content } = compile(\n        `\n        <script setup>\n        import { ref } from 'vue'\n        const count = ref(0)\n        </script>\n        <template>\n          <div>{{ count }}</div>\n          <div>static</div>\n        </template>\n        <style>\n        div { color: v-bind(count) }\n        </style>\n        `,\n        {\n          inlineTemplate: true,\n          templateOptions: {\n            ssr: true\n          }\n        }\n      )\n      expect(content).toMatch(`\\n  __ssrInlineRender: true,\\n`)\n      expect(content).toMatch(`return (_ctx, _push`)\n      expect(content).toMatch(`ssrInterpolate`)\n      expect(content).not.toMatch(`useCssVars`)\n      expect(content).toMatch(`\"--${mockId}-count\": (count.value)`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"hoist type declarations","suites":["SFC compile <script setup>","with TypeScript"],"updatePoint":{"line":810,"column":33},"line":810,"code":"    test('hoist type declarations', () => {\n      const { content } = compile(`\n      <script setup lang=\"ts\">\n        export interface Foo {}\n        type Bar = {}\n      </script>`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"runtime Enum","suites":["SFC compile <script setup>","with TypeScript"],"updatePoint":{"line":819,"column":22},"line":819,"code":"    test('runtime Enum', () => {\n      const { content, bindings } = compile(\n        `<script setup lang=\"ts\">\n        enum Foo { A = 123 }\n        </script>`\n      )\n      assertCode(content)\n      expect(bindings).toStrictEqual({\n        Foo: BindingTypes.LITERAL_CONST\n      })\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"runtime Enum in normal script","suites":["SFC compile <script setup>","with TypeScript"],"updatePoint":{"line":831,"column":39},"line":831,"code":"    test('runtime Enum in normal script', () => {\n      const { content, bindings } = compile(\n        `<script lang=\"ts\">\n          export enum D { D = \"D\" }\n          const enum C { C = \"C\" }\n          enum B { B = \"B\" }\n        </script>\n        <script setup lang=\"ts\">\n        enum Foo { A = 123 }\n        </script>`\n      )\n      assertCode(content)\n      expect(bindings).toStrictEqual({\n        D: BindingTypes.LITERAL_CONST,\n        C: BindingTypes.LITERAL_CONST,\n        B: BindingTypes.LITERAL_CONST,\n        Foo: BindingTypes.LITERAL_CONST\n      })\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"const Enum","suites":["SFC compile <script setup>","with TypeScript"],"updatePoint":{"line":851,"column":20},"line":851,"code":"    test('const Enum', () => {\n      const { content, bindings } = compile(\n        `<script setup lang=\"ts\">\n        const enum Foo { A = 123 }\n        </script>`,\n        { hoistStatic: true }\n      )\n      assertCode(content)\n      expect(bindings).toStrictEqual({\n        Foo: BindingTypes.LITERAL_CONST\n      })\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"import type","suites":["SFC compile <script setup>","with TypeScript"],"updatePoint":{"line":864,"column":21},"line":864,"code":"    test('import type', () => {\n      const { content } = compile(\n        `<script setup lang=\"ts\">\n        import type { Foo } from './main.ts'\n        import { type Bar, Baz } from './main.ts'\n        </script>`\n      )\n      expect(content).toMatch(`return { get Baz() { return Baz } }`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"expression statement","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":889,"column":30},"line":889,"code":"    test('expression statement', () => {\n      assertAwaitDetection(`await foo`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"variable","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":893,"column":18},"line":893,"code":"    test('variable', () => {\n      assertAwaitDetection(`const a = 1 + (await foo)`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ref","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":897,"column":13},"line":897,"code":"    test('ref', () => {\n      assertAwaitDetection(`let a = $ref(1 + (await foo))`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"nested await","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":902,"column":22},"line":902,"code":"    test('nested await', () => {\n      assertAwaitDetection(`await (await foo)`)\n      assertAwaitDetection(`await ((await foo))`)\n      assertAwaitDetection(`await (await (await foo))`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"nested leading await in expression statement","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":909,"column":54},"line":909,"code":"    test('nested leading await in expression statement', () => {\n      const code = assertAwaitDetection(`foo()\\nawait 1 + await 2`)\n      expect(code).toMatch(`foo()\\n;(`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"single line conditions","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":915,"column":32},"line":915,"code":"    test('single line conditions', () => {\n      const code = assertAwaitDetection(`if (false) await foo()`)\n      expect(code).not.toMatch(`if (false) ;(`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"nested statements","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":920,"column":27},"line":920,"code":"    test('nested statements', () => {\n      assertAwaitDetection(`if (ok) { await foo } else { await bar }`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"multiple `if` nested statements","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":924,"column":41},"line":924,"code":"    test('multiple `if` nested statements', () => {\n      assertAwaitDetection(`if (ok) {\n        let a = 'foo'\n        await 0 + await 1\n        await 2\n      } else if (a) {\n        await 10\n        if (b) {\n          await 0 + await 1\n        } else {\n          let a = 'foo'\n          await 2\n        }\n        if (b) {\n          await 3\n          await 4\n        }\n      } else {\n        await 5\n      }`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"multiple `if while` nested statements","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":946,"column":47},"line":946,"code":"    test('multiple `if while` nested statements', () => {\n      assertAwaitDetection(`if (ok) {\n        while (d) {\n          await 5\n        }\n        while (d) {\n          await 5\n          await 6\n          if (c) {\n            let f = 10\n            10 + await 7\n          } else {\n            await 8\n            await 9\n          }\n        }\n      }`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"multiple `if for` nested statements","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":965,"column":45},"line":965,"code":"    test('multiple `if for` nested statements', () => {\n      assertAwaitDetection(`if (ok) {\n        for (let a of [1,2,3]) {\n          await a\n        }\n        for (let a of [1,2,3]) {\n          await a\n          await a\n        }\n      }`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should ignore await inside functions","suites":["SFC compile <script setup>","async/await detection"],"updatePoint":{"line":977,"column":46},"line":977,"code":"    test('should ignore await inside functions', () => {\n      // function declaration\n      assertAwaitDetection(`async function foo() { await bar }`, false)\n      // function expression\n      assertAwaitDetection(`const foo = async () => { await bar }`, false)\n      // object method\n      assertAwaitDetection(`const obj = { async method() { await bar }}`, false)\n      // class method\n      assertAwaitDetection(\n        `const cls = class Foo { async method() { await bar }}`,\n        false\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> and <script setup> must have same lang","suites":["SFC compile <script setup>","errors"],"updatePoint":{"line":993,"column":57},"line":993,"code":"    test('<script> and <script setup> must have same lang', () => {\n      expect(() =>\n        compile(`<script>foo()</script><script setup lang=\"ts\">bar()</script>`)\n      ).toThrow(`<script> and <script setup> must have the same language type`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"non-type named exports","suites":["SFC compile <script setup>","errors"],"updatePoint":{"line":1001,"column":32},"line":1001,"code":"    test('non-type named exports', () => {\n      expect(() =>\n        compile(`<script setup>\n        export const a = 1\n        </script>`)\n      ).toThrow(moduleErrorMsg)\n\n      expect(() =>\n        compile(`<script setup>\n        export * from './foo'\n        </script>`)\n      ).toThrow(moduleErrorMsg)\n\n      expect(() =>\n        compile(`<script setup>\n          const bar = 1\n          export { bar as default }\n        </script>`)\n      ).toThrow(moduleErrorMsg)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/Emit() referencing local var","suites":["SFC compile <script setup>","errors"],"updatePoint":{"line":1022,"column":50},"line":1022,"code":"    test('defineProps/Emit() referencing local var', () => {\n      expect(() =>\n        compile(`<script setup>\n        let bar = 1\n        defineProps({\n          foo: {\n            default: () => bar\n          }\n        })\n        </script>`)\n      ).toThrow(`cannot reference locally declared variables`)\n\n      expect(() =>\n        compile(`<script setup>\n        let bar = 'hello'\n        defineEmits([bar])\n        </script>`)\n      ).toThrow(`cannot reference locally declared variables`)\n\n      // #4644\n      expect(() =>\n        compile(`\n        <script>const bar = 1</script>\n        <script setup>\n        defineProps({\n          foo: {\n            default: () => bar\n          }\n        })\n        </script>`)\n      ).not.toThrow(`cannot reference locally declared variables`)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow defineProps/Emit() referencing scope var","suites":["SFC compile <script setup>","errors"],"updatePoint":{"line":1055,"column":63},"line":1055,"code":"    test('should allow defineProps/Emit() referencing scope var', () => {\n      assertCode(\n        compile(`<script setup>\n          const bar = 1\n          defineProps({\n            foo: {\n              default: bar => bar + 1\n            }\n          })\n          defineEmits({\n            foo: bar => bar > 1\n          })\n        </script>`).content\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow defineProps/Emit() referencing imported binding","suites":["SFC compile <script setup>","errors"],"updatePoint":{"line":1071,"column":70},"line":1071,"code":"    test('should allow defineProps/Emit() referencing imported binding', () => {\n      assertCode(\n        compile(`<script setup>\n        import { bar } from './bar'\n        defineProps({\n          foo: {\n            default: () => bar\n          }\n        })\n        defineEmits({\n          foo: () => bar > 1\n        })\n        </script>`).content\n      )\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"can parse decorators syntax in typescript block","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1090,"column":53},"line":1090,"code":"  it('can parse decorators syntax in typescript block', () => {\n    const { scriptAst } = compile(`\n      <script lang=\"ts\">\n        import { Options, Vue } from 'vue-class-component';\n        @Options({\n          components: {\n            HelloWorld,\n          },\n          props: ['foo', 'bar']\n        })\n        export default class Home extends Vue {}\n      </script>\n    `)\n\n    expect(scriptAst).toBeDefined()\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes props array declaration","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1107,"column":40},"line":1107,"code":"  it('recognizes props array declaration', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          props: ['foo', 'bar']\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS\n    })\n    expect(bindings!.__isScriptSetup).toBe(false)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes props object declaration","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1122,"column":41},"line":1122,"code":"  it('recognizes props object declaration', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          props: {\n            foo: String,\n            bar: {\n              type: String,\n            },\n            baz: null,\n            qux: [String, Number]\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS,\n      baz: BindingTypes.PROPS,\n      qux: BindingTypes.PROPS\n    })\n    expect(bindings!.__isScriptSetup).toBe(false)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes setup return","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1146,"column":29},"line":1146,"code":"  it('recognizes setup return', () => {\n    const { bindings } = compile(`\n      <script>\n        const bar = 2\n        export default {\n          setup() {\n            return {\n              foo: 1,\n              bar\n            }\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_MAYBE_REF,\n      bar: BindingTypes.SETUP_MAYBE_REF\n    })\n    expect(bindings!.__isScriptSetup).toBe(false)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes exported vars","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1167,"column":30},"line":1167,"code":"  it('recognizes exported vars', () => {\n    const { bindings } = compile(`\n      <script>\n        export const foo = 2\n      </script>\n      <script setup>\n        console.log(foo)\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.LITERAL_CONST\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes async setup return","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1181,"column":35},"line":1181,"code":"  it('recognizes async setup return', () => {\n    const { bindings } = compile(`\n      <script>\n        const bar = 2\n        export default {\n          async setup() {\n            return {\n              foo: 1,\n              bar\n            }\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_MAYBE_REF,\n      bar: BindingTypes.SETUP_MAYBE_REF\n    })\n    expect(bindings!.__isScriptSetup).toBe(false)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes data return","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1202,"column":28},"line":1202,"code":"  it('recognizes data return', () => {\n    const { bindings } = compile(`\n      <script>\n        const bar = 2\n        export default {\n          data() {\n            return {\n              foo: null,\n              bar\n            }\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.DATA,\n      bar: BindingTypes.DATA\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes methods","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1222,"column":24},"line":1222,"code":"  it('recognizes methods', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          methods: {\n            foo() {}\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({ foo: BindingTypes.OPTIONS })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes computeds","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1235,"column":26},"line":1235,"code":"  it('recognizes computeds', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          computed: {\n            foo() {},\n            bar: {\n              get() {},\n              set() {},\n            }\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.OPTIONS,\n      bar: BindingTypes.OPTIONS\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes injections array declaration","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1255,"column":45},"line":1255,"code":"  it('recognizes injections array declaration', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          inject: ['foo', 'bar']\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.OPTIONS,\n      bar: BindingTypes.OPTIONS\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"recognizes injections object declaration","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1269,"column":46},"line":1269,"code":"  it('recognizes injections object declaration', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          inject: {\n            foo: {},\n            bar: {},\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.OPTIONS,\n      bar: BindingTypes.OPTIONS\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"works for mixed bindings","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1286,"column":30},"line":1286,"code":"  it('works for mixed bindings', () => {\n    const { bindings } = compile(`\n      <script>\n        export default {\n          inject: ['foo'],\n          props: {\n            bar: String,\n          },\n          setup() {\n            return {\n              baz: null,\n            }\n          },\n          data() {\n            return {\n              qux: null\n            }\n          },\n          methods: {\n            quux() {}\n          },\n          computed: {\n            quuz() {}\n          }\n        }\n      </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.OPTIONS,\n      bar: BindingTypes.PROPS,\n      baz: BindingTypes.SETUP_MAYBE_REF,\n      qux: BindingTypes.DATA,\n      quux: BindingTypes.OPTIONS,\n      quuz: BindingTypes.OPTIONS\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"works for script setup","suites":["SFC analyze <script> bindings"],"updatePoint":{"line":1323,"column":28},"line":1323,"code":"  it('works for script setup', () => {\n    const { bindings } = compile(`\n      <script setup>\n      import { ref as r } from 'vue'\n      defineProps({\n        foo: String\n      })\n\n      const a = r(1)\n      let b = 2\n      const c = 3\n      const { d } = someFoo()\n      let { e } = someBar()\n      </script>\n    `)\n\n    expect(bindings).toStrictEqual({\n      r: BindingTypes.SETUP_CONST,\n      a: BindingTypes.SETUP_REF,\n      b: BindingTypes.SETUP_LET,\n      c: BindingTypes.LITERAL_CONST,\n      d: BindingTypes.SETUP_MAYBE_REF,\n      e: BindingTypes.SETUP_LET,\n      foo: BindingTypes.PROPS\n    })\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic","suites":["SFC analyze <script> bindings","auto name inference"],"updatePoint":{"line":1351,"column":15},"line":1351,"code":"    test('basic', () => {\n      const { content } = compile(\n        `<script setup>const a = 1</script>\n        <template>{{ a }}</template>`,\n        undefined,\n        {\n          filename: 'FooBar.vue'\n        }\n      )\n      expect(content).toMatch(`export default {\n  __name: 'FooBar'`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"do not overwrite manual name (object)","suites":["SFC analyze <script> bindings","auto name inference"],"updatePoint":{"line":1365,"column":47},"line":1365,"code":"    test('do not overwrite manual name (object)', () => {\n      const { content } = compile(\n        `<script>\n        export default {\n          name: 'Baz'\n        }\n        </script>\n        <script setup>const a = 1</script>\n        <template>{{ a }}</template>`,\n        undefined,\n        {\n          filename: 'FooBar.vue'\n        }\n      )\n      expect(content).not.toMatch(`name: 'FooBar'`)\n      expect(content).toMatch(`name: 'Baz'`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"do not overwrite manual name (call)","suites":["SFC analyze <script> bindings","auto name inference"],"updatePoint":{"line":1384,"column":45},"line":1384,"code":"    test('do not overwrite manual name (call)', () => {\n      const { content } = compile(\n        `<script>\n        import { defineComponent } from 'vue'\n        export default defineComponent({\n          name: 'Baz'\n        })\n        </script>\n        <script setup>const a = 1</script>\n        <template>{{ a }}</template>`,\n        undefined,\n        {\n          filename: 'FooBar.vue'\n        }\n      )\n      expect(content).not.toMatch(`name: 'FooBar'`)\n      expect(content).toMatch(`name: 'Baz'`)\n      assertCode(content)\n    })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"normal <script> only","suites":["SFC genDefaultAs"],"updatePoint":{"line":1407,"column":28},"line":1407,"code":"  test('normal <script> only', () => {\n    const { content } = compile(\n      `<script>\n      export default {}\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(`const _sfc_ = {}`)\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"normal <script> w/ cssVars","suites":["SFC genDefaultAs"],"updatePoint":{"line":1421,"column":34},"line":1421,"code":"  test('normal <script> w/ cssVars', () => {\n    const { content } = compile(\n      `<script>\n      export default {}\n      </script>\n      <style>\n      .foo { color: v-bind(x) }\n      </style>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).not.toMatch('__default__')\n    expect(content).toMatch(`const _sfc_ = {}`)\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> + <script setup>","suites":["SFC genDefaultAs"],"updatePoint":{"line":1439,"column":33},"line":1439,"code":"  test('<script> + <script setup>', () => {\n    const { content } = compile(\n      `<script>\n      export default {}\n      </script>\n      <script setup>\n      const a = 1\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(\n      `const _sfc_ = /*#__PURE__*/Object.assign(__default__`\n    )\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> + <script setup>","suites":["SFC genDefaultAs"],"updatePoint":{"line":1458,"column":33},"line":1458,"code":"  test('<script> + <script setup>', () => {\n    const { content } = compile(\n      `<script>\n      export default {}\n      </script>\n      <script setup>\n      const a = 1\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(\n      `const _sfc_ = /*#__PURE__*/Object.assign(__default__`\n    )\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script setup> only","suites":["SFC genDefaultAs"],"updatePoint":{"line":1477,"column":27},"line":1477,"code":"  test('<script setup> only', () => {\n    const { content } = compile(\n      `<script setup>\n      const a = 1\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(`const _sfc_ = {\\n  setup`)\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script setup> only w/ ts","suites":["SFC genDefaultAs"],"updatePoint":{"line":1491,"column":33},"line":1491,"code":"  test('<script setup> only w/ ts', () => {\n    const { content } = compile(\n      `<script setup lang=\"ts\">\n      const a = 1\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(`const _sfc_ = /*#__PURE__*/_defineComponent(`)\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> + <script setup> w/ ts","suites":["SFC genDefaultAs"],"updatePoint":{"line":1505,"column":39},"line":1505,"code":"  test('<script> + <script setup> w/ ts', () => {\n    const { content } = compile(\n      `<script lang=\"ts\">\n      export default {}\n      </script>\n      <script setup lang=\"ts\">\n      const a = 1\n      </script>`,\n      {\n        genDefaultAs: '_sfc_'\n      }\n    )\n    expect(content).not.toMatch('export default')\n    expect(content).toMatch(\n      `const _sfc_ = /*#__PURE__*/_defineComponent({\\n  ...__default__`\n    )\n    assertCode(content)\n  })","file":"compileScript.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["defineEmits"],"updatePoint":{"line":5,"column":19},"line":5,"code":"  test('basic usage', () => {\n    const { content, bindings } = compile(`\n<script setup>\nconst myEmit = defineEmits(['foo', 'bar'])\n</script>\n  `)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      myEmit: BindingTypes.SETUP_CONST\n    })\n    // should remove defineEmits import and call\n    expect(content).not.toMatch('defineEmits')\n    // should generate correct setup signature\n    expect(content).toMatch(\n      `setup(__props, { expose: __expose, emit: myEmit }) {`\n    )\n    // should include context options in default export\n    expect(content).toMatch(`export default {\n  emits: ['foo', 'bar'],`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ runtime options","suites":["defineEmits"],"updatePoint":{"line":26,"column":26},"line":26,"code":"  test('w/ runtime options', () => {\n    const { content } = compile(`\n<script setup lang=\"ts\">\nconst emit = defineEmits(['a', 'b'])\n</script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`export default /*#__PURE__*/_defineComponent({\n  emits: ['a', 'b'],\n  setup(__props, { expose: __expose, emit }) {`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type","suites":["defineEmits"],"updatePoint":{"line":38,"column":15},"line":38,"code":"  test('w/ type', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const emit = defineEmits<(e: 'foo' | 'bar') => void>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (union)","suites":["defineEmits"],"updatePoint":{"line":48,"column":23},"line":48,"code":"  test('w/ type (union)', () => {\n    const type = `((e: 'foo' | 'bar') => void) | ((e: 'baz', id: number) => void)`\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const emit = defineEmits<${type}>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\", \"baz\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (type literal w/ call signatures)","suites":["defineEmits"],"updatePoint":{"line":59,"column":49},"line":59,"code":"  test('w/ type (type literal w/ call signatures)', () => {\n    const type = `{(e: 'foo' | 'bar'): void; (e: 'baz', id: number): void;}`\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const emit = defineEmits<${type}>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\", \"baz\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (interface)","suites":["defineEmits"],"updatePoint":{"line":70,"column":27},"line":70,"code":"  test('w/ type (interface)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    interface Emits { (e: 'foo' | 'bar'): void }\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (exported interface)","suites":["defineEmits"],"updatePoint":{"line":81,"column":36},"line":81,"code":"  test('w/ type (exported interface)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    export interface Emits { (e: 'foo' | 'bar'): void }\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type from normal script","suites":["defineEmits"],"updatePoint":{"line":92,"column":34},"line":92,"code":"  test('w/ type from normal script', () => {\n    const { content } = compile(`\n    <script lang=\"ts\">\n      export interface Emits { (e: 'foo' | 'bar'): void }\n    </script>\n    <script setup lang=\"ts\">\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (type alias)","suites":["defineEmits"],"updatePoint":{"line":105,"column":28},"line":105,"code":"  test('w/ type (type alias)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    type Emits = { (e: 'foo' | 'bar'): void }\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (exported type alias)","suites":["defineEmits"],"updatePoint":{"line":116,"column":37},"line":116,"code":"  test('w/ type (exported type alias)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    export type Emits = { (e: 'foo' | 'bar'): void }\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (referenced function type)","suites":["defineEmits"],"updatePoint":{"line":127,"column":42},"line":127,"code":"  test('w/ type (referenced function type)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    type Emits = (e: 'foo' | 'bar') => void\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (referenced exported function type)","suites":["defineEmits"],"updatePoint":{"line":138,"column":51},"line":138,"code":"  test('w/ type (referenced exported function type)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    export type Emits = (e: 'foo' | 'bar') => void\n    const emit = defineEmits<Emits>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (interface ts type)","suites":["defineEmits"],"updatePoint":{"line":150,"column":35},"line":150,"code":"  test('w/ type (interface ts type)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    interface Emits { (e: 'foo'): void }\n    const emit: Emits = defineEmits(['foo'])\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`emits: ['foo']`)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (property syntax)","suites":["defineEmits"],"updatePoint":{"line":161,"column":33},"line":161,"code":"  test('w/ type (property syntax)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const emit = defineEmits<{ foo: [], bar: [] }>()\n    </script>\n    `)\n    expect(content).toMatch(`emits: [\"foo\", \"bar\"]`)\n    assertCode(content)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type (property syntax string literal)","suites":["defineEmits"],"updatePoint":{"line":172,"column":48},"line":172,"code":"  test('w/ type (property syntax string literal)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const emit = defineEmits<{ 'foo:bar': [] }>()\n    </script>\n    `)\n    expect(content).toMatch(`emits: [\"foo:bar\"]`)\n    assertCode(content)\n  })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ both type and non-type args","suites":["defineEmits","errors"],"updatePoint":{"line":183,"column":40},"line":183,"code":"    test('w/ both type and non-type args', () => {\n      expect(() => {\n        compile(`<script setup lang=\"ts\">\n        defineEmits<{}>({})\n        </script>`)\n      }).toThrow(`cannot accept both type and non-type arguments`)\n    })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"mixed usage of property / call signature","suites":["defineEmits","errors"],"updatePoint":{"line":191,"column":50},"line":191,"code":"    test('mixed usage of property / call signature', () => {\n      expect(() =>\n        compile(`<script setup lang=\"ts\">\n        defineEmits<{\n          foo: []\n          (e: 'hi'): void\n        }>()\n        </script>`)\n      ).toThrow(\n        `defineEmits() type cannot mixed call signature and property syntax.`\n      )\n    })","file":"compileScript/defineEmits.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineExpose()","suites":[],"updatePoint":{"line":3,"column":20},"line":3,"code":"test('defineExpose()', () => {\n  const { content } = compile(`\n<script setup>\ndefineExpose({ foo: 123 })\n</script>\n`)\n  assertCode(content)\n  // should remove defineOptions import and call\n  expect(content).not.toMatch('defineExpose')\n  // should generate correct setup signature\n  expect(content).toMatch(`setup(__props, { expose: __expose }) {`)\n  // should replace callee\n  expect(content).toMatch(/\\b__expose\\(\\{ foo: 123 \\}\\)/)\n})","file":"compileScript/defineExpose.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> after <script setup> the script content not end with `\\n`","suites":[],"updatePoint":{"line":18,"column":73},"line":18,"code":"test('<script> after <script setup> the script content not end with `\\\\n`', () => {\n  const { content } = compile(`\n  <script setup>\n  import { x } from './x'\n  </script>\n  <script>const n = 1</script>\n  `)\n  assertCode(content)\n})","file":"compileScript/defineExpose.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["defineModel()"],"updatePoint":{"line":5,"column":19},"line":5,"code":"  test('basic usage', () => {\n    const { content, bindings } = compile(\n      `\n      <script setup>\n      const modelValue = defineModel({ required: true })\n      const c = defineModel('count')\n      </script>\n      `,\n      { defineModel: true }\n    )\n    assertCode(content)\n    expect(content).toMatch('props: {')\n    expect(content).toMatch('\"modelValue\": { required: true },')\n    expect(content).toMatch('\"count\": {},')\n    expect(content).toMatch('emits: [\"update:modelValue\", \"update:count\"],')\n    expect(content).toMatch(\n      `const modelValue = _useModel(__props, \"modelValue\")`\n    )\n    expect(content).toMatch(`const c = _useModel(__props, \"count\")`)\n    expect(content).toMatch(`return { modelValue, c }`)\n    expect(content).not.toMatch('defineModel')\n\n    expect(bindings).toStrictEqual({\n      modelValue: BindingTypes.SETUP_REF,\n      count: BindingTypes.PROPS,\n      c: BindingTypes.SETUP_REF\n    })\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ defineProps and defineEmits","suites":["defineModel()"],"updatePoint":{"line":34,"column":38},"line":34,"code":"  test('w/ defineProps and defineEmits', () => {\n    const { content, bindings } = compile(\n      `\n      <script setup>\n      defineProps({ foo: String })\n      defineEmits(['change'])\n      const count = defineModel({ default: 0 })\n      </script>\n    `,\n      { defineModel: true }\n    )\n    assertCode(content)\n    expect(content).toMatch(`props: _mergeModels({ foo: String }`)\n    expect(content).toMatch(`\"modelValue\": { default: 0 }`)\n    expect(content).toMatch(`const count = _useModel(__props, \"modelValue\")`)\n    expect(content).not.toMatch('defineModel')\n    expect(bindings).toStrictEqual({\n      count: BindingTypes.SETUP_REF,\n      foo: BindingTypes.PROPS,\n      modelValue: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ array props","suites":["defineModel()"],"updatePoint":{"line":57,"column":22},"line":57,"code":"  test('w/ array props', () => {\n    const { content, bindings } = compile(\n      `\n      <script setup>\n      defineProps(['foo', 'bar'])\n      const count = defineModel('count')\n      </script>\n    `,\n      { defineModel: true }\n    )\n    assertCode(content)\n    expect(content).toMatch(`props: _mergeModels(['foo', 'bar'], {\n    \"count\": {},\n  })`)\n    expect(content).toMatch(`const count = _useModel(__props, \"count\")`)\n    expect(content).not.toMatch('defineModel')\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS,\n      count: BindingTypes.SETUP_REF\n    })\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ local flag","suites":["defineModel()"],"updatePoint":{"line":80,"column":21},"line":80,"code":"  test('w/ local flag', () => {\n    const { content } = compile(\n      `<script setup>\n      const foo = defineModel({ local: true, default: 1 })\n      const bar = defineModel('bar', { [key]: true })\n      const baz = defineModel('baz', { ...x })\n      const qux = defineModel('qux', x)\n\n      const foo2 = defineModel('foo2', { local: true, ...x })\n\n      const local = true\n      const hoist = defineModel('hoist', { local })\n      </script>`,\n      { defineModel: true }\n    )\n    assertCode(content)\n    expect(content).toMatch(`_useModel(__props, \"modelValue\", { local: true })`)\n    expect(content).toMatch(`_useModel(__props, \"bar\", { [key]: true })`)\n    expect(content).toMatch(`_useModel(__props, \"baz\", { ...x })`)\n    expect(content).toMatch(`_useModel(__props, \"qux\", x)`)\n    expect(content).toMatch(`_useModel(__props, \"foo2\", { local: true })`)\n    expect(content).toMatch(`_useModel(__props, \"hoist\", { local })`)\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ types, basic usage","suites":["defineModel()"],"updatePoint":{"line":104,"column":29},"line":104,"code":"  test('w/ types, basic usage', () => {\n    const { content, bindings } = compile(\n      `\n      <script setup lang=\"ts\">\n      const modelValue = defineModel<boolean | string>()\n      const count = defineModel<number>('count')\n      const disabled = defineModel<number>('disabled', { required: false })\n      const any = defineModel<any | boolean>('any')\n      </script>\n      `,\n      { defineModel: true }\n    )\n    assertCode(content)\n    expect(content).toMatch('\"modelValue\": { type: [Boolean, String] }')\n    expect(content).toMatch('\"count\": { type: Number }')\n    expect(content).toMatch(\n      '\"disabled\": { type: Number, ...{ required: false } }'\n    )\n    expect(content).toMatch('\"any\": { type: Boolean, skipCheck: true }')\n    expect(content).toMatch(\n      'emits: [\"update:modelValue\", \"update:count\", \"update:disabled\", \"update:any\"]'\n    )\n\n    expect(content).toMatch(\n      `const modelValue = _useModel(__props, \"modelValue\")`\n    )\n    expect(content).toMatch(`const count = _useModel(__props, \"count\")`)\n    expect(content).toMatch(`const disabled = _useModel(__props, \"disabled\")`)\n    expect(content).toMatch(`const any = _useModel(__props, \"any\")`)\n\n    expect(bindings).toStrictEqual({\n      modelValue: BindingTypes.SETUP_REF,\n      count: BindingTypes.SETUP_REF,\n      disabled: BindingTypes.SETUP_REF,\n      any: BindingTypes.SETUP_REF\n    })\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ types, production mode","suites":["defineModel()"],"updatePoint":{"line":142,"column":33},"line":142,"code":"  test('w/ types, production mode', () => {\n    const { content, bindings } = compile(\n      `\n      <script setup lang=\"ts\">\n      const modelValue = defineModel<boolean>()\n      const fn = defineModel<() => void>('fn')\n      const fnWithDefault = defineModel<() => void>('fnWithDefault', { default: () => null })\n      const str = defineModel<string>('str')\n      const optional = defineModel<string>('optional', { required: false })\n      </script>\n      `,\n      { defineModel: true, isProd: true }\n    )\n    assertCode(content)\n    expect(content).toMatch('\"modelValue\": { type: Boolean }')\n    expect(content).toMatch('\"fn\": {}')\n    expect(content).toMatch(\n      '\"fnWithDefault\": { type: Function, ...{ default: () => null } },'\n    )\n    expect(content).toMatch('\"str\": {}')\n    expect(content).toMatch('\"optional\": { required: false }')\n    expect(content).toMatch(\n      'emits: [\"update:modelValue\", \"update:fn\", \"update:fnWithDefault\", \"update:str\", \"update:optional\"]'\n    )\n    expect(content).toMatch(\n      `const modelValue = _useModel(__props, \"modelValue\")`\n    )\n    expect(content).toMatch(`const fn = _useModel(__props, \"fn\")`)\n    expect(content).toMatch(`const str = _useModel(__props, \"str\")`)\n    expect(bindings).toStrictEqual({\n      modelValue: BindingTypes.SETUP_REF,\n      fn: BindingTypes.SETUP_REF,\n      fnWithDefault: BindingTypes.SETUP_REF,\n      str: BindingTypes.SETUP_REF,\n      optional: BindingTypes.SETUP_REF\n    })\n  })","file":"compileScript/defineModel.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["defineOptions()"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  test('basic usage', () => {\n    const { content } = compile(`\n      <script setup>\n      defineOptions({ name: 'FooApp' })\n      </script>\n    `)\n    assertCode(content)\n    // should remove defineOptions import and call\n    expect(content).not.toMatch('defineOptions')\n    // should include context options in default export\n    expect(content).toMatch(\n      `export default /*#__PURE__*/Object.assign({ name: 'FooApp' }, `\n    )\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"empty argument","suites":["defineOptions()"],"updatePoint":{"line":19,"column":22},"line":19,"code":"  test('empty argument', () => {\n    const { content } = compile(`\n      <script setup>\n      defineOptions()\n      </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`export default {`)\n    // should remove defineOptions import and call\n    expect(content).not.toMatch('defineOptions')\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should emit an error with two defineProps","suites":["defineOptions()"],"updatePoint":{"line":31,"column":47},"line":31,"code":"  it('should emit an error with two defineProps', () => {\n    expect(() =>\n      compile(`\n      <script setup>\n      defineOptions({ name: 'FooApp' })\n      defineOptions({ name: 'BarApp' })\n      </script>\n      `)\n    ).toThrowError('[@vue/compiler-sfc] duplicate defineOptions() call')\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should emit an error with props or emits property","suites":["defineOptions()"],"updatePoint":{"line":42,"column":55},"line":42,"code":"  it('should emit an error with props or emits property', () => {\n    expect(() =>\n      compile(`\n      <script setup>\n      defineOptions({ props: { foo: String } })\n      </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare props. Use defineProps() instead.'\n    )\n\n    expect(() =>\n      compile(`\n      <script setup>\n      defineOptions({ emits: ['update'] })\n      </script>\n    `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare emits. Use defineEmits() instead.'\n    )\n\n    expect(() =>\n      compile(`\n      <script setup>\n      defineOptions({ expose: ['foo'] })\n      </script>\n    `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare expose. Use defineExpose() instead.'\n    )\n\n    expect(() =>\n      compile(`\n      <script setup>\n      defineOptions({ slots: ['foo'] })\n      </script>\n    `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare slots. Use defineSlots() instead.'\n    )\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should emit an error with type generic","suites":["defineOptions()"],"updatePoint":{"line":84,"column":44},"line":84,"code":"  it('should emit an error with type generic', () => {\n    expect(() =>\n      compile(`\n      <script setup lang=\"ts\">\n      defineOptions<{ name: 'FooApp' }>()\n      </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot accept type arguments'\n    )\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should emit an error with type assertion","suites":["defineOptions()"],"updatePoint":{"line":96,"column":46},"line":96,"code":"  it('should emit an error with type assertion', () => {\n    expect(() =>\n      compile(`\n      <script setup lang=\"ts\">\n      defineOptions({ props: [] } as any)\n      </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare props. Use defineProps() instead.'\n    )\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should emit an error with declaring props/emits/slots/expose","suites":["defineOptions()"],"updatePoint":{"line":108,"column":66},"line":108,"code":"  it('should emit an error with declaring props/emits/slots/expose', () => {\n    expect(() =>\n      compile(`\n        <script setup>\n        defineOptions({ props: ['foo'] })\n        </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare props. Use defineProps() instead'\n    )\n\n    expect(() =>\n      compile(`\n        <script setup>\n        defineOptions({ emits: ['update'] })\n        </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare emits. Use defineEmits() instead'\n    )\n\n    expect(() =>\n      compile(`\n        <script setup>\n        defineOptions({ expose: ['foo'] })\n        </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare expose. Use defineExpose() instead'\n    )\n\n    expect(() =>\n      compile(`\n        <script setup lang=\"ts\">\n        defineOptions({ slots: Object })\n        </script>\n      `)\n    ).toThrowError(\n      '[@vue/compiler-sfc] defineOptions() cannot be used to declare slots. Use defineSlots() instead'\n    )\n  })","file":"compileScript/defineOptions.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["defineProps"],"updatePoint":{"line":5,"column":19},"line":5,"code":"  test('basic usage', () => {\n    const { content, bindings } = compile(`\n<script setup>\nconst props = defineProps({\n  foo: String\n})\nconst bar = 1\n</script>\n  `)\n    // should generate working code\n    assertCode(content)\n    // should analyze bindings\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.LITERAL_CONST,\n      props: BindingTypes.SETUP_REACTIVE_CONST\n    })\n\n    // should remove defineOptions import and call\n    expect(content).not.toMatch('defineProps')\n    // should generate correct setup signature\n    expect(content).toMatch(`setup(__props, { expose: __expose }) {`)\n    // should assign user identifier to it\n    expect(content).toMatch(`const props = __props`)\n    // should include context options in default export\n    expect(content).toMatch(`export default {\n  props: {\n  foo: String\n},`)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ external definition","suites":["defineProps"],"updatePoint":{"line":36,"column":30},"line":36,"code":"  test('w/ external definition', () => {\n    const { content } = compile(`\n    <script setup>\n    import { propsModel } from './props'\n    const props = defineProps(propsModel)\n    </script>\n      `)\n    assertCode(content)\n    expect(content).toMatch(`export default {\n  props: propsModel,`)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ leading code","suites":["defineProps"],"updatePoint":{"line":49,"column":23},"line":49,"code":"  test('w/ leading code', () => {\n    const { content } = compile(`\n    <script setup>import { x } from './x'\n    const props = defineProps({})\n    </script>\n    `)\n    // props declaration should be inside setup, not moved along with the import\n    expect(content).not.toMatch(`const props = __props\\nimport`)\n    assertCode(content)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps w/ runtime options","suites":["defineProps"],"updatePoint":{"line":60,"column":38},"line":60,"code":"  test('defineProps w/ runtime options', () => {\n    const { content } = compile(`\n<script setup lang=\"ts\">\nconst props = defineProps({ foo: String })\n</script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`export default /*#__PURE__*/_defineComponent({\n  props: { foo: String },\n  setup(__props, { expose: __expose }) {`)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type","suites":["defineProps"],"updatePoint":{"line":72,"column":15},"line":72,"code":"  test('w/ type', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    interface Test {}\n\n    type Alias = number[]\n\n    defineProps<{\n      string: string\n      number: number\n      boolean: boolean\n      object: object\n      objectLiteral: { a: number }\n      fn: (n: number) => void\n      functionRef: Function\n      objectRef: Object\n      dateTime: Date\n      array: string[]\n      arrayRef: Array<any>\n      tuple: [number, number]\n      set: Set<string>\n      literal: 'foo'\n      optional?: any\n      recordRef: Record<string, null>\n      interface: Test\n      alias: Alias\n      method(): void\n      symbol: symbol\n      extract: Extract<1 | 2 | boolean, 2>\n      exclude: Exclude<1 | 2 | boolean, 2>\n      uppercase: Uppercase<'foo'>\n      params: Parameters<(foo: any) => void>\n      nonNull: NonNullable<string | null>\n      objectOrFn: {\n        (): void\n        foo: string\n      }\n\n      union: string | number\n      literalUnion: 'foo' | 'bar'\n      literalUnionNumber: 1 | 2 | 3 | 4 | 5\n      literalUnionMixed: 'foo' | 1 | boolean\n      intersection: Test & {}\n      intersection2: 'foo' & ('foo' | 'bar')\n      foo: ((item: any) => boolean) | null\n\n      unknown: UnknownType\n      unknownUnion: UnknownType | string\n      unknownIntersection: UnknownType & Object\n      unknownUnionWithBoolean: UnknownType | boolean\n      unknownUnionWithFunction: UnknownType | (() => any)\n    }>()\n    </script>`)\n    assertCode(content)\n    expect(content).toMatch(`string: { type: String, required: true }`)\n    expect(content).toMatch(`number: { type: Number, required: true }`)\n    expect(content).toMatch(`boolean: { type: Boolean, required: true }`)\n    expect(content).toMatch(`object: { type: Object, required: true }`)\n    expect(content).toMatch(`objectLiteral: { type: Object, required: true }`)\n    expect(content).toMatch(`fn: { type: Function, required: true }`)\n    expect(content).toMatch(`functionRef: { type: Function, required: true }`)\n    expect(content).toMatch(`objectRef: { type: Object, required: true }`)\n    expect(content).toMatch(`dateTime: { type: Date, required: true }`)\n    expect(content).toMatch(`array: { type: Array, required: true }`)\n    expect(content).toMatch(`arrayRef: { type: Array, required: true }`)\n    expect(content).toMatch(`tuple: { type: Array, required: true }`)\n    expect(content).toMatch(`set: { type: Set, required: true }`)\n    expect(content).toMatch(`literal: { type: String, required: true }`)\n    expect(content).toMatch(`optional: { type: null, required: false }`)\n    expect(content).toMatch(`recordRef: { type: Object, required: true }`)\n    expect(content).toMatch(`interface: { type: Object, required: true }`)\n    expect(content).toMatch(`alias: { type: Array, required: true }`)\n    expect(content).toMatch(`method: { type: Function, required: true }`)\n    expect(content).toMatch(`symbol: { type: Symbol, required: true }`)\n    expect(content).toMatch(\n      `objectOrFn: { type: [Function, Object], required: true },`\n    )\n    expect(content).toMatch(`extract: { type: Number, required: true }`)\n    expect(content).toMatch(\n      `exclude: { type: [Number, Boolean], required: true }`\n    )\n    expect(content).toMatch(`uppercase: { type: String, required: true }`)\n    expect(content).toMatch(`params: { type: Array, required: true }`)\n    expect(content).toMatch(`nonNull: { type: String, required: true }`)\n    expect(content).toMatch(`union: { type: [String, Number], required: true }`)\n    expect(content).toMatch(`literalUnion: { type: String, required: true }`)\n    expect(content).toMatch(\n      `literalUnionNumber: { type: Number, required: true }`\n    )\n    expect(content).toMatch(\n      `literalUnionMixed: { type: [String, Number, Boolean], required: true }`\n    )\n    expect(content).toMatch(`intersection: { type: Object, required: true }`)\n    expect(content).toMatch(`intersection2: { type: String, required: true }`)\n    expect(content).toMatch(`foo: { type: [Function, null], required: true }`)\n    expect(content).toMatch(`unknown: { type: null, required: true }`)\n    // uninon containing unknown type: skip check\n    expect(content).toMatch(`unknownUnion: { type: null, required: true }`)\n    // intersection containing unknown type: narrow to the known types\n    expect(content).toMatch(\n      `unknownIntersection: { type: Object, required: true },`\n    )\n    expect(content).toMatch(\n      `unknownUnionWithBoolean: { type: Boolean, required: true, skipCheck: true },`\n    )\n    expect(content).toMatch(\n      `unknownUnionWithFunction: { type: Function, required: true, skipCheck: true }`\n    )\n    expect(bindings).toStrictEqual({\n      string: BindingTypes.PROPS,\n      number: BindingTypes.PROPS,\n      boolean: BindingTypes.PROPS,\n      object: BindingTypes.PROPS,\n      objectLiteral: BindingTypes.PROPS,\n      fn: BindingTypes.PROPS,\n      functionRef: BindingTypes.PROPS,\n      objectRef: BindingTypes.PROPS,\n      dateTime: BindingTypes.PROPS,\n      array: BindingTypes.PROPS,\n      arrayRef: BindingTypes.PROPS,\n      tuple: BindingTypes.PROPS,\n      set: BindingTypes.PROPS,\n      literal: BindingTypes.PROPS,\n      optional: BindingTypes.PROPS,\n      recordRef: BindingTypes.PROPS,\n      interface: BindingTypes.PROPS,\n      alias: BindingTypes.PROPS,\n      method: BindingTypes.PROPS,\n      symbol: BindingTypes.PROPS,\n      objectOrFn: BindingTypes.PROPS,\n      extract: BindingTypes.PROPS,\n      exclude: BindingTypes.PROPS,\n      union: BindingTypes.PROPS,\n      literalUnion: BindingTypes.PROPS,\n      literalUnionNumber: BindingTypes.PROPS,\n      literalUnionMixed: BindingTypes.PROPS,\n      intersection: BindingTypes.PROPS,\n      intersection2: BindingTypes.PROPS,\n      foo: BindingTypes.PROPS,\n      uppercase: BindingTypes.PROPS,\n      params: BindingTypes.PROPS,\n      nonNull: BindingTypes.PROPS,\n      unknown: BindingTypes.PROPS,\n      unknownUnion: BindingTypes.PROPS,\n      unknownIntersection: BindingTypes.PROPS,\n      unknownUnionWithBoolean: BindingTypes.PROPS,\n      unknownUnionWithFunction: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ interface","suites":["defineProps"],"updatePoint":{"line":222,"column":20},"line":222,"code":"  test('w/ interface', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    interface Props { x?: number }\n    defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ extends interface","suites":["defineProps"],"updatePoint":{"line":236,"column":28},"line":236,"code":"  test('w/ extends interface', () => {\n    const { content, bindings } = compile(`\n    <script lang=\"ts\">\n      interface Foo { x?: number }\n    </script>\n    <script setup lang=\"ts\">\n      interface Bar extends Foo { y?: number }\n      interface Props extends Bar {\n        z: number\n        y: string\n      }\n      defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`z: { type: Number, required: true }`)\n    expect(content).toMatch(`y: { type: String, required: true }`)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS,\n      y: BindingTypes.PROPS,\n      z: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ exported interface","suites":["defineProps"],"updatePoint":{"line":261,"column":29},"line":261,"code":"  test('w/ exported interface', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    export interface Props { x?: number }\n    defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ exported interface in normal script","suites":["defineProps"],"updatePoint":{"line":275,"column":46},"line":275,"code":"  test('w/ exported interface in normal script', () => {\n    const { content, bindings } = compile(`\n    <script lang=\"ts\">\n      export interface Props { x?: number }\n    </script>\n    <script setup lang=\"ts\">\n      defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ type alias","suites":["defineProps"],"updatePoint":{"line":291,"column":21},"line":291,"code":"  test('w/ type alias', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    type Props = { x?: number }\n    defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ exported type alias","suites":["defineProps"],"updatePoint":{"line":305,"column":30},"line":305,"code":"  test('w/ exported type alias', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    export type Props = { x?: number }\n    defineProps<Props>()\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`x: { type: Number, required: false }`)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ TS assertion","suites":["defineProps"],"updatePoint":{"line":319,"column":23},"line":319,"code":"  test('w/ TS assertion', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n      defineProps(['foo'])! as any\n    </script>\n  `)\n    expect(content).toMatch(`props: ['foo']`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (static)","suites":["defineProps"],"updatePoint":{"line":332,"column":29},"line":332,"code":"  test('withDefaults (static)', () => {\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    const props = withDefaults(defineProps<{\n      foo?: string\n      bar?: number;\n      baz: boolean;\n      qux?(): number;\n      quux?(): void\n      quuxx?: Promise<string>;\n      fred?: string\n    }>(), {\n      foo: 'hi',\n      qux() { return 1 },\n      ['quux']() { },\n      async quuxx() { return await Promise.resolve('hi') },\n      get fred() { return 'fred' }\n    })\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(\n      `foo: { type: String, required: false, default: 'hi' }`\n    )\n    expect(content).toMatch(`bar: { type: Number, required: false }`)\n    expect(content).toMatch(`baz: { type: Boolean, required: true }`)\n    expect(content).toMatch(\n      `qux: { type: Function, required: false, default() { return 1 } }`\n    )\n    expect(content).toMatch(\n      `quux: { type: Function, required: false, default() { } }`\n    )\n    expect(content).toMatch(\n      `quuxx: { type: Promise, required: false, async default() { return await Promise.resolve('hi') } }`\n    )\n    expect(content).toMatch(\n      `fred: { type: String, required: false, get default() { return 'fred' } }`\n    )\n    expect(content).toMatch(`const props = __props`)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS,\n      baz: BindingTypes.PROPS,\n      qux: BindingTypes.PROPS,\n      quux: BindingTypes.PROPS,\n      quuxx: BindingTypes.PROPS,\n      fred: BindingTypes.PROPS,\n      props: BindingTypes.SETUP_CONST\n    })\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (static) + normal script","suites":["defineProps"],"updatePoint":{"line":383,"column":45},"line":383,"code":"  test('withDefaults (static) + normal script', () => {\n    const { content } = compile(`\n    <script lang=\"ts\">\n      interface Props {\n        a?: string;\n      }\n    </script>\n    <script setup lang=\"ts\">\n      const props = withDefaults(defineProps<Props>(), {\n        a: \"a\",\n      });\n    </script>\n    `)\n    assertCode(content)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (static) w/ production mode","suites":["defineProps"],"updatePoint":{"line":400,"column":48},"line":400,"code":"  test('withDefaults (static) w/ production mode', () => {\n    const { content } = compile(\n      `\n    <script setup lang=\"ts\">\n    const props = withDefaults(defineProps<{\n      foo: () => void\n      bar: boolean\n      baz: boolean | (() => void)\n      qux: string | number\n    }>(), {\n      baz: true,\n      qux: 'hi'\n    })\n    </script>\n    `,\n      { isProd: true }\n    )\n    assertCode(content)\n    expect(content).toMatch(`const props = __props`)\n\n    // foo has no default value, the Function can be dropped\n    expect(content).toMatch(`foo: {}`)\n    expect(content).toMatch(`bar: { type: Boolean }`)\n    expect(content).toMatch(`baz: { type: [Boolean, Function], default: true }`)\n    expect(content).toMatch(`qux: { default: 'hi' }`)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (dynamic)","suites":["defineProps"],"updatePoint":{"line":427,"column":30},"line":427,"code":"  test('withDefaults (dynamic)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    import { defaults } from './foo'\n    const props = withDefaults(defineProps<{\n      foo?: string\n      bar?: number\n      baz: boolean\n    }>(), { ...defaults })\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`import { mergeDefaults as _mergeDefaults`)\n    expect(content).toMatch(\n      `\n  _mergeDefaults({\n    foo: { type: String, required: false },\n    bar: { type: Number, required: false },\n    baz: { type: Boolean, required: true }\n  }, { ...defaults })`.trim()\n    )\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (reference)","suites":["defineProps"],"updatePoint":{"line":450,"column":32},"line":450,"code":"  test('withDefaults (reference)', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    import { defaults } from './foo'\n    const props = withDefaults(defineProps<{\n      foo?: string\n      bar?: number\n      baz: boolean\n    }>(), defaults)\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`import { mergeDefaults as _mergeDefaults`)\n    expect(content).toMatch(\n      `\n  _mergeDefaults({\n    foo: { type: String, required: false },\n    bar: { type: Number, required: false },\n    baz: { type: Boolean, required: true }\n  }, defaults)`.trim()\n    )\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults (dynamic) w/ production mode","suites":["defineProps"],"updatePoint":{"line":474,"column":49},"line":474,"code":"  test('withDefaults (dynamic) w/ production mode', () => {\n    const { content } = compile(\n      `\n    <script setup lang=\"ts\">\n    import { defaults } from './foo'\n    const props = withDefaults(defineProps<{\n      foo: () => void\n      bar: boolean\n      baz: boolean | (() => void)\n      qux: string | number\n    }>(), { ...defaults })\n    </script>\n    `,\n      { isProd: true }\n    )\n    assertCode(content)\n    expect(content).toMatch(`import { mergeDefaults as _mergeDefaults`)\n    expect(content).toMatch(\n      `\n  _mergeDefaults({\n    foo: { type: Function },\n    bar: { type: Boolean },\n    baz: { type: [Boolean, Function] },\n    qux: {}\n  }, { ...defaults })`.trim()\n    )\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"withDefaults w/ dynamic object method","suites":["defineProps"],"updatePoint":{"line":502,"column":45},"line":502,"code":"  test('withDefaults w/ dynamic object method', () => {\n    const { content } = compile(`\n    <script setup lang=\"ts\">\n    const props = withDefaults(defineProps<{\n      foo?: () => 'string'\n    }>(), {\n      ['fo' + 'o']() { return 'foo' }\n    })\n    </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`import { mergeDefaults as _mergeDefaults`)\n    expect(content).toMatch(\n      `\n  _mergeDefaults({\n    foo: { type: Function, required: false }\n  }, {\n      ['fo' + 'o']() { return 'foo' }\n    })`.trim()\n    )\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"runtime inference for Enum","suites":["defineProps"],"updatePoint":{"line":524,"column":34},"line":524,"code":"  test('runtime inference for Enum', () => {\n    expect(\n      compile(\n        `<script setup lang=\"ts\">\n      const enum Foo { A = 123 }\n      defineProps<{\n        foo: Foo\n      }>()\n      </script>`,\n        { hoistStatic: true }\n      ).content\n    ).toMatch(`foo: { type: Number`)\n\n    expect(\n      compile(\n        `<script setup lang=\"ts\">\n      const enum Foo { A = '123' }\n      defineProps<{\n        foo: Foo\n      }>()\n      </script>`,\n        { hoistStatic: true }\n      ).content\n    ).toMatch(`foo: { type: String`)\n\n    expect(\n      compile(\n        `<script setup lang=\"ts\">\n      const enum Foo { A = '123', B = 123 }\n      defineProps<{\n        foo: Foo\n      }>()\n      </script>`,\n        { hoistStatic: true }\n      ).content\n    ).toMatch(`foo: { type: [String, Number]`)\n\n    expect(\n      compile(\n        `<script setup lang=\"ts\">\n      const enum Foo { A, B }\n      defineProps<{\n        foo: Foo\n      }>()\n      </script>`,\n        { hoistStatic: true }\n      ).content\n    ).toMatch(`foo: { type: Number`)\n  })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ both type and non-type args","suites":["defineProps","errors"],"updatePoint":{"line":575,"column":40},"line":575,"code":"    test('w/ both type and non-type args', () => {\n      expect(() => {\n        compile(`<script setup lang=\"ts\">\n        defineProps<{}>({})\n        </script>`)\n      }).toThrow(`cannot accept both type and non-type arguments`)\n    })","file":"compileScript/defineProps.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["sfc reactive props destructure"],"updatePoint":{"line":14,"column":19},"line":14,"code":"  test('basic usage', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { foo } = defineProps(['foo'])\n      console.log(foo)\n      </script>\n      <template>{{ foo }}</template>\n    `)\n    expect(content).not.toMatch(`const { foo } =`)\n    expect(content).toMatch(`console.log(__props.foo)`)\n    expect(content).toMatch(`_toDisplayString(__props.foo)`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"multiple variable declarations","suites":["sfc reactive props destructure"],"updatePoint":{"line":31,"column":38},"line":31,"code":"  test('multiple variable declarations', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const bar = 'fish', { foo } = defineProps(['foo']), hello = 'world'\n      </script>\n      <template><div>{{ foo }} {{ hello }} {{ bar }}</div></template>\n    `)\n    expect(content).not.toMatch(`const { foo } =`)\n    expect(content).toMatch(`const bar = 'fish', hello = 'world'`)\n    expect(content).toMatch(`_toDisplayString(hello)`)\n    expect(content).toMatch(`_toDisplayString(bar)`)\n    expect(content).toMatch(`_toDisplayString(__props.foo)`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.LITERAL_CONST,\n      hello: BindingTypes.LITERAL_CONST\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"nested scope","suites":["sfc reactive props destructure"],"updatePoint":{"line":51,"column":20},"line":51,"code":"  test('nested scope', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { foo, bar } = defineProps(['foo', 'bar'])\n      function test(foo) {\n        console.log(foo)\n        console.log(bar)\n      }\n      </script>\n    `)\n    expect(content).not.toMatch(`const { foo, bar } =`)\n    expect(content).toMatch(`console.log(foo)`)\n    expect(content).toMatch(`console.log(__props.bar)`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS,\n      test: BindingTypes.SETUP_CONST\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"default values w/ array runtime declaration","suites":["sfc reactive props destructure"],"updatePoint":{"line":72,"column":51},"line":72,"code":"  test('default values w/ array runtime declaration', () => {\n    const { content } = compile(`\n      <script setup>\n      const { foo = 1, bar = {}, func = () => {} } = defineProps(['foo', 'bar', 'baz'])\n      </script>\n    `)\n    // literals can be used as-is, non-literals are always returned from a\n    // function\n    // functions need to be marked with a skip marker\n    expect(content).toMatch(`props: _mergeDefaults(['foo', 'bar', 'baz'], {\n  foo: 1,\n  bar: () => ({}),\n  func: () => {}, __skip_func: true\n})`)\n    assertCode(content)\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"default values w/ object runtime declaration","suites":["sfc reactive props destructure"],"updatePoint":{"line":89,"column":52},"line":89,"code":"  test('default values w/ object runtime declaration', () => {\n    const { content } = compile(`\n      <script setup>\n      const { foo = 1, bar = {}, func = () => {}, ext = x } = defineProps({ foo: Number, bar: Object, func: Function, ext: null })\n      </script>\n    `)\n    // literals can be used as-is, non-literals are always returned from a\n    // function\n    // functions need to be marked with a skip marker since we cannot always\n    // safely infer whether runtime type is Function (e.g. if the runtime decl\n    // is imported, or spreads another object)\n    expect(content)\n      .toMatch(`props: _mergeDefaults({ foo: Number, bar: Object, func: Function, ext: null }, {\n  foo: 1,\n  bar: () => ({}),\n  func: () => {}, __skip_func: true,\n  ext: x, __skip_ext: true\n})`)\n    assertCode(content)\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"default values w/ type declaration","suites":["sfc reactive props destructure"],"updatePoint":{"line":110,"column":42},"line":110,"code":"  test('default values w/ type declaration', () => {\n    const { content } = compile(`\n      <script setup lang=\"ts\">\n      const { foo = 1, bar = {}, func = () => {} } = defineProps<{ foo?: number, bar?: object, func?: () => any }>()\n      </script>\n    `)\n    // literals can be used as-is, non-literals are always returned from a\n    // function\n    expect(content).toMatch(`props: {\n    foo: { type: Number, required: false, default: 1 },\n    bar: { type: Object, required: false, default: () => ({}) },\n    func: { type: Function, required: false, default: () => {} }\n  }`)\n    assertCode(content)\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"default values w/ type declaration, prod mode","suites":["sfc reactive props destructure"],"updatePoint":{"line":126,"column":53},"line":126,"code":"  test('default values w/ type declaration, prod mode', () => {\n    const { content } = compile(\n      `\n      <script setup lang=\"ts\">\n      const { foo = 1, bar = {}, func = () => {} } = defineProps<{ foo?: number, bar?: object, baz?: any, boola?: boolean, boolb?: boolean | number, func?: Function }>()\n      </script>\n    `,\n      { isProd: true }\n    )\n    assertCode(content)\n    // literals can be used as-is, non-literals are always returned from a\n    // function\n    expect(content).toMatch(`props: {\n    foo: { default: 1 },\n    bar: { default: () => ({}) },\n    baz: {},\n    boola: { type: Boolean },\n    boolb: { type: [Boolean, Number] },\n    func: { type: Function, default: () => {} }\n  }`)\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"aliasing","suites":["sfc reactive props destructure"],"updatePoint":{"line":148,"column":16},"line":148,"code":"  test('aliasing', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { foo: bar } = defineProps(['foo'])\n      let x = foo\n      let y = bar\n      </script>\n      <template>{{ foo + bar }}</template>\n    `)\n    expect(content).not.toMatch(`const { foo: bar } =`)\n    expect(content).toMatch(`let x = foo`) // should not process\n    expect(content).toMatch(`let y = __props.foo`)\n    // should convert bar to __props.foo in template expressions\n    expect(content).toMatch(`_toDisplayString(__props.foo + __props.foo)`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.SETUP_LET,\n      y: BindingTypes.SETUP_LET,\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS_ALIASED,\n      __propsAliases: {\n        bar: 'foo'\n      }\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"non-identifier prop names","suites":["sfc reactive props destructure"],"updatePoint":{"line":175,"column":33},"line":175,"code":"  test('non-identifier prop names', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { 'foo.bar': fooBar } = defineProps({ 'foo.bar': Function })\n      let x = fooBar\n      </script>\n      <template>{{ fooBar }}</template>\n    `)\n    expect(content).toMatch(`x = __props[\"foo.bar\"]`)\n    expect(content).toMatch(`toDisplayString(__props[\"foo.bar\"])`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      x: BindingTypes.SETUP_LET,\n      'foo.bar': BindingTypes.PROPS,\n      fooBar: BindingTypes.PROPS_ALIASED,\n      __propsAliases: {\n        fooBar: 'foo.bar'\n      }\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"rest spread","suites":["sfc reactive props destructure"],"updatePoint":{"line":196,"column":19},"line":196,"code":"  test('rest spread', () => {\n    const { content, bindings } = compile(`\n      <script setup>\n      const { foo, bar, ...rest } = defineProps(['foo', 'bar', 'baz'])\n      </script>\n    `)\n    expect(content).toMatch(\n      `const rest = _createPropsRestProxy(__props, [\"foo\",\"bar\"])`\n    )\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      bar: BindingTypes.PROPS,\n      baz: BindingTypes.PROPS,\n      rest: BindingTypes.SETUP_REACTIVE_CONST\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"computed static key","suites":["sfc reactive props destructure"],"updatePoint":{"line":215,"column":27},"line":215,"code":"  test('computed static key', () => {\n    const { content, bindings } = compile(`\n    <script setup>\n    const { ['foo']: foo } = defineProps(['foo'])\n    console.log(foo)\n    </script>\n    <template>{{ foo }}</template>\n  `)\n    expect(content).not.toMatch(`const { foo } =`)\n    expect(content).toMatch(`console.log(__props.foo)`)\n    expect(content).toMatch(`_toDisplayString(__props.foo)`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS\n    })\n  })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error on deep destructure","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":233,"column":42},"line":233,"code":"    test('should error on deep destructure', () => {\n      expect(() =>\n        compile(\n          `<script setup>const { foo: [bar] } = defineProps(['foo'])</script>`\n        )\n      ).toThrow(`destructure does not support nested patterns`)\n\n      expect(() =>\n        compile(\n          `<script setup>const { foo: { bar } } = defineProps(['foo'])</script>`\n        )\n      ).toThrow(`destructure does not support nested patterns`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error on computed key","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":247,"column":38},"line":247,"code":"    test('should error on computed key', () => {\n      expect(() =>\n        compile(\n          `<script setup>const { [foo]: bar } = defineProps(['foo'])</script>`\n        )\n      ).toThrow(`destructure cannot use computed key`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error when used with withDefaults","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":255,"column":50},"line":255,"code":"    test('should error when used with withDefaults', () => {\n      expect(() =>\n        compile(\n          `<script setup lang=\"ts\">\n          const { foo } = withDefaults(defineProps<{ foo: string }>(), { foo: 'foo' })\n          </script>`\n        )\n      ).toThrow(`withDefaults() is unnecessary when using destructure`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error if destructure reference local vars","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":265,"column":58},"line":265,"code":"    test('should error if destructure reference local vars', () => {\n      expect(() =>\n        compile(\n          `<script setup>\n          let x = 1\n          const {\n            foo = () => x\n          } = defineProps(['foo'])\n          </script>`\n        )\n      ).toThrow(`cannot reference locally declared variables`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error if assignment to destructured prop binding","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":278,"column":65},"line":278,"code":"    test('should error if assignment to destructured prop binding', () => {\n      expect(() =>\n        compile(\n          `<script setup>\n          const { foo } = defineProps(['foo'])\n          foo = 'bar'\n          </script>`\n        )\n      ).toThrow(`Cannot assign to destructured props`)\n\n      expect(() =>\n        compile(\n          `<script setup>\n          let { foo } = defineProps(['foo'])\n          foo = 'bar'\n          </script>`\n        )\n      ).toThrow(`Cannot assign to destructured props`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error when passing destructured prop into certain methods","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":298,"column":74},"line":298,"code":"    test('should error when passing destructured prop into certain methods', () => {\n      expect(() =>\n        compile(\n          `<script setup>\n        import { watch } from 'vue'\n        const { foo } = defineProps(['foo'])\n        watch(foo, () => {})\n        </script>`\n        )\n      ).toThrow(\n        `\"foo\" is a destructured prop and should not be passed directly to watch().`\n      )\n\n      expect(() =>\n        compile(\n          `<script setup>\n        import { watch as w } from 'vue'\n        const { foo } = defineProps(['foo'])\n        w(foo, () => {})\n        </script>`\n        )\n      ).toThrow(\n        `\"foo\" is a destructured prop and should not be passed directly to watch().`\n      )\n\n      expect(() =>\n        compile(\n          `<script setup>\n        import { toRef } from 'vue'\n        const { foo } = defineProps(['foo'])\n        toRef(foo)\n        </script>`\n        )\n      ).toThrow(\n        `\"foo\" is a destructured prop and should not be passed directly to toRef().`\n      )\n\n      expect(() =>\n        compile(\n          `<script setup>\n        import { toRef as r } from 'vue'\n        const { foo } = defineProps(['foo'])\n        r(foo)\n        </script>`\n        )\n      ).toThrow(\n        `\"foo\" is a destructured prop and should not be passed directly to toRef().`\n      )\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should error if default value type does not match declared type","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":349,"column":73},"line":349,"code":"    test('should error if default value type does not match declared type', () => {\n      expect(() =>\n        compile(\n          `<script setup lang=\"ts\">\n        const { foo = 'hello' } = defineProps<{ foo?: number }>()\n        </script>`\n        )\n      ).toThrow(`Default value of prop \"foo\" does not match declared type.`)\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not throw an error if the variable is not a props","suites":["sfc reactive props destructure","errors"],"updatePoint":{"line":360,"column":66},"line":360,"code":"    test('should not throw an error if the variable is not a props', () => {\n      expect(() =>\n        compile(\n          `<script setup lang='ts'>\n        import { watch } from 'vue'\n        const { userId } = defineProps({ userId: Number })\n        const { error: e, info } = useRequest();\n        watch(e, () => {});\n        watch(info, () => {});\n        </script>`\n        )\n      ).not.toThrowError()\n    })","file":"compileScript/definePropsDestructure.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic usage","suites":["defineSlots()"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  test('basic usage', () => {\n    const { content } = compile(`\n      <script setup lang=\"ts\">\n      const slots = defineSlots<{\n        default: { msg: string }\n      }>()\n      </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`const slots = _useSlots()`)\n    expect(content).not.toMatch('defineSlots')\n  })","file":"compileScript/defineSlots.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/o return value","suites":["defineSlots()"],"updatePoint":{"line":17,"column":24},"line":17,"code":"  test('w/o return value', () => {\n    const { content } = compile(`\n      <script setup lang=\"ts\">\n      defineSlots<{\n        default: { msg: string }\n      }>()\n      </script>\n    `)\n    assertCode(content)\n    expect(content).not.toMatch('defineSlots')\n    expect(content).not.toMatch(`_useSlots`)\n  })","file":"compileScript/defineSlots.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/o generic params","suites":["defineSlots()"],"updatePoint":{"line":30,"column":26},"line":30,"code":"  test('w/o generic params', () => {\n    const { content } = compile(`\n      <script setup>\n      const slots = defineSlots()\n      </script>\n    `)\n    assertCode(content)\n    expect(content).toMatch(`const slots = _useSlots()`)\n    expect(content).not.toMatch('defineSlots')\n  })","file":"compileScript/defineSlots.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should hoist literal value","suites":["sfc hoist static"],"updatePoint":{"line":14,"column":34},"line":14,"code":"  test('should hoist literal value', () => {\n    const code = `\n    const string = 'default value'\n    const number = 123\n    const boolean = false\n    const nil = null\n    const bigint = 100n\n    const template = \\`str\\`\n    const regex = /.*/g\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup>\n    ${code}\n    </script>\n    `)\n\n    // should hoist to first line\n    expect(content.startsWith(code)).toBe(true)\n    expect(bindings).toStrictEqual({\n      string: BindingTypes.LITERAL_CONST,\n      number: BindingTypes.LITERAL_CONST,\n      boolean: BindingTypes.LITERAL_CONST,\n      nil: BindingTypes.LITERAL_CONST,\n      bigint: BindingTypes.LITERAL_CONST,\n      template: BindingTypes.LITERAL_CONST,\n      regex: BindingTypes.LITERAL_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should hoist expressions","suites":["sfc hoist static"],"updatePoint":{"line":44,"column":32},"line":44,"code":"  test('should hoist expressions', () => {\n    const code = `\n    const unary = !false\n    const binary = 1 + 2\n    const conditional = 1 ? 2 : 3\n    const sequence = (1, true, 'foo', 1)\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup>\n    ${code}\n    </script>\n    `)\n    // should hoist to first line\n    expect(content.startsWith(code)).toBe(true)\n    expect(bindings).toStrictEqual({\n      binary: BindingTypes.LITERAL_CONST,\n      conditional: BindingTypes.LITERAL_CONST,\n      unary: BindingTypes.LITERAL_CONST,\n      sequence: BindingTypes.LITERAL_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should hoist w/ defineProps/Emits","suites":["sfc hoist static"],"updatePoint":{"line":67,"column":41},"line":67,"code":"  test('should hoist w/ defineProps/Emits', () => {\n    const hoistCode = `const defaultValue = 'default value'`\n    const { content, bindings } = compile(`\n    <script setup>\n    ${hoistCode}\n    defineProps({\n      foo: {\n        default: defaultValue\n      }\n    })\n    </script>\n    `)\n\n    // should hoist to first line\n    expect(content.startsWith(hoistCode)).toBe(true)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.PROPS,\n      defaultValue: BindingTypes.LITERAL_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist a variable","suites":["sfc hoist static"],"updatePoint":{"line":89,"column":35},"line":89,"code":"  test('should not hoist a variable', () => {\n    const code = `\n    let KEY1 = 'default value'\n    var KEY2 = 123\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup>\n    ${code}\n    </script>\n    `)\n    expect(bindings).toStrictEqual({\n      KEY1: BindingTypes.SETUP_LET,\n      KEY2: BindingTypes.SETUP_LET\n    })\n    expect(content).toMatch(`setup(__props) {\\n\\n    ${code}`)\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist a constant initialized to a reference value","suites":["sfc hoist static"],"updatePoint":{"line":107,"column":68},"line":107,"code":"  test('should not hoist a constant initialized to a reference value', () => {\n    const code = `\n    const KEY1 = Boolean\n    const KEY2 = [Boolean]\n    const KEY3 = [getCurrentInstance()]\n    let i = 0;\n    const KEY4 = (i++, 'foo')\n    enum KEY5 {\n      FOO = 1,\n      BAR = getCurrentInstance(),\n    }\n    const KEY6 = \\`template\\${i}\\`\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup lang=\"ts\">\n    ${code}\n    </script>\n    `)\n    expect(bindings).toStrictEqual({\n      KEY1: BindingTypes.SETUP_MAYBE_REF,\n      KEY2: BindingTypes.SETUP_CONST,\n      KEY3: BindingTypes.SETUP_CONST,\n      KEY4: BindingTypes.SETUP_CONST,\n      KEY5: BindingTypes.SETUP_CONST,\n      KEY6: BindingTypes.SETUP_CONST,\n      i: BindingTypes.SETUP_LET\n    })\n    expect(content).toMatch(`setup(__props) {\\n\\n    ${code}`)\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist a object or array","suites":["sfc hoist static"],"updatePoint":{"line":138,"column":42},"line":138,"code":"  test('should not hoist a object or array', () => {\n    const code = `\n    const obj = { foo: 'bar' }\n    const arr = [1, 2, 3]\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup>\n    ${code}\n    </script>\n    `)\n    expect(bindings).toStrictEqual({\n      arr: BindingTypes.SETUP_CONST,\n      obj: BindingTypes.SETUP_CONST\n    })\n    expect(content).toMatch(`setup(__props) {\\n\\n    ${code}`)\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist a function or class","suites":["sfc hoist static"],"updatePoint":{"line":156,"column":44},"line":156,"code":"  test('should not hoist a function or class', () => {\n    const code = `\n    const fn = () => {}\n    function fn2() {}\n    class Foo {}\n    `.trim()\n    const { content, bindings } = compile(`\n    <script setup>\n    ${code}\n    </script>\n    `)\n    expect(bindings).toStrictEqual({\n      Foo: BindingTypes.SETUP_CONST,\n      fn: BindingTypes.SETUP_CONST,\n      fn2: BindingTypes.SETUP_CONST\n    })\n    expect(content).toMatch(`setup(__props) {\\n\\n    ${code}`)\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should enable when only script setup","suites":["sfc hoist static"],"updatePoint":{"line":176,"column":44},"line":176,"code":"  test('should enable when only script setup', () => {\n    const { content, bindings } = compile(`\n    <script>\n    const foo = 'bar'\n    </script>\n    <script setup>\n    const foo = 'bar'\n    </script>\n    `)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist when disabled","suites":["sfc hoist static"],"updatePoint":{"line":191,"column":38},"line":191,"code":"  test('should not hoist when disabled', () => {\n    const { content, bindings } = compile(\n      `\n    <script setup>\n    const foo = 'bar'\n    </script>\n    `,\n      { hoistStatic: false }\n    )\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_CONST\n    })\n    assertCode(content)\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template binding access in inline mode","suites":["sfc hoist static"],"updatePoint":{"line":206,"column":46},"line":206,"code":"  test('template binding access in inline mode', () => {\n    const { content } = compile(\n      `\n    <script setup>\n    const foo = 'bar'\n    </script>\n    <template>{{ foo }}</template>\n    `\n    )\n    expect(content).toMatch('_toDisplayString(foo)')\n  })","file":"compileScript/hoistStatic.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"$ unwrapping","suites":["sfc ref transform"],"updatePoint":{"line":12,"column":20},"line":12,"code":"  test('$ unwrapping', () => {\n    const { content, bindings } = compileWithReactivityTransform(`<script setup>\n    import { ref, shallowRef } from 'vue'\n    let foo = $(ref())\n    let a = $(ref(1))\n    let b = $(shallowRef({\n      count: 0\n    }))\n    let c = () => {}\n    let d\n    </script>`)\n    expect(content).not.toMatch(`$(ref())`)\n    expect(content).not.toMatch(`$(ref(1))`)\n    expect(content).not.toMatch(`$(shallowRef({`)\n    expect(content).toMatch(`let foo = (ref())`)\n    expect(content).toMatch(`let a = (ref(1))`)\n    expect(content).toMatch(`\n    let b = (shallowRef({\n      count: 0\n    }))\n    `)\n    // normal declarations left untouched\n    expect(content).toMatch(`let c = () => {}`)\n    expect(content).toMatch(`let d`)\n    expect(content).toMatch(\n      `return { foo, a, b, get c() { return c }, set c(v) { c = v }, ` +\n        `get d() { return d }, set d(v) { d = v }, ref, shallowRef }`\n    )\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_REF,\n      a: BindingTypes.SETUP_REF,\n      b: BindingTypes.SETUP_REF,\n      c: BindingTypes.SETUP_LET,\n      d: BindingTypes.SETUP_LET,\n      ref: BindingTypes.SETUP_CONST,\n      shallowRef: BindingTypes.SETUP_CONST\n    })\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"$ref & $shallowRef declarations","suites":["sfc ref transform"],"updatePoint":{"line":52,"column":39},"line":52,"code":"  test('$ref & $shallowRef declarations', () => {\n    const { content, bindings } = compileWithReactivityTransform(`<script setup>\n    let foo = $ref()\n    let a = $ref(1)\n    let b = $shallowRef({\n      count: 0\n    })\n    let c = () => {}\n    let d\n    </script>`)\n    expect(content).toMatch(\n      `import { ref as _ref, shallowRef as _shallowRef } from 'vue'`\n    )\n    expect(content).not.toMatch(`$ref()`)\n    expect(content).not.toMatch(`$ref(1)`)\n    expect(content).not.toMatch(`$shallowRef({`)\n    expect(content).toMatch(`let foo = _ref()`)\n    expect(content).toMatch(`let a = _ref(1)`)\n    expect(content).toMatch(`\n    let b = _shallowRef({\n      count: 0\n    })\n    `)\n    // normal declarations left untouched\n    expect(content).toMatch(`let c = () => {}`)\n    expect(content).toMatch(`let d`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      foo: BindingTypes.SETUP_REF,\n      a: BindingTypes.SETUP_REF,\n      b: BindingTypes.SETUP_REF,\n      c: BindingTypes.SETUP_LET,\n      d: BindingTypes.SETUP_LET\n    })\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"usage in normal <script>","suites":["sfc ref transform"],"updatePoint":{"line":88,"column":32},"line":88,"code":"  test('usage in normal <script>', () => {\n    const { content } = compileWithReactivityTransform(`<script>\n    export default {\n      setup() {\n        let count = $ref(0)\n        const inc = () => count++\n        return $$({ count })\n      }\n    }\n    </script>`)\n    expect(content).not.toMatch(`$ref(0)`)\n    expect(content).toMatch(`import { ref as _ref } from 'vue'`)\n    expect(content).toMatch(`let count = _ref(0)`)\n    expect(content).toMatch(`count.value++`)\n    expect(content).toMatch(`return ({ count })`)\n    assertCode(content)\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"usage /w typescript","suites":["sfc ref transform"],"updatePoint":{"line":106,"column":27},"line":106,"code":"  test('usage /w typescript', () => {\n    const { content } = compileWithReactivityTransform(`\n      <script setup lang=\"ts\">\n        let msg = $ref<string | number>('foo');\n        let bar = $ref <string | number>('bar');\n      </script>\n    `)\n    expect(content).toMatch(`import { ref as _ref`)\n    expect(content).toMatch(`let msg = _ref<string | number>('foo')`)\n    expect(content).toMatch(`let bar = _ref <string | number>('bar')`)\n    assertCode(content)\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"usage with normal <script> + <script setup>","suites":["sfc ref transform"],"updatePoint":{"line":119,"column":51},"line":119,"code":"  test('usage with normal <script> + <script setup>', () => {\n    const { content, bindings } = compileWithReactivityTransform(`<script>\n    let a = $ref(0)\n    let c = $ref(0)\n    </script>\n    <script setup>\n    let b = $ref(0)\n    let c = 0\n    function change() {\n      a++\n      b++\n      c++\n    }\n    </script>`)\n    // should dedupe helper imports\n    expect(content).toMatch(`import { ref as _ref } from 'vue'`)\n\n    expect(content).toMatch(`let a = _ref(0)`)\n    expect(content).toMatch(`let b = _ref(0)`)\n\n    // root level ref binding declared in <script> should be inherited in <script setup>\n    expect(content).toMatch(`a.value++`)\n    expect(content).toMatch(`b.value++`)\n    // c shadowed\n    expect(content).toMatch(`c++`)\n    assertCode(content)\n    expect(bindings).toStrictEqual({\n      a: BindingTypes.SETUP_REF,\n      b: BindingTypes.SETUP_REF,\n      c: BindingTypes.SETUP_REF,\n      change: BindingTypes.SETUP_CONST\n    })\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"usage with normal <script> (has macro usage) + <script setup> (no macro usage)","suites":["sfc ref transform"],"updatePoint":{"line":153,"column":86},"line":153,"code":"  test('usage with normal <script> (has macro usage) + <script setup> (no macro usage)', () => {\n    const { content } = compileWithReactivityTransform(`\n    <script>\n    let data = $ref()\n    </script>\n    <script setup>\n    console.log(data)\n    </script>\n    `)\n    expect(content).toMatch(`console.log(data.value)`)\n    assertCode(content)\n  })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"defineProps/Emit() referencing ref declarations","suites":["sfc ref transform","errors"],"updatePoint":{"line":167,"column":57},"line":167,"code":"    test('defineProps/Emit() referencing ref declarations', () => {\n      expect(() =>\n        compile(\n          `<script setup>\n        let bar = $ref(1)\n        defineProps({\n          bar\n        })\n      </script>`,\n          { reactivityTransform: true }\n        )\n      ).toThrow(`cannot reference locally declared variables`)\n\n      expect(() =>\n        compile(\n          `<script setup>\n        let bar = $ref(1)\n        defineEmits({\n          bar\n        })\n      </script>`,\n          { reactivityTransform: true }\n        )\n      ).toThrow(`cannot reference locally declared variables`)\n    })","file":"compileScript/reactivityTransform.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"type literal","suites":["resolveType"],"updatePoint":{"line":16,"column":20},"line":16,"code":"  test('type literal', () => {\n    const { props, calls } = resolve(`defineProps<{\n      foo: number // property\n      bar(): void // method\n      'baz': string // string literal key\n      (e: 'foo'): void // call signature\n      (e: 'bar'): void\n    }>()`)\n    expect(props).toStrictEqual({\n      foo: ['Number'],\n      bar: ['Function'],\n      baz: ['String']\n    })\n    expect(calls?.length).toBe(2)\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference type","suites":["resolveType"],"updatePoint":{"line":32,"column":22},"line":32,"code":"  test('reference type', () => {\n    expect(\n      resolve(`\n    type Aliased = { foo: number }\n    defineProps<Aliased>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference exported type","suites":["resolveType"],"updatePoint":{"line":43,"column":31},"line":43,"code":"  test('reference exported type', () => {\n    expect(\n      resolve(`\n    export type Aliased = { foo: number }\n    defineProps<Aliased>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference interface","suites":["resolveType"],"updatePoint":{"line":54,"column":27},"line":54,"code":"  test('reference interface', () => {\n    expect(\n      resolve(`\n    interface Aliased { foo: number }\n    defineProps<Aliased>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference exported interface","suites":["resolveType"],"updatePoint":{"line":65,"column":36},"line":65,"code":"  test('reference exported interface', () => {\n    expect(\n      resolve(`\n    export interface Aliased { foo: number }\n    defineProps<Aliased>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference interface extends","suites":["resolveType"],"updatePoint":{"line":76,"column":35},"line":76,"code":"  test('reference interface extends', () => {\n    expect(\n      resolve(`\n    export interface A { a(): void }\n    export interface B extends A { b: boolean }\n    interface C { c: string }\n    interface Aliased extends B, C { foo: number }\n    defineProps<Aliased>()\n    `).props\n    ).toStrictEqual({\n      a: ['Function'],\n      b: ['Boolean'],\n      c: ['String'],\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference class","suites":["resolveType"],"updatePoint":{"line":93,"column":23},"line":93,"code":"  test('reference class', () => {\n    expect(\n      resolve(`\n    class Foo {}\n    defineProps<{ foo: Foo }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Object']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"function type","suites":["resolveType"],"updatePoint":{"line":104,"column":21},"line":104,"code":"  test('function type', () => {\n    expect(\n      resolve(`\n    defineProps<(e: 'foo') => void>()\n    `).calls?.length\n    ).toBe(1)\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"reference function type","suites":["resolveType"],"updatePoint":{"line":112,"column":31},"line":112,"code":"  test('reference function type', () => {\n    expect(\n      resolve(`\n    type Fn = (e: 'foo') => void\n    defineProps<Fn>()\n    `).calls?.length\n    ).toBe(1)\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"intersection type","suites":["resolveType"],"updatePoint":{"line":121,"column":25},"line":121,"code":"  test('intersection type', () => {\n    expect(\n      resolve(`\n    type Foo = { foo: number }\n    type Bar = { bar: string }\n    type Baz = { bar: string | boolean }\n    defineProps<{ self: any } & Foo & Bar & Baz>()\n    `).props\n    ).toStrictEqual({\n      self: ['Unknown'],\n      foo: ['Number'],\n      // both Bar & Baz has 'bar', but Baz['bar] is wider so it should be\n      // preferred\n      bar: ['String', 'Boolean']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"union type","suites":["resolveType"],"updatePoint":{"line":139,"column":18},"line":139,"code":"  test('union type', () => {\n    expect(\n      resolve(`\n    interface CommonProps {\n      size?: 'xl' | 'l' | 'm' | 's' | 'xs'\n    }\n\n    type ConditionalProps =\n      | {\n          color: 'normal' | 'primary' | 'secondary'\n          appearance: 'normal' | 'outline' | 'text'\n        }\n      | {\n          color: number\n          appearance: 'outline'\n          note: string\n        }\n\n    defineProps<CommonProps & ConditionalProps>()\n    `).props\n    ).toStrictEqual({\n      size: ['String'],\n      color: ['String', 'Number'],\n      appearance: ['String'],\n      note: ['String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template string type","suites":["resolveType"],"updatePoint":{"line":167,"column":28},"line":167,"code":"  test('template string type', () => {\n    expect(\n      resolve(`\n    type T = 'foo' | 'bar'\n    type S = 'x' | 'y'\n    defineProps<{\n      [\\`_\\${T}_\\${S}_\\`]: string\n    }>()\n    `).props\n    ).toStrictEqual({\n      _foo_x_: ['String'],\n      _foo_y_: ['String'],\n      _bar_x_: ['String'],\n      _bar_y_: ['String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"mapped types w/ string manipulation","suites":["resolveType"],"updatePoint":{"line":184,"column":43},"line":184,"code":"  test('mapped types w/ string manipulation', () => {\n    expect(\n      resolve(`\n    type T = 'foo' | 'bar'\n    defineProps<{ [K in T]: string | number } & {\n      [K in 'optional']?: boolean\n    } & {\n      [K in Capitalize<T>]: string\n    } & {\n      [K in Uppercase<Extract<T, 'foo'>>]: string\n    } & {\n      [K in \\`x\\${T}\\`]: string\n    }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String', 'Number'],\n      bar: ['String', 'Number'],\n      Foo: ['String'],\n      Bar: ['String'],\n      FOO: ['String'],\n      xfoo: ['String'],\n      xbar: ['String'],\n      optional: ['Boolean']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"utility type: Partial","suites":["resolveType"],"updatePoint":{"line":210,"column":29},"line":210,"code":"  test('utility type: Partial', () => {\n    expect(\n      resolve(`\n    type T = { foo: number, bar: string }\n    defineProps<Partial<T>>()\n    `).raw.props\n    ).toMatchObject({\n      foo: {\n        optional: true\n      },\n      bar: {\n        optional: true\n      }\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"utility type: Required","suites":["resolveType"],"updatePoint":{"line":226,"column":30},"line":226,"code":"  test('utility type: Required', () => {\n    expect(\n      resolve(`\n    type T = { foo?: number, bar?: string }\n    defineProps<Required<T>>()\n    `).raw.props\n    ).toMatchObject({\n      foo: {\n        optional: false\n      },\n      bar: {\n        optional: false\n      }\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"utility type: Pick","suites":["resolveType"],"updatePoint":{"line":242,"column":26},"line":242,"code":"  test('utility type: Pick', () => {\n    expect(\n      resolve(`\n    type T = { foo: number, bar: string, baz: boolean }\n    type K = 'foo' | 'bar'\n    defineProps<Pick<T, K>>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number'],\n      bar: ['String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"utility type: Omit","suites":["resolveType"],"updatePoint":{"line":255,"column":26},"line":255,"code":"  test('utility type: Omit', () => {\n    expect(\n      resolve(`\n    type T = { foo: number, bar: string, baz: boolean }\n    type K = 'foo' | 'bar'\n    defineProps<Omit<T, K>>()\n    `).props\n    ).toStrictEqual({\n      baz: ['Boolean']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"indexed access type (literal)","suites":["resolveType"],"updatePoint":{"line":267,"column":37},"line":267,"code":"  test('indexed access type (literal)', () => {\n    expect(\n      resolve(`\n    type T = { bar: number }\n    type S = { nested: { foo: T['bar'] }}\n    defineProps<S['nested']>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"indexed access type (advanced)","suites":["resolveType"],"updatePoint":{"line":279,"column":38},"line":279,"code":"  test('indexed access type (advanced)', () => {\n    expect(\n      resolve(`\n    type K = 'foo' | 'bar'\n    type T = { foo: string, bar: number }\n    type S = { foo: { foo: T[string] }, bar: { bar: string } }\n    defineProps<S[K]>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String', 'Number'],\n      bar: ['String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"indexed access type (number)","suites":["resolveType"],"updatePoint":{"line":293,"column":36},"line":293,"code":"  test('indexed access type (number)', () => {\n    expect(\n      resolve(`\n    type A = (string | number)[]\n    type AA = Array<string>\n    type T = [1, 'foo']\n    type TT = [foo: 1, bar: 'foo']\n    defineProps<{ foo: A[number], bar: AA[number], tuple: T[number], namedTuple: TT[number] }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String', 'Number'],\n      bar: ['String'],\n      tuple: ['Number', 'String'],\n      namedTuple: ['Number', 'String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"namespace","suites":["resolveType"],"updatePoint":{"line":310,"column":17},"line":310,"code":"  test('namespace', () => {\n    expect(\n      resolve(`\n      type X = string\n      namespace Foo {\n        type X = number\n        export namespace Bar {\n          export type A = {\n            foo: X\n          }\n        }\n      }\n      defineProps<Foo.Bar.A>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"interface merging","suites":["resolveType"],"updatePoint":{"line":329,"column":25},"line":329,"code":"  test('interface merging', () => {\n    expect(\n      resolve(`\n      interface Foo {\n        a: string\n      }\n      interface Foo {\n        b: number\n      }\n      defineProps<{\n        foo: Foo['a'],\n        bar: Foo['b']\n      }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String'],\n      bar: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"namespace merging","suites":["resolveType"],"updatePoint":{"line":349,"column":25},"line":349,"code":"  test('namespace merging', () => {\n    expect(\n      resolve(`\n      namespace Foo {\n        export type A = string\n      }\n      namespace Foo {\n        export type B = number\n      }\n      defineProps<{\n        foo: Foo.A,\n        bar: Foo.B\n      }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String'],\n      bar: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"namespace merging with other types","suites":["resolveType"],"updatePoint":{"line":369,"column":42},"line":369,"code":"  test('namespace merging with other types', () => {\n    expect(\n      resolve(`\n      namespace Foo {\n        export type A = string\n      }\n      interface Foo {\n        b: number\n      }\n      defineProps<{\n        foo: Foo.A,\n        bar: Foo['b']\n      }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String'],\n      bar: ['Number']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"enum merging","suites":["resolveType"],"updatePoint":{"line":389,"column":20},"line":389,"code":"  test('enum merging', () => {\n    expect(\n      resolve(`\n      enum Foo {\n        A = 1\n      }\n      enum Foo {\n        B = 'hi'\n      }\n      defineProps<{\n        foo: Foo\n      }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['Number', 'String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"typeof","suites":["resolveType"],"updatePoint":{"line":407,"column":14},"line":407,"code":"  test('typeof', () => {\n    expect(\n      resolve(`\n      declare const a: string\n      defineProps<{ foo: typeof a }>()\n    `).props\n    ).toStrictEqual({\n      foo: ['String']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ExtractPropTypes (element-plus)","suites":["resolveType"],"updatePoint":{"line":418,"column":39},"line":418,"code":"  test('ExtractPropTypes (element-plus)', () => {\n    const { props, raw } = resolve(\n      `\n      import { ExtractPropTypes } from 'vue'\n      declare const props: {\n        foo: StringConstructor,\n        bar: {\n          type: import('foo').EpPropFinalized<BooleanConstructor>,\n          required: true\n        }\n      }\n      type Props = ExtractPropTypes<typeof props>\n      defineProps<Props>()\n    `\n    )\n    expect(props).toStrictEqual({\n      foo: ['String'],\n      bar: ['Boolean']\n    })\n    expect(raw.props.bar.optional).toBe(false)\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ExtractPropTypes (antd)","suites":["resolveType"],"updatePoint":{"line":440,"column":31},"line":440,"code":"  test('ExtractPropTypes (antd)', () => {\n    const { props } = resolve(\n      `\n      declare const props: () => {\n        foo: StringConstructor,\n        bar: { type: PropType<boolean> }\n      }\n      type Props = Partial<import('vue').ExtractPropTypes<ReturnType<typeof props>>>\n      defineProps<Props>()\n    `\n    )\n    expect(props).toStrictEqual({\n      foo: ['String'],\n      bar: ['Boolean']\n    })\n  })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative ts","suites":["resolveType","external type imports"],"updatePoint":{"line":462,"column":21},"line":462,"code":"    test('relative ts', () => {\n      const { props, deps } = resolve(\n        `\n        import { P } from './foo'\n        import { Y as PP } from './bar'\n        defineProps<P & PP>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        foo: ['Number'],\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative vue","suites":["resolveType","external type imports"],"updatePoint":{"line":478,"column":22},"line":478,"code":"    test('relative vue', () => {\n      const files = {\n        '/foo.vue':\n          '<script lang=\"ts\">export type P = { foo: number }</script>',\n        '/bar.vue':\n          '<script setup lang=\"tsx\">export type P = { bar: string }</script>'\n      }\n      const { props, deps } = resolve(\n        `\n        import { P } from './foo.vue'\n        import { P as PP } from './bar.vue'\n        defineProps<P & PP>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        foo: ['Number'],\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative (chained)","suites":["resolveType","external type imports"],"updatePoint":{"line":500,"column":28},"line":500,"code":"    test('relative (chained)', () => {\n      const files = {\n        '/foo.ts': `import type { P as PP } from './nested/bar.vue'\n          export type P = { foo: number } & PP`,\n        '/nested/bar.vue':\n          '<script setup lang=\"ts\">export type P = { bar: string }</script>'\n      }\n      const { props, deps } = resolve(\n        `\n        import { P } from './foo'\n        defineProps<P>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        foo: ['Number'],\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative (chained, re-export)","suites":["resolveType","external type imports"],"updatePoint":{"line":521,"column":39},"line":521,"code":"    test('relative (chained, re-export)', () => {\n      const files = {\n        '/foo.ts': `export { P as PP } from './bar'`,\n        '/bar.ts': 'export type P = { bar: string }'\n      }\n      const { props, deps } = resolve(\n        `\n        import { PP as P } from './foo'\n        defineProps<P>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative (chained, export *)","suites":["resolveType","external type imports"],"updatePoint":{"line":539,"column":38},"line":539,"code":"    test('relative (chained, export *)', () => {\n      const files = {\n        '/foo.ts': `export * from './bar'`,\n        '/bar.ts': 'export type P = { bar: string }'\n      }\n      const { props, deps } = resolve(\n        `\n        import { P } from './foo'\n        defineProps<P>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"relative (dynamic import)","suites":["resolveType","external type imports"],"updatePoint":{"line":557,"column":35},"line":557,"code":"    test('relative (dynamic import)', () => {\n      const files = {\n        '/foo.ts': `export type P = { foo: string, bar: import('./bar').N }`,\n        '/bar.ts': 'export type N = number'\n      }\n      const { props, deps } = resolve(\n        `\n        defineProps<import('./foo').P>()\n      `,\n        files\n      )\n      expect(props).toStrictEqual({\n        foo: ['String'],\n        bar: ['Number']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ts module resolve","suites":["resolveType","external type imports"],"updatePoint":{"line":575,"column":27},"line":575,"code":"    test('ts module resolve', () => {\n      const files = {\n        '/node_modules/foo/package.json': JSON.stringify({\n          types: 'index.d.ts'\n        }),\n        '/node_modules/foo/index.d.ts': 'export type P = { foo: number }',\n        '/tsconfig.json': JSON.stringify({\n          compilerOptions: {\n            paths: {\n              bar: ['./pp.ts']\n            }\n          }\n        }),\n        '/pp.ts': 'export type PP = { bar: string }'\n      }\n\n      const { props, deps } = resolve(\n        `\n        import { P } from 'foo'\n        import { PP } from 'bar'\n        defineProps<P & PP>()\n        `,\n        files\n      )\n\n      expect(props).toStrictEqual({\n        foo: ['Number'],\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual([\n        '/node_modules/foo/index.d.ts',\n        '/pp.ts'\n      ])\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"global types","suites":["resolveType","external type imports"],"updatePoint":{"line":610,"column":22},"line":610,"code":"    test('global types', () => {\n      const files = {\n        // ambient\n        '/app.d.ts':\n          'declare namespace App { interface User { name: string } }',\n        // module - should only respect the declare global block\n        '/global.d.ts': `\n          declare type PP = { bar: number }\n          declare global {\n            type PP = { bar: string }\n          }\n          export {}\n        `\n      }\n\n      const { props, deps } = resolve(`defineProps<App.User & PP>()`, files, {\n        globalTypeFiles: Object.keys(files)\n      })\n\n      expect(props).toStrictEqual({\n        name: ['String'],\n        bar: ['String']\n      })\n      expect(deps && [...deps]).toStrictEqual(Object.keys(files))\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"global types with ambient references","suites":["resolveType","external type imports"],"updatePoint":{"line":636,"column":46},"line":636,"code":"    test('global types with ambient references', () => {\n      const files = {\n        // with references\n        '/backend.d.ts': `\n          declare namespace App.Data {\n            export type AircraftData = {\n              id: string\n              manufacturer: App.Data.Listings.ManufacturerData\n            }\n          }\n          declare namespace App.Data.Listings {\n            export type ManufacturerData = {\n              id: string\n            }\n          }\n        `\n      }\n\n      const { props } = resolve(`defineProps<App.Data.AircraftData>()`, files, {\n        globalTypeFiles: Object.keys(files)\n      })\n\n      expect(props).toStrictEqual({\n        id: ['String'],\n        manufacturer: ['Object']\n      })\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"failed type reference","suites":["resolveType","errors"],"updatePoint":{"line":666,"column":31},"line":666,"code":"    test('failed type reference', () => {\n      expect(() => resolve(`defineProps<X>()`)).toThrow(\n        `Unresolvable type reference`\n      )\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"unsupported computed keys","suites":["resolveType","errors"],"updatePoint":{"line":672,"column":35},"line":672,"code":"    test('unsupported computed keys', () => {\n      expect(() => resolve(`defineProps<{ [Foo]: string }>()`)).toThrow(\n        `Unsupported computed key in type referenced by a macro`\n      )\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"unsupported index type","suites":["resolveType","errors"],"updatePoint":{"line":678,"column":32},"line":678,"code":"    test('unsupported index type', () => {\n      expect(() => resolve(`defineProps<X[K]>()`)).toThrow(\n        `Unsupported type when resolving index type`\n      )\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"failed import source resolve","suites":["resolveType","errors"],"updatePoint":{"line":684,"column":38},"line":684,"code":"    test('failed import source resolve', () => {\n      expect(() =>\n        resolve(`import { X } from './foo'; defineProps<X>()`)\n      ).toThrow(`Failed to resolve import source \"./foo\"`)\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not error on unresolved type when inferring runtime type","suites":["resolveType","errors"],"updatePoint":{"line":690,"column":73},"line":690,"code":"    test('should not error on unresolved type when inferring runtime type', () => {\n      expect(() => resolve(`defineProps<{ foo: T }>()`)).not.toThrow()\n      expect(() => resolve(`defineProps<{ foo: T['bar'] }>()`)).not.toThrow()\n      expect(() =>\n        resolve(`\n        import type P from 'unknown'\n        defineProps<{ foo: P }>()\n      `)\n      ).not.toThrow()\n    })","file":"compileScript/resolveType.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"simple selectors","suites":["SFC scoped CSS"],"updatePoint":{"line":29,"column":24},"line":29,"code":"  test('simple selectors', () => {\n    expect(compileScoped(`h1 { color: red; }`)).toMatch(\n      `h1[data-v-test] { color: red;`\n    )\n    expect(compileScoped(`.foo { color: red; }`)).toMatch(\n      `.foo[data-v-test] { color: red;`\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"descendent selector","suites":["SFC scoped CSS"],"updatePoint":{"line":38,"column":27},"line":38,"code":"  test('descendent selector', () => {\n    expect(compileScoped(`h1 .foo { color: red; }`)).toMatch(\n      `h1 .foo[data-v-test] { color: red;`\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"multiple selectors","suites":["SFC scoped CSS"],"updatePoint":{"line":44,"column":26},"line":44,"code":"  test('multiple selectors', () => {\n    expect(compileScoped(`h1 .foo, .bar, .baz { color: red; }`)).toMatch(\n      `h1 .foo[data-v-test], .bar[data-v-test], .baz[data-v-test] { color: red;`\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"pseudo class","suites":["SFC scoped CSS"],"updatePoint":{"line":50,"column":20},"line":50,"code":"  test('pseudo class', () => {\n    expect(compileScoped(`.foo:after { color: red; }`)).toMatch(\n      `.foo[data-v-test]:after { color: red;`\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"pseudo element","suites":["SFC scoped CSS"],"updatePoint":{"line":56,"column":22},"line":56,"code":"  test('pseudo element', () => {\n    expect(compileScoped(`::selection { display: none; }`)).toMatch(\n      '[data-v-test]::selection {'\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"spaces before pseudo element","suites":["SFC scoped CSS"],"updatePoint":{"line":62,"column":36},"line":62,"code":"  test('spaces before pseudo element', () => {\n    const code = compileScoped(`.abc, ::selection { color: red; }`)\n    expect(code).toMatch('.abc[data-v-test],')\n    expect(code).toMatch('[data-v-test]::selection {')\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"::v-deep","suites":["SFC scoped CSS"],"updatePoint":{"line":68,"column":16},"line":68,"code":"  test('::v-deep', () => {\n    expect(compileScoped(`:deep(.foo) { color: red; }`)).toMatchInlineSnapshot(`\n      \"[data-v-test] .foo { color: red;\n      }\"\n    `)\n    expect(compileScoped(`::v-deep(.foo) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \"[data-v-test] .foo { color: red;\n      }\"\n    `)\n    expect(compileScoped(`::v-deep(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \"[data-v-test] .foo .bar { color: red;\n      }\"\n    `)\n    expect(compileScoped(`.baz .qux ::v-deep(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".baz .qux[data-v-test] .foo .bar { color: red;\n      }\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"::v-slotted","suites":["SFC scoped CSS"],"updatePoint":{"line":90,"column":19},"line":90,"code":"  test('::v-slotted', () => {\n    expect(compileScoped(`:slotted(.foo) { color: red; }`))\n      .toMatchInlineSnapshot(`\n    \".foo[data-v-test-s] { color: red;\n    }\"\n  `)\n    expect(compileScoped(`::v-slotted(.foo) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".foo[data-v-test-s] { color: red;\n      }\"\n    `)\n    expect(compileScoped(`::v-slotted(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".foo .bar[data-v-test-s] { color: red;\n      }\"\n    `)\n    expect(compileScoped(`.baz .qux ::v-slotted(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".baz .qux .foo .bar[data-v-test-s] { color: red;\n      }\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"::v-global","suites":["SFC scoped CSS"],"updatePoint":{"line":113,"column":18},"line":113,"code":"  test('::v-global', () => {\n    expect(compileScoped(`:global(.foo) { color: red; }`))\n      .toMatchInlineSnapshot(`\n    \".foo { color: red;\n    }\"\n  `)\n    expect(compileScoped(`::v-global(.foo) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".foo { color: red;\n      }\"\n    `)\n    expect(compileScoped(`::v-global(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".foo .bar { color: red;\n      }\"\n    `)\n    // global ignores anything before it\n    expect(compileScoped(`.baz .qux ::v-global(.foo .bar) { color: red; }`))\n      .toMatchInlineSnapshot(`\n      \".foo .bar { color: red;\n      }\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"media query","suites":["SFC scoped CSS"],"updatePoint":{"line":137,"column":19},"line":137,"code":"  test('media query', () => {\n    expect(compileScoped(`@media print { .foo { color: red }}`))\n      .toMatchInlineSnapshot(`\n      \"@media print {\n      .foo[data-v-test] { color: red\n      }}\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"supports query","suites":["SFC scoped CSS"],"updatePoint":{"line":146,"column":22},"line":146,"code":"  test('supports query', () => {\n    expect(compileScoped(`@supports(display: grid) { .foo { display: grid }}`))\n      .toMatchInlineSnapshot(`\n      \"@supports(display: grid) {\n      .foo[data-v-test] { display: grid\n      }}\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"scoped keyframes","suites":["SFC scoped CSS"],"updatePoint":{"line":155,"column":24},"line":155,"code":"  test('scoped keyframes', () => {\n    const style = compileScoped(\n      `\n.anim {\n  animation: color 5s infinite, other 5s;\n}\n.anim-2 {\n  animation-name: color;\n  animation-duration: 5s;\n}\n.anim-3 {\n  animation: 5s color infinite, 5s other;\n}\n.anim-multiple {\n  animation: color 5s infinite, opacity 2s;\n}\n.anim-multiple-2 {\n  animation-name: color, opacity;\n  animation-duration: 5s, 2s;\n}\n\n@keyframes color {\n  from { color: red; }\n  to { color: green; }\n}\n@-webkit-keyframes color {\n  from { color: red; }\n  to { color: green; }\n}\n@keyframes opacity {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n@-webkit-keyframes opacity {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n    `,\n      { id: 'data-v-test' }\n    )\n\n    expect(style).toContain(\n      `.anim[data-v-test] {\\n  animation: color-test 5s infinite, other 5s;`\n    )\n    expect(style).toContain(\n      `.anim-2[data-v-test] {\\n  animation-name: color-test`\n    )\n    expect(style).toContain(\n      `.anim-3[data-v-test] {\\n  animation: 5s color-test infinite, 5s other;`\n    )\n    expect(style).toContain(`@keyframes color-test {`)\n    expect(style).toContain(`@-webkit-keyframes color-test {`)\n\n    expect(style).toContain(\n      `.anim-multiple[data-v-test] {\\n  animation: color-test 5s infinite,opacity-test 2s;`\n    )\n    expect(style).toContain(\n      `.anim-multiple-2[data-v-test] {\\n  animation-name: color-test,opacity-test;`\n    )\n    expect(style).toContain(`@keyframes opacity-test {\\nfrom { opacity: 0;`)\n    expect(style).toContain(\n      `@-webkit-keyframes opacity-test {\\nfrom { opacity: 0;`\n    )\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"spaces after selector","suites":["SFC scoped CSS"],"updatePoint":{"line":221,"column":29},"line":221,"code":"  test('spaces after selector', () => {\n    expect(compileScoped(`.foo , .bar { color: red; }`)).toMatchInlineSnapshot(`\n      \".foo[data-v-test], .bar[data-v-test] { color: red;\n      }\"\n    `)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"::v-deep as combinator","suites":["SFC scoped CSS","deprecated syntax"],"updatePoint":{"line":229,"column":32},"line":229,"code":"    test('::v-deep as combinator', () => {\n      expect(compileScoped(`::v-deep .foo { color: red; }`))\n        .toMatchInlineSnapshot(`\n        \"[data-v-test] .foo { color: red;\n        }\"\n      `)\n      expect(compileScoped(`.bar ::v-deep .foo { color: red; }`))\n        .toMatchInlineSnapshot(`\n        \".bar[data-v-test] .foo { color: red;\n        }\"\n      `)\n      expect(\n        `::v-deep usage as a combinator has been deprecated.`\n      ).toHaveBeenWarned()\n    })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":">>> (deprecated syntax)","suites":["SFC scoped CSS","deprecated syntax"],"updatePoint":{"line":245,"column":33},"line":245,"code":"    test('>>> (deprecated syntax)', () => {\n      const code = compileScoped(`>>> .foo { color: red; }`)\n      expect(code).toMatchInlineSnapshot(`\n        \"[data-v-test] .foo { color: red;\n        }\"\n      `)\n      expect(\n        `the >>> and /deep/ combinators have been deprecated.`\n      ).toHaveBeenWarned()\n    })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"/deep/ (deprecated syntax)","suites":["SFC scoped CSS","deprecated syntax"],"updatePoint":{"line":256,"column":36},"line":256,"code":"    test('/deep/ (deprecated syntax)', () => {\n      const code = compileScoped(`/deep/ .foo { color: red; }`)\n      expect(code).toMatchInlineSnapshot(`\n        \"[data-v-test] .foo { color: red;\n        }\"\n      `)\n      expect(\n        `the >>> and /deep/ combinators have been deprecated.`\n      ).toHaveBeenWarned()\n    })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should include resulting classes object in result","suites":["SFC CSS modules"],"updatePoint":{"line":270,"column":57},"line":270,"code":"  test('should include resulting classes object in result', async () => {\n    const result = await compileStyleAsync({\n      source: `.red { color: red }\\n.green { color: green }\\n:global(.blue) { color: blue }`,\n      filename: `test.css`,\n      id: 'test',\n      modules: true\n    })\n    expect(result.modules).toBeDefined()\n    expect(result.modules!.red).toMatch('_red_')\n    expect(result.modules!.green).toMatch('_green_')\n    expect(result.modules!.blue).toBeUndefined()\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"postcss-modules options","suites":["SFC CSS modules"],"updatePoint":{"line":283,"column":31},"line":283,"code":"  test('postcss-modules options', async () => {\n    const result = await compileStyleAsync({\n      source: `:local(.foo-bar) { color: red }\\n.baz-qux { color: green }`,\n      filename: `test.css`,\n      id: 'test',\n      modules: true,\n      modulesOptions: {\n        scopeBehaviour: 'global',\n        generateScopedName: `[name]__[local]__[hash:base64:5]`,\n        localsConvention: 'camelCaseOnly'\n      }\n    })\n    expect(result.modules).toBeDefined()\n    expect(result.modules!.fooBar).toMatch('__foo-bar__')\n    expect(result.modules!.bazQux).toBeUndefined()\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"scss @import","suites":["SFC style preprocessors"],"updatePoint":{"line":302,"column":20},"line":302,"code":"  test('scss @import', () => {\n    const res = compileStyle({\n      source: `\n        @import \"./import.scss\";\n      `,\n      filename: path.resolve(__dirname, './fixture/test.scss'),\n      id: '',\n      preprocessLang: 'scss'\n    })\n\n    expect([...res.dependencies]).toStrictEqual([\n      path.join(__dirname, './fixture/import.scss')\n    ])\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"scss respect user-defined string options.additionalData","suites":["SFC style preprocessors"],"updatePoint":{"line":317,"column":63},"line":317,"code":"  test('scss respect user-defined string options.additionalData', () => {\n    const res = compileStyle({\n      preprocessOptions: {\n        additionalData: `\n          @mixin square($size) {\n            width: $size;\n            height: $size;\n          }`\n      },\n      source: `\n        .square {\n          @include square(100px);\n        }\n      `,\n      filename: path.resolve(__dirname, './fixture/test.scss'),\n      id: '',\n      preprocessLang: 'scss'\n    })\n\n    expect(res.errors.length).toBe(0)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"scss respect user-defined function options.additionalData","suites":["SFC style preprocessors"],"updatePoint":{"line":339,"column":65},"line":339,"code":"  test('scss respect user-defined function options.additionalData', () => {\n    const source = `\n        .square {\n          @include square(100px);\n        }\n      `\n    const filename = path.resolve(__dirname, './fixture/test.scss')\n    const res = compileStyle({\n      preprocessOptions: {\n        additionalData: (s: string, f: string) => {\n          expect(s).toBe(source)\n          expect(f).toBe(filename)\n          return `\n          @mixin square($size) {\n            width: $size;\n            height: $size;\n          }`\n        }\n      },\n      source,\n      filename,\n      id: '',\n      preprocessLang: 'scss'\n    })\n\n    expect(res.errors.length).toBe(0)\n  })","file":"compileStyle.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should work","suites":[],"updatePoint":{"line":14,"column":17},"line":14,"code":"test('should work', () => {\n  const source = `<div><p>{{ render }}</p></div>`\n\n  const result = compile({ filename: 'example.vue', source })\n\n  expect(result.errors.length).toBe(0)\n  expect(result.source).toBe(source)\n  // should expose render fn\n  expect(result.code).toMatch(`export function render(`)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should work with style comment","suites":[],"updatePoint":{"line":26,"column":36},"line":26,"code":"test('should work with style comment', () => {\n  const source = `\n  <div style=\"\n    /* nothing */\n    width: 300px;\n    height: 100px/* nothing */\n    \">{{ render }}</div>\n  `\n\n  const result = compile({ filename: 'example.vue', source })\n  expect(result.errors.length).toBe(0)\n  expect(result.source).toBe(source)\n  expect(result.code).toMatch(`{\"width\":\"300px\",\"height\":\"100px\"}`)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"preprocess pug","suites":[],"updatePoint":{"line":41,"column":20},"line":41,"code":"test('preprocess pug', () => {\n  const template = parse(\n    `\n<template lang=\"pug\">\nbody\n  h1 Pug Examples\n  div.container\n    p Cool Pug example!\n</template>\n`,\n    { filename: 'example.vue', sourceMap: true }\n  ).descriptor.template as SFCTemplateBlock\n\n  const result = compile({\n    filename: 'example.vue',\n    source: template.content,\n    preprocessLang: template.lang\n  })\n\n  expect(result.errors.length).toBe(0)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"warn missing preprocessor","suites":[],"updatePoint":{"line":63,"column":31},"line":63,"code":"test('warn missing preprocessor', () => {\n  const template = parse(`<template lang=\"unknownLang\">hi</template>\\n`, {\n    filename: 'example.vue',\n    sourceMap: true\n  }).descriptor.template as SFCTemplateBlock\n\n  const result = compile({\n    filename: 'example.vue',\n    source: template.content,\n    preprocessLang: template.lang\n  })\n\n  expect(result.errors.length).toBe(1)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform asset url options","suites":[],"updatePoint":{"line":78,"column":33},"line":78,"code":"test('transform asset url options', () => {\n  const input = { source: `<foo bar=\"~baz\"/>`, filename: 'example.vue' }\n  // Object option\n  const { code: code1 } = compile({\n    ...input,\n    transformAssetUrls: {\n      tags: { foo: ['bar'] }\n    }\n  })\n  expect(code1).toMatch(`import _imports_0 from 'baz'\\n`)\n\n  // legacy object option (direct tags config)\n  const { code: code2 } = compile({\n    ...input,\n    transformAssetUrls: {\n      foo: ['bar']\n    }\n  })\n  expect(code2).toMatch(`import _imports_0 from 'baz'\\n`)\n\n  // false option\n  const { code: code3 } = compile({\n    ...input,\n    transformAssetUrls: false\n  })\n  expect(code3).not.toMatch(`import _imports_0 from 'baz'\\n`)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"source map","suites":[],"updatePoint":{"line":106,"column":16},"line":106,"code":"test('source map', () => {\n  const template = parse(\n    `\n<template>\n  <div><p>{{ render }}</p></div>\n</template>\n`,\n    { filename: 'example.vue', sourceMap: true }\n  ).descriptor.template as SFCTemplateBlock\n\n  const result = compile({\n    filename: 'example.vue',\n    source: template.content\n  })\n\n  expect(result.map).toMatchSnapshot()\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"template errors","suites":[],"updatePoint":{"line":124,"column":21},"line":124,"code":"test('template errors', () => {\n  const result = compile({\n    filename: 'example.vue',\n    source: `<div :foo\n      :bar=\"a[\" v-model=\"baz\"/>`\n  })\n  expect(result.errors).toMatchSnapshot()\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"preprocessor errors","suites":[],"updatePoint":{"line":133,"column":25},"line":133,"code":"test('preprocessor errors', () => {\n  const template = parse(\n    `\n<template lang=\"pug\">\n  div(class='class)\n</template>\n`,\n    { filename: 'example.vue', sourceMap: true }\n  ).descriptor.template as SFCTemplateBlock\n\n  const result = compile({\n    filename: 'example.vue',\n    source: template.content,\n    preprocessLang: template.lang\n  })\n\n  expect(result.errors.length).toBe(1)\n  const message = result.errors[0].toString()\n  expect(message).toMatch(`Error: example.vue:3:1`)\n  expect(message).toMatch(\n    `The end of the string reached with no closing bracket ) found.`\n  )\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should generate the correct imports expression","suites":[],"updatePoint":{"line":158,"column":52},"line":158,"code":"test('should generate the correct imports expression', () => {\n  const { code } = compile({\n    filename: 'example.vue',\n    source: `\n      <img src=\"./foo.svg\"/>\n      <Comp>\n        <img src=\"./bar.svg\"/>\n      </Comp>\n    `,\n    ssr: true\n  })\n  expect(code).toMatch(`_ssrRenderAttr(\\\"src\\\", _imports_1)`)\n  expect(code).toMatch(`_createVNode(\\\"img\\\", { src: _imports_1 })`)\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not hoist srcset URLs in SSR mode","suites":[],"updatePoint":{"line":174,"column":46},"line":174,"code":"test('should not hoist srcset URLs in SSR mode', () => {\n  const { code } = compile({\n    filename: 'example.vue',\n    source: `\n    <picture>\n      <source srcset=\"./img/foo.svg\"/>\n      <img src=\"./img/foo.svg\"/>\n    </picture>\n    <router-link>\n      <picture>\n        <source srcset=\"./img/bar.svg\"/>\n        <img src=\"./img/bar.svg\"/>\n      </picture>\n    </router-link>\n    `,\n    ssr: true\n  })\n  expect(code).toMatchSnapshot()\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"dynamic v-on + static v-on should merged","suites":[],"updatePoint":{"line":195,"column":46},"line":195,"code":"test('dynamic v-on + static v-on should merged', () => {\n  const source = `<input @blur=\"onBlur\" @[validateEvent]=\"onValidateEvent\">`\n\n  const result = compile({ filename: 'example.vue', source })\n\n  expect(result.code).toMatchSnapshot()\n})","file":"compileTemplate.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"generating correct code for nested paths","suites":["CSS vars injection"],"updatePoint":{"line":5,"column":48},"line":5,"code":"  test('generating correct code for nested paths', () => {\n    const { content } = compileSFCScript(\n      `<script>const a = 1</script>\\n` +\n        `<style>div{\n          color: v-bind(color);\n          font-size: v-bind('font.size');\n        }</style>`\n    )\n    expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"${mockId}-color\": (_ctx.color),\n  \"${mockId}-font\\\\.size\": (_ctx.font.size)\n})`)\n    assertCode(content)\n  })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ normal <script> binding analysis","suites":["CSS vars injection"],"updatePoint":{"line":20,"column":43},"line":20,"code":"  test('w/ normal <script> binding analysis', () => {\n    const { content } = compileSFCScript(\n      `<script>\n      export default {\n        setup() {\n          return {\n            size: ref('100px')\n          }\n        }\n      }\n      </script>\\n` +\n        `<style>\n          div {\n            font-size: v-bind(size);\n          }\n        </style>`\n    )\n    expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"${mockId}-size\": (_ctx.size)\n})`)\n    expect(content).toMatch(`import { useCssVars as _useCssVars } from 'vue'`)\n    assertCode(content)\n  })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ <script setup> binding analysis","suites":["CSS vars injection"],"updatePoint":{"line":44,"column":42},"line":44,"code":"  test('w/ <script setup> binding analysis', () => {\n    const { content } = compileSFCScript(\n      `<script setup>\n        import { defineProps, ref } from 'vue'\n        const color = 'red'\n        const size = ref('10px')\n        defineProps({\n          foo: String\n        })\n        </script>\\n` +\n        `<style>\n          div {\n            color: v-bind(color);\n            font-size: v-bind(size);\n            border: v-bind(foo);\n          }\n        </style>`\n    )\n    // should handle:\n    // 1. local const bindings\n    // 2. local potential ref bindings\n    // 3. props bindings (analyzed)\n    expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"${mockId}-color\": (color),\n  \"${mockId}-size\": (size.value),\n  \"${mockId}-foo\": (__props.foo)\n})`)\n    expect(content).toMatch(\n      `import { useCssVars as _useCssVars, unref as _unref } from 'vue'`\n    )\n    assertCode(content)\n  })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should rewrite CSS vars in compileStyle","suites":["CSS vars injection"],"updatePoint":{"line":77,"column":47},"line":77,"code":"  test('should rewrite CSS vars in compileStyle', () => {\n    const { code } = compileStyle({\n      source: `.foo {\n        color: v-bind(color);\n        font-size: v-bind('font.size');\n\n        font-weight: v-bind(_);\n        font-size: v-bind(1-);\n        font-family: v-bind();\n      }`,\n      filename: 'test.css',\n      id: 'data-v-test'\n    })\n    expect(code).toMatchInlineSnapshot(`\n      \".foo {\n              color: var(--test-color);\n              font-size: var(--test-font\\\\\\\\.size);\n\n              font-weight: var(--test-_);\n              font-size: var(--test-1-);\n              font-family: var(--test-);\n      }\"\n    `)\n  })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"prod mode","suites":["CSS vars injection"],"updatePoint":{"line":102,"column":17},"line":102,"code":"  test('prod mode', () => {\n    const { content } = compileSFCScript(\n      `<script>const a = 1</script>\\n` +\n        `<style>div{\n          color: v-bind(color);\n          font-size: v-bind('font.size');\n        }</style>`,\n      { isProd: true }\n    )\n    expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"4003f1a6\": (_ctx.color),\n  \"41b6490a\": (_ctx.font.size)\n}))}`)\n\n    const { code } = compileStyle({\n      source: `.foo {\n        color: v-bind(color);\n        font-size: v-bind('font.size');\n      }`,\n      filename: 'test.css',\n      id: mockId,\n      isProd: true\n    })\n    expect(code).toMatchInlineSnapshot(`\n      \".foo {\n              color: var(--4003f1a6);\n              font-size: var(--41b6490a);\n      }\"\n    `)\n  })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> w/ no default export","suites":["CSS vars injection","codegen"],"updatePoint":{"line":134,"column":39},"line":134,"code":"    test('<script> w/ no default export', () => {\n      assertCode(\n        compileSFCScript(\n          `<script>const a = 1</script>\\n` +\n            `<style>div{ color: v-bind(color); }</style>`\n        ).content\n      )\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> w/ default export","suites":["CSS vars injection","codegen"],"updatePoint":{"line":143,"column":36},"line":143,"code":"    test('<script> w/ default export', () => {\n      assertCode(\n        compileSFCScript(\n          `<script>export default { setup() {} }</script>\\n` +\n            `<style>div{ color: v-bind(color); }</style>`\n        ).content\n      )\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"<script> w/ default export in strings/comments","suites":["CSS vars injection","codegen"],"updatePoint":{"line":152,"column":56},"line":152,"code":"    test('<script> w/ default export in strings/comments', () => {\n      assertCode(\n        compileSFCScript(\n          `<script>\n          // export default {}\n          export default {}\n        </script>\\n` + `<style>div{ color: v-bind(color); }</style>`\n        ).content\n      )\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ <script setup>","suites":["CSS vars injection","codegen"],"updatePoint":{"line":163,"column":27},"line":163,"code":"    test('w/ <script setup>', () => {\n      assertCode(\n        compileSFCScript(\n          `<script setup>const color = 'red'</script>\\n` +\n            `<style>div{ color: v-bind(color); }</style>`\n        ).content\n      )\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should ignore comments","suites":["CSS vars injection","codegen"],"updatePoint":{"line":173,"column":32},"line":173,"code":"    test('should ignore comments', () => {\n      const { content } = compileSFCScript(\n        `<script setup>const color = 'red';const width = 100</script>\\n` +\n          `<style>\n            /* comment **/\n            div{ /* color: v-bind(color); */ width:20; }\n            div{ width: v-bind(width); }\n            /* comment */\n          </style>`\n      )\n\n      expect(content).not.toMatch(`\"${mockId}-color\": (color)`)\n      expect(content).toMatch(`\"${mockId}-width\": (width)`)\n      assertCode(content)\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ <script setup> using the same var multiple times","suites":["CSS vars injection","codegen"],"updatePoint":{"line":189,"column":61},"line":189,"code":"    test('w/ <script setup> using the same var multiple times', () => {\n      const { content } = compileSFCScript(\n        `<script setup>\n        const color = 'red'\n        </script>\\n` +\n          `<style>\n          div {\n            color: v-bind(color);\n          }\n          p {\n            color: v-bind(color);\n          }\n        </style>`\n      )\n      // color should only be injected once, even if it is twice in style\n      expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"${mockId}-color\": (color)\n})`)\n      assertCode(content)\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should work with w/ complex expression","suites":["CSS vars injection","codegen"],"updatePoint":{"line":210,"column":48},"line":210,"code":"    test('should work with w/ complex expression', () => {\n      const { content } = compileSFCScript(\n        `<script setup>\n        let a = 100\n        let b = 200\n        let foo = 300\n        </script>\\n` +\n          `<style>\n          p{\n            width: calc(v-bind(foo) - 3px);\n            height: calc(v-bind('foo') - 3px);\n            top: calc(v-bind(foo + 'px') - 3px);\n          }\n          div {\n            color: v-bind((a + b) / 2 + 'px' );\n          }\n          div {\n            color: v-bind    ((a + b) / 2 + 'px' );\n          }\n          p {\n            color: v-bind(((a + b)) / (2 * a));\n          }\n        </style>`\n      )\n      expect(content).toMatch(`_useCssVars(_ctx => ({\n  \"${mockId}-foo\": (_unref(foo)),\n  \"${mockId}-foo\\\\ \\\\+\\\\ \\\\'px\\\\'\": (_unref(foo) + 'px'),\n  \"${mockId}-\\\\(a\\\\ \\\\+\\\\ b\\\\)\\\\ \\\\/\\\\ 2\\\\ \\\\+\\\\ \\\\'px\\\\'\": ((_unref(a) + _unref(b)) / 2 + 'px'),\n  \"${mockId}-\\\\(\\\\(a\\\\ \\\\+\\\\ b\\\\)\\\\)\\\\ \\\\/\\\\ \\\\(2\\\\ \\\\*\\\\ a\\\\)\": (((_unref(a) + _unref(b))) / (2 * _unref(a)))\n}))`)\n      assertCode(content)\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should be able to parse incomplete expressions","suites":["CSS vars injection","codegen"],"updatePoint":{"line":244,"column":56},"line":244,"code":"    test('should be able to parse incomplete expressions', () => {\n      const {\n        descriptor: { cssVars }\n      } = parse(\n        `<script setup>let xxx = 1</script>\n        <style scoped>\n        label {\n          font-weight: v-bind(\"count.toString(\");\n          font-weight: v-bind(xxx);\n        }\n        </style>`\n      )\n      expect(cssVars).toMatchObject([`count.toString(`, `xxx`])\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"It should correctly parse the case where there is no space after the script tag","suites":["CSS vars injection","codegen"],"updatePoint":{"line":260,"column":89},"line":260,"code":"    test('It should correctly parse the case where there is no space after the script tag', () => {\n      const { content } = compileSFCScript(\n        `<script setup>import { ref as _ref } from 'vue';\n                let background = _ref('red')\n             </script>\n             <style>\n             label {\n               background: v-bind(background);\n             }\n             </style>`\n      )\n      expect(content).toMatch(\n        `export default {\\n  setup(__props, { expose: __expose }) {\\n  __expose();\\n\\n_useCssVars(_ctx => ({\\n  \"xxxxxxxx-background\": (_unref(background))\\n}))`\n      )\n    })","file":"cssVars.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"style block","suites":["compiler:sfc","source map"],"updatePoint":{"line":7,"column":21},"line":7,"code":"    test('style block', () => {\n      // Padding determines how many blank lines will there be before the style block\n      const padding = Math.round(Math.random() * 10)\n      const style = parse(\n        `${'\\n'.repeat(padding)}<style>\\n.color {\\n color: red;\\n }\\n</style>\\n`\n      ).descriptor.styles[0]\n\n      expect(style.map).not.toBeUndefined()\n\n      const consumer = new SourceMapConsumer(style.map!)\n      consumer.eachMapping(mapping => {\n        expect(mapping.originalLine - mapping.generatedLine).toBe(padding)\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"script block","suites":["compiler:sfc","source map"],"updatePoint":{"line":22,"column":22},"line":22,"code":"    test('script block', () => {\n      // Padding determines how many blank lines will there be before the style block\n      const padding = Math.round(Math.random() * 10)\n      const script = parse(\n        `${'\\n'.repeat(padding)}<script>\\nconsole.log(1)\\n }\\n</script>\\n`\n      ).descriptor.script\n\n      expect(script!.map).not.toBeUndefined()\n\n      const consumer = new SourceMapConsumer(script!.map!)\n      consumer.eachMapping(mapping => {\n        expect(mapping.originalLine - mapping.generatedLine).toBe(padding)\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"custom block","suites":["compiler:sfc","source map"],"updatePoint":{"line":37,"column":22},"line":37,"code":"    test('custom block', () => {\n      const padding = Math.round(Math.random() * 10)\n      const custom = parse(\n        `${'\\n'.repeat(padding)}<i18n>\\n{\\n  \"greeting\": \"hello\"\\n}\\n</i18n>\\n`\n      ).descriptor.customBlocks[0]\n\n      expect(custom!.map).not.toBeUndefined()\n\n      const consumer = new SourceMapConsumer(custom!.map!)\n      consumer.eachMapping(mapping => {\n        expect(mapping.originalLine - mapping.generatedLine).toBe(padding)\n      })\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"pad content","suites":["compiler:sfc","source map"],"updatePoint":{"line":52,"column":19},"line":52,"code":"  test('pad content', () => {\n    const content = `\n<template>\n<div></div>\n</template>\n<script>\nexport default {}\n</script>\n<style>\nh1 { color: red }\n</style>\n<i18n>\n{ \"greeting\": \"hello\" }\n</i18n>\n`\n    const padFalse = parse(content.trim(), { pad: false }).descriptor\n    expect(padFalse.template!.content).toBe('\\n<div></div>\\n')\n    expect(padFalse.script!.content).toBe('\\nexport default {}\\n')\n    expect(padFalse.styles[0].content).toBe('\\nh1 { color: red }\\n')\n    expect(padFalse.customBlocks[0].content).toBe('\\n{ \"greeting\": \"hello\" }\\n')\n\n    const padTrue = parse(content.trim(), { pad: true }).descriptor\n    expect(padTrue.script!.content).toBe(\n      Array(3 + 1).join('//\\n') + '\\nexport default {}\\n'\n    )\n    expect(padTrue.styles[0].content).toBe(\n      Array(6 + 1).join('\\n') + '\\nh1 { color: red }\\n'\n    )\n    expect(padTrue.customBlocks[0].content).toBe(\n      Array(9 + 1).join('\\n') + '\\n{ \"greeting\": \"hello\" }\\n'\n    )\n\n    const padLine = parse(content.trim(), { pad: 'line' }).descriptor\n    expect(padLine.script!.content).toBe(\n      Array(3 + 1).join('//\\n') + '\\nexport default {}\\n'\n    )\n    expect(padLine.styles[0].content).toBe(\n      Array(6 + 1).join('\\n') + '\\nh1 { color: red }\\n'\n    )\n    expect(padLine.customBlocks[0].content).toBe(\n      Array(9 + 1).join('\\n') + '\\n{ \"greeting\": \"hello\" }\\n'\n    )\n\n    const padSpace = parse(content.trim(), { pad: 'space' }).descriptor\n    expect(padSpace.script!.content).toBe(\n      `<template>\\n<div></div>\\n</template>\\n<script>`.replace(/./g, ' ') +\n        '\\nexport default {}\\n'\n    )\n    expect(padSpace.styles[0].content).toBe(\n      `<template>\\n<div></div>\\n</template>\\n<script>\\nexport default {}\\n</script>\\n<style>`.replace(\n        /./g,\n        ' '\n      ) + '\\nh1 { color: red }\\n'\n    )\n    expect(padSpace.customBlocks[0].content).toBe(\n      `<template>\\n<div></div>\\n</template>\\n<script>\\nexport default {}\\n</script>\\n<style>\\nh1 { color: red }\\n</style>\\n<i18n>`.replace(\n        /./g,\n        ' '\n      ) + '\\n{ \"greeting\": \"hello\" }\\n'\n    )\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should parse correct range for root level self closing tag","suites":["compiler:sfc","source map"],"updatePoint":{"line":114,"column":66},"line":114,"code":"  test('should parse correct range for root level self closing tag', () => {\n    const content = `\\n  <div/>\\n`\n    const { descriptor } = parse(`<template>${content}</template>`)\n    expect(descriptor.template).toBeTruthy()\n    expect(descriptor.template!.content).toBe(content)\n    expect(descriptor.template!.loc).toMatchObject({\n      start: { line: 1, column: 11, offset: 10 },\n      end: {\n        line: 3,\n        column: 1,\n        offset: 10 + content.length\n      },\n      source: content\n    })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should parse correct range for blocks with no content (self closing)","suites":["compiler:sfc","source map"],"updatePoint":{"line":130,"column":76},"line":130,"code":"  test('should parse correct range for blocks with no content (self closing)', () => {\n    const { descriptor } = parse(`<template/>`)\n    expect(descriptor.template).toBeTruthy()\n    expect(descriptor.template!.content).toBeFalsy()\n    expect(descriptor.template!.loc).toMatchObject({\n      start: { line: 1, column: 1, offset: 0 },\n      end: { line: 1, column: 1, offset: 0 },\n      source: ''\n    })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should parse correct range for blocks with no content (explicit)","suites":["compiler:sfc","source map"],"updatePoint":{"line":141,"column":72},"line":141,"code":"  test('should parse correct range for blocks with no content (explicit)', () => {\n    const { descriptor } = parse(`<template></template>`)\n    expect(descriptor.template).toBeTruthy()\n    expect(descriptor.template!.content).toBeFalsy()\n    expect(descriptor.template!.loc).toMatchObject({\n      start: { line: 1, column: 11, offset: 10 },\n      end: { line: 1, column: 11, offset: 10 },\n      source: ''\n    })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should ignore other nodes with no content","suites":["compiler:sfc","source map"],"updatePoint":{"line":152,"column":49},"line":152,"code":"  test('should ignore other nodes with no content', () => {\n    expect(parse(`<script/>`).descriptor.script).toBe(null)\n    expect(parse(`<script> \\n\\t  </script>`).descriptor.script).toBe(null)\n    expect(parse(`<style/>`).descriptor.styles.length).toBe(0)\n    expect(parse(`<style> \\n\\t </style>`).descriptor.styles.length).toBe(0)\n    expect(parse(`<custom/>`).descriptor.customBlocks.length).toBe(0)\n    expect(\n      parse(`<custom> \\n\\t </custom>`).descriptor.customBlocks.length\n    ).toBe(0)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"handle empty nodes with src attribute","suites":["compiler:sfc","source map"],"updatePoint":{"line":163,"column":45},"line":163,"code":"  test('handle empty nodes with src attribute', () => {\n    const { descriptor } = parse(`<script src=\"com\"/>`)\n    expect(descriptor.script).toBeTruthy()\n    expect(descriptor.script!.content).toBeFalsy()\n    expect(descriptor.script!.attrs['src']).toBe('com')\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"ignoreEmpty: false","suites":["compiler:sfc","source map"],"updatePoint":{"line":170,"column":26},"line":170,"code":"  test('ignoreEmpty: false', () => {\n    const { descriptor } = parse(\n      `<script></script>\\n<script setup>\\n</script>`,\n      {\n        ignoreEmpty: false\n      }\n    )\n    expect(descriptor.script).toBeTruthy()\n    expect(descriptor.script!.loc).toMatchObject({\n      source: '',\n      start: { line: 1, column: 9, offset: 8 },\n      end: { line: 1, column: 9, offset: 8 }\n    })\n\n    expect(descriptor.scriptSetup).toBeTruthy()\n    expect(descriptor.scriptSetup!.loc).toMatchObject({\n      source: '\\n',\n      start: { line: 2, column: 15, offset: 32 },\n      end: { line: 3, column: 1, offset: 33 }\n    })\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"nested templates","suites":["compiler:sfc","source map"],"updatePoint":{"line":192,"column":24},"line":192,"code":"  test('nested templates', () => {\n    const content = `\n    <template v-if=\"ok\">ok</template>\n    <div><div></div></div>\n    `\n    const { descriptor } = parse(`<template>${content}</template>`)\n    expect(descriptor.template!.content).toBe(content)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"treat empty lang attribute as the html","suites":["compiler:sfc","source map"],"updatePoint":{"line":201,"column":46},"line":201,"code":"  test('treat empty lang attribute as the html', () => {\n    const content = `<div><template v-if=\"ok\">ok</template></div>`\n    const { descriptor, errors } = parse(\n      `<template lang=\"\">${content}</template>`\n    )\n    expect(descriptor.template!.content).toBe(content)\n    expect(errors.length).toBe(0)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"alternative template lang should be treated as plain text","suites":["compiler:sfc","source map"],"updatePoint":{"line":211,"column":65},"line":211,"code":"  test('alternative template lang should be treated as plain text', () => {\n    const content = `p(v-if=\"1 < 2\") test`\n    const { descriptor, errors } = parse(\n      `<template lang=\"pug\">` + content + `</template>`\n    )\n    expect(errors.length).toBe(0)\n    expect(descriptor.template!.content).toBe(content)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"div lang should not be treated as plain text","suites":["compiler:sfc","source map"],"updatePoint":{"line":221,"column":52},"line":221,"code":"  test('div lang should not be treated as plain text', () => {\n    const { errors } = parse(`\n    <template lang=\"pug\">\n      <div lang=\"\">\n        <div></div>\n      </div>\n    </template>\n    `)\n    expect(errors.length).toBe(0)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"slotted detection","suites":["compiler:sfc","source map"],"updatePoint":{"line":232,"column":25},"line":232,"code":"  test('slotted detection', async () => {\n    expect(parse(`<template>hi</template>`).descriptor.slotted).toBe(false)\n    expect(\n      parse(`<template>hi</template><style>h1{color:red;}</style>`).descriptor\n        .slotted\n    ).toBe(false)\n    expect(\n      parse(\n        `<template>hi</template><style scoped>:slotted(h1){color:red;}</style>`\n      ).descriptor.slotted\n    ).toBe(true)\n    expect(\n      parse(\n        `<template>hi</template><style scoped>::v-slotted(h1){color:red;}</style>`\n      ).descriptor.slotted\n    ).toBe(true)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"error tolerance","suites":["compiler:sfc","source map"],"updatePoint":{"line":250,"column":23},"line":250,"code":"  test('error tolerance', () => {\n    const { errors } = parse(`<template>`)\n    expect(errors.length).toBe(1)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should parse as DOM by default","suites":["compiler:sfc","source map"],"updatePoint":{"line":255,"column":38},"line":255,"code":"  test('should parse as DOM by default', () => {\n    const { errors } = parse(`<template><input></template>`)\n    expect(errors.length).toBe(0)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"custom compiler","suites":["compiler:sfc","source map"],"updatePoint":{"line":260,"column":23},"line":260,"code":"  test('custom compiler', () => {\n    const { errors } = parse(`<template><input></template>`, {\n      compiler: {\n        parse: baseParse,\n        compile: baseCompile\n      }\n    })\n    expect(errors.length).toBe(1)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"treat custom blocks as raw text","suites":["compiler:sfc","source map"],"updatePoint":{"line":270,"column":39},"line":270,"code":"  test('treat custom blocks as raw text', () => {\n    const { errors, descriptor } = parse(\n      `<template><input></template><foo> <-& </foo>`\n    )\n    expect(errors.length).toBe(0)\n    expect(descriptor.customBlocks[0].content).toBe(` <-& `)\n  })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should only allow single template element","suites":["compiler:sfc","warnings"],"updatePoint":{"line":283,"column":51},"line":283,"code":"    test('should only allow single template element', () => {\n      assertWarning(\n        parse(`<template><div/></template><template><div/></template>`).errors,\n        `Single file component can contain only one <template> element`\n      )\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should only allow single script element","suites":["compiler:sfc","warnings"],"updatePoint":{"line":290,"column":49},"line":290,"code":"    test('should only allow single script element', () => {\n      assertWarning(\n        parse(`<script>console.log(1)</script><script>console.log(1)</script>`)\n          .errors,\n        `Single file component can contain only one <script> element`\n      )\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should only allow single script setup element","suites":["compiler:sfc","warnings"],"updatePoint":{"line":298,"column":55},"line":298,"code":"    test('should only allow single script setup element', () => {\n      assertWarning(\n        parse(\n          `<script setup>console.log(1)</script><script setup>console.log(1)</script>`\n        ).errors,\n        `Single file component can contain only one <script setup> element`\n      )\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not warn script & script setup","suites":["compiler:sfc","warnings"],"updatePoint":{"line":307,"column":47},"line":307,"code":"    test('should not warn script & script setup', () => {\n      expect(\n        parse(\n          `<script setup>console.log(1)</script><script>console.log(1)</script>`\n        ).errors.length\n      ).toBe(0)\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should throw error if no <template> or <script> is present","suites":["compiler:sfc","warnings"],"updatePoint":{"line":316,"column":68},"line":316,"code":"    test('should throw error if no <template> or <script> is present', () => {\n      assertWarning(\n        parse(`import { ref } from 'vue'`).errors,\n        `At least one <template> or <script> is required in a single file component`\n      )\n    })","file":"parse.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"without export default","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":4,"column":30},"line":4,"code":"  test('without export default', () => {\n    expect(rewriteDefault(`export const a = {}`, 'script'))\n      .toMatchInlineSnapshot(`\n      \"export const a = {}\n      const script = {}\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"rewrite export default","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":12,"column":30},"line":12,"code":"  test('rewrite export default', () => {\n    expect(\n      rewriteDefault(`export  default {}`, 'script')\n    ).toMatchInlineSnapshot(`\"const script = {}\"`)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"rewrite variable value default","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":18,"column":38},"line":18,"code":"  test('rewrite variable value default', () => {\n    expect(rewriteDefault(`export const foo = 'default'`, 'script'))\n      .toMatchInlineSnapshot(`\n      \"export const foo = 'default'\n      const script = {}\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"rewrite export named default","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":26,"column":36},"line":26,"code":"  test('rewrite export named default', () => {\n    expect(\n      rewriteDefault(\n        `const a = 1 \\n export { a as b, a as default, a as c}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const a = 1 \n       export { a as b,  a as c}\n      const script = a\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `const a = 1 \\n export { a as b, a as default    , a as c}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const a = 1 \n       export { a as b,  a as c}\n      const script = a\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `const a = 1 \\n export { a as b } \\n export { a as default, a as c }`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const a = 1 \n       export { a as b } \n       export {  a as c }\n      const script = a\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"w/ comments","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":62,"column":19},"line":62,"code":"  test('w/ comments', async () => {\n    expect(rewriteDefault(`// export default\\nexport default {}`, 'script'))\n      .toMatchInlineSnapshot(`\n      \"// export default\n      const script = {}\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export named default multiline","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":70,"column":38},"line":70,"code":"  test('export named default multiline', () => {\n    expect(\n      rewriteDefault(`let App = {}\\n export {\\nApp as default\\n}`, '_sfc_main')\n    ).toMatchInlineSnapshot(`\n      \"let App = {}\n       export {\n\n      }\n      const _sfc_main = App\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export named default multiline /w comments","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":82,"column":50},"line":82,"code":"  test('export named default multiline /w comments', () => {\n    expect(\n      rewriteDefault(\n        `const a = 1 \\n export {\\n a as b,\\n a as default,\\n a as c}\\n` +\n          `// export { myFunction as default }`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const a = 1 \n       export {\n       a as b,\n       \n       a as c}\n      // export { myFunction as default }\n      const script = a\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `const a = 1 \\n export {\\n a as b,\\n a as default      ,\\n a as c}\\n` +\n          `// export { myFunction as default }`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const a = 1 \n       export {\n       a as b,\n       \n       a as c}\n      // export { myFunction as default }\n      const script = a\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export { default } from '...'","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":116,"column":37},"line":116,"code":"  test(`export { default } from '...'`, async () => {\n    expect(\n      rewriteDefault(`export { default, foo } from './index.js'`, 'script')\n    ).toMatchInlineSnapshot(`\n      \"import { default as __VUE_DEFAULT__ } from './index.js'\n      export {  foo } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(`export { default    , foo } from './index.js'`, 'script')\n    ).toMatchInlineSnapshot(`\n      \"import { default as __VUE_DEFAULT__ } from './index.js'\n      export {  foo } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(`export { foo,   default } from './index.js'`, 'script')\n    ).toMatchInlineSnapshot(`\n      \"import { default as __VUE_DEFAULT__ } from './index.js'\n      export { foo,    } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `export { foo as default, bar } from './index.js'`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"import { foo as __VUE_DEFAULT__ } from './index.js'\n      export {  bar } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `export { foo as default     , bar } from './index.js'`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"import { foo as __VUE_DEFAULT__ } from './index.js'\n      export {  bar } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `export { bar,   foo as default } from './index.js'`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"import { foo as __VUE_DEFAULT__ } from './index.js'\n      export { bar,    } from './index.js'\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `export { foo as default } from './index.js' \\n const foo = 1`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"import { foo as __VUE_DEFAULT__ } from './index.js'\n      export {  } from './index.js' \n       const foo = 1\n      const script = __VUE_DEFAULT__\"\n    `)\n\n    expect(\n      rewriteDefault(\n        `const a = 1 \\nexport { a as default } from 'xxx'`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"import { a as __VUE_DEFAULT__ } from 'xxx'\n      const a = 1 \n      export {  } from 'xxx'\n      const script = __VUE_DEFAULT__\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export default class","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":199,"column":28},"line":199,"code":"  test('export default class', async () => {\n    expect(rewriteDefault(`export default class Foo {}`, 'script'))\n      .toMatchInlineSnapshot(`\n        \" class Foo {}\n        const script = Foo\"\n      `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export default class w/ comments","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":207,"column":40},"line":207,"code":"  test('export default class w/ comments', async () => {\n    expect(\n      rewriteDefault(`// export default\\nexport default class Foo {}`, 'script')\n    ).toMatchInlineSnapshot(`\n      \"// export default\n       class Foo {}\n      const script = Foo\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export default class w/ comments 2","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":217,"column":42},"line":217,"code":"  test('export default class w/ comments 2', async () => {\n    expect(\n      rewriteDefault(\n        `export default {}\\n` + `// export default class Foo {}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const script = {}\n      // export default class Foo {}\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"export default class w/ comments 3","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":229,"column":42},"line":229,"code":"  test('export default class w/ comments 3', async () => {\n    expect(\n      rewriteDefault(\n        `/*\\nexport default class Foo {}*/\\n` + `export default class Bar {}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"/*\n      export default class Foo {}*/\n       class Bar {}\n      const script = Bar\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"@Component\nexport default class","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":243,"column":40},"line":243,"code":"  test('@Component\\nexport default class', async () => {\n    expect(\n      rewriteDefault(`@Component\\nexport default class Foo {}`, 'script', [\n        'decorators-legacy'\n      ])\n    ).toMatchInlineSnapshot(`\n      \"@Component class Foo {}\n      const script = Foo\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"@Component\nexport default class w/ comments","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":254,"column":52},"line":254,"code":"  test('@Component\\nexport default class w/ comments', async () => {\n    expect(\n      rewriteDefault(\n        `// export default\\n@Component\\nexport default class Foo {}`,\n        'script',\n        ['decorators-legacy']\n      )\n    ).toMatchInlineSnapshot(`\n      \"// export default\n      @Component class Foo {}\n      const script = Foo\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"@Component\nexport default class w/ comments 2","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":268,"column":54},"line":268,"code":"  test('@Component\\nexport default class w/ comments 2', async () => {\n    expect(\n      rewriteDefault(\n        `export default {}\\n` + `// @Component\\n// export default class Foo {}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"const script = {}\n      // @Component\n      // export default class Foo {}\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"@Component\nexport default class w/ comments 3","suites":["compiler sfc: rewriteDefault"],"updatePoint":{"line":281,"column":54},"line":281,"code":"  test('@Component\\nexport default class w/ comments 3', async () => {\n    expect(\n      rewriteDefault(\n        `/*\\n@Component\\nexport default class Foo {}*/\\n` +\n          `export default class Bar {}`,\n        'script'\n      )\n    ).toMatchInlineSnapshot(`\n      \"/*\n      @Component\n      export default class Foo {}*/\n       class Bar {}\n      const script = Bar\"\n    `)\n  })","file":"rewriteDefault.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform assetUrls","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":37,"column":27},"line":37,"code":"  test('transform assetUrls', () => {\n    const result = compileWithAssetUrls(`\n\t\t\t<img src=\"./logo.png\"/>\n\t\t\t<img src=\"~fixtures/logo.png\"/>\n\t\t\t<img src=\"~/fixtures/logo.png\"/>\n\t\t\t<img src=\"http://example.com/fixtures/logo.png\"/>\n\t\t\t<img src=\"//example.com/fixtures/logo.png\"/>\n\t\t\t<img src=\"/fixtures/logo.png\"/>\n\t\t\t<img src=\"data:image/png;base64,i\"/>\n\t\t`)\n\n    expect(result.code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"support uri fragment","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":54,"column":28},"line":54,"code":"  test('support uri fragment', () => {\n    const result = compileWithAssetUrls(\n      '<use href=\"~@svg/file.svg#fragment\"></use>' +\n        '<use href=\"~@svg/file.svg#fragment\"></use>',\n      {},\n      {\n        hoistStatic: true\n      }\n    )\n    expect(result.code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"support uri is empty","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":69,"column":28},"line":69,"code":"  test('support uri is empty', () => {\n    const result = compileWithAssetUrls('<use href=\"~\"></use>')\n\n    expect(result.code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"with explicit base","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":75,"column":26},"line":75,"code":"  test('with explicit base', () => {\n    const { code } = compileWithAssetUrls(\n      `<img src=\"./bar.png\"></img>` + // -> /foo/bar.png\n        `<img src=\"bar.png\"></img>` + // -> bar.png (untouched)\n        `<img src=\"~bar.png\"></img>` + // -> still converts to import\n        `<img src=\"@theme/bar.png\"></img>`, // -> still converts to import\n      {\n        base: '/foo'\n      }\n    )\n    expect(code).toMatch(`import _imports_0 from 'bar.png'`)\n    expect(code).toMatch(`import _imports_1 from '@theme/bar.png'`)\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"with includeAbsolute: true","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":90,"column":34},"line":90,"code":"  test('with includeAbsolute: true', () => {\n    const { code } = compileWithAssetUrls(\n      `<img src=\"./bar.png\"/>` +\n        `<img src=\"/bar.png\"/>` +\n        `<img src=\"https://foo.bar/baz.png\"/>` +\n        `<img src=\"//foo.bar/baz.png\"/>`,\n      {\n        includeAbsolute: true\n      }\n    )\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should not transform hash fragments","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":104,"column":43},"line":104,"code":"  test('should not transform hash fragments', () => {\n    const { code } = compileWithAssetUrls(\n      `<svg viewBox=\"0 0 10 10\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n        <defs>\n          <circle id=\"myCircle\" cx=\"0\" cy=\"0\" r=\"5\" />\n        </defs>\n        <use x=\"5\" y=\"5\" xlink:href=\"#myCircle\" />\n      </svg>`\n    )\n    // should not remove it\n    expect(code).toMatch(`\"xlink:href\": \"#myCircle\"`)\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow for full base URLs, with paths","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":117,"column":51},"line":117,"code":"  test('should allow for full base URLs, with paths', () => {\n    const { code } = compileWithAssetUrls(`<img src=\"./logo.png\" />`, {\n      base: 'http://localhost:3000/src/'\n    })\n\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow for full base URLs, without paths","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":125,"column":54},"line":125,"code":"  test('should allow for full base URLs, without paths', () => {\n    const { code } = compileWithAssetUrls(`<img src=\"./logo.png\" />`, {\n      base: 'http://localhost:3000'\n    })\n\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow for full base URLs, without port","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":133,"column":53},"line":133,"code":"  test('should allow for full base URLs, without port', () => {\n    const { code } = compileWithAssetUrls(`<img src=\"./logo.png\" />`, {\n      base: 'http://localhost'\n    })\n\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should allow for full base URLs, without protocol","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":141,"column":57},"line":141,"code":"  test('should allow for full base URLs, without protocol', () => {\n    const { code } = compileWithAssetUrls(`<img src=\"./logo.png\" />`, {\n      base: '//localhost'\n    })\n\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform with stringify","suites":["compiler sfc: transform asset url"],"updatePoint":{"line":149,"column":32},"line":149,"code":"  test('transform with stringify', () => {\n    const { code } = compileWithAssetUrls(\n      `<div>` +\n        `<img src=\"./bar.png\"/>` +\n        `<img src=\"/bar.png\"/>` +\n        `<img src=\"https://foo.bar/baz.png\"/>` +\n        `<img src=\"//foo.bar/baz.png\"/>` +\n        `<img src=\"./bar.png\"/>` +\n        `</div>`,\n      {\n        includeAbsolute: true\n      },\n      {\n        hoistStatic: true,\n        transformHoist: stringifyStatic\n      }\n    )\n    expect(code).toMatch(`_createStaticVNode`)\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformAssetUrl.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform srcset","suites":["compiler sfc: transform srcset"],"updatePoint":{"line":55,"column":24},"line":55,"code":"  test('transform srcset', () => {\n    expect(compileWithSrcset(src).code).toMatchSnapshot()\n  })","file":"templateTransformSrcset.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform srcset w/ base","suites":["compiler sfc: transform srcset"],"updatePoint":{"line":59,"column":32},"line":59,"code":"  test('transform srcset w/ base', () => {\n    expect(\n      compileWithSrcset(src, {\n        base: '/foo'\n      }).code\n    ).toMatchSnapshot()\n  })","file":"templateTransformSrcset.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform srcset w/ includeAbsolute: true","suites":["compiler sfc: transform srcset"],"updatePoint":{"line":67,"column":49},"line":67,"code":"  test('transform srcset w/ includeAbsolute: true', () => {\n    expect(\n      compileWithSrcset(src, {\n        includeAbsolute: true\n      }).code\n    ).toMatchSnapshot()\n  })","file":"templateTransformSrcset.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"transform srcset w/ stringify","suites":["compiler sfc: transform srcset"],"updatePoint":{"line":75,"column":37},"line":75,"code":"  test('transform srcset w/ stringify', () => {\n    const code = compileWithSrcset(\n      `<div>${src}</div>`,\n      {\n        includeAbsolute: true\n      },\n      {\n        hoistStatic: true,\n        transformHoist: stringifyStatic\n      }\n    ).code\n    expect(code).toMatch(`_createStaticVNode`)\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformSrcset.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"srcset w/ explicit base option","suites":["compiler sfc: transform srcset"],"updatePoint":{"line":90,"column":38},"line":90,"code":"  test('srcset w/ explicit base option', () => {\n    const code = compileWithSrcset(\n      `\n      <img srcset=\"@/logo.png, @/logo.png 2x\"/>\n      <img srcset=\"@/logo.png 1x, ./logo.png 2x\"/>\n    `,\n      { base: '/foo/' },\n      { hoistStatic: true }\n    ).code\n    expect(code).toMatchSnapshot()\n  })","file":"templateTransformSrcset.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when The first character of the string path is .","suites":["compiler sfc:templateUtils isRelativeUrl"],"updatePoint":{"line":8,"column":75},"line":8,"code":"  test('should return true when The first character of the string path is .', () => {\n    const url = './**.vue'\n    const result = isRelativeUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when The first character of the string path is ~","suites":["compiler sfc:templateUtils isRelativeUrl"],"updatePoint":{"line":14,"column":75},"line":14,"code":"  test('should return true when The first character of the string path is ~', () => {\n    const url = '~/xx.vue'\n    const result = isRelativeUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when The first character of the string path is @","suites":["compiler sfc:templateUtils isRelativeUrl"],"updatePoint":{"line":20,"column":75},"line":20,"code":"  test('should return true when The first character of the string path is @', () => {\n    const url = '@/xx.vue'\n    const result = isRelativeUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when String starts with http://","suites":["compiler sfc:templateUtils isExternalUrl"],"updatePoint":{"line":28,"column":58},"line":28,"code":"  test('should return true when String starts with http://', () => {\n    const url = 'http://vuejs.org/'\n    const result = isExternalUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when String starts with https://","suites":["compiler sfc:templateUtils isExternalUrl"],"updatePoint":{"line":34,"column":59},"line":34,"code":"  test('should return true when String starts with https://', () => {\n    const url = 'https://vuejs.org/'\n    const result = isExternalUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true when String starts with //","suites":["compiler sfc:templateUtils isExternalUrl"],"updatePoint":{"line":40,"column":53},"line":40,"code":"  test('should return true when String starts with //', () => {\n    const url = '//vuejs.org/'\n    const result = isExternalUrl(url)\n    expect(result).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true w/ hasn`t media type and encode","suites":["compiler sfc:templateUtils isDataUrl"],"updatePoint":{"line":48,"column":58},"line":48,"code":"  test('should return true w/ hasn`t media type and encode', () => {\n    expect(isDataUrl('data:,i')).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true w/ media type + encode","suites":["compiler sfc:templateUtils isDataUrl"],"updatePoint":{"line":52,"column":49},"line":52,"code":"  test('should return true w/ media type + encode', () => {\n    expect(isDataUrl('data:image/png;base64,i')).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"should return true w/ media type + hasn`t encode","suites":["compiler sfc:templateUtils isDataUrl"],"updatePoint":{"line":56,"column":56},"line":56,"code":"  test('should return true w/ media type + hasn`t encode', () => {\n    expect(isDataUrl('data:image/png,i')).toBe(true)\n  })","file":"templateUtils.spec.ts","skipped":false,"dir":"packages/compiler-sfc/__tests__"},{"name":"basic","suites":["ssr: components"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('basic', () => {\n    expect(compile(`<foo id=\"a\" :prop=\"b\" />`).code).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent, mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _push(_ssrRenderComponent(_component_foo, _mergeProps({\n          id: \\\\\"a\\\\\",\n          prop: _ctx.b\n        }, _attrs), null, _parent))\n      }\"\n    `)\n  })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"event listeners","suites":["ssr: components"],"updatePoint":{"line":21,"column":23},"line":21,"code":"  test('event listeners', () => {\n    expect(compile(`<foo @click=\"bar\" />`).code).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent, mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _push(_ssrRenderComponent(_component_foo, _mergeProps({ onClick: _ctx.bar }, _attrs), null, _parent))\n      }\"\n    `)\n  })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"dynamic component","suites":["ssr: components"],"updatePoint":{"line":34,"column":25},"line":34,"code":"  test('dynamic component', () => {\n    expect(compile(`<component is=\"foo\" prop=\"b\" />`).code)\n      .toMatchInlineSnapshot(`\n        \"const { resolveDynamicComponent: _resolveDynamicComponent, mergeProps: _mergeProps, createVNode: _createVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderVNode: _ssrRenderVNode } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderVNode(_push, _createVNode(_resolveDynamicComponent(\\\\\"foo\\\\\"), _mergeProps({ prop: \\\\\"b\\\\\" }, _attrs), null), _parent)\n        }\"\n      `)\n\n    expect(compile(`<component :is=\"foo\" prop=\"b\" />`).code)\n      .toMatchInlineSnapshot(`\n        \"const { resolveDynamicComponent: _resolveDynamicComponent, mergeProps: _mergeProps, createVNode: _createVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderVNode: _ssrRenderVNode } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderVNode(_push, _createVNode(_resolveDynamicComponent(_ctx.foo), _mergeProps({ prop: \\\\\"b\\\\\" }, _attrs), null), _parent)\n        }\"\n      `)\n  })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"implicit default slot","suites":["ssr: components","slots"],"updatePoint":{"line":57,"column":31},"line":57,"code":"    test('implicit default slot', () => {\n      expect(compile(`<foo>hello<div/></foo>`).code).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, createVNode: _createVNode, createTextVNode: _createTextVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, {\n            default: _withCtx((_, _push, _parent, _scopeId) => {\n              if (_push) {\n                _push(\\`hello<div\\${_scopeId}></div>\\`)\n              } else {\n                return [\n                  _createTextVNode(\\\\\"hello\\\\\"),\n                  _createVNode(\\\\\"div\\\\\")\n                ]\n              }\n            }),\n            _: 1 /* STABLE */\n          }, _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"explicit default slot","suites":["ssr: components","slots"],"updatePoint":{"line":82,"column":31},"line":82,"code":"    test('explicit default slot', () => {\n      expect(compile(`<foo v-slot=\"{ msg }\">{{ msg + outer }}</foo>`).code)\n        .toMatchInlineSnapshot(`\n          \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, toDisplayString: _toDisplayString, createTextVNode: _createTextVNode } = require(\\\\\"vue\\\\\")\n          const { ssrRenderComponent: _ssrRenderComponent, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n          return function ssrRender(_ctx, _push, _parent, _attrs) {\n            const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n            _push(_ssrRenderComponent(_component_foo, _attrs, {\n              default: _withCtx(({ msg }, _push, _parent, _scopeId) => {\n                if (_push) {\n                  _push(\\`\\${_ssrInterpolate(msg + _ctx.outer)}\\`)\n                } else {\n                  return [\n                    _createTextVNode(_toDisplayString(msg + _ctx.outer), 1 /* TEXT */)\n                  ]\n                }\n              }),\n              _: 1 /* STABLE */\n            }, _parent))\n          }\"\n        `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"empty attribute should not produce syntax error","suites":["ssr: components","slots"],"updatePoint":{"line":107,"column":57},"line":107,"code":"    test('empty attribute should not produce syntax error', () => {\n      // previously this would produce syntax error `default: _withCtx((, _push, ...)`\n      expect(compile(`<foo v-slot=\"\">foo</foo>`).code).not.toMatch(`(,`)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"named slots","suites":["ssr: components","slots"],"updatePoint":{"line":112,"column":21},"line":112,"code":"    test('named slots', () => {\n      expect(\n        compile(`<foo>\n        <template v-slot>foo</template>\n        <template v-slot:named>bar</template>\n      </foo>`).code\n      ).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, createTextVNode: _createTextVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, {\n            default: _withCtx((_, _push, _parent, _scopeId) => {\n              if (_push) {\n                _push(\\`foo\\`)\n              } else {\n                return [\n                  _createTextVNode(\\\\\"foo\\\\\")\n                ]\n              }\n            }),\n            named: _withCtx((_, _push, _parent, _scopeId) => {\n              if (_push) {\n                _push(\\`bar\\`)\n              } else {\n                return [\n                  _createTextVNode(\\\\\"bar\\\\\")\n                ]\n              }\n            }),\n            _: 1 /* STABLE */\n          }, _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-if slot","suites":["ssr: components","slots"],"updatePoint":{"line":150,"column":19},"line":150,"code":"    test('v-if slot', () => {\n      expect(\n        compile(`<foo>\n        <template v-slot:named v-if=\"ok\">foo</template>\n      </foo>`).code\n      ).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, createTextVNode: _createTextVNode, createSlots: _createSlots } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, _createSlots({ _: 2 /* DYNAMIC */ }, [\n            (_ctx.ok)\n              ? {\n                  name: \\\\\"named\\\\\",\n                  fn: _withCtx((_, _push, _parent, _scopeId) => {\n                    if (_push) {\n                      _push(\\`foo\\`)\n                    } else {\n                      return [\n                        _createTextVNode(\\\\\"foo\\\\\")\n                      ]\n                    }\n                  }),\n                  key: \\\\\"0\\\\\"\n                }\n              : undefined\n          ]), _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-for slot","suites":["ssr: components","slots"],"updatePoint":{"line":183,"column":20},"line":183,"code":"    test('v-for slot', () => {\n      expect(\n        compile(`<foo>\n        <template v-for=\"key in names\" v-slot:[key]=\"{ msg }\">{{ msg + key + bar }}</template>\n      </foo>`).code\n      ).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, toDisplayString: _toDisplayString, createTextVNode: _createTextVNode, renderList: _renderList, createSlots: _createSlots } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, _createSlots({ _: 2 /* DYNAMIC */ }, [\n            _renderList(_ctx.names, (key) => {\n              return {\n                name: key,\n                fn: _withCtx(({ msg }, _push, _parent, _scopeId) => {\n                  if (_push) {\n                    _push(\\`\\${_ssrInterpolate(msg + key + _ctx.bar)}\\`)\n                  } else {\n                    return [\n                      _createTextVNode(_toDisplayString(msg + _ctx.key + _ctx.bar), 1 /* TEXT */)\n                    ]\n                  }\n                })\n              }\n            })\n          ]), _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested transform scoping in vnode branch","suites":["ssr: components","slots"],"updatePoint":{"line":215,"column":50},"line":215,"code":"    test('nested transform scoping in vnode branch', () => {\n      expect(\n        compile(`<foo>\n        <template v-slot:foo=\"{ list }\">\n          <div v-if=\"ok\">\n            <span v-for=\"i in list\"></span>\n          </div>\n        </template>\n        <template v-slot:bar=\"{ ok }\">\n          <div v-if=\"ok\">\n            <span v-for=\"i in list\"></span>\n          </div>\n        </template>\n      </foo>`).code\n      ).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, renderList: _renderList, Fragment: _Fragment, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, {\n            foo: _withCtx(({ list }, _push, _parent, _scopeId) => {\n              if (_push) {\n                if (_ctx.ok) {\n                  _push(\\`<div\\${_scopeId}><!--[-->\\`)\n                  _ssrRenderList(list, (i) => {\n                    _push(\\`<span\\${_scopeId}></span>\\`)\n                  })\n                  _push(\\`<!--]--></div>\\`)\n                } else {\n                  _push(\\`<!---->\\`)\n                }\n              } else {\n                return [\n                  (_ctx.ok)\n                    ? (_openBlock(), _createBlock(\\\\\"div\\\\\", { key: 0 }, [\n                        (_openBlock(true), _createBlock(_Fragment, null, _renderList(list, (i) => {\n                          return (_openBlock(), _createBlock(\\\\\"span\\\\\"))\n                        }), 256 /* UNKEYED_FRAGMENT */))\n                      ]))\n                    : _createCommentVNode(\\\\\"v-if\\\\\", true)\n                ]\n              }\n            }),\n            bar: _withCtx(({ ok }, _push, _parent, _scopeId) => {\n              if (_push) {\n                if (ok) {\n                  _push(\\`<div\\${_scopeId}><!--[-->\\`)\n                  _ssrRenderList(_ctx.list, (i) => {\n                    _push(\\`<span\\${_scopeId}></span>\\`)\n                  })\n                  _push(\\`<!--]--></div>\\`)\n                } else {\n                  _push(\\`<!---->\\`)\n                }\n              } else {\n                return [\n                  ok\n                    ? (_openBlock(), _createBlock(\\\\\"div\\\\\", { key: 0 }, [\n                        (_openBlock(true), _createBlock(_Fragment, null, _renderList(_ctx.list, (i) => {\n                          return (_openBlock(), _createBlock(\\\\\"span\\\\\"))\n                        }), 256 /* UNKEYED_FRAGMENT */))\n                      ]))\n                    : _createCommentVNode(\\\\\"v-if\\\\\", true)\n                ]\n              }\n            }),\n            _: 1 /* STABLE */\n          }, _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"slot content with v-once","suites":["ssr: components","slots"],"updatePoint":{"line":290,"column":34},"line":290,"code":"    test('slot content with v-once', () => {\n      const { code } = compile(`<foo><bar v-once /></foo>`)\n      expect(code).not.toMatch(`_cache`)\n      expect(compile(`<foo><bar v-once /></foo>`).code).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, createVNode: _createVNode } = require(\\\\\"vue\\\\\")\n        const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n          const _component_bar = _resolveComponent(\\\\\"bar\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _attrs, {\n            default: _withCtx((_, _push, _parent, _scopeId) => {\n              if (_push) {\n                _push(_ssrRenderComponent(_component_bar, null, null, _parent, _scopeId))\n              } else {\n                return [\n                  _createVNode(_component_bar)\n                ]\n              }\n            }),\n            _: 1 /* STABLE */\n          }, _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"transition","suites":["ssr: components","slots","built-in fallthroughs"],"updatePoint":{"line":318,"column":22},"line":318,"code":"      test('transition', () => {\n        expect(compile(`<transition><div/></transition>`).code)\n          .toMatchInlineSnapshot(`\n            \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n            return function ssrRender(_ctx, _push, _parent, _attrs) {\n              _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n            }\"\n          `)\n      })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"keep-alive","suites":["ssr: components","slots","built-in fallthroughs"],"updatePoint":{"line":329,"column":22},"line":329,"code":"      test('keep-alive', () => {\n        expect(compile(`<keep-alive><foo/></keep-alive>`).code)\n          .toMatchInlineSnapshot(`\n            \"const { resolveComponent: _resolveComponent } = require(\\\\\"vue\\\\\")\n            const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n            return function ssrRender(_ctx, _push, _parent, _attrs) {\n              const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n              _push(_ssrRenderComponent(_component_foo, _attrs, null, _parent))\n            }\"\n          `)\n      })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should push marker string if is slot root","suites":["ssr: components","slots","built-in fallthroughs"],"updatePoint":{"line":344,"column":53},"line":344,"code":"      test('should push marker string if is slot root', () => {\n        expect(\n          compile(`<foo><transition><div v-if=\"false\"/></transition></foo>`)\n            .code\n        ).toMatchInlineSnapshot(`\n          \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, openBlock: _openBlock, createBlock: _createBlock, createCommentVNode: _createCommentVNode, Transition: _Transition, createVNode: _createVNode } = require(\\\\\"vue\\\\\")\n          const { ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n          return function ssrRender(_ctx, _push, _parent, _attrs) {\n            const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n            _push(_ssrRenderComponent(_component_foo, _attrs, {\n              default: _withCtx((_, _push, _parent, _scopeId) => {\n                if (_push) {\n                  _push(\\`\\`)\n                  if (false) {\n                    _push(\\`<div\\${_scopeId}></div>\\`)\n                  } else {\n                    _push(\\`<!---->\\`)\n                  }\n                } else {\n                  return [\n                    _createVNode(_Transition, null, {\n                      default: _withCtx(() => [\n                        false\n                          ? (_openBlock(), _createBlock(\\\\\"div\\\\\", { key: 0 }))\n                          : _createCommentVNode(\\\\\"v-if\\\\\", true)\n                      ]),\n                      _: 1 /* STABLE */\n                    })\n                  ]\n                }\n              }),\n              _: 1 /* STABLE */\n            }, _parent))\n          }\"\n        `)\n      })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: components","custom directive"],"updatePoint":{"line":386,"column":15},"line":386,"code":"    test('basic', () => {\n      expect(compile(`<foo v-xxx:x.y=\"z\" />`).code).toMatchInlineSnapshot(`\n        \"const { resolveComponent: _resolveComponent, resolveDirective: _resolveDirective, mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n        const { ssrGetDirectiveProps: _ssrGetDirectiveProps, ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n          const _directive_xxx = _resolveDirective(\\\\\"xxx\\\\\")\n\n          _push(_ssrRenderComponent(_component_foo, _mergeProps(_attrs, _ssrGetDirectiveProps(_ctx, _directive_xxx, _ctx.z, \\\\\"x\\\\\", { y: true })), null, _parent))\n        }\"\n      `)\n    })","file":"ssrComponent.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic elements","suites":["ssr: element"],"updatePoint":{"line":5,"column":22},"line":5,"code":"  test('basic elements', () => {\n    expect(getCompiledString(`<div></div>`)).toMatchInlineSnapshot(\n      `\"\\`<div></div>\\`\"`\n    )\n    expect(getCompiledString(`<div/>`)).toMatchInlineSnapshot(\n      `\"\\`<div></div>\\`\"`\n    )\n  })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested elements","suites":["ssr: element"],"updatePoint":{"line":14,"column":23},"line":14,"code":"  test('nested elements', () => {\n    expect(\n      getCompiledString(`<div><span></span><span></span></div>`)\n    ).toMatchInlineSnapshot(`\"\\`<div><span></span><span></span></div>\\`\"`)\n  })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"void element","suites":["ssr: element"],"updatePoint":{"line":20,"column":20},"line":20,"code":"  test('void element', () => {\n    expect(getCompiledString(`<input>`)).toMatchInlineSnapshot(`\"\\`<input>\\`\"`)\n  })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-html","suites":["ssr: element","children override"],"updatePoint":{"line":25,"column":16},"line":25,"code":"    test('v-html', () => {\n      expect(getCompiledString(`<div v-html=\"foo\"/>`)).toMatchInlineSnapshot(`\n        \"\\`<div>\\${\n            _ctx.foo\n          }</div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-text","suites":["ssr: element","children override"],"updatePoint":{"line":33,"column":16},"line":33,"code":"    test('v-text', () => {\n      expect(getCompiledString(`<div v-text=\"foo\"/>`)).toMatchInlineSnapshot(`\n        \"\\`<div>\\${\n            _ssrInterpolate(_ctx.foo)\n          }</div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<textarea> with dynamic value","suites":["ssr: element","children override"],"updatePoint":{"line":41,"column":39},"line":41,"code":"    test('<textarea> with dynamic value', () => {\n      expect(getCompiledString(`<textarea :value=\"foo\"/>`))\n        .toMatchInlineSnapshot(`\n        \"\\`<textarea>\\${\n            _ssrInterpolate(_ctx.foo)\n          }</textarea>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<textarea> with static value","suites":["ssr: element","children override"],"updatePoint":{"line":50,"column":38},"line":50,"code":"    test('<textarea> with static value', () => {\n      expect(\n        getCompiledString(`<textarea value=\"fo&gt;o\"/>`)\n      ).toMatchInlineSnapshot(`\"\\`<textarea>fo&gt;o</textarea>\\`\"`)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<textarea> with dynamic v-bind","suites":["ssr: element","children override"],"updatePoint":{"line":56,"column":40},"line":56,"code":"    test('<textarea> with dynamic v-bind', () => {\n      expect(compile(`<textarea v-bind=\"obj\">fallback</textarea>`).code)\n        .toMatchInlineSnapshot(`\n          \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n          const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n          return function ssrRender(_ctx, _push, _parent, _attrs) {\n            let _temp0\n\n            _push(\\`<textarea\\${\n              _ssrRenderAttrs(_temp0 = _mergeProps(_ctx.obj, _attrs), \\\\\"textarea\\\\\")\n            }>\\${\n              _ssrInterpolate((\\\\\"value\\\\\" in _temp0) ? _temp0.value : \\\\\"fallback\\\\\")\n            }</textarea>\\`)\n          }\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"multiple _ssrInterpolate at parent and child import dependency once","suites":["ssr: element","children override"],"updatePoint":{"line":74,"column":77},"line":74,"code":"    test('multiple _ssrInterpolate at parent and child import dependency once', () => {\n      expect(\n        compile(`<div>{{ hello }}<textarea v-bind=\"a\"></textarea></div>`).code\n      ).toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          let _temp0\n\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }>\\${\n            _ssrInterpolate(_ctx.hello)\n          }<textarea\\${\n            _ssrRenderAttrs(_temp0 = _ctx.a, \\\\\"textarea\\\\\")\n          }>\\${\n            _ssrInterpolate((\\\\\"value\\\\\" in _temp0) ? _temp0.value : \\\\\"\\\\\")\n          }</textarea></div>\\`)\n        }\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should pass tag to custom elements w/ dynamic v-bind","suites":["ssr: element","children override"],"updatePoint":{"line":96,"column":62},"line":96,"code":"    test('should pass tag to custom elements w/ dynamic v-bind', () => {\n      expect(\n        compile(`<my-foo v-bind=\"obj\"></my-foo>`, {\n          isCustomElement: () => true\n        }).code\n      ).toMatchInlineSnapshot(`\n        \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n        const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<my-foo\\${_ssrRenderAttrs(_mergeProps(_ctx.obj, _attrs), \\\\\"my-foo\\\\\")}></my-foo>\\`)\n        }\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static attrs","suites":["ssr: element","attrs"],"updatePoint":{"line":113,"column":22},"line":113,"code":"    test('static attrs', () => {\n      expect(\n        getCompiledString(`<div id=\"foo\" class=\"bar\"></div>`)\n      ).toMatchInlineSnapshot('\"`<div id=\\\\\"foo\\\\\" class=\\\\\"bar\\\\\"></div>`\"')\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"ignore static key/ref","suites":["ssr: element","attrs"],"updatePoint":{"line":119,"column":31},"line":119,"code":"    test('ignore static key/ref', () => {\n      expect(\n        getCompiledString(`<div key=\"1\" ref=\"el\"></div>`)\n      ).toMatchInlineSnapshot(`\"\\`<div></div>\\`\"`)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"ignore v-bind key/ref","suites":["ssr: element","attrs"],"updatePoint":{"line":125,"column":31},"line":125,"code":"    test('ignore v-bind key/ref', () => {\n      expect(\n        getCompiledString(`<div :key=\"1\" :ref=\"el\"></div>`)\n      ).toMatchInlineSnapshot(`\"\\`<div></div>\\`\"`)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:class","suites":["ssr: element","attrs"],"updatePoint":{"line":131,"column":22},"line":131,"code":"    test('v-bind:class', () => {\n      expect(getCompiledString(`<div id=\"foo\" :class=\"bar\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div id=\\\\\"foo\\\\\" class=\\\\\"\\${\n              _ssrRenderClass(_ctx.bar)\n            }\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static class + v-bind:class","suites":["ssr: element","attrs"],"updatePoint":{"line":140,"column":37},"line":140,"code":"    test('static class + v-bind:class', () => {\n      expect(getCompiledString(`<div class=\"foo\" :class=\"bar\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div class=\\\\\"\\${\n              _ssrRenderClass([_ctx.bar, \\\\\"foo\\\\\"])\n            }\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:class + static class","suites":["ssr: element","attrs"],"updatePoint":{"line":149,"column":37},"line":149,"code":"    test('v-bind:class + static class', () => {\n      expect(getCompiledString(`<div :class=\"bar\" class=\"foo\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div class=\\\\\"\\${\n              _ssrRenderClass([_ctx.bar, \\\\\"foo\\\\\"])\n            }\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:style","suites":["ssr: element","attrs"],"updatePoint":{"line":158,"column":22},"line":158,"code":"    test('v-bind:style', () => {\n      expect(getCompiledString(`<div id=\"foo\" :style=\"bar\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div id=\\\\\"foo\\\\\" style=\\\\\"\\${\n              _ssrRenderStyle(_ctx.bar)\n            }\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static style + v-bind:style","suites":["ssr: element","attrs"],"updatePoint":{"line":167,"column":37},"line":167,"code":"    test('static style + v-bind:style', () => {\n      expect(getCompiledString(`<div style=\"color:red;\" :style=\"bar\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div style=\\\\\"\\${\n              _ssrRenderStyle([{\\\\\"color\\\\\":\\\\\"red\\\\\"}, _ctx.bar])\n            }\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:arg (boolean)","suites":["ssr: element","attrs"],"updatePoint":{"line":176,"column":30},"line":176,"code":"    test('v-bind:arg (boolean)', () => {\n      expect(getCompiledString(`<input type=\"checkbox\" :checked=\"checked\">`))\n        .toMatchInlineSnapshot(`\n          \"\\`<input type=\\\\\"checkbox\\\\\"\\${\n              (_ssrIncludeBooleanAttr(_ctx.checked)) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n            }>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:arg (non-boolean)","suites":["ssr: element","attrs"],"updatePoint":{"line":185,"column":34},"line":185,"code":"    test('v-bind:arg (non-boolean)', () => {\n      expect(getCompiledString(`<div :id=\"id\" class=\"bar\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttr(\\\\\"id\\\\\", _ctx.id)\n            } class=\\\\\"bar\\\\\"></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind:[arg]","suites":["ssr: element","attrs"],"updatePoint":{"line":194,"column":22},"line":194,"code":"    test('v-bind:[arg]', () => {\n      expect(getCompiledString(`<div v-bind:[key]=\"value\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs({ [_ctx.key || \\\\\"\\\\\"]: _ctx.value })\n            }></div>\\`\"\n        `)\n\n      expect(getCompiledString(`<div class=\"foo\" v-bind:[key]=\"value\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs({\n                class: \\\\\"foo\\\\\",\n                [_ctx.key || \\\\\"\\\\\"]: _ctx.value\n              })\n            }></div>\\`\"\n        `)\n\n      expect(getCompiledString(`<div :id=\"id\" v-bind:[key]=\"value\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs({\n                id: _ctx.id,\n                [_ctx.key || \\\\\"\\\\\"]: _ctx.value\n              })\n            }></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-bind=\"obj\"","suites":["ssr: element","attrs"],"updatePoint":{"line":223,"column":22},"line":223,"code":"    test('v-bind=\"obj\"', () => {\n      expect(getCompiledString(`<div v-bind=\"obj\"></div>`))\n        .toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_ctx.obj)\n          }></div>\\`\"\n      `)\n\n      expect(getCompiledString(`<div class=\"foo\" v-bind=\"obj\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs(_mergeProps({ class: \\\\\"foo\\\\\" }, _ctx.obj))\n            }></div>\\`\"\n        `)\n\n      expect(getCompiledString(`<div :id=\"id\" v-bind=\"obj\"></div>`))\n        .toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_mergeProps({ id: _ctx.id }, _ctx.obj))\n          }></div>\\`\"\n      `)\n\n      // dynamic key + v-bind=\"object\"\n      expect(getCompiledString(`<div :[key]=\"id\" v-bind=\"obj\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs(_mergeProps({ [_ctx.key || \\\\\"\\\\\"]: _ctx.id }, _ctx.obj))\n            }></div>\\`\"\n        `)\n\n      // should merge class and :class\n      expect(getCompiledString(`<div class=\"a\" :class=\"b\" v-bind=\"obj\"></div>`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs(_mergeProps({\n                class: [\\\\\"a\\\\\", _ctx.b]\n              }, _ctx.obj))\n            }></div>\\`\"\n        `)\n\n      // should merge style and :style\n      expect(\n        getCompiledString(\n          `<div style=\"color:red;\" :style=\"b\" v-bind=\"obj\"></div>`\n        )\n      ).toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_mergeProps({\n              style: [{\\\\\"color\\\\\":\\\\\"red\\\\\"}, _ctx.b]\n            }, _ctx.obj))\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should ignore v-on","suites":["ssr: element","attrs"],"updatePoint":{"line":277,"column":28},"line":277,"code":"    test('should ignore v-on', () => {\n      expect(\n        getCompiledString(`<div id=\"foo\" @click=\"bar\"/>`)\n      ).toMatchInlineSnapshot('\"`<div id=\\\\\"foo\\\\\"></div>`\"')\n      expect(\n        getCompiledString(`<div id=\"foo\" v-on=\"bar\"/>`)\n      ).toMatchInlineSnapshot('\"`<div id=\\\\\"foo\\\\\"></div>`\"')\n      expect(getCompiledString(`<div v-bind=\"foo\" v-on=\"bar\"/>`))\n        .toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_ctx.foo)\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"custom dir","suites":["ssr: element","attrs"],"updatePoint":{"line":292,"column":20},"line":292,"code":"    test('custom dir', () => {\n      expect(getCompiledString(`<div v-xxx:x.y=\"z\" />`)).toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_ssrGetDirectiveProps(_ctx, _directive_xxx, _ctx.z, \\\\\"x\\\\\", { y: true }))\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"custom dir with normal attrs","suites":["ssr: element","attrs"],"updatePoint":{"line":300,"column":38},"line":300,"code":"    test('custom dir with normal attrs', () => {\n      expect(getCompiledString(`<div class=\"foo\" v-xxx />`))\n        .toMatchInlineSnapshot(`\n          \"\\`<div\\${\n              _ssrRenderAttrs(_mergeProps({ class: \\\\\"foo\\\\\" }, _ssrGetDirectiveProps(_ctx, _directive_xxx)))\n            }></div>\\`\"\n        `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"custom dir with v-bind","suites":["ssr: element","attrs"],"updatePoint":{"line":309,"column":32},"line":309,"code":"    test('custom dir with v-bind', () => {\n      expect(getCompiledString(`<div :title=\"foo\" :class=\"bar\" v-xxx />`))\n        .toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_mergeProps({\n              title: _ctx.foo,\n              class: _ctx.bar\n            }, _ssrGetDirectiveProps(_ctx, _directive_xxx)))\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"custom dir with object v-bind","suites":["ssr: element","attrs"],"updatePoint":{"line":321,"column":39},"line":321,"code":"    test('custom dir with object v-bind', () => {\n      expect(getCompiledString(`<div v-bind=\"x\" v-xxx />`))\n        .toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_mergeProps(_ctx.x, _ssrGetDirectiveProps(_ctx, _directive_xxx)))\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"custom dir with object v-bind + normal bindings","suites":["ssr: element","attrs"],"updatePoint":{"line":330,"column":57},"line":330,"code":"    test('custom dir with object v-bind + normal bindings', () => {\n      expect(\n        getCompiledString(`<div v-bind=\"x\" class=\"foo\" v-xxx title=\"bar\" />`)\n      ).toMatchInlineSnapshot(`\n        \"\\`<div\\${\n            _ssrRenderAttrs(_mergeProps(_ctx.x, {\n              class: \\\\\"foo\\\\\",\n              title: \\\\\"bar\\\\\"\n            }, _ssrGetDirectiveProps(_ctx, _directive_xxx)))\n          }></div>\\`\"\n      `)\n    })","file":"ssrElement.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: attrs fallthrough"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('basic', () => {\n    expect(compile(`<div/>`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n      }\"\n    `)\n  })","file":"ssrFallthroughAttrs.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with comments","suites":["ssr: attrs fallthrough"],"updatePoint":{"line":14,"column":21},"line":14,"code":"  test('with comments', () => {\n    expect(compile(`<!--!--><div/>`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[--><!--!--><div\\${_ssrRenderAttrs(_attrs)}></div><!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrFallthroughAttrs.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should not inject to non-single-root if branches","suites":["ssr: attrs fallthrough"],"updatePoint":{"line":25,"column":56},"line":25,"code":"  test('should not inject to non-single-root if branches', () => {\n    expect(compile(`<div v-if=\"true\"/><div/>`).code).toMatchInlineSnapshot(`\n      \"\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        if (true) {\n          _push(\\`<div></div>\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n        _push(\\`<div></div><!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrFallthroughAttrs.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"fallthrough component content (root with comments)","suites":["ssr: attrs fallthrough"],"updatePoint":{"line":40,"column":58},"line":40,"code":"  test('fallthrough component content (root with comments)', () => {\n    expect(compile(`<!--root--><transition><div/></transition>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<!--[--><!--root--><div\\${_ssrRenderAttrs(_attrs)}></div><!--]-->\\`)\n        }\"\n      `)\n  })","file":"ssrFallthroughAttrs.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should not inject to fallthrough component content if not root","suites":["ssr: attrs fallthrough"],"updatePoint":{"line":51,"column":70},"line":51,"code":"  test('should not inject to fallthrough component content if not root', () => {\n    expect(compile(`<div/><transition><div/></transition>`).code)\n      .toMatchInlineSnapshot(`\n              \"\n              return function ssrRender(_ctx, _push, _parent, _attrs) {\n                _push(\\`<!--[--><div></div><div></div><!--]-->\\`)\n              }\"\n          `)\n  })","file":"ssrFallthroughAttrs.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: inject <style vars>"],"updatePoint":{"line":5,"column":13},"line":5,"code":"  test('basic', () => {\n    expect(\n      compile(`<div/>`, {\n        ssrCssVars: `{ color }`\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _cssVars = { style: { color: _ctx.color }}\n        _push(\\`<div\\${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}></div>\\`)\n      }\"\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"fragment","suites":["ssr: inject <style vars>"],"updatePoint":{"line":21,"column":16},"line":21,"code":"  test('fragment', () => {\n    expect(\n      compile(`<div/><div/>`, {\n        ssrCssVars: `{ color }`\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _cssVars = { style: { color: _ctx.color }}\n        _push(\\`<!--[--><div\\${\n          _ssrRenderAttrs(_cssVars)\n        }></div><div\\${\n          _ssrRenderAttrs(_cssVars)\n        }></div><!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"passing on to components","suites":["ssr: inject <style vars>"],"updatePoint":{"line":40,"column":32},"line":40,"code":"  test('passing on to components', () => {\n    expect(\n      compile(`<div/><foo/>`, {\n        ssrCssVars: `{ color }`\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs, ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        const _cssVars = { style: { color: _ctx.color }}\n        _push(\\`<!--[--><div\\${_ssrRenderAttrs(_cssVars)}></div>\\`)\n        _push(_ssrRenderComponent(_component_foo, _cssVars, null, _parent))\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-if branches","suites":["ssr: inject <style vars>"],"updatePoint":{"line":60,"column":21},"line":60,"code":"  test('v-if branches', () => {\n    expect(\n      compile(`<div v-if=\"ok\"/><template v-else><div/><div/></template>`, {\n        ssrCssVars: `{ color }`\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _cssVars = { style: { color: _ctx.color }}\n        if (_ctx.ok) {\n          _push(\\`<div\\${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}></div>\\`)\n        } else {\n          _push(\\`<!--[--><div\\${\n            _ssrRenderAttrs(_cssVars)\n          }></div><div\\${\n            _ssrRenderAttrs(_cssVars)\n          }></div><!--]-->\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"w/ suspense","suites":["ssr: inject <style vars>"],"updatePoint":{"line":84,"column":19},"line":84,"code":"  test('w/ suspense', () => {\n    expect(\n      compile(\n        `<Suspense>\n          <div>ok</div>\n          <template #fallback>\n            <div>fallback</div>\n          </template>\n        </Suspense>`,\n        {\n          ssrCssVars: `{ color }`\n        }\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { withCtx: _withCtx } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs, ssrRenderSuspense: _ssrRenderSuspense } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _cssVars = { style: { color: _ctx.color }}\n        _ssrRenderSuspense(_push, {\n          fallback: () => {\n            _push(\\`<div\\${_ssrRenderAttrs(_cssVars)}>fallback</div>\\`)\n          },\n          default: () => {\n            _push(\\`<div\\${_ssrRenderAttrs(_cssVars)}>ok</div>\\`)\n          },\n          _: 1 /* STABLE */\n        })\n      }\"\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"inject helpers","suites":["ssr: inject <style vars>"],"updatePoint":{"line":116,"column":22},"line":116,"code":"  test('inject helpers', () => {\n    const result = compile(`<div/>`, {\n      inline: true,\n      bindingMetadata: { dynamic: BindingTypes.SETUP_MAYBE_REF },\n      ssrCssVars: '{ \"--hash\": (dynamic) }'\n    })\n\n    expect(result.code).toMatchInlineSnapshot(`\n      \"(_ctx, _push, _parent, _attrs) => {\n        const _cssVars = { style: { \\\\\"--hash\\\\\": (_unref(dynamic)) }}\n        _push(\\`<div\\${_ssrRenderAttrs(_mergeProps(_attrs, _cssVars))}></div>\\`)\n      }\"\n    `)\n    expect(result.ast.helpers).toMatchInlineSnapshot(`\n      Set {\n        Symbol(mergeProps),\n        Symbol(unref),\n      }\n    `)\n  })","file":"ssrInjectCssVars.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"should work","suites":["ssr compile: teleport"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  test('should work', () => {\n    expect(compile(`<teleport :to=\"target\"><div/></teleport>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderTeleport: _ssrRenderTeleport } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderTeleport(_push, (_push) => {\n            _push(\\`<div></div>\\`)\n          }, _ctx.target, false, _parent)\n        }\"\n      `)\n  })","file":"ssrPortal.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"disabled prop handling","suites":["ssr compile: teleport"],"updatePoint":{"line":17,"column":30},"line":17,"code":"  test('disabled prop handling', () => {\n    expect(compile(`<teleport :to=\"target\" disabled><div/></teleport>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderTeleport: _ssrRenderTeleport } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderTeleport(_push, (_push) => {\n            _push(\\`<div></div>\\`)\n          }, _ctx.target, true, _parent)\n        }\"\n      `)\n\n    expect(\n      compile(`<teleport :to=\"target\" :disabled=\"foo\"><div/></teleport>`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderTeleport: _ssrRenderTeleport } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderTeleport(_push, (_push) => {\n          _push(\\`<div></div>\\`)\n        }, _ctx.target, _ctx.foo, _parent)\n      }\"\n    `)\n  })","file":"ssrPortal.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: scopeId"],"updatePoint":{"line":6,"column":13},"line":6,"code":"  test('basic', () => {\n    expect(\n      compile(`<div><span>hello</span></div>`, {\n        scopeId,\n        mode: 'module'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"import { ssrRenderAttrs as _ssrRenderAttrs } from \\\\\"vue/server-renderer\\\\\"\n\n      export function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${_ssrRenderAttrs(_attrs)} data-v-xxxxxxx><span data-v-xxxxxxx>hello</span></div>\\`)\n      }\"\n    `)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"inside slots (only text)","suites":["ssr: scopeId"],"updatePoint":{"line":21,"column":32},"line":21,"code":"  test('inside slots (only text)', () => {\n    // should have no branching inside slot\n    expect(\n      compile(`<foo>foo</foo>`, {\n        scopeId,\n        mode: 'module'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"import { resolveComponent as _resolveComponent, withCtx as _withCtx, createTextVNode as _createTextVNode } from \\\\\"vue\\\\\"\n      import { ssrRenderComponent as _ssrRenderComponent } from \\\\\"vue/server-renderer\\\\\"\n\n      export function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _push(_ssrRenderComponent(_component_foo, _attrs, {\n          default: _withCtx((_, _push, _parent, _scopeId) => {\n            if (_push) {\n              _push(\\`foo\\`)\n            } else {\n              return [\n                _createTextVNode(\\\\\"foo\\\\\")\n              ]\n            }\n          }),\n          _: 1 /* STABLE */\n        }, _parent))\n      }\"\n    `)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"inside slots (with elements)","suites":["ssr: scopeId"],"updatePoint":{"line":51,"column":36},"line":51,"code":"  test('inside slots (with elements)', () => {\n    expect(\n      compile(`<foo><span>hello</span></foo>`, {\n        scopeId,\n        mode: 'module'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"import { resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode } from \\\\\"vue\\\\\"\n      import { ssrRenderComponent as _ssrRenderComponent } from \\\\\"vue/server-renderer\\\\\"\n\n      export function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _push(_ssrRenderComponent(_component_foo, _attrs, {\n          default: _withCtx((_, _push, _parent, _scopeId) => {\n            if (_push) {\n              _push(\\`<span data-v-xxxxxxx\\${_scopeId}>hello</span>\\`)\n            } else {\n              return [\n                _createVNode(\\\\\"span\\\\\", null, \\\\\"hello\\\\\")\n              ]\n            }\n          }),\n          _: 1 /* STABLE */\n        }, _parent))\n      }\"\n    `)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested slots","suites":["ssr: scopeId"],"updatePoint":{"line":80,"column":20},"line":80,"code":"  test('nested slots', () => {\n    expect(\n      compile(`<foo><span>hello</span><bar><span/></bar></foo>`, {\n        scopeId,\n        mode: 'module'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"import { resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode } from \\\\\"vue\\\\\"\n      import { ssrRenderComponent as _ssrRenderComponent } from \\\\\"vue/server-renderer\\\\\"\n\n      export function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n        const _component_bar = _resolveComponent(\\\\\"bar\\\\\")\n\n        _push(_ssrRenderComponent(_component_foo, _attrs, {\n          default: _withCtx((_, _push, _parent, _scopeId) => {\n            if (_push) {\n              _push(\\`<span data-v-xxxxxxx\\${_scopeId}>hello</span>\\`)\n              _push(_ssrRenderComponent(_component_bar, null, {\n                default: _withCtx((_, _push, _parent, _scopeId) => {\n                  if (_push) {\n                    _push(\\`<span data-v-xxxxxxx\\${_scopeId}></span>\\`)\n                  } else {\n                    return [\n                      _createVNode(\\\\\"span\\\\\")\n                    ]\n                  }\n                }),\n                _: 1 /* STABLE */\n              }, _parent, _scopeId))\n            } else {\n              return [\n                _createVNode(\\\\\"span\\\\\", null, \\\\\"hello\\\\\"),\n                _createVNode(_component_bar, null, {\n                  default: _withCtx(() => [\n                    _createVNode(\\\\\"span\\\\\")\n                  ]),\n                  _: 1 /* STABLE */\n                })\n              ]\n            }\n          }),\n          _: 1 /* STABLE */\n        }, _parent))\n      }\"\n    `)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: <slot>"],"updatePoint":{"line":5,"column":13},"line":5,"code":"  test('basic', () => {\n    expect(compile(`<slot/>`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlot(_ctx.$slots, \\\\\"default\\\\\", {}, null, _push, _parent)\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with name","suites":["ssr: <slot>"],"updatePoint":{"line":15,"column":17},"line":15,"code":"  test('with name', () => {\n    expect(compile(`<slot name=\"foo\" />`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlot(_ctx.$slots, \\\\\"foo\\\\\", {}, null, _push, _parent)\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with dynamic name","suites":["ssr: <slot>"],"updatePoint":{"line":25,"column":25},"line":25,"code":"  test('with dynamic name', () => {\n    expect(compile(`<slot :name=\"bar.baz\" />`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlot(_ctx.$slots, _ctx.bar.baz, {}, null, _push, _parent)\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with props","suites":["ssr: <slot>"],"updatePoint":{"line":35,"column":18},"line":35,"code":"  test('with props', () => {\n    expect(compile(`<slot name=\"foo\" :p=\"1\" bar=\"2\" />`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderSlot(_ctx.$slots, \\\\\"foo\\\\\", {\n            p: 1,\n            bar: \\\\\"2\\\\\"\n          }, null, _push, _parent)\n        }\"\n      `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with fallback","suites":["ssr: <slot>"],"updatePoint":{"line":49,"column":21},"line":49,"code":"  test('with fallback', () => {\n    expect(compile(`<slot>some {{ fallback }} content</slot>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderSlot: _ssrRenderSlot, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _ssrRenderSlot(_ctx.$slots, \\\\\"default\\\\\", {}, () => {\n            _push(\\`some \\${_ssrInterpolate(_ctx.fallback)} content\\`)\n          }, _push, _parent)\n        }\"\n      `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with scopeId","suites":["ssr: <slot>"],"updatePoint":{"line":62,"column":20},"line":62,"code":"  test('with scopeId', async () => {\n    expect(\n      compile(`<slot/>`, {\n        scopeId: 'hello'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlot(_ctx.$slots, \\\\\"default\\\\\", {}, null, _push, _parent, \\\\\"hello-s\\\\\")\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with scopeId + slotted:false","suites":["ssr: <slot>"],"updatePoint":{"line":76,"column":36},"line":76,"code":"  test('with scopeId + slotted:false', async () => {\n    expect(\n      compile(`<slot/>`, {\n        scopeId: 'hello',\n        slotted: false\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlot: _ssrRenderSlot } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlot(_ctx.$slots, \\\\\"default\\\\\", {}, null, _push, _parent)\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with forwarded scopeId","suites":["ssr: <slot>"],"updatePoint":{"line":91,"column":30},"line":91,"code":"  test('with forwarded scopeId', async () => {\n    expect(\n      compile(`<Comp><slot/></Comp>`, {\n        scopeId: 'hello'\n      }).code\n    ).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent, withCtx: _withCtx, renderSlot: _renderSlot } = require(\\\\\"vue\\\\\")\n      const { ssrRenderSlot: _ssrRenderSlot, ssrRenderComponent: _ssrRenderComponent } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_Comp = _resolveComponent(\\\\\"Comp\\\\\")\n\n        _push(_ssrRenderComponent(_component_Comp, _attrs, {\n          default: _withCtx((_, _push, _parent, _scopeId) => {\n            if (_push) {\n              _ssrRenderSlot(_ctx.$slots, \\\\\"default\\\\\", {}, null, _push, _parent, \\\\\"hello-s\\\\\" + _scopeId)\n            } else {\n              return [\n                _renderSlot(_ctx.$slots, \\\\\"default\\\\\")\n              ]\n            }\n          }),\n          _: 3 /* FORWARDED */\n        }, _parent))\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"inside transition","suites":["ssr: <slot>"],"updatePoint":{"line":119,"column":25},"line":119,"code":"  test('inside transition', () => {\n    const { code } = compile(`<transition><slot/></transition>`)\n    expect(code).toMatch(ssrHelpers[SSR_RENDER_SLOT_INNER])\n    expect(code).toMatchInlineSnapshot(`\n      \"const { ssrRenderSlotInner: _ssrRenderSlotInner } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _ssrRenderSlotInner(_ctx.$slots, \\\\\"default\\\\\", {}, null, _push, _parent, null, true)\n      }\"\n    `)\n  })","file":"ssrSlotOutlet.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"implicit default","suites":["ssr compile: suspense"],"updatePoint":{"line":4,"column":24},"line":4,"code":"  test('implicit default', () => {\n    expect(compile(`<suspense><foo/></suspense>`).code).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent, withCtx: _withCtx } = require(\\\\\"vue\\\\\")\n      const { ssrRenderComponent: _ssrRenderComponent, ssrRenderSuspense: _ssrRenderSuspense } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _ssrRenderSuspense(_push, {\n          default: () => {\n            _push(_ssrRenderComponent(_component_foo, null, null, _parent))\n          },\n          _: 1 /* STABLE */\n        })\n      }\"\n    `)\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"explicit slots","suites":["ssr compile: suspense"],"updatePoint":{"line":22,"column":22},"line":22,"code":"  test('explicit slots', () => {\n    expect(\n      compile(`<suspense>\n      <template #default>\n        <foo/>\n      </template>\n      <template #fallback>\n        loading...\n      </template>\n    </suspense>`).code\n    ).toMatchInlineSnapshot(`\n      \"const { resolveComponent: _resolveComponent, withCtx: _withCtx } = require(\\\\\"vue\\\\\")\n      const { ssrRenderComponent: _ssrRenderComponent, ssrRenderSuspense: _ssrRenderSuspense } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        const _component_foo = _resolveComponent(\\\\\"foo\\\\\")\n\n        _ssrRenderSuspense(_push, {\n          default: () => {\n            _push(_ssrRenderComponent(_component_foo, null, null, _parent))\n          },\n          fallback: () => {\n            _push(\\` loading... \\`)\n          },\n          _: 1 /* STABLE */\n        })\n      }\"\n    `)\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static text","suites":["ssr: text"],"updatePoint":{"line":5,"column":19},"line":5,"code":"  test('static text', () => {\n    expect(getCompiledString(`foo`)).toMatchInlineSnapshot(`\"\\`foo\\`\"`)\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static text with template string special chars","suites":["ssr: text"],"updatePoint":{"line":9,"column":54},"line":9,"code":"  test('static text with template string special chars', () => {\n    expect(getCompiledString(`\\`\\${foo}\\``)).toMatchInlineSnapshot(\n      '\"`\\\\\\\\`\\\\\\\\${foo}\\\\\\\\``\"'\n    )\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static text with char escape","suites":["ssr: text"],"updatePoint":{"line":15,"column":36},"line":15,"code":"  test('static text with char escape', () => {\n    // the desired generated code should be `\\\\\\$foo`\n    // snapshot -> inline snapshot goes through two escapes\n    // so that makes a total of 3 * 2 * 2 = 12 back slashes\n    expect(getCompiledString(`\\\\$foo`)).toMatchInlineSnapshot(\n      '\"`\\\\\\\\\\\\\\\\\\\\\\\\$foo`\"'\n    )\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"comments","suites":["ssr: text"],"updatePoint":{"line":24,"column":16},"line":24,"code":"  test('comments', () => {\n    expect(getCompiledString(`<!--bar-->`)).toMatchInlineSnapshot(\n      `\"\\`<!--bar-->\\`\"`\n    )\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"static text escape","suites":["ssr: text"],"updatePoint":{"line":30,"column":26},"line":30,"code":"  test('static text escape', () => {\n    expect(getCompiledString(`&lt;foo&gt;`)).toMatchInlineSnapshot(\n      `\"\\`&lt;foo&gt;\\`\"`\n    )\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested elements with static text","suites":["ssr: text"],"updatePoint":{"line":36,"column":40},"line":36,"code":"  test('nested elements with static text', () => {\n    expect(\n      getCompiledString(`<div><span>hello</span><span>bye</span></div>`)\n    ).toMatchInlineSnapshot(\n      `\"\\`<div><span>hello</span><span>bye</span></div>\\`\"`\n    )\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"interpolation","suites":["ssr: text"],"updatePoint":{"line":44,"column":21},"line":44,"code":"  test('interpolation', () => {\n    expect(compile(`foo {{ bar }} baz`).code).toMatchInlineSnapshot(`\n      \"const { ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`foo \\${_ssrInterpolate(_ctx.bar)} baz\\`)\n      }\"\n    `)\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested elements with interpolation","suites":["ssr: text"],"updatePoint":{"line":54,"column":42},"line":54,"code":"  test('nested elements with interpolation', () => {\n    expect(\n      compile(`<div><span>{{ foo }} bar</span><span>baz {{ qux }}</span></div>`)\n        .code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><span>\\${\n          _ssrInterpolate(_ctx.foo)\n        } bar</span><span>baz \\${\n          _ssrInterpolate(_ctx.qux)\n        }</span></div>\\`)\n      }\"\n    `)\n  })","file":"ssrText.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["transition-group"],"updatePoint":{"line":6,"column":13},"line":6,"code":"  test('basic', () => {\n    expect(\n      compile(`<transition-group><div v-for=\"i in list\"/></transition-group>`)\n        .code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrTransitionGroup.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with static tag","suites":["transition-group"],"updatePoint":{"line":23,"column":23},"line":23,"code":"  test('with static tag', () => {\n    expect(\n      compile(\n        `<transition-group tag=\"ul\"><div v-for=\"i in list\"/></transition-group>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<ul\\${_ssrRenderAttrs(_attrs)}>\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        _push(\\`</ul>\\`)\n      }\"\n    `)\n  })","file":"ssrTransitionGroup.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with dynamic tag","suites":["transition-group"],"updatePoint":{"line":41,"column":24},"line":41,"code":"  test('with dynamic tag', () => {\n    expect(\n      compile(\n        `<transition-group :tag=\"someTag\"><div v-for=\"i in list\"/></transition-group>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<\\${\n          _ctx.someTag\n        }\\${\n          _ssrRenderAttrs(_attrs)\n        }>\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        _push(\\`</\\${_ctx.someTag}>\\`)\n      }\"\n    `)\n  })","file":"ssrTransitionGroup.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with multi fragments children","suites":["transition-group"],"updatePoint":{"line":63,"column":37},"line":63,"code":"  test('with multi fragments children', () => {\n    expect(\n      compile(\n        `<transition-group>\n              <div v-for=\"i in 10\"/>\n              <div v-for=\"i in 10\"/>\n              <template v-if=\"ok\"><div>ok</div></template>\n            </transition-group>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(10, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        _ssrRenderList(10, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        if (_ctx.ok) {\n          _push(\\`<div>ok</div>\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrTransitionGroup.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"attribute fallthrough","suites":["transition-group"],"updatePoint":{"line":93,"column":29},"line":93,"code":"  test('attribute fallthrough', () => {\n    expect(\n      compile(\n        `<transition-group tag=\"ul\" class=\"red\" id=\"ok\">\n        </transition-group>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<ul\\${_ssrRenderAttrs(_mergeProps({\n          class: \\\\\"red\\\\\",\n          id: \\\\\"ok\\\\\"\n        }, _attrs))}></ul>\\`)\n      }\"\n    `)\n  })","file":"ssrTransitionGroup.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: v-for"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('basic', () => {\n    expect(compile(`<div v-for=\"i in list\" />`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<div></div>\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested content","suites":["ssr: v-for"],"updatePoint":{"line":18,"column":22},"line":18,"code":"  test('nested content', () => {\n    expect(compile(`<div v-for=\"i in list\">foo<span>bar</span></div>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<!--[-->\\`)\n          _ssrRenderList(_ctx.list, (i) => {\n            _push(\\`<div>foo<span>bar</span></div>\\`)\n          })\n          _push(\\`<!--]-->\\`)\n        }\"\n      `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"nested v-for","suites":["ssr: v-for"],"updatePoint":{"line":33,"column":20},"line":33,"code":"  test('nested v-for', () => {\n    expect(\n      compile(\n        `<div v-for=\"row, i in list\">` +\n          `<div v-for=\"j in row\">{{ i }},{{ j }}</div>` +\n          `</div>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, (row, i) => {\n          _push(\\`<div><!--[-->\\`)\n          _ssrRenderList(row, (j) => {\n            _push(\\`<div>\\${\n              _ssrInterpolate(i)\n            },\\${\n              _ssrInterpolate(j)\n            }</div>\\`)\n          })\n          _push(\\`<!--]--></div>\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"template v-for (text)","suites":["ssr: v-for"],"updatePoint":{"line":61,"column":29},"line":61,"code":"  test('template v-for (text)', () => {\n    expect(compile(`<template v-for=\"i in list\">{{ i }}</template>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<!--[-->\\`)\n          _ssrRenderList(_ctx.list, (i) => {\n            _push(\\`<!--[-->\\${_ssrInterpolate(i)}<!--]-->\\`)\n          })\n          _push(\\`<!--]-->\\`)\n        }\"\n      `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"template v-for (single element)","suites":["ssr: v-for"],"updatePoint":{"line":76,"column":39},"line":76,"code":"  test('template v-for (single element)', () => {\n    expect(\n      compile(`<template v-for=\"i in list\"><span>{{ i }}</span></template>`)\n        .code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<span>\\${_ssrInterpolate(i)}</span>\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"template v-for (multi element)","suites":["ssr: v-for"],"updatePoint":{"line":93,"column":38},"line":93,"code":"  test('template v-for (multi element)', () => {\n    expect(\n      compile(\n        `<template v-for=\"i in list\"><span>{{ i }}</span><span>{{ i + 1 }}</span></template>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, (i) => {\n          _push(\\`<!--[--><span>\\${\n            _ssrInterpolate(i)\n          }</span><span>\\${\n            _ssrInterpolate(i + 1)\n          }</span><!--]-->\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"render loop args should not be prefixed","suites":["ssr: v-for"],"updatePoint":{"line":115,"column":47},"line":115,"code":"  test('render loop args should not be prefixed', () => {\n    const { code } = compile(\n      `<div v-for=\"{ foo }, index in list\">{{ foo + bar + index }}</div>`\n    )\n    expect(code).toMatch(`_ctx.bar`)\n    expect(code).not.toMatch(`_ctx.foo`)\n    expect(code).not.toMatch(`_ctx.index`)\n    expect(code).toMatchInlineSnapshot(`\n      \"const { ssrInterpolate: _ssrInterpolate, ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<!--[-->\\`)\n        _ssrRenderList(_ctx.list, ({ foo }, index) => {\n          _push(\\`<div>\\${_ssrInterpolate(foo + _ctx.bar + index)}</div>\\`)\n        })\n        _push(\\`<!--]-->\\`)\n      }\"\n    `)\n  })","file":"ssrVFor.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: v-if"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('basic', () => {\n    expect(compile(`<div v-if=\"foo\"></div>`).code).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        if (_ctx.foo) {\n          _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with nested content","suites":["ssr: v-if"],"updatePoint":{"line":18,"column":27},"line":18,"code":"  test('with nested content', () => {\n    expect(compile(`<div v-if=\"foo\">hello<span>ok</span></div>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (_ctx.foo) {\n            _push(\\`<div\\${_ssrRenderAttrs(_attrs)}>hello<span>ok</span></div>\\`)\n          } else {\n            _push(\\`<!---->\\`)\n          }\n        }\"\n      `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-if + v-else","suites":["ssr: v-if"],"updatePoint":{"line":33,"column":21},"line":33,"code":"  test('v-if + v-else', () => {\n    expect(compile(`<div v-if=\"foo\"/><span v-else/>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (_ctx.foo) {\n            _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n          } else {\n            _push(\\`<span\\${_ssrRenderAttrs(_attrs)}></span>\\`)\n          }\n        }\"\n      `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-if + v-else-if","suites":["ssr: v-if"],"updatePoint":{"line":48,"column":24},"line":48,"code":"  test('v-if + v-else-if', () => {\n    expect(compile(`<div v-if=\"foo\"/><span v-else-if=\"bar\"/>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (_ctx.foo) {\n            _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n          } else if (_ctx.bar) {\n            _push(\\`<span\\${_ssrRenderAttrs(_attrs)}></span>\\`)\n          } else {\n            _push(\\`<!---->\\`)\n          }\n        }\"\n      `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"v-if + v-else-if + v-else","suites":["ssr: v-if"],"updatePoint":{"line":65,"column":33},"line":65,"code":"  test('v-if + v-else-if + v-else', () => {\n    expect(compile(`<div v-if=\"foo\"/><span v-else-if=\"bar\"/><p v-else/>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (_ctx.foo) {\n            _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n          } else if (_ctx.bar) {\n            _push(\\`<span\\${_ssrRenderAttrs(_attrs)}></span>\\`)\n          } else {\n            _push(\\`<p\\${_ssrRenderAttrs(_attrs)}></p>\\`)\n          }\n        }\"\n      `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<template v-if> (text)","suites":["ssr: v-if"],"updatePoint":{"line":82,"column":30},"line":82,"code":"  test('<template v-if> (text)', () => {\n    expect(compile(`<template v-if=\"foo\">hello</template>`).code)\n      .toMatchInlineSnapshot(`\n      \"\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        if (_ctx.foo) {\n          _push(\\`<!--[-->hello<!--]-->\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<template v-if> (single element)","suites":["ssr: v-if"],"updatePoint":{"line":96,"column":40},"line":96,"code":"  test('<template v-if> (single element)', () => {\n    // single element should not wrap with fragment\n    expect(compile(`<template v-if=\"foo\"><div>hi</div></template>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          if (_ctx.foo) {\n            _push(\\`<div\\${_ssrRenderAttrs(_attrs)}>hi</div>\\`)\n          } else {\n            _push(\\`<!---->\\`)\n          }\n        }\"\n      `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<template v-if> (multiple element)","suites":["ssr: v-if"],"updatePoint":{"line":112,"column":42},"line":112,"code":"  test('<template v-if> (multiple element)', () => {\n    expect(\n      compile(`<template v-if=\"foo\"><div>hi</div><div>ho</div></template>`).code\n    ).toMatchInlineSnapshot(`\n      \"\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        if (_ctx.foo) {\n          _push(\\`<!--[--><div>hi</div><div>ho</div><!--]-->\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<template v-if> (with v-for inside)","suites":["ssr: v-if"],"updatePoint":{"line":127,"column":43},"line":127,"code":"  test('<template v-if> (with v-for inside)', () => {\n    expect(\n      compile(`<template v-if=\"foo\"><div v-for=\"i in list\"/></template>`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderList: _ssrRenderList } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        if (_ctx.foo) {\n          _push(\\`<!--[-->\\`)\n          _ssrRenderList(_ctx.list, (i) => {\n            _push(\\`<div></div>\\`)\n          })\n          _push(\\`<!--]-->\\`)\n        } else {\n          _push(\\`<!---->\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<template v-if> + normal v-else","suites":["ssr: v-if"],"updatePoint":{"line":147,"column":39},"line":147,"code":"  test('<template v-if> + normal v-else', () => {\n    expect(\n      compile(\n        `<template v-if=\"foo\"><div>hi</div><div>ho</div></template><div v-else/>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        if (_ctx.foo) {\n          _push(\\`<!--[--><div>hi</div><div>ho</div><!--]-->\\`)\n        } else {\n          _push(\\`<div\\${_ssrRenderAttrs(_attrs)}></div>\\`)\n        }\n      }\"\n    `)\n  })","file":"ssrVIf.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<input> (text types)","suites":["ssr: v-model"],"updatePoint":{"line":8,"column":28},"line":8,"code":"  test('<input> (text types)', () => {\n    expect(compileWithWrapper(`<input v-model=\"bar\">`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttr: _ssrRenderAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><input\\${\n            _ssrRenderAttr(\\\\\"value\\\\\", _ctx.bar)\n          }></div>\\`)\n        }\"\n      `)\n\n    expect(compileWithWrapper(`<input type=\"email\" v-model=\"bar\">`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttr: _ssrRenderAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><input type=\\\\\"email\\\\\"\\${\n            _ssrRenderAttr(\\\\\"value\\\\\", _ctx.bar)\n          }></div>\\`)\n        }\"\n      `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<input type=\"radio\">","suites":["ssr: v-model"],"updatePoint":{"line":36,"column":28},"line":36,"code":"  test('<input type=\"radio\">', () => {\n    expect(\n      compileWithWrapper(`<input type=\"radio\" value=\"foo\" v-model=\"bar\">`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrLooseEqual: _ssrLooseEqual, ssrIncludeBooleanAttr: _ssrIncludeBooleanAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input type=\\\\\"radio\\\\\" value=\\\\\"foo\\\\\"\\${\n          (_ssrIncludeBooleanAttr(_ssrLooseEqual(_ctx.bar, \\\\\"foo\\\\\"))) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n        }></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<input type=\"checkbox\">","suites":["ssr: v-model"],"updatePoint":{"line":52,"column":31},"line":52,"code":"  test('<input type=\"checkbox\">', () => {\n    expect(compileWithWrapper(`<input type=\"checkbox\" v-model=\"bar\">`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrLooseContain: _ssrLooseContain, ssrIncludeBooleanAttr: _ssrIncludeBooleanAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><input type=\\\\\"checkbox\\\\\"\\${\n            (_ssrIncludeBooleanAttr((Array.isArray(_ctx.bar))\n              ? _ssrLooseContain(_ctx.bar, null)\n              : _ctx.bar)) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n          }></div>\\`)\n        }\"\n      `)\n\n    expect(\n      compileWithWrapper(`<input type=\"checkbox\" value=\"foo\" v-model=\"bar\">`)\n        .code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrLooseContain: _ssrLooseContain, ssrIncludeBooleanAttr: _ssrIncludeBooleanAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input type=\\\\\"checkbox\\\\\" value=\\\\\"foo\\\\\"\\${\n          (_ssrIncludeBooleanAttr((Array.isArray(_ctx.bar))\n            ? _ssrLooseContain(_ctx.bar, \\\\\"foo\\\\\")\n            : _ctx.bar)) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n        }></div>\\`)\n      }\"\n    `)\n\n    expect(\n      compileWithWrapper(\n        `<input type=\"checkbox\" :true-value=\"foo\" :false-value=\"bar\" v-model=\"baz\">`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrLooseEqual: _ssrLooseEqual, ssrIncludeBooleanAttr: _ssrIncludeBooleanAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input type=\\\\\"checkbox\\\\\"\\${\n          (_ssrIncludeBooleanAttr(_ssrLooseEqual(_ctx.baz, _ctx.foo))) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n        }></div>\\`)\n      }\"\n    `)\n\n    expect(\n      compileWithWrapper(\n        `<input type=\"checkbox\" true-value=\"foo\" false-value=\"bar\" v-model=\"baz\">`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrLooseEqual: _ssrLooseEqual, ssrIncludeBooleanAttr: _ssrIncludeBooleanAttr, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input type=\\\\\"checkbox\\\\\"\\${\n          (_ssrIncludeBooleanAttr(_ssrLooseEqual(_ctx.baz, \\\\\"foo\\\\\"))) ? \\\\\" checked\\\\\" : \\\\\"\\\\\"\n        }></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<textarea>","suites":["ssr: v-model"],"updatePoint":{"line":118,"column":18},"line":118,"code":"  test('<textarea>', () => {\n    expect(compileWithWrapper(`<textarea v-model=\"foo\">bar</textarea>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttrs: _ssrRenderAttrs, ssrInterpolate: _ssrInterpolate } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><textarea>\\${\n            _ssrInterpolate(_ctx.foo)\n          }</textarea></div>\\`)\n        }\"\n      `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<input :type=\"x\">","suites":["ssr: v-model"],"updatePoint":{"line":133,"column":25},"line":133,"code":"  test('<input :type=\"x\">', () => {\n    expect(compileWithWrapper(`<input :type=\"x\" v-model=\"foo\">`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderAttr: _ssrRenderAttr, ssrRenderDynamicModel: _ssrRenderDynamicModel, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><input\\${\n            _ssrRenderAttr(\\\\\"type\\\\\", _ctx.x)\n          }\\${\n            _ssrRenderDynamicModel(_ctx.x, _ctx.foo, null)\n          }></div>\\`)\n        }\"\n      `)\n\n    expect(\n      compileWithWrapper(`<input :type=\"x\" v-model=\"foo\" value=\"bar\">`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttr: _ssrRenderAttr, ssrRenderDynamicModel: _ssrRenderDynamicModel, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input\\${\n          _ssrRenderAttr(\\\\\"type\\\\\", _ctx.x)\n        }\\${\n          _ssrRenderDynamicModel(_ctx.x, _ctx.foo, \\\\\"bar\\\\\")\n        } value=\\\\\"bar\\\\\"></div>\\`)\n      }\"\n    `)\n\n    expect(\n      compileWithWrapper(`<input :type=\"x\" v-model=\"foo\" :value=\"bar\">`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderAttr: _ssrRenderAttr, ssrRenderDynamicModel: _ssrRenderDynamicModel, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input\\${\n          _ssrRenderAttr(\\\\\"type\\\\\", _ctx.x)\n        }\\${\n          _ssrRenderDynamicModel(_ctx.x, _ctx.foo, _ctx.bar)\n        }\\${\n          _ssrRenderAttr(\\\\\"value\\\\\", _ctx.bar)\n        }></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"<input v-bind=\"obj\">","suites":["ssr: v-model"],"updatePoint":{"line":184,"column":28},"line":184,"code":"  test('<input v-bind=\"obj\">', () => {\n    expect(compileWithWrapper(`<input v-bind=\"obj\" v-model=\"foo\">`).code)\n      .toMatchInlineSnapshot(`\n        \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n        const { ssrRenderAttrs: _ssrRenderAttrs, ssrGetDynamicModelProps: _ssrGetDynamicModelProps } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          let _temp0\n\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><input\\${\n            _ssrRenderAttrs((_temp0 = _ctx.obj, _mergeProps(_temp0, _ssrGetDynamicModelProps(_temp0, _ctx.foo))))\n          }></div>\\`)\n        }\"\n      `)\n\n    expect(\n      compileWithWrapper(`<input id=\"x\" v-bind=\"obj\" v-model=\"foo\" class=\"y\">`)\n        .code\n    ).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs, ssrGetDynamicModelProps: _ssrGetDynamicModelProps } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        let _temp0\n\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><input\\${\n          _ssrRenderAttrs((_temp0 = _mergeProps({ id: \\\\\"x\\\\\" }, _ctx.obj, { class: \\\\\"y\\\\\" }), _mergeProps(_temp0, _ssrGetDynamicModelProps(_temp0, _ctx.foo))))\n        }></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVModel.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic as root","suites":["ssr: v-show"],"updatePoint":{"line":8,"column":21},"line":8,"code":"  test('basic as root', () => {\n    expect(compile(`<div v-show=\"foo\"/>`).code).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${_ssrRenderAttrs(_mergeProps({\n          style: (_ctx.foo) ? null : { display: \\\\\"none\\\\\" }\n        }, _attrs))}></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"basic","suites":["ssr: v-show"],"updatePoint":{"line":21,"column":13},"line":21,"code":"  test('basic', () => {\n    expect(compileWithWrapper(`<div v-show=\"foo\"/>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><div style=\\\\\"\\${\n            _ssrRenderStyle((_ctx.foo) ? null : { display: \\\\\"none\\\\\" })\n          }\\\\\"></div></div>\\`)\n        }\"\n      `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with static style","suites":["ssr: v-show"],"updatePoint":{"line":36,"column":25},"line":36,"code":"  test('with static style', () => {\n    expect(compileWithWrapper(`<div style=\"color:red\" v-show=\"foo\"/>`).code)\n      .toMatchInlineSnapshot(`\n        \"const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n        return function ssrRender(_ctx, _push, _parent, _attrs) {\n          _push(\\`<div\\${\n            _ssrRenderAttrs(_attrs)\n          }><div style=\\\\\"\\${\n            _ssrRenderStyle([\n              {\\\\\"color\\\\\":\\\\\"red\\\\\"},\n              (_ctx.foo) ? null : { display: \\\\\"none\\\\\" }\n            ])\n          }\\\\\"></div></div>\\`)\n        }\"\n      `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with dynamic style","suites":["ssr: v-show"],"updatePoint":{"line":54,"column":26},"line":54,"code":"  test('with dynamic style', () => {\n    expect(\n      compileWithWrapper(`<div :style=\"{ color: 'red' }\" v-show=\"foo\"/>`).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><div style=\\\\\"\\${\n          _ssrRenderStyle([\n            { color: 'red' },\n            (_ctx.foo) ? null : { display: \\\\\"none\\\\\" }\n          ])\n        }\\\\\"></div></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with static + dynamic style","suites":["ssr: v-show"],"updatePoint":{"line":73,"column":35},"line":73,"code":"  test('with static + dynamic style', () => {\n    expect(\n      compileWithWrapper(\n        `<div style=\"color:red\" :style=\"{ fontSize: 14 }\" v-show=\"foo\"/>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { ssrRenderStyle: _ssrRenderStyle, ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><div style=\\\\\"\\${\n          _ssrRenderStyle([\n            {\\\\\"color\\\\\":\\\\\"red\\\\\"},\n            { fontSize: 14 },\n            (_ctx.foo) ? null : { display: \\\\\"none\\\\\" }\n          ])\n        }\\\\\"></div></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"with v-bind","suites":["ssr: v-show"],"updatePoint":{"line":95,"column":19},"line":95,"code":"  test('with v-bind', () => {\n    expect(\n      compileWithWrapper(\n        `<div v-bind=\"baz\" style=\"color:red\" :style=\"{ fontSize: 14 }\" v-show=\"foo\"/>`\n      ).code\n    ).toMatchInlineSnapshot(`\n      \"const { mergeProps: _mergeProps } = require(\\\\\"vue\\\\\")\n      const { ssrRenderAttrs: _ssrRenderAttrs } = require(\\\\\"vue/server-renderer\\\\\")\n\n      return function ssrRender(_ctx, _push, _parent, _attrs) {\n        _push(\\`<div\\${\n          _ssrRenderAttrs(_attrs)\n        }><div\\${\n          _ssrRenderAttrs(_mergeProps(_ctx.baz, {\n            style: [\n              {\\\\\"color\\\\\":\\\\\"red\\\\\"},\n              { fontSize: 14 },\n              (_ctx.foo) ? null : { display: \\\\\"none\\\\\" }\n            ]\n          }))\n        }></div></div>\\`)\n      }\"\n    `)\n  })","file":"ssrVShow.spec.ts","skipped":false,"dir":"packages/compiler-ssr/__tests__"},{"name":"$ unwrapping","suites":[],"updatePoint":{"line":18,"column":18},"line":18,"code":"test('$ unwrapping', () => {\n  const { code, rootRefs } = transform(`\n    import { ref, shallowRef } from 'vue'\n    let foo = $(ref())\n    export let a = $(ref(1))\n    let b = $(shallowRef({\n      count: 0\n    }))\n    let c = () => {}\n    let d\n    label: var e = $(ref())\n    `)\n  expect(code).not.toMatch(`$(ref())`)\n  expect(code).not.toMatch(`$(ref(1))`)\n  expect(code).not.toMatch(`$(shallowRef({`)\n  expect(code).toMatch(`let foo = (ref())`)\n  expect(code).toMatch(`export let a = (ref(1))`)\n  expect(code).toMatch(`\n    let b = (shallowRef({\n      count: 0\n    }))\n    `)\n  // normal declarations left untouched\n  expect(code).toMatch(`let c = () => {}`)\n  expect(code).toMatch(`let d`)\n  expect(code).toMatch(`label: var e = (ref())`)\n  expect(rootRefs).toStrictEqual(['foo', 'a', 'b', 'e'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$ref & $shallowRef declarations","suites":[],"updatePoint":{"line":48,"column":37},"line":48,"code":"test('$ref & $shallowRef declarations', () => {\n  const { code, rootRefs, importedHelpers } = transform(`\n    let foo = $ref()\n    export let a = $ref(1)\n    let b = $shallowRef({\n      count: 0\n    })\n    let c = () => {}\n    let d\n    label: var e = $ref()\n    `)\n  expect(code).toMatch(\n    `import { ref as _ref, shallowRef as _shallowRef } from 'vue'`\n  )\n  expect(code).not.toMatch(`$ref()`)\n  expect(code).not.toMatch(`$ref(1)`)\n  expect(code).not.toMatch(`$shallowRef({`)\n  expect(code).toMatch(`let foo = _ref()`)\n  expect(code).toMatch(`let a = _ref(1)`)\n  expect(code).toMatch(`\n    let b = _shallowRef({\n      count: 0\n    })\n    `)\n  // normal declarations left untouched\n  expect(code).toMatch(`let c = () => {}`)\n  expect(code).toMatch(`let d`)\n  expect(code).toMatch(`label: var e = _ref()`)\n  expect(rootRefs).toStrictEqual(['foo', 'a', 'b', 'e'])\n  expect(importedHelpers).toStrictEqual(['ref', 'shallowRef'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"multi $ref declarations","suites":[],"updatePoint":{"line":81,"column":29},"line":81,"code":"test('multi $ref declarations', () => {\n  const { code, rootRefs, importedHelpers } = transform(`\n    let a = $ref(1), b = $ref(2), c = $ref({\n      count: 0\n    })\n    `)\n  expect(code).toMatch(`\n    let a = _ref(1), b = _ref(2), c = _ref({\n      count: 0\n    })\n    `)\n  expect(rootRefs).toStrictEqual(['a', 'b', 'c'])\n  expect(importedHelpers).toStrictEqual(['ref'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$computed declaration","suites":[],"updatePoint":{"line":97,"column":27},"line":97,"code":"test('$computed declaration', () => {\n  const { code, rootRefs, importedHelpers } = transform(`\n    let a = $computed(() => 1)\n    `)\n  expect(code).toMatch(`\n    let a = _computed(() => 1)\n    `)\n  expect(rootRefs).toStrictEqual(['a'])\n  expect(importedHelpers).toStrictEqual(['computed'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"mixing $ref & $computed declarations","suites":[],"updatePoint":{"line":109,"column":42},"line":109,"code":"test('mixing $ref & $computed declarations', () => {\n  const { code, rootRefs, importedHelpers } = transform(`\n    let a = $ref(1), b = $computed(() => a + 1)\n    `)\n  expect(code).toMatch(`\n    let a = _ref(1), b = _computed(() => a.value + 1)\n    `)\n  expect(rootRefs).toStrictEqual(['a', 'b'])\n  expect(importedHelpers).toStrictEqual(['ref', 'computed'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"accessing ref binding","suites":[],"updatePoint":{"line":121,"column":27},"line":121,"code":"test('accessing ref binding', () => {\n  const { code } = transform(`\n    let a = $ref(1)\n    console.log(a)\n    function get() {\n      return a + 1\n    }\n    `)\n  expect(code).toMatch(`console.log(a.value)`)\n  expect(code).toMatch(`return a.value + 1`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"member expression","suites":["cases that should not append .value"],"updatePoint":{"line":135,"column":25},"line":135,"code":"  test('member expression', () => {\n    const { code } = transform(`\n      let a = $ref(1)\n      console.log(b.a)\n      `)\n    expect(code).not.toMatch(`a.value`)\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"function argument","suites":["cases that should not append .value"],"updatePoint":{"line":143,"column":25},"line":143,"code":"  test('function argument', () => {\n    const { code } = transform(`\n      let a = $ref(1)\n      function get(a) {\n        return a + 1\n      }\n      function get2({ a }) {\n        return a + 1\n      }\n      function get3([a]) {\n        return a + 1\n      }\n      `)\n    expect(code).not.toMatch(`a.value`)\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"for in/of loops","suites":["cases that should not append .value"],"updatePoint":{"line":159,"column":23},"line":159,"code":"  test('for in/of loops', () => {\n    const { code } = transform(`\n    let a = $ref(1)\n    for (const [a, b] of arr) {\n      console.log(a)\n    }\n    for (let a in arr) {\n      console.log(a)\n    }\n    `)\n    expect(code).not.toMatch(`a.value`)\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"mutating ref binding","suites":["cases that should not append .value"],"updatePoint":{"line":173,"column":26},"line":173,"code":"test('mutating ref binding', () => {\n  const { code } = transform(`\n    let a = $ref(1)\n    let b = $ref({ count: 0 })\n    function inc() {\n      a++\n      a = a + 1\n      b.count++\n      b.count = b.count + 1\n      ;({ a } = { a: 2 })\n      ;[a] = [1]\n    }\n    `)\n  expect(code).toMatch(`a.value++`)\n  expect(code).toMatch(`a.value = a.value + 1`)\n  expect(code).toMatch(`b.value.count++`)\n  expect(code).toMatch(`b.value.count = b.value.count + 1`)\n  expect(code).toMatch(`;({ a: a.value } = { a: 2 })`)\n  expect(code).toMatch(`;[a.value] = [1]`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"using ref binding in property shorthand","suites":["cases that should not append .value"],"updatePoint":{"line":195,"column":45},"line":195,"code":"test('using ref binding in property shorthand', () => {\n  const { code } = transform(`\n    let a = $ref(1)\n    const b = { a }\n    function test() {\n      const { a } = b\n    }\n    `)\n  expect(code).toMatch(`const b = { a: a.value }`)\n  // should not convert destructure\n  expect(code).toMatch(`const { a } = b`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"should not rewrite scope variable","suites":["cases that should not append .value"],"updatePoint":{"line":209,"column":39},"line":209,"code":"test('should not rewrite scope variable', () => {\n  const { code } = transform(`\n\n      let a = $ref(1)\n      let b = $ref(1)\n      let d = $ref(1)\n      const e = 1\n      function test() {\n        const a = 2\n        console.log(a)\n        console.log(b)\n        let c = { c: 3 }\n        console.log(c)\n        console.log(d)\n        console.log(e)\n      }\n      let err = $ref(null)\n      try {\n      } catch (err) {\n        console.log(err)\n      }\n    `)\n  expect(code).toMatch('console.log(a)')\n  expect(code).toMatch('console.log(b.value)')\n  expect(code).toMatch('console.log(c)')\n  expect(code).toMatch('console.log(d.value)')\n  expect(code).toMatch('console.log(e)')\n  expect(code).toMatch('console.log(err)')\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"object destructure","suites":["cases that should not append .value"],"updatePoint":{"line":240,"column":24},"line":240,"code":"test('object destructure', () => {\n  const { code, rootRefs } = transform(`\n    let n = $ref(1), { a, b: c, d = 1, e: f = 2, [g]: h } = $(useFoo())\n    let { foo } = $(useSomething(() => 1));\n    console.log(n, a, c, d, f, h, foo)\n    `)\n  expect(code).toMatch(`a = _toRef(__$temp_1, 'a')`)\n  expect(code).toMatch(`c = _toRef(__$temp_1, 'b')`)\n  expect(code).toMatch(`d = _toRef(__$temp_1, 'd', 1)`)\n  expect(code).toMatch(`f = _toRef(__$temp_1, 'e', 2)`)\n  expect(code).toMatch(`h = _toRef(__$temp_1, g)`)\n  expect(code).toMatch(`foo = _toRef(__$temp_2, 'foo')`)\n  expect(code).toMatch(\n    `console.log(n.value, a.value, c.value, d.value, f.value, h.value, foo.value)`\n  )\n  expect(rootRefs).toStrictEqual(['n', 'a', 'c', 'd', 'f', 'h', 'foo'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"object destructure w/ mid-path default values","suites":["cases that should not append .value"],"updatePoint":{"line":259,"column":51},"line":259,"code":"test('object destructure w/ mid-path default values', () => {\n  const { code, rootRefs } = transform(`\n    const { a: { b } = { b: 123 }} = $(useFoo())\n    console.log(b)\n  `)\n  expect(code).toMatch(`b = _toRef((__$temp_1.a || { b: 123 }), 'b')`)\n  expect(code).toMatch(`console.log(b.value)`)\n  expect(rootRefs).toStrictEqual(['b'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"array destructure","suites":["cases that should not append .value"],"updatePoint":{"line":270,"column":23},"line":270,"code":"test('array destructure', () => {\n  const { code, rootRefs } = transform(`\n    let n = $ref(1), [a, b = 1] = $(useFoo())\n    console.log(n, a, b)\n    `)\n  expect(code).toMatch(`a = _toRef(__$temp_1, 0)`)\n  expect(code).toMatch(`b = _toRef(__$temp_1, 1, 1)`)\n  expect(code).toMatch(`console.log(n.value, a.value, b.value)`)\n  expect(rootRefs).toStrictEqual(['n', 'a', 'b'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"nested destructure","suites":["cases that should not append .value"],"updatePoint":{"line":282,"column":24},"line":282,"code":"test('nested destructure', () => {\n  const { code, rootRefs } = transform(`\n    let [{ a: { b }}] = $(useFoo())\n    let { c: [d, e] } = $(useBar())\n    console.log(b, d, e)\n    `)\n  expect(code).toMatch(`b = _toRef(__$temp_1[0].a, 'b')`)\n  expect(code).toMatch(`d = _toRef(__$temp_2.c, 0)`)\n  expect(code).toMatch(`e = _toRef(__$temp_2.c, 1)`)\n  expect(rootRefs).toStrictEqual(['b', 'd', 'e'])\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$$","suites":["cases that should not append .value"],"updatePoint":{"line":295,"column":8},"line":295,"code":"test('$$', () => {\n  const { code } = transform(`\n    let a = $ref(1)\n    const b = $$(a)\n    const c = $$({ a })\n    callExternal($$(a))\n    `)\n  expect(code).toMatch(`const b = (a)`)\n  expect(code).toMatch(`const c = ({ a })`)\n  expect(code).toMatch(`callExternal((a))`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$$ with some edge cases","suites":["cases that should not append .value"],"updatePoint":{"line":308,"column":29},"line":308,"code":"test('$$ with some edge cases', () => {\n  const { code } = transform(`\n    $$(  /* 2 */ count /* 2 */   )\n    $$(   count /* 2 */, /**/ a   )\n    $$(   (count /* 2 */, /**/ a) /**/   )\n    {\n      a:$$(count,a)\n    }\n    $$((count) + 1)\n    $$([count])\n    $$ (count )\n    console.log($$($$(a)))\n    $$(a,b)\n    $$($$((a++,b)))\n    count = $$( a++ ,b)\n    count = ()=>$$(a++,b)\n    let r1 = $ref(a, $$(a++,b))\n    let r2 = { a:$$(a++,b),b:$$ (a) }\n    switch($$(c)){\n      case d:\n        $$(a)\n        $$($$(h,f))\n        break\n    }\n    ($$(count++,$$(count),$$(count,a)))\n    `)\n  expect(code).toMatch(`/* 2 */ count /* 2 */`)\n  expect(code).toMatch(`;(   count /* 2 */, /**/ a   )`)\n  expect(code).toMatch(`;(   (count /* 2 */, /**/ a) /**/   )`)\n  expect(code).toMatch(`a:(count,a)`)\n  expect(code).toMatch(`;((count) + 1)`)\n  expect(code).toMatch(`;([count])`)\n  expect(code).toMatch(`;(a,b)`)\n  expect(code).toMatch(`log(((a)))`)\n  expect(code).toMatch(`count = ( a++ ,b)`)\n  expect(code).toMatch(`()=>(a++,b)`)\n  expect(code).toMatch(`_ref(a, (a++,b))`)\n  expect(code).toMatch(`{ a:(a++,b),b: (a) }`)\n  expect(code).toMatch(`switch((c))`)\n  expect(code).toMatch(`;((h,f))`)\n  expect(code).toMatch(`((count++,(count),(count,a)))`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"nested scopes","suites":["cases that should not append .value"],"updatePoint":{"line":352,"column":19},"line":352,"code":"test('nested scopes', () => {\n  const { code, rootRefs } = transform(`\n    let a = $ref(0)\n    let b = $ref(0)\n    let c = 0\n\n    a++ // outer a\n    b++ // outer b\n    c++ // outer c\n\n    let bar = $ref(0)\n    bar++ // outer bar\n\n    function foo({ a }) {\n      a++ // inner a\n      b++ // inner b\n      let c = $ref(0)\n      c++ // inner c\n      let d = $ref(0)\n\n      function bar(c) {\n        c++ // nested c\n        d++ // nested d\n      }\n      bar() // inner bar\n\n      if (true) {\n        let a = $ref(0)\n        a++ // if block a\n      }\n\n      return $$({ a, b, c, d })\n    }\n    `)\n  expect(rootRefs).toStrictEqual(['a', 'b', 'bar'])\n\n  expect(code).toMatch('a.value++ // outer a')\n  expect(code).toMatch('b.value++ // outer b')\n  expect(code).toMatch('c++ // outer c')\n\n  expect(code).toMatch('a++ // inner a') // shadowed by function arg\n  expect(code).toMatch('b.value++ // inner b')\n  expect(code).toMatch('c.value++ // inner c') // shadowed by local ref binding\n\n  expect(code).toMatch('c++ // nested c') // shadowed by inline fn arg\n  expect(code).toMatch(`d.value++ // nested d`)\n\n  expect(code).toMatch(`a.value++ // if block a`) // if block\n\n  expect(code).toMatch(`bar.value++ // outer bar`)\n  // inner bar shadowed by function declaration\n  expect(code).toMatch(`bar() // inner bar`)\n\n  expect(code).toMatch(`return ({ a, b, c, d })`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"should not rewrite type identifiers","suites":["cases that should not append .value"],"updatePoint":{"line":410,"column":41},"line":410,"code":"test('should not rewrite type identifiers', () => {\n  const { code } = transform(\n    `const props = defineProps<{msg: string; ids?: string[]}>()\n        let ids = $ref([])`,\n    {\n      parserPlugins: ['typescript']\n    }\n  )\n  expect(code).not.toMatch('.value')\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"handle TS casting syntax","suites":["cases that should not append .value"],"updatePoint":{"line":423,"column":30},"line":423,"code":"test('handle TS casting syntax', () => {\n  const { code } = transform(\n    `\n      let a = $ref(1)\n      console.log(a!)\n      console.log(a! + 1)\n      console.log(a as number)\n      console.log((a as number) + 1)\n      console.log(<number>a)\n      console.log(<number>a + 1)\n      console.log(a! + (a as number))\n      console.log(a! + <number>a)\n      console.log((a as number) + <number>a)\n      `,\n    {\n      parserPlugins: ['typescript']\n    }\n  )\n  expect(code).toMatch('console.log(a.value!)')\n  expect(code).toMatch('console.log(a.value as number)')\n  expect(code).toMatch('console.log(<number>a.value)')\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"macro import alias and removal","suites":["cases that should not append .value"],"updatePoint":{"line":447,"column":36},"line":447,"code":"test('macro import alias and removal', () => {\n  const { code } = transform(\n    `\n    import { $ as fromRefs, $ref } from 'vue/macros'\n\n    let a = $ref(1)\n    const { x, y } = fromRefs(useMouse())\n    `\n  )\n  // should remove imports\n  expect(code).not.toMatch(`from 'vue/macros'`)\n  expect(code).toMatch(`let a = _ref(1)`)\n  expect(code).toMatch(`const __$temp_1 = (useMouse())`)\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"should not overwrite importing","suites":["cases that should not append .value"],"updatePoint":{"line":464,"column":36},"line":464,"code":"test('should not overwrite importing', () => {\n  const { code } = transform(\n    `\n    import { $, $$ } from './foo'\n    $('foo')\n    $$('bar')\n    `\n  )\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"should not overwrite current scope","suites":["cases that should not append .value"],"updatePoint":{"line":476,"column":40},"line":476,"code":"test('should not overwrite current scope', () => {\n  const { code } = transform(\n    `\n    const fn = () => {\n      const $ = () => 'foo'\n      const $ref = () => 'bar'\n      const $$ = () => 'baz'\n      console.log($())\n      console.log($ref())\n      console.log($$())\n    }\n    `\n  )\n  assertCode(code)\n})","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$ref w/ destructure","suites":["errors"],"updatePoint":{"line":493,"column":27},"line":493,"code":"  test('$ref w/ destructure', () => {\n    expect(() => transform(`let { a } = $ref(1)`)).toThrow(\n      `cannot be used with destructure`\n    )\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"$computed w/ destructure","suites":["errors"],"updatePoint":{"line":499,"column":32},"line":499,"code":"  test('$computed w/ destructure', () => {\n    expect(() => transform(`let { a } = $computed(() => 1)`)).toThrow(\n      `cannot be used with destructure`\n    )\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"warn usage in non-init positions","suites":["errors"],"updatePoint":{"line":505,"column":40},"line":505,"code":"  test('warn usage in non-init positions', () => {\n    expect(() =>\n      transform(\n        `let bar = $ref(1)\n          bar = $ref(2)`\n      )\n    ).toThrow(`$ref can only be used as the initializer`)\n\n    expect(() => transform(`let bar = { foo: $computed(1) }`)).toThrow(\n      `$computed can only be used as the initializer`\n    )\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"not transform the prototype attributes","suites":["errors"],"updatePoint":{"line":518,"column":46},"line":518,"code":"  test('not transform the prototype attributes', () => {\n    const { code } = transform(`\n    const hasOwnProperty = Object.prototype.hasOwnProperty\n    const hasOwn = (val, key) => hasOwnProperty.call(val, key)\n    `)\n    expect(code).not.toMatch('.value')\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"rest element in $() destructure","suites":["errors"],"updatePoint":{"line":526,"column":39},"line":526,"code":"  test('rest element in $() destructure', () => {\n    expect(() => transform(`let { a, ...b } = $(foo())`)).toThrow(\n      `does not support rest element`\n    )\n    expect(() => transform(`let [a, ...b] = $(foo())`)).toThrow(\n      `does not support rest element`\n    )\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"assignment to constant variable","suites":["errors"],"updatePoint":{"line":535,"column":39},"line":535,"code":"  test('assignment to constant variable', () => {\n    expect(() =>\n      transform(`\n        const foo = $ref(0)\n        foo = 1\n      `)\n    ).toThrow(`Assignment to constant variable.`)\n\n    expect(() =>\n      transform(`\n        const [a, b] = $([1, 2])\n        a = 1\n      `)\n    ).toThrow(`Assignment to constant variable.`)\n\n    expect(() =>\n      transform(`\n        const foo = $ref(0)\n        foo++\n      `)\n    ).toThrow(`Assignment to constant variable.`)\n\n    expect(() =>\n      transform(`\n      const foo = $ref(0)\n      bar = foo\n      `)\n    ).not.toThrow()\n  })","file":"reactivityTransform.spec.ts","skipped":false,"dir":"packages/reactivity-transform/__tests__"},{"name":"instanceof","suites":["reactivity/collections","Map"],"updatePoint":{"line":13,"column":20},"line":13,"code":"    test('instanceof', () => {\n      const original = new Map()\n      const observed = reactive(original)\n      expect(isReactive(observed)).toBe(true)\n      expect(original instanceof Map).toBe(true)\n      expect(observed instanceof Map).toBe(true)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations","suites":["reactivity/collections","Map"],"updatePoint":{"line":21,"column":32},"line":21,"code":"    it('should observe mutations', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = map.get('key')\n      })\n\n      expect(dummy).toBe(undefined)\n      map.set('key', 'value')\n      expect(dummy).toBe('value')\n      map.set('key', 'value2')\n      expect(dummy).toBe('value2')\n      map.delete('key')\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations with observed value as key","suites":["reactivity/collections","Map"],"updatePoint":{"line":37,"column":59},"line":37,"code":"    it('should observe mutations with observed value as key', () => {\n      let dummy\n      const key = reactive({})\n      const value = reactive({})\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = map.get(key)\n      })\n\n      expect(dummy).toBe(undefined)\n      map.set(key, value)\n      expect(dummy).toBe(value)\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe size mutations","suites":["reactivity/collections","Map"],"updatePoint":{"line":53,"column":37},"line":53,"code":"    it('should observe size mutations', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => (dummy = map.size))\n\n      expect(dummy).toBe(0)\n      map.set('key1', 'value')\n      map.set('key2', 'value2')\n      expect(dummy).toBe(2)\n      map.delete('key1')\n      expect(dummy).toBe(1)\n      map.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe for of iteration","suites":["reactivity/collections","Map"],"updatePoint":{"line":68,"column":39},"line":68,"code":"    it('should observe for of iteration', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = 0\n        // eslint-disable-next-line no-unused-vars\n        for (let [key, num] of map) {\n          key\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      map.set('key1', 3)\n      expect(dummy).toBe(3)\n      map.set('key2', 2)\n      expect(dummy).toBe(5)\n      // iteration should track mutation of existing entries (#709)\n      map.set('key1', 4)\n      expect(dummy).toBe(6)\n      map.delete('key1')\n      expect(dummy).toBe(2)\n      map.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe forEach iteration","suites":["reactivity/collections","Map"],"updatePoint":{"line":94,"column":40},"line":94,"code":"    it('should observe forEach iteration', () => {\n      let dummy: any\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = 0\n        map.forEach((num: any) => (dummy += num))\n      })\n\n      expect(dummy).toBe(0)\n      map.set('key1', 3)\n      expect(dummy).toBe(3)\n      map.set('key2', 2)\n      expect(dummy).toBe(5)\n      // iteration should track mutation of existing entries (#709)\n      map.set('key1', 4)\n      expect(dummy).toBe(6)\n      map.delete('key1')\n      expect(dummy).toBe(2)\n      map.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe keys iteration","suites":["reactivity/collections","Map"],"updatePoint":{"line":116,"column":37},"line":116,"code":"    it('should observe keys iteration', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = 0\n        for (let key of map.keys()) {\n          dummy += key\n        }\n      })\n\n      expect(dummy).toBe(0)\n      map.set(3, 3)\n      expect(dummy).toBe(3)\n      map.set(2, 2)\n      expect(dummy).toBe(5)\n      map.delete(3)\n      expect(dummy).toBe(2)\n      map.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe values iteration","suites":["reactivity/collections","Map"],"updatePoint":{"line":137,"column":39},"line":137,"code":"    it('should observe values iteration', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = 0\n        for (let num of map.values()) {\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      map.set('key1', 3)\n      expect(dummy).toBe(3)\n      map.set('key2', 2)\n      expect(dummy).toBe(5)\n      // iteration should track mutation of existing entries (#709)\n      map.set('key1', 4)\n      expect(dummy).toBe(6)\n      map.delete('key1')\n      expect(dummy).toBe(2)\n      map.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe entries iteration","suites":["reactivity/collections","Map"],"updatePoint":{"line":161,"column":40},"line":161,"code":"    it('should observe entries iteration', () => {\n      let dummy\n      let dummy2\n      const map = reactive(new Map())\n      effect(() => {\n        dummy = ''\n        dummy2 = 0\n        // eslint-disable-next-line no-unused-vars\n        for (let [key, num] of map.entries()) {\n          dummy += key\n          dummy2 += num\n        }\n      })\n\n      expect(dummy).toBe('')\n      expect(dummy2).toBe(0)\n      map.set('key1', 3)\n      expect(dummy).toBe('key1')\n      expect(dummy2).toBe(3)\n      map.set('key2', 2)\n      expect(dummy).toBe('key1key2')\n      expect(dummy2).toBe(5)\n      // iteration should track mutation of existing entries (#709)\n      map.set('key1', 4)\n      expect(dummy).toBe('key1key2')\n      expect(dummy2).toBe(6)\n      map.delete('key1')\n      expect(dummy).toBe('key2')\n      expect(dummy2).toBe(2)\n      map.clear()\n      expect(dummy).toBe('')\n      expect(dummy2).toBe(0)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be triggered by clearing","suites":["reactivity/collections","Map"],"updatePoint":{"line":195,"column":39},"line":195,"code":"    it('should be triggered by clearing', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => (dummy = map.get('key')))\n\n      expect(dummy).toBe(undefined)\n      map.set('key', 3)\n      expect(dummy).toBe(3)\n      map.clear()\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe custom property mutations","suites":["reactivity/collections","Map"],"updatePoint":{"line":207,"column":52},"line":207,"code":"    it('should not observe custom property mutations', () => {\n      let dummy\n      const map: any = reactive(new Map())\n      effect(() => (dummy = map.customProp))\n\n      expect(dummy).toBe(undefined)\n      map.customProp = 'Hello World'\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe non value changing mutations","suites":["reactivity/collections","Map"],"updatePoint":{"line":217,"column":55},"line":217,"code":"    it('should not observe non value changing mutations', () => {\n      let dummy\n      const map = reactive(new Map())\n      const mapSpy = vi.fn(() => (dummy = map.get('key')))\n      effect(mapSpy)\n\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(1)\n      map.set('key', undefined)\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(2)\n      map.set('key', 'value')\n      expect(dummy).toBe('value')\n      expect(mapSpy).toHaveBeenCalledTimes(3)\n      map.set('key', 'value')\n      expect(dummy).toBe('value')\n      expect(mapSpy).toHaveBeenCalledTimes(3)\n      map.delete('key')\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(4)\n      map.delete('key')\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(4)\n      map.clear()\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(4)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw data","suites":["reactivity/collections","Map"],"updatePoint":{"line":245,"column":35},"line":245,"code":"    it('should not observe raw data', () => {\n      let dummy\n      const map = reactive(new Map())\n      effect(() => (dummy = toRaw(map).get('key')))\n\n      expect(dummy).toBe(undefined)\n      map.set('key', 'Hello')\n      expect(dummy).toBe(undefined)\n      map.delete('key')\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not pollute original Map with Proxies","suites":["reactivity/collections","Map"],"updatePoint":{"line":257,"column":52},"line":257,"code":"    it('should not pollute original Map with Proxies', () => {\n      const map = new Map()\n      const observed = reactive(map)\n      const value = reactive({})\n      observed.set('key', value)\n      expect(map.get('key')).not.toBe(value)\n      expect(map.get('key')).toBe(toRaw(value))\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return observable versions of contained values","suites":["reactivity/collections","Map"],"updatePoint":{"line":266,"column":61},"line":266,"code":"    it('should return observable versions of contained values', () => {\n      const observed = reactive(new Map())\n      const value = {}\n      observed.set('key', value)\n      const wrapped = observed.get('key')\n      expect(isReactive(wrapped)).toBe(true)\n      expect(toRaw(wrapped)).toBe(value)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observed nested data","suites":["reactivity/collections","Map"],"updatePoint":{"line":275,"column":35},"line":275,"code":"    it('should observed nested data', () => {\n      const observed = reactive(new Map())\n      observed.set('key', { a: 1 })\n      let dummy\n      effect(() => {\n        dummy = observed.get('key').a\n      })\n      observed.get('key').a = 2\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (forEach)","suites":["reactivity/collections","Map"],"updatePoint":{"line":286,"column":60},"line":286,"code":"    it('should observe nested values in iterations (forEach)', () => {\n      const map = reactive(new Map([[1, { foo: 1 }]]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        map.forEach(value => {\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        })\n      })\n      expect(dummy).toBe(1)\n      map.get(1)!.foo++\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (values)","suites":["reactivity/collections","Map"],"updatePoint":{"line":301,"column":59},"line":301,"code":"    it('should observe nested values in iterations (values)', () => {\n      const map = reactive(new Map([[1, { foo: 1 }]]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const value of map.values()) {\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      map.get(1)!.foo++\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (entries)","suites":["reactivity/collections","Map"],"updatePoint":{"line":316,"column":60},"line":316,"code":"    it('should observe nested values in iterations (entries)', () => {\n      const key = {}\n      const map = reactive(new Map([[key, { foo: 1 }]]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const [key, value] of map.entries()) {\n          key\n          expect(isReactive(key)).toBe(true)\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      map.get(key)!.foo++\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (for...of)","suites":["reactivity/collections","Map"],"updatePoint":{"line":334,"column":61},"line":334,"code":"    it('should observe nested values in iterations (for...of)', () => {\n      const key = {}\n      const map = reactive(new Map([[key, { foo: 1 }]]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const [key, value] of map) {\n          key\n          expect(isReactive(key)).toBe(true)\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      map.get(key)!.foo++\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be trigger when the value and the old value both are NaN","suites":["reactivity/collections","Map"],"updatePoint":{"line":352,"column":75},"line":352,"code":"    it('should not be trigger when the value and the old value both are NaN', () => {\n      const map = reactive(new Map([['foo', NaN]]))\n      const mapSpy = vi.fn(() => map.get('foo'))\n      effect(mapSpy)\n      map.set('foo', NaN)\n      expect(mapSpy).toHaveBeenCalledTimes(1)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work with reactive keys in raw map","suites":["reactivity/collections","Map"],"updatePoint":{"line":360,"column":49},"line":360,"code":"    it('should work with reactive keys in raw map', () => {\n      const raw = new Map()\n      const key = reactive({})\n      raw.set(key, 1)\n      const map = reactive(raw)\n\n      expect(map.has(key)).toBe(true)\n      expect(map.get(key)).toBe(1)\n\n      expect(map.delete(key)).toBe(true)\n      expect(map.has(key)).toBe(false)\n      expect(map.get(key)).toBeUndefined()\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should track set of reactive keys in raw map","suites":["reactivity/collections","Map"],"updatePoint":{"line":374,"column":52},"line":374,"code":"    it('should track set of reactive keys in raw map', () => {\n      const raw = new Map()\n      const key = reactive({})\n      raw.set(key, 1)\n      const map = reactive(raw)\n\n      let dummy\n      effect(() => {\n        dummy = map.get(key)\n      })\n      expect(dummy).toBe(1)\n\n      map.set(key, 2)\n      expect(dummy).toBe(2)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should track deletion of reactive keys in raw map","suites":["reactivity/collections","Map"],"updatePoint":{"line":390,"column":57},"line":390,"code":"    it('should track deletion of reactive keys in raw map', () => {\n      const raw = new Map()\n      const key = reactive({})\n      raw.set(key, 1)\n      const map = reactive(raw)\n\n      let dummy\n      effect(() => {\n        dummy = map.has(key)\n      })\n      expect(dummy).toBe(true)\n\n      map.delete(key)\n      expect(dummy).toBe(false)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should warn when both raw and reactive versions of the same object is used as key","suites":["reactivity/collections","Map"],"updatePoint":{"line":406,"column":89},"line":406,"code":"    it('should warn when both raw and reactive versions of the same object is used as key', () => {\n      const raw = new Map()\n      const rawKey = {}\n      const key = reactive(rawKey)\n      raw.set(rawKey, 1)\n      raw.set(key, 1)\n      const map = reactive(raw)\n      map.set(key, 2)\n      expect(\n        `Reactive Map contains both the raw and reactive`\n      ).toHaveBeenWarned()\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not trigger key iteration when setting existing keys","suites":["reactivity/collections","Map"],"updatePoint":{"line":420,"column":67},"line":420,"code":"    it('should not trigger key iteration when setting existing keys', () => {\n      const map = reactive(new Map())\n      const spy = vi.fn()\n\n      effect(() => {\n        const keys = []\n        for (const key of map.keys()) {\n          keys.push(key)\n        }\n        spy(keys)\n      })\n\n      expect(spy).toHaveBeenCalledTimes(1)\n      expect(spy.mock.calls[0][0]).toMatchObject([])\n\n      map.set('a', 0)\n      expect(spy).toHaveBeenCalledTimes(2)\n      expect(spy.mock.calls[1][0]).toMatchObject(['a'])\n\n      map.set('b', 0)\n      expect(spy).toHaveBeenCalledTimes(3)\n      expect(spy.mock.calls[2][0]).toMatchObject(['a', 'b'])\n\n      // keys didn't change, should not trigger\n      map.set('b', 1)\n      expect(spy).toHaveBeenCalledTimes(3)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Map.has only once for non-reactive keys","suites":["reactivity/collections","Map"],"updatePoint":{"line":448,"column":62},"line":448,"code":"    it('should trigger Map.has only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Map(), 'has')\n      proxy.has('k')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Map.set only once for non-reactive keys","suites":["reactivity/collections","Map"],"updatePoint":{"line":454,"column":62},"line":454,"code":"    it('should trigger Map.set only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Map(), 'set')\n      proxy.set('k', 'v')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Map.delete only once for non-reactive keys","suites":["reactivity/collections","Map"],"updatePoint":{"line":460,"column":65},"line":460,"code":"    it('should trigger Map.delete only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Map(), 'delete')\n      proxy.delete('foo')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Map.clear only once for non-reactive keys","suites":["reactivity/collections","Map"],"updatePoint":{"line":466,"column":64},"line":466,"code":"    it('should trigger Map.clear only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Map(), 'clear')\n      proxy.clear()\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return proxy from Map.set call","suites":["reactivity/collections","Map"],"updatePoint":{"line":472,"column":45},"line":472,"code":"    it('should return proxy from Map.set call', () => {\n      const map = reactive(new Map())\n      const result = map.set('a', 'a')\n      expect(result).toBe(map)\n    })","file":"collections/Map.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"instanceof","suites":["reactivity/collections","Set"],"updatePoint":{"line":13,"column":18},"line":13,"code":"    it('instanceof', () => {\n      const original = new Set()\n      const observed = reactive(original)\n      expect(isReactive(observed)).toBe(true)\n      expect(original instanceof Set).toBe(true)\n      expect(observed instanceof Set).toBe(true)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":21,"column":32},"line":21,"code":"    it('should observe mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = set.has('value')))\n\n      expect(dummy).toBe(false)\n      set.add('value')\n      expect(dummy).toBe(true)\n      set.delete('value')\n      expect(dummy).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations with observed value","suites":["reactivity/collections","Set"],"updatePoint":{"line":33,"column":52},"line":33,"code":"    it('should observe mutations with observed value', () => {\n      let dummy\n      const value = reactive({})\n      const set = reactive(new Set())\n      effect(() => (dummy = set.has(value)))\n\n      expect(dummy).toBe(false)\n      set.add(value)\n      expect(dummy).toBe(true)\n      set.delete(value)\n      expect(dummy).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe for of iteration","suites":["reactivity/collections","Set"],"updatePoint":{"line":46,"column":39},"line":46,"code":"    it('should observe for of iteration', () => {\n      let dummy\n      const set = reactive(new Set() as Set<number>)\n      effect(() => {\n        dummy = 0\n        for (let num of set) {\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(1)\n      expect(dummy).toBe(3)\n      set.delete(2)\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe forEach iteration","suites":["reactivity/collections","Set"],"updatePoint":{"line":66,"column":40},"line":66,"code":"    it('should observe forEach iteration', () => {\n      let dummy: any\n      const set = reactive(new Set())\n      effect(() => {\n        dummy = 0\n        set.forEach(num => (dummy += num))\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(1)\n      expect(dummy).toBe(3)\n      set.delete(2)\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe values iteration","suites":["reactivity/collections","Set"],"updatePoint":{"line":84,"column":39},"line":84,"code":"    it('should observe values iteration', () => {\n      let dummy\n      const set = reactive(new Set() as Set<number>)\n      effect(() => {\n        dummy = 0\n        for (let num of set.values()) {\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(1)\n      expect(dummy).toBe(3)\n      set.delete(2)\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe keys iteration","suites":["reactivity/collections","Set"],"updatePoint":{"line":104,"column":37},"line":104,"code":"    it('should observe keys iteration', () => {\n      let dummy\n      const set = reactive(new Set() as Set<number>)\n      effect(() => {\n        dummy = 0\n        for (let num of set.keys()) {\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(1)\n      expect(dummy).toBe(3)\n      set.delete(2)\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe entries iteration","suites":["reactivity/collections","Set"],"updatePoint":{"line":124,"column":40},"line":124,"code":"    it('should observe entries iteration', () => {\n      let dummy\n      const set = reactive(new Set<number>())\n      effect(() => {\n        dummy = 0\n        // eslint-disable-next-line no-unused-vars\n        for (let [key, num] of set.entries()) {\n          key\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(1)\n      expect(dummy).toBe(3)\n      set.delete(2)\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be triggered by clearing","suites":["reactivity/collections","Set"],"updatePoint":{"line":146,"column":39},"line":146,"code":"    it('should be triggered by clearing', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = set.has('key')))\n\n      expect(dummy).toBe(false)\n      set.add('key')\n      expect(dummy).toBe(true)\n      set.clear()\n      expect(dummy).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe custom property mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":158,"column":52},"line":158,"code":"    it('should not observe custom property mutations', () => {\n      let dummy\n      const set: any = reactive(new Set())\n      effect(() => (dummy = set.customProp))\n\n      expect(dummy).toBe(undefined)\n      set.customProp = 'Hello World'\n      expect(dummy).toBe(undefined)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe size mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":168,"column":37},"line":168,"code":"    it('should observe size mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = set.size))\n\n      expect(dummy).toBe(0)\n      set.add('value')\n      set.add('value2')\n      expect(dummy).toBe(2)\n      set.delete('value')\n      expect(dummy).toBe(1)\n      set.clear()\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe non value changing mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":183,"column":55},"line":183,"code":"    it('should not observe non value changing mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      const setSpy = vi.fn(() => (dummy = set.has('value')))\n      effect(setSpy)\n\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(1)\n      set.add('value')\n      expect(dummy).toBe(true)\n      expect(setSpy).toHaveBeenCalledTimes(2)\n      set.add('value')\n      expect(dummy).toBe(true)\n      expect(setSpy).toHaveBeenCalledTimes(2)\n      set.delete('value')\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(3)\n      set.delete('value')\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(3)\n      set.clear()\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(3)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw data","suites":["reactivity/collections","Set"],"updatePoint":{"line":208,"column":35},"line":208,"code":"    it('should not observe raw data', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = toRaw(set).has('value')))\n\n      expect(dummy).toBe(false)\n      set.add('value')\n      expect(dummy).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw iterations","suites":["reactivity/collections","Set"],"updatePoint":{"line":218,"column":41},"line":218,"code":"    it('should not observe raw iterations', () => {\n      let dummy = 0\n      const set = reactive(new Set<number>())\n      effect(() => {\n        dummy = 0\n        for (let [num] of toRaw(set).entries()) {\n          dummy += num\n        }\n        for (let num of toRaw(set).keys()) {\n          dummy += num\n        }\n        for (let num of toRaw(set).values()) {\n          dummy += num\n        }\n        toRaw(set).forEach(num => {\n          dummy += num\n        })\n        for (let num of toRaw(set)) {\n          dummy += num\n        }\n      })\n\n      expect(dummy).toBe(0)\n      set.add(2)\n      set.add(3)\n      expect(dummy).toBe(0)\n      set.delete(2)\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by raw mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":248,"column":48},"line":248,"code":"    it('should not be triggered by raw mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = set.has('value')))\n\n      expect(dummy).toBe(false)\n      toRaw(set).add('value')\n      expect(dummy).toBe(false)\n      dummy = true\n      toRaw(set).delete('value')\n      expect(dummy).toBe(true)\n      toRaw(set).clear()\n      expect(dummy).toBe(true)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw size mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":263,"column":45},"line":263,"code":"    it('should not observe raw size mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = toRaw(set).size))\n\n      expect(dummy).toBe(0)\n      set.add('value')\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by raw size mutations","suites":["reactivity/collections","Set"],"updatePoint":{"line":273,"column":53},"line":273,"code":"    it('should not be triggered by raw size mutations', () => {\n      let dummy\n      const set = reactive(new Set())\n      effect(() => (dummy = set.size))\n\n      expect(dummy).toBe(0)\n      toRaw(set).add('value')\n      expect(dummy).toBe(0)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should support objects as key","suites":["reactivity/collections","Set"],"updatePoint":{"line":283,"column":37},"line":283,"code":"    it('should support objects as key', () => {\n      let dummy\n      const key = {}\n      const set = reactive(new Set())\n      const setSpy = vi.fn(() => (dummy = set.has(key)))\n      effect(setSpy)\n\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(1)\n\n      set.add({})\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(1)\n\n      set.add(key)\n      expect(dummy).toBe(true)\n      expect(setSpy).toHaveBeenCalledTimes(2)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not pollute original Set with Proxies","suites":["reactivity/collections","Set"],"updatePoint":{"line":302,"column":52},"line":302,"code":"    it('should not pollute original Set with Proxies', () => {\n      const set = new Set()\n      const observed = reactive(set)\n      const value = reactive({})\n      observed.add(value)\n      expect(observed.has(value)).toBe(true)\n      expect(set.has(value)).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (forEach)","suites":["reactivity/collections","Set"],"updatePoint":{"line":311,"column":60},"line":311,"code":"    it('should observe nested values in iterations (forEach)', () => {\n      const set = reactive(new Set([{ foo: 1 }]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        set.forEach(value => {\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        })\n      })\n      expect(dummy).toBe(1)\n      set.forEach(value => {\n        value.foo++\n      })\n      expect(dummy).toBe(2)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (values)","suites":["reactivity/collections","Set"],"updatePoint":{"line":328,"column":59},"line":328,"code":"    it('should observe nested values in iterations (values)', () => {\n      const set = reactive(new Set([{ foo: 1 }]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const value of set.values()) {\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      set.forEach(value => {\n        value.foo++\n      })\n      expect(dummy).toBe(2)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (entries)","suites":["reactivity/collections","Set"],"updatePoint":{"line":345,"column":60},"line":345,"code":"    it('should observe nested values in iterations (entries)', () => {\n      const set = reactive(new Set([{ foo: 1 }]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const [key, value] of set.entries()) {\n          expect(isReactive(key)).toBe(true)\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      set.forEach(value => {\n        value.foo++\n      })\n      expect(dummy).toBe(2)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested values in iterations (for...of)","suites":["reactivity/collections","Set"],"updatePoint":{"line":363,"column":61},"line":363,"code":"    it('should observe nested values in iterations (for...of)', () => {\n      const set = reactive(new Set([{ foo: 1 }]))\n      let dummy: any\n      effect(() => {\n        dummy = 0\n        for (const value of set) {\n          expect(isReactive(value)).toBe(true)\n          dummy += value.foo\n        }\n      })\n      expect(dummy).toBe(1)\n      set.forEach(value => {\n        value.foo++\n      })\n      expect(dummy).toBe(2)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work with reactive entries in raw set","suites":["reactivity/collections","Set"],"updatePoint":{"line":380,"column":52},"line":380,"code":"    it('should work with reactive entries in raw set', () => {\n      const raw = new Set()\n      const entry = reactive({})\n      raw.add(entry)\n      const set = reactive(raw)\n\n      expect(set.has(entry)).toBe(true)\n\n      expect(set.delete(entry)).toBe(true)\n      expect(set.has(entry)).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should track deletion of reactive entries in raw set","suites":["reactivity/collections","Set"],"updatePoint":{"line":392,"column":60},"line":392,"code":"    it('should track deletion of reactive entries in raw set', () => {\n      const raw = new Set()\n      const entry = reactive({})\n      raw.add(entry)\n      const set = reactive(raw)\n\n      let dummy\n      effect(() => {\n        dummy = set.has(entry)\n      })\n      expect(dummy).toBe(true)\n\n      set.delete(entry)\n      expect(dummy).toBe(false)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should warn when set contains both raw and reactive versions of the same object","suites":["reactivity/collections","Set"],"updatePoint":{"line":408,"column":87},"line":408,"code":"    it('should warn when set contains both raw and reactive versions of the same object', () => {\n      const raw = new Set()\n      const rawKey = {}\n      const key = reactive(rawKey)\n      raw.add(rawKey)\n      raw.add(key)\n      const set = reactive(raw)\n      set.delete(key)\n      expect(\n        `Reactive Set contains both the raw and reactive`\n      ).toHaveBeenWarned()\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"thisArg","suites":["reactivity/collections","Set"],"updatePoint":{"line":421,"column":15},"line":421,"code":"    it('thisArg', () => {\n      const raw = new Set(['value'])\n      const proxy = reactive(raw)\n      const thisArg = {}\n      let count = 0\n      proxy.forEach(function (this: {}, value, _, set) {\n        ++count\n        expect(this).toBe(thisArg)\n        expect(value).toBe('value')\n        expect(set).toBe(proxy)\n      }, thisArg)\n      expect(count).toBe(1)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Set.has only once for non-reactive keys","suites":["reactivity/collections","Set"],"updatePoint":{"line":435,"column":62},"line":435,"code":"    it('should trigger Set.has only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Set(), 'has')\n      proxy.has('foo')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Set.add only once for non-reactive keys","suites":["reactivity/collections","Set"],"updatePoint":{"line":441,"column":62},"line":441,"code":"    it('should trigger Set.add only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Set(), 'add')\n      proxy.add('foo')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Set.delete only once for non-reactive keys","suites":["reactivity/collections","Set"],"updatePoint":{"line":447,"column":65},"line":447,"code":"    it('should trigger Set.delete only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Set(), 'delete')\n      proxy.delete('foo')\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger Set.clear only once for non-reactive keys","suites":["reactivity/collections","Set"],"updatePoint":{"line":453,"column":64},"line":453,"code":"    it('should trigger Set.clear only once for non-reactive keys', () => {\n      const [proxy, spy] = coverCollectionFn(new Set(), 'clear')\n      proxy.clear()\n      expect(spy).toBeCalledTimes(1)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return proxy from Set.add call","suites":["reactivity/collections","Set"],"updatePoint":{"line":459,"column":45},"line":459,"code":"    it('should return proxy from Set.add call', () => {\n      const set = reactive(new Set())\n      const result = set.add('a')\n      expect(result).toBe(set)\n    })","file":"collections/Set.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make the map/weak-map readonly","suites":["reactivity/collections","shallowReadonly/Map"],"updatePoint":{"line":6,"column":49},"line":6,"code":"      test('should make the map/weak-map readonly', () => {\n        const key = {}\n        const val = { foo: 1 }\n        const original = new Collection([[key, val]])\n        const sroMap = shallowReadonly(original)\n        expect(isReadonly(sroMap)).toBe(true)\n        expect(isReactive(sroMap)).toBe(false)\n        expect(sroMap.get(key)).toBe(val)\n\n        sroMap.set(key, {} as any)\n        expect(\n          `Set operation on key \"[object Object]\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make nested values readonly","suites":["reactivity/collections","shallowReadonly/Map"],"updatePoint":{"line":21,"column":50},"line":21,"code":"      test('should not make nested values readonly', () => {\n        const key = {}\n        const val = { foo: 1 }\n        const original = new Collection([[key, val]])\n        const sroMap = shallowReadonly(original)\n        expect(isReadonly(sroMap.get(key))).toBe(false)\n        expect(isReactive(sroMap.get(key))).toBe(false)\n\n        sroMap.get(key)!.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the iterable method readonly","suites":["reactivity/collections","shallowReadonly/Map"],"updatePoint":{"line":36,"column":77},"line":36,"code":"    test('should not make the value generated by the iterable method readonly', () => {\n      const key = {}\n      const val = { foo: 1 }\n      const original = new Map([[key, val]])\n      const sroMap = shallowReadonly(original)\n\n      const values1 = [...sroMap.values()]\n      const values2 = [...sroMap.entries()]\n\n      expect(isReadonly(values1[0])).toBe(false)\n      expect(isReactive(values1[0])).toBe(false)\n      expect(values1[0]).toBe(val)\n\n      values1[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n\n      expect(isReadonly(values2[0][1])).toBe(false)\n      expect(isReactive(values2[0][1])).toBe(false)\n      expect(values2[0][1]).toBe(val)\n\n      values2[0][1].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the forEach method readonly","suites":["reactivity/collections","shallowReadonly/Map"],"updatePoint":{"line":64,"column":76},"line":64,"code":"    test('should not make the value generated by the forEach method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Map([['key', val]])\n      const sroMap = shallowReadonly(original)\n\n      sroMap.forEach(val => {\n        expect(isReadonly(val)).toBe(false)\n        expect(isReactive(val)).toBe(false)\n        expect(val).toBe(val)\n\n        val.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make the set/weak-set readonly","suites":["reactivity/collections","shallowReadonly/Set"],"updatePoint":{"line":83,"column":47},"line":83,"code":"    test('should make the set/weak-set readonly', () => {\n      ;[Set, WeakSet].forEach(Collection => {\n        const obj = { foo: 1 }\n        const original = new Collection([obj])\n        const sroSet = shallowReadonly(original)\n        expect(isReadonly(sroSet)).toBe(true)\n        expect(isReactive(sroSet)).toBe(false)\n        expect(sroSet.has(obj)).toBe(true)\n\n        sroSet.add({} as any)\n        expect(\n          `Add operation on key \"[object Object]\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make nested values readonly","suites":["reactivity/collections","shallowReadonly/Set"],"updatePoint":{"line":99,"column":48},"line":99,"code":"    test('should not make nested values readonly', () => {\n      const obj = { foo: 1 }\n      const original = new Set([obj])\n      const sroSet = shallowReadonly(original)\n\n      const values = [...sroSet.values()]\n\n      expect(values[0]).toBe(obj)\n      expect(isReadonly(values[0])).toBe(false)\n      expect(isReactive(values[0])).toBe(false)\n\n      sroSet.add({} as any)\n      expect(\n        `Add operation on key \"[object Object]\" failed: target is readonly.`\n      ).toHaveBeenWarned()\n\n      values[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the iterable method readonly","suites":["reactivity/collections","shallowReadonly/Set"],"updatePoint":{"line":121,"column":77},"line":121,"code":"    test('should not make the value generated by the iterable method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Set([val])\n      const sroSet = shallowReadonly(original)\n\n      const values1 = [...sroSet.values()]\n      const values2 = [...sroSet.entries()]\n\n      expect(isReadonly(values1[0])).toBe(false)\n      expect(isReactive(values1[0])).toBe(false)\n      expect(values1[0]).toBe(val)\n\n      values1[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n\n      expect(isReadonly(values2[0][1])).toBe(false)\n      expect(isReactive(values2[0][1])).toBe(false)\n      expect(values2[0][1]).toBe(val)\n\n      values2[0][1].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the forEach method readonly","suites":["reactivity/collections","shallowReadonly/Set"],"updatePoint":{"line":148,"column":76},"line":148,"code":"    test('should not make the value generated by the forEach method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Set([val])\n      const sroSet = shallowReadonly(original)\n\n      sroSet.forEach(val => {\n        expect(isReadonly(val)).toBe(false)\n        expect(isReactive(val)).toBe(false)\n        expect(val).toBe(val)\n\n        val.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })\n    })","file":"collections/shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"instanceof","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":6,"column":20},"line":6,"code":"    test('instanceof', () => {\n      const original = new WeakMap()\n      const observed = reactive(original)\n      expect(isReactive(observed)).toBe(true)\n      expect(original instanceof WeakMap).toBe(true)\n      expect(observed instanceof WeakMap).toBe(true)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":14,"column":32},"line":14,"code":"    it('should observe mutations', () => {\n      let dummy\n      const key = {}\n      const map = reactive(new WeakMap())\n      effect(() => {\n        dummy = map.get(key)\n      })\n\n      expect(dummy).toBe(undefined)\n      map.set(key, 'value')\n      expect(dummy).toBe('value')\n      map.set(key, 'value2')\n      expect(dummy).toBe('value2')\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations with observed value as key","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":31,"column":59},"line":31,"code":"    it('should observe mutations with observed value as key', () => {\n      let dummy\n      const key = reactive({})\n      const value = reactive({})\n      const map = reactive(new WeakMap())\n      effect(() => {\n        dummy = map.get(key)\n      })\n\n      expect(dummy).toBe(undefined)\n      map.set(key, value)\n      expect(dummy).toBe(value)\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe custom property mutations","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":47,"column":52},"line":47,"code":"    it('should not observe custom property mutations', () => {\n      let dummy\n      const map: any = reactive(new WeakMap())\n      effect(() => (dummy = map.customProp))\n\n      expect(dummy).toBe(undefined)\n      map.customProp = 'Hello World'\n      expect(dummy).toBe(undefined)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe non value changing mutations","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":57,"column":55},"line":57,"code":"    it('should not observe non value changing mutations', () => {\n      let dummy\n      const key = {}\n      const map = reactive(new WeakMap())\n      const mapSpy = vi.fn(() => (dummy = map.get(key)))\n      effect(mapSpy)\n\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(1)\n      map.set(key, undefined)\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(2)\n      map.set(key, 'value')\n      expect(dummy).toBe('value')\n      expect(mapSpy).toHaveBeenCalledTimes(3)\n      map.set(key, 'value')\n      expect(dummy).toBe('value')\n      expect(mapSpy).toHaveBeenCalledTimes(3)\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(4)\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n      expect(mapSpy).toHaveBeenCalledTimes(4)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw data","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":83,"column":35},"line":83,"code":"    it('should not observe raw data', () => {\n      let dummy\n      const key = {}\n      const map = reactive(new WeakMap())\n      effect(() => (dummy = toRaw(map).get(key)))\n\n      expect(dummy).toBe(undefined)\n      map.set(key, 'Hello')\n      expect(dummy).toBe(undefined)\n      map.delete(key)\n      expect(dummy).toBe(undefined)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not pollute original Map with Proxies","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":96,"column":52},"line":96,"code":"    it('should not pollute original Map with Proxies', () => {\n      const map = new WeakMap()\n      const observed = reactive(map)\n      const key = {}\n      const value = reactive({})\n      observed.set(key, value)\n      expect(map.get(key)).not.toBe(value)\n      expect(map.get(key)).toBe(toRaw(value))\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return observable versions of contained values","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":106,"column":61},"line":106,"code":"    it('should return observable versions of contained values', () => {\n      const observed = reactive(new WeakMap())\n      const key = {}\n      const value = {}\n      observed.set(key, value)\n      const wrapped = observed.get(key)\n      expect(isReactive(wrapped)).toBe(true)\n      expect(toRaw(wrapped)).toBe(value)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observed nested data","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":116,"column":35},"line":116,"code":"    it('should observed nested data', () => {\n      const observed = reactive(new WeakMap())\n      const key = {}\n      observed.set(key, { a: 1 })\n      let dummy\n      effect(() => {\n        dummy = observed.get(key).a\n      })\n      observed.get(key).a = 2\n      expect(dummy).toBe(2)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be trigger when the value and the old value both are NaN","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":128,"column":75},"line":128,"code":"    it('should not be trigger when the value and the old value both are NaN', () => {\n      const map = new WeakMap()\n      const key = {}\n      map.set(key, NaN)\n      const mapSpy = vi.fn(() => map.get(key))\n      effect(mapSpy)\n      map.set(key, NaN)\n      expect(mapSpy).toHaveBeenCalledTimes(1)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return proxy from WeakMap.set call","suites":["reactivity/collections","WeakMap"],"updatePoint":{"line":137,"column":49},"line":137,"code":"    it('should return proxy from WeakMap.set call', () => {\n      const map = reactive(new WeakMap())\n      const result = map.set({}, 'a')\n      expect(result).toBe(map)\n    })","file":"collections/WeakMap.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"instanceof","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":6,"column":18},"line":6,"code":"    it('instanceof', () => {\n      const original = new WeakSet()\n      const observed = reactive(original)\n      expect(isReactive(observed)).toBe(true)\n      expect(original instanceof WeakSet).toBe(true)\n      expect(observed instanceof WeakSet).toBe(true)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":14,"column":32},"line":14,"code":"    it('should observe mutations', () => {\n      let dummy\n      const value = {}\n      const set = reactive(new WeakSet())\n      effect(() => (dummy = set.has(value)))\n\n      expect(dummy).toBe(false)\n      set.add(value)\n      expect(dummy).toBe(true)\n      set.delete(value)\n      expect(dummy).toBe(false)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe mutations with observed value","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":27,"column":52},"line":27,"code":"    it('should observe mutations with observed value', () => {\n      let dummy\n      const value = reactive({})\n      const set = reactive(new WeakSet())\n      effect(() => (dummy = set.has(value)))\n\n      expect(dummy).toBe(false)\n      set.add(value)\n      expect(dummy).toBe(true)\n      set.delete(value)\n      expect(dummy).toBe(false)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe custom property mutations","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":40,"column":52},"line":40,"code":"    it('should not observe custom property mutations', () => {\n      let dummy\n      const set: any = reactive(new WeakSet())\n      effect(() => (dummy = set.customProp))\n\n      expect(dummy).toBe(undefined)\n      set.customProp = 'Hello World'\n      expect(dummy).toBe(undefined)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe non value changing mutations","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":50,"column":55},"line":50,"code":"    it('should not observe non value changing mutations', () => {\n      let dummy\n      const value = {}\n      const set = reactive(new WeakSet())\n      const setSpy = vi.fn(() => (dummy = set.has(value)))\n      effect(setSpy)\n\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(1)\n      set.add(value)\n      expect(dummy).toBe(true)\n      expect(setSpy).toHaveBeenCalledTimes(2)\n      set.add(value)\n      expect(dummy).toBe(true)\n      expect(setSpy).toHaveBeenCalledTimes(2)\n      set.delete(value)\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(3)\n      set.delete(value)\n      expect(dummy).toBe(false)\n      expect(setSpy).toHaveBeenCalledTimes(3)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw data","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":73,"column":35},"line":73,"code":"    it('should not observe raw data', () => {\n      const value = {}\n      let dummy\n      const set = reactive(new WeakSet())\n      effect(() => (dummy = toRaw(set).has(value)))\n\n      expect(dummy).toBe(false)\n      set.add(value)\n      expect(dummy).toBe(false)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by raw mutations","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":84,"column":48},"line":84,"code":"    it('should not be triggered by raw mutations', () => {\n      const value = {}\n      let dummy\n      const set = reactive(new WeakSet())\n      effect(() => (dummy = set.has(value)))\n\n      expect(dummy).toBe(false)\n      toRaw(set).add(value)\n      expect(dummy).toBe(false)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not pollute original Set with Proxies","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":95,"column":52},"line":95,"code":"    it('should not pollute original Set with Proxies', () => {\n      const set = new WeakSet()\n      const observed = reactive(set)\n      const value = reactive({})\n      observed.add(value)\n      expect(observed.has(value)).toBe(true)\n      expect(set.has(value)).toBe(false)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return proxy from WeakSet.add call","suites":["reactivity/collections","WeakSet"],"updatePoint":{"line":104,"column":49},"line":104,"code":"    it('should return proxy from WeakSet.add call', () => {\n      const set = reactive(new WeakSet())\n      const result = set.add({})\n      expect(result).toBe(set)\n    })","file":"collections/WeakSet.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return updated value","suites":["reactivity/computed"],"updatePoint":{"line":17,"column":33},"line":17,"code":"  it('should return updated value', () => {\n    const value = reactive<{ foo?: number }>({})\n    const cValue = computed(() => value.foo)\n    expect(cValue.value).toBe(undefined)\n    value.foo = 1\n    expect(cValue.value).toBe(1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should compute lazily","suites":["reactivity/computed"],"updatePoint":{"line":25,"column":27},"line":25,"code":"  it('should compute lazily', () => {\n    const value = reactive<{ foo?: number }>({})\n    const getter = vi.fn(() => value.foo)\n    const cValue = computed(getter)\n\n    // lazy\n    expect(getter).not.toHaveBeenCalled()\n\n    expect(cValue.value).toBe(undefined)\n    expect(getter).toHaveBeenCalledTimes(1)\n\n    // should not compute again\n    cValue.value\n    expect(getter).toHaveBeenCalledTimes(1)\n\n    // should not compute until needed\n    value.foo = 1\n    expect(getter).toHaveBeenCalledTimes(1)\n\n    // now it should compute\n    expect(cValue.value).toBe(1)\n    expect(getter).toHaveBeenCalledTimes(2)\n\n    // should not compute again\n    cValue.value\n    expect(getter).toHaveBeenCalledTimes(2)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger effect","suites":["reactivity/computed"],"updatePoint":{"line":53,"column":27},"line":53,"code":"  it('should trigger effect', () => {\n    const value = reactive<{ foo?: number }>({})\n    const cValue = computed(() => value.foo)\n    let dummy\n    effect(() => {\n      dummy = cValue.value\n    })\n    expect(dummy).toBe(undefined)\n    value.foo = 1\n    expect(dummy).toBe(1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work when chained","suites":["reactivity/computed"],"updatePoint":{"line":65,"column":30},"line":65,"code":"  it('should work when chained', () => {\n    const value = reactive({ foo: 0 })\n    const c1 = computed(() => value.foo)\n    const c2 = computed(() => c1.value + 1)\n    expect(c2.value).toBe(1)\n    expect(c1.value).toBe(0)\n    value.foo++\n    expect(c2.value).toBe(2)\n    expect(c1.value).toBe(1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger effect when chained","suites":["reactivity/computed"],"updatePoint":{"line":76,"column":40},"line":76,"code":"  it('should trigger effect when chained', () => {\n    const value = reactive({ foo: 0 })\n    const getter1 = vi.fn(() => value.foo)\n    const getter2 = vi.fn(() => {\n      return c1.value + 1\n    })\n    const c1 = computed(getter1)\n    const c2 = computed(getter2)\n\n    let dummy\n    effect(() => {\n      dummy = c2.value\n    })\n    expect(dummy).toBe(1)\n    expect(getter1).toHaveBeenCalledTimes(1)\n    expect(getter2).toHaveBeenCalledTimes(1)\n    value.foo++\n    expect(dummy).toBe(2)\n    // should not result in duplicate calls\n    expect(getter1).toHaveBeenCalledTimes(2)\n    expect(getter2).toHaveBeenCalledTimes(2)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger effect when chained (mixed invocations)","suites":["reactivity/computed"],"updatePoint":{"line":99,"column":60},"line":99,"code":"  it('should trigger effect when chained (mixed invocations)', () => {\n    const value = reactive({ foo: 0 })\n    const getter1 = vi.fn(() => value.foo)\n    const getter2 = vi.fn(() => {\n      return c1.value + 1\n    })\n    const c1 = computed(getter1)\n    const c2 = computed(getter2)\n\n    let dummy\n    effect(() => {\n      dummy = c1.value + c2.value\n    })\n    expect(dummy).toBe(1)\n\n    expect(getter1).toHaveBeenCalledTimes(1)\n    expect(getter2).toHaveBeenCalledTimes(1)\n    value.foo++\n    expect(dummy).toBe(3)\n    // should not result in duplicate calls\n    expect(getter1).toHaveBeenCalledTimes(2)\n    expect(getter2).toHaveBeenCalledTimes(2)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should no longer update when stopped","suites":["reactivity/computed"],"updatePoint":{"line":123,"column":42},"line":123,"code":"  it('should no longer update when stopped', () => {\n    const value = reactive<{ foo?: number }>({})\n    const cValue = computed(() => value.foo)\n    let dummy\n    effect(() => {\n      dummy = cValue.value\n    })\n    expect(dummy).toBe(undefined)\n    value.foo = 1\n    expect(dummy).toBe(1)\n    cValue.effect.stop()\n    value.foo = 2\n    expect(dummy).toBe(1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should support setter","suites":["reactivity/computed"],"updatePoint":{"line":138,"column":27},"line":138,"code":"  it('should support setter', () => {\n    const n = ref(1)\n    const plusOne = computed({\n      get: () => n.value + 1,\n      set: val => {\n        n.value = val - 1\n      }\n    })\n\n    expect(plusOne.value).toBe(2)\n    n.value++\n    expect(plusOne.value).toBe(3)\n\n    plusOne.value = 0\n    expect(n.value).toBe(-1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger effect w/ setter","suites":["reactivity/computed"],"updatePoint":{"line":155,"column":37},"line":155,"code":"  it('should trigger effect w/ setter', () => {\n    const n = ref(1)\n    const plusOne = computed({\n      get: () => n.value + 1,\n      set: val => {\n        n.value = val - 1\n      }\n    })\n\n    let dummy\n    effect(() => {\n      dummy = n.value\n    })\n    expect(dummy).toBe(1)\n\n    plusOne.value = 0\n    expect(dummy).toBe(-1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should invalidate before non-computed effects","suites":["reactivity/computed"],"updatePoint":{"line":175,"column":51},"line":175,"code":"  it('should invalidate before non-computed effects', () => {\n    let plusOneValues: number[] = []\n    const n = ref(0)\n    const plusOne = computed(() => n.value + 1)\n    effect(() => {\n      n.value\n      plusOneValues.push(plusOne.value)\n    })\n    // access plusOne, causing it to be non-dirty\n    plusOne.value\n    // mutate n\n    n.value++\n    // on the 2nd run, plusOne.value should have already updated.\n    expect(plusOneValues).toMatchObject([1, 2, 2])\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should warn if trying to set a readonly computed","suites":["reactivity/computed"],"updatePoint":{"line":191,"column":54},"line":191,"code":"  it('should warn if trying to set a readonly computed', () => {\n    const n = ref(1)\n    const plusOne = computed(() => n.value + 1)\n    ;(plusOne as WritableComputedRef<number>).value++ // Type cast to prevent TS from preventing the error\n\n    expect(\n      'Write operation failed: computed value is readonly'\n    ).toHaveBeenWarnedLast()\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be readonly","suites":["reactivity/computed"],"updatePoint":{"line":201,"column":24},"line":201,"code":"  it('should be readonly', () => {\n    let a = { a: 1 }\n    const x = computed(() => a)\n    expect(isReadonly(x)).toBe(true)\n    expect(isReadonly(x.value)).toBe(false)\n    expect(isReadonly(x.value.a)).toBe(false)\n    const z = computed<typeof a>({\n      get() {\n        return a\n      },\n      set(v) {\n        a = v\n      }\n    })\n    expect(isReadonly(z)).toBe(false)\n    expect(isReadonly(z.value.a)).toBe(false)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should expose value when stopped","suites":["reactivity/computed"],"updatePoint":{"line":219,"column":38},"line":219,"code":"  it('should expose value when stopped', () => {\n    const x = computed(() => 1)\n    x.effect.stop()\n    expect(x.value).toBe(1)\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"debug: onTrack","suites":["reactivity/computed"],"updatePoint":{"line":225,"column":20},"line":225,"code":"  it('debug: onTrack', () => {\n    let events: DebuggerEvent[] = []\n    const onTrack = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive({ foo: 1, bar: 2 })\n    const c = computed(() => (obj.foo, 'bar' in obj, Object.keys(obj)), {\n      onTrack\n    })\n    expect(c.value).toEqual(['foo', 'bar'])\n    expect(onTrack).toHaveBeenCalledTimes(3)\n    expect(events).toEqual([\n      {\n        effect: c.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.GET,\n        key: 'foo'\n      },\n      {\n        effect: c.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.HAS,\n        key: 'bar'\n      },\n      {\n        effect: c.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.ITERATE,\n        key: ITERATE_KEY\n      }\n    ])\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"debug: onTrigger","suites":["reactivity/computed"],"updatePoint":{"line":258,"column":22},"line":258,"code":"  it('debug: onTrigger', () => {\n    let events: DebuggerEvent[] = []\n    const onTrigger = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive({ foo: 1 })\n    const c = computed(() => obj.foo, { onTrigger })\n\n    // computed won't trigger compute until accessed\n    c.value\n\n    obj.foo++\n    expect(c.value).toBe(2)\n    expect(onTrigger).toHaveBeenCalledTimes(1)\n    expect(events[0]).toEqual({\n      effect: c.effect,\n      target: toRaw(obj),\n      type: TriggerOpTypes.SET,\n      key: 'foo',\n      oldValue: 1,\n      newValue: 2\n    })\n\n    // @ts-ignore\n    delete obj.foo\n    expect(c.value).toBeUndefined()\n    expect(onTrigger).toHaveBeenCalledTimes(2)\n    expect(events[1]).toEqual({\n      effect: c.effect,\n      target: toRaw(obj),\n      type: TriggerOpTypes.DELETE,\n      key: 'foo',\n      oldValue: 2\n    })\n  })","file":"computed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should only trigger once on multiple mutations","suites":["deferred computed"],"updatePoint":{"line":7,"column":54},"line":7,"code":"  test('should only trigger once on multiple mutations', async () => {\n    const src = ref(0)\n    const c = deferredComputed(() => src.value)\n    const spy = vi.fn()\n    effect(() => {\n      spy(c.value)\n    })\n    expect(spy).toHaveBeenCalledTimes(1)\n    src.value = 1\n    src.value = 2\n    src.value = 3\n    // not called yet\n    expect(spy).toHaveBeenCalledTimes(1)\n    await tick\n    // should only trigger once\n    expect(spy).toHaveBeenCalledTimes(2)\n    expect(spy).toHaveBeenCalledWith(c.value)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not trigger if value did not change","suites":["deferred computed"],"updatePoint":{"line":26,"column":50},"line":26,"code":"  test('should not trigger if value did not change', async () => {\n    const src = ref(0)\n    const c = deferredComputed(() => src.value % 2)\n    const spy = vi.fn()\n    effect(() => {\n      spy(c.value)\n    })\n    expect(spy).toHaveBeenCalledTimes(1)\n    src.value = 1\n    src.value = 2\n\n    await tick\n    // should not trigger\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    src.value = 3\n    src.value = 4\n    src.value = 5\n    await tick\n    // should trigger because latest value changes\n    expect(spy).toHaveBeenCalledTimes(2)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"chained computed trigger","suites":["deferred computed"],"updatePoint":{"line":49,"column":32},"line":49,"code":"  test('chained computed trigger', async () => {\n    const effectSpy = vi.fn()\n    const c1Spy = vi.fn()\n    const c2Spy = vi.fn()\n\n    const src = ref(0)\n    const c1 = deferredComputed(() => {\n      c1Spy()\n      return src.value % 2\n    })\n    const c2 = computed(() => {\n      c2Spy()\n      return c1.value + 1\n    })\n\n    effect(() => {\n      effectSpy(c2.value)\n    })\n\n    expect(c1Spy).toHaveBeenCalledTimes(1)\n    expect(c2Spy).toHaveBeenCalledTimes(1)\n    expect(effectSpy).toHaveBeenCalledTimes(1)\n\n    src.value = 1\n    await tick\n    expect(c1Spy).toHaveBeenCalledTimes(2)\n    expect(c2Spy).toHaveBeenCalledTimes(2)\n    expect(effectSpy).toHaveBeenCalledTimes(2)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"chained computed avoid re-compute","suites":["deferred computed"],"updatePoint":{"line":79,"column":41},"line":79,"code":"  test('chained computed avoid re-compute', async () => {\n    const effectSpy = vi.fn()\n    const c1Spy = vi.fn()\n    const c2Spy = vi.fn()\n\n    const src = ref(0)\n    const c1 = deferredComputed(() => {\n      c1Spy()\n      return src.value % 2\n    })\n    const c2 = computed(() => {\n      c2Spy()\n      return c1.value + 1\n    })\n\n    effect(() => {\n      effectSpy(c2.value)\n    })\n\n    expect(effectSpy).toHaveBeenCalledTimes(1)\n    src.value = 2\n    src.value = 4\n    src.value = 6\n    await tick\n    // c1 should re-compute once.\n    expect(c1Spy).toHaveBeenCalledTimes(2)\n    // c2 should not have to re-compute because c1 did not change.\n    expect(c2Spy).toHaveBeenCalledTimes(1)\n    // effect should not trigger because c2 did not change.\n    expect(effectSpy).toHaveBeenCalledTimes(1)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"chained computed value invalidation","suites":["deferred computed"],"updatePoint":{"line":111,"column":43},"line":111,"code":"  test('chained computed value invalidation', async () => {\n    const effectSpy = vi.fn()\n    const c1Spy = vi.fn()\n    const c2Spy = vi.fn()\n\n    const src = ref(0)\n    const c1 = deferredComputed(() => {\n      c1Spy()\n      return src.value % 2\n    })\n    const c2 = deferredComputed(() => {\n      c2Spy()\n      return c1.value + 1\n    })\n\n    effect(() => {\n      effectSpy(c2.value)\n    })\n\n    expect(effectSpy).toHaveBeenCalledTimes(1)\n    expect(effectSpy).toHaveBeenCalledWith(1)\n    expect(c2.value).toBe(1)\n\n    expect(c1Spy).toHaveBeenCalledTimes(1)\n    expect(c2Spy).toHaveBeenCalledTimes(1)\n\n    src.value = 1\n    // value should be available sync\n    expect(c2.value).toBe(2)\n    expect(c2Spy).toHaveBeenCalledTimes(2)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"sync access of invalidated chained computed should not prevent final effect from running","suites":["deferred computed"],"updatePoint":{"line":143,"column":96},"line":143,"code":"  test('sync access of invalidated chained computed should not prevent final effect from running', async () => {\n    const effectSpy = vi.fn()\n    const c1Spy = vi.fn()\n    const c2Spy = vi.fn()\n\n    const src = ref(0)\n    const c1 = deferredComputed(() => {\n      c1Spy()\n      return src.value % 2\n    })\n    const c2 = deferredComputed(() => {\n      c2Spy()\n      return c1.value + 1\n    })\n\n    effect(() => {\n      effectSpy(c2.value)\n    })\n    expect(effectSpy).toHaveBeenCalledTimes(1)\n\n    src.value = 1\n    // sync access c2\n    c2.value\n    await tick\n    expect(effectSpy).toHaveBeenCalledTimes(2)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not compute if deactivated before scheduler is called","suites":["deferred computed"],"updatePoint":{"line":170,"column":68},"line":170,"code":"  test('should not compute if deactivated before scheduler is called', async () => {\n    const c1Spy = vi.fn()\n    const src = ref(0)\n    const c1 = deferredComputed(() => {\n      c1Spy()\n      return src.value % 2\n    })\n    effect(() => c1.value)\n    expect(c1Spy).toHaveBeenCalledTimes(1)\n\n    c1.effect.stop()\n    // trigger\n    src.value++\n    await tick\n    expect(c1Spy).toHaveBeenCalledTimes(1)\n  })","file":"deferredComputed.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should run the passed function once (wrapped by a effect)","suites":["reactivity/effect"],"updatePoint":{"line":19,"column":63},"line":19,"code":"  it('should run the passed function once (wrapped by a effect)', () => {\n    const fnSpy = vi.fn(() => {})\n    effect(fnSpy)\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe basic properties","suites":["reactivity/effect"],"updatePoint":{"line":25,"column":37},"line":25,"code":"  it('should observe basic properties', () => {\n    let dummy\n    const counter = reactive({ num: 0 })\n    effect(() => (dummy = counter.num))\n\n    expect(dummy).toBe(0)\n    counter.num = 7\n    expect(dummy).toBe(7)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe multiple properties","suites":["reactivity/effect"],"updatePoint":{"line":35,"column":40},"line":35,"code":"  it('should observe multiple properties', () => {\n    let dummy\n    const counter = reactive({ num1: 0, num2: 0 })\n    effect(() => (dummy = counter.num1 + counter.num1 + counter.num2))\n\n    expect(dummy).toBe(0)\n    counter.num1 = counter.num2 = 7\n    expect(dummy).toBe(21)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should handle multiple effects","suites":["reactivity/effect"],"updatePoint":{"line":45,"column":36},"line":45,"code":"  it('should handle multiple effects', () => {\n    let dummy1, dummy2\n    const counter = reactive({ num: 0 })\n    effect(() => (dummy1 = counter.num))\n    effect(() => (dummy2 = counter.num))\n\n    expect(dummy1).toBe(0)\n    expect(dummy2).toBe(0)\n    counter.num++\n    expect(dummy1).toBe(1)\n    expect(dummy2).toBe(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe nested properties","suites":["reactivity/effect"],"updatePoint":{"line":58,"column":38},"line":58,"code":"  it('should observe nested properties', () => {\n    let dummy\n    const counter = reactive({ nested: { num: 0 } })\n    effect(() => (dummy = counter.nested.num))\n\n    expect(dummy).toBe(0)\n    counter.nested.num = 8\n    expect(dummy).toBe(8)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe delete operations","suites":["reactivity/effect"],"updatePoint":{"line":68,"column":38},"line":68,"code":"  it('should observe delete operations', () => {\n    let dummy\n    const obj = reactive<{\n      prop?: string\n    }>({ prop: 'value' })\n    effect(() => (dummy = obj.prop))\n\n    expect(dummy).toBe('value')\n    delete obj.prop\n    expect(dummy).toBe(undefined)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe has operations","suites":["reactivity/effect"],"updatePoint":{"line":80,"column":35},"line":80,"code":"  it('should observe has operations', () => {\n    let dummy\n    const obj = reactive<{ prop?: string | number }>({ prop: 'value' })\n    effect(() => (dummy = 'prop' in obj))\n\n    expect(dummy).toBe(true)\n    delete obj.prop\n    expect(dummy).toBe(false)\n    obj.prop = 12\n    expect(dummy).toBe(true)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe properties on the prototype chain","suites":["reactivity/effect"],"updatePoint":{"line":92,"column":54},"line":92,"code":"  it('should observe properties on the prototype chain', () => {\n    let dummy\n    const counter = reactive<{ num?: number }>({ num: 0 })\n    const parentCounter = reactive({ num: 2 })\n    Object.setPrototypeOf(counter, parentCounter)\n    effect(() => (dummy = counter.num))\n\n    expect(dummy).toBe(0)\n    delete counter.num\n    expect(dummy).toBe(2)\n    parentCounter.num = 4\n    expect(dummy).toBe(4)\n    counter.num = 3\n    expect(dummy).toBe(3)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe has operations on the prototype chain","suites":["reactivity/effect"],"updatePoint":{"line":108,"column":58},"line":108,"code":"  it('should observe has operations on the prototype chain', () => {\n    let dummy\n    const counter = reactive<{ num?: number }>({ num: 0 })\n    const parentCounter = reactive<{ num?: number }>({ num: 2 })\n    Object.setPrototypeOf(counter, parentCounter)\n    effect(() => (dummy = 'num' in counter))\n\n    expect(dummy).toBe(true)\n    delete counter.num\n    expect(dummy).toBe(true)\n    delete parentCounter.num\n    expect(dummy).toBe(false)\n    counter.num = 3\n    expect(dummy).toBe(true)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe inherited property accessors","suites":["reactivity/effect"],"updatePoint":{"line":124,"column":49},"line":124,"code":"  it('should observe inherited property accessors', () => {\n    let dummy, parentDummy, hiddenValue: any\n    const obj = reactive<{ prop?: number }>({})\n    const parent = reactive({\n      set prop(value) {\n        hiddenValue = value\n      },\n      get prop() {\n        return hiddenValue\n      }\n    })\n    Object.setPrototypeOf(obj, parent)\n    effect(() => (dummy = obj.prop))\n    effect(() => (parentDummy = parent.prop))\n\n    expect(dummy).toBe(undefined)\n    expect(parentDummy).toBe(undefined)\n    obj.prop = 4\n    expect(dummy).toBe(4)\n    // this doesn't work, should it?\n    // expect(parentDummy).toBe(4)\n    parent.prop = 2\n    expect(dummy).toBe(2)\n    expect(parentDummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe function call chains","suites":["reactivity/effect"],"updatePoint":{"line":150,"column":41},"line":150,"code":"  it('should observe function call chains', () => {\n    let dummy\n    const counter = reactive({ num: 0 })\n    effect(() => (dummy = getNum()))\n\n    function getNum() {\n      return counter.num\n    }\n\n    expect(dummy).toBe(0)\n    counter.num = 2\n    expect(dummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe iteration","suites":["reactivity/effect"],"updatePoint":{"line":164,"column":30},"line":164,"code":"  it('should observe iteration', () => {\n    let dummy\n    const list = reactive(['Hello'])\n    effect(() => (dummy = list.join(' ')))\n\n    expect(dummy).toBe('Hello')\n    list.push('World!')\n    expect(dummy).toBe('Hello World!')\n    list.shift()\n    expect(dummy).toBe('World!')\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe implicit array length changes","suites":["reactivity/effect"],"updatePoint":{"line":176,"column":50},"line":176,"code":"  it('should observe implicit array length changes', () => {\n    let dummy\n    const list = reactive(['Hello'])\n    effect(() => (dummy = list.join(' ')))\n\n    expect(dummy).toBe('Hello')\n    list[1] = 'World!'\n    expect(dummy).toBe('Hello World!')\n    list[3] = 'Hello!'\n    expect(dummy).toBe('Hello World!  Hello!')\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe sparse array mutations","suites":["reactivity/effect"],"updatePoint":{"line":188,"column":43},"line":188,"code":"  it('should observe sparse array mutations', () => {\n    let dummy\n    const list = reactive<string[]>([])\n    list[1] = 'World!'\n    effect(() => (dummy = list.join(' ')))\n\n    expect(dummy).toBe(' World!')\n    list[0] = 'Hello'\n    expect(dummy).toBe('Hello World!')\n    list.pop()\n    expect(dummy).toBe('Hello')\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe enumeration","suites":["reactivity/effect"],"updatePoint":{"line":201,"column":32},"line":201,"code":"  it('should observe enumeration', () => {\n    let dummy = 0\n    const numbers = reactive<Record<string, number>>({ num1: 3 })\n    effect(() => {\n      dummy = 0\n      for (let key in numbers) {\n        dummy += numbers[key]\n      }\n    })\n\n    expect(dummy).toBe(3)\n    numbers.num2 = 4\n    expect(dummy).toBe(7)\n    delete numbers.num1\n    expect(dummy).toBe(4)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe symbol keyed properties","suites":["reactivity/effect"],"updatePoint":{"line":218,"column":44},"line":218,"code":"  it('should observe symbol keyed properties', () => {\n    const key = Symbol('symbol keyed prop')\n    let dummy, hasDummy\n    const obj = reactive<{ [key]?: string }>({ [key]: 'value' })\n    effect(() => (dummy = obj[key]))\n    effect(() => (hasDummy = key in obj))\n\n    expect(dummy).toBe('value')\n    expect(hasDummy).toBe(true)\n    obj[key] = 'newValue'\n    expect(dummy).toBe('newValue')\n    delete obj[key]\n    expect(dummy).toBe(undefined)\n    expect(hasDummy).toBe(false)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe well-known symbol keyed properties","suites":["reactivity/effect"],"updatePoint":{"line":234,"column":59},"line":234,"code":"  it('should not observe well-known symbol keyed properties', () => {\n    const key = Symbol.isConcatSpreadable\n    let dummy\n    const array: any = reactive([])\n    effect(() => (dummy = array[key]))\n\n    expect(array[key]).toBe(undefined)\n    expect(dummy).toBe(undefined)\n    array[key] = true\n    expect(array[key]).toBe(true)\n    expect(dummy).toBe(undefined)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe function valued properties","suites":["reactivity/effect"],"updatePoint":{"line":247,"column":47},"line":247,"code":"  it('should observe function valued properties', () => {\n    const oldFunc = () => {}\n    const newFunc = () => {}\n\n    let dummy\n    const obj = reactive({ func: oldFunc })\n    effect(() => (dummy = obj.func))\n\n    expect(dummy).toBe(oldFunc)\n    obj.func = newFunc\n    expect(dummy).toBe(newFunc)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe chained getters relying on this","suites":["reactivity/effect"],"updatePoint":{"line":260,"column":52},"line":260,"code":"  it('should observe chained getters relying on this', () => {\n    const obj = reactive({\n      a: 1,\n      get b() {\n        return this.a\n      }\n    })\n\n    let dummy\n    effect(() => (dummy = obj.b))\n    expect(dummy).toBe(1)\n    obj.a++\n    expect(dummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe methods relying on this","suites":["reactivity/effect"],"updatePoint":{"line":275,"column":44},"line":275,"code":"  it('should observe methods relying on this', () => {\n    const obj = reactive({\n      a: 1,\n      b() {\n        return this.a\n      }\n    })\n\n    let dummy\n    effect(() => (dummy = obj.b()))\n    expect(dummy).toBe(1)\n    obj.a++\n    expect(dummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe set operations without a value change","suites":["reactivity/effect"],"updatePoint":{"line":290,"column":62},"line":290,"code":"  it('should not observe set operations without a value change', () => {\n    let hasDummy, getDummy\n    const obj = reactive({ prop: 'value' })\n\n    const getSpy = vi.fn(() => (getDummy = obj.prop))\n    const hasSpy = vi.fn(() => (hasDummy = 'prop' in obj))\n    effect(getSpy)\n    effect(hasSpy)\n\n    expect(getDummy).toBe('value')\n    expect(hasDummy).toBe(true)\n    obj.prop = 'value'\n    expect(getSpy).toHaveBeenCalledTimes(1)\n    expect(hasSpy).toHaveBeenCalledTimes(1)\n    expect(getDummy).toBe('value')\n    expect(hasDummy).toBe(true)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe raw mutations","suites":["reactivity/effect"],"updatePoint":{"line":308,"column":38},"line":308,"code":"  it('should not observe raw mutations', () => {\n    let dummy\n    const obj = reactive<{ prop?: string }>({})\n    effect(() => (dummy = toRaw(obj).prop))\n\n    expect(dummy).toBe(undefined)\n    obj.prop = 'value'\n    expect(dummy).toBe(undefined)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by raw mutations","suites":["reactivity/effect"],"updatePoint":{"line":318,"column":46},"line":318,"code":"  it('should not be triggered by raw mutations', () => {\n    let dummy\n    const obj = reactive<{ prop?: string }>({})\n    effect(() => (dummy = obj.prop))\n\n    expect(dummy).toBe(undefined)\n    toRaw(obj).prop = 'value'\n    expect(dummy).toBe(undefined)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by inherited raw setters","suites":["reactivity/effect"],"updatePoint":{"line":328,"column":54},"line":328,"code":"  it('should not be triggered by inherited raw setters', () => {\n    let dummy, parentDummy, hiddenValue: any\n    const obj = reactive<{ prop?: number }>({})\n    const parent = reactive({\n      set prop(value) {\n        hiddenValue = value\n      },\n      get prop() {\n        return hiddenValue\n      }\n    })\n    Object.setPrototypeOf(obj, parent)\n    effect(() => (dummy = obj.prop))\n    effect(() => (parentDummy = parent.prop))\n\n    expect(dummy).toBe(undefined)\n    expect(parentDummy).toBe(undefined)\n    toRaw(obj).prop = 4\n    expect(dummy).toBe(undefined)\n    expect(parentDummy).toBe(undefined)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should avoid implicit infinite recursive loops with itself","suites":["reactivity/effect"],"updatePoint":{"line":350,"column":64},"line":350,"code":"  it('should avoid implicit infinite recursive loops with itself', () => {\n    const counter = reactive({ num: 0 })\n\n    const counterSpy = vi.fn(() => counter.num++)\n    effect(counterSpy)\n    expect(counter.num).toBe(1)\n    expect(counterSpy).toHaveBeenCalledTimes(1)\n    counter.num = 4\n    expect(counter.num).toBe(5)\n    expect(counterSpy).toHaveBeenCalledTimes(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should avoid infinite recursive loops when use Array.prototype.push/unshift/pop/shift","suites":["reactivity/effect"],"updatePoint":{"line":362,"column":91},"line":362,"code":"  it('should avoid infinite recursive loops when use Array.prototype.push/unshift/pop/shift', () => {\n    ;(['push', 'unshift'] as const).forEach(key => {\n      const arr = reactive<number[]>([])\n      const counterSpy1 = vi.fn(() => (arr[key] as any)(1))\n      const counterSpy2 = vi.fn(() => (arr[key] as any)(2))\n      effect(counterSpy1)\n      effect(counterSpy2)\n      expect(arr.length).toBe(2)\n      expect(counterSpy1).toHaveBeenCalledTimes(1)\n      expect(counterSpy2).toHaveBeenCalledTimes(1)\n    })\n    ;(['pop', 'shift'] as const).forEach(key => {\n      const arr = reactive<number[]>([1, 2, 3, 4])\n      const counterSpy1 = vi.fn(() => (arr[key] as any)())\n      const counterSpy2 = vi.fn(() => (arr[key] as any)())\n      effect(counterSpy1)\n      effect(counterSpy2)\n      expect(arr.length).toBe(2)\n      expect(counterSpy1).toHaveBeenCalledTimes(1)\n      expect(counterSpy2).toHaveBeenCalledTimes(1)\n    })\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should allow explicitly recursive raw function loops","suites":["reactivity/effect"],"updatePoint":{"line":385,"column":58},"line":385,"code":"  it('should allow explicitly recursive raw function loops', () => {\n    const counter = reactive({ num: 0 })\n    const numSpy = vi.fn(() => {\n      counter.num++\n      if (counter.num < 10) {\n        numSpy()\n      }\n    })\n    effect(numSpy)\n    expect(counter.num).toEqual(10)\n    expect(numSpy).toHaveBeenCalledTimes(10)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should avoid infinite loops with other effects","suites":["reactivity/effect"],"updatePoint":{"line":398,"column":52},"line":398,"code":"  it('should avoid infinite loops with other effects', () => {\n    const nums = reactive({ num1: 0, num2: 1 })\n\n    const spy1 = vi.fn(() => (nums.num1 = nums.num2))\n    const spy2 = vi.fn(() => (nums.num2 = nums.num1))\n    effect(spy1)\n    effect(spy2)\n    expect(nums.num1).toBe(1)\n    expect(nums.num2).toBe(1)\n    expect(spy1).toHaveBeenCalledTimes(1)\n    expect(spy2).toHaveBeenCalledTimes(1)\n    nums.num2 = 4\n    expect(nums.num1).toBe(4)\n    expect(nums.num2).toBe(4)\n    expect(spy1).toHaveBeenCalledTimes(2)\n    expect(spy2).toHaveBeenCalledTimes(2)\n    nums.num1 = 10\n    expect(nums.num1).toBe(10)\n    expect(nums.num2).toBe(10)\n    expect(spy1).toHaveBeenCalledTimes(3)\n    expect(spy2).toHaveBeenCalledTimes(3)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return a new reactive version of the function","suites":["reactivity/effect"],"updatePoint":{"line":421,"column":58},"line":421,"code":"  it('should return a new reactive version of the function', () => {\n    function greet() {\n      return 'Hello World'\n    }\n    const effect1 = effect(greet)\n    const effect2 = effect(greet)\n    expect(typeof effect1).toBe('function')\n    expect(typeof effect2).toBe('function')\n    expect(effect1).not.toBe(greet)\n    expect(effect1).not.toBe(effect2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should discover new branches while running automatically","suites":["reactivity/effect"],"updatePoint":{"line":433,"column":62},"line":433,"code":"  it('should discover new branches while running automatically', () => {\n    let dummy\n    const obj = reactive({ prop: 'value', run: false })\n\n    const conditionalSpy = vi.fn(() => {\n      dummy = obj.run ? obj.prop : 'other'\n    })\n    effect(conditionalSpy)\n\n    expect(dummy).toBe('other')\n    expect(conditionalSpy).toHaveBeenCalledTimes(1)\n    obj.prop = 'Hi'\n    expect(dummy).toBe('other')\n    expect(conditionalSpy).toHaveBeenCalledTimes(1)\n    obj.run = true\n    expect(dummy).toBe('Hi')\n    expect(conditionalSpy).toHaveBeenCalledTimes(2)\n    obj.prop = 'World'\n    expect(dummy).toBe('World')\n    expect(conditionalSpy).toHaveBeenCalledTimes(3)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should discover new branches when running manually","suites":["reactivity/effect"],"updatePoint":{"line":455,"column":56},"line":455,"code":"  it('should discover new branches when running manually', () => {\n    let dummy\n    let run = false\n    const obj = reactive({ prop: 'value' })\n    const runner = effect(() => {\n      dummy = run ? obj.prop : 'other'\n    })\n\n    expect(dummy).toBe('other')\n    runner()\n    expect(dummy).toBe('other')\n    run = true\n    runner()\n    expect(dummy).toBe('value')\n    obj.prop = 'World'\n    expect(dummy).toBe('World')\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered by mutating a property, which is used in an inactive branch","suites":["reactivity/effect"],"updatePoint":{"line":473,"column":89},"line":473,"code":"  it('should not be triggered by mutating a property, which is used in an inactive branch', () => {\n    let dummy\n    const obj = reactive({ prop: 'value', run: true })\n\n    const conditionalSpy = vi.fn(() => {\n      dummy = obj.run ? obj.prop : 'other'\n    })\n    effect(conditionalSpy)\n\n    expect(dummy).toBe('value')\n    expect(conditionalSpy).toHaveBeenCalledTimes(1)\n    obj.run = false\n    expect(dummy).toBe('other')\n    expect(conditionalSpy).toHaveBeenCalledTimes(2)\n    obj.prop = 'value2'\n    expect(dummy).toBe('other')\n    expect(conditionalSpy).toHaveBeenCalledTimes(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should handle deep effect recursion using cleanup fallback","suites":["reactivity/effect"],"updatePoint":{"line":492,"column":64},"line":492,"code":"  it('should handle deep effect recursion using cleanup fallback', () => {\n    const results = reactive([0])\n    const effects: { fx: ReactiveEffectRunner; index: number }[] = []\n    for (let i = 1; i < 40; i++) {\n      ;(index => {\n        const fx = effect(() => {\n          results[index] = results[index - 1] * 2\n        })\n        effects.push({ fx, index })\n      })(i)\n    }\n\n    expect(results[39]).toBe(0)\n    results[0] = 1\n    expect(results[39]).toBe(Math.pow(2, 39))\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should register deps independently during effect recursion","suites":["reactivity/effect"],"updatePoint":{"line":509,"column":64},"line":509,"code":"  it('should register deps independently during effect recursion', () => {\n    const input = reactive({ a: 1, b: 2, c: 0 })\n    const output = reactive({ fx1: 0, fx2: 0 })\n\n    const fx1Spy = vi.fn(() => {\n      let result = 0\n      if (input.c < 2) result += input.a\n      if (input.c > 1) result += input.b\n      output.fx1 = result\n    })\n\n    const fx1 = effect(fx1Spy)\n\n    const fx2Spy = vi.fn(() => {\n      let result = 0\n      if (input.c > 1) result += input.a\n      if (input.c < 3) result += input.b\n      output.fx2 = result + output.fx1\n    })\n\n    const fx2 = effect(fx2Spy)\n\n    expect(fx1).not.toBeNull()\n    expect(fx2).not.toBeNull()\n\n    expect(output.fx1).toBe(1)\n    expect(output.fx2).toBe(2 + 1)\n    expect(fx1Spy).toHaveBeenCalledTimes(1)\n    expect(fx2Spy).toHaveBeenCalledTimes(1)\n\n    fx1Spy.mockClear()\n    fx2Spy.mockClear()\n    input.b = 3\n    expect(output.fx1).toBe(1)\n    expect(output.fx2).toBe(3 + 1)\n    expect(fx1Spy).toHaveBeenCalledTimes(0)\n    expect(fx2Spy).toHaveBeenCalledTimes(1)\n\n    fx1Spy.mockClear()\n    fx2Spy.mockClear()\n    input.c = 1\n    expect(output.fx1).toBe(1)\n    expect(output.fx2).toBe(3 + 1)\n    expect(fx1Spy).toHaveBeenCalledTimes(1)\n    expect(fx2Spy).toHaveBeenCalledTimes(1)\n\n    fx1Spy.mockClear()\n    fx2Spy.mockClear()\n    input.c = 2\n    expect(output.fx1).toBe(3)\n    expect(output.fx2).toBe(1 + 3 + 3)\n    expect(fx1Spy).toHaveBeenCalledTimes(1)\n\n    // Invoked twice due to change of fx1.\n    expect(fx2Spy).toHaveBeenCalledTimes(2)\n\n    fx1Spy.mockClear()\n    fx2Spy.mockClear()\n    input.c = 3\n    expect(output.fx1).toBe(3)\n    expect(output.fx2).toBe(1 + 3)\n    expect(fx1Spy).toHaveBeenCalledTimes(1)\n    expect(fx2Spy).toHaveBeenCalledTimes(1)\n\n    fx1Spy.mockClear()\n    fx2Spy.mockClear()\n    input.a = 10\n    expect(output.fx1).toBe(3)\n    expect(output.fx2).toBe(10 + 3)\n    expect(fx1Spy).toHaveBeenCalledTimes(0)\n    expect(fx2Spy).toHaveBeenCalledTimes(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not double wrap if the passed function is a effect","suites":["reactivity/effect"],"updatePoint":{"line":582,"column":63},"line":582,"code":"  it('should not double wrap if the passed function is a effect', () => {\n    const runner = effect(() => {})\n    const otherRunner = effect(runner)\n    expect(runner).not.toBe(otherRunner)\n    expect(runner.effect.fn).toBe(otherRunner.effect.fn)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not run multiple times for a single mutation","suites":["reactivity/effect"],"updatePoint":{"line":589,"column":57},"line":589,"code":"  it('should not run multiple times for a single mutation', () => {\n    let dummy\n    const obj = reactive<Record<string, number>>({})\n    const fnSpy = vi.fn(() => {\n      for (const key in obj) {\n        dummy = obj[key]\n      }\n      dummy = obj.prop\n    })\n    effect(fnSpy)\n\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n    obj.prop = 16\n    expect(dummy).toBe(16)\n    expect(fnSpy).toHaveBeenCalledTimes(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should allow nested effects","suites":["reactivity/effect"],"updatePoint":{"line":606,"column":33},"line":606,"code":"  it('should allow nested effects', () => {\n    const nums = reactive({ num1: 0, num2: 1, num3: 2 })\n    const dummy: any = {}\n\n    const childSpy = vi.fn(() => (dummy.num1 = nums.num1))\n    const childeffect = effect(childSpy)\n    const parentSpy = vi.fn(() => {\n      dummy.num2 = nums.num2\n      childeffect()\n      dummy.num3 = nums.num3\n    })\n    effect(parentSpy)\n\n    expect(dummy).toEqual({ num1: 0, num2: 1, num3: 2 })\n    expect(parentSpy).toHaveBeenCalledTimes(1)\n    expect(childSpy).toHaveBeenCalledTimes(2)\n    // this should only call the childeffect\n    nums.num1 = 4\n    expect(dummy).toEqual({ num1: 4, num2: 1, num3: 2 })\n    expect(parentSpy).toHaveBeenCalledTimes(1)\n    expect(childSpy).toHaveBeenCalledTimes(3)\n    // this calls the parenteffect, which calls the childeffect once\n    nums.num2 = 10\n    expect(dummy).toEqual({ num1: 4, num2: 10, num3: 2 })\n    expect(parentSpy).toHaveBeenCalledTimes(2)\n    expect(childSpy).toHaveBeenCalledTimes(4)\n    // this calls the parenteffect, which calls the childeffect once\n    nums.num3 = 7\n    expect(dummy).toEqual({ num1: 4, num2: 10, num3: 7 })\n    expect(parentSpy).toHaveBeenCalledTimes(3)\n    expect(childSpy).toHaveBeenCalledTimes(5)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe json methods","suites":["reactivity/effect"],"updatePoint":{"line":639,"column":33},"line":639,"code":"  it('should observe json methods', () => {\n    let dummy = <Record<string, number>>{}\n    const obj = reactive<Record<string, number>>({})\n    effect(() => {\n      dummy = JSON.parse(JSON.stringify(obj))\n    })\n    obj.a = 1\n    expect(dummy.a).toBe(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should observe class method invocations","suites":["reactivity/effect"],"updatePoint":{"line":649,"column":45},"line":649,"code":"  it('should observe class method invocations', () => {\n    class Model {\n      count: number\n      constructor() {\n        this.count = 0\n      }\n      inc() {\n        this.count++\n      }\n    }\n    const model = reactive(new Model())\n    let dummy\n    effect(() => {\n      dummy = model.count\n    })\n    expect(dummy).toBe(0)\n    model.inc()\n    expect(dummy).toBe(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"lazy","suites":["reactivity/effect"],"updatePoint":{"line":669,"column":10},"line":669,"code":"  it('lazy', () => {\n    const obj = reactive({ foo: 1 })\n    let dummy\n    const runner = effect(() => (dummy = obj.foo), { lazy: true })\n    expect(dummy).toBe(undefined)\n\n    expect(runner()).toBe(1)\n    expect(dummy).toBe(1)\n    obj.foo = 2\n    expect(dummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"scheduler","suites":["reactivity/effect"],"updatePoint":{"line":681,"column":15},"line":681,"code":"  it('scheduler', () => {\n    let dummy\n    let run: any\n    const scheduler = vi.fn(() => {\n      run = runner\n    })\n    const obj = reactive({ foo: 1 })\n    const runner = effect(\n      () => {\n        dummy = obj.foo\n      },\n      { scheduler }\n    )\n    expect(scheduler).not.toHaveBeenCalled()\n    expect(dummy).toBe(1)\n    // should be called on first trigger\n    obj.foo++\n    expect(scheduler).toHaveBeenCalledTimes(1)\n    // should not run yet\n    expect(dummy).toBe(1)\n    // manually run\n    run()\n    // should have run\n    expect(dummy).toBe(2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"events: onTrack","suites":["reactivity/effect"],"updatePoint":{"line":707,"column":21},"line":707,"code":"  it('events: onTrack', () => {\n    let events: DebuggerEvent[] = []\n    let dummy\n    const onTrack = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive({ foo: 1, bar: 2 })\n    const runner = effect(\n      () => {\n        dummy = obj.foo\n        dummy = 'bar' in obj\n        dummy = Object.keys(obj)\n      },\n      { onTrack }\n    )\n    expect(dummy).toEqual(['foo', 'bar'])\n    expect(onTrack).toHaveBeenCalledTimes(3)\n    expect(events).toEqual([\n      {\n        effect: runner.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.GET,\n        key: 'foo'\n      },\n      {\n        effect: runner.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.HAS,\n        key: 'bar'\n      },\n      {\n        effect: runner.effect,\n        target: toRaw(obj),\n        type: TrackOpTypes.ITERATE,\n        key: ITERATE_KEY\n      }\n    ])\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"events: onTrigger","suites":["reactivity/effect"],"updatePoint":{"line":746,"column":23},"line":746,"code":"  it('events: onTrigger', () => {\n    let events: DebuggerEvent[] = []\n    let dummy\n    const onTrigger = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive<{ foo?: number }>({ foo: 1 })\n    const runner = effect(\n      () => {\n        dummy = obj.foo\n      },\n      { onTrigger }\n    )\n\n    obj.foo!++\n    expect(dummy).toBe(2)\n    expect(onTrigger).toHaveBeenCalledTimes(1)\n    expect(events[0]).toEqual({\n      effect: runner.effect,\n      target: toRaw(obj),\n      type: TriggerOpTypes.SET,\n      key: 'foo',\n      oldValue: 1,\n      newValue: 2\n    })\n\n    delete obj.foo\n    expect(dummy).toBeUndefined()\n    expect(onTrigger).toHaveBeenCalledTimes(2)\n    expect(events[1]).toEqual({\n      effect: runner.effect,\n      target: toRaw(obj),\n      type: TriggerOpTypes.DELETE,\n      key: 'foo',\n      oldValue: 2\n    })\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"stop","suites":["reactivity/effect"],"updatePoint":{"line":784,"column":10},"line":784,"code":"  it('stop', () => {\n    let dummy\n    const obj = reactive({ prop: 1 })\n    const runner = effect(() => {\n      dummy = obj.prop\n    })\n    obj.prop = 2\n    expect(dummy).toBe(2)\n    stop(runner)\n    obj.prop = 3\n    expect(dummy).toBe(2)\n\n    // stopped effect should still be manually callable\n    runner()\n    expect(dummy).toBe(3)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"edge case: self-stopping effect tracking ref","suites":["reactivity/effect"],"updatePoint":{"line":805,"column":50},"line":805,"code":"  it('edge case: self-stopping effect tracking ref', () => {\n    const c = ref(true)\n    const runner = effect(() => {\n      // reference ref\n      if (!c.value) {\n        // stop itself while running\n        stop(runner)\n      }\n    })\n    // trigger run\n    c.value = !c.value\n    // should clear bits\n    expect((c as any).dep.w).toBe(0)\n    expect((c as any).dep.n).toBe(0)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"events: onStop","suites":["reactivity/effect"],"updatePoint":{"line":821,"column":20},"line":821,"code":"  it('events: onStop', () => {\n    const onStop = vi.fn()\n    const runner = effect(() => {}, {\n      onStop\n    })\n\n    stop(runner)\n    expect(onStop).toHaveBeenCalled()\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"stop: a stopped effect is nested in a normal effect","suites":["reactivity/effect"],"updatePoint":{"line":831,"column":57},"line":831,"code":"  it('stop: a stopped effect is nested in a normal effect', () => {\n    let dummy\n    const obj = reactive({ prop: 1 })\n    const runner = effect(() => {\n      dummy = obj.prop\n    })\n    stop(runner)\n    obj.prop = 2\n    expect(dummy).toBe(1)\n\n    // observed value in inner stopped effect\n    // will track outer effect as an dependency\n    effect(() => {\n      runner()\n    })\n    expect(dummy).toBe(2)\n\n    // notify outer effect to run\n    obj.prop = 3\n    expect(dummy).toBe(3)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"markRaw","suites":["reactivity/effect"],"updatePoint":{"line":853,"column":13},"line":853,"code":"  it('markRaw', () => {\n    const obj = reactive({\n      foo: markRaw({\n        prop: 0\n      })\n    })\n    let dummy\n    effect(() => {\n      dummy = obj.foo.prop\n    })\n    expect(dummy).toBe(0)\n    obj.foo.prop++\n    expect(dummy).toBe(0)\n    obj.foo = { prop: 1 }\n    expect(dummy).toBe(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered when the value and the old value both are NaN","suites":["reactivity/effect"],"updatePoint":{"line":870,"column":75},"line":870,"code":"  it('should not be triggered when the value and the old value both are NaN', () => {\n    const obj = reactive({\n      foo: NaN\n    })\n    const fnSpy = vi.fn(() => obj.foo)\n    effect(fnSpy)\n    obj.foo = NaN\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should trigger all effects when array length is set to 0","suites":["reactivity/effect"],"updatePoint":{"line":880,"column":62},"line":880,"code":"  it('should trigger all effects when array length is set to 0', () => {\n    const observed: any = reactive([1])\n    let dummy, record\n    effect(() => {\n      dummy = observed.length\n    })\n    effect(() => {\n      record = observed[0]\n    })\n    expect(dummy).toBe(1)\n    expect(record).toBe(1)\n\n    observed[1] = 2\n    expect(observed[1]).toBe(2)\n\n    observed.unshift(3)\n    expect(dummy).toBe(3)\n    expect(record).toBe(3)\n\n    observed.length = 0\n    expect(dummy).toBe(0)\n    expect(record).toBeUndefined()\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not be triggered when set with the same proxy","suites":["reactivity/effect"],"updatePoint":{"line":904,"column":58},"line":904,"code":"  it('should not be triggered when set with the same proxy', () => {\n    const obj = reactive({ foo: 1 })\n    const observed: any = reactive({ obj })\n    const fnSpy = vi.fn(() => observed.obj)\n\n    effect(fnSpy)\n\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n    observed.obj = obj\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n\n    const obj2 = reactive({ foo: 1 })\n    const observed2: any = shallowReactive({ obj2 })\n    const fnSpy2 = vi.fn(() => observed2.obj2)\n\n    effect(fnSpy2)\n\n    expect(fnSpy2).toHaveBeenCalledTimes(1)\n    observed2.obj2 = obj2\n    expect(fnSpy2).toHaveBeenCalledTimes(1)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be triggered when set length with string","suites":["reactivity/effect"],"updatePoint":{"line":926,"column":53},"line":926,"code":"  it('should be triggered when set length with string', () => {\n    let ret1 = 'idle'\n    let ret2 = 'idle'\n    const arr1 = reactive(new Array(11).fill(0))\n    const arr2 = reactive(new Array(11).fill(0))\n    effect(() => {\n      ret1 = arr1[10] === undefined ? 'arr[10] is set to empty' : 'idle'\n    })\n    effect(() => {\n      ret2 = arr2[10] === undefined ? 'arr[10] is set to empty' : 'idle'\n    })\n    arr1.length = 2\n    arr2.length = '2' as any\n    expect(ret1).toBe(ret2)\n  })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work with readonly(reactive(Map))","suites":["reactivity/effect","readonly + reactive for Map"],"updatePoint":{"line":943,"column":50},"line":943,"code":"    test('should work with readonly(reactive(Map))', () => {\n      const m = reactive(new Map())\n      const roM = readonly(m)\n      const fnSpy = vi.fn(() => roM.get(1))\n\n      effect(fnSpy)\n      expect(fnSpy).toHaveBeenCalledTimes(1)\n      m.set(1, 1)\n      expect(fnSpy).toHaveBeenCalledTimes(2)\n    })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work with observed value as key","suites":["reactivity/effect","readonly + reactive for Map"],"updatePoint":{"line":954,"column":48},"line":954,"code":"    test('should work with observed value as key', () => {\n      const key = reactive({})\n      const m = reactive(new Map())\n      m.set(key, 1)\n      const roM = readonly(m)\n      const fnSpy = vi.fn(() => roM.get(key))\n\n      effect(fnSpy)\n      expect(fnSpy).toHaveBeenCalledTimes(1)\n      m.set(key, 1)\n      expect(fnSpy).toHaveBeenCalledTimes(1)\n      m.set(key, 2)\n      expect(fnSpy).toHaveBeenCalledTimes(2)\n    })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should track hasOwnProperty","suites":["reactivity/effect","readonly + reactive for Map"],"updatePoint":{"line":969,"column":37},"line":969,"code":"    test('should track hasOwnProperty', () => {\n      const obj: any = reactive({})\n      let has = false\n      const fnSpy = vi.fn()\n\n      effect(() => {\n        fnSpy()\n        has = obj.hasOwnProperty('foo')\n      })\n      expect(fnSpy).toHaveBeenCalledTimes(1)\n      expect(has).toBe(false)\n\n      obj.foo = 1\n      expect(fnSpy).toHaveBeenCalledTimes(2)\n      expect(has).toBe(true)\n\n      delete obj.foo\n      expect(fnSpy).toHaveBeenCalledTimes(3)\n      expect(has).toBe(false)\n\n      // should not trigger on unrelated key\n      obj.bar = 2\n      expect(fnSpy).toHaveBeenCalledTimes(3)\n      expect(has).toBe(false)\n    })","file":"effect.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should run","suites":["reactivity/effect/scope"],"updatePoint":{"line":15,"column":16},"line":15,"code":"  it('should run', () => {\n    const fnSpy = vi.fn(() => {})\n    new EffectScope().run(fnSpy)\n    expect(fnSpy).toHaveBeenCalledTimes(1)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should accept zero argument","suites":["reactivity/effect/scope"],"updatePoint":{"line":21,"column":33},"line":21,"code":"  it('should accept zero argument', () => {\n    const scope = new EffectScope()\n    expect(scope.effects.length).toBe(0)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should return run value","suites":["reactivity/effect/scope"],"updatePoint":{"line":26,"column":29},"line":26,"code":"  it('should return run value', () => {\n    expect(new EffectScope().run(() => 1)).toBe(1)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work w/ active property","suites":["reactivity/effect/scope"],"updatePoint":{"line":30,"column":36},"line":30,"code":"  it('should work w/ active property', () => {\n    const scope = new EffectScope()\n    scope.run(() => 1)\n    expect(scope.active).toBe(true)\n    scope.stop()\n    expect(scope.active).toBe(false)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should collect the effects","suites":["reactivity/effect/scope"],"updatePoint":{"line":38,"column":32},"line":38,"code":"  it('should collect the effects', () => {\n    const scope = new EffectScope()\n    scope.run(() => {\n      let dummy\n      const counter = reactive({ num: 0 })\n      effect(() => (dummy = counter.num))\n\n      expect(dummy).toBe(0)\n      counter.num = 7\n      expect(dummy).toBe(7)\n    })\n\n    expect(scope.effects.length).toBe(1)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"stop","suites":["reactivity/effect/scope"],"updatePoint":{"line":53,"column":10},"line":53,"code":"  it('stop', () => {\n    let dummy, doubled\n    const counter = reactive({ num: 0 })\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      effect(() => (dummy = counter.num))\n      effect(() => (doubled = counter.num * 2))\n    })\n\n    expect(scope.effects.length).toBe(2)\n\n    expect(dummy).toBe(0)\n    counter.num = 7\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n\n    scope.stop()\n\n    counter.num = 6\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should collect nested scope","suites":["reactivity/effect/scope"],"updatePoint":{"line":77,"column":33},"line":77,"code":"  it('should collect nested scope', () => {\n    let dummy, doubled\n    const counter = reactive({ num: 0 })\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      effect(() => (dummy = counter.num))\n      // nested scope\n      new EffectScope().run(() => {\n        effect(() => (doubled = counter.num * 2))\n      })\n    })\n\n    expect(scope.effects.length).toBe(1)\n    expect(scope.scopes!.length).toBe(1)\n    expect(scope.scopes![0]).toBeInstanceOf(EffectScope)\n\n    expect(dummy).toBe(0)\n    counter.num = 7\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n\n    // stop the nested scope as well\n    scope.stop()\n\n    counter.num = 6\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"nested scope can be escaped","suites":["reactivity/effect/scope"],"updatePoint":{"line":107,"column":33},"line":107,"code":"  it('nested scope can be escaped', () => {\n    let dummy, doubled\n    const counter = reactive({ num: 0 })\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      effect(() => (dummy = counter.num))\n      // nested scope\n      new EffectScope(true).run(() => {\n        effect(() => (doubled = counter.num * 2))\n      })\n    })\n\n    expect(scope.effects.length).toBe(1)\n\n    expect(dummy).toBe(0)\n    counter.num = 7\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n\n    scope.stop()\n\n    counter.num = 6\n    expect(dummy).toBe(7)\n\n    // nested scope should not be stopped\n    expect(doubled).toBe(12)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"able to run the scope","suites":["reactivity/effect/scope"],"updatePoint":{"line":136,"column":27},"line":136,"code":"  it('able to run the scope', () => {\n    let dummy, doubled\n    const counter = reactive({ num: 0 })\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      effect(() => (dummy = counter.num))\n    })\n\n    expect(scope.effects.length).toBe(1)\n\n    scope.run(() => {\n      effect(() => (doubled = counter.num * 2))\n    })\n\n    expect(scope.effects.length).toBe(2)\n\n    counter.num = 7\n    expect(dummy).toBe(7)\n    expect(doubled).toBe(14)\n\n    scope.stop()\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"can not run an inactive scope","suites":["reactivity/effect/scope"],"updatePoint":{"line":160,"column":35},"line":160,"code":"  it('can not run an inactive scope', () => {\n    let dummy, doubled\n    const counter = reactive({ num: 0 })\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      effect(() => (dummy = counter.num))\n    })\n\n    expect(scope.effects.length).toBe(1)\n\n    scope.stop()\n\n    scope.run(() => {\n      effect(() => (doubled = counter.num * 2))\n    })\n\n    expect('[Vue warn] cannot run an inactive effect scope.').toHaveBeenWarned()\n\n    expect(scope.effects.length).toBe(1)\n\n    counter.num = 7\n    expect(dummy).toBe(0)\n    expect(doubled).toBe(undefined)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should fire onScopeDispose hook","suites":["reactivity/effect/scope"],"updatePoint":{"line":186,"column":37},"line":186,"code":"  it('should fire onScopeDispose hook', () => {\n    let dummy = 0\n\n    const scope = new EffectScope()\n    scope.run(() => {\n      onScopeDispose(() => (dummy += 1))\n      onScopeDispose(() => (dummy += 2))\n    })\n\n    scope.run(() => {\n      onScopeDispose(() => (dummy += 4))\n    })\n\n    expect(dummy).toBe(0)\n\n    scope.stop()\n    expect(dummy).toBe(7)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should warn onScopeDispose() is called when there is no active effect scope","suites":["reactivity/effect/scope"],"updatePoint":{"line":205,"column":81},"line":205,"code":"  it('should warn onScopeDispose() is called when there is no active effect scope', () => {\n    const spy = vi.fn()\n    const scope = new EffectScope()\n    scope.run(() => {\n      onScopeDispose(spy)\n    })\n\n    expect(spy).toHaveBeenCalledTimes(0)\n\n    onScopeDispose(spy)\n\n    expect(\n      '[Vue warn] onScopeDispose() is called when there is no active effect scope to be associated with.'\n    ).toHaveBeenWarned()\n\n    scope.stop()\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should dereference child scope from parent scope after stopping child scope (no memleaks)","suites":["reactivity/effect/scope"],"updatePoint":{"line":224,"column":95},"line":224,"code":"  it('should dereference child scope from parent scope after stopping child scope (no memleaks)', () => {\n    const parent = new EffectScope()\n    const child = parent.run(() => new EffectScope())!\n    expect(parent.scopes!.includes(child)).toBe(true)\n    child.stop()\n    expect(parent.scopes!.includes(child)).toBe(false)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"test with higher level APIs","suites":["reactivity/effect/scope"],"updatePoint":{"line":232,"column":33},"line":232,"code":"  it('test with higher level APIs', async () => {\n    const r = ref(1)\n\n    const computedSpy = vi.fn()\n    const watchSpy = vi.fn()\n    const watchEffectSpy = vi.fn()\n\n    let c: ComputedRef\n    const scope = new EffectScope()\n    scope.run(() => {\n      c = computed(() => {\n        computedSpy()\n        return r.value + 1\n      })\n\n      watch(r, watchSpy)\n      watchEffect(() => {\n        watchEffectSpy()\n        r.value\n      })\n    })\n\n    c!.value // computed is lazy so trigger collection\n    expect(computedSpy).toHaveBeenCalledTimes(1)\n    expect(watchSpy).toHaveBeenCalledTimes(0)\n    expect(watchEffectSpy).toHaveBeenCalledTimes(1)\n\n    r.value++\n    c!.value\n    await nextTick()\n    expect(computedSpy).toHaveBeenCalledTimes(2)\n    expect(watchSpy).toHaveBeenCalledTimes(1)\n    expect(watchEffectSpy).toHaveBeenCalledTimes(2)\n\n    scope.stop()\n\n    r.value++\n    c!.value\n    await nextTick()\n    // should not trigger anymore\n    expect(computedSpy).toHaveBeenCalledTimes(2)\n    expect(watchSpy).toHaveBeenCalledTimes(1)\n    expect(watchEffectSpy).toHaveBeenCalledTimes(2)\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"getCurrentScope() stays valid when running a detached nested EffectScope","suites":["reactivity/effect/scope"],"updatePoint":{"line":277,"column":78},"line":277,"code":"  it('getCurrentScope() stays valid when running a detached nested EffectScope', () => {\n    const parentScope = new EffectScope()\n\n    parentScope.run(() => {\n      const currentScope = getCurrentScope()\n      expect(currentScope).toBeDefined()\n      const detachedScope = new EffectScope(true)\n      detachedScope.run(() => {})\n\n      expect(getCurrentScope()).toBe(currentScope)\n    })\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calling .off() of a detached scope inside an active scope should not break currentScope","suites":["reactivity/effect/scope"],"updatePoint":{"line":290,"column":93},"line":290,"code":"  it('calling .off() of a detached scope inside an active scope should not break currentScope', () => {\n    const parentScope = new EffectScope()\n\n    parentScope.run(() => {\n      const childScope = new EffectScope(true)\n      childScope.on()\n      childScope.off()\n      expect(getCurrentScope()).toBe(parentScope)\n    })\n  })","file":"effectScope.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"Object","suites":["reactivity/reactive"],"updatePoint":{"line":7,"column":14},"line":7,"code":"  test('Object', () => {\n    const original = { foo: 1 }\n    const observed = reactive(original)\n    expect(observed).not.toBe(original)\n    expect(isReactive(observed)).toBe(true)\n    expect(isReactive(original)).toBe(false)\n    // get\n    expect(observed.foo).toBe(1)\n    // has\n    expect('foo' in observed).toBe(true)\n    // ownKeys\n    expect(Object.keys(observed)).toEqual(['foo'])\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"proto","suites":["reactivity/reactive"],"updatePoint":{"line":21,"column":13},"line":21,"code":"  test('proto', () => {\n    const obj = {}\n    const reactiveObj = reactive(obj)\n    expect(isReactive(reactiveObj)).toBe(true)\n    // read prop of reactiveObject will cause reactiveObj[prop] to be reactive\n    // @ts-ignore\n    const prototype = reactiveObj['__proto__']\n    const otherObj = { data: ['a'] }\n    expect(isReactive(otherObj)).toBe(false)\n    const reactiveOther = reactive(otherObj)\n    expect(isReactive(reactiveOther)).toBe(true)\n    expect(reactiveOther.data[0]).toBe('a')\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"nested reactives","suites":["reactivity/reactive"],"updatePoint":{"line":35,"column":24},"line":35,"code":"  test('nested reactives', () => {\n    const original = {\n      nested: {\n        foo: 1\n      },\n      array: [{ bar: 2 }]\n    }\n    const observed = reactive(original)\n    expect(isReactive(observed.nested)).toBe(true)\n    expect(isReactive(observed.array)).toBe(true)\n    expect(isReactive(observed.array[0])).toBe(true)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observing subtypes of IterableCollections(Map, Set)","suites":["reactivity/reactive"],"updatePoint":{"line":48,"column":59},"line":48,"code":"  test('observing subtypes of IterableCollections(Map, Set)', () => {\n    // subtypes of Map\n    class CustomMap extends Map {}\n    const cmap = reactive(new CustomMap())\n\n    expect(cmap instanceof Map).toBe(true)\n    expect(isReactive(cmap)).toBe(true)\n\n    cmap.set('key', {})\n    expect(isReactive(cmap.get('key'))).toBe(true)\n\n    // subtypes of Set\n    class CustomSet extends Set {}\n    const cset = reactive(new CustomSet())\n\n    expect(cset instanceof Set).toBe(true)\n    expect(isReactive(cset)).toBe(true)\n\n    let dummy\n    effect(() => (dummy = cset.has('value')))\n    expect(dummy).toBe(false)\n    cset.add('value')\n    expect(dummy).toBe(true)\n    cset.delete('value')\n    expect(dummy).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observing subtypes of WeakCollections(WeakMap, WeakSet)","suites":["reactivity/reactive"],"updatePoint":{"line":75,"column":63},"line":75,"code":"  test('observing subtypes of WeakCollections(WeakMap, WeakSet)', () => {\n    // subtypes of WeakMap\n    class CustomMap extends WeakMap {}\n    const cmap = reactive(new CustomMap())\n\n    expect(cmap instanceof WeakMap).toBe(true)\n    expect(isReactive(cmap)).toBe(true)\n\n    const key = {}\n    cmap.set(key, {})\n    expect(isReactive(cmap.get(key))).toBe(true)\n\n    // subtypes of WeakSet\n    class CustomSet extends WeakSet {}\n    const cset = reactive(new CustomSet())\n\n    expect(cset instanceof WeakSet).toBe(true)\n    expect(isReactive(cset)).toBe(true)\n\n    let dummy\n    effect(() => (dummy = cset.has(key)))\n    expect(dummy).toBe(false)\n    cset.add(key)\n    expect(dummy).toBe(true)\n    cset.delete(key)\n    expect(dummy).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observed value should proxy mutations to original (Object)","suites":["reactivity/reactive"],"updatePoint":{"line":103,"column":66},"line":103,"code":"  test('observed value should proxy mutations to original (Object)', () => {\n    const original: any = { foo: 1 }\n    const observed = reactive(original)\n    // set\n    observed.bar = 1\n    expect(observed.bar).toBe(1)\n    expect(original.bar).toBe(1)\n    // delete\n    delete observed.foo\n    expect('foo' in observed).toBe(false)\n    expect('foo' in original).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"original value change should reflect in observed value (Object)","suites":["reactivity/reactive"],"updatePoint":{"line":116,"column":71},"line":116,"code":"  test('original value change should reflect in observed value (Object)', () => {\n    const original: any = { foo: 1 }\n    const observed = reactive(original)\n    // set\n    original.bar = 1\n    expect(original.bar).toBe(1)\n    expect(observed.bar).toBe(1)\n    // delete\n    delete original.foo\n    expect('foo' in original).toBe(false)\n    expect('foo' in observed).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"setting a property with an unobserved value should wrap with reactive","suites":["reactivity/reactive"],"updatePoint":{"line":129,"column":77},"line":129,"code":"  test('setting a property with an unobserved value should wrap with reactive', () => {\n    const observed = reactive<{ foo?: object }>({})\n    const raw = {}\n    observed.foo = raw\n    expect(observed.foo).not.toBe(raw)\n    expect(isReactive(observed.foo)).toBe(true)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observing already observed value should return same Proxy","suites":["reactivity/reactive"],"updatePoint":{"line":137,"column":65},"line":137,"code":"  test('observing already observed value should return same Proxy', () => {\n    const original = { foo: 1 }\n    const observed = reactive(original)\n    const observed2 = reactive(observed)\n    expect(observed2).toBe(observed)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observing the same value multiple times should return same Proxy","suites":["reactivity/reactive"],"updatePoint":{"line":144,"column":72},"line":144,"code":"  test('observing the same value multiple times should return same Proxy', () => {\n    const original = { foo: 1 }\n    const observed = reactive(original)\n    const observed2 = reactive(original)\n    expect(observed2).toBe(observed)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not pollute original object with Proxies","suites":["reactivity/reactive"],"updatePoint":{"line":151,"column":55},"line":151,"code":"  test('should not pollute original object with Proxies', () => {\n    const original: any = { foo: 1 }\n    const original2 = { bar: 2 }\n    const observed = reactive(original)\n    const observed2 = reactive(original2)\n    observed.bar = observed2\n    expect(observed.bar).toBe(observed2)\n    expect(original.bar).toBe(original2)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRaw","suites":["reactivity/reactive"],"updatePoint":{"line":161,"column":13},"line":161,"code":"  test('toRaw', () => {\n    const original = { foo: 1 }\n    const observed = reactive(original)\n    expect(toRaw(observed)).toBe(original)\n    expect(toRaw(original)).toBe(original)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRaw on object using reactive as prototype","suites":["reactivity/reactive"],"updatePoint":{"line":168,"column":51},"line":168,"code":"  test('toRaw on object using reactive as prototype', () => {\n    const original = reactive({})\n    const obj = Object.create(original)\n    const raw = toRaw(obj)\n    expect(raw).toBe(obj)\n    expect(raw).not.toBe(toRaw(original))\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not unwrap Ref<T>","suites":["reactivity/reactive"],"updatePoint":{"line":176,"column":32},"line":176,"code":"  test('should not unwrap Ref<T>', () => {\n    const observedNumberRef = reactive(ref(1))\n    const observedObjectRef = reactive(ref({ foo: 1 }))\n\n    expect(isRef(observedNumberRef)).toBe(true)\n    expect(isRef(observedObjectRef)).toBe(true)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should unwrap computed refs","suites":["reactivity/reactive"],"updatePoint":{"line":184,"column":35},"line":184,"code":"  test('should unwrap computed refs', () => {\n    // readonly\n    const a = computed(() => 1)\n    // writable\n    const b = computed({\n      get: () => 1,\n      set: () => {}\n    })\n    const obj = reactive({ a, b })\n    // check type\n    obj.a + 1\n    obj.b + 1\n    expect(typeof obj.a).toBe(`number`)\n    expect(typeof obj.b).toBe(`number`)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should allow setting property from a ref to another ref","suites":["reactivity/reactive"],"updatePoint":{"line":200,"column":63},"line":200,"code":"  test('should allow setting property from a ref to another ref', () => {\n    const foo = ref(0)\n    const bar = ref(1)\n    const observed = reactive({ a: foo })\n    const dummy = computed(() => observed.a)\n    expect(dummy.value).toBe(0)\n\n    // @ts-ignore\n    observed.a = bar\n    expect(dummy.value).toBe(1)\n\n    bar.value++\n    expect(dummy.value).toBe(2)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"non-observable values","suites":["reactivity/reactive"],"updatePoint":{"line":215,"column":29},"line":215,"code":"  test('non-observable values', () => {\n    const assertValue = (value: any) => {\n      reactive(value)\n      expect(\n        `value cannot be made reactive: ${String(value)}`\n      ).toHaveBeenWarnedLast()\n    }\n\n    // number\n    assertValue(1)\n    // string\n    assertValue('foo')\n    // boolean\n    assertValue(false)\n    // null\n    assertValue(null)\n    // undefined\n    assertValue(undefined)\n    // symbol\n    const s = Symbol()\n    assertValue(s)\n\n    // built-ins should work and return same value\n    const p = Promise.resolve()\n    expect(reactive(p)).toBe(p)\n    const r = new RegExp('')\n    expect(reactive(r)).toBe(r)\n    const d = new Date()\n    expect(reactive(d)).toBe(d)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"markRaw","suites":["reactivity/reactive"],"updatePoint":{"line":246,"column":15},"line":246,"code":"  test('markRaw', () => {\n    const obj = reactive({\n      foo: { a: 1 },\n      bar: markRaw({ b: 2 })\n    })\n    expect(isReactive(obj.foo)).toBe(true)\n    expect(isReactive(obj.bar)).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe non-extensible objects","suites":["reactivity/reactive"],"updatePoint":{"line":255,"column":49},"line":255,"code":"  test('should not observe non-extensible objects', () => {\n    const obj = reactive({\n      foo: Object.preventExtensions({ a: 1 }),\n      // sealed or frozen objects are considered non-extensible as well\n      bar: Object.freeze({ a: 1 }),\n      baz: Object.seal({ a: 1 })\n    })\n    expect(isReactive(obj.foo)).toBe(false)\n    expect(isReactive(obj.bar)).toBe(false)\n    expect(isReactive(obj.baz)).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe objects with __v_skip","suites":["reactivity/reactive"],"updatePoint":{"line":267,"column":48},"line":267,"code":"  test('should not observe objects with __v_skip', () => {\n    const original = {\n      foo: 1,\n      __v_skip: true\n    }\n    const observed = reactive(original)\n    expect(isReactive(observed)).toBe(false)\n  })","file":"reactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make Array reactive","suites":["reactivity/reactive/Array"],"updatePoint":{"line":7,"column":34},"line":7,"code":"  test('should make Array reactive', () => {\n    const original = [{ foo: 1 }]\n    const observed = reactive(original)\n    expect(observed).not.toBe(original)\n    expect(isReactive(observed)).toBe(true)\n    expect(isReactive(original)).toBe(false)\n    expect(isReactive(observed[0])).toBe(true)\n    // get\n    expect(observed[0].foo).toBe(1)\n    // has\n    expect(0 in observed).toBe(true)\n    // ownKeys\n    expect(Object.keys(observed)).toEqual(['0'])\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"cloned reactive Array should point to observed values","suites":["reactivity/reactive/Array"],"updatePoint":{"line":22,"column":61},"line":22,"code":"  test('cloned reactive Array should point to observed values', () => {\n    const original = [{ foo: 1 }]\n    const observed = reactive(original)\n    const clone = observed.slice()\n    expect(isReactive(clone[0])).toBe(true)\n    expect(clone[0]).not.toBe(original[0])\n    expect(clone[0]).toBe(observed[0])\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"observed value should proxy mutations to original (Array)","suites":["reactivity/reactive/Array"],"updatePoint":{"line":31,"column":65},"line":31,"code":"  test('observed value should proxy mutations to original (Array)', () => {\n    const original: any[] = [{ foo: 1 }, { bar: 2 }]\n    const observed = reactive(original)\n    // set\n    const value = { baz: 3 }\n    const reactiveValue = reactive(value)\n    observed[0] = value\n    expect(observed[0]).toBe(reactiveValue)\n    expect(original[0]).toBe(value)\n    // delete\n    delete observed[0]\n    expect(observed[0]).toBeUndefined()\n    expect(original[0]).toBeUndefined()\n    // mutating methods\n    observed.push(value)\n    expect(observed[2]).toBe(reactiveValue)\n    expect(original[2]).toBe(value)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"Array identity methods should work with raw values","suites":["reactivity/reactive/Array"],"updatePoint":{"line":50,"column":58},"line":50,"code":"  test('Array identity methods should work with raw values', () => {\n    const raw = {}\n    const arr = reactive([{}, {}])\n    arr.push(raw)\n    expect(arr.indexOf(raw)).toBe(2)\n    expect(arr.indexOf(raw, 3)).toBe(-1)\n    expect(arr.includes(raw)).toBe(true)\n    expect(arr.includes(raw, 3)).toBe(false)\n    expect(arr.lastIndexOf(raw)).toBe(2)\n    expect(arr.lastIndexOf(raw, 1)).toBe(-1)\n\n    // should work also for the observed version\n    const observed = arr[2]\n    expect(arr.indexOf(observed)).toBe(2)\n    expect(arr.indexOf(observed, 3)).toBe(-1)\n    expect(arr.includes(observed)).toBe(true)\n    expect(arr.includes(observed, 3)).toBe(false)\n    expect(arr.lastIndexOf(observed)).toBe(2)\n    expect(arr.lastIndexOf(observed, 1)).toBe(-1)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"Array identity methods should work if raw value contains reactive objects","suites":["reactivity/reactive/Array"],"updatePoint":{"line":71,"column":81},"line":71,"code":"  test('Array identity methods should work if raw value contains reactive objects', () => {\n    const raw = []\n    const obj = reactive({})\n    raw.push(obj)\n    const arr = reactive(raw)\n    expect(arr.includes(obj)).toBe(true)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"Array identity methods should be reactive","suites":["reactivity/reactive/Array"],"updatePoint":{"line":79,"column":49},"line":79,"code":"  test('Array identity methods should be reactive', () => {\n    const obj = {}\n    const arr = reactive([obj, {}])\n\n    let index: number = -1\n    effect(() => {\n      index = arr.indexOf(obj)\n    })\n    expect(index).toBe(0)\n    arr.reverse()\n    expect(index).toBe(1)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"delete on Array should not trigger length dependency","suites":["reactivity/reactive/Array"],"updatePoint":{"line":92,"column":60},"line":92,"code":"  test('delete on Array should not trigger length dependency', () => {\n    const arr = reactive([1, 2, 3])\n    const fn = vi.fn()\n    effect(() => {\n      fn(arr.length)\n    })\n    expect(fn).toHaveBeenCalledTimes(1)\n    delete arr[1]\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"add existing index on Array should not trigger length dependency","suites":["reactivity/reactive/Array"],"updatePoint":{"line":103,"column":72},"line":103,"code":"  test('add existing index on Array should not trigger length dependency', () => {\n    const array = new Array(3)\n    const observed = reactive(array)\n    const fn = vi.fn()\n    effect(() => {\n      fn(observed.length)\n    })\n    expect(fn).toHaveBeenCalledTimes(1)\n    observed[1] = 1\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"add non-integer prop on Array should not trigger length dependency","suites":["reactivity/reactive/Array"],"updatePoint":{"line":115,"column":74},"line":115,"code":"  test('add non-integer prop on Array should not trigger length dependency', () => {\n    const array: any[] & { x?: string } = new Array(3)\n    const observed = reactive(array)\n    const fn = vi.fn()\n    effect(() => {\n      fn(observed.length)\n    })\n    expect(fn).toHaveBeenCalledTimes(1)\n    observed.x = 'x'\n    expect(fn).toHaveBeenCalledTimes(1)\n    observed[-1] = 'x'\n    expect(fn).toHaveBeenCalledTimes(1)\n    observed[NaN] = 'x'\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"track length on for ... in iteration","suites":["reactivity/reactive/Array"],"updatePoint":{"line":132,"column":44},"line":132,"code":"  test('track length on for ... in iteration', () => {\n    const array = reactive([1])\n    let length = ''\n    effect(() => {\n      length = ''\n      for (const key in array) {\n        length += key\n      }\n    })\n    expect(length).toBe('0')\n    array.push(1)\n    expect(length).toBe('01')\n  })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"read only copy methods","suites":["reactivity/reactive/Array","Array methods w/ refs"],"updatePoint":{"line":153,"column":32},"line":153,"code":"    test('read only copy methods', () => {\n      const raw = original.concat([3, ref(4)])\n      expect(isRef(raw[1])).toBe(true)\n      expect(isRef(raw[3])).toBe(true)\n    })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"read + write mutating methods","suites":["reactivity/reactive/Array","Array methods w/ refs"],"updatePoint":{"line":160,"column":39},"line":160,"code":"    test('read + write mutating methods', () => {\n      const res = original.copyWithin(0, 1, 2)\n      const raw = toRaw(res)\n      expect(isRef(raw[0])).toBe(true)\n      expect(isRef(raw[1])).toBe(true)\n    })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"read + identity","suites":["reactivity/reactive/Array","Array methods w/ refs"],"updatePoint":{"line":167,"column":25},"line":167,"code":"    test('read + identity', () => {\n      const ref = original[1]\n      expect(ref).toBe(toRaw(original)[1])\n      expect(original.indexOf(ref)).toBe(1)\n    })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calls correct mutation method on Array subclass","suites":["reactivity/reactive/Array","Array subclasses"],"updatePoint":{"line":190,"column":57},"line":190,"code":"    test('calls correct mutation method on Array subclass', () => {\n      const subArray = new SubArray(4, 5, 6)\n      const observed = reactive(subArray)\n\n      subArray.push(7)\n      expect(subArray.lastPushed).toBe(7)\n      observed.push(9)\n      expect(observed.lastPushed).toBe(9)\n    })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calls correct identity-sensitive method on Array subclass","suites":["reactivity/reactive/Array","Array subclasses"],"updatePoint":{"line":200,"column":67},"line":200,"code":"    test('calls correct identity-sensitive method on Array subclass', () => {\n      const subArray = new SubArray(4, 5, 6)\n      const observed = reactive(subArray)\n      let index\n\n      index = subArray.indexOf(4)\n      expect(index).toBe(0)\n      expect(subArray.lastSearched).toBe(4)\n\n      index = observed.indexOf(6)\n      expect(index).toBe(2)\n      expect(observed.lastSearched).toBe(6)\n    })","file":"reactiveArray.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make nested values readonly","suites":["reactivity/readonly","Object"],"updatePoint":{"line":21,"column":42},"line":21,"code":"    it('should make nested values readonly', () => {\n      const original = { foo: 1, bar: { baz: 2 } }\n      const wrapped = readonly(original)\n      expect(wrapped).not.toBe(original)\n      expect(isProxy(wrapped)).toBe(true)\n      expect(isReactive(wrapped)).toBe(false)\n      expect(isReadonly(wrapped)).toBe(true)\n      expect(isReactive(original)).toBe(false)\n      expect(isReadonly(original)).toBe(false)\n      expect(isReactive(wrapped.bar)).toBe(false)\n      expect(isReadonly(wrapped.bar)).toBe(true)\n      expect(isReactive(original.bar)).toBe(false)\n      expect(isReadonly(original.bar)).toBe(false)\n      // get\n      expect(wrapped.foo).toBe(1)\n      // has\n      expect('foo' in wrapped).toBe(true)\n      // ownKeys\n      expect(Object.keys(wrapped)).toEqual(['foo', 'bar'])\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not allow mutation","suites":["reactivity/readonly","Object"],"updatePoint":{"line":42,"column":33},"line":42,"code":"    it('should not allow mutation', () => {\n      const qux = Symbol('qux')\n      const original = {\n        foo: 1,\n        bar: {\n          baz: 2\n        },\n        [qux]: 3\n      }\n      const wrapped: Writable<typeof original> = readonly(original)\n\n      wrapped.foo = 2\n      expect(wrapped.foo).toBe(1)\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n\n      wrapped.bar.baz = 3\n      expect(wrapped.bar.baz).toBe(2)\n      expect(\n        `Set operation on key \"baz\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n\n      wrapped[qux] = 4\n      expect(wrapped[qux]).toBe(3)\n      expect(\n        `Set operation on key \"Symbol(qux)\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n\n      // @ts-expect-error\n      delete wrapped.foo\n      expect(wrapped.foo).toBe(1)\n      expect(\n        `Delete operation on key \"foo\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n\n      // @ts-expect-error\n      delete wrapped.bar.baz\n      expect(wrapped.bar.baz).toBe(2)\n      expect(\n        `Delete operation on key \"baz\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n\n      // @ts-expect-error\n      delete wrapped[qux]\n      expect(wrapped[qux]).toBe(3)\n      expect(\n        `Delete operation on key \"Symbol(qux)\" failed: target is readonly.`\n      ).toHaveBeenWarnedLast()\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not trigger effects","suites":["reactivity/readonly","Object"],"updatePoint":{"line":93,"column":34},"line":93,"code":"    it('should not trigger effects', () => {\n      const wrapped: any = readonly({ a: 1 })\n      let dummy\n      effect(() => {\n        dummy = wrapped.a\n      })\n      expect(dummy).toBe(1)\n      wrapped.a = 2\n      expect(wrapped.a).toBe(1)\n      expect(dummy).toBe(1)\n      expect(`target is readonly`).toHaveBeenWarned()\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make nested values readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":108,"column":42},"line":108,"code":"    it('should make nested values readonly', () => {\n      const original = [{ foo: 1 }]\n      const wrapped = readonly(original)\n      expect(wrapped).not.toBe(original)\n      expect(isProxy(wrapped)).toBe(true)\n      expect(isReactive(wrapped)).toBe(false)\n      expect(isReadonly(wrapped)).toBe(true)\n      expect(isReactive(original)).toBe(false)\n      expect(isReadonly(original)).toBe(false)\n      expect(isReactive(wrapped[0])).toBe(false)\n      expect(isReadonly(wrapped[0])).toBe(true)\n      expect(isReactive(original[0])).toBe(false)\n      expect(isReadonly(original[0])).toBe(false)\n      // get\n      expect(wrapped[0].foo).toBe(1)\n      // has\n      expect(0 in wrapped).toBe(true)\n      // ownKeys\n      expect(Object.keys(wrapped)).toEqual(['0'])\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not allow mutation","suites":["reactivity/readonly","Array"],"updatePoint":{"line":129,"column":33},"line":129,"code":"    it('should not allow mutation', () => {\n      const wrapped: any = readonly([{ foo: 1 }])\n      wrapped[0] = 1\n      expect(wrapped[0]).not.toBe(1)\n      expect(\n        `Set operation on key \"0\" failed: target is readonly.`\n      ).toHaveBeenWarned()\n      wrapped[0].foo = 2\n      expect(wrapped[0].foo).toBe(1)\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).toHaveBeenWarned()\n\n      // should block length mutation\n      wrapped.length = 0\n      expect(wrapped.length).toBe(1)\n      expect(wrapped[0].foo).toBe(1)\n      expect(\n        `Set operation on key \"length\" failed: target is readonly.`\n      ).toHaveBeenWarned()\n\n      // mutation methods invoke set/length internally and thus are blocked as well\n      wrapped.push(2)\n      expect(wrapped.length).toBe(1)\n      // push triggers two warnings on [1] and .length\n      expect(`target is readonly.`).toHaveBeenWarnedTimes(5)\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not trigger effects","suites":["reactivity/readonly","Array"],"updatePoint":{"line":157,"column":34},"line":157,"code":"    it('should not trigger effects', () => {\n      const wrapped: any = readonly([{ a: 1 }])\n      let dummy\n      effect(() => {\n        dummy = wrapped[0].a\n      })\n      expect(dummy).toBe(1)\n      wrapped[0].a = 2\n      expect(wrapped[0].a).toBe(1)\n      expect(dummy).toBe(1)\n      expect(`target is readonly`).toHaveBeenWarnedTimes(1)\n      wrapped[0] = { a: 2 }\n      expect(wrapped[0].a).toBe(1)\n      expect(dummy).toBe(1)\n      expect(`target is readonly`).toHaveBeenWarnedTimes(2)\n    })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make nested values readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":178,"column":46},"line":178,"code":"      test('should make nested values readonly', () => {\n        const key1 = {}\n        const key2 = {}\n        const original = new Collection([\n          [key1, {}],\n          [key2, {}]\n        ])\n        const wrapped = readonly(original)\n        expect(wrapped).not.toBe(original)\n        expect(isProxy(wrapped)).toBe(true)\n        expect(isReactive(wrapped)).toBe(false)\n        expect(isReadonly(wrapped)).toBe(true)\n        expect(isReactive(original)).toBe(false)\n        expect(isReadonly(original)).toBe(false)\n        expect(isReactive(wrapped.get(key1))).toBe(false)\n        expect(isReadonly(wrapped.get(key1))).toBe(true)\n        expect(isReactive(original.get(key1))).toBe(false)\n        expect(isReadonly(original.get(key1))).toBe(false)\n      })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not allow mutation & not trigger effect","suites":["reactivity/readonly","Array"],"updatePoint":{"line":198,"column":58},"line":198,"code":"      test('should not allow mutation & not trigger effect', () => {\n        const map = readonly(new Collection())\n        const key = {}\n        let dummy\n        effect(() => {\n          dummy = map.get(key)\n        })\n        expect(dummy).toBeUndefined()\n        map.set(key, 1)\n        expect(dummy).toBeUndefined()\n        expect(map.has(key)).toBe(false)\n        expect(\n          `Set operation on key \"${key}\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"readonly + reactive should make get() value also readonly + reactive","suites":["reactivity/readonly","Array"],"updatePoint":{"line":215,"column":80},"line":215,"code":"      test('readonly + reactive should make get() value also readonly + reactive', () => {\n        const map = reactive(new Collection())\n        const roMap = readonly(map)\n        const key = {}\n        map.set(key, {})\n\n        const item = map.get(key)\n        expect(isReactive(item)).toBe(true)\n        expect(isReadonly(item)).toBe(false)\n\n        const roItem = roMap.get(key)\n        expect(isReactive(roItem)).toBe(true)\n        expect(isReadonly(roItem)).toBe(true)\n      })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should retrieve readonly values on iteration","suites":["reactivity/readonly","Array"],"updatePoint":{"line":231,"column":58},"line":231,"code":"        test('should retrieve readonly values on iteration', () => {\n          const key1 = {}\n          const key2 = {}\n          const original = new Map([\n            [key1, {}],\n            [key2, {}]\n          ])\n          const wrapped: any = readonly(original)\n          expect(wrapped.size).toBe(2)\n          for (const [key, value] of wrapped) {\n            expect(isReadonly(key)).toBe(true)\n            expect(isReadonly(value)).toBe(true)\n          }\n          wrapped.forEach((value: any) => {\n            expect(isReadonly(value)).toBe(true)\n          })\n          for (const value of wrapped.values()) {\n            expect(isReadonly(value)).toBe(true)\n          }\n        })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should retrieve reactive + readonly values on iteration","suites":["reactivity/readonly","Array"],"updatePoint":{"line":252,"column":69},"line":252,"code":"        test('should retrieve reactive + readonly values on iteration', () => {\n          const key1 = {}\n          const key2 = {}\n          const original = reactive(\n            new Map([\n              [key1, {}],\n              [key2, {}]\n            ])\n          )\n          const wrapped: any = readonly(original)\n          expect(wrapped.size).toBe(2)\n          for (const [key, value] of wrapped) {\n            expect(isReadonly(key)).toBe(true)\n            expect(isReadonly(value)).toBe(true)\n            expect(isReactive(key)).toBe(true)\n            expect(isReactive(value)).toBe(true)\n          }\n          wrapped.forEach((value: any) => {\n            expect(isReadonly(value)).toBe(true)\n            expect(isReactive(value)).toBe(true)\n          })\n          for (const value of wrapped.values()) {\n            expect(isReadonly(value)).toBe(true)\n            expect(isReactive(value)).toBe(true)\n          }\n        })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make nested values readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":285,"column":46},"line":285,"code":"      test('should make nested values readonly', () => {\n        const key1 = {}\n        const key2 = {}\n        const original = new Collection([key1, key2])\n        const wrapped = readonly(original)\n        expect(wrapped).not.toBe(original)\n        expect(isProxy(wrapped)).toBe(true)\n        expect(isReactive(wrapped)).toBe(false)\n        expect(isReadonly(wrapped)).toBe(true)\n        expect(isReactive(original)).toBe(false)\n        expect(isReadonly(original)).toBe(false)\n        expect(wrapped.has(reactive(key1))).toBe(true)\n        expect(original.has(reactive(key1))).toBe(false)\n      })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not allow mutation & not trigger effect","suites":["reactivity/readonly","Array"],"updatePoint":{"line":300,"column":58},"line":300,"code":"      test('should not allow mutation & not trigger effect', () => {\n        const set = readonly(new Collection())\n        const key = {}\n        let dummy\n        effect(() => {\n          dummy = set.has(key)\n        })\n        expect(dummy).toBe(false)\n        set.add(key)\n        expect(dummy).toBe(false)\n        expect(set.has(key)).toBe(false)\n        expect(\n          `Add operation on key \"${key}\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should retrieve readonly values on iteration","suites":["reactivity/readonly","Array"],"updatePoint":{"line":317,"column":58},"line":317,"code":"        test('should retrieve readonly values on iteration', () => {\n          const original = new Collection([{}, {}])\n          const wrapped: any = readonly(original)\n          expect(wrapped.size).toBe(2)\n          for (const value of wrapped) {\n            expect(isReadonly(value)).toBe(true)\n          }\n          wrapped.forEach((value: any) => {\n            expect(isReadonly(value)).toBe(true)\n          })\n          for (const value of wrapped.values()) {\n            expect(isReadonly(value)).toBe(true)\n          }\n          for (const [v1, v2] of wrapped.entries()) {\n            expect(isReadonly(v1)).toBe(true)\n            expect(isReadonly(v2)).toBe(true)\n          }\n        })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calling reactive on an readonly should return readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":339,"column":62},"line":339,"code":"  test('calling reactive on an readonly should return readonly', () => {\n    const a = readonly({})\n    const b = reactive(a)\n    expect(isReadonly(b)).toBe(true)\n    // should point to same original\n    expect(toRaw(a)).toBe(toRaw(b))\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calling readonly on a reactive object should return readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":347,"column":68},"line":347,"code":"  test('calling readonly on a reactive object should return readonly', () => {\n    const a = reactive({})\n    const b = readonly(a)\n    expect(isReadonly(b)).toBe(true)\n    // should point to same original\n    expect(toRaw(a)).toBe(toRaw(b))\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"readonly should track and trigger if wrapping reactive original","suites":["reactivity/readonly","Array"],"updatePoint":{"line":355,"column":71},"line":355,"code":"  test('readonly should track and trigger if wrapping reactive original', () => {\n    const a = reactive({ n: 1 })\n    const b = readonly(a)\n    // should return true since it's wrapping a reactive source\n    expect(isReactive(b)).toBe(true)\n\n    let dummy\n    effect(() => {\n      dummy = b.n\n    })\n    expect(dummy).toBe(1)\n    a.n++\n    expect(b.n).toBe(2)\n    expect(dummy).toBe(2)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"readonly collection should not track","suites":["reactivity/readonly","Array"],"updatePoint":{"line":371,"column":44},"line":371,"code":"  test('readonly collection should not track', () => {\n    const map = new Map()\n    map.set('foo', 1)\n\n    const reMap = reactive(map)\n    const roMap = readonly(map)\n\n    let dummy\n    effect(() => {\n      dummy = roMap.get('foo')\n    })\n    expect(dummy).toBe(1)\n    reMap.set('foo', 2)\n    expect(roMap.get('foo')).toBe(2)\n    // should not trigger\n    expect(dummy).toBe(1)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"readonly array should not track","suites":["reactivity/readonly","Array"],"updatePoint":{"line":389,"column":39},"line":389,"code":"  test('readonly array should not track', () => {\n    const arr = [1]\n    const roArr = readonly(arr)\n\n    const eff = effect(() => {\n      roArr.includes(2)\n    })\n    expect(eff.effect.deps.length).toBe(0)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"readonly should track and trigger if wrapping reactive original (collection)","suites":["reactivity/readonly","Array"],"updatePoint":{"line":399,"column":84},"line":399,"code":"  test('readonly should track and trigger if wrapping reactive original (collection)', () => {\n    const a = reactive(new Map())\n    const b = readonly(a)\n    // should return true since it's wrapping a reactive source\n    expect(isReactive(b)).toBe(true)\n\n    a.set('foo', 1)\n\n    let dummy\n    effect(() => {\n      dummy = b.get('foo')\n    })\n    expect(dummy).toBe(1)\n    a.set('foo', 2)\n    expect(b.get('foo')).toBe(2)\n    expect(dummy).toBe(2)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"wrapping already wrapped value should return same Proxy","suites":["reactivity/readonly","Array"],"updatePoint":{"line":417,"column":63},"line":417,"code":"  test('wrapping already wrapped value should return same Proxy', () => {\n    const original = { foo: 1 }\n    const wrapped = readonly(original)\n    const wrapped2 = readonly(wrapped)\n    expect(wrapped2).toBe(wrapped)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"wrapping the same value multiple times should return same Proxy","suites":["reactivity/readonly","Array"],"updatePoint":{"line":424,"column":71},"line":424,"code":"  test('wrapping the same value multiple times should return same Proxy', () => {\n    const original = { foo: 1 }\n    const wrapped = readonly(original)\n    const wrapped2 = readonly(original)\n    expect(wrapped2).toBe(wrapped)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"markRaw","suites":["reactivity/readonly","Array"],"updatePoint":{"line":431,"column":15},"line":431,"code":"  test('markRaw', () => {\n    const obj = readonly({\n      foo: { a: 1 },\n      bar: markRaw({ b: 2 })\n    })\n    expect(isReadonly(obj.foo)).toBe(true)\n    expect(isReactive(obj.bar)).toBe(false)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make ref readonly","suites":["reactivity/readonly","Array"],"updatePoint":{"line":440,"column":32},"line":440,"code":"  test('should make ref readonly', () => {\n    const n = readonly(ref(1))\n    // @ts-expect-error\n    n.value = 2\n    expect(n.value).toBe(1)\n    expect(\n      `Set operation on key \"value\" failed: target is readonly.`\n    ).toHaveBeenWarned()\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"calling readonly on computed should allow computed to set its private properties","suites":["reactivity/readonly","Array"],"updatePoint":{"line":451,"column":88},"line":451,"code":"  test('calling readonly on computed should allow computed to set its private properties', () => {\n    const r = ref<boolean>(false)\n    const c = computed(() => r.value)\n    const rC = readonly(c)\n\n    r.value = true\n\n    expect(rC.value).toBe(true)\n    expect(\n      'Set operation on key \"_dirty\" failed: target is readonly.'\n    ).not.toHaveBeenWarned()\n    // @ts-expect-error - non-existent property\n    rC.randomProperty = true\n\n    expect(\n      'Set operation on key \"randomProperty\" failed: target is readonly.'\n    ).toHaveBeenWarned()\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"setting a readonly object as a property of a reactive object should retain readonly proxy","suites":["reactivity/readonly","Array"],"updatePoint":{"line":471,"column":97},"line":471,"code":"  test('setting a readonly object as a property of a reactive object should retain readonly proxy', () => {\n    const r = readonly({})\n    const rr = reactive({}) as any\n    rr.foo = r\n    expect(rr.foo).toBe(r)\n    expect(isReadonly(rr.foo)).toBe(true)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"attempting to write plain value to a readonly ref nested in a reactive object should fail","suites":["reactivity/readonly","Array"],"updatePoint":{"line":479,"column":97},"line":479,"code":"  test('attempting to write plain value to a readonly ref nested in a reactive object should fail', () => {\n    const r = ref(false)\n    const ror = readonly(r)\n    const obj = reactive({ ror })\n    expect(() => {\n      obj.ror = true\n    }).toThrow()\n    expect(obj.ror).toBe(false)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"replacing a readonly ref nested in a reactive object with a new ref","suites":["reactivity/readonly","Array"],"updatePoint":{"line":489,"column":75},"line":489,"code":"  test('replacing a readonly ref nested in a reactive object with a new ref', () => {\n    const r = ref(false)\n    const ror = readonly(r)\n    const obj = reactive({ ror })\n    obj.ror = ref(true) as unknown as boolean\n    expect(obj.ror).toBe(true)\n    expect(toRaw(obj).ror).not.toBe(ror) // ref successfully replaced\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"setting readonly object to writable nested ref","suites":["reactivity/readonly","Array"],"updatePoint":{"line":498,"column":54},"line":498,"code":"  test('setting readonly object to writable nested ref', () => {\n    const r = ref<any>()\n    const obj = reactive({ r })\n    const ro = readonly({})\n    obj.r = ro\n    expect(obj.r).toBe(ro)\n    expect(r.value).toBe(ro)\n  })","file":"readonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should hold a value","suites":["reactivity/ref"],"updatePoint":{"line":22,"column":25},"line":22,"code":"  it('should hold a value', () => {\n    const a = ref(1)\n    expect(a.value).toBe(1)\n    a.value = 2\n    expect(a.value).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be reactive","suites":["reactivity/ref"],"updatePoint":{"line":29,"column":24},"line":29,"code":"  it('should be reactive', () => {\n    const a = ref(1)\n    let dummy\n    let calls = 0\n    effect(() => {\n      calls++\n      dummy = a.value\n    })\n    expect(calls).toBe(1)\n    expect(dummy).toBe(1)\n    a.value = 2\n    expect(calls).toBe(2)\n    expect(dummy).toBe(2)\n    // same value should not trigger\n    a.value = 2\n    expect(calls).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make nested properties reactive","suites":["reactivity/ref"],"updatePoint":{"line":47,"column":44},"line":47,"code":"  it('should make nested properties reactive', () => {\n    const a = ref({\n      count: 1\n    })\n    let dummy\n    effect(() => {\n      dummy = a.value.count\n    })\n    expect(dummy).toBe(1)\n    a.value.count = 2\n    expect(dummy).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work without initial value","suites":["reactivity/ref"],"updatePoint":{"line":60,"column":39},"line":60,"code":"  it('should work without initial value', () => {\n    const a = ref()\n    let dummy\n    effect(() => {\n      dummy = a.value\n    })\n    expect(dummy).toBe(undefined)\n    a.value = 2\n    expect(dummy).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should work like a normal property when nested in a reactive object","suites":["reactivity/ref"],"updatePoint":{"line":71,"column":73},"line":71,"code":"  it('should work like a normal property when nested in a reactive object', () => {\n    const a = ref(1)\n    const obj = reactive({\n      a,\n      b: {\n        c: a\n      }\n    })\n\n    let dummy1: number\n    let dummy2: number\n\n    effect(() => {\n      dummy1 = obj.a\n      dummy2 = obj.b.c\n    })\n\n    const assertDummiesEqualTo = (val: number) =>\n      [dummy1, dummy2].forEach(dummy => expect(dummy).toBe(val))\n\n    assertDummiesEqualTo(1)\n    a.value++\n    assertDummiesEqualTo(2)\n    obj.a++\n    assertDummiesEqualTo(3)\n    obj.b.c++\n    assertDummiesEqualTo(4)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should unwrap nested ref in types","suites":["reactivity/ref"],"updatePoint":{"line":100,"column":39},"line":100,"code":"  it('should unwrap nested ref in types', () => {\n    const a = ref(0)\n    const b = ref(a)\n\n    expect(typeof (b.value + 1)).toBe('number')\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should unwrap nested values in types","suites":["reactivity/ref"],"updatePoint":{"line":107,"column":42},"line":107,"code":"  it('should unwrap nested values in types', () => {\n    const a = {\n      b: ref(0)\n    }\n\n    const c = ref(a)\n\n    expect(typeof (c.value.b + 1)).toBe('number')\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should NOT unwrap ref types nested inside arrays","suites":["reactivity/ref"],"updatePoint":{"line":117,"column":54},"line":117,"code":"  it('should NOT unwrap ref types nested inside arrays', () => {\n    const arr = ref([1, ref(3)]).value\n    expect(isRef(arr[0])).toBe(false)\n    expect(isRef(arr[1])).toBe(true)\n    expect((arr[1] as Ref).value).toBe(3)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should unwrap ref types as props of arrays","suites":["reactivity/ref"],"updatePoint":{"line":124,"column":48},"line":124,"code":"  it('should unwrap ref types as props of arrays', () => {\n    const arr = [ref(0)]\n    const symbolKey = Symbol('')\n    arr['' as any] = ref(1)\n    arr[symbolKey as any] = ref(2)\n    const arrRef = ref(arr).value\n    expect(isRef(arrRef[0])).toBe(true)\n    expect(isRef(arrRef['' as any])).toBe(false)\n    expect(isRef(arrRef[symbolKey as any])).toBe(false)\n    expect(arrRef['' as any]).toBe(1)\n    expect(arrRef[symbolKey as any]).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should keep tuple types","suites":["reactivity/ref"],"updatePoint":{"line":137,"column":29},"line":137,"code":"  it('should keep tuple types', () => {\n    const tuple: [number, string, { a: number }, () => number, Ref<number>] = [\n      0,\n      '1',\n      { a: 1 },\n      () => 0,\n      ref(0)\n    ]\n    const tupleRef = ref(tuple)\n\n    tupleRef.value[0]++\n    expect(tupleRef.value[0]).toBe(1)\n    tupleRef.value[1] += '1'\n    expect(tupleRef.value[1]).toBe('11')\n    tupleRef.value[2].a++\n    expect(tupleRef.value[2].a).toBe(2)\n    expect(tupleRef.value[3]()).toBe(0)\n    tupleRef.value[4].value++\n    expect(tupleRef.value[4].value).toBe(1)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should keep symbols","suites":["reactivity/ref"],"updatePoint":{"line":158,"column":25},"line":158,"code":"  it('should keep symbols', () => {\n    const customSymbol = Symbol()\n    const obj = {\n      [Symbol.asyncIterator]: ref(1),\n      [Symbol.hasInstance]: { a: ref('a') },\n      [Symbol.isConcatSpreadable]: { b: ref(true) },\n      [Symbol.iterator]: [ref(1)],\n      [Symbol.match]: new Set<Ref<number>>(),\n      [Symbol.matchAll]: new Map<number, Ref<string>>(),\n      [Symbol.replace]: { arr: [ref('a')] },\n      [Symbol.search]: { set: new Set<Ref<number>>() },\n      [Symbol.species]: { map: new Map<number, Ref<string>>() },\n      [Symbol.split]: new WeakSet<Ref<boolean>>(),\n      [Symbol.toPrimitive]: new WeakMap<Ref<boolean>, string>(),\n      [Symbol.toStringTag]: { weakSet: new WeakSet<Ref<boolean>>() },\n      [Symbol.unscopables]: { weakMap: new WeakMap<Ref<boolean>, string>() },\n      [customSymbol]: { arr: [ref(1)] }\n    }\n\n    const objRef = ref(obj)\n\n    const keys: (keyof typeof obj)[] = [\n      Symbol.asyncIterator,\n      Symbol.hasInstance,\n      Symbol.isConcatSpreadable,\n      Symbol.iterator,\n      Symbol.match,\n      Symbol.matchAll,\n      Symbol.replace,\n      Symbol.search,\n      Symbol.species,\n      Symbol.split,\n      Symbol.toPrimitive,\n      Symbol.toStringTag,\n      Symbol.unscopables,\n      customSymbol\n    ]\n\n    keys.forEach(key => {\n      expect(objRef.value[key]).toStrictEqual(obj[key])\n    })\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"unref","suites":["reactivity/ref"],"updatePoint":{"line":201,"column":13},"line":201,"code":"  test('unref', () => {\n    expect(unref(1)).toBe(1)\n    expect(unref(ref(1))).toBe(1)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"shallowRef","suites":["reactivity/ref"],"updatePoint":{"line":206,"column":18},"line":206,"code":"  test('shallowRef', () => {\n    const sref = shallowRef({ a: 1 })\n    expect(isReactive(sref.value)).toBe(false)\n\n    let dummy\n    effect(() => {\n      dummy = sref.value.a\n    })\n    expect(dummy).toBe(1)\n\n    sref.value = { a: 2 }\n    expect(isReactive(sref.value)).toBe(false)\n    expect(dummy).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"shallowRef force trigger","suites":["reactivity/ref"],"updatePoint":{"line":221,"column":32},"line":221,"code":"  test('shallowRef force trigger', () => {\n    const sref = shallowRef({ a: 1 })\n    let dummy\n    effect(() => {\n      dummy = sref.value.a\n    })\n    expect(dummy).toBe(1)\n\n    sref.value.a = 2\n    expect(dummy).toBe(1) // should not trigger yet\n\n    // force trigger\n    triggerRef(sref)\n    expect(dummy).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"shallowRef isShallow","suites":["reactivity/ref"],"updatePoint":{"line":237,"column":28},"line":237,"code":"  test('shallowRef isShallow', () => {\n    expect(isShallow(shallowRef({ a: 1 }))).toBe(true)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"isRef","suites":["reactivity/ref"],"updatePoint":{"line":241,"column":13},"line":241,"code":"  test('isRef', () => {\n    expect(isRef(ref(1))).toBe(true)\n    expect(isRef(computed(() => 1))).toBe(true)\n\n    expect(isRef(0)).toBe(false)\n    expect(isRef(1)).toBe(false)\n    // an object that looks like a ref isn't necessarily a ref\n    expect(isRef({ value: 0 })).toBe(false)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRef","suites":["reactivity/ref"],"updatePoint":{"line":251,"column":13},"line":251,"code":"  test('toRef', () => {\n    const a = reactive({\n      x: 1\n    })\n    const x = toRef(a, 'x')\n    expect(isRef(x)).toBe(true)\n    expect(x.value).toBe(1)\n\n    // source -> proxy\n    a.x = 2\n    expect(x.value).toBe(2)\n\n    // proxy -> source\n    x.value = 3\n    expect(a.x).toBe(3)\n\n    // reactivity\n    let dummyX\n    effect(() => {\n      dummyX = x.value\n    })\n    expect(dummyX).toBe(x.value)\n\n    // mutating source should trigger effect using the proxy refs\n    a.x = 4\n    expect(dummyX).toBe(4)\n\n    // should keep ref\n    const r = { x: ref(1) }\n    expect(toRef(r, 'x')).toBe(r.x)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRef on array","suites":["reactivity/ref"],"updatePoint":{"line":283,"column":22},"line":283,"code":"  test('toRef on array', () => {\n    const a = reactive(['a', 'b'])\n    const r = toRef(a, 1)\n    expect(r.value).toBe('b')\n    r.value = 'c'\n    expect(r.value).toBe('c')\n    expect(a[1]).toBe('c')\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRef default value","suites":["reactivity/ref"],"updatePoint":{"line":292,"column":27},"line":292,"code":"  test('toRef default value', () => {\n    const a: { x: number | undefined } = { x: undefined }\n    const x = toRef(a, 'x', 1)\n    expect(x.value).toBe(1)\n\n    a.x = 2\n    expect(x.value).toBe(2)\n\n    a.x = undefined\n    expect(x.value).toBe(1)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRef getter","suites":["reactivity/ref"],"updatePoint":{"line":304,"column":20},"line":304,"code":"  test('toRef getter', () => {\n    const x = toRef(() => 1)\n    expect(x.value).toBe(1)\n    expect(isRef(x)).toBe(true)\n    expect(unref(x)).toBe(1)\n    //@ts-expect-error\n    expect(() => (x.value = 123)).toThrow()\n\n    expect(isReadonly(x)).toBe(true)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRefs","suites":["reactivity/ref"],"updatePoint":{"line":315,"column":14},"line":315,"code":"  test('toRefs', () => {\n    const a = reactive({\n      x: 1,\n      y: 2\n    })\n\n    const { x, y } = toRefs(a)\n\n    expect(isRef(x)).toBe(true)\n    expect(isRef(y)).toBe(true)\n    expect(x.value).toBe(1)\n    expect(y.value).toBe(2)\n\n    // source -> proxy\n    a.x = 2\n    a.y = 3\n    expect(x.value).toBe(2)\n    expect(y.value).toBe(3)\n\n    // proxy -> source\n    x.value = 3\n    y.value = 4\n    expect(a.x).toBe(3)\n    expect(a.y).toBe(4)\n\n    // reactivity\n    let dummyX, dummyY\n    effect(() => {\n      dummyX = x.value\n      dummyY = y.value\n    })\n    expect(dummyX).toBe(x.value)\n    expect(dummyY).toBe(y.value)\n\n    // mutating source should trigger effect using the proxy refs\n    a.x = 4\n    a.y = 5\n    expect(dummyX).toBe(4)\n    expect(dummyY).toBe(5)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRefs should warn on plain object","suites":["reactivity/ref"],"updatePoint":{"line":356,"column":42},"line":356,"code":"  test('toRefs should warn on plain object', () => {\n    toRefs({})\n    expect(`toRefs() expects a reactive object`).toHaveBeenWarned()\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRefs should warn on plain array","suites":["reactivity/ref"],"updatePoint":{"line":361,"column":41},"line":361,"code":"  test('toRefs should warn on plain array', () => {\n    toRefs([])\n    expect(`toRefs() expects a reactive object`).toHaveBeenWarned()\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"toRefs reactive array","suites":["reactivity/ref"],"updatePoint":{"line":366,"column":29},"line":366,"code":"  test('toRefs reactive array', () => {\n    const arr = reactive(['a', 'b', 'c'])\n    const refs = toRefs(arr)\n\n    expect(Array.isArray(refs)).toBe(true)\n\n    refs[0].value = '1'\n    expect(arr[0]).toBe('1')\n\n    arr[1] = '2'\n    expect(refs[1].value).toBe('2')\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"customRef","suites":["reactivity/ref"],"updatePoint":{"line":379,"column":17},"line":379,"code":"  test('customRef', () => {\n    let value = 1\n    let _trigger: () => void\n\n    const custom = customRef((track, trigger) => ({\n      get() {\n        track()\n        return value\n      },\n      set(newValue: number) {\n        value = newValue\n        _trigger = trigger\n      }\n    }))\n\n    expect(isRef(custom)).toBe(true)\n\n    let dummy\n    effect(() => {\n      dummy = custom.value\n    })\n    expect(dummy).toBe(1)\n\n    custom.value = 2\n    // should not trigger yet\n    expect(dummy).toBe(1)\n\n    _trigger!()\n    expect(dummy).toBe(2)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not trigger when setting value to same proxy","suites":["reactivity/ref"],"updatePoint":{"line":410,"column":59},"line":410,"code":"  test('should not trigger when setting value to same proxy', () => {\n    const obj = reactive({ count: 0 })\n\n    const a = ref(obj)\n    const spy1 = vi.fn(() => a.value)\n\n    effect(spy1)\n\n    a.value = obj\n    expect(spy1).toBeCalledTimes(1)\n\n    const b = shallowRef(obj)\n    const spy2 = vi.fn(() => b.value)\n\n    effect(spy2)\n\n    b.value = obj\n    expect(spy2).toBeCalledTimes(1)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"ref should preserve value shallow/readonly-ness","suites":["reactivity/ref"],"updatePoint":{"line":430,"column":55},"line":430,"code":"  test('ref should preserve value shallow/readonly-ness', () => {\n    const original = {}\n    const r = reactive(original)\n    const s = shallowReactive(original)\n    const rr = readonly(original)\n    const a = ref(original)\n\n    expect(a.value).toBe(r)\n\n    a.value = s\n    expect(a.value).toBe(s)\n    expect(a.value).not.toBe(r)\n\n    a.value = rr\n    expect(a.value).toBe(rr)\n    expect(a.value).not.toBe(r)\n  })","file":"ref.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make non-reactive properties reactive","suites":["shallowReactive"],"updatePoint":{"line":14,"column":56},"line":14,"code":"  test('should not make non-reactive properties reactive', () => {\n    const props = shallowReactive({ n: { foo: 1 } })\n    expect(isReactive(props.n)).toBe(false)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should keep reactive properties reactive","suites":["shallowReactive"],"updatePoint":{"line":19,"column":48},"line":19,"code":"  test('should keep reactive properties reactive', () => {\n    const props: any = shallowReactive({ n: reactive({ foo: 1 }) })\n    props.n = reactive({ foo: 2 })\n    expect(isReactive(props.n)).toBe(true)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should allow shallow and normal reactive for same target","suites":["shallowReactive"],"updatePoint":{"line":26,"column":64},"line":26,"code":"  test('should allow shallow and normal reactive for same target', () => {\n    const original = { foo: {} }\n    const shallowProxy = shallowReactive(original)\n    const reactiveProxy = reactive(original)\n    expect(shallowProxy).not.toBe(reactiveProxy)\n    expect(isReactive(shallowProxy.foo)).toBe(false)\n    expect(isReactive(reactiveProxy.foo)).toBe(true)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"isShallow","suites":["shallowReactive"],"updatePoint":{"line":35,"column":17},"line":35,"code":"  test('isShallow', () => {\n    expect(isShallow(shallowReactive({}))).toBe(true)\n    expect(isShallow(shallowReadonly({}))).toBe(true)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should respect shallow reactive nested inside reactive on reset","suites":["shallowReactive"],"updatePoint":{"line":41,"column":71},"line":41,"code":"  test('should respect shallow reactive nested inside reactive on reset', () => {\n    const r = reactive({ foo: shallowReactive({ bar: {} }) })\n    expect(isShallow(r.foo)).toBe(true)\n    expect(isReactive(r.foo.bar)).toBe(false)\n\n    r.foo = shallowReactive({ bar: {} })\n    expect(isShallow(r.foo)).toBe(true)\n    expect(isReactive(r.foo.bar)).toBe(false)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not unwrap refs","suites":["shallowReactive"],"updatePoint":{"line":52,"column":30},"line":52,"code":"  test('should not unwrap refs', () => {\n    const foo = shallowReactive({\n      bar: ref(123)\n    })\n    expect(isRef(foo.bar)).toBe(true)\n    expect(foo.bar.value).toBe(123)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not mutate refs","suites":["shallowReactive"],"updatePoint":{"line":61,"column":30},"line":61,"code":"  test('should not mutate refs', () => {\n    const original = ref(123)\n    const foo = shallowReactive<{ bar: Ref<number> | number }>({\n      bar: original\n    })\n    expect(foo.bar).toBe(original)\n    foo.bar = 234\n    expect(foo.bar).toBe(234)\n    expect(original.value).toBe(123)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should respect shallow/deep versions of same target on access","suites":["shallowReactive"],"updatePoint":{"line":72,"column":69},"line":72,"code":"  test('should respect shallow/deep versions of same target on access', () => {\n    const original = {}\n    const shallow = shallowReactive(original)\n    const deep = reactive(original)\n    const r = reactive({ shallow, deep })\n    expect(r.shallow).toBe(shallow)\n    expect(r.deep).toBe(deep)\n  })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be reactive","suites":["shallowReactive","collections"],"updatePoint":{"line":82,"column":28},"line":82,"code":"    test('should be reactive', () => {\n      const shallowSet = shallowReactive(new Set())\n      const a = {}\n      let size\n\n      effect(() => {\n        size = shallowSet.size\n      })\n\n      expect(size).toBe(0)\n\n      shallowSet.add(a)\n      expect(size).toBe(1)\n\n      shallowSet.delete(a)\n      expect(size).toBe(0)\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe when iterating","suites":["shallowReactive","collections"],"updatePoint":{"line":100,"column":43},"line":100,"code":"    test('should not observe when iterating', () => {\n      const shallowSet = shallowReactive(new Set())\n      const a = {}\n      shallowSet.add(a)\n\n      const spreadA = [...shallowSet][0]\n      expect(isReactive(spreadA)).toBe(false)\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not get reactive entry","suites":["shallowReactive","collections"],"updatePoint":{"line":109,"column":39},"line":109,"code":"    test('should not get reactive entry', () => {\n      const shallowMap = shallowReactive(new Map())\n      const a = {}\n      const key = 'a'\n\n      shallowMap.set(key, a)\n\n      expect(isReactive(shallowMap.get(key))).toBe(false)\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not get reactive on foreach","suites":["shallowReactive","collections"],"updatePoint":{"line":119,"column":44},"line":119,"code":"    test('should not get reactive on foreach', () => {\n      const shallowSet = shallowReactive(new Set())\n      const a = {}\n      shallowSet.add(a)\n\n      shallowSet.forEach(x => expect(isReactive(x)).toBe(false))\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"onTrack on called on objectSpread","suites":["shallowReactive","collections"],"updatePoint":{"line":128,"column":43},"line":128,"code":"    test('onTrack on called on objectSpread', () => {\n      const onTrackFn = vi.fn()\n      const shallowSet = shallowReactive(new Set())\n      let a\n      effect(\n        () => {\n          a = Array.from(shallowSet)\n        },\n        {\n          onTrack: onTrackFn\n        }\n      )\n\n      expect(a).toMatchObject([])\n      expect(onTrackFn).toHaveBeenCalled()\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should be reactive","suites":["shallowReactive","array"],"updatePoint":{"line":147,"column":28},"line":147,"code":"    test('should be reactive', () => {\n      const shallowArray = shallowReactive<unknown[]>([])\n      const a = {}\n      let size\n\n      effect(() => {\n        size = shallowArray.length\n      })\n\n      expect(size).toBe(0)\n\n      shallowArray.push(a)\n      expect(size).toBe(1)\n\n      shallowArray.pop()\n      expect(size).toBe(0)\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not observe when iterating","suites":["shallowReactive","array"],"updatePoint":{"line":164,"column":43},"line":164,"code":"    test('should not observe when iterating', () => {\n      const shallowArray = shallowReactive<object[]>([])\n      const a = {}\n      shallowArray.push(a)\n\n      const spreadA = [...shallowArray][0]\n      expect(isReactive(spreadA)).toBe(false)\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"onTrack on called on objectSpread","suites":["shallowReactive","array"],"updatePoint":{"line":173,"column":43},"line":173,"code":"    test('onTrack on called on objectSpread', () => {\n      const onTrackFn = vi.fn()\n      const shallowArray = shallowReactive([])\n      let a\n      effect(\n        () => {\n          a = Array.from(shallowArray)\n        },\n        {\n          onTrack: onTrackFn\n        }\n      )\n\n      expect(a).toMatchObject([])\n      expect(onTrackFn).toHaveBeenCalled()\n    })","file":"shallowReactive.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make non-reactive properties reactive","suites":["reactivity/shallowReadonly"],"updatePoint":{"line":4,"column":56},"line":4,"code":"  test('should not make non-reactive properties reactive', () => {\n    const props = shallowReadonly({ n: { foo: 1 } })\n    expect(isReactive(props.n)).toBe(false)\n  })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make root level properties readonly","suites":["reactivity/shallowReadonly"],"updatePoint":{"line":9,"column":50},"line":9,"code":"  test('should make root level properties readonly', () => {\n    const props = shallowReadonly({ n: 1 })\n    // @ts-expect-error\n    props.n = 2\n    expect(props.n).toBe(1)\n    expect(\n      `Set operation on key \"n\" failed: target is readonly.`\n    ).toHaveBeenWarned()\n  })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should NOT make nested properties readonly","suites":["reactivity/shallowReadonly"],"updatePoint":{"line":20,"column":50},"line":20,"code":"  test('should NOT make nested properties readonly', () => {\n    const props = shallowReadonly({ n: { foo: 1 } })\n\n    props.n.foo = 2\n    expect(props.n.foo).toBe(2)\n    expect(\n      `Set operation on key \"foo\" failed: target is readonly.`\n    ).not.toHaveBeenWarned()\n  })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should differentiate from normal readonly calls","suites":["reactivity/shallowReadonly"],"updatePoint":{"line":31,"column":55},"line":31,"code":"  test('should differentiate from normal readonly calls', () => {\n    const original = { foo: {} }\n    const shallowProxy = shallowReadonly(original)\n    const reactiveProxy = readonly(original)\n    expect(shallowProxy).not.toBe(reactiveProxy)\n    expect(isReadonly(shallowProxy.foo)).toBe(false)\n    expect(isReadonly(reactiveProxy.foo)).toBe(true)\n  })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make the map/weak-map readonly","suites":["reactivity/shallowReadonly","collection/Map"],"updatePoint":{"line":42,"column":49},"line":42,"code":"      test('should make the map/weak-map readonly', () => {\n        const key = {}\n        const val = { foo: 1 }\n        const original = new Collection([[key, val]])\n        const sroMap = shallowReadonly(original)\n        expect(isReadonly(sroMap)).toBe(true)\n        expect(isReactive(sroMap)).toBe(false)\n        expect(sroMap.get(key)).toBe(val)\n\n        sroMap.set(key, {} as any)\n        expect(\n          `Set operation on key \"[object Object]\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make nested values readonly","suites":["reactivity/shallowReadonly","collection/Map"],"updatePoint":{"line":57,"column":50},"line":57,"code":"      test('should not make nested values readonly', () => {\n        const key = {}\n        const val = { foo: 1 }\n        const original = new Collection([[key, val]])\n        const sroMap = shallowReadonly(original)\n        expect(isReadonly(sroMap.get(key))).toBe(false)\n        expect(isReactive(sroMap.get(key))).toBe(false)\n\n        sroMap.get(key)!.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the iterable method readonly","suites":["reactivity/shallowReadonly","collection/Map"],"updatePoint":{"line":72,"column":77},"line":72,"code":"    test('should not make the value generated by the iterable method readonly', () => {\n      const key = {}\n      const val = { foo: 1 }\n      const original = new Map([[key, val]])\n      const sroMap = shallowReadonly(original)\n\n      const values1 = [...sroMap.values()]\n      const values2 = [...sroMap.entries()]\n\n      expect(isReadonly(values1[0])).toBe(false)\n      expect(isReactive(values1[0])).toBe(false)\n      expect(values1[0]).toBe(val)\n\n      values1[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n\n      expect(isReadonly(values2[0][1])).toBe(false)\n      expect(isReactive(values2[0][1])).toBe(false)\n      expect(values2[0][1]).toBe(val)\n\n      values2[0][1].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the forEach method readonly","suites":["reactivity/shallowReadonly","collection/Map"],"updatePoint":{"line":100,"column":76},"line":100,"code":"    test('should not make the value generated by the forEach method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Map([['key', val]])\n      const sroMap = shallowReadonly(original)\n\n      sroMap.forEach(val => {\n        expect(isReadonly(val)).toBe(false)\n        expect(isReactive(val)).toBe(false)\n        expect(val).toBe(val)\n\n        val.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should make the set/weak-set readonly","suites":["reactivity/shallowReadonly","collection/Set"],"updatePoint":{"line":119,"column":47},"line":119,"code":"    test('should make the set/weak-set readonly', () => {\n      ;[Set, WeakSet].forEach(Collection => {\n        const obj = { foo: 1 }\n        const original = new Collection([obj])\n        const sroSet = shallowReadonly(original)\n        expect(isReadonly(sroSet)).toBe(true)\n        expect(isReactive(sroSet)).toBe(false)\n        expect(sroSet.has(obj)).toBe(true)\n\n        sroSet.add({} as any)\n        expect(\n          `Add operation on key \"[object Object]\" failed: target is readonly.`\n        ).toHaveBeenWarned()\n      })\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make nested values readonly","suites":["reactivity/shallowReadonly","collection/Set"],"updatePoint":{"line":135,"column":48},"line":135,"code":"    test('should not make nested values readonly', () => {\n      const obj = { foo: 1 }\n      const original = new Set([obj])\n      const sroSet = shallowReadonly(original)\n\n      const values = [...sroSet.values()]\n\n      expect(values[0]).toBe(obj)\n      expect(isReadonly(values[0])).toBe(false)\n      expect(isReactive(values[0])).toBe(false)\n\n      sroSet.add({} as any)\n      expect(\n        `Add operation on key \"[object Object]\" failed: target is readonly.`\n      ).toHaveBeenWarned()\n\n      values[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the iterable method readonly","suites":["reactivity/shallowReadonly","collection/Set"],"updatePoint":{"line":157,"column":77},"line":157,"code":"    test('should not make the value generated by the iterable method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Set([val])\n      const sroSet = shallowReadonly(original)\n\n      const values1 = [...sroSet.values()]\n      const values2 = [...sroSet.entries()]\n\n      expect(isReadonly(values1[0])).toBe(false)\n      expect(isReactive(values1[0])).toBe(false)\n      expect(values1[0]).toBe(val)\n\n      values1[0].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n\n      expect(isReadonly(values2[0][1])).toBe(false)\n      expect(isReactive(values2[0][1])).toBe(false)\n      expect(values2[0][1]).toBe(val)\n\n      values2[0][1].foo = 2\n      expect(\n        `Set operation on key \"foo\" failed: target is readonly.`\n      ).not.toHaveBeenWarned()\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"should not make the value generated by the forEach method readonly","suites":["reactivity/shallowReadonly","collection/Set"],"updatePoint":{"line":184,"column":76},"line":184,"code":"    test('should not make the value generated by the forEach method readonly', () => {\n      const val = { foo: 1 }\n      const original = new Set([val])\n      const sroSet = shallowReadonly(original)\n\n      sroSet.forEach(val => {\n        expect(isReadonly(val)).toBe(false)\n        expect(isReactive(val)).toBe(false)\n        expect(val).toBe(val)\n\n        val.foo = 2\n        expect(\n          `Set operation on key \"foo\" failed: target is readonly.`\n        ).not.toHaveBeenWarned()\n      })\n    })","file":"shallowReadonly.spec.ts","skipped":false,"dir":"packages/reactivity/__tests__"},{"name":"simple usage","suites":["api: defineAsyncComponent"],"updatePoint":{"line":17,"column":20},"line":17,"code":"  test('simple usage', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    }).mount(root)\n\n    expect(serializeInner(root)).toBe('<!---->')\n\n    resolve!(() => 'resolved')\n    // first time resolve, wait for macro task since there are multiple\n    // microtasks / .then() calls\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // already resolved component should update on nextTick\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with loading component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":50,"column":30},"line":50,"code":"  test('with loading component', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(r => {\n          resolve = r as any\n        }),\n      loadingComponent: () => 'loading',\n      delay: 1 // defaults to 200\n    })\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    }).mount(root)\n\n    // due to the delay, initial mount should be empty\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // loading show up after delay\n    await timeout(1)\n    expect(serializeInner(root)).toBe('loading')\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // already resolved component should update on nextTick without loading\n    // state\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with loading component + explicit delay (0)","suites":["api: defineAsyncComponent"],"updatePoint":{"line":89,"column":51},"line":89,"code":"  test('with loading component + explicit delay (0)', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(r => {\n          resolve = r as any\n        }),\n      loadingComponent: () => 'loading',\n      delay: 0\n    })\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    }).mount(root)\n\n    // with delay: 0, should show loading immediately\n    expect(serializeInner(root)).toBe('loading')\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // already resolved component should update on nextTick without loading\n    // state\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error without error component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":124,"column":37},"line":124,"code":"  test('error without error component', async () => {\n    let resolve: (comp: Component) => void\n    let reject: (e: Error) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise((_resolve, _reject) => {\n          resolve = _resolve as any\n          reject = _reject\n        })\n    )\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    const err = new Error('foo')\n    reject!(err)\n    await timeout()\n    expect(handler).toHaveBeenCalled()\n    expect(handler.mock.calls[0][0]).toBe(err)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // errored out on previous load, toggle and mock success this time\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // should render this time\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error with error component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":168,"column":34},"line":168,"code":"  test('error with error component', async () => {\n    let resolve: (comp: Component) => void\n    let reject: (e: Error) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise((_resolve, _reject) => {\n          resolve = _resolve as any\n          reject = _reject\n        }),\n      errorComponent: (props: { error: Error }) => props.error.message\n    })\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    const err = new Error('errored out')\n    reject!(err)\n    await timeout()\n    expect(handler).toHaveBeenCalled()\n    expect(serializeInner(root)).toBe('errored out')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // errored out on previous load, toggle and mock success this time\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // should render this time\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error with error component, without global handler","suites":["api: defineAsyncComponent"],"updatePoint":{"line":213,"column":58},"line":213,"code":"  test('error with error component, without global handler', async () => {\n    let resolve: (comp: Component) => void\n    let reject: (e: Error) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise((_resolve, _reject) => {\n          resolve = _resolve as any\n          reject = _reject\n        }),\n      errorComponent: (props: { error: Error }) => props.error.message\n    })\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    })\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    const err = new Error('errored out')\n    reject!(err)\n    await timeout()\n    expect(serializeInner(root)).toBe('errored out')\n    expect(\n      'Unhandled error during execution of async component loader'\n    ).toHaveBeenWarned()\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // errored out on previous load, toggle and mock success this time\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // should render this time\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error with error + loading components","suites":["api: defineAsyncComponent"],"updatePoint":{"line":257,"column":45},"line":257,"code":"  test('error with error + loading components', async () => {\n    let resolve: (comp: Component) => void\n    let reject: (e: Error) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise((_resolve, _reject) => {\n          resolve = _resolve as any\n          reject = _reject\n        }),\n      errorComponent: (props: { error: Error }) => props.error.message,\n      loadingComponent: () => 'loading',\n      delay: 1\n    })\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => (toggle.value ? h(Foo) : null)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n\n    app.mount(root)\n\n    // due to the delay, initial mount should be empty\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // loading show up after delay\n    await timeout(1)\n    expect(serializeInner(root)).toBe('loading')\n\n    const err = new Error('errored out')\n    reject!(err)\n    await timeout()\n    expect(handler).toHaveBeenCalled()\n    expect(serializeInner(root)).toBe('errored out')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // errored out on previous load, toggle and mock success this time\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // loading show up after delay\n    await timeout(1)\n    expect(serializeInner(root)).toBe('loading')\n\n    // should render this time\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"timeout without error component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":313,"column":39},"line":313,"code":"  test('timeout without error component', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        }),\n      timeout: 1\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n\n    const handler = vi.fn()\n    app.config.errorHandler = handler\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    await timeout(1)\n    expect(handler).toHaveBeenCalled()\n    expect(handler.mock.calls[0][0].message).toMatch(\n      `Async component timed out after 1ms.`\n    )\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // if it resolved after timeout, should still work\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"timeout with error component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":347,"column":36},"line":347,"code":"  test('timeout with error component', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        }),\n      timeout: 1,\n      errorComponent: () => 'timed out'\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    await timeout(1)\n    expect(handler).toHaveBeenCalled()\n    expect(serializeInner(root)).toBe('timed out')\n\n    // if it resolved after timeout, should still work\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"timeout with error + loading components","suites":["api: defineAsyncComponent"],"updatePoint":{"line":378,"column":47},"line":378,"code":"  test('timeout with error + loading components', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        }),\n      delay: 1,\n      timeout: 16,\n      errorComponent: () => 'timed out',\n      loadingComponent: () => 'loading'\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n    await timeout(1)\n    expect(serializeInner(root)).toBe('loading')\n\n    await timeout(16)\n    expect(serializeInner(root)).toBe('timed out')\n    expect(handler).toHaveBeenCalled()\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"timeout without error component, but with loading component","suites":["api: defineAsyncComponent"],"updatePoint":{"line":410,"column":67},"line":410,"code":"  test('timeout without error component, but with loading component', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        }),\n      delay: 1,\n      timeout: 16,\n      loadingComponent: () => 'loading'\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n    const handler = vi.fn()\n    app.config.errorHandler = handler\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n    await timeout(1)\n    expect(serializeInner(root)).toBe('loading')\n\n    await timeout(16)\n    expect(handler).toHaveBeenCalled()\n    expect(handler.mock.calls[0][0].message).toMatch(\n      `Async component timed out after 16ms.`\n    )\n    // should still display loading\n    expect(serializeInner(root)).toBe('loading')\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with suspense","suites":["api: defineAsyncComponent"],"updatePoint":{"line":446,"column":21},"line":446,"code":"  test('with suspense', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        })\n    )\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () =>\n        h(Suspense, null, {\n          default: () => h('div', [h(Foo), ' & ', h(Foo)]),\n          fallback: () => 'loading'\n        })\n    })\n\n    app.mount(root)\n    expect(serializeInner(root)).toBe('loading')\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('<div>resolved & resolved</div>')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"suspensible: false","suites":["api: defineAsyncComponent"],"updatePoint":{"line":472,"column":26},"line":472,"code":"  test('suspensible: false', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent({\n      loader: () =>\n        new Promise(_resolve => {\n          resolve = _resolve as any\n        }),\n      suspensible: false\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () =>\n        h(Suspense, null, {\n          default: () => h('div', [h(Foo), ' & ', h(Foo)]),\n          fallback: () => 'loading'\n        })\n    })\n\n    app.mount(root)\n    // should not show suspense fallback\n    expect(serializeInner(root)).toBe('<div><!----> & <!----></div>')\n\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(serializeInner(root)).toBe('<div>resolved & resolved</div>')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"suspense with error handling","suites":["api: defineAsyncComponent"],"updatePoint":{"line":500,"column":36},"line":500,"code":"  test('suspense with error handling', async () => {\n    let reject: (e: Error) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise((_resolve, _reject) => {\n          reject = _reject\n        })\n    )\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () =>\n        h(Suspense, null, {\n          default: () => h('div', [h(Foo), ' & ', h(Foo)]),\n          fallback: () => 'loading'\n        })\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(root)\n    expect(serializeInner(root)).toBe('loading')\n\n    reject!(new Error('no'))\n    await timeout()\n    expect(handler).toHaveBeenCalled()\n    expect(serializeInner(root)).toBe('<div><!----> & <!----></div>')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"retry (success)","suites":["api: defineAsyncComponent"],"updatePoint":{"line":528,"column":23},"line":528,"code":"  test('retry (success)', async () => {\n    let loaderCallCount = 0\n    let resolve: (comp: Component) => void\n    let reject: (e: Error) => void\n\n    const Foo = defineAsyncComponent({\n      loader: () => {\n        loaderCallCount++\n        return new Promise((_resolve, _reject) => {\n          resolve = _resolve as any\n          reject = _reject\n        })\n      },\n      onError(error, retry, fail) {\n        if (error.message.match(/foo/)) {\n          retry()\n        } else {\n          fail()\n        }\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(loaderCallCount).toBe(1)\n\n    const err = new Error('foo')\n    reject!(err)\n    await timeout()\n    expect(handler).not.toHaveBeenCalled()\n    expect(loaderCallCount).toBe(2)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // should render this time\n    resolve!(() => 'resolved')\n    await timeout()\n    expect(handler).not.toHaveBeenCalled()\n    expect(serializeInner(root)).toBe('resolved')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"retry (skipped)","suites":["api: defineAsyncComponent"],"updatePoint":{"line":574,"column":23},"line":574,"code":"  test('retry (skipped)', async () => {\n    let loaderCallCount = 0\n    let reject: (e: Error) => void\n\n    const Foo = defineAsyncComponent({\n      loader: () => {\n        loaderCallCount++\n        return new Promise((_resolve, _reject) => {\n          reject = _reject\n        })\n      },\n      onError(error, retry, fail) {\n        if (error.message.match(/bar/)) {\n          retry()\n        } else {\n          fail()\n        }\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(loaderCallCount).toBe(1)\n\n    const err = new Error('foo')\n    reject!(err)\n    await timeout()\n    // should fail because retryWhen returns false\n    expect(handler).toHaveBeenCalled()\n    expect(handler.mock.calls[0][0]).toBe(err)\n    expect(loaderCallCount).toBe(1)\n    expect(serializeInner(root)).toBe('<!---->')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"retry (fail w/ max retry attempts)","suites":["api: defineAsyncComponent"],"updatePoint":{"line":614,"column":42},"line":614,"code":"  test('retry (fail w/ max retry attempts)', async () => {\n    let loaderCallCount = 0\n    let reject: (e: Error) => void\n\n    const Foo = defineAsyncComponent({\n      loader: () => {\n        loaderCallCount++\n        return new Promise((_resolve, _reject) => {\n          reject = _reject\n        })\n      },\n      onError(error, retry, fail, attempts) {\n        if (error.message.match(/foo/) && attempts <= 1) {\n          retry()\n        } else {\n          fail()\n        }\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(Foo)\n    })\n\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(root)\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(loaderCallCount).toBe(1)\n\n    // first retry\n    const err = new Error('foo')\n    reject!(err)\n    await timeout()\n    expect(handler).not.toHaveBeenCalled()\n    expect(loaderCallCount).toBe(2)\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // 2nd retry, should fail due to reaching maxRetries\n    reject!(err)\n    await timeout()\n    expect(handler).toHaveBeenCalled()\n    expect(handler.mock.calls[0][0]).toBe(err)\n    expect(loaderCallCount).toBe(2)\n    expect(serializeInner(root)).toBe('<!---->')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"template ref forwarding","suites":["api: defineAsyncComponent"],"updatePoint":{"line":661,"column":31},"line":661,"code":"  test('template ref forwarding', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n\n    const fooRef = ref<any>(null)\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () => (toggle.value ? h(Foo, { ref: fooRef }) : null)\n    }).mount(root)\n\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(fooRef.value).toBe(null)\n\n    resolve!({\n      data() {\n        return {\n          id: 'foo'\n        }\n      },\n      render: () => 'resolved'\n    })\n    // first time resolve, wait for macro task since there are multiple\n    // microtasks / .then() calls\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved')\n    expect(fooRef.value.id).toBe('foo')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(fooRef.value).toBe(null)\n\n    // already resolved component should update on nextTick\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved')\n    expect(fooRef.value.id).toBe('foo')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"the forwarded template ref should always exist when doing multi patching","suites":["api: defineAsyncComponent"],"updatePoint":{"line":707,"column":80},"line":707,"code":"  test('the forwarded template ref should always exist when doing multi patching', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n\n    const fooRef = ref<any>(null)\n    const toggle = ref(true)\n    const updater = ref(0)\n\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () =>\n        toggle.value ? [h(Foo, { ref: fooRef }), updater.value] : null\n    }).mount(root)\n\n    expect(serializeInner(root)).toBe('<!---->0')\n    expect(fooRef.value).toBe(null)\n\n    resolve!({\n      data() {\n        return {\n          id: 'foo'\n        }\n      },\n      render: () => 'resolved'\n    })\n\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved0')\n    expect(fooRef.value.id).toBe('foo')\n\n    updater.value++\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved1')\n    expect(fooRef.value.id).toBe('foo')\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(fooRef.value).toBe(null)\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"vnode hooks on async wrapper","suites":["api: defineAsyncComponent"],"updatePoint":{"line":753,"column":36},"line":753,"code":"  test('vnode hooks on async wrapper', async () => {\n    let resolve: (comp: Component) => void\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n    const updater = ref(0)\n\n    const vnodeHooks = {\n      onVnodeBeforeMount: vi.fn(),\n      onVnodeMounted: vi.fn(),\n      onVnodeBeforeUpdate: vi.fn(),\n      onVnodeUpdated: vi.fn(),\n      onVnodeBeforeUnmount: vi.fn(),\n      onVnodeUnmounted: vi.fn()\n    }\n\n    const toggle = ref(true)\n\n    const root = nodeOps.createElement('div')\n    createApp({\n      render: () => (toggle.value ? [h(Foo, vnodeHooks), updater.value] : null)\n    }).mount(root)\n\n    expect(serializeInner(root)).toBe('<!---->0')\n\n    resolve!({\n      data() {\n        return {\n          id: 'foo'\n        }\n      },\n      render: () => 'resolved'\n    })\n\n    await timeout()\n    expect(serializeInner(root)).toBe('resolved0')\n    expect(vnodeHooks.onVnodeBeforeMount).toHaveBeenCalledTimes(1)\n    expect(vnodeHooks.onVnodeMounted).toHaveBeenCalledTimes(1)\n\n    updater.value++\n    await nextTick()\n    expect(serializeInner(root)).toBe('resolved1')\n    expect(vnodeHooks.onVnodeBeforeUpdate).toHaveBeenCalledTimes(1)\n    expect(vnodeHooks.onVnodeUpdated).toHaveBeenCalledTimes(1)\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n    expect(vnodeHooks.onVnodeBeforeUnmount).toHaveBeenCalledTimes(1)\n    expect(vnodeHooks.onVnodeUnmounted).toHaveBeenCalledTimes(1)\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with KeepAlive","suites":["api: defineAsyncComponent"],"updatePoint":{"line":808,"column":22},"line":808,"code":"  test('with KeepAlive', async () => {\n    const spy = vi.fn()\n    let resolve: (comp: Component) => void\n\n    const Foo = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n\n    const Bar = defineAsyncComponent(() => Promise.resolve(() => 'Bar'))\n\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const app = createApp({\n      render: () => h(KeepAlive, [toggle.value ? h(Foo) : h(Bar)])\n    })\n\n    app.mount(root)\n    await nextTick()\n\n    resolve!({\n      setup() {\n        onActivated(() => {\n          spy()\n        })\n        return () => 'Foo'\n      }\n    })\n\n    await timeout()\n    expect(serializeInner(root)).toBe('Foo')\n    expect(spy).toBeCalledTimes(1)\n\n    toggle.value = false\n    await timeout()\n    expect(serializeInner(root)).toBe('Bar')\n  })","file":"apiAsyncComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"mount","suites":["api: createApp"],"updatePoint":{"line":19,"column":13},"line":19,"code":"  test('mount', () => {\n    const Comp = defineComponent({\n      props: {\n        count: {\n          default: 0\n        }\n      },\n      setup(props) {\n        return () => props.count\n      }\n    })\n\n    const root1 = nodeOps.createElement('div')\n    createApp(Comp).mount(root1)\n    expect(serializeInner(root1)).toBe(`0`)\n    //#5571 mount multiple apps to the same host element\n    createApp(Comp).mount(root1)\n    expect(\n      `There is already an app instance mounted on the host container`\n    ).toHaveBeenWarned()\n\n    // mount with props\n    const root2 = nodeOps.createElement('div')\n    const app2 = createApp(Comp, { count: 1 })\n    app2.mount(root2)\n    expect(serializeInner(root2)).toBe(`1`)\n\n    // remount warning\n    const root3 = nodeOps.createElement('div')\n    app2.mount(root3)\n    expect(serializeInner(root3)).toBe(``)\n    expect(`already been mounted`).toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount","suites":["api: createApp"],"updatePoint":{"line":53,"column":15},"line":53,"code":"  test('unmount', () => {\n    const Comp = defineComponent({\n      props: {\n        count: {\n          default: 0\n        }\n      },\n      setup(props) {\n        return () => props.count\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    const app = createApp(Comp)\n\n    // warning\n    app.unmount()\n    expect(`that is not mounted`).toHaveBeenWarned()\n\n    app.mount(root)\n\n    app.unmount()\n    expect(serializeInner(root)).toBe(``)\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"provide","suites":["api: createApp"],"updatePoint":{"line":78,"column":15},"line":78,"code":"  test('provide', () => {\n    const Root = {\n      setup() {\n        // test override\n        provide('foo', 3)\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        const foo = inject('foo')\n        const bar = inject('bar')\n        try {\n          inject('__proto__')\n        } catch (e: any) {}\n        return () => `${foo},${bar}`\n      }\n    }\n\n    const app = createApp(Root)\n    app.provide('foo', 1)\n    app.provide('bar', 2)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe(`3,2`)\n    expect('[Vue warn]: injection \"__proto__\" not found.').toHaveBeenWarned()\n\n    const app2 = createApp(Root)\n    app2.provide('bar', 1)\n    app2.provide('bar', 2)\n    expect(`App already provides property with key \"bar\".`).toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"runWithContext","suites":["api: createApp"],"updatePoint":{"line":113,"column":22},"line":113,"code":"  test('runWithContext', () => {\n    const app = createApp({\n      setup() {\n        provide('foo', 'should not be seen')\n        return () => h('div')\n      }\n    })\n    app.provide('foo', 1)\n\n    expect(app.runWithContext(() => inject('foo'))).toBe(1)\n\n    // ensure the context is restored\n    inject('foo')\n    expect('inject() can only be used inside setup').toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component","suites":["api: createApp"],"updatePoint":{"line":129,"column":17},"line":129,"code":"  test('component', () => {\n    const Root = {\n      // local override\n      components: {\n        BarBaz: () => 'barbaz-local!'\n      },\n      setup() {\n        // resolve in setup\n        const FooBar = resolveComponent('foo-bar') as any\n        return () => {\n          // resolve in render\n          const BarBaz = resolveComponent('bar-baz') as any\n          return h('div', [h(FooBar), h(BarBaz)])\n        }\n      }\n    }\n\n    const app = createApp(Root)\n\n    const FooBar = () => 'foobar!'\n    app.component('FooBar', FooBar)\n    expect(app.component('FooBar')).toBe(FooBar)\n\n    app.component('BarBaz', () => 'barbaz!')\n\n    app.component('BarBaz', () => 'barbaz!')\n    expect(\n      'Component \"BarBaz\" has already been registered in target app.'\n    ).toHaveBeenWarnedTimes(1)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe(`<div>foobar!barbaz-local!</div>`)\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"directive","suites":["api: createApp"],"updatePoint":{"line":164,"column":17},"line":164,"code":"  test('directive', () => {\n    const spy1 = vi.fn()\n    const spy2 = vi.fn()\n    const spy3 = vi.fn()\n\n    const Root = {\n      // local override\n      directives: {\n        BarBaz: { mounted: spy3 }\n      },\n      setup() {\n        // resolve in setup\n        const FooBar = resolveDirective('foo-bar')!\n        return () => {\n          // resolve in render\n          const BarBaz = resolveDirective('bar-baz')!\n          return withDirectives(h('div'), [[FooBar], [BarBaz]])\n        }\n      }\n    }\n\n    const app = createApp(Root)\n\n    const FooBar = { mounted: spy1 }\n    app.directive('FooBar', FooBar)\n    expect(app.directive('FooBar')).toBe(FooBar)\n\n    app.directive('BarBaz', {\n      mounted: spy2\n    })\n\n    app.directive('BarBaz', {\n      mounted: spy2\n    })\n    expect(\n      'Directive \"BarBaz\" has already been registered in target app.'\n    ).toHaveBeenWarnedTimes(1)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(spy1).toHaveBeenCalled()\n    expect(spy2).not.toHaveBeenCalled()\n    expect(spy3).toHaveBeenCalled()\n\n    app.directive('bind', FooBar)\n    expect(\n      `Do not use built-in directive ids as custom directive id: bind`\n    ).toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"mixin","suites":["api: createApp"],"updatePoint":{"line":214,"column":13},"line":214,"code":"  test('mixin', () => {\n    const calls: string[] = []\n    const mixinA = {\n      data() {\n        return {\n          a: 1\n        }\n      },\n      created(this: any) {\n        calls.push('mixinA created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.c).toBe(3)\n      },\n      mounted() {\n        calls.push('mixinA mounted')\n      }\n    }\n    const mixinB = {\n      name: 'mixinB',\n      data() {\n        return {\n          b: 2\n        }\n      },\n      created(this: any) {\n        calls.push('mixinB created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.c).toBe(3)\n      },\n      mounted() {\n        calls.push('mixinB mounted')\n      }\n    }\n    const Comp = {\n      data() {\n        return {\n          c: 3\n        }\n      },\n      created(this: any) {\n        calls.push('comp created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.c).toBe(3)\n      },\n      mounted() {\n        calls.push('comp mounted')\n      },\n      render(this: any) {\n        return `${this.a}${this.b}${this.c}`\n      }\n    }\n\n    const app = createApp(Comp)\n    app.mixin(mixinA)\n    app.mixin(mixinB)\n\n    app.mixin(mixinA)\n    app.mixin(mixinB)\n    expect(\n      'Mixin has already been applied to target app'\n    ).toHaveBeenWarnedTimes(2)\n    expect(\n      'Mixin has already been applied to target app: mixinB'\n    ).toHaveBeenWarnedTimes(1)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n\n    expect(serializeInner(root)).toBe(`123`)\n    expect(calls).toEqual([\n      'mixinA created',\n      'mixinB created',\n      'comp created',\n      'mixinA mounted',\n      'mixinB mounted',\n      'comp mounted'\n    ])\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"use","suites":["api: createApp"],"updatePoint":{"line":296,"column":11},"line":296,"code":"  test('use', () => {\n    const PluginA: Plugin = app => app.provide('foo', 1)\n    const PluginB: Plugin = {\n      install: (app, arg1, arg2) => app.provide('bar', arg1 + arg2)\n    }\n    class PluginC {\n      someProperty = {}\n      static install() {\n        app.provide('baz', 2)\n      }\n    }\n    const PluginD: any = undefined\n\n    const Root = {\n      setup() {\n        const foo = inject('foo')\n        const bar = inject('bar')\n        return () => `${foo},${bar}`\n      }\n    }\n\n    const app = createApp(Root)\n    app.use(PluginA)\n    app.use(PluginB, 1, 1)\n    app.use(PluginC)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe(`1,2`)\n\n    app.use(PluginA)\n    expect(\n      `Plugin has already been applied to target app`\n    ).toHaveBeenWarnedTimes(1)\n\n    app.use(PluginD)\n    expect(\n      `A plugin must either be a function or an object with an \"install\" ` +\n        `function.`\n    ).toHaveBeenWarnedTimes(1)\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"config.errorHandler","suites":["api: createApp"],"updatePoint":{"line":338,"column":27},"line":338,"code":"  test('config.errorHandler', () => {\n    const error = new Error()\n    const count = ref(0)\n\n    const handler = vi.fn((err, instance, info) => {\n      expect(err).toBe(error)\n      expect((instance as any).count).toBe(count.value)\n      expect(info).toBe(`render function`)\n    })\n\n    const Root = {\n      setup() {\n        const count = ref(0)\n        return {\n          count\n        }\n      },\n      render() {\n        throw error\n      }\n    }\n\n    const app = createApp(Root)\n    app.config.errorHandler = handler\n    app.mount(nodeOps.createElement('div'))\n    expect(handler).toHaveBeenCalled()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"config.warnHandler","suites":["api: createApp"],"updatePoint":{"line":366,"column":26},"line":366,"code":"  test('config.warnHandler', () => {\n    let ctx: any\n    const handler = vi.fn((msg, instance, trace) => {\n      expect(msg).toMatch(`Component is missing template or render function`)\n      expect(instance).toBe(ctx.proxy)\n      expect(trace).toMatch(`Hello`)\n    })\n\n    const Root = {\n      name: 'Hello',\n      setup() {\n        ctx = getCurrentInstance()\n      }\n    }\n\n    const app = createApp(Root)\n    app.config.warnHandler = handler\n    app.mount(nodeOps.createElement('div'))\n    expect(handler).toHaveBeenCalledTimes(1)\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Component.name","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":390,"column":24},"line":390,"code":"    test('Component.name', () => {\n      const Root = {\n        name: 'div',\n        render() {\n          return null\n        }\n      }\n\n      const app = createApp(Root)\n\n      Object.defineProperty(app.config, 'isNativeTag', {\n        value: isNativeTag,\n        writable: false\n      })\n\n      app.mount(nodeOps.createElement('div'))\n      expect(\n        `Do not use built-in or reserved HTML elements as component id: div`\n      ).toHaveBeenWarned()\n    })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Component.components","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":411,"column":30},"line":411,"code":"    test('Component.components', () => {\n      const Root = {\n        components: {\n          div: () => 'div'\n        },\n        render() {\n          return null\n        }\n      }\n\n      const app = createApp(Root)\n      Object.defineProperty(app.config, 'isNativeTag', {\n        value: isNativeTag,\n        writable: false\n      })\n\n      app.mount(nodeOps.createElement('div'))\n      expect(\n        `Do not use built-in or reserved HTML elements as component id: div`\n      ).toHaveBeenWarned()\n    })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Component.directives","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":433,"column":30},"line":433,"code":"    test('Component.directives', () => {\n      const Root = {\n        directives: {\n          bind: () => {}\n        },\n        render() {\n          return null\n        }\n      }\n\n      const app = createApp(Root)\n      Object.defineProperty(app.config, 'isNativeTag', {\n        value: isNativeTag,\n        writable: false\n      })\n\n      app.mount(nodeOps.createElement('div'))\n      expect(\n        `Do not use built-in directive ids as custom directive id: bind`\n      ).toHaveBeenWarned()\n    })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"register using app.component","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":455,"column":38},"line":455,"code":"    test('register using app.component', () => {\n      const app = createApp({\n        render() {}\n      })\n\n      Object.defineProperty(app.config, 'isNativeTag', {\n        value: isNativeTag,\n        writable: false\n      })\n\n      app.component('div', () => 'div')\n      app.mount(nodeOps.createElement('div'))\n      expect(\n        `Do not use built-in or reserved HTML elements as component id: div`\n      ).toHaveBeenWarned()\n    })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"config.optionMergeStrategies","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":473,"column":36},"line":473,"code":"  test('config.optionMergeStrategies', () => {\n    let merged: string\n    const App = defineComponent({\n      render() {},\n      mixins: [{ foo: 'mixin' }],\n      extends: { foo: 'extends' },\n      foo: 'local',\n      beforeCreate() {\n        merged = this.$options.foo\n      }\n    })\n\n    const app = createApp(App)\n    app.mixin({\n      foo: 'global'\n    })\n    app.config.optionMergeStrategies.foo = (a, b) => (a ? `${a},` : ``) + b\n\n    app.mount(nodeOps.createElement('div'))\n    expect(merged!).toBe('global,extends,mixin,local')\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"config.globalProperties","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":495,"column":31},"line":495,"code":"  test('config.globalProperties', () => {\n    const app = createApp({\n      render() {\n        return this.foo\n      }\n    })\n    app.config.globalProperties.foo = 'hello'\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe('hello')\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"return property \"_\" should not overwrite \"ctx._\", __isScriptSetup: false","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":507,"column":80},"line":507,"code":"  test('return property \"_\" should not overwrite \"ctx._\", __isScriptSetup: false', () => {\n    const Comp = defineComponent({\n      setup() {\n        return {\n          _: ref(0) // return property \"_\" should not overwrite \"ctx._\"\n        }\n      },\n      render() {\n        return h('input', {\n          ref: 'input'\n        })\n      }\n    })\n\n    const root1 = nodeOps.createElement('div')\n    createApp(Comp).mount(root1)\n\n    expect(\n      `setup() return property \"_\" should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`\n    ).toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"return property \"_\" should not overwrite \"ctx._\", __isScriptSetup: true","suites":["api: createApp","config.isNativeTag"],"updatePoint":{"line":529,"column":79},"line":529,"code":"  test('return property \"_\" should not overwrite \"ctx._\", __isScriptSetup: true', () => {\n    const Comp = defineComponent({\n      setup() {\n        return {\n          _: ref(0), // return property \"_\" should not overwrite \"ctx._\"\n          __isScriptSetup: true // mock __isScriptSetup = true\n        }\n      },\n      render() {\n        return h('input', {\n          ref: 'input'\n        })\n      }\n    })\n\n    const root1 = nodeOps.createElement('div')\n    const app = createApp(Comp).mount(root1)\n\n    // trigger\n    app.$refs.input\n\n    expect(\n      `TypeError: Cannot read property '__isScriptSetup' of undefined`\n    ).not.toHaveBeenWarned()\n  })","file":"apiCreateApp.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"via setup context","suites":["api: expose"],"updatePoint":{"line":5,"column":25},"line":5,"code":"  test('via setup context', () => {\n    const Child = defineComponent({\n      render() {},\n      setup(_, { expose }) {\n        expose({\n          foo: 1,\n          bar: ref(2)\n        })\n        return {\n          bar: ref(3),\n          baz: ref(4)\n        }\n      }\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(childRef.value).toBeTruthy()\n    expect(childRef.value.foo).toBe(1)\n    expect(childRef.value.bar).toBe(2)\n    expect(childRef.value.baz).toBeUndefined()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"via options","suites":["api: expose"],"updatePoint":{"line":34,"column":19},"line":34,"code":"  test('via options', () => {\n    const Child = defineComponent({\n      render() {},\n      data() {\n        return {\n          foo: 1\n        }\n      },\n      setup() {\n        return {\n          bar: ref(2),\n          baz: ref(3)\n        }\n      },\n      expose: ['foo', 'bar']\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(childRef.value).toBeTruthy()\n    expect(childRef.value.foo).toBe(1)\n    expect(childRef.value.bar).toBe(2)\n    expect(childRef.value.baz).toBeUndefined()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"options + context","suites":["api: expose"],"updatePoint":{"line":65,"column":25},"line":65,"code":"  test('options + context', () => {\n    const Child = defineComponent({\n      render() {},\n      expose: ['foo'],\n      data() {\n        return {\n          foo: 1\n        }\n      },\n      setup(_, { expose }) {\n        expose({\n          bar: ref(2)\n        })\n        return {\n          bar: ref(3),\n          baz: ref(4)\n        }\n      }\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(childRef.value).toBeTruthy()\n    expect(childRef.value.foo).toBe(1)\n    expect(childRef.value.bar).toBe(2)\n    expect(childRef.value.baz).toBeUndefined()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"options: empty","suites":["api: expose"],"updatePoint":{"line":99,"column":22},"line":99,"code":"  test('options: empty', () => {\n    const Child = defineComponent({\n      render() {},\n      expose: [],\n      data() {\n        return {\n          foo: 1\n        }\n      }\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(childRef.value).toBeTruthy()\n    expect('foo' in childRef.value).toBe(false)\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"options: empty + setup context","suites":["api: expose"],"updatePoint":{"line":122,"column":38},"line":122,"code":"  test('options: empty + setup context', () => {\n    const Child = defineComponent({\n      render() {},\n      expose: [],\n      setup(_, { expose }) {\n        expose({\n          foo: 1\n        })\n      }\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(childRef.value).toBeTruthy()\n    expect(childRef.value.foo).toBe(1)\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with $parent/$root","suites":["api: expose"],"updatePoint":{"line":145,"column":26},"line":145,"code":"  test('with $parent/$root', () => {\n    const Child = defineComponent({\n      render() {\n        expect((this.$parent! as any).foo).toBe(1)\n        expect((this.$parent! as any).bar).toBe(undefined)\n        expect((this.$root! as any).foo).toBe(1)\n        expect((this.$root! as any).bar).toBe(undefined)\n      }\n    })\n\n    const Parent = defineComponent({\n      expose: [],\n      setup(_, { expose }) {\n        expose({\n          foo: 1\n        })\n        return {\n          bar: 2\n        }\n      },\n      render() {\n        return h(Child)\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with mount","suites":["api: expose"],"updatePoint":{"line":173,"column":18},"line":173,"code":"  test('with mount', () => {\n    const Component = defineComponent({\n      setup(_, { expose }) {\n        expose({\n          foo: 1\n        })\n        return {\n          bar: 2\n        }\n      },\n      render() {\n        return h('div')\n      }\n    })\n    const root = nodeOps.createElement('div')\n    const vm = createApp(Component).mount(root) as any\n    expect(vm.foo).toBe(1)\n    expect(vm.bar).toBe(undefined)\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"expose should allow access to built-in instance properties","suites":["api: expose"],"updatePoint":{"line":193,"column":66},"line":193,"code":"  test('expose should allow access to built-in instance properties', () => {\n    const GrandChild = defineComponent({\n      render() {\n        return h('div')\n      }\n    })\n\n    const grandChildRef = ref()\n    const Child = defineComponent({\n      render() {\n        return h('div')\n      },\n      setup(_, { expose }) {\n        expose({\n          foo: 42\n        })\n        return () => h(GrandChild, { ref: grandChildRef })\n      }\n    })\n\n    const childRef = ref()\n    const Parent = {\n      setup() {\n        return () => h(Child, { ref: childRef })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect('$el' in childRef.value).toBe(true)\n    expect(childRef.value.$el.tag).toBe('div')\n    expect('foo' in childRef.value).toBe(true)\n    expect('$parent' in grandChildRef.value).toBe(true)\n    expect(grandChildRef.value.$parent).toBe(childRef.value)\n    expect(grandChildRef.value.$parent.$parent).toBe(grandChildRef.value.$root)\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warning for ref","suites":["api: expose"],"updatePoint":{"line":229,"column":23},"line":229,"code":"  test('warning for ref', () => {\n    const Comp = defineComponent({\n      setup(_, { expose }) {\n        expose(ref(1))\n        return () => null\n      }\n    })\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(\n      'expose() should be passed a plain object, received ref'\n    ).toHaveBeenWarned()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warning for array","suites":["api: expose"],"updatePoint":{"line":242,"column":25},"line":242,"code":"  test('warning for array', () => {\n    const Comp = defineComponent({\n      setup(_, { expose }) {\n        expose(['focus'])\n        return () => null\n      }\n    })\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(\n      'expose() should be passed a plain object, received array'\n    ).toHaveBeenWarned()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warning for function","suites":["api: expose"],"updatePoint":{"line":255,"column":28},"line":255,"code":"  test('warning for function', () => {\n    const Comp = defineComponent({\n      setup(_, { expose }) {\n        expose(() => null)\n        return () => null\n      }\n    })\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(\n      'expose() should be passed a plain object, received function'\n    ).toHaveBeenWarned()\n  })","file":"apiExpose.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string keys","suites":["api: provide/inject"],"updatePoint":{"line":18,"column":17},"line":18,"code":"  it('string keys', () => {\n    const Provider = {\n      setup() {\n        provide('foo', 1)\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const foo = inject('foo')\n        return () => foo\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>1</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"symbol keys","suites":["api: provide/inject"],"updatePoint":{"line":42,"column":17},"line":42,"code":"  it('symbol keys', () => {\n    // also verifies InjectionKey type sync\n    const key: InjectionKey<number> = Symbol()\n\n    const Provider = {\n      setup() {\n        provide(key, 1)\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const foo = inject(key) || 1\n        return () => foo + 1\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>2</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"default values","suites":["api: provide/inject"],"updatePoint":{"line":69,"column":20},"line":69,"code":"  it('default values', () => {\n    const Provider = {\n      setup() {\n        provide('foo', 'foo')\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        // default value should be ignored if value is provided\n        const foo = inject('foo', 'fooDefault')\n        // default value should be used if value is not provided\n        const bar = inject('bar', 'bar')\n        return () => foo + bar\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>foobar</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"bound to instance","suites":["api: provide/inject"],"updatePoint":{"line":96,"column":23},"line":96,"code":"  it('bound to instance', () => {\n    const Provider = {\n      setup() {\n        return () => h(Consumer)\n      }\n    }\n\n    const Consumer = defineComponent({\n      name: 'Consumer',\n      inject: {\n        foo: {\n          from: 'foo',\n          default() {\n            return this!.$options.name\n          }\n        }\n      },\n      render() {\n        // @ts-ignore\n        return this.foo\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>Consumer</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested providers","suites":["api: provide/inject"],"updatePoint":{"line":124,"column":22},"line":124,"code":"  it('nested providers', () => {\n    const ProviderOne = {\n      setup() {\n        provide('foo', 'foo')\n        provide('bar', 'bar')\n        return () => h(ProviderTwo)\n      }\n    }\n\n    const ProviderTwo = {\n      setup() {\n        // override parent value\n        provide('foo', 'fooOverride')\n        provide('baz', 'baz')\n        return () => h(Consumer)\n      }\n    }\n\n    const Consumer = {\n      setup() {\n        const foo = inject('foo')\n        const bar = inject('bar')\n        const baz = inject('baz')\n        return () => [foo, bar, baz].join(',')\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(ProviderOne), root)\n    expect(serialize(root)).toBe(`<div>fooOverride,bar,baz</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reactivity with refs","suites":["api: provide/inject"],"updatePoint":{"line":156,"column":26},"line":156,"code":"  it('reactivity with refs', async () => {\n    const count = ref(1)\n\n    const Provider = {\n      setup() {\n        provide('count', count)\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const count = inject<Ref<number>>('count')!\n        return () => count.value\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>1</div>`)\n\n    count.value++\n    await nextTick()\n    expect(serialize(root)).toBe(`<div>2</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reactivity with readonly refs","suites":["api: provide/inject"],"updatePoint":{"line":186,"column":35},"line":186,"code":"  it('reactivity with readonly refs', async () => {\n    const count = ref(1)\n\n    const Provider = {\n      setup() {\n        provide('count', readonly(count))\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const count = inject<Ref<number>>('count')!\n        // should not work\n        count.value++\n        return () => count.value\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>1</div>`)\n\n    expect(\n      `Set operation on key \"value\" failed: target is readonly`\n    ).toHaveBeenWarned()\n\n    // source mutation should still work\n    count.value++\n    await nextTick()\n    expect(serialize(root)).toBe(`<div>2</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reactivity with objects","suites":["api: provide/inject"],"updatePoint":{"line":223,"column":29},"line":223,"code":"  it('reactivity with objects', async () => {\n    const rootState = reactive({ count: 1 })\n\n    const Provider = {\n      setup() {\n        provide('state', rootState)\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const state = inject<typeof rootState>('state')!\n        return () => state.count\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>1</div>`)\n\n    rootState.count++\n    await nextTick()\n    expect(serialize(root)).toBe(`<div>2</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reactivity with readonly objects","suites":["api: provide/inject"],"updatePoint":{"line":253,"column":38},"line":253,"code":"  it('reactivity with readonly objects', async () => {\n    const rootState = reactive({ count: 1 })\n\n    const Provider = {\n      setup() {\n        provide('state', readonly(rootState))\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const state = inject<typeof rootState>('state')!\n        // should not work\n        state.count++\n        return () => state.count\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div>1</div>`)\n\n    expect(\n      `Set operation on key \"count\" failed: target is readonly`\n    ).toHaveBeenWarned()\n\n    rootState.count++\n    await nextTick()\n    expect(serialize(root)).toBe(`<div>2</div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn unfound","suites":["api: provide/inject"],"updatePoint":{"line":289,"column":25},"line":289,"code":"  it('should warn unfound', () => {\n    const Provider = {\n      setup() {\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const foo = inject('foo')\n        expect(foo).toBeUndefined()\n        return () => foo\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(serialize(root)).toBe(`<div><!----></div>`)\n    expect(`injection \"foo\" not found.`).toHaveBeenWarned()\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn when default value is undefined","suites":["api: provide/inject"],"updatePoint":{"line":314,"column":53},"line":314,"code":"  it('should not warn when default value is undefined', () => {\n    const Provider = {\n      setup() {\n        return () => h(Middle)\n      }\n    }\n\n    const Middle = {\n      render: () => h(Consumer)\n    }\n\n    const Consumer = {\n      setup() {\n        const foo = inject('foo', undefined)\n        return () => foo\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Provider), root)\n    expect(`injection \"foo\" not found.`).not.toHaveBeenWarned()\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not self-inject","suites":["api: provide/inject"],"updatePoint":{"line":338,"column":28},"line":338,"code":"  it('should not self-inject', () => {\n    const Comp = {\n      setup() {\n        provide('foo', 'foo')\n        const injection = inject('foo', null)\n        return () => injection\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serialize(root)).toBe(`<div><!----></div>`)\n  })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should be false outside of setup","suites":["api: provide/inject","hasInjectionContext"],"updatePoint":{"line":353,"column":40},"line":353,"code":"    it('should be false outside of setup', () => {\n      expect(hasInjectionContext()).toBe(false)\n    })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should be true within setup","suites":["api: provide/inject","hasInjectionContext"],"updatePoint":{"line":357,"column":35},"line":357,"code":"    it('should be true within setup', () => {\n      expect.assertions(1)\n      const Comp = {\n        setup() {\n          expect(hasInjectionContext()).toBe(true)\n          return () => null\n        }\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n    })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should be true within app.runWithContext()","suites":["api: provide/inject","hasInjectionContext"],"updatePoint":{"line":370,"column":50},"line":370,"code":"    it('should be true within app.runWithContext()', () => {\n      expect.assertions(1)\n      createApp({}).runWithContext(() => {\n        expect(hasInjectionContext()).toBe(true)\n      })\n    })","file":"apiInject.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onBeforeMount","suites":["api: lifecycle hooks"],"updatePoint":{"line":25,"column":19},"line":25,"code":"  it('onBeforeMount', () => {\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called before inner div is rendered\n      expect(serializeInner(root)).toBe(``)\n    })\n\n    const Comp = {\n      setup() {\n        onBeforeMount(fn)\n        return () => h('div')\n      }\n    }\n    render(h(Comp), root)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onMounted","suites":["api: lifecycle hooks"],"updatePoint":{"line":42,"column":15},"line":42,"code":"  it('onMounted', () => {\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called after inner div is rendered\n      expect(serializeInner(root)).toBe(`<div></div>`)\n    })\n\n    const Comp = {\n      setup() {\n        onMounted(fn)\n        return () => h('div')\n      }\n    }\n    render(h(Comp), root)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onBeforeUpdate","suites":["api: lifecycle hooks"],"updatePoint":{"line":59,"column":20},"line":59,"code":"  it('onBeforeUpdate', async () => {\n    const count = ref(0)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called before inner div is updated\n      expect(serializeInner(root)).toBe(`<div>0</div>`)\n    })\n\n    const Comp = {\n      setup() {\n        onBeforeUpdate(fn)\n        return () => h('div', count.value)\n      }\n    }\n    render(h(Comp), root)\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(serializeInner(root)).toBe(`<div>1</div>`)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"state mutation in onBeforeUpdate","suites":["api: lifecycle hooks"],"updatePoint":{"line":81,"column":38},"line":81,"code":"  it('state mutation in onBeforeUpdate', async () => {\n    const count = ref(0)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called before inner div is updated\n      expect(serializeInner(root)).toBe(`<div>0</div>`)\n      count.value++\n    })\n    const renderSpy = vi.fn()\n\n    const Comp = {\n      setup() {\n        onBeforeUpdate(fn)\n        return () => {\n          renderSpy()\n          return h('div', count.value)\n        }\n      }\n    }\n    render(h(Comp), root)\n    expect(renderSpy).toHaveBeenCalledTimes(1)\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(renderSpy).toHaveBeenCalledTimes(2)\n    expect(serializeInner(root)).toBe(`<div>2</div>`)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onUpdated","suites":["api: lifecycle hooks"],"updatePoint":{"line":110,"column":15},"line":110,"code":"  it('onUpdated', async () => {\n    const count = ref(0)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called after inner div is updated\n      expect(serializeInner(root)).toBe(`<div>1</div>`)\n    })\n\n    const Comp = {\n      setup() {\n        onUpdated(fn)\n        return () => h('div', count.value)\n      }\n    }\n    render(h(Comp), root)\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onBeforeUnmount","suites":["api: lifecycle hooks"],"updatePoint":{"line":131,"column":21},"line":131,"code":"  it('onBeforeUnmount', async () => {\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called before inner div is removed\n      expect(serializeInner(root)).toBe(`<div></div>`)\n    })\n\n    const Comp = {\n      setup() {\n        return () => (toggle.value ? h(Child) : null)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onBeforeUnmount(fn)\n        return () => h('div')\n      }\n    }\n\n    render(h(Comp), root)\n\n    toggle.value = false\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onUnmounted","suites":["api: lifecycle hooks"],"updatePoint":{"line":159,"column":17},"line":159,"code":"  it('onUnmounted', async () => {\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called after inner div is removed\n      expect(serializeInner(root)).toBe(`<!---->`)\n    })\n\n    const Comp = {\n      setup() {\n        return () => (toggle.value ? h(Child) : null)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onUnmounted(fn)\n        return () => h('div')\n      }\n    }\n\n    render(h(Comp), root)\n\n    toggle.value = false\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onBeforeUnmount in onMounted","suites":["api: lifecycle hooks"],"updatePoint":{"line":187,"column":34},"line":187,"code":"  it('onBeforeUnmount in onMounted', async () => {\n    const toggle = ref(true)\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn(() => {\n      // should be called before inner div is removed\n      expect(serializeInner(root)).toBe(`<div></div>`)\n    })\n\n    const Comp = {\n      setup() {\n        return () => (toggle.value ? h(Child) : null)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onMounted(() => {\n          onBeforeUnmount(fn)\n        })\n        return () => h('div')\n      }\n    }\n\n    render(h(Comp), root)\n\n    toggle.value = false\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"lifecycle call order","suites":["api: lifecycle hooks"],"updatePoint":{"line":217,"column":26},"line":217,"code":"  it('lifecycle call order', async () => {\n    const count = ref(0)\n    const root = nodeOps.createElement('div')\n    const calls: string[] = []\n\n    const Root = {\n      setup() {\n        onBeforeMount(() => calls.push('root onBeforeMount'))\n        onMounted(() => calls.push('root onMounted'))\n        onBeforeUpdate(() => calls.push('root onBeforeUpdate'))\n        onUpdated(() => calls.push('root onUpdated'))\n        onBeforeUnmount(() => calls.push('root onBeforeUnmount'))\n        onUnmounted(() => calls.push('root onUnmounted'))\n        return () => h(Mid, { count: count.value })\n      }\n    }\n\n    const Mid = {\n      props: ['count'],\n      setup(props: any) {\n        onBeforeMount(() => calls.push('mid onBeforeMount'))\n        onMounted(() => calls.push('mid onMounted'))\n        onBeforeUpdate(() => calls.push('mid onBeforeUpdate'))\n        onUpdated(() => calls.push('mid onUpdated'))\n        onBeforeUnmount(() => calls.push('mid onBeforeUnmount'))\n        onUnmounted(() => calls.push('mid onUnmounted'))\n        return () => h(Child, { count: props.count })\n      }\n    }\n\n    const Child = {\n      props: ['count'],\n      setup(props: any) {\n        onBeforeMount(() => calls.push('child onBeforeMount'))\n        onMounted(() => calls.push('child onMounted'))\n        onBeforeUpdate(() => calls.push('child onBeforeUpdate'))\n        onUpdated(() => calls.push('child onUpdated'))\n        onBeforeUnmount(() => calls.push('child onBeforeUnmount'))\n        onUnmounted(() => calls.push('child onUnmounted'))\n        return () => h('div', props.count)\n      }\n    }\n\n    // mount\n    render(h(Root), root)\n    expect(calls).toEqual([\n      'root onBeforeMount',\n      'mid onBeforeMount',\n      'child onBeforeMount',\n      'child onMounted',\n      'mid onMounted',\n      'root onMounted'\n    ])\n\n    calls.length = 0\n\n    // update\n    count.value++\n    await nextTick()\n    expect(calls).toEqual([\n      'root onBeforeUpdate',\n      'mid onBeforeUpdate',\n      'child onBeforeUpdate',\n      'child onUpdated',\n      'mid onUpdated',\n      'root onUpdated'\n    ])\n\n    calls.length = 0\n\n    // unmount\n    render(null, root)\n    expect(calls).toEqual([\n      'root onBeforeUnmount',\n      'mid onBeforeUnmount',\n      'child onBeforeUnmount',\n      'child onUnmounted',\n      'mid onUnmounted',\n      'root onUnmounted'\n    ])\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onRenderTracked","suites":["api: lifecycle hooks"],"updatePoint":{"line":299,"column":21},"line":299,"code":"  it('onRenderTracked', () => {\n    const events: DebuggerEvent[] = []\n    const onTrack = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive({ foo: 1, bar: 2 })\n\n    const Comp = {\n      setup() {\n        onRenderTracked(onTrack)\n        return () =>\n          h('div', [obj.foo, 'bar' in obj, Object.keys(obj).join('')])\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(onTrack).toHaveBeenCalledTimes(3)\n    expect(events).toMatchObject([\n      {\n        target: obj,\n        type: TrackOpTypes.GET,\n        key: 'foo'\n      },\n      {\n        target: obj,\n        type: TrackOpTypes.HAS,\n        key: 'bar'\n      },\n      {\n        target: obj,\n        type: TrackOpTypes.ITERATE,\n        key: ITERATE_KEY\n      }\n    ])\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onRenderTriggered","suites":["api: lifecycle hooks"],"updatePoint":{"line":335,"column":23},"line":335,"code":"  it('onRenderTriggered', async () => {\n    const events: DebuggerEvent[] = []\n    const onTrigger = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive<{\n      foo: number\n      bar?: number\n    }>({ foo: 1, bar: 2 })\n\n    const Comp = {\n      setup() {\n        onRenderTriggered(onTrigger)\n        return () =>\n          h('div', [obj.foo, 'bar' in obj, Object.keys(obj).join('')])\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    obj.foo++\n    await nextTick()\n    expect(onTrigger).toHaveBeenCalledTimes(1)\n    expect(events[0]).toMatchObject({\n      type: TriggerOpTypes.SET,\n      key: 'foo',\n      oldValue: 1,\n      newValue: 2\n    })\n\n    delete obj.bar\n    await nextTick()\n    expect(onTrigger).toHaveBeenCalledTimes(2)\n    expect(events[1]).toMatchObject({\n      type: TriggerOpTypes.DELETE,\n      key: 'bar',\n      oldValue: 2\n    })\n    ;(obj as any).baz = 3\n    await nextTick()\n    expect(onTrigger).toHaveBeenCalledTimes(3)\n    expect(events[2]).toMatchObject({\n      type: TriggerOpTypes.ADD,\n      key: 'baz',\n      newValue: 3\n    })\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"runs shared hook fn for each instance","suites":["api: lifecycle hooks"],"updatePoint":{"line":383,"column":43},"line":383,"code":"  it('runs shared hook fn for each instance', async () => {\n    const fn = vi.fn()\n    const toggle = ref(true)\n    const Comp = {\n      setup() {\n        return () => (toggle.value ? [h(Child), h(Child)] : null)\n      }\n    }\n    const Child = {\n      setup() {\n        onMounted(fn)\n        onBeforeUnmount(fn)\n        return () => h('div')\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledTimes(2)\n    toggle.value = false\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(4)\n  })","file":"apiLifecycle.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"data","suites":["api: options"],"updatePoint":{"line":22,"column":12},"line":22,"code":"  test('data', async () => {\n    const Comp = defineComponent({\n      data() {\n        return {\n          foo: 1\n        }\n      },\n      render() {\n        return h(\n          'div',\n          {\n            onClick: () => {\n              this.foo++\n            }\n          },\n          this.foo\n        )\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>1</div>`)\n\n    triggerEvent(root.children[0] as TestElement, 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>2</div>`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed","suites":["api: options"],"updatePoint":{"line":50,"column":16},"line":50,"code":"  test('computed', async () => {\n    const Comp = defineComponent({\n      data() {\n        return {\n          foo: 1\n        }\n      },\n      computed: {\n        bar(): number {\n          return this.foo + 1\n        },\n        baz: (vm: any): number => vm.bar + 1\n      },\n      render() {\n        return h(\n          'div',\n          {\n            onClick: () => {\n              this.foo++\n            }\n          },\n          this.bar + this.baz\n        )\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>5</div>`)\n\n    triggerEvent(root.children[0] as TestElement, 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>7</div>`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"methods","suites":["api: options"],"updatePoint":{"line":84,"column":15},"line":84,"code":"  test('methods', async () => {\n    const Comp = defineComponent({\n      data() {\n        // #3300 method on ctx should be overwritable\n        this.incBy = this.incBy.bind(this, 2)\n        return {\n          foo: 1\n        }\n      },\n      methods: {\n        inc() {\n          this.foo++\n        },\n        incBy(n = 0) {\n          this.foo += n\n        }\n      },\n      render() {\n        return h(\n          'div',\n          {\n            onClick: this.inc,\n            onFoo: this.incBy\n          },\n          this.foo\n        )\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>1</div>`)\n\n    triggerEvent(root.children[0] as TestElement, 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>2</div>`)\n\n    triggerEvent(root.children[0] as TestElement, 'foo')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>4</div>`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component's own methods have higher priority than global properties","suites":["api: options"],"updatePoint":{"line":125,"column":75},"line":125,"code":"  test(\"component's own methods have higher priority than global properties\", async () => {\n    const app = createApp({\n      methods: {\n        foo() {\n          return 'foo'\n        }\n      },\n      render() {\n        return this.foo()\n      }\n    })\n    app.config.globalProperties.foo = () => 'bar'\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe(`foo`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watch","suites":["api: options"],"updatePoint":{"line":143,"column":13},"line":143,"code":"  test('watch', async () => {\n    function returnThis(this: any) {\n      return this\n    }\n    const spyA = vi.fn(returnThis)\n    const spyB = vi.fn(returnThis)\n    const spyC = vi.fn(returnThis)\n    const spyD = vi.fn(returnThis)\n    const spyE = vi.fn(returnThis)\n\n    let ctx: any\n    const Comp = {\n      data() {\n        return {\n          foo: 1,\n          bar: 2,\n          baz: {\n            qux: 3\n          },\n          qux: 4,\n          dot: {\n            path: 5\n          }\n        }\n      },\n      watch: {\n        // string method name\n        foo: 'onFooChange',\n        // direct function\n        bar: spyB,\n        baz: {\n          handler: spyC,\n          deep: true\n        },\n        qux: {\n          handler: 'onQuxChange'\n        },\n        'dot.path': spyE\n      },\n      methods: {\n        onFooChange: spyA,\n        onQuxChange: spyD\n      },\n      render() {\n        ctx = this\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    function assertCall(spy: Mock, callIndex: number, args: any[]) {\n      expect(spy.mock.calls[callIndex].slice(0, 2)).toMatchObject(args)\n      expect(spy.mock.results[callIndex].value).toBe(ctx)\n    }\n\n    ctx.foo++\n    await nextTick()\n    expect(spyA).toHaveBeenCalledTimes(1)\n    assertCall(spyA, 0, [2, 1])\n\n    ctx.bar++\n    await nextTick()\n    expect(spyB).toHaveBeenCalledTimes(1)\n    assertCall(spyB, 0, [3, 2])\n\n    ctx.baz.qux++\n    await nextTick()\n    expect(spyC).toHaveBeenCalledTimes(1)\n    // new and old objects have same identity\n    assertCall(spyC, 0, [{ qux: 4 }, { qux: 4 }])\n\n    ctx.qux++\n    await nextTick()\n    expect(spyD).toHaveBeenCalledTimes(1)\n    assertCall(spyD, 0, [5, 4])\n\n    ctx.dot.path++\n    await nextTick()\n    expect(spyE).toHaveBeenCalledTimes(1)\n    assertCall(spyE, 0, [6, 5])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watch array","suites":["api: options"],"updatePoint":{"line":225,"column":19},"line":225,"code":"  test('watch array', async () => {\n    function returnThis(this: any) {\n      return this\n    }\n    const spyA = vi.fn(returnThis)\n    const spyB = vi.fn(returnThis)\n    const spyC = vi.fn(returnThis)\n\n    let ctx: any\n    const Comp = {\n      data() {\n        return {\n          foo: 1,\n          bar: 2,\n          baz: {\n            qux: 3\n          }\n        }\n      },\n      watch: {\n        // string method name\n        foo: ['onFooChange'],\n        // direct function\n        bar: [spyB],\n        baz: [\n          {\n            handler: spyC,\n            deep: true\n          }\n        ]\n      },\n      methods: {\n        onFooChange: spyA\n      },\n      render() {\n        ctx = this\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    function assertCall(spy: Mock, callIndex: number, args: any[]) {\n      expect(spy.mock.calls[callIndex].slice(0, 2)).toMatchObject(args)\n      expect(spy.mock.results[callIndex].value).toBe(ctx)\n    }\n\n    ctx.foo++\n    await nextTick()\n    expect(spyA).toHaveBeenCalledTimes(1)\n    assertCall(spyA, 0, [2, 1])\n\n    ctx.bar++\n    await nextTick()\n    expect(spyB).toHaveBeenCalledTimes(1)\n    assertCall(spyB, 0, [3, 2])\n\n    ctx.baz.qux++\n    await nextTick()\n    expect(spyC).toHaveBeenCalledTimes(1)\n    // new and old objects have same identity\n    assertCall(spyC, 0, [{ qux: 4 }, { qux: 4 }])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watch merging from mixins","suites":["api: options"],"updatePoint":{"line":289,"column":33},"line":289,"code":"  test('watch merging from mixins', async () => {\n    const mixinA = {\n      data() {\n        return {\n          fromMixinA: ''\n        }\n      },\n      watch: {\n        obj: {\n          handler(this: any, to: any) {\n            this.fromMixinA = to\n          }\n        }\n      }\n    }\n\n    const mixinB = {\n      data() {\n        return {\n          fromMixinB: ''\n        }\n      },\n      watch: {\n        obj: 'setMixinB'\n      },\n      methods: {\n        setMixinB(this: any, to: any) {\n          this.fromMixinB = to\n        }\n      }\n    }\n\n    let vm: any\n    const Comp = {\n      render() {},\n      mixins: [mixinA, mixinB],\n      data: () => ({\n        obj: 'foo',\n        fromComp: ''\n      }),\n      watch: {\n        obj(this: any, to: any) {\n          this.fromComp = to\n        }\n      },\n      mounted() {\n        vm = this\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    vm.obj = 'bar'\n    await nextTick()\n    expect(vm.fromComp).toBe('bar')\n    expect(vm.fromMixinA).toBe('bar')\n    expect(vm.fromMixinB).toBe('bar')\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"provide/inject","suites":["api: options"],"updatePoint":{"line":349,"column":22},"line":349,"code":"  test('provide/inject', () => {\n    const symbolKey = Symbol()\n    const Root = defineComponent({\n      data() {\n        return {\n          a: 1\n        }\n      },\n      provide() {\n        return {\n          a: this.a,\n          [symbolKey]: 2\n        }\n      },\n      render() {\n        return [\n          h(ChildA),\n          h(ChildB),\n          h(ChildC),\n          h(ChildD),\n          h(ChildE),\n          h(ChildF),\n          h(ChildG),\n          h(ChildH),\n          h(ChildI),\n          h(ChildJ)\n        ]\n      }\n    })\n\n    const defineChild = (injectOptions: any, injectedKey = 'b') =>\n      ({\n        inject: injectOptions,\n        render() {\n          return this[injectedKey]\n        }\n      } as any)\n\n    const ChildA = defineChild(['a'], 'a')\n    const ChildB = defineChild({ b: 'a' })\n    const ChildC = defineChild({\n      b: {\n        from: 'a'\n      }\n    })\n    const ChildD = defineChild(\n      {\n        a: {\n          default: () => 0\n        }\n      },\n      'a'\n    )\n    const ChildE = defineChild({\n      b: {\n        from: 'c',\n        default: 2\n      }\n    })\n    const ChildF = defineChild({\n      b: {\n        from: 'c',\n        default: () => 3\n      }\n    })\n    const ChildG = defineChild({\n      b: {\n        default: 4\n      }\n    })\n    const ChildH = defineChild({\n      b: {\n        default: () => 5\n      }\n    })\n    const ChildI = defineChild({\n      b: symbolKey\n    })\n    const ChildJ = defineChild({\n      b: {\n        from: symbolKey\n      }\n    })\n    expect(renderToString(h(Root))).toBe(`1111234522`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"provide/inject refs","suites":["api: options"],"updatePoint":{"line":435,"column":27},"line":435,"code":"  test('provide/inject refs', async () => {\n    const n = ref(0)\n    const np = computed(() => n.value + 1)\n    const Parent = defineComponent({\n      provide() {\n        return {\n          n,\n          np\n        }\n      },\n      render: () => h(Child)\n    })\n    const Child = defineComponent({\n      inject: ['n', 'np'],\n      render(this: any) {\n        return this.n + this.np\n      }\n    })\n    const app = createApp(Parent)\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toBe(`1`)\n\n    n.value++\n    await nextTick()\n    expect(serializeInner(root)).toBe(`3`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"provide accessing data in extends","suites":["api: options"],"updatePoint":{"line":463,"column":41},"line":463,"code":"  test('provide accessing data in extends', () => {\n    const Base = defineComponent({\n      data() {\n        return {\n          a: 1\n        }\n      },\n      provide() {\n        return {\n          a: this.a\n        }\n      }\n    })\n\n    const Child = {\n      inject: ['a'],\n      render() {\n        return (this as any).a\n      }\n    }\n\n    const Root = defineComponent({\n      extends: Base,\n      render() {\n        return h(Child)\n      }\n    })\n    expect(renderToString(h(Root))).toBe(`1`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"lifecycle","suites":["api: options"],"updatePoint":{"line":493,"column":17},"line":493,"code":"  test('lifecycle', async () => {\n    const count = ref(0)\n    const root = nodeOps.createElement('div')\n    const calls: string[] = []\n\n    const Root = {\n      beforeCreate() {\n        calls.push('root beforeCreate')\n      },\n      created() {\n        calls.push('root created')\n      },\n      beforeMount() {\n        calls.push('root onBeforeMount')\n      },\n      mounted() {\n        calls.push('root onMounted')\n      },\n      beforeUpdate() {\n        calls.push('root onBeforeUpdate')\n      },\n      updated() {\n        calls.push('root onUpdated')\n      },\n      beforeUnmount() {\n        calls.push('root onBeforeUnmount')\n      },\n      unmounted() {\n        calls.push('root onUnmounted')\n      },\n      render() {\n        return h(Mid, { count: count.value })\n      }\n    }\n\n    const Mid = {\n      beforeCreate() {\n        calls.push('mid beforeCreate')\n      },\n      created() {\n        calls.push('mid created')\n      },\n      beforeMount() {\n        calls.push('mid onBeforeMount')\n      },\n      mounted() {\n        calls.push('mid onMounted')\n      },\n      beforeUpdate() {\n        calls.push('mid onBeforeUpdate')\n      },\n      updated() {\n        calls.push('mid onUpdated')\n      },\n      beforeUnmount() {\n        calls.push('mid onBeforeUnmount')\n      },\n      unmounted() {\n        calls.push('mid onUnmounted')\n      },\n      render(this: any) {\n        return h(Child, { count: this.$props.count })\n      }\n    }\n\n    const Child = {\n      beforeCreate() {\n        calls.push('child beforeCreate')\n      },\n      created() {\n        calls.push('child created')\n      },\n      beforeMount() {\n        calls.push('child onBeforeMount')\n      },\n      mounted() {\n        calls.push('child onMounted')\n      },\n      beforeUpdate() {\n        calls.push('child onBeforeUpdate')\n      },\n      updated() {\n        calls.push('child onUpdated')\n      },\n      beforeUnmount() {\n        calls.push('child onBeforeUnmount')\n      },\n      unmounted() {\n        calls.push('child onUnmounted')\n      },\n      render(this: any) {\n        return h('div', this.$props.count)\n      }\n    }\n\n    // mount\n    render(h(Root), root)\n    expect(calls).toEqual([\n      'root beforeCreate',\n      'root created',\n      'root onBeforeMount',\n      'mid beforeCreate',\n      'mid created',\n      'mid onBeforeMount',\n      'child beforeCreate',\n      'child created',\n      'child onBeforeMount',\n      'child onMounted',\n      'mid onMounted',\n      'root onMounted'\n    ])\n\n    calls.length = 0\n\n    // update\n    count.value++\n    await nextTick()\n    expect(calls).toEqual([\n      'root onBeforeUpdate',\n      'mid onBeforeUpdate',\n      'child onBeforeUpdate',\n      'child onUpdated',\n      'mid onUpdated',\n      'root onUpdated'\n    ])\n\n    calls.length = 0\n\n    // unmount\n    render(null, root)\n    expect(calls).toEqual([\n      'root onBeforeUnmount',\n      'mid onBeforeUnmount',\n      'child onBeforeUnmount',\n      'child onUnmounted',\n      'mid onUnmounted',\n      'root onUnmounted'\n    ])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"mixins","suites":["api: options"],"updatePoint":{"line":633,"column":14},"line":633,"code":"  test('mixins', () => {\n    const calls: string[] = []\n    const mixinA = defineComponent({\n      data() {\n        return {\n          a: 1\n        }\n      },\n      created(this: any) {\n        calls.push('mixinA created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.c).toBe(4)\n      },\n      mounted() {\n        calls.push('mixinA mounted')\n      }\n    })\n    const mixinB = defineComponent({\n      props: {\n        bP: {\n          type: String\n        }\n      },\n      data() {\n        return {\n          b: 2\n        }\n      },\n      created(this: any) {\n        calls.push('mixinB created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.bP).toBeUndefined()\n        expect(this.c).toBe(4)\n        expect(this.cP1).toBeUndefined()\n      },\n      mounted() {\n        calls.push('mixinB mounted')\n      }\n    })\n    const mixinC = defineComponent({\n      props: ['cP1', 'cP2'],\n      data() {\n        return {\n          c: 3\n        }\n      },\n      created() {\n        calls.push('mixinC created')\n        // component data() should overwrite mixin field with same key\n        expect(this.c).toBe(4)\n        expect(this.cP1).toBeUndefined()\n      },\n      mounted() {\n        calls.push('mixinC mounted')\n      }\n    })\n    const Comp = defineComponent({\n      props: {\n        aaa: String\n      },\n      mixins: [mixinA, mixinB, mixinC],\n      data() {\n        return {\n          c: 4,\n          z: 4\n        }\n      },\n      created() {\n        calls.push('comp created')\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        expect(this.bP).toBeUndefined()\n        expect(this.c).toBe(4)\n        expect(this.cP2).toBeUndefined()\n        expect(this.z).toBe(4)\n      },\n      mounted() {\n        calls.push('comp mounted')\n      },\n      render() {\n        return `${this.a}${this.b}${this.c}`\n      }\n    })\n    expect(renderToString(h(Comp))).toBe(`124`)\n    expect(calls).toEqual([\n      'mixinA created',\n      'mixinB created',\n      'mixinC created',\n      'comp created',\n      'mixinA mounted',\n      'mixinB mounted',\n      'mixinC mounted',\n      'comp mounted'\n    ])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"render from mixin","suites":["api: options"],"updatePoint":{"line":731,"column":25},"line":731,"code":"  test('render from mixin', () => {\n    const Comp = {\n      mixins: [\n        {\n          render: () => 'from mixin'\n        }\n      ]\n    }\n    expect(renderToString(h(Comp))).toBe('from mixin')\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"chained mixins in extends","suites":["api: options"],"updatePoint":{"line":742,"column":33},"line":742,"code":"  test('chained mixins in extends', () => {\n    const calls: string[] = []\n    const mixinA = {\n      beforeCreate() {\n        calls.push('mixinA beforeCreate')\n      },\n      created() {\n        calls.push('mixinA created')\n      }\n    }\n\n    const extendA = {\n      mixins: [mixinA],\n      beforeCreate() {\n        calls.push('extendA beforeCreate')\n      },\n      created() {\n        calls.push('extendA created')\n      }\n    }\n\n    const Comp = {\n      extends: extendA,\n      render: () => '123',\n      beforeCreate() {\n        calls.push('self beforeCreate')\n      },\n      created() {\n        calls.push('self created')\n      }\n    }\n\n    expect(renderToString(h(Comp))).toBe(`123`)\n    expect(calls).toEqual([\n      'mixinA beforeCreate',\n      'extendA beforeCreate',\n      'self beforeCreate',\n      'mixinA created',\n      'extendA created',\n      'self created'\n    ])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unlikely mixin usage","suites":["api: options"],"updatePoint":{"line":785,"column":28},"line":785,"code":"  test('unlikely mixin usage', () => {\n    const MixinA = {\n      data() {}\n    }\n    const MixinB = {\n      data() {}\n    }\n    defineComponent({\n      // @ts-expect-error edge case after #7963, unlikely to happen in practice\n      // since the user will want to type the mixins themselves.\n      mixins: [defineComponent(MixinA), defineComponent(MixinB)],\n      // @ts-expect-error\n      data() {}\n    })\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"chained extends in mixins","suites":["api: options"],"updatePoint":{"line":801,"column":33},"line":801,"code":"  test('chained extends in mixins', () => {\n    const calls: string[] = []\n\n    const extendA = {\n      beforeCreate() {\n        calls.push('extendA beforeCreate')\n      },\n      created() {\n        calls.push('extendA created')\n      }\n    }\n\n    const mixinA = {\n      extends: extendA,\n      beforeCreate() {\n        calls.push('mixinA beforeCreate')\n      },\n      created() {\n        calls.push('mixinA created')\n      }\n    }\n\n    const Comp = {\n      mixins: [mixinA],\n      render: () => '123',\n      beforeCreate() {\n        calls.push('self beforeCreate')\n      },\n      created() {\n        calls.push('self created')\n      }\n    }\n\n    expect(renderToString(h(Comp))).toBe(`123`)\n    expect(calls).toEqual([\n      'extendA beforeCreate',\n      'mixinA beforeCreate',\n      'self beforeCreate',\n      'extendA created',\n      'mixinA created',\n      'self created'\n    ])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"extends","suites":["api: options"],"updatePoint":{"line":845,"column":15},"line":845,"code":"  test('extends', () => {\n    const calls: string[] = []\n    const Base = defineComponent({\n      data() {\n        return {\n          a: 1,\n          b: 1\n        }\n      },\n      methods: {\n        sayA() {}\n      },\n      mounted(this: any) {\n        expect(this.a).toBe(1)\n        expect(this.b).toBe(2)\n        calls.push('base')\n      }\n    })\n    const Comp = defineComponent({\n      extends: Base,\n      data() {\n        return {\n          b: 2\n        }\n      },\n      mounted() {\n        calls.push('comp')\n      },\n      render() {\n        return `${this.a}${this.b}`\n      }\n    })\n\n    expect(renderToString(h(Comp))).toBe(`12`)\n    expect(calls).toEqual(['base', 'comp'])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"extends with mixins","suites":["api: options"],"updatePoint":{"line":882,"column":27},"line":882,"code":"  test('extends with mixins', () => {\n    const calls: string[] = []\n    const Base = defineComponent({\n      data() {\n        return {\n          a: 1,\n          x: 'base'\n        }\n      },\n      methods: {\n        sayA() {}\n      },\n      mounted(this: any) {\n        expect(this.a).toBe(1)\n        expect(this.b).toBeTruthy()\n        expect(this.c).toBe(2)\n        calls.push('base')\n      }\n    })\n    const Mixin = defineComponent({\n      data() {\n        return {\n          b: true,\n          x: 'mixin'\n        }\n      },\n      mounted(this: any) {\n        expect(this.a).toBe(1)\n        expect(this.b).toBeTruthy()\n        expect(this.c).toBe(2)\n        calls.push('mixin')\n      }\n    })\n    const Comp = defineComponent({\n      extends: Base,\n      mixins: [Mixin],\n      data() {\n        return {\n          c: 2\n        }\n      },\n      mounted() {\n        calls.push('comp')\n      },\n      render() {\n        return `${this.a}${this.b}${this.c}${this.x}`\n      }\n    })\n\n    expect(renderToString(h(Comp))).toBe(`1true2mixin`)\n    expect(calls).toEqual(['base', 'mixin', 'comp'])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"beforeCreate/created in extends and mixins","suites":["api: options"],"updatePoint":{"line":935,"column":50},"line":935,"code":"  test('beforeCreate/created in extends and mixins', () => {\n    const calls: string[] = []\n    const BaseA = {\n      beforeCreate() {\n        calls.push('beforeCreateA')\n      },\n      created() {\n        calls.push('createdA')\n      }\n    }\n    const BaseB = {\n      extends: BaseA,\n      beforeCreate() {\n        calls.push('beforeCreateB')\n      },\n      created() {\n        calls.push('createdB')\n      }\n    }\n\n    const MixinA = {\n      beforeCreate() {\n        calls.push('beforeCreateC')\n      },\n      created() {\n        calls.push('createdC')\n      }\n    }\n    const MixinB = {\n      mixins: [MixinA],\n      beforeCreate() {\n        calls.push('beforeCreateD')\n      },\n      created() {\n        calls.push('createdD')\n      }\n    }\n\n    const Comp = {\n      extends: BaseB,\n      mixins: [MixinB],\n      beforeCreate() {\n        calls.push('selfBeforeCreate')\n      },\n      created() {\n        calls.push('selfCreated')\n      },\n      render() {}\n    }\n\n    renderToString(h(Comp))\n    expect(calls).toEqual([\n      'beforeCreateA',\n      'beforeCreateB',\n      'beforeCreateC',\n      'beforeCreateD',\n      'selfBeforeCreate',\n      'createdA',\n      'createdB',\n      'createdC',\n      'createdD',\n      'selfCreated'\n    ])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flatten merged options","suites":["api: options"],"updatePoint":{"line":1000,"column":30},"line":1000,"code":"  test('flatten merged options', async () => {\n    const MixinBase = {\n      msg1: 'base'\n    }\n    const ExtendsBase = {\n      msg2: 'base'\n    }\n    const Mixin = {\n      mixins: [MixinBase]\n    }\n    const Extends = {\n      extends: ExtendsBase\n    }\n    const Comp = defineComponent({\n      extends: defineComponent(Extends),\n      mixins: [defineComponent(Mixin)],\n      render() {\n        return `${this.$options.msg1},${this.$options.msg2}`\n      }\n    })\n\n    expect(renderToString(h(Comp))).toBe('base,base')\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"extends template","suites":["api: options"],"updatePoint":{"line":1024,"column":24},"line":1024,"code":"  test('extends template', () => {\n    const Comp = {\n      extends: {\n        template: `<h1>Foo</h1>`\n      }\n    }\n\n    const root = document.createElement('div') as any\n    domRender(h(Comp), root)\n    expect(root.innerHTML).toBe(`<h1>Foo</h1>`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"options defined in component have higher priority","suites":["api: options"],"updatePoint":{"line":1036,"column":57},"line":1036,"code":"  test('options defined in component have higher priority', async () => {\n    const Mixin = {\n      msg1: 'base'\n    }\n    const Extends = {\n      msg2: 'base'\n    }\n    const Comp = defineComponent({\n      msg1: 'local',\n      msg2: 'local',\n      extends: defineComponent(Extends),\n      mixins: [defineComponent(Mixin)],\n      render() {\n        return `${this.$options.msg1},${this.$options.msg2}`\n      }\n    })\n\n    expect(renderToString(h(Comp))).toBe('local,local')\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"accessing setup() state from options","suites":["api: options"],"updatePoint":{"line":1056,"column":44},"line":1056,"code":"  test('accessing setup() state from options', async () => {\n    const Comp = defineComponent({\n      setup() {\n        return {\n          count: ref(0)\n        }\n      },\n      data() {\n        return {\n          plusOne: (this as any).count + 1\n        }\n      },\n      computed: {\n        plusTwo(): number {\n          return this.count + 2\n        }\n      },\n      methods: {\n        inc() {\n          this.count++\n        }\n      },\n      render() {\n        return h(\n          'div',\n          {\n            onClick: this.inc\n          },\n          `${this.count},${this.plusOne},${this.plusTwo}`\n        )\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>0,1,2</div>`)\n\n    triggerEvent(root.children[0] as TestElement, 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1,1,3</div>`)\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watcher initialization should be deferred in mixins","suites":["api: options"],"updatePoint":{"line":1098,"column":59},"line":1098,"code":"  test('watcher initialization should be deferred in mixins', async () => {\n    const mixin1 = {\n      data() {\n        return {\n          mixin1Data: 'mixin1'\n        }\n      },\n      methods: {}\n    }\n\n    const watchSpy = vi.fn()\n    const mixin2 = {\n      watch: {\n        mixin3Data: watchSpy\n      }\n    }\n\n    const mixin3 = {\n      data() {\n        return {\n          mixin3Data: 'mixin3'\n        }\n      },\n      methods: {}\n    }\n\n    let vm: any\n    const Comp = {\n      mixins: [mixin1, mixin2, mixin3],\n      render() {},\n      created() {\n        vm = this\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    // should have no warnings\n    vm.mixin3Data = 'hello'\n    await nextTick()\n    expect(watchSpy.mock.calls[0].slice(0, 2)).toEqual(['hello', 'mixin3'])\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"injection from closest ancestor","suites":["api: options"],"updatePoint":{"line":1142,"column":39},"line":1142,"code":"  test('injection from closest ancestor', () => {\n    const Root = defineComponent({\n      provide: {\n        a: 'root'\n      },\n      render() {\n        return [h(Mid), ' ', h(MidWithProvide), ' ', h(MidWithMixinProvide)]\n      }\n    })\n\n    const Mid = {\n      render() {\n        return h(Child)\n      }\n    } as any\n\n    const MidWithProvide = {\n      provide: {\n        a: 'midWithProvide'\n      },\n      render() {\n        return h(Child)\n      }\n    } as any\n\n    const mixin = {\n      provide: {\n        a: 'midWithMixinProvide'\n      }\n    }\n\n    const MidWithMixinProvide = {\n      mixins: [mixin],\n      render() {\n        return h(Child)\n      }\n    } as any\n\n    const Child = {\n      inject: ['a'],\n      render() {\n        return this.a\n      }\n    } as any\n\n    expect(renderToString(h(Root))).toBe(\n      'root midWithProvide midWithMixinProvide'\n    )\n  })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options.data","suites":["api: options","options merge strategies"],"updatePoint":{"line":1193,"column":28},"line":1193,"code":"    test('this.$options.data', () => {\n      const mixin = {\n        data() {\n          return { foo: 1, bar: 2 }\n        }\n      }\n      createApp({\n        mixins: [mixin],\n        data() {\n          return {\n            foo: 3,\n            baz: 4\n          }\n        },\n        created() {\n          expect(this.$options.data).toBeInstanceOf(Function)\n          expect(this.$options.data()).toEqual({\n            foo: 3,\n            bar: 2,\n            baz: 4\n          })\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options.inject","suites":["api: options","options merge strategies"],"updatePoint":{"line":1219,"column":30},"line":1219,"code":"    test('this.$options.inject', () => {\n      const mixin = {\n        inject: ['a']\n      }\n      const app = createApp({\n        mixins: [mixin],\n        inject: { b: 'b', c: { from: 'd' } },\n        created() {\n          expect(this.$options.inject.a).toEqual('a')\n          expect(this.$options.inject.b).toEqual('b')\n          expect(this.$options.inject.c).toEqual({ from: 'd' })\n          expect(this.a).toBe(1)\n          expect(this.b).toBe(2)\n          expect(this.c).toBe(3)\n        },\n        render: () => null\n      })\n\n      app.provide('a', 1)\n      app.provide('b', 2)\n      app.provide('d', 3)\n      app.mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options.provide","suites":["api: options","options merge strategies"],"updatePoint":{"line":1243,"column":31},"line":1243,"code":"    test('this.$options.provide', () => {\n      const mixin = {\n        provide: {\n          a: 1\n        }\n      }\n      createApp({\n        mixins: [mixin],\n        provide() {\n          return {\n            b: 2\n          }\n        },\n        created() {\n          expect(this.$options.provide).toBeInstanceOf(Function)\n          expect(this.$options.provide()).toEqual({ a: 1, b: 2 })\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options[lifecycle-name]","suites":["api: options","options merge strategies"],"updatePoint":{"line":1264,"column":39},"line":1264,"code":"    test('this.$options[lifecycle-name]', () => {\n      const mixin = {\n        mounted() {},\n        beforeUnmount() {},\n        unmounted() {}\n      }\n      createApp({\n        mixins: [mixin],\n        mounted() {},\n        beforeUnmount() {},\n        unmounted() {},\n        created() {\n          expect(this.$options.mounted).toBeInstanceOf(Array)\n          expect(this.$options.mounted.length).toBe(2)\n          expect(this.$options.beforeUnmount).toBeInstanceOf(Array)\n          expect(this.$options.beforeUnmount.length).toBe(2)\n          expect(this.$options.unmounted).toBeInstanceOf(Array)\n          expect(this.$options.unmounted.length).toBe(2)\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options[asset-name]","suites":["api: options","options merge strategies"],"updatePoint":{"line":1287,"column":35},"line":1287,"code":"    test('this.$options[asset-name]', () => {\n      const mixin = {\n        components: {\n          a: {}\n        },\n        directives: {\n          d1: {}\n        }\n      }\n      createApp({\n        mixins: [mixin],\n        components: {\n          b: {}\n        },\n        directives: {\n          d2: {}\n        },\n        created() {\n          expect('a' in this.$options.components).toBe(true)\n          expect('b' in this.$options.components).toBe(true)\n          expect('d1' in this.$options.directives).toBe(true)\n          expect('d2' in this.$options.directives).toBe(true)\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options.methods","suites":["api: options","options merge strategies"],"updatePoint":{"line":1314,"column":31},"line":1314,"code":"    test('this.$options.methods', () => {\n      const mixin = {\n        methods: {\n          fn1() {}\n        }\n      }\n      createApp({\n        mixins: [mixin],\n        methods: {\n          fn2() {}\n        },\n        created() {\n          expect(this.$options.methods.fn1).toBeInstanceOf(Function)\n          expect(this.$options.methods.fn2).toBeInstanceOf(Function)\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$options.computed","suites":["api: options","options merge strategies"],"updatePoint":{"line":1333,"column":32},"line":1333,"code":"    test('this.$options.computed', () => {\n      const mixin = {\n        computed: {\n          c1() {}\n        }\n      }\n      createApp({\n        mixins: [mixin],\n        computed: {\n          c2() {}\n        },\n        created() {\n          expect(this.$options.computed.c1).toBeInstanceOf(Function)\n          expect(this.$options.computed.c2).toBeInstanceOf(Function)\n        },\n        render: () => null\n      }).mount(nodeOps.createElement('div'))\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"modify $options in the beforeCreate hook","suites":["api: options","options merge strategies"],"updatePoint":{"line":1353,"column":50},"line":1353,"code":"    test('modify $options in the beforeCreate hook', async () => {\n      const count = ref(0)\n      const mixin = {\n        data() {\n          return { foo: 1 }\n        },\n        beforeCreate(this: any) {\n          if (!this.$options.computed) {\n            this.$options.computed = {}\n          }\n          this.$options.computed.value = () => count.value\n        }\n      }\n      const root = nodeOps.createElement('div')\n      createApp({\n        mixins: [mixin],\n        render(this: any) {\n          return this.value\n        }\n      }).mount(root)\n\n      expect(serializeInner(root)).toBe('0')\n\n      count.value++\n      await nextTick()\n      expect(serializeInner(root)).toBe('1')\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Expected a function as watch handler","suites":["api: options","warnings"],"updatePoint":{"line":1383,"column":46},"line":1383,"code":"    test('Expected a function as watch handler', () => {\n      const Comp = {\n        watch: {\n          foo: 'notExistingMethod',\n          foo2: {\n            handler: 'notExistingMethod2'\n          }\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n\n      expect(\n        'Invalid watch handler specified by key \"notExistingMethod\"'\n      ).toHaveBeenWarned()\n      expect(\n        'Invalid watch handler specified by key \"notExistingMethod2\"'\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Invalid watch option","suites":["api: options","warnings"],"updatePoint":{"line":1405,"column":30},"line":1405,"code":"    test('Invalid watch option', () => {\n      const Comp = {\n        watch: { foo: true },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      // @ts-expect-error\n      render(h(Comp), root)\n\n      expect('Invalid watch option: \"foo\"').toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed with setter and no getter","suites":["api: options","warnings"],"updatePoint":{"line":1418,"column":44},"line":1418,"code":"    test('computed with setter and no getter', () => {\n      const Comp = {\n        computed: {\n          foo: {\n            set() {}\n          }\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect('Computed property \"foo\" has no getter.').toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"assigning to computed with no setter","suites":["api: options","warnings"],"updatePoint":{"line":1433,"column":46},"line":1433,"code":"    test('assigning to computed with no setter', () => {\n      let instance: any\n      const Comp = {\n        computed: {\n          foo: {\n            get() {}\n          }\n        },\n        mounted() {\n          instance = this\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      instance.foo = 1\n      expect(\n        'Write operation failed: computed property \"foo\" is readonly'\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"inject property is already declared in props","suites":["api: options","warnings"],"updatePoint":{"line":1455,"column":54},"line":1455,"code":"    test('inject property is already declared in props', () => {\n      const Comp = {\n        data() {\n          return {\n            a: 1\n          }\n        },\n        provide() {\n          return {\n            a: this.a\n          }\n        },\n        render() {\n          return [h(ChildA)]\n        }\n      } as any\n      const ChildA = {\n        props: { a: Number },\n        inject: ['a'],\n        render() {\n          return this.a\n        }\n      } as any\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Inject property \"a\" is already defined in Props.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"methods property is not a function","suites":["api: options","warnings"],"updatePoint":{"line":1486,"column":44},"line":1486,"code":"    test('methods property is not a function', () => {\n      const Comp = {\n        methods: {\n          foo: 1\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Method \"foo\" has type \"number\" in the component definition. ` +\n          `Did you reference the function correctly?`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"methods property is already declared in props","suites":["api: options","warnings"],"updatePoint":{"line":1502,"column":55},"line":1502,"code":"    test('methods property is already declared in props', () => {\n      const Comp = {\n        props: {\n          foo: Number\n        },\n        methods: {\n          foo() {}\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Methods property \"foo\" is already defined in Props.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"methods property is already declared in inject","suites":["api: options","warnings"],"updatePoint":{"line":1520,"column":56},"line":1520,"code":"    test('methods property is already declared in inject', () => {\n      const Comp = {\n        data() {\n          return {\n            a: 1\n          }\n        },\n        provide() {\n          return {\n            a: this.a\n          }\n        },\n        render() {\n          return [h(ChildA)]\n        }\n      } as any\n      const ChildA = {\n        methods: {\n          a: () => null\n        },\n        inject: ['a'],\n        render() {\n          return this.a\n        }\n      } as any\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Methods property \"a\" is already defined in Inject.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"data property is already declared in props","suites":["api: options","warnings"],"updatePoint":{"line":1553,"column":52},"line":1553,"code":"    test('data property is already declared in props', () => {\n      const Comp = {\n        props: { foo: Number },\n        data: () => ({\n          foo: 1\n        }),\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Data property \"foo\" is already defined in Props.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"data property is already declared in inject","suites":["api: options","warnings"],"updatePoint":{"line":1569,"column":53},"line":1569,"code":"    test('data property is already declared in inject', () => {\n      const Comp = {\n        data() {\n          return {\n            a: 1\n          }\n        },\n        provide() {\n          return {\n            a: this.a\n          }\n        },\n        render() {\n          return [h(ChildA)]\n        }\n      } as any\n      const ChildA = {\n        data() {\n          return {\n            a: 1\n          }\n        },\n        inject: ['a'],\n        render() {\n          return this.a\n        }\n      } as any\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Data property \"a\" is already defined in Inject.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"data property is already declared in methods","suites":["api: options","warnings"],"updatePoint":{"line":1604,"column":54},"line":1604,"code":"    test('data property is already declared in methods', () => {\n      const Comp = {\n        data: () => ({\n          foo: 1\n        }),\n        methods: {\n          foo() {}\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Data property \"foo\" is already defined in Methods.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed property is already declared in props","suites":["api: options","warnings"],"updatePoint":{"line":1622,"column":56},"line":1622,"code":"    test('computed property is already declared in props', () => {\n      const Comp = {\n        props: { foo: Number },\n        computed: {\n          foo() {}\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Computed property \"foo\" is already defined in Props.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed property is already declared in inject","suites":["api: options","warnings"],"updatePoint":{"line":1638,"column":57},"line":1638,"code":"    test('computed property is already declared in inject', () => {\n      const Comp = {\n        data() {\n          return {\n            a: 1\n          }\n        },\n        provide() {\n          return {\n            a: this.a\n          }\n        },\n        render() {\n          return [h(ChildA)]\n        }\n      } as any\n      const ChildA = {\n        computed: {\n          a: {\n            get() {},\n            set() {}\n          }\n        },\n        inject: ['a'],\n        render() {\n          return this.a\n        }\n      } as any\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Computed property \"a\" is already defined in Inject.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed property is already declared in methods","suites":["api: options","warnings"],"updatePoint":{"line":1674,"column":58},"line":1674,"code":"    test('computed property is already declared in methods', () => {\n      const Comp = {\n        computed: {\n          foo() {}\n        },\n        methods: {\n          foo() {}\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Computed property \"foo\" is already defined in Methods.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed property is already declared in data","suites":["api: options","warnings"],"updatePoint":{"line":1692,"column":55},"line":1692,"code":"    test('computed property is already declared in data', () => {\n      const Comp = {\n        data: () => ({\n          foo: 1\n        }),\n        computed: {\n          foo() {}\n        },\n        render() {}\n      }\n\n      const root = nodeOps.createElement('div')\n      render(h(Comp), root)\n      expect(\n        `Computed property \"foo\" is already defined in Data.`\n      ).toHaveBeenWarned()\n    })","file":"apiOptions.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should expose return values to template render context","suites":["api: setup context"],"updatePoint":{"line":19,"column":60},"line":19,"code":"  it('should expose return values to template render context', () => {\n    const Comp = defineComponent({\n      setup() {\n        return {\n          // ref should auto-unwrap\n          ref: ref('foo'),\n          // object exposed as-is\n          object: reactive({ msg: 'bar' }),\n          // primitive value exposed as-is\n          value: 'baz'\n        }\n      },\n      render() {\n        return `${this.ref} ${this.object.msg} ${this.value}`\n      }\n    })\n    expect(renderToString(h(Comp))).toMatch(`foo bar baz`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should support returning render function","suites":["api: setup context"],"updatePoint":{"line":38,"column":46},"line":38,"code":"  it('should support returning render function', () => {\n    const Comp = {\n      setup() {\n        return () => {\n          return h('div', 'hello')\n        }\n      }\n    }\n    expect(renderToString(h(Comp))).toMatch(`hello`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"props","suites":["api: setup context"],"updatePoint":{"line":49,"column":11},"line":49,"code":"  it('props', async () => {\n    const count = ref(0)\n    let dummy\n\n    const Parent = {\n      render: () => h(Child, { count: count.value })\n    }\n\n    const Child = defineComponent({\n      props: { count: Number },\n      setup(props) {\n        watchEffect(() => {\n          dummy = props.count\n        })\n        return () => h('div', props.count)\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toMatch(`<div>0</div>`)\n    expect(dummy).toBe(0)\n\n    // props should be reactive\n    count.value++\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<div>1</div>`)\n    expect(dummy).toBe(1)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"context.attrs","suites":["api: setup context"],"updatePoint":{"line":79,"column":19},"line":79,"code":"  it('context.attrs', async () => {\n    const toggle = ref(true)\n\n    const Parent = {\n      render: () => h(Child, toggle.value ? { id: 'foo' } : { class: 'baz' })\n    }\n\n    const Child = {\n      // explicit empty props declaration\n      // puts everything received in attrs\n      // disable implicit fallthrough\n      inheritAttrs: false,\n      setup(props: any, { attrs }: any) {\n        return () => h('div', attrs)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toMatch(`<div id=\"foo\"></div>`)\n\n    // should update even though it's not reactive\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<div class=\"baz\"></div>`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"context.attrs in child component slots","suites":["api: setup context"],"updatePoint":{"line":107,"column":44},"line":107,"code":"  it('context.attrs in child component slots', async () => {\n    const toggle = ref(true)\n\n    const Parent = {\n      render: () => h(Child, toggle.value ? { id: 'foo' } : { class: 'baz' })\n    }\n\n    const Wrapper = {\n      render(this: any) {\n        return this.$slots.default()\n      }\n    }\n\n    const Child = {\n      inheritAttrs: false,\n      setup(_: any, { attrs }: any) {\n        return () => {\n          const vnode = h(Wrapper, null, {\n            default: () => [h('div', attrs)],\n            _: 1 // mark stable slots\n          })\n          vnode.dynamicChildren = [] // force optimized mode\n          return vnode\n        }\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toMatch(`<div id=\"foo\"></div>`)\n\n    // should update even though it's not reactive\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<div class=\"baz\"></div>`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"context.slots","suites":["api: setup context"],"updatePoint":{"line":144,"column":19},"line":144,"code":"  it('context.slots', async () => {\n    const id = ref('foo')\n\n    const Parent = {\n      render: () =>\n        h(Child, null, {\n          foo: () => id.value,\n          bar: () => 'bar'\n        })\n    }\n\n    const Child = {\n      setup(props: any, { slots }: any) {\n        return () => h('div', [...slots.foo(), ...slots.bar()])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toMatch(`<div>foobar</div>`)\n\n    // should update even though it's not reactive\n    id.value = 'baz'\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<div>bazbar</div>`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"context.emit","suites":["api: setup context"],"updatePoint":{"line":171,"column":18},"line":171,"code":"  it('context.emit', async () => {\n    const count = ref(0)\n    const spy = vi.fn()\n\n    const Parent = {\n      render: () =>\n        h(Child, {\n          count: count.value,\n          onInc: (newVal: number) => {\n            spy()\n            count.value = newVal\n          }\n        })\n    }\n\n    const Child = defineComponent({\n      props: {\n        count: {\n          type: Number,\n          default: 1\n        }\n      },\n      setup(props, { emit }) {\n        return () =>\n          h(\n            'div',\n            {\n              onClick: () => emit('inc', props.count + 1)\n            },\n            props.count\n          )\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toMatch(`<div>0</div>`)\n\n    // emit should trigger parent handler\n    triggerEvent(root.children[0] as TestElement, 'click')\n    expect(spy).toHaveBeenCalled()\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<div>1</div>`)\n  })","file":"apiSetupContext.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn runtime usage","suites":["SFC <script setup> helpers"],"updatePoint":{"line":35,"column":33},"line":35,"code":"  test('should warn runtime usage', () => {\n    defineProps()\n    expect(`defineProps() is a compiler-hint`).toHaveBeenWarned()\n\n    defineEmits()\n    expect(`defineEmits() is a compiler-hint`).toHaveBeenWarned()\n\n    defineExpose()\n    expect(`defineExpose() is a compiler-hint`).toHaveBeenWarned()\n\n    withDefaults({}, {})\n    expect(`withDefaults() is a compiler-hint`).toHaveBeenWarned()\n  })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"useSlots / useAttrs (no args)","suites":["SFC <script setup> helpers"],"updatePoint":{"line":49,"column":37},"line":49,"code":"  test('useSlots / useAttrs (no args)', () => {\n    let slots: SetupContext['slots'] | undefined\n    let attrs: SetupContext['attrs'] | undefined\n    const Comp = {\n      setup() {\n        slots = useSlots()\n        attrs = useAttrs()\n        return () => {}\n      }\n    }\n    const passedAttrs = { id: 'foo' }\n    const passedSlots = {\n      default: () => {},\n      x: () => {}\n    }\n    render(h(Comp, passedAttrs, passedSlots), nodeOps.createElement('div'))\n    expect(typeof slots!.default).toBe('function')\n    expect(typeof slots!.x).toBe('function')\n    expect(attrs).toMatchObject(passedAttrs)\n  })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"useSlots / useAttrs (with args)","suites":["SFC <script setup> helpers"],"updatePoint":{"line":70,"column":39},"line":70,"code":"  test('useSlots / useAttrs (with args)', () => {\n    let slots: SetupContext['slots'] | undefined\n    let attrs: SetupContext['attrs'] | undefined\n    let ctx: SetupContext | undefined\n    const Comp = defineComponent({\n      setup(_, _ctx) {\n        slots = useSlots()\n        attrs = useAttrs()\n        ctx = _ctx\n        return () => {}\n      }\n    })\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(slots).toBe(ctx!.slots)\n    expect(attrs).toBe(ctx!.attrs)\n  })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"object syntax","suites":["SFC <script setup> helpers","mergeDefaults"],"updatePoint":{"line":88,"column":23},"line":88,"code":"    test('object syntax', () => {\n      const merged = mergeDefaults(\n        {\n          foo: null,\n          bar: { type: String, required: false },\n          baz: String\n        },\n        {\n          foo: 1,\n          bar: 'baz',\n          baz: 'qux'\n        }\n      )\n      expect(merged).toMatchObject({\n        foo: { default: 1 },\n        bar: { type: String, required: false, default: 'baz' },\n        baz: { type: String, default: 'qux' }\n      })\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array syntax","suites":["SFC <script setup> helpers","mergeDefaults"],"updatePoint":{"line":108,"column":22},"line":108,"code":"    test('array syntax', () => {\n      const merged = mergeDefaults(['foo', 'bar', 'baz'], {\n        foo: 1,\n        bar: 'baz',\n        baz: 'qux'\n      })\n      expect(merged).toMatchObject({\n        foo: { default: 1 },\n        bar: { default: 'baz' },\n        baz: { default: 'qux' }\n      })\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merging with skipFactory","suites":["SFC <script setup> helpers","mergeDefaults"],"updatePoint":{"line":121,"column":34},"line":121,"code":"    test('merging with skipFactory', () => {\n      const fn = () => {}\n      const merged = mergeDefaults(['foo', 'bar', 'baz'], {\n        foo: fn,\n        __skip_foo: true\n      })\n      expect(merged).toMatchObject({\n        foo: { default: fn, skipFactory: true }\n      })\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn missing","suites":["SFC <script setup> helpers","mergeDefaults"],"updatePoint":{"line":132,"column":29},"line":132,"code":"    test('should warn missing', () => {\n      mergeDefaults({}, { foo: 1 })\n      expect(\n        `props default key \"foo\" has no corresponding declaration`\n      ).toHaveBeenWarned()\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array syntax","suites":["SFC <script setup> helpers","mergeModels"],"updatePoint":{"line":141,"column":22},"line":141,"code":"    test('array syntax', () => {\n      expect(mergeModels(['foo', 'bar'], ['baz'])).toMatchObject([\n        'foo',\n        'bar',\n        'baz'\n      ])\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"object syntax","suites":["SFC <script setup> helpers","mergeModels"],"updatePoint":{"line":149,"column":23},"line":149,"code":"    test('object syntax', () => {\n      expect(\n        mergeModels({ foo: null, bar: { required: true } }, ['baz'])\n      ).toMatchObject({\n        foo: null,\n        bar: { required: true },\n        baz: {}\n      })\n\n      expect(\n        mergeModels(['baz'], { foo: null, bar: { required: true } })\n      ).toMatchObject({\n        foo: null,\n        bar: { required: true },\n        baz: {}\n      })\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"overwrite","suites":["SFC <script setup> helpers","mergeModels"],"updatePoint":{"line":167,"column":19},"line":167,"code":"    test('overwrite', () => {\n      expect(\n        mergeModels(\n          { foo: null, bar: { required: true } },\n          { bar: {}, baz: {} }\n        )\n      ).toMatchObject({\n        foo: null,\n        bar: {},\n        baz: {}\n      })\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"basic","suites":["SFC <script setup> helpers","useModel"],"updatePoint":{"line":182,"column":15},"line":182,"code":"    test('basic', async () => {\n      let foo: any\n      const update = () => {\n        foo.value = 'bar'\n      }\n\n      const Comp = defineComponent({\n        props: ['modelValue'],\n        emits: ['update:modelValue'],\n        setup(props) {\n          foo = useModel(props, 'modelValue')\n        },\n        render() {}\n      })\n\n      const msg = ref('')\n      const setValue = vi.fn(v => (msg.value = v))\n      const root = nodeOps.createElement('div')\n      createApp(() =>\n        h(Comp, {\n          modelValue: msg.value,\n          'onUpdate:modelValue': setValue\n        })\n      ).mount(root)\n\n      expect(foo.value).toBe('')\n      expect(msg.value).toBe('')\n      expect(setValue).not.toBeCalled()\n\n      // update from child\n      update()\n\n      await nextTick()\n      expect(msg.value).toBe('bar')\n      expect(foo.value).toBe('bar')\n      expect(setValue).toBeCalledTimes(1)\n\n      // update from parent\n      msg.value = 'qux'\n\n      await nextTick()\n      expect(msg.value).toBe('qux')\n      expect(foo.value).toBe('qux')\n      expect(setValue).toBeCalledTimes(1)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"local","suites":["SFC <script setup> helpers","useModel"],"updatePoint":{"line":228,"column":15},"line":228,"code":"    test('local', async () => {\n      let foo: any\n      const update = () => {\n        foo.value = 'bar'\n      }\n\n      const Comp = defineComponent({\n        props: ['foo'],\n        emits: ['update:foo'],\n        setup(props) {\n          foo = useModel(props, 'foo', { local: true })\n        },\n        render() {}\n      })\n\n      const root = nodeOps.createElement('div')\n      const updateFoo = vi.fn()\n      render(h(Comp, { 'onUpdate:foo': updateFoo }), root)\n\n      expect(foo.value).toBeUndefined()\n      update()\n\n      expect(foo.value).toBe('bar')\n\n      await nextTick()\n      expect(updateFoo).toBeCalledTimes(1)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"default value","suites":["SFC <script setup> helpers","useModel"],"updatePoint":{"line":256,"column":23},"line":256,"code":"    test('default value', async () => {\n      let count: any\n      const inc = () => {\n        count.value++\n      }\n      const Comp = defineComponent({\n        props: { count: { default: 0 } },\n        emits: ['update:count'],\n        setup(props) {\n          count = useModel(props, 'count', { local: true })\n        },\n        render() {}\n      })\n\n      const root = nodeOps.createElement('div')\n      const updateCount = vi.fn()\n      render(h(Comp, { 'onUpdate:count': updateCount }), root)\n\n      expect(count.value).toBe(0)\n\n      inc()\n      expect(count.value).toBe(1)\n      await nextTick()\n      expect(updateCount).toBeCalledTimes(1)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"createPropsRestProxy","suites":["SFC <script setup> helpers","useModel"],"updatePoint":{"line":283,"column":28},"line":283,"code":"  test('createPropsRestProxy', () => {\n    const original = shallowReactive({\n      foo: 1,\n      bar: 2,\n      baz: 3\n    })\n    const rest = createPropsRestProxy(original, ['foo', 'bar'])\n    expect('foo' in rest).toBe(false)\n    expect('bar' in rest).toBe(false)\n    expect(rest.baz).toBe(3)\n    expect(Object.keys(rest)).toEqual(['baz'])\n\n    original.baz = 4\n    expect(rest.baz).toBe(4)\n  })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"basic","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":310,"column":15},"line":310,"code":"    test('basic', async () => {\n      const spy = vi.fn()\n\n      let beforeInstance: ComponentInternalInstance | null = null\n      let afterInstance: ComponentInternalInstance | null = null\n      let resolve: (msg: string) => void\n\n      const Comp = defineComponent({\n        async setup() {\n          let __temp: any, __restore: any\n\n          beforeInstance = getCurrentInstance()\n\n          const msg =\n            (([__temp, __restore] = withAsyncContext(\n              () =>\n                new Promise(r => {\n                  resolve = r\n                })\n            )),\n            (__temp = await __temp),\n            __restore(),\n            __temp)\n\n          // register the lifecycle after an await statement\n          onMounted(spy)\n          afterInstance = getCurrentInstance()\n          return () => msg\n        }\n      })\n\n      const root = nodeOps.createElement('div')\n      render(\n        h(() => h(Suspense, () => h(Comp))),\n        root\n      )\n\n      expect(spy).not.toHaveBeenCalled()\n      resolve!('hello')\n      // wait a macro task tick for all micro ticks to resolve\n      await new Promise(r => setTimeout(r))\n      // mount hook should have been called\n      expect(spy).toHaveBeenCalled()\n      // should retain same instance before/after the await call\n      expect(beforeInstance).toBe(afterInstance)\n      expect(serializeInner(root)).toBe('hello')\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error handling","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":358,"column":24},"line":358,"code":"    test('error handling', async () => {\n      const spy = vi.fn()\n\n      let beforeInstance: ComponentInternalInstance | null = null\n      let afterInstance: ComponentInternalInstance | null = null\n      let reject: () => void\n\n      const Comp = defineComponent({\n        async setup() {\n          let __temp: any, __restore: any\n\n          beforeInstance = getCurrentInstance()\n          try {\n            ;[__temp, __restore] = withAsyncContext(\n              () =>\n                new Promise((_, rj) => {\n                  reject = rj\n                })\n            )\n            __temp = await __temp\n            __restore()\n          } catch (e: any) {\n            // ignore\n          }\n          // register the lifecycle after an await statement\n          onMounted(spy)\n          afterInstance = getCurrentInstance()\n          return () => ''\n        }\n      })\n\n      const root = nodeOps.createElement('div')\n      render(\n        h(() => h(Suspense, () => h(Comp))),\n        root\n      )\n\n      expect(spy).not.toHaveBeenCalled()\n      reject!()\n      // wait a macro task tick for all micro ticks to resolve\n      await new Promise(r => setTimeout(r))\n      // mount hook should have been called\n      expect(spy).toHaveBeenCalled()\n      // should retain same instance before/after the await call\n      expect(beforeInstance).toBe(afterInstance)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not leak instance on multiple awaits","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":405,"column":53},"line":405,"code":"    test('should not leak instance on multiple awaits', async () => {\n      let resolve: (val?: any) => void\n      let beforeInstance: ComponentInternalInstance | null = null\n      let afterInstance: ComponentInternalInstance | null = null\n      let inBandInstance: ComponentInternalInstance | null = null\n      let outOfBandInstance: ComponentInternalInstance | null = null\n\n      const ready = new Promise(r => {\n        resolve = r\n      })\n\n      async function doAsyncWork() {\n        // should still have instance\n        inBandInstance = getCurrentInstance()\n        await Promise.resolve()\n        // should not leak instance\n        outOfBandInstance = getCurrentInstance()\n      }\n\n      const Comp = defineComponent({\n        async setup() {\n          let __temp: any, __restore: any\n\n          beforeInstance = getCurrentInstance()\n\n          // first await\n          ;[__temp, __restore] = withAsyncContext(() => Promise.resolve())\n          __temp = await __temp\n          __restore()\n\n          // setup exit, instance set to null, then resumed\n          ;[__temp, __restore] = withAsyncContext(() => doAsyncWork())\n          __temp = await __temp\n          __restore()\n\n          afterInstance = getCurrentInstance()\n          return () => {\n            resolve()\n            return ''\n          }\n        }\n      })\n\n      const root = nodeOps.createElement('div')\n      render(\n        h(() => h(Suspense, () => h(Comp))),\n        root\n      )\n\n      await ready\n      expect(inBandInstance).toBe(beforeInstance)\n      expect(outOfBandInstance).toBeNull()\n      expect(afterInstance).toBe(beforeInstance)\n      expect(getCurrentInstance()).toBeNull()\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not leak on multiple awaits + error","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":461,"column":52},"line":461,"code":"    test('should not leak on multiple awaits + error', async () => {\n      let resolve: (val?: any) => void\n      const ready = new Promise(r => {\n        resolve = r\n      })\n\n      const Comp = defineComponent({\n        async setup() {\n          let __temp: any, __restore: any\n          ;[__temp, __restore] = withAsyncContext(() => Promise.resolve())\n          __temp = await __temp\n          __restore()\n          ;[__temp, __restore] = withAsyncContext(() => Promise.reject())\n          __temp = await __temp\n          __restore()\n        },\n        render() {}\n      })\n\n      const app = createApp(() => h(Suspense, () => h(Comp)))\n      app.config.errorHandler = () => {\n        resolve()\n        return false\n      }\n\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n\n      await ready\n      expect(getCurrentInstance()).toBeNull()\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"race conditions","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":494,"column":25},"line":494,"code":"    test('race conditions', async () => {\n      const uids = {\n        one: { before: NaN, after: NaN },\n        two: { before: NaN, after: NaN }\n      }\n\n      const Comp = defineComponent({\n        props: ['name'],\n        async setup(props: { name: 'one' | 'two' }) {\n          let __temp: any, __restore: any\n\n          uids[props.name].before = getCurrentInstance()!.uid\n          ;[__temp, __restore] = withAsyncContext(() => Promise.resolve())\n          __temp = await __temp\n          __restore()\n\n          uids[props.name].after = getCurrentInstance()!.uid\n          return () => ''\n        }\n      })\n\n      const app = createApp(() =>\n        h(Suspense, () =>\n          h('div', [h(Comp, { name: 'one' }), h(Comp, { name: 'two' })])\n        )\n      )\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n\n      await new Promise(r => setTimeout(r))\n      expect(uids.one.before).not.toBe(uids.two.before)\n      expect(uids.one.before).toBe(uids.one.after)\n      expect(uids.two.before).toBe(uids.two.after)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should teardown in-scope effects","suites":["SFC <script setup> helpers","withAsyncContext"],"updatePoint":{"line":529,"column":42},"line":529,"code":"    test('should teardown in-scope effects', async () => {\n      let resolve: (val?: any) => void\n      const ready = new Promise(r => {\n        resolve = r\n      })\n\n      let c: ComputedRef\n\n      const Comp = defineComponent({\n        async setup() {\n          let __temp: any, __restore: any\n          ;[__temp, __restore] = withAsyncContext(() => Promise.resolve())\n          __temp = await __temp\n          __restore()\n\n          c = computed(() => {})\n          // register the lifecycle after an await statement\n          onMounted(resolve)\n          return () => ''\n        }\n      })\n\n      const app = createApp(() => h(Suspense, () => h(Comp)))\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n\n      await ready\n      expect(c!.effect.active).toBe(true)\n\n      app.unmount()\n      expect(c!.effect.active).toBe(false)\n    })","file":"apiSetupHelpers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"effect","suites":["api: watch"],"updatePoint":{"line":40,"column":12},"line":40,"code":"  it('effect', async () => {\n    const state = reactive({ count: 0 })\n    let dummy\n    watchEffect(() => {\n      dummy = state.count\n    })\n    expect(dummy).toBe(0)\n\n    state.count++\n    await nextTick()\n    expect(dummy).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching single source: getter","suites":["api: watch"],"updatePoint":{"line":53,"column":36},"line":53,"code":"  it('watching single source: getter', async () => {\n    const state = reactive({ count: 0 })\n    let dummy\n    watch(\n      () => state.count,\n      (count, prevCount) => {\n        dummy = [count, prevCount]\n        // assert types\n        count + 1\n        if (prevCount) {\n          prevCount + 1\n        }\n      }\n    )\n    state.count++\n    await nextTick()\n    expect(dummy).toMatchObject([1, 0])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching single source: ref","suites":["api: watch"],"updatePoint":{"line":72,"column":33},"line":72,"code":"  it('watching single source: ref', async () => {\n    const count = ref(0)\n    let dummy\n    watch(count, (count, prevCount) => {\n      dummy = [count, prevCount]\n      // assert types\n      count + 1\n      if (prevCount) {\n        prevCount + 1\n      }\n    })\n    count.value++\n    await nextTick()\n    expect(dummy).toMatchObject([1, 0])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching single source: array","suites":["api: watch"],"updatePoint":{"line":88,"column":35},"line":88,"code":"  it('watching single source: array', async () => {\n    const array = reactive([] as number[])\n    const spy = vi.fn()\n    watch(array, spy)\n    array.push(1)\n    await nextTick()\n    expect(spy).toBeCalledTimes(1)\n    expect(spy).toBeCalledWith([1], expect.anything(), expect.anything())\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fire if watched getter result did not change","suites":["api: watch"],"updatePoint":{"line":98,"column":61},"line":98,"code":"  it('should not fire if watched getter result did not change', async () => {\n    const spy = vi.fn()\n    const n = ref(0)\n    watch(() => n.value % 2, spy)\n\n    n.value++\n    await nextTick()\n    expect(spy).toBeCalledTimes(1)\n\n    n.value += 2\n    await nextTick()\n    // should not be called again because getter result did not change\n    expect(spy).toBeCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching single source: computed ref","suites":["api: watch"],"updatePoint":{"line":113,"column":42},"line":113,"code":"  it('watching single source: computed ref', async () => {\n    const count = ref(0)\n    const plus = computed(() => count.value + 1)\n    let dummy\n    watch(plus, (count, prevCount) => {\n      dummy = [count, prevCount]\n      // assert types\n      count + 1\n      if (prevCount) {\n        prevCount + 1\n      }\n    })\n    count.value++\n    await nextTick()\n    expect(dummy).toMatchObject([2, 1])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching primitive with deep: true","suites":["api: watch"],"updatePoint":{"line":130,"column":40},"line":130,"code":"  it('watching primitive with deep: true', async () => {\n    const count = ref(0)\n    let dummy\n    watch(\n      count,\n      (c, prevCount) => {\n        dummy = [c, prevCount]\n      },\n      {\n        deep: true\n      }\n    )\n    count.value++\n    await nextTick()\n    expect(dummy).toMatchObject([1, 0])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"directly watching reactive object (with automatic deep: true)","suites":["api: watch"],"updatePoint":{"line":147,"column":67},"line":147,"code":"  it('directly watching reactive object (with automatic deep: true)', async () => {\n    const src = reactive({\n      count: 0\n    })\n    let dummy\n    watch(src, ({ count }) => {\n      dummy = count\n    })\n    src.count++\n    await nextTick()\n    expect(dummy).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching multiple sources","suites":["api: watch"],"updatePoint":{"line":160,"column":31},"line":160,"code":"  it('watching multiple sources', async () => {\n    const state = reactive({ count: 1 })\n    const count = ref(1)\n    const plus = computed(() => count.value + 1)\n\n    let dummy\n    watch([() => state.count, count, plus], (vals, oldVals) => {\n      dummy = [vals, oldVals]\n      // assert types\n      vals.concat(1)\n      oldVals.concat(1)\n    })\n\n    state.count++\n    count.value++\n    await nextTick()\n    expect(dummy).toMatchObject([\n      [2, 2, 3],\n      [1, 1, 2]\n    ])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching multiple sources: undefined initial values and immediate: true","suites":["api: watch"],"updatePoint":{"line":182,"column":77},"line":182,"code":"  it('watching multiple sources: undefined initial values and immediate: true', async () => {\n    const a = ref()\n    const b = ref()\n    let called = false\n    watch(\n      [a, b],\n      ([newA, newB], [oldA, oldB]) => {\n        called = true\n        expect([newA, newB]).toMatchObject([undefined, undefined])\n        expect([oldA, oldB]).toMatchObject([undefined, undefined])\n      },\n      { immediate: true }\n    )\n    await nextTick()\n    expect(called).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching multiple sources: readonly array","suites":["api: watch"],"updatePoint":{"line":199,"column":47},"line":199,"code":"  it('watching multiple sources: readonly array', async () => {\n    const state = reactive({ count: 1 })\n    const status = ref(false)\n\n    let dummy\n    watch([() => state.count, status] as const, (vals, oldVals) => {\n      dummy = [vals, oldVals]\n      const [count] = vals\n      const [, oldStatus] = oldVals\n      // assert types\n      count + 1\n      oldStatus === true\n    })\n\n    state.count++\n    status.value = true\n    await nextTick()\n    expect(dummy).toMatchObject([\n      [2, true],\n      [1, false]\n    ])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching multiple sources: reactive object (with automatic deep: true)","suites":["api: watch"],"updatePoint":{"line":222,"column":76},"line":222,"code":"  it('watching multiple sources: reactive object (with automatic deep: true)', async () => {\n    const src = reactive({ count: 0 })\n    let dummy\n    watch([src], ([state]) => {\n      dummy = state\n      // assert types\n      state.count === 1\n    })\n    src.count++\n    await nextTick()\n    expect(dummy).toMatchObject({ count: 1 })\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn invalid watch source","suites":["api: watch"],"updatePoint":{"line":235,"column":31},"line":235,"code":"  it('warn invalid watch source', () => {\n    // @ts-expect-error\n    watch(1, () => {})\n    expect(`Invalid watch source`).toHaveBeenWarned()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn invalid watch source: multiple sources","suites":["api: watch"],"updatePoint":{"line":241,"column":49},"line":241,"code":"  it('warn invalid watch source: multiple sources', () => {\n    watch([1], () => {})\n    expect(`Invalid watch source`).toHaveBeenWarned()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"stopping the watcher (effect)","suites":["api: watch"],"updatePoint":{"line":246,"column":35},"line":246,"code":"  it('stopping the watcher (effect)', async () => {\n    const state = reactive({ count: 0 })\n    let dummy\n    const stop = watchEffect(() => {\n      dummy = state.count\n    })\n    expect(dummy).toBe(0)\n\n    stop()\n    state.count++\n    await nextTick()\n    // should not update\n    expect(dummy).toBe(0)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"stopping the watcher (with source)","suites":["api: watch"],"updatePoint":{"line":261,"column":40},"line":261,"code":"  it('stopping the watcher (with source)', async () => {\n    const state = reactive({ count: 0 })\n    let dummy\n    const stop = watch(\n      () => state.count,\n      count => {\n        dummy = count\n      }\n    )\n\n    state.count++\n    await nextTick()\n    expect(dummy).toBe(1)\n\n    stop()\n    state.count++\n    await nextTick()\n    // should not update\n    expect(dummy).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cleanup registration (effect)","suites":["api: watch"],"updatePoint":{"line":282,"column":35},"line":282,"code":"  it('cleanup registration (effect)', async () => {\n    const state = reactive({ count: 0 })\n    const cleanup = vi.fn()\n    let dummy\n    const stop = watchEffect(onCleanup => {\n      onCleanup(cleanup)\n      dummy = state.count\n    })\n    expect(dummy).toBe(0)\n\n    state.count++\n    await nextTick()\n    expect(cleanup).toHaveBeenCalledTimes(1)\n    expect(dummy).toBe(1)\n\n    stop()\n    expect(cleanup).toHaveBeenCalledTimes(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cleanup registration (with source)","suites":["api: watch"],"updatePoint":{"line":301,"column":40},"line":301,"code":"  it('cleanup registration (with source)', async () => {\n    const count = ref(0)\n    const cleanup = vi.fn()\n    let dummy\n    const stop = watch(count, (count, prevCount, onCleanup) => {\n      onCleanup(cleanup)\n      dummy = count\n    })\n\n    count.value++\n    await nextTick()\n    expect(cleanup).toHaveBeenCalledTimes(0)\n    expect(dummy).toBe(1)\n\n    count.value++\n    await nextTick()\n    expect(cleanup).toHaveBeenCalledTimes(1)\n    expect(dummy).toBe(2)\n\n    stop()\n    expect(cleanup).toHaveBeenCalledTimes(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush timing: pre (default)","suites":["api: watch"],"updatePoint":{"line":324,"column":33},"line":324,"code":"  it('flush timing: pre (default)', async () => {\n    const count = ref(0)\n    const count2 = ref(0)\n\n    let callCount = 0\n    let result1\n    let result2\n    const assertion = vi.fn((count, count2Value) => {\n      callCount++\n      // on mount, the watcher callback should be called before DOM render\n      // on update, should be called before the count is updated\n      const expectedDOM = callCount === 1 ? `` : `${count - 1}`\n      result1 = serializeInner(root) === expectedDOM\n\n      // in a pre-flush callback, all state should have been updated\n      const expectedState = callCount - 1\n      result2 = count === expectedState && count2Value === expectedState\n    })\n\n    const Comp = {\n      setup() {\n        watchEffect(() => {\n          assertion(count.value, count2.value)\n        })\n        return () => count.value\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(assertion).toHaveBeenCalledTimes(1)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n\n    count.value++\n    count2.value++\n    await nextTick()\n    // two mutations should result in 1 callback execution\n    expect(assertion).toHaveBeenCalledTimes(2)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush timing: post","suites":["api: watch"],"updatePoint":{"line":366,"column":24},"line":366,"code":"  it('flush timing: post', async () => {\n    const count = ref(0)\n    let result\n    const assertion = vi.fn(count => {\n      result = serializeInner(root) === `${count}`\n    })\n\n    const Comp = {\n      setup() {\n        watchEffect(\n          () => {\n            assertion(count.value)\n          },\n          { flush: 'post' }\n        )\n        return () => count.value\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(assertion).toHaveBeenCalledTimes(1)\n    expect(result).toBe(true)\n\n    count.value++\n    await nextTick()\n    expect(assertion).toHaveBeenCalledTimes(2)\n    expect(result).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watchPostEffect","suites":["api: watch"],"updatePoint":{"line":395,"column":21},"line":395,"code":"  it('watchPostEffect', async () => {\n    const count = ref(0)\n    let result\n    const assertion = vi.fn(count => {\n      result = serializeInner(root) === `${count}`\n    })\n\n    const Comp = {\n      setup() {\n        watchPostEffect(() => {\n          assertion(count.value)\n        })\n        return () => count.value\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(assertion).toHaveBeenCalledTimes(1)\n    expect(result).toBe(true)\n\n    count.value++\n    await nextTick()\n    expect(assertion).toHaveBeenCalledTimes(2)\n    expect(result).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush timing: sync","suites":["api: watch"],"updatePoint":{"line":421,"column":24},"line":421,"code":"  it('flush timing: sync', async () => {\n    const count = ref(0)\n    const count2 = ref(0)\n\n    let callCount = 0\n    let result1\n    let result2\n    const assertion = vi.fn(count => {\n      callCount++\n      // on mount, the watcher callback should be called before DOM render\n      // on update, should be called before the count is updated\n      const expectedDOM = callCount === 1 ? `` : `${count - 1}`\n      result1 = serializeInner(root) === expectedDOM\n\n      // in a sync callback, state mutation on the next line should not have\n      // executed yet on the 2nd call, but will be on the 3rd call.\n      const expectedState = callCount < 3 ? 0 : 1\n      result2 = count2.value === expectedState\n    })\n\n    const Comp = {\n      setup() {\n        watchEffect(\n          () => {\n            assertion(count.value)\n          },\n          {\n            flush: 'sync'\n          }\n        )\n        return () => count.value\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(assertion).toHaveBeenCalledTimes(1)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n\n    count.value++\n    count2.value++\n    await nextTick()\n    expect(assertion).toHaveBeenCalledTimes(3)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watchSyncEffect","suites":["api: watch"],"updatePoint":{"line":468,"column":21},"line":468,"code":"  it('watchSyncEffect', async () => {\n    const count = ref(0)\n    const count2 = ref(0)\n\n    let callCount = 0\n    let result1\n    let result2\n    const assertion = vi.fn(count => {\n      callCount++\n      // on mount, the watcher callback should be called before DOM render\n      // on update, should be called before the count is updated\n      const expectedDOM = callCount === 1 ? `` : `${count - 1}`\n      result1 = serializeInner(root) === expectedDOM\n\n      // in a sync callback, state mutation on the next line should not have\n      // executed yet on the 2nd call, but will be on the 3rd call.\n      const expectedState = callCount < 3 ? 0 : 1\n      result2 = count2.value === expectedState\n    })\n\n    const Comp = {\n      setup() {\n        watchSyncEffect(() => {\n          assertion(count.value)\n        })\n        return () => count.value\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(assertion).toHaveBeenCalledTimes(1)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n\n    count.value++\n    count2.value++\n    await nextTick()\n    expect(assertion).toHaveBeenCalledTimes(3)\n    expect(result1).toBe(true)\n    expect(result2).toBe(true)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fire on component unmount w/ flush: post","suites":["api: watch"],"updatePoint":{"line":510,"column":57},"line":510,"code":"  it('should not fire on component unmount w/ flush: post', async () => {\n    const toggle = ref(true)\n    const cb = vi.fn()\n    const Comp = {\n      setup() {\n        watch(toggle, cb, { flush: 'post' })\n      },\n      render() {}\n    }\n    const App = {\n      render() {\n        return toggle.value ? h(Comp) : null\n      }\n    }\n    render(h(App), nodeOps.createElement('div'))\n    expect(cb).not.toHaveBeenCalled()\n    toggle.value = false\n    await nextTick()\n    expect(cb).not.toHaveBeenCalled()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fire on component unmount w/ flush: pre","suites":["api: watch"],"updatePoint":{"line":532,"column":56},"line":532,"code":"  it('should not fire on component unmount w/ flush: pre', async () => {\n    const toggle = ref(true)\n    const cb = vi.fn()\n    const Comp = {\n      setup() {\n        watch(toggle, cb, { flush: 'pre' })\n      },\n      render() {}\n    }\n    const App = {\n      render() {\n        return toggle.value ? h(Comp) : null\n      }\n    }\n    render(h(App), nodeOps.createElement('div'))\n    expect(cb).not.toHaveBeenCalled()\n    toggle.value = false\n    await nextTick()\n    expect(cb).not.toHaveBeenCalled()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush: pre watcher watching props should fire before child update","suites":["api: watch"],"updatePoint":{"line":554,"column":71},"line":554,"code":"  it('flush: pre watcher watching props should fire before child update', async () => {\n    const a = ref(0)\n    const b = ref(0)\n    const c = ref(0)\n    const calls: string[] = []\n\n    const Comp = {\n      props: ['a', 'b'],\n      setup(props: any) {\n        watch(\n          () => props.a + props.b,\n          () => {\n            calls.push('watcher 1')\n            c.value++\n          },\n          { flush: 'pre' }\n        )\n\n        // #1777 chained pre-watcher\n        watch(\n          c,\n          () => {\n            calls.push('watcher 2')\n          },\n          { flush: 'pre' }\n        )\n        return () => {\n          c.value\n          calls.push('render')\n        }\n      }\n    }\n\n    const App = {\n      render() {\n        return h(Comp, { a: a.value, b: b.value })\n      }\n    }\n\n    render(h(App), nodeOps.createElement('div'))\n    expect(calls).toEqual(['render'])\n\n    // both props are updated\n    // should trigger pre-flush watcher first and only once\n    // then trigger child render\n    a.value++\n    b.value++\n    await nextTick()\n    expect(calls).toEqual(['render', 'watcher 1', 'watcher 2', 'render'])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush: pre triggered in component setup should be buffered and called before mounted","suites":["api: watch"],"updatePoint":{"line":606,"column":90},"line":606,"code":"  it('flush: pre triggered in component setup should be buffered and called before mounted', () => {\n    const count = ref(0)\n    const calls: string[] = []\n    const App = {\n      render() {},\n      setup() {\n        watch(\n          count,\n          () => {\n            calls.push('watch ' + count.value)\n          },\n          { flush: 'pre' }\n        )\n        onMounted(() => {\n          calls.push('mounted')\n        })\n        // mutate multiple times\n        count.value++\n        count.value++\n        count.value++\n      }\n    }\n    render(h(App), nodeOps.createElement('div'))\n    expect(calls).toMatchObject(['watch 3', 'mounted'])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flush: post watcher should fire after template refs updated","suites":["api: watch"],"updatePoint":{"line":633,"column":65},"line":633,"code":"  it('flush: post watcher should fire after template refs updated', async () => {\n    const toggle = ref(false)\n    let dom: TestElement | null = null\n\n    const App = {\n      setup() {\n        const domRef = ref<TestElement | null>(null)\n\n        watch(\n          toggle,\n          () => {\n            dom = domRef.value\n          },\n          { flush: 'post' }\n        )\n\n        return () => {\n          return toggle.value ? h('p', { ref: domRef }) : null\n        }\n      }\n    }\n\n    render(h(App), nodeOps.createElement('div'))\n    expect(dom).toBe(null)\n\n    toggle.value = true\n    await nextTick()\n    expect(dom!.tag).toBe('p')\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"deep","suites":["api: watch"],"updatePoint":{"line":663,"column":10},"line":663,"code":"  it('deep', async () => {\n    const state = reactive({\n      nested: {\n        count: ref(0)\n      },\n      array: [1, 2, 3],\n      map: new Map([\n        ['a', 1],\n        ['b', 2]\n      ]),\n      set: new Set([1, 2, 3])\n    })\n\n    let dummy\n    watch(\n      () => state,\n      state => {\n        dummy = [\n          state.nested.count,\n          state.array[0],\n          state.map.get('a'),\n          state.set.has(1)\n        ]\n      },\n      { deep: true }\n    )\n\n    state.nested.count++\n    await nextTick()\n    expect(dummy).toEqual([1, 1, 1, true])\n\n    // nested array mutation\n    state.array[0] = 2\n    await nextTick()\n    expect(dummy).toEqual([1, 2, 1, true])\n\n    // nested map mutation\n    state.map.set('a', 2)\n    await nextTick()\n    expect(dummy).toEqual([1, 2, 2, true])\n\n    // nested set mutation\n    state.set.delete(1)\n    await nextTick()\n    expect(dummy).toEqual([1, 2, 2, false])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching deep ref","suites":["api: watch"],"updatePoint":{"line":710,"column":23},"line":710,"code":"  it('watching deep ref', async () => {\n    const count = ref(0)\n    const double = computed(() => count.value * 2)\n    const state = reactive([count, double])\n\n    let dummy\n    watch(\n      () => state,\n      state => {\n        dummy = [state[0].value, state[1].value]\n      },\n      { deep: true }\n    )\n\n    count.value++\n    await nextTick()\n    expect(dummy).toEqual([1, 2])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"immediate","suites":["api: watch"],"updatePoint":{"line":729,"column":15},"line":729,"code":"  it('immediate', async () => {\n    const count = ref(0)\n    const cb = vi.fn()\n    watch(count, cb, { immediate: true })\n    expect(cb).toHaveBeenCalledTimes(1)\n    count.value++\n    await nextTick()\n    expect(cb).toHaveBeenCalledTimes(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"immediate: triggers when initial value is null","suites":["api: watch"],"updatePoint":{"line":739,"column":52},"line":739,"code":"  it('immediate: triggers when initial value is null', async () => {\n    const state = ref(null)\n    const spy = vi.fn()\n    watch(() => state.value, spy, { immediate: true })\n    expect(spy).toHaveBeenCalled()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"immediate: triggers when initial value is undefined","suites":["api: watch"],"updatePoint":{"line":746,"column":57},"line":746,"code":"  it('immediate: triggers when initial value is undefined', async () => {\n    const state = ref()\n    const spy = vi.fn()\n    watch(() => state.value, spy, { immediate: true })\n    expect(spy).toHaveBeenCalledWith(undefined, undefined, expect.any(Function))\n    state.value = 3\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(2)\n    // testing if undefined can trigger the watcher\n    state.value = undefined\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(3)\n    // it shouldn't trigger if the same value is set\n    state.value = undefined\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(3)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn immediate option when using effect","suites":["api: watch"],"updatePoint":{"line":764,"column":45},"line":764,"code":"  it('warn immediate option when using effect', async () => {\n    const count = ref(0)\n    let dummy\n    watchEffect(\n      () => {\n        dummy = count.value\n      },\n      // @ts-expect-error\n      { immediate: false }\n    )\n    expect(dummy).toBe(0)\n    expect(`\"immediate\" option is only respected`).toHaveBeenWarned()\n\n    count.value++\n    await nextTick()\n    expect(dummy).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn and not respect deep option when using effect","suites":["api: watch"],"updatePoint":{"line":782,"column":56},"line":782,"code":"  it('warn and not respect deep option when using effect', async () => {\n    const arr = ref([1, [2]])\n    const spy = vi.fn()\n    watchEffect(\n      () => {\n        spy()\n        return arr\n      },\n      // @ts-expect-error\n      { deep: true }\n    )\n    expect(spy).toHaveBeenCalledTimes(1)\n    ;(arr.value[1] as Array<number>)[0] = 3\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(`\"deep\" option is only respected`).toHaveBeenWarned()\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onTrack","suites":["api: watch"],"updatePoint":{"line":800,"column":13},"line":800,"code":"  it('onTrack', async () => {\n    const events: DebuggerEvent[] = []\n    let dummy\n    const onTrack = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive({ foo: 1, bar: 2 })\n    watchEffect(\n      () => {\n        dummy = [obj.foo, 'bar' in obj, Object.keys(obj)]\n      },\n      { onTrack }\n    )\n    await nextTick()\n    expect(dummy).toEqual([1, true, ['foo', 'bar']])\n    expect(onTrack).toHaveBeenCalledTimes(3)\n    expect(events).toMatchObject([\n      {\n        target: obj,\n        type: TrackOpTypes.GET,\n        key: 'foo'\n      },\n      {\n        target: obj,\n        type: TrackOpTypes.HAS,\n        key: 'bar'\n      },\n      {\n        target: obj,\n        type: TrackOpTypes.ITERATE,\n        key: ITERATE_KEY\n      }\n    ])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onTrigger","suites":["api: watch"],"updatePoint":{"line":835,"column":15},"line":835,"code":"  it('onTrigger', async () => {\n    const events: DebuggerEvent[] = []\n    let dummy\n    const onTrigger = vi.fn((e: DebuggerEvent) => {\n      events.push(e)\n    })\n    const obj = reactive<{ foo?: number }>({ foo: 1 })\n    watchEffect(\n      () => {\n        dummy = obj.foo\n      },\n      { onTrigger }\n    )\n    await nextTick()\n    expect(dummy).toBe(1)\n\n    obj.foo!++\n    await nextTick()\n    expect(dummy).toBe(2)\n    expect(onTrigger).toHaveBeenCalledTimes(1)\n    expect(events[0]).toMatchObject({\n      type: TriggerOpTypes.SET,\n      key: 'foo',\n      oldValue: 1,\n      newValue: 2\n    })\n\n    delete obj.foo\n    await nextTick()\n    expect(dummy).toBeUndefined()\n    expect(onTrigger).toHaveBeenCalledTimes(2)\n    expect(events[1]).toMatchObject({\n      type: TriggerOpTypes.DELETE,\n      key: 'foo',\n      oldValue: 2\n    })\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work sync","suites":["api: watch"],"updatePoint":{"line":873,"column":22},"line":873,"code":"  it('should work sync', () => {\n    const v = ref(1)\n    let calls = 0\n\n    watch(\n      v,\n      () => {\n        ++calls\n      },\n      {\n        flush: 'sync'\n      }\n    )\n\n    expect(calls).toBe(0)\n    v.value++\n    expect(calls).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should force trigger on triggerRef when watching a shallow ref","suites":["api: watch"],"updatePoint":{"line":892,"column":70},"line":892,"code":"  test('should force trigger on triggerRef when watching a shallow ref', async () => {\n    const v = shallowRef({ a: 1 })\n    let sideEffect = 0\n    watch(v, obj => {\n      sideEffect = obj.a\n    })\n\n    v.value = v.value\n    await nextTick()\n    // should not trigger\n    expect(sideEffect).toBe(0)\n\n    v.value.a++\n    await nextTick()\n    // should not trigger\n    expect(sideEffect).toBe(0)\n\n    triggerRef(v)\n    await nextTick()\n    // should trigger now\n    expect(sideEffect).toBe(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should force trigger on triggerRef when watching multiple sources: shallow ref array","suites":["api: watch"],"updatePoint":{"line":915,"column":92},"line":915,"code":"  test('should force trigger on triggerRef when watching multiple sources: shallow ref array', async () => {\n    const v = shallowRef([] as any)\n    const spy = vi.fn()\n    watch([v], () => {\n      spy()\n    })\n\n    v.value.push(1)\n    triggerRef(v)\n\n    await nextTick()\n    // should trigger now\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should force trigger on triggerRef with toRef from reactive","suites":["api: watch"],"updatePoint":{"line":930,"column":67},"line":930,"code":"  test('should force trigger on triggerRef with toRef from reactive', async () => {\n    const foo = reactive({ bar: 1 })\n    const bar = toRef(foo, 'bar')\n    const spy = vi.fn()\n\n    watchEffect(() => {\n      bar.value\n      spy()\n    })\n\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    triggerRef(bar)\n\n    await nextTick()\n    // should trigger now\n    expect(spy).toHaveBeenCalledTimes(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watchEffect should not recursively trigger itself","suites":["api: watch"],"updatePoint":{"line":950,"column":57},"line":950,"code":"  test('watchEffect should not recursively trigger itself', async () => {\n    const spy = vi.fn()\n    const price = ref(10)\n    const history = ref<number[]>([])\n    watchEffect(() => {\n      history.value.push(price.value)\n      spy()\n    })\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"computed refs should not trigger watch if value has no change","suites":["api: watch"],"updatePoint":{"line":963,"column":69},"line":963,"code":"  test('computed refs should not trigger watch if value has no change', async () => {\n    const spy = vi.fn()\n    const source = ref(0)\n    const price = computed(() => source.value === 0)\n    watch(price, spy)\n    source.value++\n    await nextTick()\n    source.value++\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"$watch should always register its effects with its own instance","suites":["api: watch"],"updatePoint":{"line":976,"column":71},"line":976,"code":"  test('$watch should always register its effects with its own instance', async () => {\n    let instance: ComponentInternalInstance | null\n    let _show: Ref<boolean>\n\n    const Child = defineComponent({\n      render: () => h('div'),\n      mounted() {\n        instance = getCurrentInstance()\n      },\n      unmounted() {}\n    })\n\n    const Comp = defineComponent({\n      setup() {\n        const comp = ref<ComponentPublicInstance | undefined>()\n        const show = ref(true)\n        _show = show\n        return { comp, show }\n      },\n      render() {\n        return this.show\n          ? h(Child, {\n              ref: vm => void (this.comp = vm as ComponentPublicInstance)\n            })\n          : null\n      },\n      mounted() {\n        // this call runs while Comp is currentInstance, but\n        // the effect for this `$watch` should nontheless be registered with Child\n        this.comp!.$watch(\n          () => this.show,\n          () => void 0\n        )\n      }\n    })\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(instance!).toBeDefined()\n    expect(instance!.scope.effects).toBeInstanceOf(Array)\n    // includes the component's own render effect AND the watcher effect\n    expect(instance!.scope.effects.length).toBe(2)\n\n    _show!.value = false\n\n    await nextTick()\n    await nextTick()\n\n    expect(instance!.scope.effects[0].active).toBe(false)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"this.$watch should pass `this.proxy` to watch source as the first argument ","suites":["api: watch"],"updatePoint":{"line":1027,"column":83},"line":1027,"code":"  test('this.$watch should pass `this.proxy` to watch source as the first argument ', () => {\n    let instance: any\n    const source = vi.fn()\n\n    const Comp = defineComponent({\n      render() {},\n      created(this: any) {\n        instance = this\n        this.$watch(source, function () {})\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    createApp(Comp).mount(root)\n\n    expect(instance).toBeDefined()\n    expect(source.mock.calls.some(args => args.includes(instance)))\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not leak `this.proxy` to setup()","suites":["api: watch"],"updatePoint":{"line":1046,"column":47},"line":1046,"code":"  test('should not leak `this.proxy` to setup()', () => {\n    const source = vi.fn()\n\n    const Comp = defineComponent({\n      render() {},\n      setup() {\n        watch(source, () => {})\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    createApp(Comp).mount(root)\n    // should not have any arguments\n    expect(source.mock.calls[0]).toMatchObject([])\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"pre watcher callbacks should not track dependencies","suites":["api: watch"],"updatePoint":{"line":1063,"column":59},"line":1063,"code":"  test('pre watcher callbacks should not track dependencies', async () => {\n    const a = ref(0)\n    const b = ref(0)\n    const updated = vi.fn()\n\n    const Child = defineComponent({\n      props: ['a'],\n      updated,\n      watch: {\n        a() {\n          b.value\n        }\n      },\n      render() {\n        return h('div', this.a)\n      }\n    })\n\n    const Parent = defineComponent({\n      render() {\n        return h(Child, { a: a.value })\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    createApp(Parent).mount(root)\n\n    a.value++\n    await nextTick()\n    expect(updated).toHaveBeenCalledTimes(1)\n\n    b.value++\n    await nextTick()\n    // should not track b as dependency of Child\n    expect(updated).toHaveBeenCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching keypath","suites":["api: watch"],"updatePoint":{"line":1100,"column":24},"line":1100,"code":"  test('watching keypath', async () => {\n    const spy = vi.fn()\n    const Comp = defineComponent({\n      render() {},\n      data() {\n        return {\n          a: {\n            b: 1\n          }\n        }\n      },\n      watch: {\n        'a.b': spy\n      },\n      created(this: any) {\n        this.$watch('a.b', spy)\n      },\n      mounted(this: any) {\n        this.a.b++\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    createApp(Comp).mount(root)\n\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching sources: ref<any[]>","suites":["api: watch"],"updatePoint":{"line":1129,"column":34},"line":1129,"code":"  it('watching sources: ref<any[]>', async () => {\n    const foo = ref([1])\n    const spy = vi.fn()\n    watch(foo, () => {\n      spy()\n    })\n    foo.value = foo.value.slice()\n    await nextTick()\n    expect(spy).toBeCalledTimes(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watching multiple sources: computed","suites":["api: watch"],"updatePoint":{"line":1140,"column":41},"line":1140,"code":"  it('watching multiple sources: computed', async () => {\n    let count = 0\n    const value = ref('1')\n    const plus = computed(() => !!value.value)\n    watch([plus], () => {\n      count++\n    })\n    value.value = '2'\n    await nextTick()\n    expect(plus.value).toBe(true)\n    expect(count).toBe(0)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watch should not register in owner component if created inside detached scope","suites":["api: watch"],"updatePoint":{"line":1154,"column":85},"line":1154,"code":"  test('watch should not register in owner component if created inside detached scope', () => {\n    let instance: ComponentInternalInstance\n    const Comp = {\n      setup() {\n        instance = getCurrentInstance()!\n        effectScope(true).run(() => {\n          watch(\n            () => 1,\n            () => {}\n          )\n        })\n        return () => ''\n      }\n    }\n    const root = nodeOps.createElement('div')\n    createApp(Comp).mount(root)\n    // should not record watcher in detached scope and only the instance's\n    // own update effect\n    expect(instance!.scope.effects.length).toBe(1)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"watchEffect should keep running if created in a detatched scope","suites":["api: watch"],"updatePoint":{"line":1175,"column":71},"line":1175,"code":"  test('watchEffect should keep running if created in a detatched scope', async () => {\n    const trigger = ref(0)\n    let countWE = 0\n    let countW = 0\n    const Comp = {\n      setup() {\n        effectScope(true).run(() => {\n          watchEffect(() => {\n            trigger.value\n            countWE++\n          })\n          watch(trigger, () => countW++)\n        })\n        return () => ''\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    // only watchEffect as ran so far\n    expect(countWE).toBe(1)\n    expect(countW).toBe(0)\n    trigger.value++\n    await nextTick()\n    // both watchers run while component is mounted\n    expect(countWE).toBe(2)\n    expect(countW).toBe(1)\n    render(null, root) // unmount\n    await nextTick()\n    trigger.value++\n    await nextTick()\n    // both watchers run again event though component has been unmounted\n    expect(countWE).toBe(3)\n    expect(countW).toBe(2)\n  })","file":"apiWatch.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"trigger handlers","suites":["component: emit"],"updatePoint":{"line":17,"column":24},"line":17,"code":"  test('trigger handlers', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        // the `emit` function is bound on component instances\n        this.$emit('foo')\n        this.$emit('bar')\n        this.$emit('!baz')\n      }\n    })\n\n    const onfoo = vi.fn()\n    const onBar = vi.fn()\n    const onBaz = vi.fn()\n    const Comp = () => h(Foo, { onfoo, onBar, ['on!baz']: onBaz })\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(onfoo).not.toHaveBeenCalled()\n    // only capitalized or special chars are considered event listeners\n    expect(onBar).toHaveBeenCalled()\n    expect(onBaz).toHaveBeenCalled()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"trigger camelCase handler","suites":["component: emit"],"updatePoint":{"line":40,"column":33},"line":40,"code":"  test('trigger camelCase handler', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('test-event')\n      }\n    })\n\n    const fooSpy = vi.fn()\n    const Comp = () =>\n      h(Foo, {\n        onTestEvent: fooSpy\n      })\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fooSpy).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"trigger kebab-case handler","suites":["component: emit"],"updatePoint":{"line":58,"column":34},"line":58,"code":"  test('trigger kebab-case handler', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('test-event')\n      }\n    })\n\n    const fooSpy = vi.fn()\n    const Comp = () =>\n      h(Foo, {\n        'onTest-event': fooSpy\n      })\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fooSpy).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"trigger mixed case handlers","suites":["component: emit"],"updatePoint":{"line":77,"column":35},"line":77,"code":"  test('trigger mixed case handlers', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('test-event')\n        this.$emit('testEvent')\n      }\n    })\n\n    const fooSpy = vi.fn()\n    const barSpy = vi.fn()\n    const Comp = () =>\n      // simulate v-on=\"obj\" usage\n      h(\n        Foo,\n        toHandlers({\n          'test-event': fooSpy,\n          testEvent: barSpy\n        })\n      )\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fooSpy).toHaveBeenCalledTimes(1)\n    expect(barSpy).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"trigger hyphenated events for update:xxx events","suites":["component: emit"],"updatePoint":{"line":104,"column":55},"line":104,"code":"  test('trigger hyphenated events for update:xxx events', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('update:fooProp')\n        this.$emit('update:barProp')\n      }\n    })\n\n    const fooSpy = vi.fn()\n    const barSpy = vi.fn()\n    const Comp = () =>\n      h(Foo, {\n        'onUpdate:fooProp': fooSpy,\n        'onUpdate:bar-prop': barSpy\n      })\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fooSpy).toHaveBeenCalled()\n    expect(barSpy).toHaveBeenCalled()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should trigger array of listeners","suites":["component: emit"],"updatePoint":{"line":126,"column":41},"line":126,"code":"  test('should trigger array of listeners', async () => {\n    const Child = defineComponent({\n      setup(_, { emit }) {\n        emit('foo', 1)\n        return () => h('div')\n      }\n    })\n\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const App = {\n      setup() {\n        return () =>\n          h(Child, {\n            onFoo: [fn1, fn2]\n          })\n      }\n    }\n\n    render(h(App), nodeOps.createElement('div'))\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn1).toHaveBeenCalledWith(1)\n    expect(fn2).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledWith(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warning for undeclared event (array)","suites":["component: emit"],"updatePoint":{"line":153,"column":44},"line":153,"code":"  test('warning for undeclared event (array)', () => {\n    const Foo = defineComponent({\n      emits: ['foo'],\n      render() {},\n      created() {\n        // @ts-expect-error\n        this.$emit('bar')\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(\n      `Component emitted event \"bar\" but it is neither declared`\n    ).toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warning for undeclared event (object)","suites":["component: emit"],"updatePoint":{"line":168,"column":45},"line":168,"code":"  test('warning for undeclared event (object)', () => {\n    const Foo = defineComponent({\n      emits: {\n        foo: null\n      },\n      render() {},\n      created() {\n        // @ts-expect-error\n        this.$emit('bar')\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(\n      `Component emitted event \"bar\" but it is neither declared`\n    ).toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn if has equivalent onXXX prop","suites":["component: emit"],"updatePoint":{"line":185,"column":52},"line":185,"code":"  test('should not warn if has equivalent onXXX prop', () => {\n    const Foo = defineComponent({\n      props: ['onFoo'],\n      emits: [],\n      render() {},\n      created() {\n        // @ts-expect-error\n        this.$emit('foo')\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(\n      `Component emitted event \"foo\" but it is neither declared`\n    ).not.toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"validator warning","suites":["component: emit"],"updatePoint":{"line":201,"column":25},"line":201,"code":"  test('validator warning', () => {\n    const Foo = defineComponent({\n      emits: {\n        foo: (arg: number) => arg > 0\n      },\n      render() {},\n      created() {\n        this.$emit('foo', -1)\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(`event validation failed for event \"foo\"`).toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merging from mixins","suites":["component: emit"],"updatePoint":{"line":215,"column":27},"line":215,"code":"  test('merging from mixins', () => {\n    const mixin = {\n      emits: {\n        foo: (arg: number) => arg > 0\n      }\n    }\n    const Foo = defineComponent({\n      mixins: [mixin],\n      render() {},\n      created() {\n        this.$emit('foo', -1)\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(`event validation failed for event \"foo\"`).toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not attach normalized object when mixins do not contain emits","suites":["component: emit"],"updatePoint":{"line":233,"column":76},"line":233,"code":"  test('should not attach normalized object when mixins do not contain emits', () => {\n    const Foo = defineComponent({\n      mixins: [{}],\n      render() {},\n      created() {\n        this.$emit('foo')\n      }\n    })\n    render(h(Foo), nodeOps.createElement('div'))\n    expect(\n      `Component emitted event \"foo\" but it is neither declared`\n    ).not.toHaveBeenWarned()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":".once","suites":["component: emit"],"updatePoint":{"line":247,"column":13},"line":247,"code":"  test('.once', () => {\n    const Foo = defineComponent({\n      render() {},\n      emits: {\n        foo: null,\n        bar: null\n      },\n      created() {\n        this.$emit('foo')\n        this.$emit('foo')\n        this.$emit('bar')\n        this.$emit('bar')\n      }\n    })\n    const fn = vi.fn()\n    const barFn = vi.fn()\n    render(\n      h(Foo, {\n        onFooOnce: fn,\n        onBarOnce: barFn\n      }),\n      nodeOps.createElement('div')\n    )\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(barFn).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":".once with normal listener of the same name","suites":["component: emit"],"updatePoint":{"line":274,"column":51},"line":274,"code":"  test('.once with normal listener of the same name', () => {\n    const Foo = defineComponent({\n      render() {},\n      emits: {\n        foo: null\n      },\n      created() {\n        this.$emit('foo')\n        this.$emit('foo')\n      }\n    })\n    const onFoo = vi.fn()\n    const onFooOnce = vi.fn()\n    render(\n      h(Foo, {\n        onFoo,\n        onFooOnce\n      }),\n      nodeOps.createElement('div')\n    )\n    expect(onFoo).toHaveBeenCalledTimes(2)\n    expect(onFooOnce).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":".number modifier should work with v-model on component","suites":["component: emit"],"updatePoint":{"line":298,"column":62},"line":298,"code":"  test('.number modifier should work with v-model on component', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('update:modelValue', '1')\n        this.$emit('update:foo', '2')\n      }\n    })\n\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const Comp = () =>\n      h(Foo, {\n        modelValue: null,\n        modelModifiers: { number: true },\n        'onUpdate:modelValue': fn1,\n\n        foo: null,\n        fooModifiers: { number: true },\n        'onUpdate:foo': fn2\n      })\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn1).toHaveBeenCalledWith(1)\n    expect(fn2).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledWith(2)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":".trim modifier should work with v-model on component","suites":["component: emit"],"updatePoint":{"line":329,"column":60},"line":329,"code":"  test('.trim modifier should work with v-model on component', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('update:modelValue', ' one ')\n        this.$emit('update:foo', '  two  ')\n      }\n    })\n\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const Comp = () =>\n      h(Foo, {\n        modelValue: null,\n        modelModifiers: { trim: true },\n        'onUpdate:modelValue': fn1,\n\n        foo: null,\n        fooModifiers: { trim: true },\n        'onUpdate:foo': fn2\n      })\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn1).toHaveBeenCalledWith('one')\n    expect(fn2).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledWith('two')\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":".trim and .number modifiers should work with v-model on component","suites":["component: emit"],"updatePoint":{"line":360,"column":73},"line":360,"code":"  test('.trim and .number modifiers should work with v-model on component', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('update:modelValue', '    +01.2    ')\n        this.$emit('update:foo', '    1    ')\n      }\n    })\n\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const Comp = () =>\n      h(Foo, {\n        modelValue: null,\n        modelModifiers: { trim: true, number: true },\n        'onUpdate:modelValue': fn1,\n\n        foo: null,\n        fooModifiers: { trim: true, number: true },\n        'onUpdate:foo': fn2\n      })\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn1).toHaveBeenCalledWith(1.2)\n    expect(fn2).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledWith(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"only trim string parameter when work with v-model on component","suites":["component: emit"],"updatePoint":{"line":391,"column":70},"line":391,"code":"  test('only trim string parameter when work with v-model on component', () => {\n    const Foo = defineComponent({\n      render() {},\n      created() {\n        this.$emit('update:modelValue', ' foo ', { bar: ' bar ' })\n      }\n    })\n\n    const fn = vi.fn()\n    const Comp = () =>\n      h(Foo, {\n        modelValue: null,\n        modelModifiers: { trim: true },\n        'onUpdate:modelValue': fn\n      })\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(fn).toHaveBeenCalledWith('foo', { bar: ' bar ' })\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"isEmitListener","suites":["component: emit"],"updatePoint":{"line":413,"column":22},"line":413,"code":"  test('isEmitListener', () => {\n    const options = {\n      click: null,\n      'test-event': null,\n      fooBar: null,\n      FooBaz: null\n    }\n    expect(isEmitListener(options, 'onClick')).toBe(true)\n    expect(isEmitListener(options, 'onclick')).toBe(false)\n    expect(isEmitListener(options, 'onBlick')).toBe(false)\n    // .once listeners\n    expect(isEmitListener(options, 'onClickOnce')).toBe(true)\n    expect(isEmitListener(options, 'onclickOnce')).toBe(false)\n    // kebab-case option\n    expect(isEmitListener(options, 'onTestEvent')).toBe(true)\n    // camelCase option\n    expect(isEmitListener(options, 'onFooBar')).toBe(true)\n    // PascalCase option\n    expect(isEmitListener(options, 'onFooBaz')).toBe(true)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"does not emit after unmount","suites":["component: emit"],"updatePoint":{"line":434,"column":35},"line":434,"code":"  test('does not emit after unmount', async () => {\n    const fn = vi.fn()\n    const Foo = defineComponent({\n      emits: ['closing'],\n      async beforeUnmount() {\n        await this.$nextTick()\n        this.$emit('closing', true)\n      },\n      render() {\n        return h('div')\n      }\n    })\n    const Comp = () =>\n      h(Foo, {\n        onClosing: fn\n      })\n\n    const el = nodeOps.createElement('div')\n    render(h(Comp), el)\n    await nextTick()\n    render(null, el)\n    await nextTick()\n    expect(fn).not.toHaveBeenCalled()\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merge string array emits","suites":["component: emit"],"updatePoint":{"line":459,"column":32},"line":459,"code":"  test('merge string array emits', async () => {\n    const ComponentA = defineComponent({\n      emits: ['one', 'two']\n    })\n    const ComponentB = defineComponent({\n      emits: ['three']\n    })\n    const renderFn = vi.fn(function (this: ComponentPublicInstance) {\n      expect(this.$options.emits).toEqual(['one', 'two', 'three'])\n      return h('div')\n    })\n    const ComponentC = defineComponent({\n      render: renderFn,\n      mixins: [ComponentA, ComponentB]\n    })\n    const el = nodeOps.createElement('div')\n    expect(renderFn).toHaveBeenCalledTimes(0)\n    render(h(ComponentC), el)\n    expect(renderFn).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merge object emits","suites":["component: emit"],"updatePoint":{"line":480,"column":26},"line":480,"code":"  test('merge object emits', async () => {\n    const twoFn = vi.fn((v: unknown) => !v)\n    const ComponentA = defineComponent({\n      emits: {\n        one: null,\n        two: twoFn\n      }\n    })\n    const ComponentB = defineComponent({\n      emits: ['three']\n    })\n    const renderFn = vi.fn(function (this: ComponentPublicInstance) {\n      expect(this.$options.emits).toEqual({\n        one: null,\n        two: twoFn,\n        three: null\n      })\n      expect(this.$options.emits.two).toBe(twoFn)\n      return h('div')\n    })\n    const ComponentC = defineComponent({\n      render: renderFn,\n      mixins: [ComponentA, ComponentB]\n    })\n    const el = nodeOps.createElement('div')\n    expect(renderFn).toHaveBeenCalledTimes(0)\n    render(h(ComponentC), el)\n    expect(renderFn).toHaveBeenCalledTimes(1)\n  })","file":"componentEmits.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"stateful","suites":["component props"],"updatePoint":{"line":25,"column":16},"line":25,"code":"  test('stateful', () => {\n    let props: any\n    let attrs: any\n    let proxy: any\n\n    const Comp = defineComponent({\n      props: ['fooBar', 'barBaz'],\n      render() {\n        props = this.$props\n        attrs = this.$attrs\n        proxy = this\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { fooBar: 1, bar: 2 }), root)\n    expect(proxy.fooBar).toBe(1)\n    expect(props).toEqual({ fooBar: 1 })\n    expect(attrs).toEqual({ bar: 2 })\n\n    // test passing kebab-case and resolving to camelCase\n    render(h(Comp, { 'foo-bar': 2, bar: 3, baz: 4 }), root)\n    expect(proxy.fooBar).toBe(2)\n    expect(props).toEqual({ fooBar: 2 })\n    expect(attrs).toEqual({ bar: 3, baz: 4 })\n\n    // test updating kebab-case should not delete it (#955)\n    render(h(Comp, { 'foo-bar': 3, bar: 3, baz: 4, barBaz: 5 }), root)\n    expect(proxy.fooBar).toBe(3)\n    expect(proxy.barBaz).toBe(5)\n    expect(props).toEqual({ fooBar: 3, barBaz: 5 })\n    expect(attrs).toEqual({ bar: 3, baz: 4 })\n\n    render(h(Comp, { qux: 5 }), root)\n    expect(proxy.fooBar).toBeUndefined()\n    // remove the props with camelCase key (#1412)\n    expect(proxy.barBaz).toBeUndefined()\n    expect(props).toEqual({})\n    expect(attrs).toEqual({ qux: 5 })\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"stateful with setup","suites":["component props"],"updatePoint":{"line":66,"column":27},"line":66,"code":"  test('stateful with setup', () => {\n    let props: any\n    let attrs: any\n\n    const Comp = defineComponent({\n      props: ['foo'],\n      setup(_props, { attrs: _attrs }) {\n        return () => {\n          props = _props\n          attrs = _attrs\n        }\n      }\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { foo: 1, bar: 2 }), root)\n    expect(props).toEqual({ foo: 1 })\n    expect(attrs).toEqual({ bar: 2 })\n\n    render(h(Comp, { foo: 2, bar: 3, baz: 4 }), root)\n    expect(props).toEqual({ foo: 2 })\n    expect(attrs).toEqual({ bar: 3, baz: 4 })\n\n    render(h(Comp, { qux: 5 }), root)\n    expect(props).toEqual({})\n    expect(attrs).toEqual({ qux: 5 })\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"functional with declaration","suites":["component props"],"updatePoint":{"line":94,"column":35},"line":94,"code":"  test('functional with declaration', () => {\n    let props: any\n    let attrs: any\n\n    const Comp: FunctionalComponent = (_props, { attrs: _attrs }) => {\n      props = _props\n      attrs = _attrs\n    }\n    Comp.props = ['foo']\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { foo: 1, bar: 2 }), root)\n    expect(props).toEqual({ foo: 1 })\n    expect(attrs).toEqual({ bar: 2 })\n\n    render(h(Comp, { foo: 2, bar: 3, baz: 4 }), root)\n    expect(props).toEqual({ foo: 2 })\n    expect(attrs).toEqual({ bar: 3, baz: 4 })\n\n    render(h(Comp, { qux: 5 }), root)\n    expect(props).toEqual({})\n    expect(attrs).toEqual({ qux: 5 })\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"functional without declaration","suites":["component props"],"updatePoint":{"line":118,"column":38},"line":118,"code":"  test('functional without declaration', () => {\n    let props: any\n    let attrs: any\n    const Comp: FunctionalComponent = (_props, { attrs: _attrs }) => {\n      props = _props\n      attrs = _attrs\n    }\n    const root = nodeOps.createElement('div')\n\n    render(h(Comp, { foo: 1 }), root)\n    expect(props).toEqual({ foo: 1 })\n    expect(attrs).toEqual({ foo: 1 })\n    expect(props).toBe(attrs)\n\n    render(h(Comp, { bar: 2 }), root)\n    expect(props).toEqual({ bar: 2 })\n    expect(attrs).toEqual({ bar: 2 })\n    expect(props).toBe(attrs)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"boolean casting","suites":["component props"],"updatePoint":{"line":138,"column":23},"line":138,"code":"  test('boolean casting', () => {\n    let proxy: any\n    const Comp = {\n      props: {\n        foo: Boolean,\n        bar: Boolean,\n        baz: Boolean,\n        qux: Boolean\n      },\n      render() {\n        proxy = this\n      }\n    }\n    render(\n      h(Comp, {\n        // absent should cast to false\n        bar: '', // empty string should cast to true\n        baz: 'baz', // same string should cast to true\n        qux: 'ok' // other values should be left in-tact (but raise warning)\n      }),\n      nodeOps.createElement('div')\n    )\n\n    expect(proxy.foo).toBe(false)\n    expect(proxy.bar).toBe(true)\n    expect(proxy.baz).toBe(true)\n    expect(proxy.qux).toBe('ok')\n    expect('type check failed for prop \"qux\"').toHaveBeenWarned()\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"default value","suites":["component props"],"updatePoint":{"line":168,"column":21},"line":168,"code":"  test('default value', () => {\n    let proxy: any\n    const defaultFn = vi.fn(() => ({ a: 1 }))\n    const defaultBaz = vi.fn(() => ({ b: 1 }))\n\n    const Comp = {\n      props: {\n        foo: {\n          default: 1\n        },\n        bar: {\n          default: defaultFn\n        },\n        baz: {\n          type: Function,\n          default: defaultBaz\n        }\n      },\n      render() {\n        proxy = this\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { foo: 2 }), root)\n    expect(proxy.foo).toBe(2)\n    const prevBar = proxy.bar\n    expect(proxy.bar).toEqual({ a: 1 })\n    expect(proxy.baz).toEqual(defaultBaz)\n    expect(defaultFn).toHaveBeenCalledTimes(1)\n    expect(defaultBaz).toHaveBeenCalledTimes(0)\n\n    // #999: updates should not cause default factory of unchanged prop to be\n    // called again\n    render(h(Comp, { foo: 3 }), root)\n    expect(proxy.foo).toBe(3)\n    expect(proxy.bar).toEqual({ a: 1 })\n    expect(proxy.bar).toBe(prevBar)\n    expect(defaultFn).toHaveBeenCalledTimes(1)\n\n    render(h(Comp, { bar: { b: 2 } }), root)\n    expect(proxy.foo).toBe(1)\n    expect(proxy.bar).toEqual({ b: 2 })\n    expect(defaultFn).toHaveBeenCalledTimes(1)\n\n    render(h(Comp, { foo: 3, bar: { b: 3 } }), root)\n    expect(proxy.foo).toBe(3)\n    expect(proxy.bar).toEqual({ b: 3 })\n    expect(defaultFn).toHaveBeenCalledTimes(1)\n\n    render(h(Comp, { bar: { b: 4 } }), root)\n    expect(proxy.foo).toBe(1)\n    expect(proxy.bar).toEqual({ b: 4 })\n    expect(defaultFn).toHaveBeenCalledTimes(1)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"using inject in default value factory","suites":["component props"],"updatePoint":{"line":224,"column":45},"line":224,"code":"  test('using inject in default value factory', () => {\n    const Child = defineComponent({\n      props: {\n        test: {\n          default: () => inject('test', 'default')\n        }\n      },\n      setup(props) {\n        return () => {\n          return h('div', props.test)\n        }\n      }\n    })\n\n    const Comp = {\n      setup() {\n        provide('test', 'injected')\n        return () => h(Child)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>injected</div>`)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"optimized props updates","suites":["component props"],"updatePoint":{"line":250,"column":31},"line":250,"code":"  test('optimized props updates', async () => {\n    const Child = defineComponent({\n      props: ['foo'],\n      template: `<div>{{ foo }}</div>`\n    })\n\n    const foo = ref(1)\n    const id = ref('a')\n\n    const Comp = defineComponent({\n      setup() {\n        return {\n          foo,\n          id\n        }\n      },\n      components: { Child },\n      template: `<Child :foo=\"foo\" :id=\"id\"/>`\n    })\n\n    // Note this one is using the main Vue render so it can compile template\n    // on the fly\n    const root = document.createElement('div')\n    domRender(h(Comp), root)\n    expect(root.innerHTML).toBe('<div id=\"a\">1</div>')\n\n    foo.value++\n    await nextTick()\n    expect(root.innerHTML).toBe('<div id=\"a\">2</div>')\n\n    id.value = 'b'\n    await nextTick()\n    expect(root.innerHTML).toBe('<div id=\"b\">2</div>')\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn props mutation","suites":["component props"],"updatePoint":{"line":285,"column":27},"line":285,"code":"  test('warn props mutation', () => {\n    let instance: ComponentInternalInstance\n    let setupProps: any\n    const Comp = {\n      props: ['foo'],\n      setup(props: any) {\n        instance = getCurrentInstance()!\n        setupProps = props\n        return () => null\n      }\n    }\n    render(h(Comp, { foo: 1 }), nodeOps.createElement('div'))\n    expect(setupProps.foo).toBe(1)\n    expect(instance!.props.foo).toBe(1)\n    setupProps.foo = 2\n    expect(`Set operation on key \"foo\" failed`).toHaveBeenWarned()\n    expect(() => {\n      ;(instance!.proxy as any).foo = 2\n    }).toThrow(TypeError)\n    expect(`Attempting to mutate prop \"foo\"`).toHaveBeenWarned()\n    // should not throw when overriding properties other than props\n    expect(() => {\n      ;(instance!.proxy as any).hasOwnProperty = () => {}\n    }).not.toThrow(TypeError)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn absent required props","suites":["component props"],"updatePoint":{"line":311,"column":34},"line":311,"code":"  test('warn absent required props', () => {\n    const Comp = {\n      props: {\n        bool: { type: Boolean, required: true },\n        str: { type: String, required: true },\n        num: { type: Number, required: true }\n      },\n      setup() {\n        return () => null\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(`Missing required prop: \"bool\"`).toHaveBeenWarned()\n    expect(`Missing required prop: \"str\"`).toHaveBeenWarned()\n    expect(`Missing required prop: \"num\"`).toHaveBeenWarned()\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn on type mismatch","suites":["component props"],"updatePoint":{"line":328,"column":29},"line":328,"code":"  test('warn on type mismatch', () => {\n    class MyClass {}\n    const Comp = {\n      props: {\n        bool: { type: Boolean },\n        str: { type: String },\n        num: { type: Number },\n        arr: { type: Array },\n        obj: { type: Object },\n        cls: { type: MyClass },\n        fn: { type: Function },\n        skipCheck: { type: [Boolean, Function], skipCheck: true }\n      },\n      setup() {\n        return () => null\n      }\n    }\n    render(\n      h(Comp, {\n        bool: 'true',\n        str: 100,\n        num: '100',\n        arr: {},\n        obj: 'false',\n        cls: {},\n        fn: true,\n        skipCheck: 'foo'\n      }),\n      nodeOps.createElement('div')\n    )\n    expect(\n      `Invalid prop: type check failed for prop \"bool\". Expected Boolean, got String`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"str\". Expected String with value \"100\", got Number with value 100.`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"num\". Expected Number with value 100, got String with value \"100\".`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"arr\". Expected Array, got Object`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"obj\". Expected Object, got String with value \"false\"`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"fn\". Expected Function, got Boolean with value true.`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"cls\". Expected MyClass, got Object`\n    ).toHaveBeenWarned()\n    expect(\n      `Invalid prop: type check failed for prop \"skipCheck\". Expected Boolean | Function, got String with value \"foo\".`\n    ).not.toHaveBeenWarned()\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn required props using kebab-case","suites":["component props"],"updatePoint":{"line":385,"column":55},"line":385,"code":"  test('should not warn required props using kebab-case', async () => {\n    const Comp = {\n      props: {\n        fooBar: { type: String, required: true }\n      },\n      setup() {\n        return () => null\n      }\n    }\n    render(\n      h(Comp, {\n        'foo-bar': 'hello'\n      }),\n      nodeOps.createElement('div')\n    )\n    expect(`Missing required prop: \"fooBar\"`).not.toHaveBeenWarned()\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merging props from mixins and extends","suites":["component props"],"updatePoint":{"line":403,"column":45},"line":403,"code":"  test('merging props from mixins and extends', () => {\n    let setupProps: any\n    let renderProxy: any\n\n    const E = {\n      props: ['base']\n    }\n    const M1 = {\n      props: ['m1']\n    }\n    const M2 = {\n      props: { m2: null }\n    }\n    const Comp = {\n      props: ['self'],\n      mixins: [M1, M2],\n      extends: E,\n      setup(props: any) {\n        setupProps = props\n      },\n      render(this: any) {\n        renderProxy = this\n        return h('div', [this.self, this.base, this.m1, this.m2])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    const props = {\n      self: 'from self, ',\n      base: 'from base, ',\n      m1: 'from mixin 1, ',\n      m2: 'from mixin 2'\n    }\n    render(h(Comp, props), root)\n\n    expect(serializeInner(root)).toMatch(\n      `from self, from base, from mixin 1, from mixin 2`\n    )\n    expect(setupProps).toMatchObject(props)\n    expect(renderProxy.$props).toMatchObject(props)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"merging props from global mixins","suites":["component props"],"updatePoint":{"line":445,"column":40},"line":445,"code":"  test('merging props from global mixins', () => {\n    let setupProps: any\n    let renderProxy: any\n\n    const M1 = {\n      props: ['m1']\n    }\n    const M2 = {\n      props: { m2: null }\n    }\n    const Comp = {\n      props: ['self'],\n      setup(props: any) {\n        setupProps = props\n      },\n      render(this: any) {\n        renderProxy = this\n        return h('div', [this.self, this.m1, this.m2])\n      }\n    }\n\n    const props = {\n      self: 'from self, ',\n      m1: 'from mixin 1, ',\n      m2: 'from mixin 2'\n    }\n    const app = createApp(Comp, props)\n    app.mixin(M1)\n    app.mixin(M2)\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n\n    expect(serializeInner(root)).toMatch(\n      `from self, from mixin 1, from mixin 2`\n    )\n    expect(setupProps).toMatchObject(props)\n    expect(renderProxy.$props).toMatchObject(props)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"props type support BigInt","suites":["component props"],"updatePoint":{"line":485,"column":33},"line":485,"code":"  test('props type support BigInt', () => {\n    const Comp = {\n      props: {\n        foo: BigInt\n      },\n      render(this: any) {\n        return h('div', [this.foo])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(\n      h(Comp, {\n        foo: BigInt(BigInt(100000111)) + BigInt(2000000000) * BigInt(30000000)\n      }),\n      root\n    )\n\n    expect(serializeInner(root)).toMatch('<div>60000000100000111</div>')\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should cache the value returned from the default factory to avoid unnecessary watcher trigger","suites":["component props"],"updatePoint":{"line":507,"column":101},"line":507,"code":"  test('should cache the value returned from the default factory to avoid unnecessary watcher trigger', async () => {\n    let count = 0\n    const Comp = {\n      props: {\n        foo: {\n          type: Object,\n          default: () => ({ val: 1 })\n        },\n        bar: Number\n      },\n      setup(props: any) {\n        watch(\n          () => props.foo,\n          () => {\n            count++\n          }\n        )\n        return () => h('h1', [props.foo.val, props.bar])\n      }\n    }\n\n    const foo = ref()\n    const bar = ref(0)\n    const app = createApp({\n      render: () => h(Comp, { foo: foo.value, bar: bar.value })\n    })\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(serializeInner(root)).toMatch(`<h1>10</h1>`)\n    expect(count).toBe(0)\n\n    bar.value++\n    await nextTick()\n    expect(serializeInner(root)).toMatch(`<h1>11</h1>`)\n    expect(count).toBe(0)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"declared prop key should be present even if not passed","suites":["component props"],"updatePoint":{"line":546,"column":62},"line":546,"code":"  test('declared prop key should be present even if not passed', async () => {\n    let initialKeys: string[] = []\n    const changeSpy = vi.fn()\n    const passFoo = ref(false)\n\n    const Comp = {\n      render() {},\n      props: {\n        foo: String\n      },\n      setup(props: any) {\n        initialKeys = Object.keys(props)\n        const { foo } = toRefs(props)\n        watch(foo, changeSpy)\n      }\n    }\n\n    const Parent = () => (passFoo.value ? h(Comp, { foo: 'ok' }) : h(Comp))\n    const root = nodeOps.createElement('div')\n    createApp(Parent).mount(root)\n\n    expect(initialKeys).toMatchObject(['foo'])\n    passFoo.value = true\n    await nextTick()\n    expect(changeSpy).toHaveBeenCalledTimes(1)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"avoid double-setting props when casting","suites":["component props"],"updatePoint":{"line":574,"column":47},"line":574,"code":"  test(`avoid double-setting props when casting`, async () => {\n    const Parent = {\n      setup(props: any, { slots }: SetupContext) {\n        const childProps = ref()\n        const registerChildProps = (props: any) => {\n          childProps.value = props\n        }\n        provide('register', registerChildProps)\n\n        return () => {\n          // access the child component's props\n          childProps.value && childProps.value.foo\n          return slots.default!()\n        }\n      }\n    }\n\n    const Child = {\n      props: {\n        foo: {\n          type: Boolean,\n          required: false\n        }\n      },\n      setup(props: { foo: boolean }) {\n        const register = inject('register') as any\n        // 1. change the reactivity data of the parent component\n        // 2. register its own props to the parent component\n        register(props)\n\n        return () => 'foo'\n      }\n    }\n\n    const App = {\n      setup() {\n        return () => h(Parent, () => h(Child as any, { foo: '' }, () => null))\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`foo`)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"support null in required + multiple-type declarations","suites":["component props"],"updatePoint":{"line":620,"column":61},"line":620,"code":"  test('support null in required + multiple-type declarations', () => {\n    const Comp = {\n      props: {\n        foo: { type: [Function, null], required: true }\n      },\n      render() {}\n    }\n    const root = nodeOps.createElement('div')\n    expect(() => {\n      render(h(Comp, { foo: () => {} }), root)\n    }).not.toThrow()\n\n    expect(() => {\n      render(h(Comp, { foo: null }), root)\n    }).not.toThrow()\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handling attr with undefined value","suites":["component props"],"updatePoint":{"line":638,"column":42},"line":638,"code":"  test('handling attr with undefined value', () => {\n    const Comp = {\n      render(this: any) {\n        return JSON.stringify(this.$attrs) + Object.keys(this.$attrs)\n      }\n    }\n    const root = nodeOps.createElement('div')\n\n    let attrs: any = { foo: undefined }\n\n    render(h(Comp, attrs), root)\n    expect(serializeInner(root)).toBe(\n      JSON.stringify(attrs) + Object.keys(attrs)\n    )\n\n    render(h(Comp, (attrs = { foo: 'bar' })), root)\n    expect(serializeInner(root)).toBe(\n      JSON.stringify(attrs) + Object.keys(attrs)\n    )\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not mutate original props long-form definition object","suites":["component props"],"updatePoint":{"line":660,"column":68},"line":660,"code":"  test('should not mutate original props long-form definition object', () => {\n    const props = {\n      msg: {\n        type: String\n      }\n    }\n    const Comp = defineComponent({\n      props,\n      render() {}\n    })\n\n    const root = nodeOps.createElement('div')\n\n    render(h(Comp, { msg: 'test' }), root)\n\n    expect(Object.keys(props.msg).length).toBe(1)\n  })","file":"componentProps.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"data","suites":["component: proxy"],"updatePoint":{"line":14,"column":12},"line":14,"code":"  test('data', () => {\n    let instance: ComponentInternalInstance\n    let instanceProxy: any\n    const Comp = {\n      data() {\n        return {\n          foo: 1\n        }\n      },\n      mounted() {\n        instance = getCurrentInstance()!\n        instanceProxy = this\n      },\n      render() {\n        return null\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(instanceProxy.foo).toBe(1)\n    instanceProxy.foo = 2\n    expect(instance!.data.foo).toBe(2)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"setupState","suites":["component: proxy"],"updatePoint":{"line":37,"column":18},"line":37,"code":"  test('setupState', () => {\n    let instance: ComponentInternalInstance\n    let instanceProxy: any\n    const Comp = {\n      setup() {\n        return {\n          foo: 1\n        }\n      },\n      mounted() {\n        instance = getCurrentInstance()!\n        instanceProxy = this\n      },\n      render() {\n        return null\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(instanceProxy.foo).toBe(1)\n    instanceProxy.foo = 2\n    expect(instance!.setupState.foo).toBe(2)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not expose non-declared props","suites":["component: proxy"],"updatePoint":{"line":60,"column":44},"line":60,"code":"  test('should not expose non-declared props', () => {\n    let instanceProxy: any\n    const Comp = {\n      setup() {\n        return () => null\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n    render(h(Comp, { count: 1 }), nodeOps.createElement('div'))\n    expect('count' in instanceProxy).toBe(false)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"public properties","suites":["component: proxy"],"updatePoint":{"line":74,"column":25},"line":74,"code":"  test('public properties', async () => {\n    let instance: ComponentInternalInstance\n    let instanceProxy: any\n    const Comp = {\n      setup() {\n        return () => null\n      },\n      mounted() {\n        instance = getCurrentInstance()!\n        instanceProxy = this\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(instanceProxy.$data).toBe(instance!.data)\n    expect(instanceProxy.$props).toBe(shallowReadonly(instance!.props))\n    expect(instanceProxy.$attrs).toBe(shallowReadonly(instance!.attrs))\n    expect(instanceProxy.$slots).toBe(shallowReadonly(instance!.slots))\n    expect(instanceProxy.$refs).toBe(shallowReadonly(instance!.refs))\n    expect(instanceProxy.$parent).toBe(\n      instance!.parent && instance!.parent.proxy\n    )\n    expect(instanceProxy.$root).toBe(instance!.root.proxy)\n    expect(instanceProxy.$emit).toBe(instance!.emit)\n    expect(instanceProxy.$el).toBe(instance!.vnode.el)\n    expect(instanceProxy.$options).toBe(instance!.type as ComponentOptions)\n    expect(() => (instanceProxy.$data = {})).toThrow(TypeError)\n    expect(`Attempting to mutate public property \"$data\"`).toHaveBeenWarned()\n\n    const nextTickThis = await instanceProxy.$nextTick(function (this: any) {\n      return this\n    })\n    expect(nextTickThis).toBe(instanceProxy)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"user attached properties","suites":["component: proxy"],"updatePoint":{"line":108,"column":32},"line":108,"code":"  test('user attached properties', async () => {\n    let instance: ComponentInternalInstance\n    let instanceProxy: any\n    const Comp = {\n      setup() {\n        return () => null\n      },\n      mounted() {\n        instance = getCurrentInstance()!\n        instanceProxy = this\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    instanceProxy.foo = 1\n    expect(instanceProxy.foo).toBe(1)\n    expect(instance!.ctx.foo).toBe(1)\n\n    // should also allow properties that start with $\n    const obj = (instanceProxy.$store = {})\n    expect(instanceProxy.$store).toBe(obj)\n    expect(instance!.ctx.$store).toBe(obj)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"globalProperties","suites":["component: proxy"],"updatePoint":{"line":131,"column":24},"line":131,"code":"  test('globalProperties', () => {\n    let instance: ComponentInternalInstance\n    let instanceProxy: any\n    const Comp = {\n      setup() {\n        return () => null\n      },\n      mounted() {\n        instance = getCurrentInstance()!\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp)\n    app.config.globalProperties.foo = 1\n    app.mount(nodeOps.createElement('div'))\n\n    expect(instanceProxy.foo).toBe(1)\n\n    // set should overwrite globalProperties with local\n    instanceProxy.foo = 2\n    // expect(instanceProxy.foo).toBe(2)\n    expect(instance!.ctx.foo).toBe(2)\n    // should not affect global\n    expect(app.config.globalProperties.foo).toBe(1)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"has check","suites":["component: proxy"],"updatePoint":{"line":158,"column":17},"line":158,"code":"  test('has check', () => {\n    let instanceProxy: any\n    const Comp = {\n      render() {},\n      props: {\n        msg: String\n      },\n      data() {\n        return {\n          foo: 0\n        }\n      },\n      setup() {\n        return {\n          bar: 1\n        }\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp, { msg: 'hello' })\n    app.config.globalProperties.global = 1\n\n    app.mount(nodeOps.createElement('div'))\n\n    // props\n    expect('msg' in instanceProxy).toBe(true)\n    // data\n    expect('foo' in instanceProxy).toBe(true)\n    // ctx\n    expect('bar' in instanceProxy).toBe(true)\n    // public properties\n    expect('$el' in instanceProxy).toBe(true)\n    // global properties\n    expect('global' in instanceProxy).toBe(true)\n\n    // non-existent\n    expect('$foobar' in instanceProxy).toBe(false)\n    expect('baz' in instanceProxy).toBe(false)\n\n    // #4962 triggering getter should not cause non-existent property to\n    // pass the has check\n    instanceProxy.baz\n    expect('baz' in instanceProxy).toBe(false)\n\n    // set non-existent (goes into proxyTarget sink)\n    instanceProxy.baz = 1\n    expect('baz' in instanceProxy).toBe(true)\n\n    // dev mode ownKeys check for console inspection\n    // should only expose own keys\n    expect(Object.keys(instanceProxy)).toMatchObject([\n      'msg',\n      'bar',\n      'foo',\n      'baz'\n    ])\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"allow updating proxy with Object.defineProperty","suites":["component: proxy"],"updatePoint":{"line":219,"column":55},"line":219,"code":"  test('allow updating proxy with Object.defineProperty', () => {\n    let instanceProxy: any\n    const Comp = {\n      render() {},\n      setup() {\n        return {\n          isDisplayed: true\n        }\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp)\n\n    app.mount(nodeOps.createElement('div'))\n\n    Object.defineProperty(instanceProxy, 'isDisplayed', { value: false })\n\n    expect(instanceProxy.isDisplayed).toBe(false)\n\n    Object.defineProperty(instanceProxy, 'isDisplayed', { value: true })\n\n    expect(instanceProxy.isDisplayed).toBe(true)\n\n    Object.defineProperty(instanceProxy, 'isDisplayed', {\n      get() {\n        return false\n      }\n    })\n\n    expect(instanceProxy.isDisplayed).toBe(false)\n\n    Object.defineProperty(instanceProxy, 'isDisplayed', {\n      get() {\n        return true\n      }\n    })\n\n    expect(instanceProxy.isDisplayed).toBe(true)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"allow test runner spying on proxy methods with Object.defineProperty","suites":["component: proxy"],"updatePoint":{"line":262,"column":76},"line":262,"code":"  test('allow test runner spying on proxy methods with Object.defineProperty', () => {\n    // #5417\n    let instanceProxy: any\n    const Comp = {\n      render() {},\n      setup() {\n        return {\n          toggle() {\n            return 'a'\n          }\n        }\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp)\n\n    app.mount(nodeOps.createElement('div'))\n\n    // access 'toggle' to ensure key is cached\n    const v1 = instanceProxy.toggle()\n    expect(v1).toEqual('a')\n\n    // reconfigure \"toggle\" to be getter based.\n    let getCalledTimes = 0\n    Object.defineProperty(instanceProxy, 'toggle', {\n      get() {\n        getCalledTimes++\n        return () => 'b'\n      }\n    })\n\n    // getter should not be evaluated on initial definition\n    expect(getCalledTimes).toEqual(0)\n\n    // invoke \"toggle\" after \"defineProperty\"\n    const v2 = instanceProxy.toggle()\n    expect(v2).toEqual('b')\n    expect(getCalledTimes).toEqual(1)\n\n    // expect toggle getter not to be cached. it can't be\n    instanceProxy.toggle()\n    expect(getCalledTimes).toEqual(2)\n\n    // attaching spy, triggers the getter once, and override the property.\n    // also uses Object.defineProperty\n    const spy = vi.spyOn(instanceProxy, 'toggle')\n    expect(getCalledTimes).toEqual(3)\n\n    // vitest does not cache the spy like jest do\n    const v3 = instanceProxy.toggle()\n    expect(v3).toEqual('b')\n    expect(spy).toHaveBeenCalled()\n    expect(getCalledTimes).toEqual(4)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"defineProperty on proxy property with value descriptor","suites":["component: proxy"],"updatePoint":{"line":320,"column":62},"line":320,"code":"  test('defineProperty on proxy property with value descriptor', () => {\n    // #5417\n    let instanceProxy: any\n    const Comp = {\n      render() {},\n      setup() {\n        return {\n          toggle: 'a'\n        }\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp)\n\n    app.mount(nodeOps.createElement('div'))\n\n    const v1 = instanceProxy.toggle\n    expect(v1).toEqual('a')\n\n    Object.defineProperty(instanceProxy, 'toggle', {\n      value: 'b'\n    })\n    const v2 = instanceProxy.toggle\n    expect(v2).toEqual('b')\n\n    // expect null to be a settable value\n    Object.defineProperty(instanceProxy, 'toggle', {\n      value: null\n    })\n    const v3 = instanceProxy.toggle\n    expect(v3).toBeNull()\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"defineProperty on public instance proxy should work with SETUP,DATA,CONTEXT,PROPS","suites":["component: proxy"],"updatePoint":{"line":356,"column":89},"line":356,"code":"  test('defineProperty on public instance proxy should work with SETUP,DATA,CONTEXT,PROPS', () => {\n    // #5417\n    let instanceProxy: any\n    const Comp = {\n      props: ['fromProp'],\n      data() {\n        return { name: 'data.name' }\n      },\n      computed: {\n        greet() {\n          return 'Hi ' + (this as any).name\n        }\n      },\n      render() {},\n      setup() {\n        return {\n          fromSetup: true\n        }\n      },\n      mounted() {\n        instanceProxy = this\n      }\n    }\n\n    const app = createApp(Comp, {\n      fromProp: true\n    })\n\n    app.mount(nodeOps.createElement('div'))\n    expect(instanceProxy.greet).toEqual('Hi data.name')\n\n    // define property on data\n    Object.defineProperty(instanceProxy, 'name', {\n      get() {\n        return 'getter.name'\n      }\n    })\n\n    // computed is same still cached\n    expect(instanceProxy.greet).toEqual('Hi data.name')\n\n    // trigger computed\n    instanceProxy.name = ''\n\n    // expect \"greet\" to evaluated and use name from context getter\n    expect(instanceProxy.greet).toEqual('Hi getter.name')\n\n    // defineProperty on computed ( context )\n    Object.defineProperty(instanceProxy, 'greet', {\n      get() {\n        return 'Hi greet.getter.computed'\n      }\n    })\n    expect(instanceProxy.greet).toEqual('Hi greet.getter.computed')\n\n    // defineProperty on setupState\n    expect(instanceProxy.fromSetup).toBe(true)\n    Object.defineProperty(instanceProxy, 'fromSetup', {\n      get() {\n        return false\n      }\n    })\n    expect(instanceProxy.fromSetup).toBe(false)\n\n    // defineProperty on Props\n    expect(instanceProxy.fromProp).toBe(true)\n    Object.defineProperty(instanceProxy, 'fromProp', {\n      get() {\n        return false\n      }\n    })\n    expect(instanceProxy.fromProp).toBe(false)\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn declared but absent props","suites":["component: proxy"],"updatePoint":{"line":431,"column":49},"line":431,"code":"  test('should not warn declared but absent props', () => {\n    const Comp = {\n      props: ['test'],\n      render(this: any) {\n        return this.test\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(\n      `was accessed during render but is not defined`\n    ).not.toHaveBeenWarned()\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should allow symbol to access on render","suites":["component: proxy"],"updatePoint":{"line":444,"column":47},"line":444,"code":"  test('should allow symbol to access on render', () => {\n    const Comp = {\n      render() {\n        if ((this as any)[Symbol.unscopables]) {\n          return '1'\n        }\n        return '2'\n      }\n    }\n\n    const app = createApp(Comp)\n    app.mount(nodeOps.createElement('div'))\n\n    expect(\n      `Property ${JSON.stringify(\n        Symbol.unscopables\n      )} was accessed during render ` + `but is not defined on instance.`\n    ).toHaveBeenWarned()\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should prevent mutating script setup bindings","suites":["component: proxy"],"updatePoint":{"line":464,"column":53},"line":464,"code":"  test('should prevent mutating script setup bindings', () => {\n    const Comp = defineComponent({\n      render() {},\n      setup() {\n        return {\n          __isScriptSetup: true,\n          foo: 1\n        }\n      },\n      mounted() {\n        expect('foo' in this).toBe(false)\n        try {\n          this.foo = 123\n        } catch (e) {}\n      }\n    })\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(`Cannot mutate <script setup> binding \"foo\"`).toHaveBeenWarned()\n  })","file":"componentPublicInstance.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"appear: true w/ appear hooks","suites":["BaseTransition"],"updatePoint":{"line":149,"column":36},"line":149,"code":"  test('appear: true w/ appear hooks', () => {\n    const { props, cbs } = mockProps({\n      appear: true\n    })\n    mount(props, () => h('div'))\n    expect(props.onBeforeAppear).toHaveBeenCalledTimes(1)\n    expect(props.onAppear).toHaveBeenCalledTimes(1)\n    expect(props.onAfterAppear).not.toHaveBeenCalled()\n\n    // enter should not be called\n    expect(props.onBeforeEnter).not.toHaveBeenCalled()\n    expect(props.onEnter).not.toHaveBeenCalled()\n    expect(props.onAfterEnter).not.toHaveBeenCalled()\n\n    cbs.doneEnter[`<div></div>`]()\n    expect(props.onAfterAppear).toHaveBeenCalledTimes(1)\n    expect(props.onAfterEnter).not.toHaveBeenCalled()\n  })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"appear: true w/ fallback to enter hooks","suites":["BaseTransition"],"updatePoint":{"line":168,"column":47},"line":168,"code":"  test('appear: true w/ fallback to enter hooks', () => {\n    const { props, cbs } = mockProps({\n      appear: true,\n      onBeforeAppear: undefined,\n      onAppear: undefined,\n      onAfterAppear: undefined,\n      onAppearCancelled: undefined\n    })\n    mount(props, () => h('div'))\n    expect(props.onBeforeEnter).toHaveBeenCalledTimes(1)\n    expect(props.onEnter).toHaveBeenCalledTimes(1)\n    expect(props.onAfterEnter).not.toHaveBeenCalled()\n    cbs.doneEnter[`<div></div>`]()\n    expect(props.onAfterEnter).toHaveBeenCalledTimes(1)\n  })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ appear: false","suites":["BaseTransition","persisted: true"],"updatePoint":{"line":214,"column":26},"line":214,"code":"    test('w/ appear: false', async () => {\n      const { props, cbs } = mockProps({ persisted: true })\n      const { toggle, state, hooks } = mockPersistedHooks()\n\n      mount(props, () => h('div', { id: toggle.value, ...hooks }))\n      // without appear: true, enter hooks should not be called on mount\n      expect(props.onBeforeEnter).not.toHaveBeenCalled()\n      expect(props.onEnter).not.toHaveBeenCalled()\n      expect(props.onAfterEnter).not.toHaveBeenCalled()\n\n      toggle.value = false\n      await nextTick()\n      expect(props.onBeforeLeave).toHaveBeenCalledTimes(1)\n      expect(props.onLeave).toHaveBeenCalledTimes(1)\n      expect(props.onAfterLeave).not.toHaveBeenCalled()\n      expect(state.show).toBe(true) // should still be shown\n      cbs.doneLeave[`<div id=false></div>`]()\n      expect(state.show).toBe(false) // should be hidden now\n      expect(props.onAfterLeave).toHaveBeenCalledTimes(1)\n\n      toggle.value = true\n      await nextTick()\n      expect(props.onBeforeEnter).toHaveBeenCalledTimes(1)\n      expect(props.onEnter).toHaveBeenCalledTimes(1)\n      expect(props.onAfterEnter).not.toHaveBeenCalled()\n      expect(state.show).toBe(true) // should be shown now\n      cbs.doneEnter[`<div id=true></div>`]()\n      expect(props.onAfterEnter).toHaveBeenCalledTimes(1)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ appear: true","suites":["BaseTransition","persisted: true"],"updatePoint":{"line":244,"column":25},"line":244,"code":"    test('w/ appear: true', () => {\n      const { props, cbs } = mockProps({ persisted: true, appear: true })\n      const { hooks } = mockPersistedHooks()\n      mount(props, () => h('div', hooks))\n\n      expect(props.onBeforeAppear).toHaveBeenCalledTimes(1)\n      expect(props.onAppear).toHaveBeenCalledTimes(1)\n      expect(props.onAfterAppear).not.toHaveBeenCalled()\n      cbs.doneEnter[`<div></div>`]()\n      expect(props.onAfterAppear).toHaveBeenCalledTimes(1)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ element","suites":["BaseTransition","toggle on-off"],"updatePoint":{"line":317,"column":20},"line":317,"code":"    test('w/ element', async () => {\n      await testToggleOnOff({\n        trueBranch: () => h('div'),\n        trueSerialized: `<div></div>`,\n        falseBranch: () => null,\n        falseSerialized: `<!---->`\n      })\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ component","suites":["BaseTransition","toggle on-off"],"updatePoint":{"line":326,"column":22},"line":326,"code":"    test('w/ component', async () => {\n      const Comp = ({ msg }: { msg: string }) => h('div', msg)\n      await testToggleOnOff({\n        trueBranch: () => h(Comp, { msg: 'hello' }),\n        trueSerialized: `<div>hello</div>`,\n        falseBranch: () => null,\n        falseSerialized: `<!---->`\n      })\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ mode: \"in-out","suites":["BaseTransition","toggle on-off"],"updatePoint":{"line":336,"column":26},"line":336,"code":"    test('w/ mode: \"in-out', async () => {\n      await testToggleOnOff(\n        {\n          trueBranch: () => h('div'),\n          trueSerialized: `<div></div>`,\n          falseBranch: () => null,\n          falseSerialized: `<!---->`\n        },\n        'in-out'\n      )\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ element","suites":["BaseTransition","toggle on-off before finish"],"updatePoint":{"line":410,"column":20},"line":410,"code":"    test('w/ element', async () => {\n      await testToggleOnOffBeforeFinish({\n        trueBranch: () => h('div'),\n        trueSerialized: `<div></div>`,\n        falseBranch: () => null,\n        falseSerialized: `<!---->`\n      })\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ component","suites":["BaseTransition","toggle on-off before finish"],"updatePoint":{"line":419,"column":22},"line":419,"code":"    test('w/ component', async () => {\n      const Comp = ({ msg }: { msg: string }) => h('div', msg)\n      await testToggleOnOffBeforeFinish({\n        trueBranch: () => h(Comp, { msg: 'hello' }),\n        trueSerialized: `<div>hello</div>`,\n        falseBranch: () => null,\n        falseSerialized: `<!---->`\n      })\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","toggle between branches"],"updatePoint":{"line":523,"column":21},"line":523,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testToggleBranches)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","toggle between branches"],"updatePoint":{"line":527,"column":23},"line":527,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testToggleBranches)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","toggle between branches"],"updatePoint":{"line":531,"column":22},"line":531,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testToggleBranches)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","toggle between branches before finish"],"updatePoint":{"line":656,"column":21},"line":656,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testToggleBranchesBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","toggle between branches before finish"],"updatePoint":{"line":660,"column":23},"line":660,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testToggleBranchesBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","toggle between branches before finish"],"updatePoint":{"line":664,"column":22},"line":664,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testToggleBranchesBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"out-in\""],"updatePoint":{"line":761,"column":21},"line":761,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"out-in\""],"updatePoint":{"line":765,"column":23},"line":765,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"out-in\""],"updatePoint":{"line":769,"column":22},"line":769,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"out-in\" toggle again after unmounted"],"updatePoint":{"line":843,"column":21},"line":843,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"out-in\" toggle again after unmounted"],"updatePoint":{"line":847,"column":23},"line":847,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"out-in\" toggle again after unmounted"],"updatePoint":{"line":851,"column":22},"line":851,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testOutIn)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"out-in\" toggle before finish"],"updatePoint":{"line":915,"column":21},"line":915,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testOutInBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"out-in\" toggle before finish"],"updatePoint":{"line":919,"column":23},"line":919,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testOutInBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"out-in\" toggle before finish"],"updatePoint":{"line":923,"column":22},"line":923,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testOutInBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"out-in\" double quick toggle"],"updatePoint":{"line":993,"column":21},"line":993,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testOutInDoubleToggle)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"out-in\" double quick toggle"],"updatePoint":{"line":997,"column":23},"line":997,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testOutInDoubleToggle)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"out-in\" double quick toggle"],"updatePoint":{"line":1001,"column":22},"line":1001,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testOutInDoubleToggle)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"in-out\""],"updatePoint":{"line":1097,"column":21},"line":1097,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testInOut)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"in-out\""],"updatePoint":{"line":1101,"column":23},"line":1101,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testInOut)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"in-out\""],"updatePoint":{"line":1105,"column":22},"line":1105,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testInOut)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ elements","suites":["BaseTransition","mode: \"in-out\" toggle before finish"],"updatePoint":{"line":1185,"column":21},"line":1185,"code":"    test('w/ elements', async () => {\n      await runTestWithElements(testInOutBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ components","suites":["BaseTransition","mode: \"in-out\" toggle before finish"],"updatePoint":{"line":1189,"column":23},"line":1189,"code":"    test('w/ components', async () => {\n      await runTestWithComponents(testInOutBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"w/ KeepAlive","suites":["BaseTransition","mode: \"in-out\" toggle before finish"],"updatePoint":{"line":1193,"column":22},"line":1193,"code":"    test('w/ KeepAlive', async () => {\n      await runTestWithKeepAlive(testInOutBeforeFinish)\n    })","file":"components/BaseTransition.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should preserve state","suites":["KeepAlive"],"updatePoint":{"line":81,"column":29},"line":81,"code":"  test('should preserve state', async () => {\n    const viewRef = ref('one')\n    const instanceRef = ref<any>(null)\n    const App = {\n      render() {\n        return h(KeepAlive, null, {\n          default: () => h(views[viewRef.value], { ref: instanceRef })\n        })\n      }\n    }\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    instanceRef.value.msg = 'changed'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>changed</div>`)\n    viewRef.value = 'two'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    viewRef.value = 'one'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>changed</div>`)\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call correct lifecycle hooks","suites":["KeepAlive"],"updatePoint":{"line":104,"column":43},"line":104,"code":"  test('should call correct lifecycle hooks', async () => {\n    const toggle = ref(true)\n    const viewRef = ref('one')\n    const App = {\n      render() {\n        return toggle.value ? h(KeepAlive, () => h(views[viewRef.value])) : null\n      }\n    }\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    assertHookCalls(one, [1, 1, 1, 0, 0])\n    assertHookCalls(two, [0, 0, 0, 0, 0])\n\n    // toggle kept-alive component\n    viewRef.value = 'two'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 1, 1, 0])\n    assertHookCalls(two, [1, 1, 1, 0, 0])\n\n    viewRef.value = 'one'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    assertHookCalls(one, [1, 1, 2, 1, 0])\n    assertHookCalls(two, [1, 1, 1, 1, 0])\n\n    viewRef.value = 'two'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 2, 2, 0])\n    assertHookCalls(two, [1, 1, 2, 1, 0])\n\n    // teardown keep-alive, should unmount all components including cached\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 2, 1])\n    assertHookCalls(two, [1, 1, 2, 2, 1])\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call correct lifecycle hooks when toggle the KeepAlive first","suites":["KeepAlive"],"updatePoint":{"line":145,"column":75},"line":145,"code":"  test('should call correct lifecycle hooks when toggle the KeepAlive first', async () => {\n    const toggle = ref(true)\n    const viewRef = ref('one')\n    const App = {\n      render() {\n        return toggle.value ? h(KeepAlive, () => h(views[viewRef.value])) : null\n      }\n    }\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    assertHookCalls(one, [1, 1, 1, 0, 0])\n    assertHookCalls(two, [0, 0, 0, 0, 0])\n\n    // should unmount 'one' component when toggle the KeepAlive first\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 1, 1, 1])\n    assertHookCalls(two, [0, 0, 0, 0, 0])\n\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    assertHookCalls(one, [2, 2, 2, 1, 1])\n    assertHookCalls(two, [0, 0, 0, 0, 0])\n\n    // 1. the first time toggle kept-alive component\n    viewRef.value = 'two'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [2, 2, 2, 2, 1])\n    assertHookCalls(two, [1, 1, 1, 0, 0])\n\n    // 2. should unmount all components including cached\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [2, 2, 2, 2, 2])\n    assertHookCalls(two, [1, 1, 1, 1, 1])\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call lifecycle hooks on nested components","suites":["KeepAlive"],"updatePoint":{"line":187,"column":56},"line":187,"code":"  test('should call lifecycle hooks on nested components', async () => {\n    one.render = () => h(two)\n\n    const toggle = ref(true)\n    const App = {\n      render() {\n        return h(KeepAlive, () => (toggle.value ? h(one) : null))\n      }\n    }\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 1, 0, 0])\n    assertHookCalls(two, [1, 1, 1, 0, 0])\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 1, 1, 0])\n    assertHookCalls(two, [1, 1, 1, 1, 0])\n\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 2, 1, 0])\n    assertHookCalls(two, [1, 1, 2, 1, 0])\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 2, 0])\n    assertHookCalls(two, [1, 1, 2, 2, 0])\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call lifecycle hooks on nested components when root component no hooks","suites":["KeepAlive"],"updatePoint":{"line":222,"column":85},"line":222,"code":"  test('should call lifecycle hooks on nested components when root component no hooks', async () => {\n    const two = {\n      name: 'two',\n      data: () => ({ msg: 'two' }),\n      render(this: any) {\n        return h('div', this.msg)\n      },\n      activated: vi.fn()\n    }\n    const one = {\n      name: 'one',\n      data: () => ({ msg: 'one' }),\n      render(this: any) {\n        return h(two)\n      }\n    }\n\n    const toggle = ref(true)\n    const App = {\n      render() {\n        return h(KeepAlive, () => (toggle.value ? h(one) : null))\n      }\n    }\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    expect(two.activated).toHaveBeenCalledTimes(1)\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call correct hooks for nested keep-alive","suites":["KeepAlive"],"updatePoint":{"line":251,"column":55},"line":251,"code":"  test('should call correct hooks for nested keep-alive', async () => {\n    const toggle2 = ref(true)\n    one.render = () => h(KeepAlive, () => (toggle2.value ? h(two) : null))\n\n    const toggle1 = ref(true)\n    const App = {\n      render() {\n        return h(KeepAlive, () => (toggle1.value ? h(one) : null))\n      }\n    }\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 1, 0, 0])\n    assertHookCalls(two, [1, 1, 1, 0, 0])\n\n    toggle1.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 1, 1, 0])\n    assertHookCalls(two, [1, 1, 1, 1, 0])\n\n    toggle1.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 2, 1, 0])\n    assertHookCalls(two, [1, 1, 2, 1, 0])\n\n    // toggle nested instance\n    toggle2.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 1, 0])\n    assertHookCalls(two, [1, 1, 2, 2, 0])\n\n    toggle2.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 2, 1, 0])\n    assertHookCalls(two, [1, 1, 3, 2, 0])\n\n    toggle1.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 2, 0])\n    assertHookCalls(two, [1, 1, 3, 3, 0])\n\n    // toggle nested instance when parent is deactivated\n    toggle2.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 2, 0])\n    assertHookCalls(two, [1, 1, 3, 3, 0]) // should not be affected\n\n    toggle2.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 2, 2, 0])\n    assertHookCalls(two, [1, 1, 3, 3, 0]) // should not be affected\n\n    toggle1.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    assertHookCalls(one, [1, 1, 3, 2, 0])\n    assertHookCalls(two, [1, 1, 4, 3, 0])\n\n    toggle1.value = false\n    toggle2.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 3, 3, 0])\n    assertHookCalls(two, [1, 1, 4, 4, 0])\n\n    toggle1.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    assertHookCalls(one, [1, 1, 4, 3, 0])\n    assertHookCalls(two, [1, 1, 4, 4, 0]) // should remain inactive\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"include (string)","suites":["KeepAlive","props"],"updatePoint":{"line":374,"column":26},"line":374,"code":"    test('include (string)', async () => {\n      await assertNameMatch({ include: 'one' })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"include (regex)","suites":["KeepAlive","props"],"updatePoint":{"line":378,"column":25},"line":378,"code":"    test('include (regex)', async () => {\n      await assertNameMatch({ include: /^one$/ })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"include (array)","suites":["KeepAlive","props"],"updatePoint":{"line":382,"column":25},"line":382,"code":"    test('include (array)', async () => {\n      await assertNameMatch({ include: ['one'] })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"exclude (string)","suites":["KeepAlive","props"],"updatePoint":{"line":386,"column":26},"line":386,"code":"    test('exclude (string)', async () => {\n      await assertNameMatch({ exclude: 'two' })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"exclude (regex)","suites":["KeepAlive","props"],"updatePoint":{"line":390,"column":25},"line":390,"code":"    test('exclude (regex)', async () => {\n      await assertNameMatch({ exclude: /^two$/ })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"exclude (array)","suites":["KeepAlive","props"],"updatePoint":{"line":394,"column":25},"line":394,"code":"    test('exclude (array)', async () => {\n      await assertNameMatch({ exclude: ['two'] })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"include + exclude","suites":["KeepAlive","props"],"updatePoint":{"line":398,"column":27},"line":398,"code":"    test('include + exclude', async () => {\n      await assertNameMatch({ include: 'one,two', exclude: 'two' })\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"max","suites":["KeepAlive","props"],"updatePoint":{"line":402,"column":13},"line":402,"code":"    test('max', async () => {\n      const spyAC = vi.fn()\n      const spyBC = vi.fn()\n      const spyCC = vi.fn()\n      const spyAA = vi.fn()\n      const spyBA = vi.fn()\n      const spyCA = vi.fn()\n      const spyADA = vi.fn()\n      const spyBDA = vi.fn()\n      const spyCDA = vi.fn()\n      const spyAUM = vi.fn()\n      const spyBUM = vi.fn()\n      const spyCUM = vi.fn()\n\n      function assertCount(calls: number[]) {\n        expect([\n          spyAC.mock.calls.length,\n          spyAA.mock.calls.length,\n          spyADA.mock.calls.length,\n          spyAUM.mock.calls.length,\n          spyBC.mock.calls.length,\n          spyBA.mock.calls.length,\n          spyBDA.mock.calls.length,\n          spyBUM.mock.calls.length,\n          spyCC.mock.calls.length,\n          spyCA.mock.calls.length,\n          spyCDA.mock.calls.length,\n          spyCUM.mock.calls.length\n        ]).toEqual(calls)\n      }\n\n      const viewRef = ref('a')\n      const views: Record<string, ComponentOptions> = {\n        a: {\n          render: () => `one`,\n          created: spyAC,\n          activated: spyAA,\n          deactivated: spyADA,\n          unmounted: spyAUM\n        },\n        b: {\n          render: () => `two`,\n          created: spyBC,\n          activated: spyBA,\n          deactivated: spyBDA,\n          unmounted: spyBUM\n        },\n        c: {\n          render: () => `three`,\n          created: spyCC,\n          activated: spyCA,\n          deactivated: spyCDA,\n          unmounted: spyCUM\n        }\n      }\n\n      const App = {\n        render() {\n          return h(KeepAlive, { max: 2 }, () => {\n            return h(views[viewRef.value])\n          })\n        }\n      }\n      render(h(App), root)\n      assertCount([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n      viewRef.value = 'b'\n      await nextTick()\n      assertCount([1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0])\n\n      viewRef.value = 'c'\n      await nextTick()\n      // should prune A because max cache reached\n      assertCount([1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0])\n\n      viewRef.value = 'b'\n      await nextTick()\n      // B should be reused, and made latest\n      assertCount([1, 1, 1, 1, 1, 2, 1, 0, 1, 1, 1, 0])\n\n      viewRef.value = 'a'\n      await nextTick()\n      // C should be pruned because B was used last so C is the oldest cached\n      assertCount([2, 2, 1, 1, 1, 2, 2, 0, 1, 1, 1, 1])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on include change","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":526,"column":27},"line":526,"code":"    test('on include change', async () => {\n      const { viewRef, includeRef } = setup()\n\n      viewRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 0])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      includeRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 1])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      viewRef.value = 'one'\n      await nextTick()\n      assertHookCalls(one, [2, 2, 1, 1, 1])\n      assertHookCalls(two, [1, 1, 1, 1, 0])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on exclude change","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":545,"column":27},"line":545,"code":"    test('on exclude change', async () => {\n      const { viewRef, excludeRef } = setupExclude()\n\n      viewRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 0])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      excludeRef.value = 'one'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 1])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      viewRef.value = 'one'\n      await nextTick()\n      assertHookCalls(one, [2, 2, 1, 1, 1])\n      assertHookCalls(two, [1, 1, 1, 1, 0])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on include change + view switch","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":564,"column":41},"line":564,"code":"    test('on include change + view switch', async () => {\n      const { viewRef, includeRef } = setup()\n\n      viewRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 0])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      includeRef.value = 'one'\n      viewRef.value = 'one'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 2, 1, 0])\n      // two should be pruned\n      assertHookCalls(two, [1, 1, 1, 1, 1])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on exclude change + view switch","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":580,"column":41},"line":580,"code":"    test('on exclude change + view switch', async () => {\n      const { viewRef, excludeRef } = setupExclude()\n\n      viewRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 1, 0])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n\n      excludeRef.value = 'two'\n      viewRef.value = 'one'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 2, 1, 0])\n      // two should be pruned\n      assertHookCalls(two, [1, 1, 1, 1, 1])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not prune current active instance","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":596,"column":50},"line":596,"code":"    test('should not prune current active instance', async () => {\n      const { viewRef, includeRef } = setup()\n\n      includeRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 0, 0])\n      assertHookCalls(two, [0, 0, 0, 0, 0])\n\n      viewRef.value = 'two'\n      await nextTick()\n      assertHookCalls(one, [1, 1, 1, 0, 1])\n      assertHookCalls(two, [1, 1, 1, 0, 0])\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not cache anonymous component when include is specified","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":662,"column":72},"line":662,"code":"    test('should not cache anonymous component when include is specified', async () => {\n      await assertAnonymous(true)\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should cache anonymous components if include is not specified","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":666,"column":71},"line":666,"code":"    test('should cache anonymous components if include is not specified', async () => {\n      await assertAnonymous(false)\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not destroy active instance when pruning cache","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":671,"column":63},"line":671,"code":"    test('should not destroy active instance when pruning cache', async () => {\n      const Foo = {\n        render: () => 'foo',\n        unmounted: vi.fn()\n      }\n      const includeRef = ref(['foo'])\n      const App = {\n        render() {\n          return h(\n            KeepAlive,\n            {\n              include: includeRef.value\n            },\n            () => h(Foo)\n          )\n        }\n      }\n      render(h(App), root)\n      // condition: a render where a previous component is reused\n      includeRef.value = ['foo', 'bar']\n      await nextTick()\n      includeRef.value = []\n      await nextTick()\n      expect(Foo.unmounted).not.toHaveBeenCalled()\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update re-activated component if props have changed","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":697,"column":68},"line":697,"code":"    test('should update re-activated component if props have changed', async () => {\n      const Foo = (props: { n: number }) => props.n\n\n      const toggle = ref(true)\n      const n = ref(0)\n\n      const App = {\n        setup() {\n          return () =>\n            h(KeepAlive, () => (toggle.value ? h(Foo, { n: n.value }) : null))\n        }\n      }\n\n      render(h(App), root)\n      expect(serializeInner(root)).toBe(`0`)\n\n      toggle.value = false\n      await nextTick()\n      expect(serializeInner(root)).toBe(`<!---->`)\n\n      n.value++\n      await nextTick()\n      toggle.value = true\n      await nextTick()\n      expect(serializeInner(root)).toBe(`1`)\n    })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should call correct vnode hooks","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":725,"column":37},"line":725,"code":"  it('should call correct vnode hooks', async () => {\n    const Foo = markRaw({\n      name: 'Foo',\n      render() {\n        return h('Foo')\n      }\n    })\n    const Bar = markRaw({\n      name: 'Bar',\n      render() {\n        return h('Bar')\n      }\n    })\n\n    const spyMounted = vi.fn()\n    const spyUnmounted = vi.fn()\n\n    const RouterView = defineComponent({\n      setup(_, { slots }) {\n        const Component = inject<Ref<ComponentPublicInstance>>('component')\n        const refView = ref()\n\n        let componentProps = {\n          ref: refView,\n          onVnodeMounted() {\n            spyMounted()\n          },\n          onVnodeUnmounted() {\n            spyUnmounted()\n          }\n        }\n\n        return () => {\n          const child: any = slots.default!({\n            Component: Component!.value\n          })[0]\n\n          const innerChild = child.children[0]\n          child.children[0] = cloneVNode(innerChild, componentProps)\n          return child\n        }\n      }\n    })\n\n    let toggle: () => void = () => {}\n\n    const App = defineComponent({\n      setup() {\n        const component = ref(Foo)\n\n        provide('component', component)\n\n        toggle = () => {\n          component.value = component.value === Foo ? Bar : Foo\n        }\n        return {\n          component,\n          toggle\n        }\n      },\n      render() {\n        return h(RouterView, null, {\n          default: ({ Component }: any) => h(KeepAlive, null, [h(Component)])\n        })\n      }\n    })\n\n    render(h(App), root)\n    await nextTick()\n    expect(spyMounted).toHaveBeenCalledTimes(1)\n    expect(spyUnmounted).toHaveBeenCalledTimes(0)\n\n    toggle()\n    await nextTick()\n\n    expect(spyMounted).toHaveBeenCalledTimes(2)\n    expect(spyUnmounted).toHaveBeenCalledTimes(1)\n\n    toggle()\n    await nextTick()\n    expect(spyMounted).toHaveBeenCalledTimes(3)\n    expect(spyUnmounted).toHaveBeenCalledTimes(2)\n\n    render(null, root)\n    await nextTick()\n    expect(spyMounted).toHaveBeenCalledTimes(3)\n    expect(spyUnmounted).toHaveBeenCalledTimes(4)\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with cloned root due to scopeId / fallthrough attrs","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":815,"column":71},"line":815,"code":"  test('should work with cloned root due to scopeId / fallthrough attrs', async () => {\n    const viewRef = ref('one')\n    const instanceRef = ref<any>(null)\n    const App = {\n      __scopeId: 'foo',\n      render: () => {\n        return h(KeepAlive, null, {\n          default: () => h(views[viewRef.value], { ref: instanceRef })\n        })\n      }\n    }\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div foo>one</div>`)\n    instanceRef.value.msg = 'changed'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div foo>changed</div>`)\n    viewRef.value = 'two'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div foo>two</div>`)\n    viewRef.value = 'one'\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div foo>changed</div>`)\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with async component","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":839,"column":40},"line":839,"code":"  test('should work with async component', async () => {\n    let resolve: (comp: Component) => void\n    const AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r as any\n        })\n    )\n\n    const toggle = ref(true)\n    const instanceRef = ref<any>(null)\n    const App = {\n      render: () => {\n        return h(KeepAlive, { include: 'Foo' }, () =>\n          toggle.value ? h(AsyncComp, { ref: instanceRef }) : null\n        )\n      }\n    }\n\n    render(h(App), root)\n    // async component has not been resolved\n    expect(serializeInner(root)).toBe('<!---->')\n\n    resolve!({\n      name: 'Foo',\n      data: () => ({ count: 0 }),\n      render() {\n        return h('p', this.count)\n      }\n    })\n\n    await timeout()\n    // resolved\n    expect(serializeInner(root)).toBe('<p>0</p>')\n\n    // change state + toggle out\n    instanceRef.value.count++\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe('<!---->')\n\n    // toggle in, state should be maintained\n    toggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe('<p>1</p>')\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handle error in async onActivated","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":887,"column":41},"line":887,"code":"  test('handle error in async onActivated', async () => {\n    const err = new Error('foo')\n    const handler = vi.fn()\n\n    const app = createApp({\n      setup() {\n        return () => h(KeepAlive, null, () => h(Child))\n      }\n    })\n\n    const Child = {\n      setup() {\n        onActivated(async () => {\n          throw err\n        })\n      },\n      render() {}\n    }\n\n    app.config.errorHandler = handler\n    app.mount(nodeOps.createElement('div'))\n\n    await nextTick()\n    expect(handler).toHaveBeenCalledWith(err, {}, 'activated hook')\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should avoid unmount later included components","suites":["KeepAlive","cache invalidation"],"updatePoint":{"line":914,"column":54},"line":914,"code":"  test('should avoid unmount later included components', async () => {\n    const unmountedA = vi.fn()\n    const mountedA = vi.fn()\n    const activatedA = vi.fn()\n    const deactivatedA = vi.fn()\n    const unmountedB = vi.fn()\n    const mountedB = vi.fn()\n\n    const A = {\n      name: 'A',\n      setup() {\n        onMounted(mountedA)\n        onUnmounted(unmountedA)\n        onActivated(activatedA)\n        onDeactivated(deactivatedA)\n        return () => 'A'\n      }\n    }\n    const B = {\n      name: 'B',\n      setup() {\n        onMounted(mountedB)\n        onUnmounted(unmountedB)\n        return () => 'B'\n      }\n    }\n\n    const include = reactive<string[]>([])\n    const current = shallowRef(A)\n    const app = createApp({\n      setup() {\n        return () => {\n          return [\n            h(\n              KeepAlive,\n              {\n                include\n              },\n              h(current.value)\n            )\n          ]\n        }\n      }\n    })\n\n    app.mount(root)\n\n    expect(serializeInner(root)).toBe(`A`)\n    expect(mountedA).toHaveBeenCalledTimes(1)\n    expect(unmountedA).toHaveBeenCalledTimes(0)\n    expect(activatedA).toHaveBeenCalledTimes(0)\n    expect(deactivatedA).toHaveBeenCalledTimes(0)\n    expect(mountedB).toHaveBeenCalledTimes(0)\n    expect(unmountedB).toHaveBeenCalledTimes(0)\n\n    include.push('A') // cache A\n    await nextTick()\n    current.value = B // toggle to B\n    await nextTick()\n    expect(serializeInner(root)).toBe(`B`)\n    expect(mountedA).toHaveBeenCalledTimes(1)\n    expect(unmountedA).toHaveBeenCalledTimes(0)\n    expect(activatedA).toHaveBeenCalledTimes(0)\n    expect(deactivatedA).toHaveBeenCalledTimes(1)\n    expect(mountedB).toHaveBeenCalledTimes(1)\n    expect(unmountedB).toHaveBeenCalledTimes(0)\n  })","file":"components/KeepAlive.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"fallback content","suites":["Suspense"],"updatePoint":{"line":51,"column":24},"line":51,"code":"  test('fallback content', async () => {\n    const Async = defineAsyncComponent({\n      render() {\n        return h('div', 'async')\n      }\n    })\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(Async),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>async</div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"emits events","suites":["Suspense"],"updatePoint":{"line":77,"column":20},"line":77,"code":"  test('emits events', async () => {\n    const Async = defineAsyncComponent({\n      render() {\n        return h('div', 'async')\n      }\n    })\n\n    const onFallback = vi.fn()\n    const onResolve = vi.fn()\n    const onPending = vi.fn()\n\n    const show = ref(true)\n    const Comp = {\n      setup() {\n        return () =>\n          h(\n            Suspense,\n            {\n              onFallback,\n              onResolve,\n              onPending,\n              // force displaying the fallback right away\n              timeout: 0\n            },\n            {\n              default: () => (show.value ? h(Async) : null),\n              fallback: h('div', 'fallback')\n            }\n          )\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(onFallback).toHaveBeenCalledTimes(1)\n    expect(onPending).toHaveBeenCalledTimes(1)\n    expect(onResolve).toHaveBeenCalledTimes(0)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(onFallback).toHaveBeenCalledTimes(1)\n    expect(onPending).toHaveBeenCalledTimes(1)\n    expect(onResolve).toHaveBeenCalledTimes(1)\n\n    show.value = false\n    await nextTick()\n    expect(onFallback).toHaveBeenCalledTimes(1)\n    expect(onPending).toHaveBeenCalledTimes(2)\n    expect(onResolve).toHaveBeenCalledTimes(2)\n\n    deps.length = 0\n    show.value = true\n    await nextTick()\n    expect(onFallback).toHaveBeenCalledTimes(2)\n    expect(onPending).toHaveBeenCalledTimes(3)\n    expect(onResolve).toHaveBeenCalledTimes(2)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(onFallback).toHaveBeenCalledTimes(2)\n    expect(onPending).toHaveBeenCalledTimes(3)\n    expect(onResolve).toHaveBeenCalledTimes(3)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested async deps","suites":["Suspense"],"updatePoint":{"line":141,"column":25},"line":141,"code":"  test('nested async deps', async () => {\n    const calls: string[] = []\n\n    const AsyncOuter = defineAsyncComponent({\n      setup() {\n        onMounted(() => {\n          calls.push('outer mounted')\n        })\n        return () => h(AsyncInner)\n      }\n    })\n\n    const AsyncInner = defineAsyncComponent(\n      {\n        setup() {\n          onMounted(() => {\n            calls.push('inner mounted')\n          })\n          return () => h('div', 'inner')\n        }\n      },\n      10\n    )\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(AsyncOuter),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(calls).toEqual([`outer mounted`, `inner mounted`])\n    expect(serializeInner(root)).toBe(`<div>inner</div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"onResolve","suites":["Suspense"],"updatePoint":{"line":191,"column":17},"line":191,"code":"  test('onResolve', async () => {\n    const Async = defineAsyncComponent({\n      render() {\n        return h('div', 'async')\n      }\n    })\n\n    const onResolve = vi.fn()\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(\n            Suspense,\n            {\n              onResolve\n            },\n            {\n              default: h(Async),\n              fallback: h('div', 'fallback')\n            }\n          )\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(onResolve).not.toHaveBeenCalled()\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>async</div>`)\n    expect(onResolve).toHaveBeenCalled()\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"buffer mounted/updated hooks & post flush watch callbacks","suites":["Suspense"],"updatePoint":{"line":227,"column":65},"line":227,"code":"  test('buffer mounted/updated hooks & post flush watch callbacks', async () => {\n    const deps: Promise<any>[] = []\n    const calls: string[] = []\n    const toggle = ref(true)\n\n    const Async = {\n      async setup() {\n        const p = new Promise(r => setTimeout(r, 1))\n        // extra tick needed for Node 12+\n        deps.push(p.then(() => Promise.resolve()))\n\n        watchEffect(\n          () => {\n            calls.push('watch effect')\n          },\n          { flush: 'post' }\n        )\n\n        const count = ref(0)\n        watch(\n          count,\n          () => {\n            calls.push('watch callback')\n          },\n          { flush: 'post' }\n        )\n        count.value++ // trigger the watcher now\n\n        onMounted(() => {\n          calls.push('mounted')\n        })\n\n        onUnmounted(() => {\n          calls.push('unmounted')\n        })\n\n        await p\n        return () => h('div', 'async')\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: toggle.value ? h(Async) : null,\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>async</div>`)\n    expect(calls).toEqual([`watch effect`, `watch callback`, `mounted`])\n\n    // effects inside an already resolved suspense should happen at normal timing\n    toggle.value = false\n    await nextTick()\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    expect(calls).toEqual([\n      `watch effect`,\n      `watch callback`,\n      `mounted`,\n      'unmounted'\n    ])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"mounted/updated hooks & fallback component","suites":["Suspense"],"updatePoint":{"line":302,"column":50},"line":302,"code":"  test('mounted/updated hooks & fallback component', async () => {\n    const deps: Promise<any>[] = []\n    const calls: string[] = []\n    const toggle = ref(true)\n\n    const Async = {\n      async setup() {\n        const p = new Promise(r => setTimeout(r, 1))\n        // extra tick needed for Node 12+\n        deps.push(p.then(() => Promise.resolve()))\n\n        await p\n        return () => h('div', 'async')\n      }\n    }\n\n    const Fallback = {\n      setup() {\n        onMounted(() => {\n          calls.push('mounted')\n        })\n\n        onUnmounted(() => {\n          calls.push('unmounted')\n        })\n        return () => h('div', 'fallback')\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: toggle.value ? h(Async) : null,\n            fallback: h(Fallback)\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([`mounted`])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>async</div>`)\n    expect(calls).toEqual([`mounted`, `unmounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"content update before suspense resolve","suites":["Suspense"],"updatePoint":{"line":352,"column":46},"line":352,"code":"  test('content update before suspense resolve', async () => {\n    const Async = defineAsyncComponent({\n      props: { msg: String },\n      setup(props: any) {\n        return () => h('div', props.msg)\n      }\n    })\n\n    const msg = ref('foo')\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(Async, { msg: msg.value }),\n            fallback: h('div', `fallback ${msg.value}`)\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback foo</div>`)\n\n    // value changed before resolve\n    msg.value = 'bar'\n    await nextTick()\n    // fallback content should be updated\n    expect(serializeInner(root)).toBe(`<div>fallback bar</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    // async component should receive updated props/slots when resolved\n    expect(serializeInner(root)).toBe(`<div>bar</div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount before suspense resolve","suites":["Suspense"],"updatePoint":{"line":389,"column":39},"line":389,"code":"  test('unmount before suspense resolve', async () => {\n    const deps: Promise<any>[] = []\n    const calls: string[] = []\n    const toggle = ref(true)\n\n    const Async = {\n      async setup() {\n        const p = new Promise(r => setTimeout(r, 1))\n        deps.push(p)\n\n        watchEffect(\n          () => {\n            calls.push('watch effect')\n          },\n          { flush: 'post' }\n        )\n\n        const count = ref(0)\n        watch(\n          count,\n          () => {\n            calls.push('watch callback')\n          },\n          { flush: 'post' }\n        )\n        count.value++ // trigger the watcher now\n\n        onMounted(() => {\n          calls.push('mounted')\n        })\n\n        onUnmounted(() => {\n          calls.push('unmounted')\n        })\n\n        await p\n        return () => h('div', 'async')\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: toggle.value ? h(Async) : null,\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    // remove the async dep before it's resolved\n    toggle.value = false\n    await nextTick()\n    // should cause the suspense to resolve immediately\n    expect(serializeInner(root)).toBe(`<!---->`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    // should discard effects\n    expect(calls).toEqual([])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount suspense after resolve","suites":["Suspense"],"updatePoint":{"line":457,"column":38},"line":457,"code":"  test('unmount suspense after resolve', async () => {\n    const toggle = ref(true)\n    const unmounted = vi.fn()\n\n    const Async = defineAsyncComponent({\n      setup() {\n        onUnmounted(unmounted)\n        return () => h('div', 'async')\n      }\n    })\n\n    const Comp = {\n      setup() {\n        return () =>\n          toggle.value\n            ? h(Suspense, null, {\n                default: h(Async),\n                fallback: h('div', 'fallback')\n              })\n            : null\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>async</div>`)\n    expect(unmounted).not.toHaveBeenCalled()\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    expect(unmounted).toHaveBeenCalled()\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount suspense before resolve","suites":["Suspense"],"updatePoint":{"line":495,"column":39},"line":495,"code":"  test('unmount suspense before resolve', async () => {\n    const toggle = ref(true)\n    const mounted = vi.fn()\n    const unmounted = vi.fn()\n\n    const Async = defineAsyncComponent({\n      setup() {\n        onMounted(mounted)\n        onUnmounted(unmounted)\n        return () => h('div', 'async')\n      }\n    })\n\n    const Comp = {\n      setup() {\n        return () =>\n          toggle.value\n            ? h(Suspense, null, {\n                default: h(Async),\n                fallback: h('div', 'fallback')\n              })\n            : null\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<!---->`)\n    expect(mounted).not.toHaveBeenCalled()\n    expect(unmounted).not.toHaveBeenCalled()\n\n    await Promise.all(deps)\n    await nextTick()\n    // should not resolve and cause unmount\n    expect(mounted).not.toHaveBeenCalled()\n    expect(unmounted).not.toHaveBeenCalled()\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested suspense (parent resolves first)","suites":["Suspense"],"updatePoint":{"line":537,"column":47},"line":537,"code":"  test('nested suspense (parent resolves first)', async () => {\n    const calls: string[] = []\n\n    const AsyncOuter = defineAsyncComponent(\n      {\n        setup: () => {\n          onMounted(() => {\n            calls.push('outer mounted')\n          })\n          return () => h('div', 'async outer')\n        }\n      },\n      1\n    )\n\n    const AsyncInner = defineAsyncComponent(\n      {\n        setup: () => {\n          onMounted(() => {\n            calls.push('inner mounted')\n          })\n          return () => h('div', 'async inner')\n        }\n      },\n      10\n    )\n\n    const Inner = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(AsyncInner),\n            fallback: h('div', 'fallback inner')\n          })\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h('div', [h(AsyncOuter), h(Inner)]),\n            fallback: h('div', 'fallback outer')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback outer</div>`)\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>async outer</div><div>fallback inner</div></div>`\n    )\n    expect(calls).toEqual([`outer mounted`])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>async outer</div><div>async inner</div></div>`\n    )\n    expect(calls).toEqual([`outer mounted`, `inner mounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested suspense (child resolves first)","suites":["Suspense"],"updatePoint":{"line":603,"column":46},"line":603,"code":"  test('nested suspense (child resolves first)', async () => {\n    const calls: string[] = []\n\n    const AsyncOuter = defineAsyncComponent(\n      {\n        setup: () => {\n          onMounted(() => {\n            calls.push('outer mounted')\n          })\n          return () => h('div', 'async outer')\n        }\n      },\n      10\n    )\n\n    const AsyncInner = defineAsyncComponent(\n      {\n        setup: () => {\n          onMounted(() => {\n            calls.push('inner mounted')\n          })\n          return () => h('div', 'async inner')\n        }\n      },\n      1\n    )\n\n    const Inner = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(AsyncInner),\n            fallback: h('div', 'fallback inner')\n          })\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h('div', [h(AsyncOuter), h(Inner)]),\n            fallback: h('div', 'fallback outer')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback outer</div>`)\n\n    await deps[1]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>fallback outer</div>`)\n    expect(calls).toEqual([])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>async outer</div><div>async inner</div></div>`\n    )\n    expect(calls).toEqual([`inner mounted`, `outer mounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error handling","suites":["Suspense"],"updatePoint":{"line":667,"column":22},"line":667,"code":"  test('error handling', async () => {\n    const Async = {\n      async setup() {\n        throw new Error('oops')\n      }\n    }\n\n    const Comp = {\n      setup() {\n        const errorMessage = ref<string | null>(null)\n        onErrorCaptured(err => {\n          errorMessage.value =\n            err instanceof Error\n              ? err.message\n              : `A non-Error value thrown: ${err}`\n          return false\n        })\n\n        return () =>\n          errorMessage.value\n            ? h('div', errorMessage.value)\n            : h(Suspense, null, {\n                default: h(Async),\n                fallback: h('div', 'fallback')\n              })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>oops</div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error handling w/ template optimization","suites":["Suspense"],"updatePoint":{"line":705,"column":47},"line":705,"code":"  test('error handling w/ template optimization', async () => {\n    const Async = {\n      async setup() {\n        throw new Error('oops')\n      }\n    }\n\n    const Comp = {\n      template: `\n      <div v-if=\"errorMessage\">{{ errorMessage }}</div>\n      <Suspense v-else>\n        <div>\n          <Async />\n        </div>\n        <template #fallback>\n          <div>fallback</div>\n        </template>\n      </Suspense>\n      `,\n      components: { Async },\n      setup() {\n        const errorMessage = ref<string | null>(null)\n        onErrorCaptured(err => {\n          errorMessage.value =\n            err instanceof Error\n              ? err.message\n              : `A non-Error value thrown: ${err}`\n          return false\n        })\n        return { errorMessage }\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>oops</div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"combined usage (nested async + nested suspense + multiple deps)","suites":["Suspense"],"updatePoint":{"line":747,"column":69},"line":747,"code":"  it('combined usage (nested async + nested suspense + multiple deps)', async () => {\n    const msg = ref('nested msg')\n    const calls: number[] = []\n\n    const AsyncChildWithSuspense = defineAsyncComponent({\n      props: { msg: String },\n      setup(props: any) {\n        onMounted(() => {\n          calls.push(0)\n        })\n        return () =>\n          h(Suspense, null, {\n            default: h(AsyncInsideNestedSuspense, { msg: props.msg }),\n            fallback: h('div', 'nested fallback')\n          })\n      }\n    })\n\n    const AsyncInsideNestedSuspense = defineAsyncComponent(\n      {\n        props: { msg: String },\n        setup(props: any) {\n          onMounted(() => {\n            calls.push(2)\n          })\n          return () => h('div', props.msg)\n        }\n      },\n      20\n    )\n\n    const AsyncChildParent = defineAsyncComponent({\n      props: { msg: String },\n      setup(props: any) {\n        onMounted(() => {\n          calls.push(1)\n        })\n        return () => h(NestedAsyncChild, { msg: props.msg })\n      }\n    })\n\n    const NestedAsyncChild = defineAsyncComponent(\n      {\n        props: { msg: String },\n        setup(props: any) {\n          onMounted(() => {\n            calls.push(3)\n          })\n          return () => h('div', props.msg)\n        }\n      },\n      10\n    )\n\n    const MiddleComponent = {\n      setup() {\n        return () =>\n          h(AsyncChildWithSuspense, {\n            msg: msg.value\n          })\n      }\n    }\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h('div', [\n              h(MiddleComponent),\n              h(AsyncChildParent, {\n                msg: 'root async'\n              })\n            ]),\n            fallback: h('div', 'root fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>root fallback</div>`)\n    expect(calls).toEqual([])\n\n    /**\n     * <Root>\n     *   <Suspense>\n     *     <MiddleComponent>\n     *       <AsyncChildWithSuspense> (0: resolves on macrotask)\n     *         <Suspense>\n     *           <AsyncInsideNestedSuspense> (2: resolves on macrotask + 20ms)\n     *     <AsyncChildParent> (1: resolves on macrotask)\n     *       <NestedAsyncChild> (3: resolves on macrotask + 10ms)\n     */\n\n    // both top level async deps resolved, but there is another nested dep\n    // so should still be in fallback state\n    await Promise.all([deps[0], deps[1]])\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>root fallback</div>`)\n    expect(calls).toEqual([])\n\n    // root suspense all deps resolved. should show root content now\n    // with nested suspense showing fallback content\n    await deps[3]\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>nested fallback</div><div>root async</div></div>`\n    )\n    expect(calls).toEqual([0, 1, 3])\n\n    // change state for the nested component before it resolves\n    msg.value = 'nested changed'\n\n    // all deps resolved, nested suspense should resolve now\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>nested changed</div><div>root async</div></div>`\n    )\n    expect(calls).toEqual([0, 1, 3, 2])\n\n    // should update just fine after resolve\n    msg.value = 'nested changed again'\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>nested changed again</div><div>root async</div></div>`\n    )\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"switching branches","suites":["Suspense"],"updatePoint":{"line":876,"column":26},"line":876,"code":"  test('switching branches', async () => {\n    const calls: string[] = []\n    const toggle = ref(true)\n\n    const Foo = defineAsyncComponent({\n      setup() {\n        onMounted(() => {\n          calls.push('foo mounted')\n        })\n        onUnmounted(() => {\n          calls.push('foo unmounted')\n        })\n        return () => h('div', ['foo', h(FooNested)])\n      }\n    })\n\n    const FooNested = defineAsyncComponent(\n      {\n        setup() {\n          onMounted(() => {\n            calls.push('foo nested mounted')\n          })\n          onUnmounted(() => {\n            calls.push('foo nested unmounted')\n          })\n          return () => h('div', 'foo nested')\n        }\n      },\n      10\n    )\n\n    const Bar = defineAsyncComponent(\n      {\n        setup() {\n          onMounted(() => {\n            calls.push('bar mounted')\n          })\n          onUnmounted(() => {\n            calls.push('bar unmounted')\n          })\n          return () => h('div', 'bar')\n        }\n      },\n      10\n    )\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: toggle.value ? h(Foo) : h(Bar),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(calls).toEqual([`foo mounted`, `foo nested mounted`])\n    expect(serializeInner(root)).toBe(`<div>foo<div>foo nested</div></div>`)\n\n    // toggle\n    toggle.value = false\n    await nextTick()\n    expect(deps.length).toBe(3)\n    // should remain on current view\n    expect(calls).toEqual([`foo mounted`, `foo nested mounted`])\n    expect(serializeInner(root)).toBe(`<div>foo<div>foo nested</div></div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    const tempCalls = [\n      `foo mounted`,\n      `foo nested mounted`,\n      `bar mounted`,\n      `foo nested unmounted`,\n      `foo unmounted`\n    ]\n    expect(calls).toEqual(tempCalls)\n    expect(serializeInner(root)).toBe(`<div>bar</div>`)\n\n    // toggle back\n    toggle.value = true\n    await nextTick()\n    // should remain\n    expect(calls).toEqual(tempCalls)\n    expect(serializeInner(root)).toBe(`<div>bar</div>`)\n\n    await deps[3]\n    await nextTick()\n    // still pending...\n    expect(calls).toEqual(tempCalls)\n    expect(serializeInner(root)).toBe(`<div>bar</div>`)\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(calls).toEqual([\n      ...tempCalls,\n      `foo mounted`,\n      `foo nested mounted`,\n      `bar unmounted`\n    ])\n    expect(serializeInner(root)).toBe(`<div>foo<div>foo nested</div></div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"branch switch to 3rd branch before resolve","suites":["Suspense"],"updatePoint":{"line":991,"column":50},"line":991,"code":"  test('branch switch to 3rd branch before resolve', async () => {\n    const calls: string[] = []\n\n    const makeComp = (name: string, delay = 0) =>\n      defineAsyncComponent(\n        {\n          setup() {\n            onMounted(() => {\n              calls.push(`${name} mounted`)\n            })\n            onUnmounted(() => {\n              calls.push(`${name} unmounted`)\n            })\n            return () => h('div', [name])\n          }\n        },\n        delay\n      )\n\n    const One = makeComp('one')\n    const Two = makeComp('two', 10)\n    const Three = makeComp('three', 20)\n\n    const view = shallowRef(One)\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(view.value),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n\n    view.value = Two\n    await nextTick()\n    expect(deps.length).toBe(2)\n\n    // switch before two resolves\n    view.value = Three\n    await nextTick()\n    expect(deps.length).toBe(3)\n\n    // dep for two resolves\n    await deps[1]\n    await nextTick()\n    // should still be on view one\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n\n    await deps[2]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>three</div>`)\n    expect(calls).toEqual([`one mounted`, `three mounted`, `one unmounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"branch switch back before resolve","suites":["Suspense"],"updatePoint":{"line":1058,"column":41},"line":1058,"code":"  test('branch switch back before resolve', async () => {\n    const calls: string[] = []\n\n    const makeComp = (name: string, delay = 0) =>\n      defineAsyncComponent(\n        {\n          setup() {\n            onMounted(() => {\n              calls.push(`${name} mounted`)\n            })\n            onUnmounted(() => {\n              calls.push(`${name} unmounted`)\n            })\n            return () => h('div', [name])\n          }\n        },\n        delay\n      )\n\n    const One = makeComp('one')\n    const Two = makeComp('two', 10)\n\n    const view = shallowRef(One)\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: h(view.value),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n\n    view.value = Two\n    await nextTick()\n    expect(deps.length).toBe(2)\n\n    // switch back before two resolves\n    view.value = One\n    await nextTick()\n    expect(deps.length).toBe(2)\n\n    // dep for two resolves\n    await deps[1]\n    await nextTick()\n    // should still be on view one\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"branch switch timeout + fallback","suites":["Suspense"],"updatePoint":{"line":1119,"column":40},"line":1119,"code":"  test('branch switch timeout + fallback', async () => {\n    const calls: string[] = []\n\n    const makeComp = (name: string, delay = 0) =>\n      defineAsyncComponent(\n        {\n          setup() {\n            onMounted(() => {\n              calls.push(`${name} mounted`)\n            })\n            onUnmounted(() => {\n              calls.push(`${name} unmounted`)\n            })\n            return () => h('div', [name])\n          }\n        },\n        delay\n      )\n\n    const One = makeComp('one')\n    const Two = makeComp('two', 20)\n\n    const view = shallowRef(One)\n\n    const Comp = {\n      setup() {\n        return () =>\n          h(\n            Suspense,\n            {\n              timeout: 10\n            },\n            {\n              default: h(view.value),\n              fallback: h('div', 'fallback')\n            }\n          )\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([])\n\n    await deps[0]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n\n    view.value = Two\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>one</div>`)\n    expect(calls).toEqual([`one mounted`])\n\n    await new Promise(r => setTimeout(r, 10))\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>fallback</div>`)\n    expect(calls).toEqual([`one mounted`, `one unmounted`])\n\n    await deps[1]\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>two</div>`)\n    expect(calls).toEqual([`one mounted`, `one unmounted`, `two mounted`])\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not miss nested element updates when used in templates","suites":["Suspense"],"updatePoint":{"line":1188,"column":69},"line":1188,"code":"  test('should not miss nested element updates when used in templates', async () => {\n    const n = ref(1)\n    const Comp = {\n      setup() {\n        return { n }\n      },\n      template: `\n      <Suspense>\n        <div><span>{{ n }}</span></div>\n      </Suspense>\n      `\n    }\n    const root = document.createElement('div')\n    createApp(Comp).mount(root)\n    expect(root.innerHTML).toBe(`<div><span>1</span></div>`)\n\n    n.value++\n    await nextTick()\n    expect(root.innerHTML).toBe(`<div><span>2</span></div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"toggling nested async setup component inside already resolved suspense","suites":["Suspense"],"updatePoint":{"line":1210,"column":78},"line":1210,"code":"  test('toggling nested async setup component inside already resolved suspense', async () => {\n    const toggle = ref(false)\n    const Child = {\n      async setup() {\n        return () => h('div', 'child')\n      }\n    }\n    const Parent = () => h('div', ['parent', toggle.value ? h(Child) : null])\n    const Comp = {\n      setup() {\n        return () => h(Suspense, () => h(Parent))\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(`<div>parent<!----></div>`)\n\n    toggle.value = true\n    // wait for flush\n    await nextTick()\n    // wait for child async setup resolve\n    await nextTick()\n    // child should be rendered now instead of stuck in limbo\n    expect(serializeInner(root)).toBe(`<div>parent<div>child</div></div>`)\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>parent<!----></div>`)\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"warn if using async setup when not in a Suspense boundary","suites":["Suspense"],"updatePoint":{"line":1241,"column":65},"line":1241,"code":"  test('warn if using async setup when not in a Suspense boundary', () => {\n    const Child = {\n      name: 'Child',\n      async setup() {\n        return () => h('div', 'child')\n      }\n    }\n    const Parent = {\n      setup() {\n        return () => h('div', [h(Child)])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n\n    expect(\n      `A component with async setup() must be nested in a <Suspense>`\n    ).toHaveBeenWarned()\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested suspense with suspensible","suites":["Suspense"],"updatePoint":{"line":1262,"column":40},"line":1262,"code":"  test('nested suspense with suspensible', async () => {\n    const calls: string[] = []\n    let expected = ''\n\n    const InnerA = defineAsyncComponent(\n      {\n        setup: () => {\n          calls.push('innerA created')\n          onMounted(() => {\n            calls.push('innerA mounted')\n          })\n          return () => h('div', 'innerA')\n        }\n      },\n      10\n    )\n\n    const InnerB = defineAsyncComponent(\n      {\n        setup: () => {\n          calls.push('innerB created')\n          onMounted(() => {\n            calls.push('innerB mounted')\n          })\n          return () => h('div', 'innerB')\n        }\n      },\n      10\n    )\n\n    const OuterA = defineAsyncComponent(\n      {\n        setup: (_, { slots }: any) => {\n          calls.push('outerA created')\n          onMounted(() => {\n            calls.push('outerA mounted')\n          })\n          return () =>\n            h(Fragment, null, [h('div', 'outerA'), slots.default?.()])\n        }\n      },\n      5\n    )\n\n    const OuterB = defineAsyncComponent(\n      {\n        setup: (_, { slots }: any) => {\n          calls.push('outerB created')\n          onMounted(() => {\n            calls.push('outerB mounted')\n          })\n          return () =>\n            h(Fragment, null, [h('div', 'outerB'), slots.default?.()])\n        }\n      },\n      5\n    )\n\n    const outerToggle = ref(false)\n    const innerToggle = ref(false)\n\n    /**\n     *  <Suspense>\n     *    <component :is=\"outerToggle ? outerB : outerA\">\n     *      <Suspense suspensible>\n     *        <component :is=\"innerToggle ? innerB : innerA\" />\n     *      </Suspense>\n     *    </component>\n     *  </Suspense>\n     */\n    const Comp = {\n      setup() {\n        return () =>\n          h(Suspense, null, {\n            default: [\n              h(outerToggle.value ? OuterB : OuterA, null, {\n                default: () => h(Suspense, { suspensible: true },{\n                  default: h(innerToggle.value ? InnerB : InnerA)\n                })\n              })\n            ],\n            fallback: h('div', 'fallback outer')\n          })\n      }\n    }\n\n    expected = `<div>fallback outer</div>`\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(expected)\n\n    // mount outer component\n    await Promise.all(deps)\n    await nextTick()\n\n    expect(serializeInner(root)).toBe(expected)\n    expect(calls).toEqual([`outerA created`])\n\n    // mount inner component\n    await Promise.all(deps)\n    await nextTick()\n    expected = `<div>outerA</div><div>innerA</div>`\n    expect(serializeInner(root)).toBe(expected)\n\n    expect(calls).toEqual([\n      'outerA created',\n      'innerA created',\n      'outerA mounted',\n      'innerA mounted'\n    ])\n\n    // toggle outer component\n    calls.length = 0\n    deps.length = 0\n    outerToggle.value = true\n    await nextTick()\n\n    await Promise.all(deps)\n    await nextTick()\n    expect(serializeInner(root)).toBe(expected) // expect not change\n\n    await Promise.all(deps)\n    await nextTick()\n    expected = `<div>outerB</div><div>innerA</div>`\n    expect(serializeInner(root)).toBe(expected)\n    expect(calls).toContain('outerB mounted')\n    expect(calls).toContain('innerA mounted')\n\n    // toggle inner component\n    calls.length = 0\n    deps.length = 0\n    innerToggle.value = true\n    await nextTick()\n    expect(serializeInner(root)).toBe(expected) // expect not change\n\n    await Promise.all(deps)\n    await nextTick()\n    expected = `<div>outerB</div><div>innerB</div>`\n    expect(serializeInner(root)).toBe(expected)\n    expect(calls).toContain('innerB mounted')\n  })","file":"components/Suspense.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work","suites":["renderer: teleport"],"updatePoint":{"line":23,"column":19},"line":23,"code":"  test('should work', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    render(\n      h(() => [\n        h(Teleport, { to: target }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with SVG","suites":["renderer: teleport"],"updatePoint":{"line":43,"column":28},"line":43,"code":"  test('should work with SVG', async () => {\n    const root = document.createElement('div')\n    const svg = ref()\n    const circle = ref()\n\n    const Comp = defineComponent({\n      setup() {\n        return {\n          svg,\n          circle\n        }\n      },\n      template: `\n      <svg ref=\"svg\"></svg>\n      <teleport :to=\"svg\" v-if=\"svg\">\n      <circle ref=\"circle\"></circle>\n      </teleport>`\n    })\n\n    domRender(h(Comp), root)\n\n    await nextTick()\n\n    expect(root.innerHTML).toMatchInlineSnapshot(\n      `\"<svg><circle></circle></svg><!--teleport start--><!--teleport end-->\"`\n    )\n\n    expect(svg.value.namespaceURI).toBe('http://www.w3.org/2000/svg')\n    expect(circle.value.namespaceURI).toBe('http://www.w3.org/2000/svg')\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update target","suites":["renderer: teleport"],"updatePoint":{"line":74,"column":28},"line":74,"code":"  test('should update target', async () => {\n    const targetA = nodeOps.createElement('div')\n    const targetB = nodeOps.createElement('div')\n    const target = ref(targetA)\n    const root = nodeOps.createElement('div')\n\n    render(\n      h(() => [\n        h(Teleport, { to: target.value }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(targetA)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n    expect(serializeInner(targetB)).toMatchInlineSnapshot(`\"\"`)\n\n    target.value = targetB\n    await nextTick()\n\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(targetA)).toMatchInlineSnapshot(`\"\"`)\n    expect(serializeInner(targetB)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update children","suites":["renderer: teleport"],"updatePoint":{"line":108,"column":30},"line":108,"code":"  test('should update children', async () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n    const children = ref([h('div', 'teleported')])\n\n    render(\n      h(() => h(Teleport, { to: target }, children.value)),\n      root\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n\n    children.value = []\n    await nextTick()\n\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"\"`)\n\n    children.value = [createVNode(Text, null, 'teleported')]\n    await nextTick()\n\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"teleported\"`)\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should remove children when unmounted","suites":["renderer: teleport"],"updatePoint":{"line":132,"column":45},"line":132,"code":"  test('should remove children when unmounted', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    function testUnmount(props: any) {\n      render(\n        h(() => [h(Teleport, props, h('div', 'teleported')), h('div', 'root')]),\n        root\n      )\n      expect(serializeInner(target)).toMatchInlineSnapshot(\n        props.disabled ? `\"\"` : `\"<div>teleported</div>\"`\n      )\n\n      render(null, root)\n      expect(serializeInner(target)).toBe('')\n      expect(target.children.length).toBe(0)\n    }\n\n    testUnmount({ to: target, disabled: false })\n    testUnmount({ to: target, disabled: true })\n    testUnmount({ to: null, disabled: true })\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component with multi roots should be removed when unmounted","suites":["renderer: teleport"],"updatePoint":{"line":155,"column":67},"line":155,"code":"  test('component with multi roots should be removed when unmounted', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    const Comp = {\n      render() {\n        return [h('p'), h('p')]\n      }\n    }\n\n    render(\n      h(() => [h(Teleport, { to: target }, h(Comp)), h('div', 'root')]),\n      root\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"<p></p><p></p>\"`)\n\n    render(null, root)\n    expect(serializeInner(target)).toBe('')\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"multiple teleport with same target","suites":["renderer: teleport"],"updatePoint":{"line":175,"column":42},"line":175,"code":"  test('multiple teleport with same target', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    render(\n      h('div', [\n        h(Teleport, { to: target }, h('div', 'one')),\n        h(Teleport, { to: target }, 'two')\n      ]),\n      root\n    )\n\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div><!--teleport start--><!--teleport end--><!--teleport start--><!--teleport end--></div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"<div>one</div>two\"`)\n\n    // update existing content\n    render(\n      h('div', [\n        h(Teleport, { to: target }, [h('div', 'one'), h('div', 'two')]),\n        h(Teleport, { to: target }, 'three')\n      ]),\n      root\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>one</div><div>two</div>three\"`\n    )\n\n    // toggling\n    render(h('div', [null, h(Teleport, { to: target }, 'three')]), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div><!----><!--teleport start--><!--teleport end--></div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"three\"`)\n\n    // toggle back\n    render(\n      h('div', [\n        h(Teleport, { to: target }, [h('div', 'one'), h('div', 'two')]),\n        h(Teleport, { to: target }, 'three')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div><!--teleport start--><!--teleport end--><!--teleport start--><!--teleport end--></div>\"`\n    )\n    // should append\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"three<div>one</div><div>two</div>\"`\n    )\n\n    // toggle the other teleport\n    render(\n      h('div', [\n        h(Teleport, { to: target }, [h('div', 'one'), h('div', 'two')]),\n        null\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div><!--teleport start--><!--teleport end--><!----></div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>one</div><div>two</div>\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work when using template ref as target","suites":["renderer: teleport"],"updatePoint":{"line":243,"column":53},"line":243,"code":"  test('should work when using template ref as target', async () => {\n    const root = nodeOps.createElement('div')\n    const target = ref(null)\n    const disabled = ref(true)\n\n    const App = {\n      setup() {\n        return () =>\n          h(Fragment, [\n            h('div', { ref: target }),\n            h(\n              Teleport,\n              { to: target.value, disabled: disabled.value },\n              h('div', 'teleported')\n            )\n          ])\n      }\n    }\n    render(h(App), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div></div><!--teleport start--><div>teleported</div><!--teleport end-->\"`\n    )\n\n    disabled.value = false\n    await nextTick()\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div><div>teleported</div></div><!--teleport start--><!--teleport end-->\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"disabled","suites":["renderer: teleport"],"updatePoint":{"line":273,"column":16},"line":273,"code":"  test('disabled', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    const renderWithDisabled = (disabled: boolean) => {\n      return h(Fragment, [\n        h(Teleport, { to: target, disabled }, h('div', 'teleported')),\n        h('div', 'root')\n      ])\n    }\n\n    render(renderWithDisabled(false), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n\n    render(renderWithDisabled(true), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><div>teleported</div><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toBe(``)\n\n    // toggle back\n    render(renderWithDisabled(false), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moving teleport while enabled","suites":["renderer: teleport"],"updatePoint":{"line":308,"column":37},"line":308,"code":"  test('moving teleport while enabled', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    render(\n      h(Fragment, [\n        h(Teleport, { to: target }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n\n    render(\n      h(Fragment, [\n        h('div', 'root'),\n        h(Teleport, { to: target }, h('div', 'teleported'))\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div>root</div><!--teleport start--><!--teleport end-->\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n\n    render(\n      h(Fragment, [\n        h(Teleport, { to: target }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div>\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moving teleport while disabled","suites":["renderer: teleport"],"updatePoint":{"line":355,"column":38},"line":355,"code":"  test('moving teleport while disabled', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    render(\n      h(Fragment, [\n        h(Teleport, { to: target, disabled: true }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><div>teleported</div><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toBe('')\n\n    render(\n      h(Fragment, [\n        h('div', 'root'),\n        h(Teleport, { to: target, disabled: true }, h('div', 'teleported'))\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<div>root</div><!--teleport start--><div>teleported</div><!--teleport end-->\"`\n    )\n    expect(serializeInner(target)).toBe('')\n\n    render(\n      h(Fragment, [\n        h(Teleport, { to: target, disabled: true }, h('div', 'teleported')),\n        h('div', 'root')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><div>teleported</div><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toBe('')\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with block tree","suites":["renderer: teleport"],"updatePoint":{"line":396,"column":35},"line":396,"code":"  test('should work with block tree', async () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n    const disabled = ref(false)\n\n    const App = {\n      setup() {\n        return {\n          target: markRaw(target),\n          disabled\n        }\n      },\n      render: compile(`\n      <teleport :to=\"target\" :disabled=\"disabled\">\n        <div>teleported</div><span>{{ disabled }}</span><span v-if=\"disabled\"/>\n      </teleport>\n      <div>root</div>\n      `)\n    }\n    render(h(App), root)\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div><span>false</span><!--v-if-->\"`\n    )\n\n    disabled.value = true\n    await nextTick()\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><div>teleported</div><span>true</span><span></span><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toBe(``)\n\n    // toggle back\n    disabled.value = false\n    await nextTick()\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end--><div>root</div>\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(\n      `\"<div>teleported</div><span>false</span><!--v-if-->\"`\n    )\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"the dir hooks of the Teleport's children should be called correctly","suites":["renderer: teleport"],"updatePoint":{"line":442,"column":75},"line":442,"code":"  test(`the dir hooks of the Teleport's children should be called correctly`, async () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n    const toggle = ref(true)\n    const dir = {\n      mounted: vi.fn(),\n      unmounted: vi.fn()\n    }\n\n    const app = createApp({\n      setup() {\n        return () => {\n          return toggle.value\n            ? h(Teleport, { to: target }, [\n                withDirectives(h('div', ['foo']), [[dir]])\n              ])\n            : null\n        }\n      }\n    })\n    app.mount(root)\n\n    expect(serializeInner(root)).toMatchInlineSnapshot(\n      `\"<!--teleport start--><!--teleport end-->\"`\n    )\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"<div>foo</div>\"`)\n    expect(dir.mounted).toHaveBeenCalledTimes(1)\n    expect(dir.unmounted).toHaveBeenCalledTimes(0)\n\n    toggle.value = false\n    await nextTick()\n    expect(serializeInner(root)).toMatchInlineSnapshot(`\"<!---->\"`)\n    expect(serializeInner(target)).toMatchInlineSnapshot(`\"\"`)\n    expect(dir.mounted).toHaveBeenCalledTimes(1)\n    expect(dir.unmounted).toHaveBeenCalledTimes(1)\n  })","file":"components/Teleport.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"initSlots: instance.slots should be set correctly","suites":["component: slots"],"updatePoint":{"line":27,"column":57},"line":27,"code":"  test('initSlots: instance.slots should be set correctly', () => {\n    const { slots } = renderWithSlots({ _: 1 })\n    expect(slots).toMatchObject({ _: 1 })\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"initSlots: should normalize object slots (when value is null, string, array)","suites":["component: slots"],"updatePoint":{"line":32,"column":84},"line":32,"code":"  test('initSlots: should normalize object slots (when value is null, string, array)', () => {\n    const { slots } = renderWithSlots({\n      _inner: '_inner',\n      foo: null,\n      header: 'header',\n      footer: ['f1', 'f2']\n    })\n\n    expect(\n      '[Vue warn]: Non-function value encountered for slot \"header\". Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(\n      '[Vue warn]: Non-function value encountered for slot \"footer\". Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(slots).not.toHaveProperty('_inner')\n    expect(slots).not.toHaveProperty('foo')\n    expect(slots.header()).toMatchObject([normalizeVNode('header')])\n    expect(slots.footer()).toMatchObject([\n      normalizeVNode('f1'),\n      normalizeVNode('f2')\n    ])\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"initSlots: should normalize object slots (when value is function)","suites":["component: slots"],"updatePoint":{"line":57,"column":73},"line":57,"code":"  test('initSlots: should normalize object slots (when value is function)', () => {\n    let proxy: any\n    const Comp = {\n      render() {\n        proxy = getCurrentInstance()\n        return h('div')\n      }\n    }\n\n    render(\n      h(Comp, null, {\n        header: () => 'header'\n      }),\n      nodeOps.createElement('div')\n    )\n\n    expect(proxy.slots.header()).toMatchObject([normalizeVNode('header')])\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"initSlots: instance.slots should be set correctly (when vnode.shapeFlag is not SLOTS_CHILDREN)","suites":["component: slots"],"updatePoint":{"line":76,"column":102},"line":76,"code":"  test('initSlots: instance.slots should be set correctly (when vnode.shapeFlag is not SLOTS_CHILDREN)', () => {\n    const { slots } = renderWithSlots([h('span')])\n\n    expect(\n      '[Vue warn]: Non-function value encountered for default slot. Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(slots.default()).toMatchObject([normalizeVNode(h('span'))])\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"updateSlots: instance.slots should be updated correctly (when slotType is number)","suites":["component: slots"],"updatePoint":{"line":86,"column":89},"line":86,"code":"  test('updateSlots: instance.slots should be updated correctly (when slotType is number)', async () => {\n    const flag1 = ref(true)\n\n    let instance: any\n    const Child = () => {\n      instance = getCurrentInstance()\n      return 'child'\n    }\n\n    const Comp = {\n      setup() {\n        return () => [\n          h(\n            Child,\n            null,\n            createSlots({ _: 2 as any }, [\n              flag1.value\n                ? {\n                    name: 'one',\n                    fn: () => [h('span')]\n                  }\n                : {\n                    name: 'two',\n                    fn: () => [h('div')]\n                  }\n            ])\n          )\n        ]\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(instance.slots).toHaveProperty('one')\n    expect(instance.slots).not.toHaveProperty('two')\n\n    flag1.value = false\n    await nextTick()\n\n    expect(instance.slots).not.toHaveProperty('one')\n    expect(instance.slots).toHaveProperty('two')\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"updateSlots: instance.slots should be updated correctly (when slotType is null)","suites":["component: slots"],"updatePoint":{"line":128,"column":87},"line":128,"code":"  test('updateSlots: instance.slots should be updated correctly (when slotType is null)', async () => {\n    const flag1 = ref(true)\n\n    let instance: any\n    const Child = () => {\n      instance = getCurrentInstance()\n      return 'child'\n    }\n\n    const oldSlots = {\n      header: 'header'\n    }\n    const newSlots = {\n      footer: 'footer'\n    }\n\n    const Comp = {\n      setup() {\n        return () => [\n          h(Child, { n: flag1.value }, flag1.value ? oldSlots : newSlots)\n        ]\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(instance.slots).toHaveProperty('header')\n    expect(instance.slots).not.toHaveProperty('footer')\n\n    flag1.value = false\n    await nextTick()\n\n    expect(\n      '[Vue warn]: Non-function value encountered for slot \"header\". Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(\n      '[Vue warn]: Non-function value encountered for slot \"footer\". Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(instance.slots).not.toHaveProperty('header')\n    expect(instance.slots.footer()).toMatchObject([normalizeVNode('footer')])\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"updateSlots: instance.slots should be update correctly (when vnode.shapeFlag is not SLOTS_CHILDREN)","suites":["component: slots"],"updatePoint":{"line":171,"column":107},"line":171,"code":"  test('updateSlots: instance.slots should be update correctly (when vnode.shapeFlag is not SLOTS_CHILDREN)', async () => {\n    const flag1 = ref(true)\n\n    let instance: any\n    const Child = () => {\n      instance = getCurrentInstance()\n      return 'child'\n    }\n\n    const Comp = {\n      setup() {\n        return () => [\n          h(Child, { n: flag1.value }, flag1.value ? ['header'] : ['footer'])\n        ]\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n\n    expect(instance.slots.default()).toMatchObject([normalizeVNode('header')])\n\n    flag1.value = false\n    await nextTick()\n\n    expect(\n      '[Vue warn]: Non-function value encountered for default slot. Prefer function slots for better performance.'\n    ).toHaveBeenWarned()\n\n    expect(instance.slots.default()).toMatchObject([normalizeVNode('footer')])\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should respect $stable flag","suites":["component: slots"],"updatePoint":{"line":201,"column":35},"line":201,"code":"  test('should respect $stable flag', async () => {\n    const flag1 = ref(1)\n    const flag2 = ref(2)\n    const spy = vi.fn()\n\n    const Child = () => {\n      spy()\n      return 'child'\n    }\n\n    const App = {\n      setup() {\n        return () => [\n          flag1.value,\n          h(\n            Child,\n            { n: flag2.value },\n            {\n              foo: () => 'foo',\n              $stable: true\n            }\n          )\n        ]\n      }\n    }\n\n    render(h(App), nodeOps.createElement('div'))\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    // parent re-render, props didn't change, slots are stable\n    // -> child should not update\n    flag1.value++\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    // parent re-render, props changed\n    // -> child should update\n    flag2.value++\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(2)\n  })","file":"componentSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work","suites":["directives"],"updatePoint":{"line":17,"column":17},"line":17,"code":"  it('should work', async () => {\n    const count = ref(0)\n\n    function assertBindings(binding: DirectiveBinding) {\n      expect(binding.value).toBe(count.value)\n      expect(binding.arg).toBe('foo')\n      expect(binding.instance).toBe(_instance && _instance.proxy)\n      expect(binding.modifiers && binding.modifiers.ok).toBe(true)\n    }\n\n    const beforeMount = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should not be inserted yet\n      expect(el.parentNode).toBe(null)\n      expect(root.children.length).toBe(0)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const mounted = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should be inserted now\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const beforeUpdate = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      // node should not have been updated yet\n      expect(el.children[0].text).toBe(`${count.value - 1}`)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(_prevVnode)\n    }) as DirectiveHook)\n\n    const updated = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      // node should have been updated\n      expect(el.children[0].text).toBe(`${count.value}`)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(_prevVnode)\n    }) as DirectiveHook)\n\n    const beforeUnmount = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should be removed now\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const unmounted = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should have been removed\n      expect(el.parentNode).toBe(null)\n      expect(root.children.length).toBe(0)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const dir = {\n      beforeMount,\n      mounted,\n      beforeUpdate,\n      updated,\n      beforeUnmount,\n      unmounted\n    }\n\n    let _instance: ComponentInternalInstance | null = null\n    let _vnode: VNode | null = null\n    let _prevVnode: VNode | null = null\n    const Comp = {\n      setup() {\n        _instance = currentInstance\n      },\n      render() {\n        _prevVnode = _vnode\n        _vnode = withDirectives(h('div', count.value), [\n          [\n            dir,\n            // value\n            count.value,\n            // argument\n            'foo',\n            // modifiers\n            { ok: true }\n          ]\n        ])\n        return _vnode\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    expect(beforeMount).toHaveBeenCalledTimes(1)\n    expect(mounted).toHaveBeenCalledTimes(1)\n\n    count.value++\n    await nextTick()\n    expect(beforeUpdate).toHaveBeenCalledTimes(1)\n    expect(updated).toHaveBeenCalledTimes(1)\n\n    render(null, root)\n    expect(beforeUnmount).toHaveBeenCalledTimes(1)\n    expect(unmounted).toHaveBeenCalledTimes(1)\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with a function directive","suites":["directives"],"updatePoint":{"line":152,"column":43},"line":152,"code":"  it('should work with a function directive', async () => {\n    const count = ref(0)\n\n    function assertBindings(binding: DirectiveBinding) {\n      expect(binding.value).toBe(count.value)\n      expect(binding.arg).toBe('foo')\n      expect(binding.instance).toBe(_instance && _instance.proxy)\n      expect(binding.modifiers && binding.modifiers.ok).toBe(true)\n    }\n\n    const fn = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      expect(el.parentNode).toBe(root)\n\n      assertBindings(binding)\n\n      expect(vnode).toBe(_vnode)\n      expect(prevVNode).toBe(_prevVnode)\n    }) as DirectiveHook)\n\n    let _instance: ComponentInternalInstance | null = null\n    let _vnode: VNode | null = null\n    let _prevVnode: VNode | null = null\n    const Comp = {\n      setup() {\n        _instance = currentInstance\n      },\n      render() {\n        _prevVnode = _vnode\n        _vnode = withDirectives(h('div', count.value), [\n          [\n            fn,\n            // value\n            count.value,\n            // argument\n            'foo',\n            // modifiers\n            { ok: true }\n          ]\n        ])\n        return _vnode\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    expect(fn).toHaveBeenCalledTimes(1)\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledTimes(2)\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work on component vnode","suites":["directives"],"updatePoint":{"line":206,"column":36},"line":206,"code":"  it('should work on component vnode', async () => {\n    const count = ref(0)\n\n    function assertBindings(binding: DirectiveBinding) {\n      expect(binding.value).toBe(count.value)\n      expect(binding.arg).toBe('foo')\n      expect(binding.instance).toBe(_instance && _instance.proxy)\n      expect(binding.modifiers && binding.modifiers.ok).toBe(true)\n    }\n\n    const beforeMount = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should not be inserted yet\n      expect(el.parentNode).toBe(null)\n      expect(root.children.length).toBe(0)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const mounted = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should be inserted now\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const beforeUpdate = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      // node should not have been updated yet\n      expect(el.children[0].text).toBe(`${count.value - 1}`)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode!.type).toBe(_prevVnode!.type)\n    }) as DirectiveHook)\n\n    const updated = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      // node should have been updated\n      expect(el.children[0].text).toBe(`${count.value}`)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode!.type).toBe(_prevVnode!.type)\n    }) as DirectiveHook)\n\n    const beforeUnmount = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should be removed now\n      expect(el.parentNode).toBe(root)\n      expect(root.children[0]).toBe(el)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const unmounted = vi.fn(((el, binding, vnode, prevVNode) => {\n      expect(el.tag).toBe('div')\n      // should have been removed\n      expect(el.parentNode).toBe(null)\n      expect(root.children.length).toBe(0)\n\n      assertBindings(binding)\n\n      expect(vnode.type).toBe(_vnode!.type)\n      expect(prevVNode).toBe(null)\n    }) as DirectiveHook)\n\n    const dir = {\n      beforeMount,\n      mounted,\n      beforeUpdate,\n      updated,\n      beforeUnmount,\n      unmounted\n    }\n\n    let _instance: ComponentInternalInstance | null = null\n    let _vnode: VNode | null = null\n    let _prevVnode: VNode | null = null\n\n    const Child = (props: { count: number }) => {\n      _prevVnode = _vnode\n      _vnode = h('div', props.count)\n      return _vnode\n    }\n\n    const Comp = {\n      setup() {\n        _instance = currentInstance\n      },\n      render() {\n        return withDirectives(h(Child, { count: count.value }), [\n          [\n            dir,\n            // value\n            count.value,\n            // argument\n            'foo',\n            // modifiers\n            { ok: true }\n          ]\n        ])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    expect(beforeMount).toHaveBeenCalledTimes(1)\n    expect(mounted).toHaveBeenCalledTimes(1)\n\n    count.value++\n    await nextTick()\n    expect(beforeUpdate).toHaveBeenCalledTimes(1)\n    expect(updated).toHaveBeenCalledTimes(1)\n\n    render(null, root)\n    expect(beforeUnmount).toHaveBeenCalledTimes(1)\n    expect(unmounted).toHaveBeenCalledTimes(1)\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"directive merging on component root","suites":["directives"],"updatePoint":{"line":347,"column":41},"line":347,"code":"  it('directive merging on component root', () => {\n    const d1 = {\n      mounted: vi.fn()\n    }\n    const d2 = {\n      mounted: vi.fn()\n    }\n    const Comp = {\n      render() {\n        return withDirectives(h('div'), [[d2]])\n      }\n    }\n\n    const App = {\n      name: 'App',\n      render() {\n        return h('div', [withDirectives(h(Comp), [[d1]])])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(d1.mounted).toHaveBeenCalled()\n    expect(d2.mounted).toHaveBeenCalled()\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should disable tracking inside directive lifecycle hooks","suites":["directives"],"updatePoint":{"line":373,"column":64},"line":373,"code":"  test('should disable tracking inside directive lifecycle hooks', async () => {\n    const count = ref(0)\n    const text = ref('')\n    const beforeUpdate = vi.fn(() => count.value++)\n\n    const App = {\n      render() {\n        return withDirectives(h('p', text.value), [\n          [\n            {\n              beforeUpdate\n            }\n          ]\n        ])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(beforeUpdate).toHaveBeenCalledTimes(0)\n    expect(count.value).toBe(0)\n\n    text.value = 'foo'\n    await nextTick()\n    expect(beforeUpdate).toHaveBeenCalledTimes(1)\n    expect(count.value).toBe(1)\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should receive exposeProxy for closed instances","suites":["directives"],"updatePoint":{"line":401,"column":55},"line":401,"code":"  test('should receive exposeProxy for closed instances', async () => {\n    let res: string\n    const App = defineComponent({\n      setup(_, { expose }) {\n        expose({\n          msg: 'Test'\n        })\n\n        return () =>\n          withDirectives(h('p', 'Lore Ipsum'), [\n            [\n              {\n                mounted(el, { instance }) {\n                  res = (instance as any).msg as string\n                }\n              }\n            ]\n          ])\n      }\n    })\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(res!).toBe('Test')\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not throw with unknown directive","suites":["directives"],"updatePoint":{"line":426,"column":47},"line":426,"code":"  test('should not throw with unknown directive', async () => {\n    const d1 = {\n      mounted: vi.fn()\n    }\n    const App = {\n      name: 'App',\n      render() {\n        // simulates the code generated on an unknown directive\n        return withDirectives(h('div'), [[undefined], [d1]])\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(d1.mounted).toHaveBeenCalled()\n  })","file":"directives.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"propagation","suites":["error handling"],"updatePoint":{"line":17,"column":19},"line":17,"code":"  test('propagation', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info, 'root')\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info, 'child')\n        })\n        return () => h(GrandChild)\n      }\n    }\n\n    const GrandChild = {\n      setup() {\n        onMounted(() => {\n          throw err\n        })\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledTimes(2)\n    expect(fn).toHaveBeenCalledWith(err, 'mounted hook', 'root')\n    expect(fn).toHaveBeenCalledWith(err, 'mounted hook', 'child')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"propagation stoppage","suites":["error handling"],"updatePoint":{"line":55,"column":28},"line":55,"code":"  test('propagation stoppage', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info, 'root')\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info, 'child')\n          return false\n        })\n        return () => h(GrandChild)\n      }\n    }\n\n    const GrandChild = {\n      setup() {\n        onMounted(() => {\n          throw err\n        })\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(fn).toHaveBeenCalledWith(err, 'mounted hook', 'child')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"async error handling","suites":["error handling"],"updatePoint":{"line":93,"column":28},"line":93,"code":"  test('async error handling', async () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onMounted(async () => {\n          throw err\n        })\n      },\n      render() {}\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).not.toHaveBeenCalled()\n    await new Promise(r => setTimeout(r))\n    expect(fn).toHaveBeenCalledWith(err, 'mounted hook')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error thrown in onErrorCaptured","suites":["error handling"],"updatePoint":{"line":122,"column":39},"line":122,"code":"  test('error thrown in onErrorCaptured', () => {\n    const err = new Error('foo')\n    const err2 = new Error('bar')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        onErrorCaptured(() => {\n          throw err2\n        })\n        return () => h(GrandChild)\n      }\n    }\n\n    const GrandChild = {\n      setup() {\n        onMounted(() => {\n          throw err\n        })\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledTimes(2)\n    expect(fn).toHaveBeenCalledWith(err, 'mounted hook')\n    expect(fn).toHaveBeenCalledWith(err2, 'errorCaptured hook')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"setup function","suites":["error handling"],"updatePoint":{"line":161,"column":22},"line":161,"code":"  test('setup function', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        throw err\n      },\n      render() {}\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'setup function')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in created/beforeCreate hook","suites":["error handling"],"updatePoint":{"line":188,"column":36},"line":188,"code":"  test('in created/beforeCreate hook', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => [h(Child1), h(Child2)]\n      }\n    }\n\n    const Child1 = {\n      created() {\n        throw err\n      },\n      render() {}\n    }\n\n    const Child2 = {\n      beforeCreate() {\n        throw err\n      },\n      render() {}\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'created hook')\n    expect(fn).toHaveBeenCalledWith(err, 'beforeCreate hook')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in render function","suites":["error handling"],"updatePoint":{"line":221,"column":26},"line":221,"code":"  test('in render function', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        return () => {\n          throw err\n        }\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'render function')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in function ref","suites":["error handling"],"updatePoint":{"line":247,"column":23},"line":247,"code":"  test('in function ref', () => {\n    const err = new Error('foo')\n    const ref = () => {\n      throw err\n    }\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = defineComponent(() => () => h('div', { ref }))\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'ref function')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in effect","suites":["error handling"],"updatePoint":{"line":270,"column":17},"line":270,"code":"  test('in effect', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        watchEffect(() => {\n          throw err\n        })\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'watcher callback')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in watch getter","suites":["error handling"],"updatePoint":{"line":297,"column":23},"line":297,"code":"  test('in watch getter', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        watch(\n          () => {\n            throw err\n          },\n          () => {}\n        )\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'watcher getter')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in watch callback","suites":["error handling"],"updatePoint":{"line":327,"column":25},"line":327,"code":"  test('in watch callback', async () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const count = ref(0)\n    const Child = {\n      setup() {\n        watch(\n          () => count.value,\n          () => {\n            throw err\n          }\n        )\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledWith(err, 'watcher callback')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in effect cleanup","suites":["error handling"],"updatePoint":{"line":361,"column":25},"line":361,"code":"  test('in effect cleanup', async () => {\n    const err = new Error('foo')\n    const count = ref(0)\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        watchEffect(onCleanup => {\n          count.value\n          onCleanup(() => {\n            throw err\n          })\n        })\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    count.value++\n    await nextTick()\n    expect(fn).toHaveBeenCalledWith(err, 'watcher cleanup function')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in component event handler via emit","suites":["error handling"],"updatePoint":{"line":395,"column":43},"line":395,"code":"  test('in component event handler via emit', () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () =>\n          h(Child, {\n            onFoo: () => {\n              throw err\n            }\n          })\n      }\n    }\n\n    const Child = {\n      setup(props: any, { emit }: any) {\n        emit('foo')\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(fn).toHaveBeenCalledWith(err, 'component event handler')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in component event handler via emit (async)","suites":["error handling"],"updatePoint":{"line":425,"column":51},"line":425,"code":"  test('in component event handler via emit (async)', async () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () =>\n          h(Child, {\n            async onFoo() {\n              throw err\n            }\n          })\n      }\n    }\n\n    const Child = {\n      props: ['onFoo'],\n      setup(props: any, { emit }: any) {\n        emit('foo')\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n    await nextTick()\n    expect(fn).toHaveBeenCalledWith(err, 'component event handler')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"in component event handler via emit (async + array)","suites":["error handling"],"updatePoint":{"line":457,"column":59},"line":457,"code":"  test('in component event handler via emit (async + array)', async () => {\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const res: Promise<any>[] = []\n    const createAsyncHandler = (p: Promise<any>) => () => {\n      res.push(p)\n      return p\n    }\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n          return false\n        })\n        return () =>\n          h(Child, {\n            onFoo: [\n              createAsyncHandler(Promise.reject(err)),\n              createAsyncHandler(Promise.resolve(1))\n            ]\n          })\n      }\n    }\n\n    const Child = {\n      setup(props: any, { emit }: any) {\n        emit('foo')\n        return () => null\n      }\n    }\n\n    render(h(Comp), nodeOps.createElement('div'))\n\n    try {\n      await Promise.all(res)\n    } catch (e: any) {\n      expect(e).toBe(err)\n    }\n    expect(fn).toHaveBeenCalledWith(err, 'component event handler')\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn unhandled","suites":["error handling"],"updatePoint":{"line":500,"column":27},"line":500,"code":"  it('should warn unhandled', () => {\n    const groupCollapsed = vi.spyOn(console, 'groupCollapsed')\n    groupCollapsed.mockImplementation(() => {})\n    const log = vi.spyOn(console, 'log')\n    log.mockImplementation(() => {})\n\n    const err = new Error('foo')\n    const fn = vi.fn()\n\n    const Comp = {\n      setup() {\n        onErrorCaptured((err, instance, info) => {\n          fn(err, info)\n        })\n        return () => h(Child)\n      }\n    }\n\n    const Child = {\n      setup() {\n        throw err\n      },\n      render() {}\n    }\n\n    let caughtError\n    try {\n      render(h(Comp), nodeOps.createElement('div'))\n    } catch (caught) {\n      caughtError = caught\n    }\n    expect(fn).toHaveBeenCalledWith(err, 'setup function')\n    expect(\n      `Unhandled error during execution of setup function`\n    ).toHaveBeenWarned()\n    expect(caughtError).toBe(err)\n\n    groupCollapsed.mockRestore()\n    log.mockRestore()\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handle error in watch & watchEffect","suites":["error handling"],"updatePoint":{"line":542,"column":43},"line":542,"code":"  test('handle error in watch & watchEffect', async () => {\n    const error1 = new Error('error1')\n    const error2 = new Error('error2')\n    const error3 = new Error('error3')\n    const error4 = new Error('error4')\n    const handler = vi.fn()\n\n    const app = createApp({\n      setup() {\n        const count = ref(1)\n        watch(\n          count,\n          () => {\n            throw error1\n          },\n          { immediate: true }\n        )\n        watch(\n          count,\n          async () => {\n            throw error2\n          },\n          { immediate: true }\n        )\n        watchEffect(() => {\n          throw error3\n        })\n        watchEffect(async () => {\n          throw error4\n        })\n      },\n      render() {}\n    })\n\n    app.config.errorHandler = handler\n    app.mount(nodeOps.createElement('div'))\n\n    await nextTick()\n    expect(handler).toHaveBeenCalledWith(error1, {}, 'watcher callback')\n    expect(handler).toHaveBeenCalledWith(error2, {}, 'watcher callback')\n    expect(handler).toHaveBeenCalledWith(error3, {}, 'watcher callback')\n    expect(handler).toHaveBeenCalledWith(error4, {}, 'watcher callback')\n    expect(handler).toHaveBeenCalledTimes(4)\n  })","file":"errorHandling.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"type only","suites":["renderer: h"],"updatePoint":{"line":8,"column":17},"line":8,"code":"  test('type only', () => {\n    expect(h('div')).toMatchObject(createVNode('div'))\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"type + props","suites":["renderer: h"],"updatePoint":{"line":12,"column":20},"line":12,"code":"  test('type + props', () => {\n    expect(h('div', { id: 'foo' })).toMatchObject(\n      createVNode('div', { id: 'foo' })\n    )\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"type + omit props","suites":["renderer: h"],"updatePoint":{"line":18,"column":25},"line":18,"code":"  test('type + omit props', () => {\n    // array\n    expect(h('div', ['foo'])).toMatchObject(createVNode('div', null, ['foo']))\n    // default slot\n    const Component = { template: '<br />' }\n    const slot = () => {}\n    expect(h(Component, slot)).toMatchObject(createVNode(Component, null, slot))\n    // single vnode\n    const vnode = h('div')\n    expect(h('div', vnode)).toMatchObject(createVNode('div', null, [vnode]))\n    // text\n    expect(h('div', 'foo')).toMatchObject(createVNode('div', null, 'foo'))\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"type + props + children","suites":["renderer: h"],"updatePoint":{"line":32,"column":31},"line":32,"code":"  test('type + props + children', () => {\n    // array\n    expect(h('div', {}, ['foo'])).toMatchObject(createVNode('div', {}, ['foo']))\n    // slots\n    const slots = {} as RawSlots\n    expect(h('div', {}, slots)).toMatchObject(createVNode('div', {}, slots))\n    const Component = { template: '<br />' }\n    expect(h(Component, {}, slots)).toMatchObject(\n      createVNode(Component, {}, slots)\n    )\n    // default slot\n    const slot = () => {}\n    expect(h(Component, {}, slot)).toMatchObject(\n      createVNode(Component, {}, slot)\n    )\n    // single vnode\n    const vnode = h('div')\n    expect(h('div', {}, vnode)).toMatchObject(createVNode('div', {}, [vnode]))\n    // text\n    expect(h('div', {}, 'foo')).toMatchObject(createVNode('div', {}, 'foo'))\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"named slots with null props","suites":["renderer: h"],"updatePoint":{"line":54,"column":35},"line":54,"code":"  test('named slots with null props', () => {\n    const Component = { template: '<br />' }\n    const slot = () => {}\n    expect(\n      h(Component, null, {\n        foo: slot\n      })\n    ).toMatchObject(\n      createVNode(Component, null, {\n        foo: slot\n      })\n    )\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"support variadic children","suites":["renderer: h"],"updatePoint":{"line":71,"column":33},"line":71,"code":"  test('support variadic children', () => {\n    // @ts-ignore\n    const vnode = h('div', null, h('span'), h('span'))\n    expect(vnode.children).toMatchObject([\n      {\n        type: 'span'\n      },\n      {\n        type: 'span'\n      }\n    ])\n  })","file":"h.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should return a slot","suites":["createSlot"],"updatePoint":{"line":12,"column":26},"line":12,"code":"  it('should return a slot', () => {\n    const dynamicSlot = [{ name: 'descriptor', fn: slot }]\n\n    const actual = createSlots(record, dynamicSlot)\n\n    expect(actual).toEqual({ descriptor: slot })\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should attach key","suites":["createSlot"],"updatePoint":{"line":20,"column":23},"line":20,"code":"  it('should attach key', () => {\n    const dynamicSlot = [{ name: 'descriptor', fn: slot, key: '1' }]\n\n    const actual = createSlots(record, dynamicSlot)\n    const ret = actual.descriptor()\n    // @ts-ignore\n    expect(ret.key).toBe('1')\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should check nullability","suites":["createSlot"],"updatePoint":{"line":29,"column":30},"line":29,"code":"  it('should check nullability', () => {\n    const slot = (() => {}) as Slot\n    const dynamicSlot = [{ name: 'descriptor', fn: slot, key: '1' }]\n\n    const actual = createSlots(record, dynamicSlot)\n    expect(actual).toHaveProperty('descriptor')\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should add all slots to the record","suites":["createSlot"],"updatePoint":{"line":37,"column":40},"line":37,"code":"  it('should add all slots to the record', () => {\n    const dynamicSlot = [\n      { name: 'descriptor', fn: slot },\n      { name: 'descriptor2', fn: slot }\n    ]\n\n    const actual = createSlots(record, dynamicSlot)\n\n    expect(actual).toEqual({ descriptor: slot, descriptor2: slot })\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should add slot to the record when given slot is an array","suites":["createSlot"],"updatePoint":{"line":48,"column":63},"line":48,"code":"  it('should add slot to the record when given slot is an array', () => {\n    const dynamicSlot = [\n      { name: 'descriptor', fn: slot },\n      [{ name: 'descriptor2', fn: slot }]\n    ]\n\n    const actual = createSlots(record, dynamicSlot)\n\n    expect(actual).toEqual({ descriptor: slot, descriptor2: slot })\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should add each slot to the record when given slot is an array","suites":["createSlot"],"updatePoint":{"line":59,"column":68},"line":59,"code":"  it('should add each slot to the record when given slot is an array', () => {\n    const dynamicSlot = [\n      { name: 'descriptor', fn: slot },\n      [\n        { name: 'descriptor2', fn: slot },\n        { name: 'descriptor3', fn: slot }\n      ]\n    ]\n\n    const actual = createSlots(record, dynamicSlot)\n\n    expect(actual).toEqual({\n      descriptor: slot,\n      descriptor2: slot,\n      descriptor3: slot\n    })\n  })","file":"helpers/createSlots.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render items in an array","suites":["renderList"],"updatePoint":{"line":4,"column":37},"line":4,"code":"  it('should render items in an array', () => {\n    expect(\n      renderList(['1', '2', '3'], (item, index) => `node ${index}: ${item}`)\n    ).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render characters of a string","suites":["renderList"],"updatePoint":{"line":10,"column":42},"line":10,"code":"  it('should render characters of a string', () => {\n    expect(\n      renderList('123', (item, index) => `node ${index}: ${item}`)\n    ).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render integers 1 through N when given a number N","suites":["renderList"],"updatePoint":{"line":16,"column":62},"line":16,"code":"  it('should render integers 1 through N when given a number N', () => {\n    expect(renderList(3, (item, index) => `node ${index}: ${item}`)).toEqual([\n      'node 0: 1',\n      'node 1: 2',\n      'node 2: 3'\n    ])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn when given a non-integer N","suites":["renderList"],"updatePoint":{"line":24,"column":44},"line":24,"code":"  it('should warn when given a non-integer N', () => {\n    try {\n      renderList(3.1, () => {})\n    } catch (e) {}\n    expect(\n      `The v-for range expect an integer value but got 3.1.`\n    ).toHaveBeenWarned()\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render properties in an object","suites":["renderList"],"updatePoint":{"line":33,"column":43},"line":33,"code":"  it('should render properties in an object', () => {\n    expect(\n      renderList(\n        { a: 1, b: 2, c: 3 },\n        (item, key, index) => `node ${index}/${key}: ${item}`\n      )\n    ).toEqual(['node 0/a: 1', 'node 1/b: 2', 'node 2/c: 3'])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render an item for entry in an iterable","suites":["renderList"],"updatePoint":{"line":42,"column":52},"line":42,"code":"  it('should render an item for entry in an iterable', () => {\n    const iterable = function* () {\n      yield 1\n      yield 2\n      yield 3\n    }\n\n    expect(\n      renderList(iterable(), (item, index) => `node ${index}: ${item}`)\n    ).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should return empty array when source is undefined","suites":["renderList"],"updatePoint":{"line":54,"column":56},"line":54,"code":"  it('should return empty array when source is undefined', () => {\n    expect(\n      renderList(undefined, (item, index) => `node ${index}: ${item}`)\n    ).toEqual([])\n  })","file":"helpers/renderList.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render slot","suites":["renderSlot"],"updatePoint":{"line":24,"column":24},"line":24,"code":"  it('should render slot', () => {\n    let child\n    const vnode = renderSlot(\n      { default: () => [(child = h('child'))] },\n      'default'\n    )\n    expect(vnode.children).toEqual([child])\n  })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should render slot fallback","suites":["renderSlot"],"updatePoint":{"line":33,"column":33},"line":33,"code":"  it('should render slot fallback', () => {\n    const vnode = renderSlot({}, 'default', {}, () => ['fallback'])\n    expect(vnode.children).toEqual(['fallback'])\n  })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn render ssr slot","suites":["renderSlot"],"updatePoint":{"line":38,"column":33},"line":38,"code":"  it('should warn render ssr slot', () => {\n    renderSlot({ default: (_a, _b, _c) => [h('child')] }, 'default')\n    expect('SSR-optimized slot function detected').toHaveBeenWarned()\n  })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should force enable tracking","suites":["renderSlot"],"updatePoint":{"line":44,"column":34},"line":44,"code":"  it('should force enable tracking', () => {\n    const slot = withCtx(\n      () => {\n        return [createVNode('div', null, 'foo', PatchFlags.TEXT)]\n      },\n      // mock instance\n      { type: {}, appContext: {} } as any\n    ) as Slot\n\n    // manual invocation should not track\n    const manual = (openBlock(), createBlock(Fragment, null, slot()))\n    expect(manual.dynamicChildren!.length).toBe(0)\n\n    // renderSlot should track\n    const templateRendered = renderSlot({ default: slot }, 'default')\n    expect(templateRendered.dynamicChildren!.length).toBe(1)\n  })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should ignore slots that are all comments","suites":["renderSlot","only render valid slot content"],"updatePoint":{"line":64,"column":49},"line":64,"code":"    it('should ignore slots that are all comments', () => {\n      let fallback\n      const vnode = renderSlot(\n        { default: () => [createCommentVNode('foo')] },\n        'default',\n        undefined,\n        () => [(fallback = h('fallback'))]\n      )\n      expect(vnode.children).toEqual([fallback])\n      expect(vnode.patchFlag).toBe(PatchFlags.BAIL)\n    })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should ignore invalid slot content generated by nested slot","suites":["renderSlot","only render valid slot content"],"updatePoint":{"line":76,"column":67},"line":76,"code":"    it('should ignore invalid slot content generated by nested slot', () => {\n      let fallback\n      const vnode = renderSlot(\n        { default: () => [renderSlot({}, 'foo')] },\n        'default',\n        undefined,\n        () => [(fallback = h('fallback'))]\n      )\n      expect(vnode.children).toEqual([fallback])\n      expect(vnode.patchFlag).toBe(PatchFlags.BAIL)\n    })","file":"helpers/renderSlot.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work","suites":["resolveAssets"],"updatePoint":{"line":17,"column":19},"line":17,"code":"  test('should work', () => {\n    const FooBar = () => null\n    const BarBaz = { mounted: () => null }\n\n    let component1: Component | string\n    let component2: Component | string\n    let component3: Component | string\n    let component4: Component | string\n    let directive1: Directive\n    let directive2: Directive\n    let directive3: Directive\n    let directive4: Directive\n\n    const Root = {\n      components: {\n        FooBar: FooBar\n      },\n      directives: {\n        BarBaz: BarBaz\n      },\n      setup() {\n        return () => {\n          component1 = resolveComponent('FooBar')!\n          directive1 = resolveDirective('BarBaz')!\n          // camelize\n          component2 = resolveComponent('Foo-bar')!\n          directive2 = resolveDirective('Bar-baz')!\n          // capitalize\n          component3 = resolveComponent('fooBar')!\n          directive3 = resolveDirective('barBaz')!\n          // camelize and capitalize\n          component4 = resolveComponent('foo-bar')!\n          directive4 = resolveDirective('bar-baz')!\n        }\n      }\n    }\n\n    const app = createApp(Root)\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(component1!).toBe(FooBar)\n    expect(component2!).toBe(FooBar)\n    expect(component3!).toBe(FooBar)\n    expect(component4!).toBe(FooBar)\n\n    expect(directive1!).toBe(BarBaz)\n    expect(directive2!).toBe(BarBaz)\n    expect(directive3!).toBe(BarBaz)\n    expect(directive4!).toBe(BarBaz)\n  })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"maybeSelfReference","suites":["resolveAssets"],"updatePoint":{"line":68,"column":26},"line":68,"code":"  test('maybeSelfReference', async () => {\n    let component1: Component | string\n    let component2: Component | string\n    let component3: Component | string\n\n    const Foo = () => null\n\n    const Root = {\n      name: 'Root',\n      components: {\n        Foo,\n        Root: Foo\n      },\n      setup() {\n        return () => {\n          component1 = resolveComponent('Root', true)\n          component2 = resolveComponent('Foo', true)\n          component3 = resolveComponent('Bar', true)\n        }\n      }\n    }\n\n    const app = createApp(Root)\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n\n    expect(component1!).toMatchObject(Root) // explicit self name reference\n    expect(component2!).toBe(Foo) // successful resolve take higher priority\n    expect(component3!).toMatchObject(Root) // fallback when resolve fails\n  })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"used outside render() or setup()","suites":["resolveAssets","warning"],"updatePoint":{"line":100,"column":42},"line":100,"code":"    test('used outside render() or setup()', () => {\n      resolveComponent('foo')\n      expect(\n        'resolveComponent can only be used in render() or setup().'\n      ).toHaveBeenWarned()\n\n      resolveDirective('foo')\n      expect(\n        'resolveDirective can only be used in render() or setup().'\n      ).toHaveBeenWarned()\n    })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"not exist","suites":["resolveAssets","warning"],"updatePoint":{"line":112,"column":19},"line":112,"code":"    test('not exist', () => {\n      const Root = {\n        setup() {\n          resolveComponent('foo')\n          resolveDirective('bar')\n          return () => null\n        }\n      }\n\n      const app = createApp(Root)\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n      expect('Failed to resolve component: foo').toHaveBeenWarned()\n      expect('Failed to resolve directive: bar').toHaveBeenWarned()\n    })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"resolve dynamic component","suites":["resolveAssets","warning"],"updatePoint":{"line":128,"column":35},"line":128,"code":"    test('resolve dynamic component', () => {\n      const dynamicComponents = {\n        foo: () => 'foo',\n        bar: () => 'bar',\n        baz: { render: () => 'baz' }\n      }\n      let foo, bar, baz // dynamic components\n      let dynamicVNode: VNode\n\n      const Child = {\n        render(this: any) {\n          return this.$slots.default()\n        }\n      }\n\n      const Root = {\n        components: { foo: dynamicComponents.foo },\n        setup() {\n          return () => {\n            foo = resolveDynamicComponent('foo') // <component is=\"foo\"/>\n            bar = resolveDynamicComponent(dynamicComponents.bar) // <component :is=\"bar\"/>, function\n            dynamicVNode = createVNode(resolveDynamicComponent(null)) // <component :is=\"null\"/>\n            return h(Child, () => {\n              // check inside child slots\n              baz = resolveDynamicComponent(dynamicComponents.baz) // <component :is=\"baz\"/>, object\n            })\n          }\n        }\n      }\n\n      const app = createApp(Root)\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n      expect(foo).toBe(dynamicComponents.foo)\n      expect(bar).toBe(dynamicComponents.bar)\n      expect(baz).toBe(dynamicComponents.baz)\n      // should allow explicit falsy type to remove the component\n      expect(dynamicVNode!.type).toBe(Comment)\n    })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"resolve dynamic component should fallback to plain element without warning","suites":["resolveAssets","warning"],"updatePoint":{"line":168,"column":84},"line":168,"code":"    test('resolve dynamic component should fallback to plain element without warning', () => {\n      const Root = {\n        setup() {\n          return () => {\n            return createVNode(resolveDynamicComponent('div') as string, null, {\n              default: () => 'hello'\n            })\n          }\n        }\n      }\n\n      const app = createApp(Root)\n      const root = nodeOps.createElement('div')\n      app.mount(root)\n      expect(serializeInner(root)).toBe('<div>hello</div>')\n    })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"resolving from mixins & extends","suites":["resolveAssets","warning"],"updatePoint":{"line":186,"column":39},"line":186,"code":"  test('resolving from mixins & extends', () => {\n    const FooBar = () => null\n    const BarBaz = { mounted: () => null }\n\n    let component1: Component | string\n    let component2: Component | string\n    let component3: Component | string\n    let component4: Component | string\n    let directive1: Directive\n    let directive2: Directive\n    let directive3: Directive\n    let directive4: Directive\n\n    const Base = {\n      components: {\n        FooBar: FooBar\n      }\n    }\n    const Mixin = {\n      directives: {\n        BarBaz: BarBaz\n      }\n    }\n\n    const Root = {\n      extends: Base,\n      mixins: [Mixin],\n      setup() {\n        return () => {\n          component1 = resolveComponent('FooBar')!\n          directive1 = resolveDirective('BarBaz')!\n          // camelize\n          component2 = resolveComponent('Foo-bar')!\n          directive2 = resolveDirective('Bar-baz')!\n          // capitalize\n          component3 = resolveComponent('fooBar')!\n          directive3 = resolveDirective('barBaz')!\n          // camelize and capitalize\n          component4 = resolveComponent('foo-bar')!\n          directive4 = resolveDirective('bar-baz')!\n        }\n      }\n    }\n\n    const app = createApp(Root)\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(component1!).toBe(FooBar)\n    expect(component2!).toBe(FooBar)\n    expect(component3!).toBe(FooBar)\n    expect(component4!).toBe(FooBar)\n\n    expect(directive1!).toBe(BarBaz)\n    expect(directive2!).toBe(BarBaz)\n    expect(directive3!).toBe(BarBaz)\n    expect(directive4!).toBe(BarBaz)\n  })","file":"helpers/resolveAssets.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not accept non-objects","suites":["toHandlers"],"updatePoint":{"line":4,"column":35},"line":4,"code":"  it('should not accept non-objects', () => {\n    toHandlers(null as any)\n    toHandlers(undefined as any)\n\n    expect(\n      'v-on with no argument expects an object value.'\n    ).toHaveBeenWarnedTimes(2)\n  })","file":"helpers/toHandlers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should properly change object keys","suites":["toHandlers"],"updatePoint":{"line":13,"column":40},"line":13,"code":"  it('should properly change object keys', () => {\n    const input = () => {}\n    const change = () => {}\n\n    expect(toHandlers({ input, change })).toStrictEqual({\n      onInput: input,\n      onChange: change\n    })\n  })","file":"helpers/toHandlers.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on with external array","suites":["v-memo"],"updatePoint":{"line":17,"column":30},"line":17,"code":"  test('on with external array', async () => {\n    const [el, vm] = mount({\n      template: `<div v-memo=\"arr\">{{ arr[0] }} {{ arr[1] }} {{arr[2] ?? '_' }} ({{c}})</div>{{c}}`,\n      data: () => ({ arr: [0, 0], c: 0 })\n    })\n    expect(el.innerHTML).toBe(`<div>0 0 _ (0)</div>0`)\n\n    let [x, y, z] = [0, 1, 2]\n\n    // change at index x - should update\n    vm.arr[x]++\n    vm.c++\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0 _ (1)</div>1`)\n\n    // change at index y - should update\n    vm.arr[y]++\n    vm.c++\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 1 _ (2)</div>2`)\n\n    // noop change - should NOT update\n    vm.arr[x] = vm.arr[0]\n    vm.arr[y] = vm.arr[1]\n    vm.c++\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 1 _ (2)</div>3`)\n\n    // add item  3rd item - should update\n    vm.arr[z] = 0\n    vm.c++\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 1 0 (4)</div>4`)\n\n    // remove 3rd item - should update\n    vm.arr = vm.arr.slice(0, vm.arr.length - 1)\n    vm.c++\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 1 _ (5)</div>5`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on normal element","suites":["v-memo"],"updatePoint":{"line":58,"column":25},"line":58,"code":"  test('on normal element', async () => {\n    const [el, vm] = mount({\n      template: `<div v-memo=\"[x]\">{{ x }} {{ y }}</div>`,\n      data: () => ({ x: 0, y: 0 })\n    })\n    expect(el.innerHTML).toBe(`<div>0 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.y++\n    // should not update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>2 1</div>`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on component","suites":["v-memo"],"updatePoint":{"line":81,"column":20},"line":81,"code":"  test('on component', async () => {\n    const [el, vm] = mount({\n      template: `<Comp v-memo=\"[x]\" :x=\"x\" :y=\"y\"></Comp>`,\n      data: () => ({ x: 0, y: 0 }),\n      components: {\n        Comp: {\n          props: ['x', 'y'],\n          template: `<div>{{x}} {{y}}</div>`\n        }\n      }\n    })\n    expect(el.innerHTML).toBe(`<div>0 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.y++\n    // should not update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>2 1</div>`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on v-if","suites":["v-memo"],"updatePoint":{"line":110,"column":15},"line":110,"code":"  test('on v-if', async () => {\n    const [el, vm] = mount({\n      template: `<div v-if=\"ok\" v-memo=\"[x]\">{{ x }} {{ y }}</div>\n        <div v-else v-memo=\"[y]\">{{ y }} {{ x }}</div>`,\n      data: () => ({ ok: true, x: 0, y: 0 })\n    })\n    expect(el.innerHTML).toBe(`<div>0 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.y++\n    // should not update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 0</div>`)\n\n    vm.x++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>2 1</div>`)\n\n    vm.ok = false\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>1 2</div>`)\n\n    vm.y++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>2 2</div>`)\n\n    vm.x++\n    // should not update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>2 2</div>`)\n\n    vm.y++\n    // should update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>3 3</div>`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on v-for","suites":["v-memo"],"updatePoint":{"line":153,"column":16},"line":153,"code":"  test('on v-for', async () => {\n    const [el, vm] = mount({\n      template:\n        `<div v-for=\"{ x } in list\" :key=\"x\" v-memo=\"[x, x === y]\">` +\n        `{{ x }} {{ x === y ? 'yes' : 'no' }} {{ z }}` +\n        `</div>`,\n      data: () => ({\n        list: [{ x: 1 }, { x: 2 }, { x: 3 }],\n        y: 1,\n        z: 'z'\n      })\n    })\n    expect(el.innerHTML).toBe(\n      `<div>1 yes z</div><div>2 no z</div><div>3 no z</div>`\n    )\n\n    vm.y = 2\n    await nextTick()\n    expect(el.innerHTML).toBe(\n      `<div>1 no z</div><div>2 yes z</div><div>3 no z</div>`\n    )\n\n    vm.list[0].x = 4\n    await nextTick()\n    expect(el.innerHTML).toBe(\n      `<div>4 no z</div><div>2 yes z</div><div>3 no z</div>`\n    )\n\n    vm.list[0].x = 5\n    vm.y = 5\n    await nextTick()\n    expect(el.innerHTML).toBe(\n      `<div>5 yes z</div><div>2 no z</div><div>3 no z</div>`\n    )\n\n    vm.z = 'zz'\n    await nextTick()\n    // should not update\n    expect(el.innerHTML).toBe(\n      `<div>5 yes z</div><div>2 no z</div><div>3 no z</div>`\n    )\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"on v-for /w constant expression ","suites":["v-memo"],"updatePoint":{"line":196,"column":40},"line":196,"code":"  test('on v-for /w constant expression ', async () => {\n    const [el, vm] = mount({\n      template: `<div v-for=\"item in 3\"  v-memo=\"[count < 2 ? true : count]\">\n          {{count}}\n        </div>`,\n      data: () => ({\n        count: 0\n      })\n    })\n    expect(el.innerHTML).toBe(`<div>0</div><div>0</div><div>0</div>`)\n\n    vm.count = 1\n    await nextTick()\n    // should not update\n    expect(el.innerHTML).toBe(`<div>0</div><div>0</div><div>0</div>`)\n\n    vm.count = 2\n    await nextTick()\n    // should update\n    expect(el.innerHTML).toBe(`<div>2</div><div>2</div><div>2</div>`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"v-memo dependency is NaN should be equal","suites":["v-memo"],"updatePoint":{"line":218,"column":48},"line":218,"code":"  test('v-memo dependency is NaN should be equal', async () => {\n    const [el, vm] = mount({\n      template: `<div v-memo=\"[x]\">{{ y }}</div>`,\n      data: () => ({ x: NaN, y: 0 })\n    })\n    expect(el.innerHTML).toBe(`<div>0</div>`)\n\n    vm.y++\n    // should not update\n    await nextTick()\n    expect(el.innerHTML).toBe(`<div>0</div>`)\n  })","file":"helpers/withMemo.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"inject global runtime","suites":["hot module replacement"],"updatePoint":{"line":33,"column":29},"line":33,"code":"  test('inject global runtime', () => {\n    expect(createRecord).toBeDefined()\n    expect(rerender).toBeDefined()\n    expect(reload).toBeDefined()\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"createRecord","suites":["hot module replacement"],"updatePoint":{"line":39,"column":20},"line":39,"code":"  test('createRecord', () => {\n    expect(createRecord('test1', {})).toBe(true)\n    // if id has already been created, should return false\n    expect(createRecord('test1', {})).toBe(false)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"rerender","suites":["hot module replacement"],"updatePoint":{"line":45,"column":16},"line":45,"code":"  test('rerender', async () => {\n    const root = nodeOps.createElement('div')\n    const parentId = 'test2-parent'\n    const childId = 'test2-child'\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      render: compileToFunction(`<div><slot/></div>`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      __hmrId: parentId,\n      data() {\n        return { count: 0 }\n      },\n      components: { Child },\n      render: compileToFunction(\n        `<div @click=\"count++\">{{ count }}<Child>{{ count }}</Child></div>`\n      )\n    }\n    createRecord(parentId, Parent)\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div>0<div>0</div></div>`)\n\n    // Perform some state change. This change should be preserved after the\n    // re-render!\n    triggerEvent(root.children[0] as TestElement, 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1<div>1</div></div>`)\n\n    // // Update text while preserving state\n    rerender(\n      parentId,\n      compileToFunction(\n        `<div @click=\"count++\">{{ count }}!<Child>{{ count }}</Child></div>`\n      )\n    )\n    expect(serializeInner(root)).toBe(`<div>1!<div>1</div></div>`)\n\n    // Should force child update on slot content change\n    rerender(\n      parentId,\n      compileToFunction(\n        `<div @click=\"count++\">{{ count }}!<Child>{{ count }}!</Child></div>`\n      )\n    )\n    expect(serializeInner(root)).toBe(`<div>1!<div>1!</div></div>`)\n\n    // Should force update element children despite block optimization\n    rerender(\n      parentId,\n      compileToFunction(\n        `<div @click=\"count++\">{{ count }}<span>{{ count }}</span>\n        <Child>{{ count }}!</Child>\n      </div>`\n      )\n    )\n    expect(serializeInner(root)).toBe(`<div>1<span>1</span><div>1!</div></div>`)\n\n    // Should force update child slot elements\n    rerender(\n      parentId,\n      compileToFunction(\n        `<div @click=\"count++\">\n        <Child><span>{{ count }}</span></Child>\n      </div>`\n      )\n    )\n    expect(serializeInner(root)).toBe(`<div><div><span>1</span></div></div>`)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reload","suites":["hot module replacement"],"updatePoint":{"line":118,"column":14},"line":118,"code":"  test('reload', async () => {\n    const root = nodeOps.createElement('div')\n    const childId = 'test3-child'\n    const unmountSpy = vi.fn()\n    const mountSpy = vi.fn()\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      data() {\n        return { count: 0 }\n      },\n      unmounted: unmountSpy,\n      render: compileToFunction(`<div @click=\"count++\">{{ count }}</div>`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      render: () => h(Child)\n    }\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div>0</div>`)\n\n    reload(childId, {\n      __hmrId: childId,\n      data() {\n        return { count: 1 }\n      },\n      mounted: mountSpy,\n      render: compileToFunction(`<div @click=\"count++\">{{ count }}</div>`)\n    })\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1</div>`)\n    expect(unmountSpy).toHaveBeenCalledTimes(1)\n    expect(mountSpy).toHaveBeenCalledTimes(1)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reload KeepAlive slot","suites":["hot module replacement"],"updatePoint":{"line":156,"column":29},"line":156,"code":"  test('reload KeepAlive slot', async () => {\n    const root = nodeOps.createElement('div')\n    const childId = 'test-child-keep-alive'\n    const unmountSpy = vi.fn()\n    const mountSpy = vi.fn()\n    const activeSpy = vi.fn()\n    const deactiveSpy = vi.fn()\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      data() {\n        return { count: 0 }\n      },\n      unmounted: unmountSpy,\n      render: compileToFunction(`<div>{{ count }}</div>`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      components: { Child },\n      data() {\n        return { toggle: true }\n      },\n      render: compileToFunction(\n        `<button @click=\"toggle = !toggle\"></button><KeepAlive><Child v-if=\"toggle\" /></KeepAlive>`\n      )\n    }\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<button></button><div>0</div>`)\n\n    reload(childId, {\n      __hmrId: childId,\n      data() {\n        return { count: 1 }\n      },\n      mounted: mountSpy,\n      unmounted: unmountSpy,\n      activated: activeSpy,\n      deactivated: deactiveSpy,\n      render: compileToFunction(`<div>{{ count }}</div>`)\n    })\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<button></button><div>1</div>`)\n    expect(unmountSpy).toHaveBeenCalledTimes(1)\n    expect(mountSpy).toHaveBeenCalledTimes(1)\n    expect(activeSpy).toHaveBeenCalledTimes(1)\n    expect(deactiveSpy).toHaveBeenCalledTimes(0)\n\n    // should not unmount when toggling\n    triggerEvent(root.children[1] as TestElement, 'click')\n    await nextTick()\n    expect(unmountSpy).toHaveBeenCalledTimes(1)\n    expect(mountSpy).toHaveBeenCalledTimes(1)\n    expect(activeSpy).toHaveBeenCalledTimes(1)\n    expect(deactiveSpy).toHaveBeenCalledTimes(1)\n\n    // should not mount when toggling\n    triggerEvent(root.children[1] as TestElement, 'click')\n    await nextTick()\n    expect(unmountSpy).toHaveBeenCalledTimes(1)\n    expect(mountSpy).toHaveBeenCalledTimes(1)\n    expect(activeSpy).toHaveBeenCalledTimes(2)\n    expect(deactiveSpy).toHaveBeenCalledTimes(1)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reload class component","suites":["hot module replacement"],"updatePoint":{"line":222,"column":30},"line":222,"code":"  test('reload class component', async () => {\n    const root = nodeOps.createElement('div')\n    const childId = 'test4-child'\n    const unmountSpy = vi.fn()\n    const mountSpy = vi.fn()\n\n    class Child {\n      static __vccOpts: ComponentOptions = {\n        __hmrId: childId,\n        data() {\n          return { count: 0 }\n        },\n        unmounted: unmountSpy,\n        render: compileToFunction(`<div @click=\"count++\">{{ count }}</div>`)\n      }\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      render: () => h(Child)\n    }\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div>0</div>`)\n\n    class UpdatedChild {\n      static __vccOpts: ComponentOptions = {\n        __hmrId: childId,\n        data() {\n          return { count: 1 }\n        },\n        mounted: mountSpy,\n        render: compileToFunction(`<div @click=\"count++\">{{ count }}</div>`)\n      }\n    }\n\n    reload(childId, UpdatedChild)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1</div>`)\n    expect(unmountSpy).toHaveBeenCalledTimes(1)\n    expect(mountSpy).toHaveBeenCalledTimes(1)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"static el reference","suites":["hot module replacement"],"updatePoint":{"line":267,"column":27},"line":267,"code":"  test('static el reference', async () => {\n    const root = nodeOps.createElement('div')\n    const id = 'test-static-el'\n\n    const template = `<div>\n    <div>{{ count }}</div>\n    <button @click=\"count++\">++</button>\n  </div>`\n\n    const Comp: ComponentOptions = {\n      __hmrId: id,\n      data() {\n        return { count: 0 }\n      },\n      render: compileToFunction(template)\n    }\n    createRecord(id, Comp)\n\n    render(h(Comp), root)\n    expect(serializeInner(root)).toBe(\n      `<div><div>0</div><button>++</button></div>`\n    )\n\n    // 1. click to trigger update\n    triggerEvent((root as any).children[0].children[1], 'click')\n    await nextTick()\n    expect(serializeInner(root)).toBe(\n      `<div><div>1</div><button>++</button></div>`\n    )\n\n    // 2. trigger HMR\n    rerender(\n      id,\n      compileToFunction(template.replace(`<button`, `<button class=\"foo\"`))\n    )\n    expect(serializeInner(root)).toBe(\n      `<div><div>1</div><button class=\"foo\">++</button></div>`\n    )\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"force update child component w/ static props","suites":["hot module replacement"],"updatePoint":{"line":308,"column":52},"line":308,"code":"  test('force update child component w/ static props', () => {\n    const root = nodeOps.createElement('div')\n    const parentId = 'test-force-props-parent'\n    const childId = 'test-force-props-child'\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      props: {\n        msg: String\n      },\n      render: compileToFunction(`<div>{{ msg }}</div>`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      __hmrId: parentId,\n      components: { Child },\n      render: compileToFunction(`<Child msg=\"foo\" />`)\n    }\n    createRecord(parentId, Parent)\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div>foo</div>`)\n\n    rerender(parentId, compileToFunction(`<Child msg=\"bar\" />`))\n    expect(serializeInner(root)).toBe(`<div>bar</div>`)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove static class from parent","suites":["hot module replacement"],"updatePoint":{"line":337,"column":39},"line":337,"code":"  test('remove static class from parent', () => {\n    const root = nodeOps.createElement('div')\n    const parentId = 'test-force-class-parent'\n    const childId = 'test-force-class-child'\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      render: compileToFunction(`<div>child</div>`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      __hmrId: parentId,\n      components: { Child },\n      render: compileToFunction(`<Child class=\"test\" />`)\n    }\n    createRecord(parentId, Parent)\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div class=\"test\">child</div>`)\n\n    rerender(parentId, compileToFunction(`<Child/>`))\n    expect(serializeInner(root)).toBe(`<div>child</div>`)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"rerender if any parent in the parent chain","suites":["hot module replacement"],"updatePoint":{"line":362,"column":50},"line":362,"code":"  test('rerender if any parent in the parent chain', () => {\n    const root = nodeOps.createElement('div')\n    const parent = 'test-force-props-parent-'\n    const childId = 'test-force-props-child'\n\n    const numberOfParents = 5\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      render: compileToFunction(`<div>child</div>`)\n    }\n    createRecord(childId, Child)\n\n    const components: ComponentOptions[] = []\n\n    for (let i = 0; i < numberOfParents; i++) {\n      const parentId = `${parent}${i}`\n      const parentComp: ComponentOptions = {\n        __hmrId: parentId\n      }\n      components.push(parentComp)\n      if (i === 0) {\n        parentComp.render = compileToFunction(`<Child />`)\n        parentComp.components = {\n          Child\n        }\n      } else {\n        parentComp.render = compileToFunction(`<Parent />`)\n        parentComp.components = {\n          Parent: components[i - 1]\n        }\n      }\n\n      createRecord(parentId, parentComp)\n    }\n\n    const last = components[components.length - 1]\n\n    render(h(last), root)\n    expect(serializeInner(root)).toBe(`<div>child</div>`)\n\n    rerender(last.__hmrId!, compileToFunction(`<Parent class=\"test\"/>`))\n    expect(serializeInner(root)).toBe(`<div class=\"test\">child</div>`)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"rerender with Teleport","suites":["hot module replacement"],"updatePoint":{"line":408,"column":30},"line":408,"code":"  test('rerender with Teleport', () => {\n    const root = nodeOps.createElement('div')\n    const target = nodeOps.createElement('div')\n    const parentId = 'parent-teleport'\n\n    const Child: ComponentOptions = {\n      data() {\n        return {\n          // style is used to ensure that the div tag will be tracked by Teleport\n          style: {},\n          target\n        }\n      },\n      render: compileToFunction(`\n        <teleport :to=\"target\">\n          <div :style=\"style\">\n            <slot/>\n          </div>\n        </teleport>\n      `)\n    }\n\n    const Parent: ComponentOptions = {\n      __hmrId: parentId,\n      components: { Child },\n      render: compileToFunction(`\n        <Child>\n          <template #default>\n            <div>1</div>\n          </template>\n        </Child>\n      `)\n    }\n    createRecord(parentId, Parent)\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(\n      `<!--teleport start--><!--teleport end-->`\n    )\n    expect(serializeInner(target)).toBe(`<div style={}><div>1</div></div>`)\n\n    rerender(\n      parentId,\n      compileToFunction(`\n      <Child>\n        <template #default>\n          <div>1</div>\n          <div>2</div>\n        </template>\n      </Child>\n    `)\n    )\n    expect(serializeInner(root)).toBe(\n      `<!--teleport start--><!--teleport end-->`\n    )\n    expect(serializeInner(target)).toBe(\n      `<div style={}><div>1</div><div>2</div></div>`\n    )\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with global mixins","suites":["hot module replacement"],"updatePoint":{"line":469,"column":26},"line":469,"code":"  test('with global mixins', async () => {\n    const childId = 'hmr-global-mixin'\n    const createSpy1 = vi.fn()\n    const createSpy2 = vi.fn()\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      created: createSpy1,\n      render() {\n        return h('div')\n      }\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      render: () => h(Child)\n    }\n\n    const app = createApp(Parent)\n    app.mixin({})\n\n    const root = nodeOps.createElement('div')\n    app.mount(root)\n    expect(createSpy1).toHaveBeenCalledTimes(1)\n    expect(createSpy2).toHaveBeenCalledTimes(0)\n\n    reload(childId, {\n      __hmrId: childId,\n      created: createSpy2,\n      render() {\n        return h('div')\n      }\n    })\n    await nextTick()\n    expect(createSpy1).toHaveBeenCalledTimes(1)\n    expect(createSpy2).toHaveBeenCalledTimes(1)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"rerender for component that has no active instance yet","suites":["hot module replacement"],"updatePoint":{"line":508,"column":62},"line":508,"code":"  test('rerender for component that has no active instance yet', () => {\n    const id = 'no-active-instance-rerender'\n    const Foo: ComponentOptions = {\n      __hmrId: id,\n      render: () => 'foo'\n    }\n\n    createRecord(id, Foo)\n    rerender(id, () => 'bar')\n\n    const root = nodeOps.createElement('div')\n    render(h(Foo), root)\n    expect(serializeInner(root)).toBe('bar')\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reload for component that has no active instance yet","suites":["hot module replacement"],"updatePoint":{"line":523,"column":60},"line":523,"code":"  test('reload for component that has no active instance yet', () => {\n    const id = 'no-active-instance-reload'\n    const Foo: ComponentOptions = {\n      __hmrId: id,\n      render: () => 'foo'\n    }\n\n    createRecord(id, Foo)\n    reload(id, {\n      __hmrId: id,\n      render: () => 'bar'\n    })\n\n    const root = nodeOps.createElement('div')\n    render(h(Foo), root)\n    expect(serializeInner(root)).toBe('bar')\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"force update slot content change","suites":["hot module replacement"],"updatePoint":{"line":542,"column":40},"line":542,"code":"  test('force update slot content change', () => {\n    const root = nodeOps.createElement('div')\n    const parentId = 'test-force-computed-parent'\n    const childId = 'test-force-computed-child'\n\n    const Child: ComponentOptions = {\n      __hmrId: childId,\n      computed: {\n        slotContent() {\n          return this.$slots.default?.()\n        }\n      },\n      render: compileToFunction(`<component :is=\"() => slotContent\" />`)\n    }\n    createRecord(childId, Child)\n\n    const Parent: ComponentOptions = {\n      __hmrId: parentId,\n      components: { Child },\n      render: compileToFunction(`<Child>1</Child>`)\n    }\n    createRecord(parentId, Parent)\n\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`1`)\n\n    rerender(parentId, compileToFunction(`<Child>2</Child>`))\n    expect(serializeInner(root)).toBe(`2`)\n  })","file":"hmr.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"text","suites":["SSR hydration"],"updatePoint":{"line":50,"column":12},"line":50,"code":"  test('text', async () => {\n    const msg = ref('foo')\n    const { vnode, container } = mountWithHydration('foo', () => msg.value)\n    expect(vnode.el).toBe(container.firstChild)\n    expect(container.textContent).toBe('foo')\n    msg.value = 'bar'\n    await nextTick()\n    expect(container.textContent).toBe('bar')\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"empty text","suites":["SSR hydration"],"updatePoint":{"line":60,"column":18},"line":60,"code":"  test('empty text', async () => {\n    const { container } = mountWithHydration('<div></div>', () =>\n      h('div', createTextVNode(''))\n    )\n    expect(container.textContent).toBe('')\n    expect(`Hydration children mismatch in <div>`).not.toHaveBeenWarned()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"comment","suites":["SSR hydration"],"updatePoint":{"line":68,"column":15},"line":68,"code":"  test('comment', () => {\n    const { vnode, container } = mountWithHydration('<!---->', () => null)\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.el.nodeType).toBe(8) // comment\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"static","suites":["SSR hydration"],"updatePoint":{"line":74,"column":14},"line":74,"code":"  test('static', () => {\n    const html = '<div><span>hello</span></div>'\n    const { vnode, container } = mountWithHydration(html, () =>\n      createStaticVNode('', 1)\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.el.outerHTML).toBe(html)\n    expect(vnode.anchor).toBe(container.firstChild)\n    expect(vnode.children).toBe(html)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"static (multiple elements)","suites":["SSR hydration"],"updatePoint":{"line":85,"column":34},"line":85,"code":"  test('static (multiple elements)', () => {\n    const staticContent = '<div></div><span>hello</span>'\n    const html = `<div><div>hi</div>` + staticContent + `<div>ho</div></div>`\n\n    const n1 = h('div', 'hi')\n    const s = createStaticVNode('', 2)\n    const n2 = h('div', 'ho')\n\n    const { container } = mountWithHydration(html, () => h('div', [n1, s, n2]))\n\n    const div = container.firstChild!\n\n    expect(n1.el).toBe(div.firstChild)\n    expect(n2.el).toBe(div.lastChild)\n    expect(s.el).toBe(div.childNodes[1])\n    expect(s.anchor).toBe(div.childNodes[2])\n    expect(s.children).toBe(staticContent)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"static (with text node as starting node)","suites":["SSR hydration"],"updatePoint":{"line":105,"column":48},"line":105,"code":"  test('static (with text node as starting node)', () => {\n    const html = ` A <span>foo</span> B`\n    const { vnode, container } = mountWithHydration(html, () =>\n      createStaticVNode(` A <span>foo</span> B`, 3)\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.anchor).toBe(container.lastChild)\n    expect(`Hydration node mismatch`).not.toHaveBeenWarned()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"static with content adoption","suites":["SSR hydration"],"updatePoint":{"line":115,"column":36},"line":115,"code":"  test('static with content adoption', () => {\n    const html = ` A <span>foo</span> B`\n    const { vnode, container } = mountWithHydration(html, () =>\n      createStaticVNode(``, 3)\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.anchor).toBe(container.lastChild)\n    expect(vnode.children).toBe(html)\n    expect(`Hydration node mismatch`).not.toHaveBeenWarned()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element with text children","suites":["SSR hydration"],"updatePoint":{"line":126,"column":34},"line":126,"code":"  test('element with text children', async () => {\n    const msg = ref('foo')\n    const { vnode, container } = mountWithHydration(\n      '<div class=\"foo\">foo</div>',\n      () => h('div', { class: msg.value }, msg.value)\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(container.firstChild!.textContent).toBe('foo')\n    msg.value = 'bar'\n    await nextTick()\n    expect(container.innerHTML).toBe(`<div class=\"bar\">bar</div>`)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element with elements children","suites":["SSR hydration"],"updatePoint":{"line":139,"column":38},"line":139,"code":"  test('element with elements children', async () => {\n    const msg = ref('foo')\n    const fn = vi.fn()\n    const { vnode, container } = mountWithHydration(\n      '<div><span>foo</span><span class=\"foo\"></span></div>',\n      () =>\n        h('div', [\n          h('span', msg.value),\n          h('span', { class: msg.value, onClick: fn })\n        ])\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect((vnode.children as VNode[])[0].el).toBe(\n      container.firstChild!.childNodes[0]\n    )\n    expect((vnode.children as VNode[])[1].el).toBe(\n      container.firstChild!.childNodes[1]\n    )\n\n    // event handler\n    triggerEvent('click', vnode.el.querySelector('.foo')!)\n    expect(fn).toHaveBeenCalled()\n\n    msg.value = 'bar'\n    await nextTick()\n    expect(vnode.el.innerHTML).toBe(`<span>bar</span><span class=\"bar\"></span>`)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element with ref","suites":["SSR hydration"],"updatePoint":{"line":167,"column":24},"line":167,"code":"  test('element with ref', () => {\n    const el = ref()\n    const { vnode, container } = mountWithHydration('<div></div>', () =>\n      h('div', { ref: el })\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(el.value).toBe(vnode.el)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Fragment","suites":["SSR hydration"],"updatePoint":{"line":176,"column":16},"line":176,"code":"  test('Fragment', async () => {\n    const msg = ref('foo')\n    const fn = vi.fn()\n    const { vnode, container } = mountWithHydration(\n      '<div><!--[--><span>foo</span><!--[--><span class=\"foo\"></span><!--]--><!--]--></div>',\n      () =>\n        h('div', [\n          [h('span', msg.value), [h('span', { class: msg.value, onClick: fn })]]\n        ])\n    )\n    expect(vnode.el).toBe(container.firstChild)\n\n    expect(vnode.el.innerHTML).toBe(\n      `<!--[--><span>foo</span><!--[--><span class=\"foo\"></span><!--]--><!--]-->`\n    )\n\n    // start fragment 1\n    const fragment1 = (vnode.children as VNode[])[0]\n    expect(fragment1.el).toBe(vnode.el.childNodes[0])\n    const fragment1Children = fragment1.children as VNode[]\n\n    // first <span>\n    expect(fragment1Children[0].el!.tagName).toBe('SPAN')\n    expect(fragment1Children[0].el).toBe(vnode.el.childNodes[1])\n\n    // start fragment 2\n    const fragment2 = fragment1Children[1]\n    expect(fragment2.el).toBe(vnode.el.childNodes[2])\n    const fragment2Children = fragment2.children as VNode[]\n\n    // second <span>\n    expect(fragment2Children[0].el!.tagName).toBe('SPAN')\n    expect(fragment2Children[0].el).toBe(vnode.el.childNodes[3])\n\n    // end fragment 2\n    expect(fragment2.anchor).toBe(vnode.el.childNodes[4])\n\n    // end fragment 1\n    expect(fragment1.anchor).toBe(vnode.el.childNodes[5])\n\n    // event handler\n    triggerEvent('click', vnode.el.querySelector('.foo')!)\n    expect(fn).toHaveBeenCalled()\n\n    msg.value = 'bar'\n    await nextTick()\n    expect(vnode.el.innerHTML).toBe(\n      `<!--[--><span>bar</span><!--[--><span class=\"bar\"></span><!--]--><!--]-->`\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport","suites":["SSR hydration"],"updatePoint":{"line":227,"column":16},"line":227,"code":"  test('Teleport', async () => {\n    const msg = ref('foo')\n    const fn = vi.fn()\n    const teleportContainer = document.createElement('div')\n    teleportContainer.id = 'teleport'\n    teleportContainer.innerHTML = `<span>foo</span><span class=\"foo\"></span><!--teleport anchor-->`\n    document.body.appendChild(teleportContainer)\n\n    const { vnode, container } = mountWithHydration(\n      '<!--teleport start--><!--teleport end-->',\n      () =>\n        h(Teleport, { to: '#teleport' }, [\n          h('span', msg.value),\n          h('span', { class: msg.value, onClick: fn })\n        ])\n    )\n\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.anchor).toBe(container.lastChild)\n\n    expect(vnode.target).toBe(teleportContainer)\n    expect((vnode.children as VNode[])[0].el).toBe(\n      teleportContainer.childNodes[0]\n    )\n    expect((vnode.children as VNode[])[1].el).toBe(\n      teleportContainer.childNodes[1]\n    )\n    expect(vnode.targetAnchor).toBe(teleportContainer.childNodes[2])\n\n    // event handler\n    triggerEvent('click', teleportContainer.querySelector('.foo')!)\n    expect(fn).toHaveBeenCalled()\n\n    msg.value = 'bar'\n    await nextTick()\n    expect(teleportContainer.innerHTML).toBe(\n      `<span>bar</span><span class=\"bar\"></span><!--teleport anchor-->`\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport (multiple + integration)","suites":["SSR hydration"],"updatePoint":{"line":267,"column":41},"line":267,"code":"  test('Teleport (multiple + integration)', async () => {\n    const msg = ref('foo')\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const Comp = () => [\n      h(Teleport, { to: '#teleport2' }, [\n        h('span', msg.value),\n        h('span', { class: msg.value, onClick: fn1 })\n      ]),\n      h(Teleport, { to: '#teleport2' }, [\n        h('span', msg.value + '2'),\n        h('span', { class: msg.value + '2', onClick: fn2 })\n      ])\n    ]\n\n    const teleportContainer = document.createElement('div')\n    teleportContainer.id = 'teleport2'\n    const ctx: SSRContext = {}\n    const mainHtml = await renderToString(h(Comp), ctx)\n    expect(mainHtml).toMatchInlineSnapshot(\n      `\"<!--[--><!--teleport start--><!--teleport end--><!--teleport start--><!--teleport end--><!--]-->\"`\n    )\n\n    const teleportHtml = ctx.teleports!['#teleport2']\n    expect(teleportHtml).toMatchInlineSnapshot(\n      '\"<span>foo</span><span class=\\\\\"foo\\\\\"></span><!--teleport anchor--><span>foo2</span><span class=\\\\\"foo2\\\\\"></span><!--teleport anchor-->\"'\n    )\n\n    teleportContainer.innerHTML = teleportHtml\n    document.body.appendChild(teleportContainer)\n\n    const { vnode, container } = mountWithHydration(mainHtml, Comp)\n    expect(vnode.el).toBe(container.firstChild)\n    const teleportVnode1 = (vnode.children as VNode[])[0]\n    const teleportVnode2 = (vnode.children as VNode[])[1]\n    expect(teleportVnode1.el).toBe(container.childNodes[1])\n    expect(teleportVnode1.anchor).toBe(container.childNodes[2])\n    expect(teleportVnode2.el).toBe(container.childNodes[3])\n    expect(teleportVnode2.anchor).toBe(container.childNodes[4])\n\n    expect(teleportVnode1.target).toBe(teleportContainer)\n    expect((teleportVnode1 as any).children[0].el).toBe(\n      teleportContainer.childNodes[0]\n    )\n    expect(teleportVnode1.targetAnchor).toBe(teleportContainer.childNodes[2])\n\n    expect(teleportVnode2.target).toBe(teleportContainer)\n    expect((teleportVnode2 as any).children[0].el).toBe(\n      teleportContainer.childNodes[3]\n    )\n    expect(teleportVnode2.targetAnchor).toBe(teleportContainer.childNodes[5])\n\n    // // event handler\n    triggerEvent('click', teleportContainer.querySelector('.foo')!)\n    expect(fn1).toHaveBeenCalled()\n\n    triggerEvent('click', teleportContainer.querySelector('.foo2')!)\n    expect(fn2).toHaveBeenCalled()\n\n    msg.value = 'bar'\n    await nextTick()\n    expect(teleportContainer.innerHTML).toMatchInlineSnapshot(\n      '\"<span>bar</span><span class=\\\\\"bar\\\\\"></span><!--teleport anchor--><span>bar2</span><span class=\\\\\"bar2\\\\\"></span><!--teleport anchor-->\"'\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport (disabled)","suites":["SSR hydration"],"updatePoint":{"line":334,"column":27},"line":334,"code":"  test('Teleport (disabled)', async () => {\n    const msg = ref('foo')\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    const Comp = () => [\n      h('div', 'foo'),\n      h(Teleport, { to: '#teleport3', disabled: true }, [\n        h('span', msg.value),\n        h('span', { class: msg.value, onClick: fn1 })\n      ]),\n      h('div', { class: msg.value + '2', onClick: fn2 }, 'bar')\n    ]\n\n    const teleportContainer = document.createElement('div')\n    teleportContainer.id = 'teleport3'\n    const ctx: SSRContext = {}\n    const mainHtml = await renderToString(h(Comp), ctx)\n    expect(mainHtml).toMatchInlineSnapshot(\n      '\"<!--[--><div>foo</div><!--teleport start--><span>foo</span><span class=\\\\\"foo\\\\\"></span><!--teleport end--><div class=\\\\\"foo2\\\\\">bar</div><!--]-->\"'\n    )\n\n    const teleportHtml = ctx.teleports!['#teleport3']\n    expect(teleportHtml).toMatchInlineSnapshot(`\"<!--teleport anchor-->\"`)\n\n    teleportContainer.innerHTML = teleportHtml\n    document.body.appendChild(teleportContainer)\n\n    const { vnode, container } = mountWithHydration(mainHtml, Comp)\n    expect(vnode.el).toBe(container.firstChild)\n    const children = vnode.children as VNode[]\n\n    expect(children[0].el).toBe(container.childNodes[1])\n\n    const teleportVnode = children[1]\n    expect(teleportVnode.el).toBe(container.childNodes[2])\n    expect((teleportVnode.children as VNode[])[0].el).toBe(\n      container.childNodes[3]\n    )\n    expect((teleportVnode.children as VNode[])[1].el).toBe(\n      container.childNodes[4]\n    )\n    expect(teleportVnode.anchor).toBe(container.childNodes[5])\n    expect(children[2].el).toBe(container.childNodes[6])\n\n    expect(teleportVnode.target).toBe(teleportContainer)\n    expect(teleportVnode.targetAnchor).toBe(teleportContainer.childNodes[0])\n\n    // // event handler\n    triggerEvent('click', container.querySelector('.foo')!)\n    expect(fn1).toHaveBeenCalled()\n\n    triggerEvent('click', container.querySelector('.foo2')!)\n    expect(fn2).toHaveBeenCalled()\n\n    msg.value = 'bar'\n    await nextTick()\n    expect(container.innerHTML).toMatchInlineSnapshot(\n      '\"<!--[--><div>foo</div><!--teleport start--><span>bar</span><span class=\\\\\"bar\\\\\"></span><!--teleport end--><div class=\\\\\"bar2\\\\\">bar</div><!--]-->\"'\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport (as component root)","suites":["SSR hydration"],"updatePoint":{"line":396,"column":36},"line":396,"code":"  test('Teleport (as component root)', () => {\n    const teleportContainer = document.createElement('div')\n    teleportContainer.id = 'teleport4'\n    teleportContainer.innerHTML = `hello<!--teleport anchor-->`\n    document.body.appendChild(teleportContainer)\n\n    const wrapper = {\n      render() {\n        return h(Teleport, { to: '#teleport4' }, ['hello'])\n      }\n    }\n\n    const { vnode, container } = mountWithHydration(\n      '<div><!--teleport start--><!--teleport end--><div></div></div>',\n      () => h('div', [h(wrapper), h('div')])\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    // component el\n    const wrapperVNode = (vnode as any).children[0]\n    const tpStart = container.firstChild?.firstChild\n    const tpEnd = tpStart?.nextSibling\n    expect(wrapperVNode.el).toBe(tpStart)\n    expect(wrapperVNode.component.subTree.el).toBe(tpStart)\n    expect(wrapperVNode.component.subTree.anchor).toBe(tpEnd)\n    // next node hydrate properly\n    const nextVNode = (vnode as any).children[1]\n    expect(nextVNode.el).toBe(container.firstChild?.lastChild)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport (nested)","suites":["SSR hydration"],"updatePoint":{"line":425,"column":25},"line":425,"code":"  test('Teleport (nested)', () => {\n    const teleportContainer = document.createElement('div')\n    teleportContainer.id = 'teleport5'\n    teleportContainer.innerHTML = `<div><!--teleport start--><!--teleport end--></div><!--teleport anchor--><div>child</div><!--teleport anchor-->`\n    document.body.appendChild(teleportContainer)\n\n    const { vnode, container } = mountWithHydration(\n      '<!--teleport start--><!--teleport end-->',\n      () =>\n        h(Teleport, { to: '#teleport5' }, [\n          h('div', [h(Teleport, { to: '#teleport5' }, [h('div', 'child')])])\n        ])\n    )\n\n    expect(vnode.el).toBe(container.firstChild)\n    expect(vnode.anchor).toBe(container.lastChild)\n\n    const childDivVNode = (vnode as any).children[0]\n    const div = teleportContainer.firstChild\n    expect(childDivVNode.el).toBe(div)\n    expect(vnode.targetAnchor).toBe(div?.nextSibling)\n\n    const childTeleportVNode = childDivVNode.children[0]\n    expect(childTeleportVNode.el).toBe(div?.firstChild)\n    expect(childTeleportVNode.anchor).toBe(div?.lastChild)\n\n    expect(childTeleportVNode.targetAnchor).toBe(teleportContainer.lastChild)\n    expect(childTeleportVNode.children[0].el).toBe(\n      teleportContainer.lastChild?.previousSibling\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"full compiler integration","suites":["SSR hydration"],"updatePoint":{"line":458,"column":33},"line":458,"code":"  test('full compiler integration', async () => {\n    const mounted: string[] = []\n    const log = vi.fn()\n    const toggle = ref(true)\n\n    const Child = {\n      data() {\n        return {\n          count: 0,\n          text: 'hello',\n          style: {\n            color: 'red'\n          }\n        }\n      },\n      mounted() {\n        mounted.push('child')\n      },\n      template: `\n      <div>\n        <span class=\"count\" :style=\"style\">{{ count }}</span>\n        <button class=\"inc\" @click=\"count++\">inc</button>\n        <button class=\"change\" @click=\"style.color = 'green'\" >change color</button>\n        <button class=\"emit\" @click=\"$emit('foo')\">emit</button>\n        <span class=\"text\">{{ text }}</span>\n        <input v-model=\"text\">\n      </div>\n      `\n    }\n\n    const App = {\n      setup() {\n        return { toggle }\n      },\n      mounted() {\n        mounted.push('parent')\n      },\n      template: `\n        <div>\n          <span>hello</span>\n          <template v-if=\"toggle\">\n            <Child @foo=\"log('child')\"/>\n            <template v-if=\"true\">\n              <button class=\"parent-click\" @click=\"log('click')\">click me</button>\n            </template>\n          </template>\n          <span>hello</span>\n        </div>`,\n      components: {\n        Child\n      },\n      methods: {\n        log\n      }\n    }\n\n    const container = document.createElement('div')\n    // server render\n    container.innerHTML = await renderToString(h(App))\n    // hydrate\n    createSSRApp(App).mount(container)\n\n    // assert interactions\n    // 1. parent button click\n    triggerEvent('click', container.querySelector('.parent-click')!)\n    expect(log).toHaveBeenCalledWith('click')\n\n    // 2. child inc click + text interpolation\n    const count = container.querySelector('.count') as HTMLElement\n    expect(count.textContent).toBe(`0`)\n    triggerEvent('click', container.querySelector('.inc')!)\n    await nextTick()\n    expect(count.textContent).toBe(`1`)\n\n    // 3. child color click + style binding\n    expect(count.style.color).toBe('red')\n    triggerEvent('click', container.querySelector('.change')!)\n    await nextTick()\n    expect(count.style.color).toBe('green')\n\n    // 4. child event emit\n    triggerEvent('click', container.querySelector('.emit')!)\n    expect(log).toHaveBeenCalledWith('child')\n\n    // 5. child v-model\n    const text = container.querySelector('.text')!\n    const input = container.querySelector('input')!\n    expect(text.textContent).toBe('hello')\n    input.value = 'bye'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(text.textContent).toBe('bye')\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handle click error in ssr mode","suites":["SSR hydration"],"updatePoint":{"line":552,"column":38},"line":552,"code":"  test('handle click error in ssr mode', async () => {\n    const App = {\n      setup() {\n        const throwError = () => {\n          throw new Error('Sentry Error')\n        }\n        return { throwError }\n      },\n      template: `\n        <div>\n          <button class=\"parent-click\" @click=\"throwError\">click me</button>\n        </div>`\n    }\n\n    const container = document.createElement('div')\n    // server render\n    container.innerHTML = await renderToString(h(App))\n    // hydrate\n    const app = createSSRApp(App)\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(container)\n    // assert interactions\n    // parent button click\n    triggerEvent('click', container.querySelector('.parent-click')!)\n    expect(handler).toHaveBeenCalled()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handle blur error in ssr mode","suites":["SSR hydration"],"updatePoint":{"line":579,"column":37},"line":579,"code":"  test('handle blur error in ssr mode', async () => {\n    const App = {\n      setup() {\n        const throwError = () => {\n          throw new Error('Sentry Error')\n        }\n        return { throwError }\n      },\n      template: `\n        <div>\n          <input class=\"parent-click\" @blur=\"throwError\"/>\n        </div>`\n    }\n\n    const container = document.createElement('div')\n    // server render\n    container.innerHTML = await renderToString(h(App))\n    // hydrate\n    const app = createSSRApp(App)\n    const handler = (app.config.errorHandler = vi.fn())\n    app.mount(container)\n    // assert interactions\n    // parent blur event\n    triggerEvent('blur', container.querySelector('.parent-click')!)\n    expect(handler).toHaveBeenCalled()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Suspense","suites":["SSR hydration"],"updatePoint":{"line":606,"column":16},"line":606,"code":"  test('Suspense', async () => {\n    const AsyncChild = {\n      async setup() {\n        const count = ref(0)\n        return () =>\n          h(\n            'span',\n            {\n              onClick: () => {\n                count.value++\n              }\n            },\n            count.value\n          )\n      }\n    }\n    const { vnode, container } = mountWithHydration('<span>0</span>', () =>\n      h(Suspense, () => h(AsyncChild))\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    // wait for hydration to finish\n    await new Promise(r => setTimeout(r))\n    triggerEvent('click', container.querySelector('span')!)\n    await nextTick()\n    expect(container.innerHTML).toBe(`<span>1</span>`)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Suspense (full integration)","suites":["SSR hydration"],"updatePoint":{"line":633,"column":35},"line":633,"code":"  test('Suspense (full integration)', async () => {\n    const mountedCalls: number[] = []\n    const asyncDeps: Promise<any>[] = []\n\n    const AsyncChild = defineComponent({\n      props: ['n'],\n      async setup(props) {\n        const count = ref(props.n)\n        onMounted(() => {\n          mountedCalls.push(props.n)\n        })\n        const p = new Promise(r => setTimeout(r, props.n * 10))\n        asyncDeps.push(p)\n        await p\n        return () =>\n          h(\n            'span',\n            {\n              onClick: () => {\n                count.value++\n              }\n            },\n            count.value\n          )\n      }\n    })\n\n    const done = vi.fn()\n    const App = {\n      template: `\n      <Suspense @resolve=\"done\">\n        <div>\n          <AsyncChild :n=\"1\" />\n          <AsyncChild :n=\"2\" />\n        </div>\n      </Suspense>`,\n      components: {\n        AsyncChild\n      },\n      methods: {\n        done\n      }\n    }\n\n    const container = document.createElement('div')\n    // server render\n    container.innerHTML = await renderToString(h(App))\n    expect(container.innerHTML).toMatchInlineSnapshot(\n      `\"<div><span>1</span><span>2</span></div>\"`\n    )\n    // reset asyncDeps from ssr\n    asyncDeps.length = 0\n    // hydrate\n    createSSRApp(App).mount(container)\n\n    expect(mountedCalls.length).toBe(0)\n    expect(asyncDeps.length).toBe(2)\n\n    // wait for hydration to complete\n    await Promise.all(asyncDeps)\n    await new Promise(r => setTimeout(r))\n\n    // should flush buffered effects\n    expect(mountedCalls).toMatchObject([1, 2])\n    expect(container.innerHTML).toMatch(\n      `<div><span>1</span><span>2</span></div>`\n    )\n\n    const span1 = container.querySelector('span')!\n    triggerEvent('click', span1)\n    await nextTick()\n    expect(container.innerHTML).toMatch(\n      `<div><span>2</span><span>2</span></div>`\n    )\n\n    const span2 = span1.nextSibling as Element\n    triggerEvent('click', span2)\n    await nextTick()\n    expect(container.innerHTML).toMatch(\n      `<div><span>2</span><span>3</span></div>`\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"async component","suites":["SSR hydration"],"updatePoint":{"line":716,"column":23},"line":716,"code":"  test('async component', async () => {\n    const spy = vi.fn()\n    const Comp = () =>\n      h(\n        'button',\n        {\n          onClick: spy\n        },\n        'hello!'\n      )\n\n    let serverResolve: any\n    let AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          serverResolve = r\n        })\n    )\n\n    const App = {\n      render() {\n        return ['hello', h(AsyncComp), 'world']\n      }\n    }\n\n    // server render\n    const htmlPromise = renderToString(h(App))\n    serverResolve(Comp)\n    const html = await htmlPromise\n    expect(html).toMatchInlineSnapshot(\n      `\"<!--[-->hello<button>hello!</button>world<!--]-->\"`\n    )\n\n    // hydration\n    let clientResolve: any\n    AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          clientResolve = r\n        })\n    )\n\n    const container = document.createElement('div')\n    container.innerHTML = html\n    createSSRApp(App).mount(container)\n\n    // hydration not complete yet\n    triggerEvent('click', container.querySelector('button')!)\n    expect(spy).not.toHaveBeenCalled()\n\n    // resolve\n    clientResolve(Comp)\n    await new Promise(r => setTimeout(r))\n\n    // should be hydrated now\n    triggerEvent('click', container.querySelector('button')!)\n    expect(spy).toHaveBeenCalled()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"update async wrapper before resolve","suites":["SSR hydration"],"updatePoint":{"line":775,"column":43},"line":775,"code":"  test('update async wrapper before resolve', async () => {\n    const Comp = {\n      render() {\n        return h('h1', 'Async component')\n      }\n    }\n    let serverResolve: any\n    let AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          serverResolve = r\n        })\n    )\n\n    const bol = ref(true)\n    const App = {\n      setup() {\n        onMounted(() => {\n          // change state, this makes updateComponent(AsyncComp) execute before\n          // the async component is resolved\n          bol.value = false\n        })\n\n        return () => {\n          return [bol.value ? 'hello' : 'world', h(AsyncComp)]\n        }\n      }\n    }\n\n    // server render\n    const htmlPromise = renderToString(h(App))\n    serverResolve(Comp)\n    const html = await htmlPromise\n    expect(html).toMatchInlineSnapshot(\n      `\"<!--[-->hello<h1>Async component</h1><!--]-->\"`\n    )\n\n    // hydration\n    let clientResolve: any\n    AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          clientResolve = r\n        })\n    )\n\n    const container = document.createElement('div')\n    container.innerHTML = html\n    createSSRApp(App).mount(container)\n\n    // resolve\n    clientResolve(Comp)\n    await new Promise(r => setTimeout(r))\n\n    // should be hydrated now\n    expect(`Hydration node mismatch`).not.toHaveBeenWarned()\n    expect(container.innerHTML).toMatchInlineSnapshot(\n      `\"<!--[-->world<h1>Async component</h1><!--]-->\"`\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount async wrapper before load","suites":["SSR hydration"],"updatePoint":{"line":837,"column":41},"line":837,"code":"  test('unmount async wrapper before load', async () => {\n    let resolve: any\n    const AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r\n        })\n    )\n\n    const show = ref(true)\n    const root = document.createElement('div')\n    root.innerHTML = '<div><div>async</div></div>'\n\n    createSSRApp({\n      render() {\n        return h('div', [show.value ? h(AsyncComp) : h('div', 'hi')])\n      }\n    }).mount(root)\n\n    show.value = false\n    await nextTick()\n    expect(root.innerHTML).toBe('<div><div>hi</div></div>')\n    resolve({})\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmount async wrapper before load (fragment)","suites":["SSR hydration"],"updatePoint":{"line":862,"column":52},"line":862,"code":"  test('unmount async wrapper before load (fragment)', async () => {\n    let resolve: any\n    const AsyncComp = defineAsyncComponent(\n      () =>\n        new Promise(r => {\n          resolve = r\n        })\n    )\n\n    const show = ref(true)\n    const root = document.createElement('div')\n    root.innerHTML = '<div><!--[-->async<!--]--></div>'\n\n    createSSRApp({\n      render() {\n        return h('div', [show.value ? h(AsyncComp) : h('div', 'hi')])\n      }\n    }).mount(root)\n\n    show.value = false\n    await nextTick()\n    expect(root.innerHTML).toBe('<div><div>hi</div></div>')\n    resolve({})\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"elements with camel-case in svg ","suites":["SSR hydration"],"updatePoint":{"line":887,"column":40},"line":887,"code":"  test('elements with camel-case in svg ', () => {\n    const { vnode, container } = mountWithHydration(\n      '<animateTransform></animateTransform>',\n      () => h('animateTransform')\n    )\n    expect(vnode.el).toBe(container.firstChild)\n    expect(`Hydration node mismatch`).not.toHaveBeenWarned()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"SVG as a mount container","suites":["SSR hydration"],"updatePoint":{"line":896,"column":32},"line":896,"code":"  test('SVG as a mount container', () => {\n    const svgContainer = document.createElement('svg')\n    svgContainer.innerHTML = '<g></g>'\n    const app = createSSRApp({\n      render: () => h('g')\n    })\n\n    expect(\n      (\n        app.mount(svgContainer).$.subTree as VNode<Node, Element> & {\n          el: Element\n        }\n      ).el instanceof SVGElement\n    )\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"force hydrate input v-model with non-string value bindings","suites":["SSR hydration"],"updatePoint":{"line":912,"column":66},"line":912,"code":"  test('force hydrate input v-model with non-string value bindings', () => {\n    const { container } = mountWithHydration(\n      '<input type=\"checkbox\" value=\"true\">',\n      () =>\n        withDirectives(\n          createVNode(\n            'input',\n            { type: 'checkbox', 'true-value': true },\n            null,\n            PatchFlags.PROPS,\n            ['true-value']\n          ),\n          [[vModelCheckbox, true]]\n        )\n    )\n    expect((container.firstChild as any)._trueValue).toBe(true)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"force hydrate select option with non-string value bindings","suites":["SSR hydration"],"updatePoint":{"line":930,"column":66},"line":930,"code":"  test('force hydrate select option with non-string value bindings', () => {\n    const { container } = mountWithHydration(\n      '<select><option :value=\"true\">ok</option></select>',\n      () =>\n        h('select', [\n          // hoisted because bound value is a constant...\n          createVNode('option', { value: true }, null, -1 /* HOISTED */)\n        ])\n    )\n    expect((container.firstChild!.firstChild as any)._value).toBe(true)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"empty text node in slot","suites":["SSR hydration"],"updatePoint":{"line":943,"column":31},"line":943,"code":"  test('empty text node in slot', () => {\n    const Comp = {\n      render(this: any) {\n        return renderSlot(this.$slots, 'default', {}, () => [\n          createTextVNode('')\n        ])\n      }\n    }\n    const { container, vnode } = mountWithHydration('<!--[--><!--]-->', () =>\n      h(Comp)\n    )\n    expect(container.childNodes.length).toBe(3)\n    const text = container.childNodes[1]\n    expect(text.nodeType).toBe(3)\n    expect(vnode.el).toBe(container.childNodes[0])\n    // component => slot fragment => text node\n    expect((vnode as any).component?.subTree.children[0].el).toBe(text)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"app.unmount()","suites":["SSR hydration"],"updatePoint":{"line":962,"column":21},"line":962,"code":"  test('app.unmount()', async () => {\n    const container = document.createElement('DIV')\n    container.innerHTML = '<button></button>'\n    const App = defineComponent({\n      setup(_, { expose }) {\n        const count = ref(0)\n\n        expose({ count })\n\n        return () =>\n          h('button', {\n            onClick: () => count.value++\n          })\n      }\n    })\n\n    const app = createSSRApp(App)\n    const vm = app.mount(container)\n    await nextTick()\n    expect((container as any)._vnode).toBeDefined()\n    // @ts-expect-error - expose()'d properties are not available on vm type\n    expect(vm.count).toBe(0)\n\n    app.unmount()\n    expect((container as any)._vnode).toBe(null)\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"stringified root fragment","suites":["SSR hydration"],"updatePoint":{"line":990,"column":33},"line":990,"code":"  test('stringified root fragment', () => {\n    mountWithHydration(`<!--[--><div></div><!--]-->`, () =>\n      createStaticVNode(`<div></div>`, 1)\n    )\n    expect(`mismatch`).not.toHaveBeenWarned()\n  })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"text node","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":998,"column":19},"line":998,"code":"    test('text node', () => {\n      const { container } = mountWithHydration(`foo`, () => 'bar')\n      expect(container.textContent).toBe('bar')\n      expect(`Hydration text mismatch`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element text content","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1004,"column":30},"line":1004,"code":"    test('element text content', () => {\n      const { container } = mountWithHydration(`<div>foo</div>`, () =>\n        h('div', 'bar')\n      )\n      expect(container.innerHTML).toBe('<div>bar</div>')\n      expect(`Hydration text content mismatch in <div>`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"not enough children","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1012,"column":29},"line":1012,"code":"    test('not enough children', () => {\n      const { container } = mountWithHydration(`<div></div>`, () =>\n        h('div', [h('span', 'foo'), h('span', 'bar')])\n      )\n      expect(container.innerHTML).toBe(\n        '<div><span>foo</span><span>bar</span></div>'\n      )\n      expect(`Hydration children mismatch in <div>`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"too many children","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1022,"column":27},"line":1022,"code":"    test('too many children', () => {\n      const { container } = mountWithHydration(\n        `<div><span>foo</span><span>bar</span></div>`,\n        () => h('div', [h('span', 'foo')])\n      )\n      expect(container.innerHTML).toBe('<div><span>foo</span></div>')\n      expect(`Hydration children mismatch in <div>`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"complete mismatch","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1031,"column":27},"line":1031,"code":"    test('complete mismatch', () => {\n      const { container } = mountWithHydration(\n        `<div><span>foo</span><span>bar</span></div>`,\n        () => h('div', [h('div', 'foo'), h('p', 'bar')])\n      )\n      expect(container.innerHTML).toBe('<div><div>foo</div><p>bar</p></div>')\n      expect(`Hydration node mismatch`).toHaveBeenWarnedTimes(2)\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"fragment mismatch removal","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1040,"column":35},"line":1040,"code":"    test('fragment mismatch removal', () => {\n      const { container } = mountWithHydration(\n        `<div><!--[--><div>foo</div><div>bar</div><!--]--></div>`,\n        () => h('div', [h('span', 'replaced')])\n      )\n      expect(container.innerHTML).toBe('<div><span>replaced</span></div>')\n      expect(`Hydration node mismatch`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"fragment not enough children","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1049,"column":38},"line":1049,"code":"    test('fragment not enough children', () => {\n      const { container } = mountWithHydration(\n        `<div><!--[--><div>foo</div><!--]--><div>baz</div></div>`,\n        () => h('div', [[h('div', 'foo'), h('div', 'bar')], h('div', 'baz')])\n      )\n      expect(container.innerHTML).toBe(\n        '<div><!--[--><div>foo</div><div>bar</div><!--]--><div>baz</div></div>'\n      )\n      expect(`Hydration node mismatch`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"fragment too many children","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1060,"column":36},"line":1060,"code":"    test('fragment too many children', () => {\n      const { container } = mountWithHydration(\n        `<div><!--[--><div>foo</div><div>bar</div><!--]--><div>baz</div></div>`,\n        () => h('div', [[h('div', 'foo')], h('div', 'baz')])\n      )\n      expect(container.innerHTML).toBe(\n        '<div><!--[--><div>foo</div><!--]--><div>baz</div></div>'\n      )\n      // fragment ends early and attempts to hydrate the extra <div>bar</div>\n      // as 2nd fragment child.\n      expect(`Hydration text content mismatch`).toHaveBeenWarned()\n      // excessive children removal\n      expect(`Hydration children mismatch`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"Teleport target has empty children","suites":["SSR hydration","mismatch handling"],"updatePoint":{"line":1075,"column":44},"line":1075,"code":"    test('Teleport target has empty children', () => {\n      const teleportContainer = document.createElement('div')\n      teleportContainer.id = 'teleport'\n      document.body.appendChild(teleportContainer)\n\n      mountWithHydration('<!--teleport start--><!--teleport end-->', () =>\n        h(Teleport, { to: '#teleport' }, [h('span', 'value')])\n      )\n      expect(teleportContainer.innerHTML).toBe(`<span>value</span>`)\n      expect(`Hydration children mismatch`).toHaveBeenWarned()\n    })","file":"hydration.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component public instance should not be observable","suites":["misc"],"updatePoint":{"line":4,"column":58},"line":4,"code":"  test('component public instance should not be observable', () => {\n    let instance: any\n    const Comp = {\n      render() {},\n      mounted() {\n        instance = this\n      }\n    }\n    render(h(Comp), nodeOps.createElement('div'))\n    expect(instance).toBeDefined()\n    const r = reactive(instance)\n    expect(r).toBe(instance)\n    expect(isReactive(r)).toBe(false)\n  })","file":"misc.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should allow attrs to fallthrough","suites":["attribute fallthrough"],"updatePoint":{"line":24,"column":39},"line":24,"code":"  it('should allow attrs to fallthrough', async () => {\n    const click = vi.fn()\n    const childUpdated = vi.fn()\n\n    const Hello = {\n      setup() {\n        const count = ref(0)\n\n        function inc() {\n          count.value++\n          click()\n        }\n\n        return () =>\n          h(Child, {\n            foo: count.value + 1,\n            id: 'test',\n            class: 'c' + count.value,\n            style: { color: count.value ? 'red' : 'green' },\n            onClick: inc,\n            'data-id': count.value + 1\n          })\n      }\n    }\n\n    const Child = {\n      setup(props: any) {\n        onUpdated(childUpdated)\n        return () =>\n          h(\n            'div',\n            {\n              class: 'c2',\n              style: { fontWeight: 'bold' }\n            },\n            props.foo\n          )\n      }\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Hello), root)\n\n    const node = root.children[0] as HTMLElement\n\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('foo')).toBe('1')\n    expect(node.getAttribute('class')).toBe('c2 c0')\n    expect(node.style.color).toBe('green')\n    expect(node.style.fontWeight).toBe('bold')\n    expect(node.dataset.id).toBe('1')\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n\n    await nextTick()\n    expect(childUpdated).toHaveBeenCalled()\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('foo')).toBe('2')\n    expect(node.getAttribute('class')).toBe('c2 c1')\n    expect(node.style.color).toBe('red')\n    expect(node.style.fontWeight).toBe('bold')\n    expect(node.dataset.id).toBe('2')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should only allow whitelisted fallthrough on functional component with optional props","suites":["attribute fallthrough"],"updatePoint":{"line":89,"column":91},"line":89,"code":"  it('should only allow whitelisted fallthrough on functional component with optional props', async () => {\n    const click = vi.fn()\n    const childUpdated = vi.fn()\n\n    const count = ref(0)\n\n    function inc() {\n      count.value++\n      click()\n    }\n\n    const Hello = () =>\n      h(Child, {\n        foo: count.value + 1,\n        id: 'test',\n        class: 'c' + count.value,\n        style: { color: count.value ? 'red' : 'green' },\n        onClick: inc\n      })\n\n    const Child = (props: any) => {\n      childUpdated()\n      return h(\n        'div',\n        {\n          class: 'c2',\n          style: { fontWeight: 'bold' }\n        },\n        props.foo\n      )\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Hello), root)\n\n    const node = root.children[0] as HTMLElement\n\n    // not whitelisted\n    expect(node.getAttribute('id')).toBe(null)\n    expect(node.getAttribute('foo')).toBe(null)\n\n    // whitelisted: style, class, event listeners\n    expect(node.getAttribute('class')).toBe('c2 c0')\n    expect(node.style.color).toBe('green')\n    expect(node.style.fontWeight).toBe('bold')\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n\n    await nextTick()\n    expect(childUpdated).toHaveBeenCalled()\n    expect(node.getAttribute('id')).toBe(null)\n    expect(node.getAttribute('foo')).toBe(null)\n    expect(node.getAttribute('class')).toBe('c2 c1')\n    expect(node.style.color).toBe('red')\n    expect(node.style.fontWeight).toBe('bold')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should allow all attrs on functional component with declared props","suites":["attribute fallthrough"],"updatePoint":{"line":147,"column":72},"line":147,"code":"  it('should allow all attrs on functional component with declared props', async () => {\n    const click = vi.fn()\n    const childUpdated = vi.fn()\n\n    const count = ref(0)\n\n    function inc() {\n      count.value++\n      click()\n    }\n\n    const Hello = () =>\n      h(Child, {\n        foo: count.value + 1,\n        id: 'test',\n        class: 'c' + count.value,\n        style: { color: count.value ? 'red' : 'green' },\n        onClick: inc\n      })\n\n    const Child = (props: { foo: number }) => {\n      childUpdated()\n      return h(\n        'div',\n        {\n          class: 'c2',\n          style: { fontWeight: 'bold' }\n        },\n        props.foo\n      )\n    }\n    Child.props = ['foo']\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Hello), root)\n\n    const node = root.children[0] as HTMLElement\n\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('foo')).toBe(null) // declared as prop\n    expect(node.getAttribute('class')).toBe('c2 c0')\n    expect(node.style.color).toBe('green')\n    expect(node.style.fontWeight).toBe('bold')\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n\n    await nextTick()\n    expect(childUpdated).toHaveBeenCalled()\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('foo')).toBe(null)\n    expect(node.getAttribute('class')).toBe('c2 c1')\n    expect(node.style.color).toBe('red')\n    expect(node.style.fontWeight).toBe('bold')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should fallthrough for nested components","suites":["attribute fallthrough"],"updatePoint":{"line":203,"column":46},"line":203,"code":"  it('should fallthrough for nested components', async () => {\n    const click = vi.fn()\n    const childUpdated = vi.fn()\n    const grandChildUpdated = vi.fn()\n\n    const Hello = {\n      setup() {\n        const count = ref(0)\n\n        function inc() {\n          count.value++\n          click()\n        }\n\n        return () =>\n          h(Child, {\n            foo: 1,\n            id: 'test',\n            class: 'c' + count.value,\n            style: { color: count.value ? 'red' : 'green' },\n            onClick: inc\n          })\n      }\n    }\n\n    const Child = {\n      setup(props: any) {\n        onUpdated(childUpdated)\n        // HOC simply passing props down.\n        // this will result in merging the same attrs, but should be deduped by\n        // `mergeProps`.\n        return () => h(GrandChild, props)\n      }\n    }\n\n    const GrandChild = defineComponent({\n      props: {\n        id: String,\n        foo: Number\n      },\n      setup(props) {\n        onUpdated(grandChildUpdated)\n        return () =>\n          h(\n            'div',\n            {\n              id: props.id,\n              class: 'c2',\n              style: { fontWeight: 'bold' }\n            },\n            props.foo\n          )\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Hello), root)\n\n    const node = root.children[0] as HTMLElement\n\n    // with declared props, any parent attr that isn't a prop falls through\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('class')).toBe('c2 c0')\n    expect(node.style.color).toBe('green')\n    expect(node.style.fontWeight).toBe('bold')\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n\n    // ...while declared ones remain props\n    expect(node.hasAttribute('foo')).toBe(false)\n\n    await nextTick()\n    expect(childUpdated).toHaveBeenCalled()\n    expect(grandChildUpdated).toHaveBeenCalled()\n    expect(node.getAttribute('id')).toBe('test')\n    expect(node.getAttribute('class')).toBe('c2 c1')\n    expect(node.style.color).toBe('red')\n    expect(node.style.fontWeight).toBe('bold')\n\n    expect(node.hasAttribute('foo')).toBe(false)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fallthrough with inheritAttrs: false","suites":["attribute fallthrough"],"updatePoint":{"line":286,"column":53},"line":286,"code":"  it('should not fallthrough with inheritAttrs: false', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent' })\n      }\n    }\n\n    const Child = defineComponent({\n      props: ['foo'],\n      inheritAttrs: false,\n      render() {\n        return h('div', this.foo)\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    // should not contain class\n    expect(root.innerHTML).toMatch(`<div>1</div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fallthrough with inheritAttrs: false from mixins","suites":["attribute fallthrough"],"updatePoint":{"line":310,"column":65},"line":310,"code":"  it('should not fallthrough with inheritAttrs: false from mixins', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent' })\n      }\n    }\n\n    const mixin = {\n      inheritAttrs: false\n    }\n\n    const Child = defineComponent({\n      mixins: [mixin],\n      props: ['foo'],\n      render() {\n        return h('div', this.foo)\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    // should not contain class\n    expect(root.innerHTML).toMatch(`<div>1</div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"explicit spreading with inheritAttrs: false","suites":["attribute fallthrough"],"updatePoint":{"line":337,"column":49},"line":337,"code":"  it('explicit spreading with inheritAttrs: false', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent' })\n      }\n    }\n\n    const Child = defineComponent({\n      props: ['foo'],\n      inheritAttrs: false,\n      render() {\n        return h(\n          'div',\n          mergeProps(\n            {\n              class: 'child'\n            },\n            this.$attrs\n          ),\n          this.foo\n        )\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    // should merge parent/child classes\n    expect(root.innerHTML).toMatch(`<div class=\"child parent\">1</div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn when fallthrough fails on non-single-root","suites":["attribute fallthrough"],"updatePoint":{"line":369,"column":59},"line":369,"code":"  it('should warn when fallthrough fails on non-single-root', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child = defineComponent({\n      props: ['foo'],\n      render() {\n        return [h('div'), h('div')]\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes (class)`).toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).toHaveBeenWarned()\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should dedupe same listeners when $attrs is used during render","suites":["attribute fallthrough"],"updatePoint":{"line":391,"column":68},"line":391,"code":"  it('should dedupe same listeners when $attrs is used during render', () => {\n    const click = vi.fn()\n    const count = ref(0)\n\n    function inc() {\n      count.value++\n      click()\n    }\n\n    const Parent = {\n      render() {\n        return h(Child, { onClick: inc })\n      }\n    }\n\n    const Child = defineComponent({\n      render() {\n        return h(\n          'div',\n          mergeProps(\n            {\n              onClick: withModifiers(() => {}, ['prevent', 'stop'])\n            },\n            this.$attrs\n          )\n        )\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    const node = root.children[0] as HTMLElement\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalledTimes(1)\n    expect(count.value).toBe(1)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn when $attrs is used during render","suites":["attribute fallthrough"],"updatePoint":{"line":430,"column":55},"line":430,"code":"  it('should not warn when $attrs is used during render', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child = defineComponent({\n      props: ['foo'],\n      render() {\n        return [h('div'), h('div', this.$attrs)]\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes`).not.toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).not.toHaveBeenWarned()\n\n    expect(root.innerHTML).toBe(`<div></div><div class=\"parent\"></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn when context.attrs is used during render","suites":["attribute fallthrough"],"updatePoint":{"line":454,"column":62},"line":454,"code":"  it('should not warn when context.attrs is used during render', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child = defineComponent({\n      props: ['foo'],\n      setup(_props, { attrs }) {\n        return () => [h('div'), h('div', attrs)]\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes`).not.toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).not.toHaveBeenWarned()\n\n    expect(root.innerHTML).toBe(`<div></div><div class=\"parent\"></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn when context.attrs is used during render (functional)","suites":["attribute fallthrough"],"updatePoint":{"line":478,"column":75},"line":478,"code":"  it('should not warn when context.attrs is used during render (functional)', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child: FunctionalComponent = (_, { attrs }) => [\n      h('div'),\n      h('div', attrs)\n    ]\n\n    Child.props = ['foo']\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes`).not.toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).not.toHaveBeenWarned()\n    expect(root.innerHTML).toBe(`<div></div><div class=\"parent\"></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not warn when functional component has optional props","suites":["attribute fallthrough"],"updatePoint":{"line":501,"column":66},"line":501,"code":"  it('should not warn when functional component has optional props', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child = (props: any) => [h('div'), h('div', { class: props.class })]\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes`).not.toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).not.toHaveBeenWarned()\n    expect(root.innerHTML).toBe(`<div></div><div class=\"parent\"></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn when functional component has props and does not use attrs","suites":["attribute fallthrough"],"updatePoint":{"line":519,"column":76},"line":519,"code":"  it('should warn when functional component has props and does not use attrs', () => {\n    const Parent = {\n      render() {\n        return h(Child, { foo: 1, class: 'parent', onBar: () => {} })\n      }\n    }\n\n    const Child: FunctionalComponent = () => [h('div'), h('div')]\n\n    Child.props = ['foo']\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(`Extraneous non-props attributes`).toHaveBeenWarned()\n    expect(`Extraneous non-emits event listeners`).toHaveBeenWarned()\n    expect(root.innerHTML).toBe(`<div></div><div></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update merged dynamic attrs on optimized child root","suites":["attribute fallthrough"],"updatePoint":{"line":540,"column":64},"line":540,"code":"  it('should update merged dynamic attrs on optimized child root', async () => {\n    const aria = ref('true')\n    const cls = ref('bar')\n    const Parent = {\n      render() {\n        return h(Child, { 'aria-hidden': aria.value, class: cls.value })\n      }\n    }\n\n    const Child = {\n      props: [],\n      render() {\n        return openBlock(), createBlock('div')\n      }\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Parent), root)\n\n    expect(root.innerHTML).toBe(`<div aria-hidden=\"true\" class=\"bar\"></div>`)\n\n    aria.value = 'false'\n    await nextTick()\n    expect(root.innerHTML).toBe(`<div aria-hidden=\"false\" class=\"bar\"></div>`)\n\n    cls.value = 'barr'\n    await nextTick()\n    expect(root.innerHTML).toBe(`<div aria-hidden=\"false\" class=\"barr\"></div>`)\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not let listener fallthrough when declared in emits (stateful)","suites":["attribute fallthrough"],"updatePoint":{"line":571,"column":75},"line":571,"code":"  it('should not let listener fallthrough when declared in emits (stateful)', () => {\n    const Child = defineComponent({\n      emits: ['click'],\n      render() {\n        return h(\n          'button',\n          {\n            onClick: () => {\n              this.$emit('click', 'custom')\n            }\n          },\n          'hello'\n        )\n      }\n    })\n\n    const onClick = vi.fn()\n    const App = {\n      render() {\n        return h(Child, {\n          onClick\n        })\n      }\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(App), root)\n\n    const node = root.children[0] as HTMLElement\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(onClick).toHaveBeenCalledTimes(1)\n    expect(onClick).toHaveBeenCalledWith('custom')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not let listener fallthrough when declared in emits (functional)","suites":["attribute fallthrough"],"updatePoint":{"line":606,"column":77},"line":606,"code":"  it('should not let listener fallthrough when declared in emits (functional)', () => {\n    const Child: FunctionalComponent<{}, { click: any }> = (_, { emit }) => {\n      // should not be in props\n      expect((_ as any).onClick).toBeUndefined()\n      return h('button', {\n        onClick: () => {\n          emit('click', 'custom')\n        }\n      })\n    }\n    Child.emits = ['click']\n\n    const onClick = vi.fn()\n    const App = {\n      render() {\n        return h(Child, {\n          onClick\n        })\n      }\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(App), root)\n\n    const node = root.children[0] as HTMLElement\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(onClick).toHaveBeenCalledTimes(1)\n    expect(onClick).toHaveBeenCalledWith('custom')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should support fallthrough for fragments with single element + comments","suites":["attribute fallthrough"],"updatePoint":{"line":637,"column":77},"line":637,"code":"  it('should support fallthrough for fragments with single element + comments', () => {\n    const click = vi.fn()\n\n    const Hello = {\n      setup() {\n        return () => h(Child, { class: 'foo', onClick: click })\n      }\n    }\n\n    const Child = {\n      setup() {\n        return () => (\n          openBlock(),\n          createBlock(\n            Fragment,\n            null,\n            [\n              createCommentVNode('hello'),\n              h('button'),\n              createCommentVNode('world')\n            ],\n            PatchFlags.STABLE_FRAGMENT | PatchFlags.DEV_ROOT_FRAGMENT\n          )\n        )\n      }\n    }\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(Hello), root)\n\n    expect(root.innerHTML).toBe(\n      `<!--hello--><button class=\"foo\"></button><!--world-->`\n    )\n    const button = root.children[0] as HTMLElement\n    button.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not fallthrough v-model listeners with corresponding declared prop","suites":["attribute fallthrough"],"updatePoint":{"line":677,"column":79},"line":677,"code":"  it('should not fallthrough v-model listeners with corresponding declared prop', () => {\n    let textFoo = ''\n    let textBar = ''\n    const click = vi.fn()\n\n    const App = defineComponent({\n      setup() {\n        return () =>\n          h(Child, {\n            modelValue: textFoo,\n            'onUpdate:modelValue': (val: string) => {\n              textFoo = val\n            }\n          })\n      }\n    })\n\n    const Child = defineComponent({\n      props: ['modelValue'],\n      setup(_props, { emit }) {\n        return () =>\n          h(GrandChild, {\n            modelValue: textBar,\n            'onUpdate:modelValue': (val: string) => {\n              textBar = val\n              emit('update:modelValue', 'from Child')\n            }\n          })\n      }\n    })\n\n    const GrandChild = defineComponent({\n      props: ['modelValue'],\n      setup(_props, { emit }) {\n        return () =>\n          h('button', {\n            onClick() {\n              click()\n              emit('update:modelValue', 'from GrandChild')\n            }\n          })\n      }\n    })\n\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    render(h(App), root)\n\n    const node = root.children[0] as HTMLElement\n\n    node.dispatchEvent(new CustomEvent('click'))\n    expect(click).toHaveBeenCalled()\n    expect(textBar).toBe('from GrandChild')\n    expect(textFoo).toBe('from Child')\n  })","file":"rendererAttrsFallthrough.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should patch previously empty children","suites":[],"updatePoint":{"line":39,"column":44},"line":39,"code":"test('should patch previously empty children', () => {\n  const root = nodeOps.createElement('div')\n\n  render(h('div', []), root)\n  expect(inner(root)).toBe('<div></div>')\n\n  render(h('div', ['hello']), root)\n  expect(inner(root)).toBe('<div>hello</div>')\n})","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should patch previously null children","suites":[],"updatePoint":{"line":49,"column":43},"line":49,"code":"test('should patch previously null children', () => {\n  const root = nodeOps.createElement('div')\n\n  render(h('div'), root)\n  expect(inner(root)).toBe('<div></div>')\n\n  render(h('div', ['hello']), root)\n  expect(inner(root)).toBe('<div>hello</div>')\n})","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array children -> text children","suites":[],"updatePoint":{"line":59,"column":37},"line":59,"code":"test('array children -> text children', () => {\n  const root = nodeOps.createElement('div')\n  render(h('div', [h('div')]), root)\n  expect(inner(root)).toBe('<div><div></div></div>')\n\n  render(h('div', 'hello'), root)\n  expect(inner(root)).toBe('<div>hello</div>')\n})","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"append","suites":["renderer: keyed children"],"updatePoint":{"line":81,"column":14},"line":81,"code":"  test('append', () => {\n    elm = renderChildren([1])\n    expect(elm.children.length).toBe(1)\n\n    elm = renderChildren([1, 2, 3])\n    expect(elm.children.length).toBe(3)\n    expect(serialize(elm.children[1])).toBe('<span>2</span>')\n    expect(serialize(elm.children[2])).toBe('<span>3</span>')\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"prepend","suites":["renderer: keyed children"],"updatePoint":{"line":91,"column":15},"line":91,"code":"  test('prepend', () => {\n    elm = renderChildren([4, 5])\n    expect(elm.children.length).toBe(2)\n\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '3',\n      '4',\n      '5'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"insert in middle","suites":["renderer: keyed children"],"updatePoint":{"line":106,"column":24},"line":106,"code":"  test('insert in middle', () => {\n    elm = renderChildren([1, 2, 4, 5])\n    expect(elm.children.length).toBe(4)\n\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '3',\n      '4',\n      '5'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"insert at beginning and end","suites":["renderer: keyed children"],"updatePoint":{"line":121,"column":35},"line":121,"code":"  test('insert at beginning and end', () => {\n    elm = renderChildren([2, 3, 4])\n    expect(elm.children.length).toBe(3)\n\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '3',\n      '4',\n      '5'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"insert to empty parent","suites":["renderer: keyed children"],"updatePoint":{"line":136,"column":30},"line":136,"code":"  test('insert to empty parent', () => {\n    elm = renderChildren([])\n    expect(elm.children.length).toBe(0)\n\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '3',\n      '4',\n      '5'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove all children from parent","suites":["renderer: keyed children"],"updatePoint":{"line":151,"column":39},"line":151,"code":"  test('remove all children from parent', () => {\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '3',\n      '4',\n      '5'\n    ])\n\n    render(h('div'), root)\n    expect(elm.children.length).toBe(0)\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove from beginning","suites":["renderer: keyed children"],"updatePoint":{"line":166,"column":29},"line":166,"code":"  test('remove from beginning', () => {\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n\n    elm = renderChildren([3, 4, 5])\n    expect(elm.children.length).toBe(3)\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['3', '4', '5'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove from end","suites":["renderer: keyed children"],"updatePoint":{"line":175,"column":23},"line":175,"code":"  test('remove from end', () => {\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n\n    elm = renderChildren([1, 2, 3])\n    expect(elm.children.length).toBe(3)\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['1', '2', '3'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove from middle","suites":["renderer: keyed children"],"updatePoint":{"line":184,"column":26},"line":184,"code":"  test('remove from middle', () => {\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n\n    elm = renderChildren([1, 2, 4, 5])\n    expect(elm.children.length).toBe(4)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '2',\n      '4',\n      '5'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moving single child forward","suites":["renderer: keyed children"],"updatePoint":{"line":198,"column":35},"line":198,"code":"  test('moving single child forward', () => {\n    elm = renderChildren([1, 2, 3, 4])\n    expect(elm.children.length).toBe(4)\n\n    elm = renderChildren([2, 3, 1, 4])\n    expect(elm.children.length).toBe(4)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '2',\n      '3',\n      '1',\n      '4'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moving single child backwards","suites":["renderer: keyed children"],"updatePoint":{"line":212,"column":37},"line":212,"code":"  test('moving single child backwards', () => {\n    elm = renderChildren([1, 2, 3, 4])\n    expect(elm.children.length).toBe(4)\n\n    elm = renderChildren([1, 4, 2, 3])\n    expect(elm.children.length).toBe(4)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      '4',\n      '2',\n      '3'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moving single child to end","suites":["renderer: keyed children"],"updatePoint":{"line":226,"column":34},"line":226,"code":"  test('moving single child to end', () => {\n    elm = renderChildren([1, 2, 3])\n    expect(elm.children.length).toBe(3)\n\n    elm = renderChildren([2, 3, 1])\n    expect(elm.children.length).toBe(3)\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['2', '3', '1'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"swap first and last","suites":["renderer: keyed children"],"updatePoint":{"line":235,"column":27},"line":235,"code":"  test('swap first and last', () => {\n    elm = renderChildren([1, 2, 3, 4])\n    expect(elm.children.length).toBe(4)\n\n    elm = renderChildren([4, 2, 3, 1])\n    expect(elm.children.length).toBe(4)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '4',\n      '2',\n      '3',\n      '1'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"move to left & replace","suites":["renderer: keyed children"],"updatePoint":{"line":249,"column":30},"line":249,"code":"  test('move to left & replace', () => {\n    elm = renderChildren([1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(5)\n\n    elm = renderChildren([4, 1, 2, 3, 6])\n    expect(elm.children.length).toBe(5)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '4',\n      '1',\n      '2',\n      '3',\n      '6'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"move to left and leaves hold","suites":["renderer: keyed children"],"updatePoint":{"line":264,"column":36},"line":264,"code":"  test('move to left and leaves hold', () => {\n    elm = renderChildren([1, 4, 5])\n    expect(elm.children.length).toBe(3)\n\n    elm = renderChildren([4, 6])\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['4', '6'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"moved and set to undefined element ending at the end","suites":["renderer: keyed children"],"updatePoint":{"line":272,"column":60},"line":272,"code":"  test('moved and set to undefined element ending at the end', () => {\n    elm = renderChildren([2, 4, 5])\n    expect(elm.children.length).toBe(3)\n\n    elm = renderChildren([4, 5, 3])\n    expect(elm.children.length).toBe(3)\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['4', '5', '3'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reverse element","suites":["renderer: keyed children"],"updatePoint":{"line":281,"column":23},"line":281,"code":"  test('reverse element', () => {\n    elm = renderChildren([1, 2, 3, 4, 5, 6, 7, 8])\n    expect(elm.children.length).toBe(8)\n\n    elm = renderChildren([8, 7, 6, 5, 4, 3, 2, 1])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '8',\n      '7',\n      '6',\n      '5',\n      '4',\n      '3',\n      '2',\n      '1'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"something","suites":["renderer: keyed children"],"updatePoint":{"line":298,"column":17},"line":298,"code":"  test('something', () => {\n    elm = renderChildren([0, 1, 2, 3, 4, 5])\n    expect(elm.children.length).toBe(6)\n\n    elm = renderChildren([4, 3, 2, 1, 5, 0])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '4',\n      '3',\n      '2',\n      '1',\n      '5',\n      '0'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"random shuffle","suites":["renderer: keyed children"],"updatePoint":{"line":313,"column":22},"line":313,"code":"  test('random shuffle', () => {\n    const elms = 14\n    const samples = 5\n    const arr = [...Array(elms).keys()]\n    const opacities: string[] = []\n\n    function spanNumWithOpacity(n: number, o: string) {\n      return h('span', { key: n, style: { opacity: o } }, n.toString())\n    }\n\n    for (let n = 0; n < samples; ++n) {\n      render(\n        h(\n          'span',\n          arr.map(n => spanNumWithOpacity(n, '1'))\n        ),\n        root\n      )\n      elm = root.children[0] as TestElement\n\n      for (let i = 0; i < elms; ++i) {\n        expect(serializeInner(elm.children[i] as TestElement)).toBe(\n          i.toString()\n        )\n        opacities[i] = Math.random().toFixed(5).toString()\n      }\n\n      const shufArr = shuffle(arr.slice(0))\n      render(\n        h(\n          'span',\n          arr.map(n => spanNumWithOpacity(shufArr[n], opacities[n]))\n        ),\n        root\n      )\n      elm = root.children[0] as TestElement\n      for (let i = 0; i < elms; ++i) {\n        expect(serializeInner(elm.children[i] as TestElement)).toBe(\n          shufArr[i].toString()\n        )\n        expect(elm.children[i]).toMatchObject({\n          props: {\n            style: {\n              opacity: opacities[i]\n            }\n          }\n        })\n      }\n    }\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"children with the same key but with different tag","suites":["renderer: keyed children"],"updatePoint":{"line":364,"column":57},"line":364,"code":"  test('children with the same key but with different tag', () => {\n    render(\n      h('div', [\n        h('div', { key: 1 }, 'one'),\n        h('div', { key: 2 }, 'two'),\n        h('div', { key: 3 }, 'three'),\n        h('div', { key: 4 }, 'four')\n      ]),\n      root\n    )\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(c => c.tag)).toEqual([\n      'div',\n      'div',\n      'div',\n      'div'\n    ])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'one',\n      'two',\n      'three',\n      'four'\n    ])\n\n    render(\n      h('div', [\n        h('div', { key: 4 }, 'four'),\n        h('span', { key: 3 }, 'three'),\n        h('span', { key: 2 }, 'two'),\n        h('div', { key: 1 }, 'one')\n      ]),\n      root\n    )\n    expect((elm.children as TestElement[]).map(c => c.tag)).toEqual([\n      'div',\n      'span',\n      'span',\n      'div'\n    ])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'four',\n      'three',\n      'two',\n      'one'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"children with the same tag, same key, but one with data and one without data","suites":["renderer: keyed children"],"updatePoint":{"line":411,"column":84},"line":411,"code":"  test('children with the same tag, same key, but one with data and one without data', () => {\n    render(h('div', [h('div', { class: 'hi' }, 'one')]), root)\n    elm = root.children[0] as TestElement\n    expect(elm.children[0]).toMatchObject({\n      props: {\n        class: 'hi'\n      }\n    })\n\n    render(h('div', [h('div', 'four')]), root)\n    elm = root.children[0] as TestElement\n    expect(elm.children[0] as TestElement).toMatchObject({\n      props: {\n        // in the DOM renderer this will be ''\n        // but the test renderer simply sets whatever value it receives.\n        class: null\n      }\n    })\n    expect(serialize(elm.children[0])).toBe(`<div>four</div>`)\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should warn with duplicate keys","suites":["renderer: keyed children"],"updatePoint":{"line":432,"column":39},"line":432,"code":"  test('should warn with duplicate keys', () => {\n    renderChildren([1, 2, 3, 4, 5])\n    renderChildren([1, 6, 6, 3, 5])\n    expect(`Duplicate keys`).toHaveBeenWarned()\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"move a key in non-keyed nodes with a size up","suites":["renderer: unkeyed children"],"updatePoint":{"line":452,"column":52},"line":452,"code":"  test('move a key in non-keyed nodes with a size up', () => {\n    elm = renderChildren([1, 'a', 'b', 'c'])\n    expect(elm.children.length).toBe(4)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      '1',\n      'a',\n      'b',\n      'c'\n    ])\n\n    elm = renderChildren(['d', 'a', 'b', 'c', 1, 'e'])\n    expect(elm.children.length).toBe(6)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'd',\n      'a',\n      'b',\n      'c',\n      '1',\n      'e'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"append elements with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":474,"column":59},"line":474,"code":"  test('append elements with updating children without keys', () => {\n    elm = renderChildren(['hello'])\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['hello'])\n\n    elm = renderChildren(['hello', 'world'])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'hello',\n      'world'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"unmoved text nodes with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":485,"column":62},"line":485,"code":"  test('unmoved text nodes with updating children without keys', () => {\n    render(h('div', ['text', h('span', ['hello'])]), root)\n\n    elm = root.children[0] as TestElement\n    expect(elm.children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'text'\n    })\n\n    render(h('div', ['text', h('span', ['hello'])]), root)\n\n    elm = root.children[0] as TestElement\n    expect(elm.children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'text'\n    })\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"changing text children with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":503,"column":66},"line":503,"code":"  test('changing text children with updating children without keys', () => {\n    render(h('div', ['text', h('span', ['hello'])]), root)\n\n    elm = root.children[0] as TestElement\n    expect(elm.children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'text'\n    })\n\n    render(h('div', ['text2', h('span', ['hello'])]), root)\n\n    elm = root.children[0] as TestElement\n    expect(elm.children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'text2'\n    })\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"prepend element with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":521,"column":59},"line":521,"code":"  test('prepend element with updating children without keys', () => {\n    render(h('div', [h('span', ['world'])]), root)\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['world'])\n\n    render(h('div', [h('span', ['hello']), h('span', ['world'])]), root)\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'hello',\n      'world'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"prepend element of different tag type with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":533,"column":81},"line":533,"code":"  test('prepend element of different tag type with updating children without keys', () => {\n    render(h('div', [h('span', ['world'])]), root)\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['world'])\n\n    render(h('div', [h('div', ['hello']), h('span', ['world'])]), root)\n    expect((elm.children as TestElement[]).map(c => c.tag)).toEqual([\n      'div',\n      'span'\n    ])\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'hello',\n      'world'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove elements with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":549,"column":59},"line":549,"code":"  test('remove elements with updating children without keys', () => {\n    render(\n      h('div', [h('span', ['one']), h('span', ['two']), h('span', ['three'])]),\n      root\n    )\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'one',\n      'two',\n      'three'\n    ])\n\n    render(h('div', [h('span', ['one']), h('span', ['three'])]), root)\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['one', 'three'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove a single text node with updating children without keys","suites":["renderer: unkeyed children"],"updatePoint":{"line":566,"column":69},"line":566,"code":"  test('remove a single text node with updating children without keys', () => {\n    render(h('div', ['one']), root)\n    elm = root.children[0] as TestElement\n    expect(serializeInner(elm)).toBe('one')\n\n    render(h('div'), root)\n    expect(serializeInner(elm)).toBe('')\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove a single text node when children are updated","suites":["renderer: unkeyed children"],"updatePoint":{"line":575,"column":59},"line":575,"code":"  test('remove a single text node when children are updated', () => {\n    render(h('div', ['one']), root)\n    elm = root.children[0] as TestElement\n    expect(serializeInner(elm)).toBe('one')\n\n    render(h('div', [h('div', ['two']), h('span', ['three'])]), root)\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual(['two', 'three'])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"remove a text node among other elements","suites":["renderer: unkeyed children"],"updatePoint":{"line":585,"column":47},"line":585,"code":"  test('remove a text node among other elements', () => {\n    render(h('div', ['one', h('span', ['two'])]), root)\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(c => serialize(c))).toEqual([\n      'one',\n      '<span>two</span>'\n    ])\n\n    render(h('div', [h('div', ['three'])]), root)\n    elm = root.children[0] as TestElement\n    expect(elm.children.length).toBe(1)\n    expect(serialize(elm.children[0])).toBe('<div>three</div>')\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reorder elements","suites":["renderer: unkeyed children"],"updatePoint":{"line":599,"column":24},"line":599,"code":"  test('reorder elements', () => {\n    render(\n      h('div', [h('span', ['one']), h('div', ['two']), h('b', ['three'])]),\n      root\n    )\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'one',\n      'two',\n      'three'\n    ])\n\n    render(\n      h('div', [h('b', ['three']), h('div', ['two']), h('span', ['one'])]),\n      root\n    )\n    elm = root.children[0] as TestElement\n    expect((elm.children as TestElement[]).map(inner)).toEqual([\n      'three',\n      'two',\n      'one'\n    ])\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not de-opt when both head and tail change","suites":["renderer: unkeyed children"],"updatePoint":{"line":624,"column":56},"line":624,"code":"  test('should not de-opt when both head and tail change', () => {\n    render(h('div', [null, h('div'), null]), root)\n    elm = root.children[0] as TestElement\n    const original = elm.children[1]\n\n    render(h('div', [h('p'), h('div'), h('p')]), root)\n    elm = root.children[0] as TestElement\n    const postPatch = elm.children[1]\n\n    expect(postPatch).toBe(original)\n  })","file":"rendererChildren.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update parent(hoc) component host el when child component self update","suites":["renderer: component"],"updatePoint":{"line":18,"column":84},"line":18,"code":"  test('should update parent(hoc) component host el when child component self update', async () => {\n    const value = ref(true)\n    let parentVnode: VNode\n    let childVnode1: VNode\n    let childVnode2: VNode\n\n    const Parent = {\n      render: () => {\n        // let Parent first rerender\n        return (parentVnode = h(Child))\n      }\n    }\n\n    const Child = {\n      render: () => {\n        return value.value\n          ? (childVnode1 = h('div'))\n          : (childVnode2 = h('span'))\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Parent), root)\n    expect(serializeInner(root)).toBe(`<div></div>`)\n    expect(parentVnode!.el).toBe(childVnode1!.el)\n\n    value.value = false\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<span></span>`)\n    expect(parentVnode!.el).toBe(childVnode2!.el)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an Component with props","suites":["renderer: component"],"updatePoint":{"line":50,"column":43},"line":50,"code":"  it('should create an Component with props', () => {\n    const Comp = {\n      render: () => {\n        return h('div')\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { id: 'foo', class: 'bar' }), root)\n    expect(serializeInner(root)).toBe(`<div id=\"foo\" class=\"bar\"></div>`)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an Component with direct text children","suites":["renderer: component"],"updatePoint":{"line":61,"column":58},"line":61,"code":"  it('should create an Component with direct text children', () => {\n    const Comp = {\n      render: () => {\n        return h('div', 'test')\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp, { id: 'foo', class: 'bar' }), root)\n    expect(serializeInner(root)).toBe(`<div id=\"foo\" class=\"bar\">test</div>`)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update an Component tag which is already mounted","suites":["renderer: component"],"updatePoint":{"line":72,"column":61},"line":72,"code":"  it('should update an Component tag which is already mounted', () => {\n    const Comp1 = {\n      render: () => {\n        return h('div', 'foo')\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(Comp1), root)\n    expect(serializeInner(root)).toBe('<div>foo</div>')\n\n    const Comp2 = {\n      render: () => {\n        return h('span', 'foo')\n      }\n    }\n    render(h(Comp2), root)\n    expect(serializeInner(root)).toBe('<span>foo</span>')\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not update Component if only changed props are declared emit listeners","suites":["renderer: component"],"updatePoint":{"line":92,"column":83},"line":92,"code":"  it('should not update Component if only changed props are declared emit listeners', () => {\n    const Comp1 = {\n      emits: ['foo'],\n      updated: vi.fn(),\n      render: () => null\n    }\n    const root = nodeOps.createElement('div')\n    render(\n      h(Comp1, {\n        onFoo: () => {}\n      }),\n      root\n    )\n    render(\n      h(Comp1, {\n        onFoo: () => {}\n      }),\n      root\n    )\n    expect(Comp1.updated).not.toHaveBeenCalled()\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component child synchronously updating parent state should trigger parent re-render","suites":["renderer: component"],"updatePoint":{"line":115,"column":91},"line":115,"code":"  test('component child synchronously updating parent state should trigger parent re-render', async () => {\n    const App = {\n      setup() {\n        const n = ref(0)\n        provide('foo', n)\n        return () => {\n          return [h('div', n.value), h(Child)]\n        }\n      }\n    }\n\n    const Child = {\n      setup() {\n        const n = inject<Ref<number>>('foo')!\n        n.value++\n\n        return () => {\n          return h('div', n.value)\n        }\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div>0</div><div>1</div>`)\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1</div><div>1</div>`)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"instance.$el should be exposed to watch options","suites":["renderer: component"],"updatePoint":{"line":145,"column":55},"line":145,"code":"  test('instance.$el should be exposed to watch options', async () => {\n    function returnThis(this: any, _arg: any) {\n      return this\n    }\n    const propWatchSpy = vi.fn(returnThis)\n    const dataWatchSpy = vi.fn(returnThis)\n    let instance: any\n    const Comp = {\n      props: {\n        testProp: String\n      },\n\n      data() {\n        return {\n          testData: undefined\n        }\n      },\n\n      watch: {\n        testProp() {\n          // @ts-ignore\n          propWatchSpy(this.$el)\n        },\n        testData() {\n          // @ts-ignore\n          dataWatchSpy(this.$el)\n        }\n      },\n\n      created() {\n        instance = this\n      },\n\n      render() {\n        return h('div')\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    await nextTick()\n    expect(propWatchSpy).not.toHaveBeenCalled()\n    expect(dataWatchSpy).not.toHaveBeenCalled()\n\n    render(h(Comp, { testProp: 'prop ' }), root)\n    await nextTick()\n    expect(propWatchSpy).toHaveBeenCalledWith(instance.$el)\n\n    instance.testData = 1\n    await nextTick()\n    expect(dataWatchSpy).toHaveBeenCalledWith(instance.$el)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"component child updating parent state in pre-flush should trigger parent re-render","suites":["renderer: component"],"updatePoint":{"line":199,"column":90},"line":199,"code":"  test('component child updating parent state in pre-flush should trigger parent re-render', async () => {\n    const outer = ref(0)\n    const App = {\n      setup() {\n        const inner = ref(0)\n\n        return () => {\n          return [\n            h('div', inner.value),\n            h(Child, {\n              value: outer.value,\n              onUpdate: (val: number) => (inner.value = val)\n            })\n          ]\n        }\n      }\n    }\n\n    const Child = {\n      props: ['value'],\n      setup(props: any, { emit }: SetupContext) {\n        watch(\n          () => props.value,\n          (val: number) => emit('update', val)\n        )\n\n        return () => {\n          return h('div', props.value)\n        }\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div>0</div><div>0</div>`)\n\n    outer.value++\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<div>1</div><div>1</div>`)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should pause tracking deps when initializing legacy options","suites":["renderer: component"],"updatePoint":{"line":241,"column":67},"line":241,"code":"  test('should pause tracking deps when initializing legacy options', async () => {\n    let childInstance = null as any\n    const Child = {\n      props: ['foo'],\n      data() {\n        return {\n          count: 0\n        }\n      },\n      watch: {\n        foo: {\n          immediate: true,\n          handler() {\n            ;(this as any).count\n          }\n        }\n      },\n      created() {\n        childInstance = this as any\n        childInstance.count\n      },\n      render() {\n        return h('h1', (this as any).count)\n      }\n    }\n\n    const App = {\n      setup() {\n        return () => h(Child)\n      },\n      updated: vi.fn()\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(App.updated).toHaveBeenCalledTimes(0)\n\n    childInstance.count++\n    await nextTick()\n    expect(App.updated).toHaveBeenCalledTimes(0)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not set the access cache in the data() function (production mode)","suites":["renderer: component","render with access caches"],"updatePoint":{"line":285,"column":82},"line":285,"code":"    test('should not set the access cache in the data() function (production mode)', () => {\n      const Comp = {\n        data() {\n          ;(this as any).foo\n          return { foo: 1 }\n        },\n        render() {\n          return h('h1', (this as any).foo)\n        }\n      }\n      const root = nodeOps.createElement('div')\n\n      __DEV__ = false\n      render(h(Comp), root)\n      __DEV__ = true\n      expect(serializeInner(root)).toBe(`<h1>1</h1>`)\n    })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"the component VNode should be cloned when reusing it","suites":["renderer: component","render with access caches"],"updatePoint":{"line":304,"column":60},"line":304,"code":"  test('the component VNode should be cloned when reusing it', () => {\n    const App = {\n      render() {\n        const c = [h(Comp)]\n        return [c, c, c]\n      }\n    }\n\n    const ids: number[] = []\n    const Comp = {\n      render: () => h('h1'),\n      beforeUnmount() {\n        ids.push((this as any).$.uid)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<h1></h1><h1></h1><h1></h1>`)\n\n    render(null, root)\n    expect(serializeInner(root)).toBe(``)\n    expect(ids).toEqual([ids[0], ids[0] + 1, ids[0] + 2])\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"child component props update should not lead to double update","suites":["renderer: component","render with access caches"],"updatePoint":{"line":329,"column":69},"line":329,"code":"  test('child component props update should not lead to double update', async () => {\n    const text = ref(0)\n    const spy = vi.fn()\n\n    const App = {\n      render() {\n        return h(Comp, { text: text.value })\n      }\n    }\n\n    const Comp = {\n      props: ['text'],\n      render(this: any) {\n        spy()\n        return h('h1', this.text)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<h1>0</h1>`)\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    text.value++\n    await nextTick()\n    expect(serializeInner(root)).toBe(`<h1>1</h1>`)\n    expect(spy).toHaveBeenCalledTimes(2)\n  })","file":"rendererComponent.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an element","suites":["renderer: element"],"updatePoint":{"line":16,"column":30},"line":16,"code":"  it('should create an element', () => {\n    render(h('div'), root)\n    expect(inner(root)).toBe('<div></div>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an element with props","suites":["renderer: element"],"updatePoint":{"line":21,"column":41},"line":21,"code":"  it('should create an element with props', () => {\n    render(h('div', { id: 'foo', class: 'bar' }), root)\n    expect(inner(root)).toBe('<div id=\"foo\" class=\"bar\"></div>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an element with direct text children","suites":["renderer: element"],"updatePoint":{"line":26,"column":56},"line":26,"code":"  it('should create an element with direct text children', () => {\n    render(h('div', ['foo', ' ', 'bar']), root)\n    expect(inner(root)).toBe('<div>foo bar</div>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should create an element with direct text children and props","suites":["renderer: element"],"updatePoint":{"line":31,"column":66},"line":31,"code":"  it('should create an element with direct text children and props', () => {\n    render(h('div', { id: 'foo' }, ['bar']), root)\n    expect(inner(root)).toBe('<div id=\"foo\">bar</div>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update an element tag which is already mounted","suites":["renderer: element"],"updatePoint":{"line":36,"column":59},"line":36,"code":"  it('should update an element tag which is already mounted', () => {\n    render(h('div', ['foo']), root)\n    expect(inner(root)).toBe('<div>foo</div>')\n\n    render(h('span', ['foo']), root)\n    expect(inner(root)).toBe('<span>foo</span>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should update element props which is already mounted","suites":["renderer: element"],"updatePoint":{"line":44,"column":58},"line":44,"code":"  it('should update element props which is already mounted', () => {\n    render(h('div', { id: 'bar' }, ['foo']), root)\n    expect(inner(root)).toBe('<div id=\"bar\">foo</div>')\n\n    render(h('div', { id: 'baz', class: 'bar' }, ['foo']), root)\n    expect(inner(root)).toBe('<div id=\"baz\" class=\"bar\">foo</div>')\n  })","file":"rendererElement.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should allow returning multiple component root nodes","suites":["renderer: fragment"],"updatePoint":{"line":22,"column":58},"line":22,"code":"  it('should allow returning multiple component root nodes', () => {\n    const App = {\n      render() {\n        return [h('div', 'one'), 'two']\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div>one</div>two`)\n    expect(root.children.length).toBe(4)\n    expect(root.children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: ''\n    })\n    expect(root.children[1]).toMatchObject({\n      type: TestNodeTypes.ELEMENT,\n      tag: 'div'\n    })\n    expect((root.children[1] as TestElement).children[0]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'one'\n    })\n    expect(root.children[2]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: 'two'\n    })\n    expect(root.children[3]).toMatchObject({\n      type: TestNodeTypes.TEXT,\n      text: ''\n    })\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"explicitly create fragments","suites":["renderer: fragment"],"updatePoint":{"line":56,"column":33},"line":56,"code":"  it('explicitly create fragments', () => {\n    const root = nodeOps.createElement('div')\n    render(h('div', [h(Fragment, [h('div', 'one'), 'two'])]), root)\n    const parent = root.children[0] as TestElement\n    expect(serializeInner(parent)).toBe(`<div>one</div>two`)\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"patch fragment children (manual, keyed)","suites":["renderer: fragment"],"updatePoint":{"line":63,"column":45},"line":63,"code":"  it('patch fragment children (manual, keyed)', () => {\n    const root = nodeOps.createElement('div')\n    render(\n      h(Fragment, [h('div', { key: 1 }, 'one'), h('div', { key: 2 }, 'two')]),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>one</div><div>two</div>`)\n\n    resetOps()\n    render(\n      h(Fragment, [h('div', { key: 2 }, 'two'), h('div', { key: 1 }, 'one')]),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>two</div><div>one</div>`)\n    const ops = dumpOps()\n    // should be moving nodes instead of re-creating or patching them\n    expect(ops).toMatchObject([\n      {\n        type: NodeOpTypes.INSERT\n      }\n    ])\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"patch fragment children (manual, unkeyed)","suites":["renderer: fragment"],"updatePoint":{"line":86,"column":47},"line":86,"code":"  it('patch fragment children (manual, unkeyed)', () => {\n    const root = nodeOps.createElement('div')\n    render(h(Fragment, [h('div', 'one'), h('div', 'two')]), root)\n    expect(serializeInner(root)).toBe(`<div>one</div><div>two</div>`)\n\n    resetOps()\n    render(h(Fragment, [h('div', 'two'), h('div', 'one')]), root)\n    expect(serializeInner(root)).toBe(`<div>two</div><div>one</div>`)\n    const ops = dumpOps()\n    // should be patching nodes instead of moving or re-creating them\n    expect(ops).toMatchObject([\n      {\n        type: NodeOpTypes.SET_ELEMENT_TEXT\n      },\n      {\n        type: NodeOpTypes.SET_ELEMENT_TEXT\n      }\n    ])\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"patch fragment children (compiler generated, unkeyed)","suites":["renderer: fragment"],"updatePoint":{"line":106,"column":59},"line":106,"code":"  it('patch fragment children (compiler generated, unkeyed)', () => {\n    const root = nodeOps.createElement('div')\n    render(\n      createVNode(\n        Fragment,\n        null,\n        [\n          createVNode('div', null, 'one', PatchFlags.TEXT),\n          createTextVNode('two')\n        ],\n        PatchFlags.UNKEYED_FRAGMENT\n      ),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>one</div>two`)\n\n    render(\n      createVNode(\n        Fragment,\n        null,\n        [\n          createVNode('div', null, 'foo', PatchFlags.TEXT),\n          createTextVNode('bar'),\n          createTextVNode('baz')\n        ],\n        PatchFlags.UNKEYED_FRAGMENT\n      ),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>foo</div>barbaz`)\n\n    render(\n      createVNode(\n        Fragment,\n        null,\n        [\n          createTextVNode('baz'),\n          createVNode('div', null, 'foo', PatchFlags.TEXT)\n        ],\n        PatchFlags.UNKEYED_FRAGMENT\n      ),\n      root\n    )\n    expect(serializeInner(root)).toBe(`baz<div>foo</div>`)\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"patch fragment children (compiler generated, keyed)","suites":["renderer: fragment"],"updatePoint":{"line":152,"column":57},"line":152,"code":"  it('patch fragment children (compiler generated, keyed)', () => {\n    const root = nodeOps.createElement('div')\n\n    render(\n      createVNode(\n        Fragment,\n        null,\n        [h('div', { key: 1 }, 'one'), h('div', { key: 2 }, 'two')],\n        PatchFlags.KEYED_FRAGMENT\n      ),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>one</div><div>two</div>`)\n\n    resetOps()\n    render(\n      createVNode(\n        Fragment,\n        null,\n        [h('div', { key: 2 }, 'two'), h('div', { key: 1 }, 'one')],\n        PatchFlags.KEYED_FRAGMENT\n      ),\n      root\n    )\n    expect(serializeInner(root)).toBe(`<div>two</div><div>one</div>`)\n    const ops = dumpOps()\n    // should be moving nodes instead of re-creating or patching them\n    expect(ops).toMatchObject([\n      {\n        type: NodeOpTypes.INSERT\n      }\n    ])\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"move fragment","suites":["renderer: fragment"],"updatePoint":{"line":186,"column":19},"line":186,"code":"  it('move fragment', () => {\n    const root = nodeOps.createElement('div')\n    render(\n      h('div', [\n        h('div', { key: 1 }, 'outer'),\n        h(Fragment, { key: 2 }, [\n          h('div', { key: 1 }, 'one'),\n          h('div', { key: 2 }, 'two')\n        ])\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toBe(\n      `<div><div>outer</div><div>one</div><div>two</div></div>`\n    )\n\n    resetOps()\n    render(\n      h('div', [\n        h(Fragment, { key: 2 }, [\n          h('div', { key: 2 }, 'two'),\n          h('div', { key: 1 }, 'one')\n        ]),\n        h('div', { key: 1 }, 'outer')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toBe(\n      `<div><div>two</div><div>one</div><div>outer</div></div>`\n    )\n    const ops = dumpOps()\n    // should be moving nodes instead of re-creating them\n    expect(ops).toMatchObject([\n      // 1. re-order inside the fragment\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      // 2. move entire fragment, including anchors\n      // not the most efficient move, but this case is super rare\n      // and optimizing for this special case complicates the algo quite a bit\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'text', text: '' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'text', text: '' } }\n    ])\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handle nested fragments","suites":["renderer: fragment"],"updatePoint":{"line":231,"column":29},"line":231,"code":"  it('handle nested fragments', () => {\n    const root = nodeOps.createElement('div')\n\n    render(\n      h(Fragment, [\n        h('div', { key: 1 }, 'outer'),\n        h(Fragment, { key: 2 }, [\n          h('div', { key: 1 }, 'one'),\n          h('div', { key: 2 }, 'two')\n        ])\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toBe(\n      `<div>outer</div><div>one</div><div>two</div>`\n    )\n\n    resetOps()\n    render(\n      h(Fragment, [\n        h(Fragment, { key: 2 }, [\n          h('div', { key: 2 }, 'two'),\n          h('div', { key: 1 }, 'one')\n        ]),\n        h('div', { key: 1 }, 'outer')\n      ]),\n      root\n    )\n    expect(serializeInner(root)).toBe(\n      `<div>two</div><div>one</div><div>outer</div>`\n    )\n    const ops = dumpOps()\n    // should be moving nodes instead of re-creating them\n    expect(ops).toMatchObject([\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'text', text: '' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'element' } },\n      { type: NodeOpTypes.INSERT, targetNode: { type: 'text', text: '' } }\n    ])\n\n    // should properly remove nested fragments\n    render(null, root)\n    expect(serializeInner(root)).toBe(``)\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"`template` keyed fragment w/ comment + hoisted node","suites":["renderer: fragment"],"updatePoint":{"line":278,"column":59},"line":278,"code":"  test('`template` keyed fragment w/ comment + hoisted node', () => {\n    const root = nodeOps.createElement('div')\n    const hoisted = h('span')\n\n    const renderFn = (items: string[]) => {\n      return (\n        openBlock(true),\n        createBlock(\n          Fragment,\n          null,\n          renderList(items, item => {\n            return (\n              openBlock(),\n              createBlock(\n                Fragment,\n                { key: item },\n                [\n                  createCommentVNode('comment'),\n                  hoisted,\n                  createVNode('div', null, item, PatchFlags.TEXT)\n                ],\n                PatchFlags.STABLE_FRAGMENT\n              )\n            )\n          }),\n          PatchFlags.KEYED_FRAGMENT\n        )\n      )\n    }\n\n    render(renderFn(['one', 'two']), root)\n    expect(serializeInner(root)).toBe(\n      `<!--comment--><span></span><div>one</div><!--comment--><span></span><div>two</div>`\n    )\n\n    render(renderFn(['two', 'one']), root)\n    expect(serializeInner(root)).toBe(\n      `<!--comment--><span></span><div>two</div><!--comment--><span></span><div>one</div>`\n    )\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"`template` keyed fragment w/ text","suites":["renderer: fragment"],"updatePoint":{"line":320,"column":41},"line":320,"code":"  test('`template` keyed fragment w/ text', () => {\n    const root = nodeOps.createElement('div')\n\n    const renderFn = (items: string[]) => {\n      return (\n        openBlock(true),\n        createBlock(\n          Fragment,\n          null,\n          renderList(items, item => {\n            return (\n              openBlock(),\n              createBlock(\n                Fragment,\n                { key: item },\n                [\n                  createTextVNode('text'),\n                  createVNode('div', null, item, PatchFlags.TEXT)\n                ],\n                PatchFlags.STABLE_FRAGMENT\n              )\n            )\n          }),\n          PatchFlags.KEYED_FRAGMENT\n        )\n      )\n    }\n\n    render(renderFn(['one', 'two']), root)\n    expect(serializeInner(root)).toBe(`text<div>one</div>text<div>two</div>`)\n\n    render(renderFn(['two', 'one']), root)\n    expect(serializeInner(root)).toBe(`text<div>two</div>text<div>one</div>`)\n  })","file":"rendererFragment.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"basic use of block","suites":["renderer: optimized mode"],"updatePoint":{"line":48,"column":26},"line":48,"code":"  test('basic use of block', () => {\n    render((openBlock(), (block = createBlock('p', null, 'foo'))), root)\n\n    expect(block.dynamicChildren!.length).toBe(0)\n    expect(inner(root)).toBe('<p>foo</p>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"block can appear anywhere in the vdom tree","suites":["renderer: optimized mode"],"updatePoint":{"line":55,"column":50},"line":55,"code":"  test('block can appear anywhere in the vdom tree', () => {\n    render(\n      h('div', (openBlock(), (block = createBlock('p', null, 'foo')))),\n      root\n    )\n\n    expect(block.dynamicChildren!.length).toBe(0)\n    expect(inner(root)).toBe('<div><p>foo</p></div>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"block should collect dynamic vnodes","suites":["renderer: optimized mode"],"updatePoint":{"line":65,"column":43},"line":65,"code":"  test('block should collect dynamic vnodes', () => {\n    renderWithBlock(() => [\n      createVNode('p', null, 'foo', PatchFlags.TEXT),\n      createVNode('i')\n    ])\n\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p>foo</p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"block can disable tracking","suites":["renderer: optimized mode"],"updatePoint":{"line":77,"column":34},"line":77,"code":"  test('block can disable tracking', () => {\n    render(\n      // disable tracking\n      (openBlock(true),\n      (block = createBlock('div', null, [\n        createVNode('p', null, 'foo', PatchFlags.TEXT)\n      ]))),\n      root\n    )\n\n    expect(block.dynamicChildren!.length).toBe(0)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"block as dynamic children","suites":["renderer: optimized mode"],"updatePoint":{"line":90,"column":33},"line":90,"code":"  test('block as dynamic children', () => {\n    renderWithBlock(() => [\n      (openBlock(), createBlock('div', { key: 0 }, [h('p')]))\n    ])\n\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(block!.dynamicChildren![0].dynamicChildren!.length).toBe(0)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<div><p></p></div>'\n    )\n\n    renderWithBlock(() => [\n      (openBlock(), createBlock('div', { key: 1 }, [h('i')]))\n    ])\n\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(block!.dynamicChildren![0].dynamicChildren!.length).toBe(0)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<div><i></i></div>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.TEXT","suites":["renderer: optimized mode"],"updatePoint":{"line":112,"column":35},"line":112,"code":"  test('PatchFlags: PatchFlags.TEXT', async () => {\n    renderWithBlock(() => [createVNode('p', null, 'foo', PatchFlags.TEXT)])\n\n    expect(inner(root)).toBe('<div><p>foo</p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p>foo</p>'\n    )\n\n    renderWithBlock(() => [createVNode('p', null, 'bar', PatchFlags.TEXT)])\n\n    expect(inner(root)).toBe('<div><p>bar</p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p>bar</p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.CLASS","suites":["renderer: optimized mode"],"updatePoint":{"line":130,"column":36},"line":130,"code":"  test('PatchFlags: PatchFlags.CLASS', async () => {\n    renderWithBlock(() => [\n      createVNode('p', { class: 'foo' }, '', PatchFlags.CLASS)\n    ])\n\n    expect(inner(root)).toBe('<div><p class=\"foo\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p class=\"foo\"></p>'\n    )\n\n    renderWithBlock(() => [\n      createVNode('p', { class: 'bar' }, '', PatchFlags.CLASS)\n    ])\n\n    expect(inner(root)).toBe('<div><p class=\"bar\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p class=\"bar\"></p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.STYLE","suites":["renderer: optimized mode"],"updatePoint":{"line":152,"column":36},"line":152,"code":"  test('PatchFlags: PatchFlags.STYLE', async () => {\n    renderWithBlock(() => [\n      createVNode('p', { style: 'color: red' }, '', PatchFlags.STYLE)\n    ])\n\n    expect(inner(root)).toBe('<div><p style=\"color: red\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p style=\"color: red\"></p>'\n    )\n\n    renderWithBlock(() => [\n      createVNode('p', { style: 'color: green' }, '', PatchFlags.STYLE)\n    ])\n\n    expect(inner(root)).toBe('<div><p style=\"color: green\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p style=\"color: green\"></p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.PROPS","suites":["renderer: optimized mode"],"updatePoint":{"line":174,"column":36},"line":174,"code":"  test('PatchFlags: PatchFlags.PROPS', async () => {\n    renderWithBlock(() => [\n      createVNode('p', { id: 'foo' }, '', PatchFlags.PROPS, ['id'])\n    ])\n\n    expect(inner(root)).toBe('<div><p id=\"foo\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p id=\"foo\"></p>'\n    )\n\n    renderWithBlock(() => [\n      createVNode('p', { id: 'bar' }, '', PatchFlags.PROPS, ['id'])\n    ])\n\n    expect(inner(root)).toBe('<div><p id=\"bar\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p id=\"bar\"></p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.FULL_PROPS","suites":["renderer: optimized mode"],"updatePoint":{"line":196,"column":41},"line":196,"code":"  test('PatchFlags: PatchFlags.FULL_PROPS', async () => {\n    let propName = 'foo'\n\n    renderWithBlock(() => [\n      createVNode('p', { [propName]: 'dynamic' }, '', PatchFlags.FULL_PROPS)\n    ])\n\n    expect(inner(root)).toBe('<div><p foo=\"dynamic\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p foo=\"dynamic\"></p>'\n    )\n\n    propName = 'bar'\n    renderWithBlock(() => [\n      createVNode('p', { [propName]: 'dynamic' }, '', PatchFlags.FULL_PROPS)\n    ])\n\n    expect(inner(root)).toBe('<div><p bar=\"dynamic\"></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p bar=\"dynamic\"></p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.STABLE_FRAGMENT","suites":["renderer: optimized mode"],"updatePoint":{"line":222,"column":46},"line":222,"code":"  test('PatchFlags: PatchFlags.STABLE_FRAGMENT', async () => {\n    let list = ['foo', 'bar']\n    render(\n      (openBlock(),\n      (block = createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode('p', null, item, PatchFlags.TEXT)\n        }),\n        PatchFlags.STABLE_FRAGMENT\n      ))),\n      root\n    )\n\n    expect(inner(root)).toBe('<p>foo</p><p>bar</p>')\n    expect(block.dynamicChildren!.length).toBe(2)\n    expect(serialize(block.dynamicChildren![0].el as TestElement)).toBe(\n      '<p>foo</p>'\n    )\n    expect(serialize(block.dynamicChildren![1].el as TestElement)).toBe(\n      '<p>bar</p>'\n    )\n\n    list = list.map(item => item.repeat(2))\n    render(\n      (openBlock(),\n      createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode('p', null, item, PatchFlags.TEXT)\n        }),\n        PatchFlags.STABLE_FRAGMENT\n      )),\n      root\n    )\n\n    expect(inner(root)).toBe('<p>foofoo</p><p>barbar</p>')\n    expect(block.dynamicChildren!.length).toBe(2)\n    expect(serialize(block.dynamicChildren![0].el as TestElement)).toBe(\n      '<p>foofoo</p>'\n    )\n    expect(serialize(block.dynamicChildren![1].el as TestElement)).toBe(\n      '<p>barbar</p>'\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.UNKEYED_FRAGMENT","suites":["renderer: optimized mode"],"updatePoint":{"line":272,"column":47},"line":272,"code":"  test('PatchFlags: PatchFlags.UNKEYED_FRAGMENT', async () => {\n    const list = [{ tag: 'p', text: 'foo' }]\n    render(\n      (openBlock(true),\n      (block = createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode(item.tag, null, item.text)\n        }),\n        PatchFlags.UNKEYED_FRAGMENT\n      ))),\n      root\n    )\n\n    expect(inner(root)).toBe('<p>foo</p>')\n    expect(block.dynamicChildren!.length).toBe(0)\n\n    list.unshift({ tag: 'i', text: 'bar' })\n    render(\n      (openBlock(true),\n      createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode(item.tag, null, item.text)\n        }),\n        PatchFlags.UNKEYED_FRAGMENT\n      )),\n      root\n    )\n\n    expect(inner(root)).toBe('<i>bar</i><p>foo</p>')\n    expect(block.dynamicChildren!.length).toBe(0)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.KEYED_FRAGMENT","suites":["renderer: optimized mode"],"updatePoint":{"line":310,"column":45},"line":310,"code":"  test('PatchFlags: PatchFlags.KEYED_FRAGMENT', async () => {\n    const list = [{ tag: 'p', text: 'foo' }]\n    render(\n      (openBlock(true),\n      (block = createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode(item.tag, { key: item.tag }, item.text)\n        }),\n        PatchFlags.KEYED_FRAGMENT\n      ))),\n      root\n    )\n\n    expect(inner(root)).toBe('<p>foo</p>')\n    expect(block.dynamicChildren!.length).toBe(0)\n\n    list.unshift({ tag: 'i', text: 'bar' })\n    render(\n      (openBlock(true),\n      createBlock(\n        Fragment,\n        null,\n        list.map(item => {\n          return createVNode(item.tag, { key: item.tag }, item.text)\n        }),\n        PatchFlags.KEYED_FRAGMENT\n      )),\n      root\n    )\n\n    expect(inner(root)).toBe('<i>bar</i><p>foo</p>')\n    expect(block.dynamicChildren!.length).toBe(0)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.NEED_PATCH","suites":["renderer: optimized mode"],"updatePoint":{"line":346,"column":41},"line":346,"code":"  test('PatchFlags: PatchFlags.NEED_PATCH', async () => {\n    const spyMounted = vi.fn()\n    const spyUpdated = vi.fn()\n    const count = ref(0)\n    const Comp = {\n      setup() {\n        return () => {\n          count.value\n          return (\n            openBlock(),\n            (block = createBlock('div', null, [\n              createVNode(\n                'p',\n                { onVnodeMounted: spyMounted, onVnodeBeforeUpdate: spyUpdated },\n                '',\n                PatchFlags.NEED_PATCH\n              )\n            ]))\n          )\n        }\n      }\n    }\n\n    render(h(Comp), root)\n\n    expect(inner(root)).toBe('<div><p></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p></p>'\n    )\n    expect(spyMounted).toHaveBeenCalledTimes(1)\n    expect(spyUpdated).toHaveBeenCalledTimes(0)\n\n    count.value++\n    await nextTick()\n\n    expect(inner(root)).toBe('<div><p></p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(serialize(block!.dynamicChildren![0].el as TestElement)).toBe(\n      '<p></p>'\n    )\n    expect(spyMounted).toHaveBeenCalledTimes(1)\n    expect(spyUpdated).toHaveBeenCalledTimes(1)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"PatchFlags: PatchFlags.BAIL","suites":["renderer: optimized mode"],"updatePoint":{"line":391,"column":35},"line":391,"code":"  test('PatchFlags: PatchFlags.BAIL', async () => {\n    render(\n      (openBlock(),\n      (block = createBlock('div', null, [createVNode('p', null, 'foo')]))),\n      root\n    )\n\n    expect(inner(root)).toBe('<div><p>foo</p></div>')\n    expect(block!.dynamicChildren!.length).toBe(0)\n\n    render(\n      (openBlock(),\n      (block = createBlock(\n        'div',\n        null,\n        [createVNode('i', null, 'bar')],\n        PatchFlags.BAIL\n      ))),\n      root\n    )\n\n    expect(inner(root)).toBe('<div><i>bar</i></div>')\n    expect(block!.dynamicChildren).toBe(null)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"dynamicChildren should be tracked correctly when normalizing slots to plain children","suites":["renderer: optimized mode"],"updatePoint":{"line":417,"column":92},"line":417,"code":"  test('dynamicChildren should be tracked correctly when normalizing slots to plain children', async () => {\n    let block: VNode\n    const Comp = defineComponent({\n      setup(_props, { slots }) {\n        return () => {\n          const vnode =\n            (openBlock(),\n            (block = createBlock('div', null, {\n              default: withCtx(() => [renderSlot(slots, 'default')]),\n              _: SlotFlags.FORWARDED\n            })))\n\n          return vnode\n        }\n      }\n    })\n\n    const foo = ref(0)\n    const App = {\n      setup() {\n        return () => {\n          return createVNode(Comp, null, {\n            default: withCtx(() => [\n              createVNode('p', null, foo.value, PatchFlags.TEXT)\n            ]),\n            // Indicates that this is a stable slot to avoid bail out\n            _: SlotFlags.STABLE\n          })\n        }\n      }\n    }\n\n    render(h(App), root)\n    expect(inner(root)).toBe('<div><p>0</p></div>')\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(block!.dynamicChildren![0].type).toBe(Fragment)\n    expect(block!.dynamicChildren![0].dynamicChildren!.length).toBe(1)\n    expect(\n      serialize(\n        block!.dynamicChildren![0].dynamicChildren![0].el as TestElement\n      )\n    ).toBe('<p>0</p>')\n\n    foo.value++\n    await nextTick()\n\n    expect(inner(root)).toBe('<div><p>1</p></div>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not perform unnecessary unmount traversals","suites":["renderer: optimized mode"],"updatePoint":{"line":472,"column":57},"line":472,"code":"  test('should not perform unnecessary unmount traversals', () => {\n    const spy = vi.fn()\n    const Child = {\n      setup() {\n        onBeforeUnmount(spy)\n        return () => 'child'\n      }\n    }\n    const Parent = () => (\n      openBlock(),\n      createBlock('div', null, [\n        createVNode('div', { style: {} }, [createVNode(Child)], 4 /* STYLE */)\n      ])\n    )\n    render(h(Parent), root)\n    render(null, root)\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"non-stable Fragment always need to diff its children","suites":["renderer: optimized mode"],"updatePoint":{"line":493,"column":60},"line":493,"code":"  test('non-stable Fragment always need to diff its children', () => {\n    const spyA = vi.fn()\n    const spyB = vi.fn()\n    const ChildA = {\n      setup() {\n        onBeforeUnmount(spyA)\n        return () => 'child'\n      }\n    }\n    const ChildB = {\n      setup() {\n        onBeforeUnmount(spyB)\n        return () => 'child'\n      }\n    }\n    const Parent = () => (\n      openBlock(),\n      createBlock('div', null, [\n        (openBlock(true),\n        createBlock(\n          Fragment,\n          null,\n          [createVNode(ChildA, { key: 0 })],\n          128 /* KEYED_FRAGMENT */\n        )),\n        (openBlock(true),\n        createBlock(\n          Fragment,\n          null,\n          [createVNode(ChildB)],\n          256 /* UNKEYED_FRAGMENT */\n        ))\n      ])\n    )\n    render(h(Parent), root)\n    render(null, root)\n    expect(spyA).toHaveBeenCalledTimes(1)\n    expect(spyB).toHaveBeenCalledTimes(1)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"manually rendering the optimized slots should allow subsequent updates to exit the optimized mode correctly","suites":["renderer: optimized mode"],"updatePoint":{"line":534,"column":115},"line":534,"code":"  test('manually rendering the optimized slots should allow subsequent updates to exit the optimized mode correctly', async () => {\n    const state = ref(0)\n\n    const CompA = {\n      setup(props: any, { slots }: SetupContext) {\n        return () => {\n          return (\n            openBlock(),\n            createBlock('div', null, [renderSlot(slots, 'default')])\n          )\n        }\n      }\n    }\n\n    const Wrapper = {\n      setup(props: any, { slots }: SetupContext) {\n        // use the manually written render function to rendering the optimized slots,\n        // which should make subsequent updates exit the optimized mode correctly\n        return () => {\n          return slots.default!()[state.value]\n        }\n      }\n    }\n\n    const app = createApp({\n      setup() {\n        return () => {\n          return (\n            openBlock(),\n            createBlock(Wrapper, null, {\n              default: withCtx(() => [\n                createVNode(CompA, null, {\n                  default: withCtx(() => [createTextVNode('Hello')]),\n                  _: 1 /* STABLE */\n                }),\n                createVNode(CompA, null, {\n                  default: withCtx(() => [createTextVNode('World')]),\n                  _: 1 /* STABLE */\n                })\n              ]),\n              _: 1 /* STABLE */\n            })\n          )\n        }\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<div>Hello</div>')\n\n    state.value = 1\n    await nextTick()\n    expect(inner(root)).toBe('<div>World</div>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested teleport unmount need exit the optimization mode","suites":["renderer: optimized mode"],"updatePoint":{"line":590,"column":63},"line":590,"code":"  test('nested teleport unmount need exit the optimization mode', () => {\n    const target = nodeOps.createElement('div')\n    const root = nodeOps.createElement('div')\n\n    render(\n      (openBlock(),\n      createBlock('div', null, [\n        (openBlock(),\n        createBlock(\n          Teleport as any,\n          {\n            to: target\n          },\n          [\n            createVNode('div', null, [\n              (openBlock(),\n              createBlock(\n                Teleport as any,\n                {\n                  to: target\n                },\n                [createVNode('div', null, 'foo')]\n              ))\n            ])\n          ]\n        ))\n      ])),\n      root\n    )\n    expect(inner(target)).toMatchInlineSnapshot(\n      `\"<div><!--teleport start--><!--teleport end--></div><div>foo</div>\"`\n    )\n    expect(inner(root)).toMatchInlineSnapshot(\n      `\"<div><!--teleport start--><!--teleport end--></div>\"`\n    )\n\n    render(null, root)\n    expect(inner(target)).toBe('')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not track dynamic children when the user calls a compiled slot inside template expression","suites":["renderer: optimized mode"],"updatePoint":{"line":631,"column":104},"line":631,"code":"  test('should not track dynamic children when the user calls a compiled slot inside template expression', () => {\n    const Comp = {\n      setup(props: any, { slots }: SetupContext) {\n        return () => {\n          return (\n            openBlock(),\n            (block = createBlock('section', null, [\n              renderSlot(slots, 'default')\n            ]))\n          )\n        }\n      }\n    }\n\n    let dynamicVNode: VNode\n    const Wrapper = {\n      setup(props: any, { slots }: SetupContext) {\n        return () => {\n          return (\n            openBlock(),\n            createBlock(Comp, null, {\n              default: withCtx(() => {\n                return [\n                  (dynamicVNode = createVNode(\n                    'div',\n                    {\n                      class: {\n                        foo: !!slots.default!()\n                      }\n                    },\n                    null,\n                    PatchFlags.CLASS\n                  ))\n                ]\n              }),\n              _: 1\n            })\n          )\n        }\n      }\n    }\n    const app = createApp({\n      render() {\n        return (\n          openBlock(),\n          createBlock(Wrapper, null, {\n            default: withCtx(() => {\n              return [createVNode({}) /* component */]\n            }),\n            _: 1\n          })\n        )\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<section><div class=\"foo\"></div></section>')\n    /**\n     * Block Tree:\n     *  - block(div)\n     *   - block(Fragment): renderSlots()\n     *    - dynamicVNode\n     */\n    expect(block!.dynamicChildren!.length).toBe(1)\n    expect(block!.dynamicChildren![0].dynamicChildren!.length).toBe(1)\n    expect(block!.dynamicChildren![0].dynamicChildren![0]).toEqual(\n      dynamicVNode!\n    )\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should force bailout when the user manually calls the slot function","suites":["renderer: optimized mode"],"updatePoint":{"line":702,"column":75},"line":702,"code":"  test('should force bailout when the user manually calls the slot function', async () => {\n    const index = ref(0)\n    const Foo = {\n      setup(props: any, { slots }: SetupContext) {\n        return () => {\n          return slots.default!()[index.value]\n        }\n      }\n    }\n\n    const app = createApp({\n      setup() {\n        return () => {\n          return (\n            openBlock(),\n            createBlock(Foo, null, {\n              default: withCtx(() => [\n                true\n                  ? (openBlock(), createBlock('p', { key: 0 }, '1'))\n                  : createCommentVNode('v-if', true),\n                true\n                  ? (openBlock(), createBlock('p', { key: 0 }, '2'))\n                  : createCommentVNode('v-if', true)\n              ]),\n              _: 1 /* STABLE */\n            })\n          )\n        }\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<p>1</p>')\n\n    index.value = 1\n    await nextTick()\n    expect(inner(root)).toBe('<p>2</p>')\n\n    index.value = 0\n    await nextTick()\n    expect(inner(root)).toBe('<p>1</p>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"treat slots manually written by the user as dynamic","suites":["renderer: optimized mode"],"updatePoint":{"line":746,"column":59},"line":746,"code":"  test('treat slots manually written by the user as dynamic', async () => {\n    const Middle = {\n      setup(props: any, { slots }: any) {\n        return slots.default!\n      }\n    }\n\n    const Comp = {\n      setup(props: any, { slots }: any) {\n        return () => {\n          return (\n            openBlock(),\n            createBlock('div', null, [\n              createVNode(Middle, null, {\n                default: withCtx(\n                  () => [\n                    createVNode('div', null, [renderSlot(slots, 'default')])\n                  ],\n                  undefined\n                ),\n                _: 3 /* FORWARDED */\n              })\n            ])\n          )\n        }\n      }\n    }\n\n    const loading = ref(false)\n    const app = createApp({\n      setup() {\n        return () => {\n          // important: write the slot content here\n          const content = h('span', loading.value ? 'loading' : 'loaded')\n          return h(Comp, null, {\n            default: () => content\n          })\n        }\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<div><div><span>loaded</span></div></div>')\n\n    loading.value = true\n    await nextTick()\n    expect(inner(root)).toBe('<div><div><span>loading</span></div></div>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"patch Suspense in optimized mode w/ nested dynamic nodes","suites":["renderer: optimized mode"],"updatePoint":{"line":796,"column":64},"line":796,"code":"  test('patch Suspense in optimized mode w/ nested dynamic nodes', async () => {\n    const show = ref(false)\n\n    const app = createApp({\n      render() {\n        return (\n          openBlock(),\n          createBlock(\n            Fragment,\n            null,\n            [\n              (openBlock(),\n              createBlock(SuspenseImpl, null, {\n                default: withCtx(() => [\n                  createVNode('div', null, [\n                    createVNode('div', null, show.value, PatchFlags.TEXT)\n                  ])\n                ]),\n                _: SlotFlags.STABLE\n              }))\n            ],\n            PatchFlags.STABLE_FRAGMENT\n          )\n        )\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<div><div>false</div></div>')\n\n    show.value = true\n    await nextTick()\n    expect(inner(root)).toBe('<div><div>true</div></div>')\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not take unmount children fast path /w Suspense","suites":["renderer: optimized mode"],"updatePoint":{"line":832,"column":62},"line":832,"code":"  test('should not take unmount children fast path /w Suspense', async () => {\n    const show = ref(true)\n    const spyUnmounted = vi.fn()\n\n    const Parent = {\n      setup(props: any, { slots }: SetupContext) {\n        return () => (\n          openBlock(),\n          createBlock(SuspenseImpl, null, {\n            default: withCtx(() => [renderSlot(slots, 'default')]),\n            _: SlotFlags.FORWARDED\n          })\n        )\n      }\n    }\n\n    const Child = {\n      setup() {\n        onUnmounted(spyUnmounted)\n        return () => createVNode('div', null, show.value, PatchFlags.TEXT)\n      }\n    }\n\n    const app = createApp({\n      render() {\n        return show.value\n          ? (openBlock(),\n            createBlock(\n              Parent,\n              { key: 0 },\n              {\n                default: withCtx(() => [createVNode(Child)]),\n                _: SlotFlags.STABLE\n              }\n            ))\n          : createCommentVNode('v-if', true)\n      }\n    })\n\n    app.mount(root)\n    expect(inner(root)).toBe('<div>true</div>')\n\n    show.value = false\n    await nextTick()\n    expect(inner(root)).toBe('<!--v-if-->')\n    expect(spyUnmounted).toHaveBeenCalledTimes(1)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"fragments inside programmatically invoked compiled slot should de-opt properly","suites":["renderer: optimized mode"],"updatePoint":{"line":885,"column":86},"line":885,"code":"  test('fragments inside programmatically invoked compiled slot should de-opt properly', async () => {\n    const Parent: FunctionalComponent = (_, { slots }) => slots.default!()\n    const Dummy = () => 'dummy'\n\n    const toggle = ref(true)\n    const force = ref(0)\n\n    const app = createApp({\n      render() {\n        if (!toggle.value) {\n          return null\n        }\n        return h(\n          Parent,\n          { n: force.value },\n          {\n            default: withCtx(\n              () => [\n                createVNode('ul', null, [\n                  (openBlock(),\n                  createBlock(\n                    Fragment,\n                    null,\n                    renderList(1, item => {\n                      return createVNode('li', null, [createVNode(Dummy)])\n                    }),\n                    64 /* STABLE_FRAGMENT */\n                  ))\n                ])\n              ],\n              undefined,\n              true\n            ),\n            _: 1 /* STABLE */\n          }\n        )\n      }\n    })\n\n    app.mount(root)\n\n    // force a patch\n    force.value++\n    await nextTick()\n    expect(inner(root)).toBe(`<ul><li>dummy</li></ul>`)\n\n    // unmount\n    toggle.value = false\n    await nextTick()\n    // should successfully unmount without error\n    expect(inner(root)).toBe(`<!---->`)\n  })","file":"rendererOptimizedMode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string ref mount","suites":["api: template refs"],"updatePoint":{"line":17,"column":22},"line":17,"code":"  it('string ref mount', () => {\n    const root = nodeOps.createElement('div')\n    const el = ref(null)\n\n    const Comp = {\n      setup() {\n        return {\n          refKey: el\n        }\n      },\n      render() {\n        return h('div', { ref: 'refKey' })\n      }\n    }\n    render(h(Comp), root)\n    expect(el.value).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string ref update","suites":["api: template refs"],"updatePoint":{"line":35,"column":23},"line":35,"code":"  it('string ref update', async () => {\n    const root = nodeOps.createElement('div')\n    const fooEl = ref(null)\n    const barEl = ref(null)\n    const refKey = ref('foo')\n\n    const Comp = {\n      setup() {\n        return {\n          foo: fooEl,\n          bar: barEl\n        }\n      },\n      render() {\n        return h('div', { ref: refKey.value })\n      }\n    }\n    render(h(Comp), root)\n    expect(fooEl.value).toBe(root.children[0])\n    expect(barEl.value).toBe(null)\n\n    refKey.value = 'bar'\n    await nextTick()\n    expect(fooEl.value).toBe(null)\n    expect(barEl.value).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string ref unmount","suites":["api: template refs"],"updatePoint":{"line":62,"column":24},"line":62,"code":"  it('string ref unmount', async () => {\n    const root = nodeOps.createElement('div')\n    const el = ref(null)\n    const toggle = ref(true)\n\n    const Comp = {\n      setup() {\n        return {\n          refKey: el\n        }\n      },\n      render() {\n        return toggle.value ? h('div', { ref: 'refKey' }) : null\n      }\n    }\n    render(h(Comp), root)\n    expect(el.value).toBe(root.children[0])\n\n    toggle.value = false\n    await nextTick()\n    expect(el.value).toBe(null)\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"function ref mount","suites":["api: template refs"],"updatePoint":{"line":85,"column":24},"line":85,"code":"  it('function ref mount', () => {\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn()\n\n    const Comp = defineComponent(() => () => h('div', { ref: fn }))\n    render(h(Comp), root)\n    expect(fn.mock.calls[0][0]).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"function ref update","suites":["api: template refs"],"updatePoint":{"line":94,"column":25},"line":94,"code":"  it('function ref update', async () => {\n    const root = nodeOps.createElement('div')\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n    const fn = ref(fn1)\n\n    const Comp = defineComponent(() => () => h('div', { ref: fn.value }))\n\n    render(h(Comp), root)\n    expect(fn1.mock.calls).toHaveLength(1)\n    expect(fn1.mock.calls[0][0]).toBe(root.children[0])\n    expect(fn2.mock.calls).toHaveLength(0)\n\n    fn.value = fn2\n    await nextTick()\n    expect(fn1.mock.calls).toHaveLength(1)\n    expect(fn2.mock.calls).toHaveLength(1)\n    expect(fn2.mock.calls[0][0]).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"function ref unmount","suites":["api: template refs"],"updatePoint":{"line":114,"column":26},"line":114,"code":"  it('function ref unmount', async () => {\n    const root = nodeOps.createElement('div')\n    const fn = vi.fn()\n    const toggle = ref(true)\n\n    const Comp = defineComponent(\n      () => () => toggle.value ? h('div', { ref: fn }) : null\n    )\n    render(h(Comp), root)\n    expect(fn.mock.calls[0][0]).toBe(root.children[0])\n    toggle.value = false\n    await nextTick()\n    expect(fn.mock.calls[1][0]).toBe(null)\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"render function ref mount","suites":["api: template refs"],"updatePoint":{"line":129,"column":31},"line":129,"code":"  it('render function ref mount', () => {\n    const root = nodeOps.createElement('div')\n    const el = ref(null)\n\n    const Comp = {\n      setup() {\n        return () => h('div', { ref: el })\n      }\n    }\n    render(h(Comp), root)\n    expect(el.value).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"render function ref update","suites":["api: template refs"],"updatePoint":{"line":142,"column":32},"line":142,"code":"  it('render function ref update', async () => {\n    const root = nodeOps.createElement('div')\n    const refs = {\n      foo: ref(null),\n      bar: ref(null)\n    }\n    const refKey = ref<keyof typeof refs>('foo')\n\n    const Comp = {\n      setup() {\n        return () => h('div', { ref: refs[refKey.value] })\n      }\n    }\n    render(h(Comp), root)\n    expect(refs.foo.value).toBe(root.children[0])\n    expect(refs.bar.value).toBe(null)\n\n    refKey.value = 'bar'\n    await nextTick()\n    expect(refs.foo.value).toBe(null)\n    expect(refs.bar.value).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"render function ref unmount","suites":["api: template refs"],"updatePoint":{"line":165,"column":33},"line":165,"code":"  it('render function ref unmount', async () => {\n    const root = nodeOps.createElement('div')\n    const el = ref(null)\n    const toggle = ref(true)\n\n    const Comp = {\n      setup() {\n        return () => (toggle.value ? h('div', { ref: el }) : null)\n      }\n    }\n    render(h(Comp), root)\n    expect(el.value).toBe(root.children[0])\n\n    toggle.value = false\n    await nextTick()\n    expect(el.value).toBe(null)\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string ref inside slots","suites":["api: template refs"],"updatePoint":{"line":183,"column":31},"line":183,"code":"  test('string ref inside slots', async () => {\n    const root = nodeOps.createElement('div')\n    const spy = vi.fn()\n    const Child = {\n      render(this: any) {\n        return this.$slots.default()\n      }\n    }\n\n    const Comp = {\n      render() {\n        return h(Child, () => {\n          return h('div', { ref: 'foo' })\n        })\n      },\n      mounted(this: any) {\n        spy(this.$refs.foo.tag)\n      }\n    }\n    render(h(Comp), root)\n\n    expect(spy).toHaveBeenCalledWith('div')\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work with direct reactive property","suites":["api: template refs"],"updatePoint":{"line":207,"column":47},"line":207,"code":"  it('should work with direct reactive property', () => {\n    const root = nodeOps.createElement('div')\n    const state = reactive({\n      refKey: null\n    })\n\n    const Comp = {\n      setup() {\n        return state\n      },\n      render() {\n        return h('div', { ref: 'refKey' })\n      }\n    }\n    render(h(Comp), root)\n    expect(state.refKey).toBe(root.children[0])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"multiple root refs","suites":["api: template refs"],"updatePoint":{"line":225,"column":26},"line":225,"code":"  test('multiple root refs', () => {\n    const root = nodeOps.createElement('div')\n    const refKey1 = ref(null)\n    const refKey2 = ref(null)\n    const refKey3 = ref(null)\n\n    const Comp = {\n      setup() {\n        return {\n          refKey1,\n          refKey2,\n          refKey3\n        }\n      },\n      render() {\n        return [\n          h('div', { ref: 'refKey1' }),\n          h('div', { ref: 'refKey2' }),\n          h('div', { ref: 'refKey3' })\n        ]\n      }\n    }\n    render(h(Comp), root)\n    expect(refKey1.value).toBe(root.children[1])\n    expect(refKey2.value).toBe(root.children[2])\n    expect(refKey3.value).toBe(root.children[3])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"reactive template ref in the same template","suites":["api: template refs"],"updatePoint":{"line":254,"column":50},"line":254,"code":"  test('reactive template ref in the same template', async () => {\n    const Comp = {\n      setup() {\n        const el = ref()\n        return { el }\n      },\n      render(this: any) {\n        return h('div', { id: 'foo', ref: 'el' }, this.el && this.el.props.id)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n    // ref not ready on first render, but should queue an update immediately\n    expect(serializeInner(root)).toBe(`<div id=\"foo\"></div>`)\n    await nextTick()\n    // ref should be updated\n    expect(serializeInner(root)).toBe(`<div id=\"foo\">foo</div>`)\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"exchange refs","suites":["api: template refs"],"updatePoint":{"line":275,"column":21},"line":275,"code":"  test('exchange refs', async () => {\n    const refToggle = ref(false)\n    const spy = vi.fn()\n\n    const Comp = {\n      render(this: any) {\n        return [\n          h('p', { ref: refToggle.value ? 'foo' : 'bar' }),\n          h('i', { ref: refToggle.value ? 'bar' : 'foo' })\n        ]\n      },\n      mounted(this: any) {\n        spy(this.$refs.foo.tag, this.$refs.bar.tag)\n      },\n      updated(this: any) {\n        spy(this.$refs.foo.tag, this.$refs.bar.tag)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    expect(spy.mock.calls[0][0]).toBe('i')\n    expect(spy.mock.calls[0][1]).toBe('p')\n    refToggle.value = true\n    await nextTick()\n    expect(spy.mock.calls[1][0]).toBe('p')\n    expect(spy.mock.calls[1][1]).toBe('i')\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"toggle the same ref to different elements","suites":["api: template refs"],"updatePoint":{"line":306,"column":49},"line":306,"code":"  test('toggle the same ref to different elements', async () => {\n    const refToggle = ref(false)\n    const spy = vi.fn()\n\n    const Comp = {\n      render(this: any) {\n        return refToggle.value ? h('p', { ref: 'foo' }) : h('i', { ref: 'foo' })\n      },\n      mounted(this: any) {\n        spy(this.$refs.foo.tag)\n      },\n      updated(this: any) {\n        spy(this.$refs.foo.tag)\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Comp), root)\n\n    expect(spy.mock.calls[0][0]).toBe('i')\n    refToggle.value = true\n    await nextTick()\n    expect(spy.mock.calls[1][0]).toBe('p')\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handling multiple merged refs","suites":["api: template refs"],"updatePoint":{"line":332,"column":37},"line":332,"code":"  test('handling multiple merged refs', async () => {\n    const Foo = {\n      render: () => h('div', 'foo')\n    }\n    const Bar = {\n      render: () => h('div', 'bar')\n    }\n\n    const viewRef = shallowRef<any>(Foo)\n    const elRef1 = ref()\n    const elRef2 = ref()\n\n    const App = {\n      render() {\n        if (!viewRef.value) {\n          return null\n        }\n        const view = h(viewRef.value, { ref: elRef1 })\n        return h(view, { ref: elRef2 })\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(elRef1.value.$el)).toBe('foo')\n    expect(elRef1.value).toBe(elRef2.value)\n\n    viewRef.value = Bar\n    await nextTick()\n    expect(serializeInner(elRef1.value.$el)).toBe('bar')\n    expect(elRef1.value).toBe(elRef2.value)\n\n    viewRef.value = null\n    await nextTick()\n    expect(elRef1.value).toBeNull()\n    expect(elRef1.value).toBe(elRef2.value)\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"raw ref with ref_key","suites":["api: template refs"],"updatePoint":{"line":371,"column":28},"line":371,"code":"  test('raw ref with ref_key', () => {\n    let refs: any\n\n    const el = ref()\n\n    const App = {\n      mounted() {\n        refs = (this as any).$refs\n      },\n      render() {\n        return h(\n          'div',\n          {\n            ref: el,\n            ref_key: 'el'\n          },\n          'hello'\n        )\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(el.value)).toBe('hello')\n    expect(serializeInner(refs.el)).toBe('hello')\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"ref in v-for","suites":["api: template refs"],"updatePoint":{"line":399,"column":20},"line":399,"code":"  test('ref in v-for', async () => {\n    const show = ref(true)\n    const list = reactive([1, 2, 3])\n    const listRefs = ref([])\n    const mapRefs = () => listRefs.value.map(n => serializeInner(n))\n\n    const App = {\n      render() {\n        return show.value\n          ? h(\n              'ul',\n              list.map(i =>\n                h(\n                  'li',\n                  {\n                    ref: listRefs,\n                    ref_for: true\n                  },\n                  i\n                )\n              )\n            )\n          : null\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(mapRefs()).toMatchObject(['1', '2', '3'])\n\n    list.push(4)\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['1', '2', '3', '4'])\n\n    list.shift()\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['2', '3', '4'])\n\n    show.value = !show.value\n    await nextTick()\n\n    expect(mapRefs()).toMatchObject([])\n\n    show.value = !show.value\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['2', '3', '4'])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"named ref in v-for","suites":["api: template refs"],"updatePoint":{"line":447,"column":26},"line":447,"code":"  test('named ref in v-for', async () => {\n    const show = ref(true)\n    const list = reactive([1, 2, 3])\n    const listRefs = ref([])\n    const mapRefs = () => listRefs.value.map(n => serializeInner(n))\n\n    const App = {\n      setup() {\n        return { listRefs }\n      },\n      render() {\n        return show.value\n          ? h(\n              'ul',\n              list.map(i =>\n                h(\n                  'li',\n                  {\n                    ref: 'listRefs',\n                    ref_for: true\n                  },\n                  i\n                )\n              )\n            )\n          : null\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(mapRefs()).toMatchObject(['1', '2', '3'])\n\n    list.push(4)\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['1', '2', '3', '4'])\n\n    list.shift()\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['2', '3', '4'])\n\n    show.value = !show.value\n    await nextTick()\n\n    expect(mapRefs()).toMatchObject([])\n\n    show.value = !show.value\n    await nextTick()\n    expect(mapRefs()).toMatchObject(['2', '3', '4'])\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"named ref in v-for , should be responsive when rendering","suites":["api: template refs"],"updatePoint":{"line":499,"column":64},"line":499,"code":"  test('named ref in v-for , should be responsive when rendering', async () => {\n    const list = ref([1, 2, 3])\n    const listRefs = ref([])\n    const App = {\n      setup() {\n        return { listRefs }\n      },\n      render() {\n        return h('div', null, [\n          h('div', null, String(listRefs.value)),\n          h(\n            'ul',\n            list.value.map(i =>\n              h(\n                'li',\n                {\n                  ref: 'listRefs',\n                  ref_for: true\n                },\n                i\n              )\n            )\n          )\n        ])\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    await nextTick()\n    expect(String(listRefs.value)).toBe(\n      '[object Object],[object Object],[object Object]'\n    )\n    expect(serializeInner(root)).toBe(\n      '<div><div>[object Object],[object Object],[object Object]</div><ul><li>1</li><li>2</li><li>3</li></ul></div>'\n    )\n\n    list.value.splice(0, 1)\n    await nextTick()\n    expect(String(listRefs.value)).toBe('[object Object],[object Object]')\n    expect(serializeInner(root)).toBe(\n      '<div><div>[object Object],[object Object]</div><ul><li>2</li><li>3</li></ul></div>'\n    )\n  })","file":"rendererTemplateRef.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nextTick","suites":["scheduler"],"updatePoint":{"line":12,"column":14},"line":12,"code":"  it('nextTick', async () => {\n    const calls: string[] = []\n    const dummyThen = Promise.resolve().then()\n    const job1 = () => {\n      calls.push('job1')\n    }\n    const job2 = () => {\n      calls.push('job2')\n    }\n    nextTick(job1)\n    job2()\n\n    expect(calls.length).toBe(1)\n    await dummyThen\n    // job1 will be pushed in nextTick\n    expect(calls.length).toBe(2)\n    expect(calls).toMatchObject(['job2', 'job1'])\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"basic usage","suites":["scheduler","queueJob"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('basic usage', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      const job2 = () => {\n        calls.push('job2')\n      }\n      queueJob(job1)\n      queueJob(job2)\n      expect(calls).toEqual([])\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should insert jobs in ascending order of job's id when flushing","suites":["scheduler","queueJob"],"updatePoint":{"line":47,"column":71},"line":47,"code":"    it(\"should insert jobs in ascending order of job's id when flushing\", async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n\n        queueJob(job2)\n        queueJob(job3)\n      }\n\n      const job2 = () => {\n        calls.push('job2')\n        queueJob(job4)\n        queueJob(job5)\n      }\n      job2.id = 10\n\n      const job3 = () => {\n        calls.push('job3')\n      }\n      job3.id = 1\n\n      const job4 = () => {\n        calls.push('job4')\n      }\n\n      const job5 = () => {\n        calls.push('job5')\n      }\n\n      queueJob(job1)\n\n      expect(calls).toEqual([])\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job3', 'job2', 'job4', 'job5'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should dedupe queued jobs","suites":["scheduler","queueJob"],"updatePoint":{"line":83,"column":33},"line":83,"code":"    it('should dedupe queued jobs', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      const job2 = () => {\n        calls.push('job2')\n      }\n      queueJob(job1)\n      queueJob(job2)\n      queueJob(job1)\n      queueJob(job2)\n      expect(calls).toEqual([])\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob while flushing","suites":["scheduler","queueJob"],"updatePoint":{"line":100,"column":31},"line":100,"code":"    it('queueJob while flushing', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n        // job2 will be executed after job1 at the same tick\n        queueJob(job2)\n      }\n      const job2 = () => {\n        calls.push('job2')\n      }\n      queueJob(job1)\n\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob inside preFlushCb","suites":["scheduler","pre flush jobs"],"updatePoint":{"line":118,"column":34},"line":118,"code":"    it('queueJob inside preFlushCb', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      const cb1 = () => {\n        // queueJob in postFlushCb\n        calls.push('cb1')\n        queueJob(job1)\n      }\n      cb1.pre = true\n\n      queueJob(cb1)\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'job1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob & preFlushCb inside preFlushCb","suites":["scheduler","pre flush jobs"],"updatePoint":{"line":135,"column":47},"line":135,"code":"    it('queueJob & preFlushCb inside preFlushCb', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      job1.id = 1\n\n      const cb1 = () => {\n        calls.push('cb1')\n        queueJob(job1)\n        // cb2 should execute before the job\n        queueJob(cb2)\n      }\n      cb1.pre = true\n\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n      cb2.pre = true\n      cb2.id = 1\n\n      queueJob(cb1)\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'cb2', 'job1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"preFlushCb inside queueJob","suites":["scheduler","pre flush jobs"],"updatePoint":{"line":161,"column":34},"line":161,"code":"    it('preFlushCb inside queueJob', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        // the only case where a pre-flush cb can be queued inside a job is\n        // when updating the props of a child component. This is handled\n        // directly inside `updateComponentPreRender` to avoid non atomic\n        // cb triggers (#1763)\n        queueJob(cb1)\n        queueJob(cb2)\n        flushPreFlushCbs()\n        calls.push('job1')\n      }\n      const cb1 = () => {\n        calls.push('cb1')\n        // a cb triggers its parent job, which should be skipped\n        queueJob(job1)\n      }\n      cb1.pre = true\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n      cb2.pre = true\n\n      queueJob(job1)\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'cb2', 'job1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queue preFlushCb inside postFlushCb","suites":["scheduler","pre flush jobs"],"updatePoint":{"line":190,"column":43},"line":190,"code":"    it('queue preFlushCb inside postFlushCb', async () => {\n      const spy = vi.fn()\n      const cb = () => spy()\n      cb.pre = true\n      queuePostFlushCb(() => {\n        queueJob(cb)\n      })\n      await nextTick()\n      expect(spy).toHaveBeenCalled()\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"basic usage","suites":["scheduler","queuePostFlushCb"],"updatePoint":{"line":203,"column":19},"line":203,"code":"    it('basic usage', async () => {\n      const calls: string[] = []\n      const cb1 = () => {\n        calls.push('cb1')\n      }\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n      const cb3 = () => {\n        calls.push('cb3')\n      }\n\n      queuePostFlushCb([cb1, cb2])\n      queuePostFlushCb(cb3)\n\n      expect(calls).toEqual([])\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'cb2', 'cb3'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should dedupe queued postFlushCb","suites":["scheduler","queuePostFlushCb"],"updatePoint":{"line":223,"column":40},"line":223,"code":"    it('should dedupe queued postFlushCb', async () => {\n      const calls: string[] = []\n      const cb1 = () => {\n        calls.push('cb1')\n      }\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n      const cb3 = () => {\n        calls.push('cb3')\n      }\n\n      queuePostFlushCb([cb1, cb2])\n      queuePostFlushCb(cb3)\n\n      queuePostFlushCb([cb1, cb3])\n      queuePostFlushCb(cb2)\n\n      expect(calls).toEqual([])\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'cb2', 'cb3'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queuePostFlushCb while flushing","suites":["scheduler","queuePostFlushCb"],"updatePoint":{"line":246,"column":39},"line":246,"code":"    it('queuePostFlushCb while flushing', async () => {\n      const calls: string[] = []\n      const cb1 = () => {\n        calls.push('cb1')\n        // cb2 will be executed after cb1 at the same tick\n        queuePostFlushCb(cb2)\n      }\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n      queuePostFlushCb(cb1)\n\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'cb2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob inside postFlushCb","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":264,"column":35},"line":264,"code":"    it('queueJob inside postFlushCb', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      const cb1 = () => {\n        // queueJob in postFlushCb\n        calls.push('cb1')\n        queueJob(job1)\n      }\n\n      queuePostFlushCb(cb1)\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'job1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob & postFlushCb inside postFlushCb","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":280,"column":49},"line":280,"code":"    it('queueJob & postFlushCb inside postFlushCb', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n      }\n      const cb1 = () => {\n        calls.push('cb1')\n        queuePostFlushCb(cb2)\n        // job1 will executed before cb2\n        // Job has higher priority than postFlushCb\n        queueJob(job1)\n      }\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n\n      queuePostFlushCb(cb1)\n      await nextTick()\n      expect(calls).toEqual(['cb1', 'job1', 'cb2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"postFlushCb inside queueJob","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":301,"column":35},"line":301,"code":"    it('postFlushCb inside queueJob', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n        // postFlushCb in queueJob\n        queuePostFlushCb(cb1)\n      }\n      const cb1 = () => {\n        calls.push('cb1')\n      }\n\n      queueJob(job1)\n      await nextTick()\n      expect(calls).toEqual(['job1', 'cb1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"queueJob & postFlushCb inside queueJob","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":317,"column":46},"line":317,"code":"    it('queueJob & postFlushCb inside queueJob', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n        // cb1 will executed after job2\n        // Job has higher priority than postFlushCb\n        queuePostFlushCb(cb1)\n        queueJob(job2)\n      }\n      const job2 = () => {\n        calls.push('job2')\n      }\n      const cb1 = () => {\n        calls.push('cb1')\n      }\n\n      queueJob(job1)\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job2', 'cb1'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nested queueJob w/ postFlushCb","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":338,"column":38},"line":338,"code":"    it('nested queueJob w/ postFlushCb', async () => {\n      const calls: string[] = []\n      const job1 = () => {\n        calls.push('job1')\n\n        queuePostFlushCb(cb1)\n        queueJob(job2)\n      }\n      const job2 = () => {\n        calls.push('job2')\n        queuePostFlushCb(cb2)\n      }\n      const cb1 = () => {\n        calls.push('cb1')\n      }\n      const cb2 = () => {\n        calls.push('cb2')\n      }\n\n      queueJob(job1)\n      await nextTick()\n      expect(calls).toEqual(['job1', 'job2', 'cb1', 'cb2'])\n    })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"invalidateJob","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":363,"column":21},"line":363,"code":"  test('invalidateJob', async () => {\n    const calls: string[] = []\n    const job1 = () => {\n      calls.push('job1')\n      invalidateJob(job2)\n      job2()\n    }\n    const job2 = () => {\n      calls.push('job2')\n    }\n    const job3 = () => {\n      calls.push('job3')\n    }\n    const job4 = () => {\n      calls.push('job4')\n    }\n    // queue all jobs\n    queueJob(job1)\n    queueJob(job2)\n    queueJob(job3)\n    queuePostFlushCb(job4)\n    expect(calls).toEqual([])\n    await nextTick()\n    // job2 should be called only once\n    expect(calls).toEqual(['job1', 'job2', 'job3', 'job4'])\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"sort job based on id","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":390,"column":28},"line":390,"code":"  test('sort job based on id', async () => {\n    const calls: string[] = []\n    const job1 = () => calls.push('job1')\n    // job1 has no id\n    const job2 = () => calls.push('job2')\n    job2.id = 2\n    const job3 = () => calls.push('job3')\n    job3.id = 1\n\n    queueJob(job1)\n    queueJob(job2)\n    queueJob(job3)\n    await nextTick()\n    expect(calls).toEqual(['job3', 'job2', 'job1'])\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"sort SchedulerCbs based on id","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":406,"column":37},"line":406,"code":"  test('sort SchedulerCbs based on id', async () => {\n    const calls: string[] = []\n    const cb1 = () => calls.push('cb1')\n    // cb1 has no id\n    const cb2 = () => calls.push('cb2')\n    cb2.id = 2\n    const cb3 = () => calls.push('cb3')\n    cb3.id = 1\n\n    queuePostFlushCb(cb1)\n    queuePostFlushCb(cb2)\n    queuePostFlushCb(cb3)\n    await nextTick()\n    expect(calls).toEqual(['cb3', 'cb2', 'cb1'])\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"avoid duplicate postFlushCb invocation","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":423,"column":46},"line":423,"code":"  test('avoid duplicate postFlushCb invocation', async () => {\n    const calls: string[] = []\n    const cb1 = () => {\n      calls.push('cb1')\n      queuePostFlushCb(cb2)\n    }\n    const cb2 = () => {\n      calls.push('cb2')\n    }\n    queuePostFlushCb(cb1)\n    queuePostFlushCb(cb2)\n    await nextTick()\n    expect(calls).toEqual(['cb1', 'cb2'])\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"nextTick should capture scheduler flush errors","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":438,"column":54},"line":438,"code":"  test('nextTick should capture scheduler flush errors', async () => {\n    const err = new Error('test')\n    queueJob(() => {\n      throw err\n    })\n    try {\n      await nextTick()\n    } catch (e: any) {\n      expect(e).toBe(err)\n    }\n    expect(\n      `Unhandled error during execution of scheduler flush`\n    ).toHaveBeenWarned()\n\n    // this one should no longer error\n    await nextTick()\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should prevent self-triggering jobs by default","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":456,"column":54},"line":456,"code":"  test('should prevent self-triggering jobs by default', async () => {\n    let count = 0\n    const job = () => {\n      if (count < 3) {\n        count++\n        queueJob(job)\n      }\n    }\n    queueJob(job)\n    await nextTick()\n    // only runs once - a job cannot queue itself\n    expect(count).toBe(1)\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should allow explicitly marked jobs to trigger itself","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":470,"column":61},"line":470,"code":"  test('should allow explicitly marked jobs to trigger itself', async () => {\n    // normal job\n    let count = 0\n    const job = () => {\n      if (count < 3) {\n        count++\n        queueJob(job)\n      }\n    }\n    job.allowRecurse = true\n    queueJob(job)\n    await nextTick()\n    expect(count).toBe(3)\n\n    // post cb\n    const cb = () => {\n      if (count < 5) {\n        count++\n        queuePostFlushCb(cb)\n      }\n    }\n    cb.allowRecurse = true\n    queuePostFlushCb(cb)\n    await nextTick()\n    expect(count).toBe(5)\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flushPostFlushCbs","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":499,"column":25},"line":499,"code":"  test('flushPostFlushCbs', async () => {\n    let count = 0\n\n    const queueAndFlush = (hook: Function) => {\n      queuePostFlushCb(hook)\n      flushPostFlushCbs()\n    }\n\n    queueAndFlush(() => {\n      queueAndFlush(() => {\n        count++\n      })\n    })\n\n    await nextTick()\n    expect(count).toBe(1)\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not run stopped reactive effects","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":518,"column":47},"line":518,"code":"  test('should not run stopped reactive effects', async () => {\n    const spy = vi.fn()\n\n    // simulate parent component that toggles child\n    const job1 = () => {\n      // @ts-ignore\n      job2.active = false\n    }\n    // simulate child that's triggered by the same reactive change that\n    // triggers its toggle\n    const job2 = () => spy()\n    expect(spy).toHaveBeenCalledTimes(0)\n\n    queueJob(job1)\n    queueJob(job2)\n    await nextTick()\n\n    // should not be called\n    expect(spy).toHaveBeenCalledTimes(0)\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"flushPreFlushCbs inside a pre job","suites":["scheduler","queueJob w/ queuePostFlushCb"],"updatePoint":{"line":539,"column":39},"line":539,"code":"  it('flushPreFlushCbs inside a pre job', async () => {\n    const spy = vi.fn()\n    const job = () => {\n      spy()\n      flushPreFlushCbs()\n    }\n    job.pre = true\n    queueJob(job)\n    await nextTick()\n    expect(spy).toHaveBeenCalledTimes(1)\n  })","file":"scheduler.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should attach scopeId","suites":["scopeId runtime support"],"updatePoint":{"line":14,"column":29},"line":14,"code":"  test('should attach scopeId', () => {\n    const App = {\n      __scopeId: 'parent',\n      render: () => h('div', [h('div')])\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div parent><div parent></div></div>`)\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should attach scopeId to components in parent component","suites":["scopeId runtime support"],"updatePoint":{"line":24,"column":63},"line":24,"code":"  test('should attach scopeId to components in parent component', () => {\n    const Child = {\n      __scopeId: 'child',\n      render: () => h('div')\n    }\n    const App = {\n      __scopeId: 'parent',\n      render: () => h('div', [h(Child)])\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(\n      `<div parent><div child parent></div></div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work on slots","suites":["scopeId runtime support"],"updatePoint":{"line":42,"column":28},"line":42,"code":"  test('should work on slots', () => {\n    const Child = {\n      __scopeId: 'child',\n      render(this: any) {\n        return h('div', renderSlot(this.$slots, 'default'))\n      }\n    }\n    const Child2 = {\n      __scopeId: 'child2',\n      render: () => h('span')\n    }\n    const App = {\n      __scopeId: 'parent',\n      render: () => {\n        return h(\n          Child,\n          withCtx(() => {\n            return [h('div'), h(Child2)]\n          })\n        )\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    // slot content should have:\n    // - scopeId from parent\n    // - slotted scopeId (with `-s` postfix) from child (the tree owner)\n    expect(serializeInner(root)).toBe(\n      `<div child parent>` +\n        `<div parent child-s></div>` +\n        // component inside slot should have:\n        // - scopeId from template context\n        // - slotted scopeId from slot owner\n        // - its own scopeId\n        `<span child2 parent child-s></span>` +\n        `</div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":":slotted on forwarded slots","suites":["scopeId runtime support"],"updatePoint":{"line":82,"column":35},"line":82,"code":"  test(':slotted on forwarded slots', async () => {\n    const Wrapper = {\n      __scopeId: 'wrapper',\n      render(this: any) {\n        // <div class=\"wrapper\"><slot/></div>\n        return h('div', { class: 'wrapper' }, [\n          renderSlot(\n            this.$slots,\n            'default',\n            {},\n            undefined,\n            true /* noSlotted */\n          )\n        ])\n      }\n    }\n\n    const Slotted = {\n      __scopeId: 'slotted',\n      render(this: any) {\n        // <Wrapper><slot/></Wrapper>\n        return h(Wrapper, null, {\n          default: withCtx(() => [renderSlot(this.$slots, 'default')])\n        })\n      }\n    }\n\n    // simulate hoisted node\n    pushScopeId('root')\n    const hoisted = h('div', 'hoisted')\n    popScopeId()\n\n    const Root = {\n      __scopeId: 'root',\n      render(this: any) {\n        // <Slotted><div>hoisted</div><div>{{ dynamic }}</div></Slotted>\n        return h(Slotted, null, {\n          default: withCtx(() => {\n            return [hoisted, h('div', 'dynamic')]\n          })\n        })\n      }\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(Root), root)\n    expect(serializeInner(root)).toBe(\n      `<div wrapper slotted root class=\"wrapper\">` +\n        `<div root slotted-s>hoisted</div>` +\n        `<div root slotted-s>dynamic</div>` +\n        `</div>`\n    )\n\n    const Root2 = {\n      __scopeId: 'root',\n      render(this: any) {\n        // <Slotted>\n        //  <Wrapper>\n        //    <div>hoisted</div><div>{{ dynamic }}</div>\n        //  </Wrapper>\n        // </Slotted>\n        return h(Slotted, null, {\n          default: withCtx(() => [\n            h(Wrapper, null, {\n              default: withCtx(() => [hoisted, h('div', 'dynamic')])\n            })\n          ])\n        })\n      }\n    }\n    const root2 = nodeOps.createElement('div')\n    render(h(Root2), root2)\n    expect(serializeInner(root2)).toBe(\n      `<div wrapper slotted root class=\"wrapper\">` +\n        `<div wrapper root slotted-s class=\"wrapper\">` +\n        `<div root>hoisted</div>` +\n        `<div root>dynamic</div>` +\n        `</div>` +\n        `</div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should inherit scopeId through nested HOCs with inheritAttrs: false","suites":["scopeId runtime support"],"updatePoint":{"line":165,"column":75},"line":165,"code":"  test('should inherit scopeId through nested HOCs with inheritAttrs: false', () => {\n    const App = {\n      __scopeId: 'parent',\n      render: () => {\n        return h(Child)\n      }\n    }\n\n    function Child() {\n      return h(Child2, { class: 'foo' })\n    }\n\n    function Child2() {\n      return h('div')\n    }\n    Child2.inheritAttrs = false\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div parent></div>`)\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should attach scopeId","suites":["backwards compat with <=3.0.7"],"updatePoint":{"line":193,"column":29},"line":193,"code":"  test('should attach scopeId', () => {\n    const App = {\n      __scopeId: 'parent',\n      render: withParentId(() => {\n        return h('div', [h('div')])\n      })\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(`<div parent><div parent></div></div>`)\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should attach scopeId to components in parent component","suites":["backwards compat with <=3.0.7"],"updatePoint":{"line":205,"column":63},"line":205,"code":"  test('should attach scopeId to components in parent component', () => {\n    const Child = {\n      __scopeId: 'child',\n      render: withChildId(() => {\n        return h('div')\n      })\n    }\n    const App = {\n      __scopeId: 'parent',\n      render: withParentId(() => {\n        return h('div', [h(Child)])\n      })\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serializeInner(root)).toBe(\n      `<div parent><div child parent></div></div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work on slots","suites":["backwards compat with <=3.0.7"],"updatePoint":{"line":226,"column":28},"line":226,"code":"  test('should work on slots', () => {\n    const Child = {\n      __scopeId: 'child',\n      render: withChildId(function (this: any) {\n        return h('div', renderSlot(this.$slots, 'default'))\n      })\n    }\n    const withChild2Id = withScopeId('child2')\n    const Child2 = {\n      __scopeId: 'child2',\n      render: withChild2Id(() => h('span'))\n    }\n    const App = {\n      __scopeId: 'parent',\n      render: withParentId(() => {\n        return h(\n          Child,\n          withParentId(() => {\n            return [h('div'), h(Child2)]\n          })\n        )\n      })\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    // slot content should have:\n    // - scopeId from parent\n    // - slotted scopeId (with `-s` postfix) from child (the tree owner)\n    expect(serializeInner(root)).toBe(\n      `<div child parent>` +\n        `<div parent child-s></div>` +\n        // component inside slot should have:\n        // - scopeId from template context\n        // - slotted scopeId from slot owner\n        // - its own scopeId\n        `<span child2 parent child-s></span>` +\n        `</div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should inherit scopeId through nested HOCs with inheritAttrs: false","suites":["backwards compat with <=3.0.7"],"updatePoint":{"line":267,"column":75},"line":267,"code":"  test('should inherit scopeId through nested HOCs with inheritAttrs: false', () => {\n    const withParentId = withScopeId('parent')\n    const App = {\n      __scopeId: 'parent',\n      render: withParentId(() => {\n        return h(Child)\n      })\n    }\n\n    function Child() {\n      return h(Child2, { class: 'foo' })\n    }\n\n    function Child2() {\n      return h('div')\n    }\n    Child2.inheritAttrs = false\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(`<div parent></div>`)\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"hoisted nodes","suites":["backwards compat with <=3.0.7"],"updatePoint":{"line":291,"column":21},"line":291,"code":"  test('hoisted nodes', async () => {\n    pushScopeId('foobar')\n    const hoisted = h('div', 'hello')\n    popScopeId()\n\n    const App = {\n      __scopeId: 'foobar',\n      render: () => h('div', [hoisted])\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n\n    expect(serializeInner(root)).toBe(\n      `<div foobar><div foobar>hello</div></div>`\n    )\n  })","file":"scopeId.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create with just tag","suites":["vnode"],"updatePoint":{"line":22,"column":28},"line":22,"code":"  test('create with just tag', () => {\n    const vnode = createVNode('p')\n    expect(vnode.type).toBe('p')\n    expect(vnode.props).toBe(null)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create with tag and props","suites":["vnode"],"updatePoint":{"line":28,"column":33},"line":28,"code":"  test('create with tag and props', () => {\n    const vnode = createVNode('p', {})\n    expect(vnode.type).toBe('p')\n    expect(vnode.props).toMatchObject({})\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create with tag, props and children","suites":["vnode"],"updatePoint":{"line":34,"column":43},"line":34,"code":"  test('create with tag, props and children', () => {\n    const vnode = createVNode('p', {}, ['foo'])\n    expect(vnode.type).toBe('p')\n    expect(vnode.props).toMatchObject({})\n    expect(vnode.children).toMatchObject(['foo'])\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create with 0 as props","suites":["vnode"],"updatePoint":{"line":41,"column":30},"line":41,"code":"  test('create with 0 as props', () => {\n    const vnode = createVNode('p', null)\n    expect(vnode.type).toBe('p')\n    expect(vnode.props).toBe(null)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"show warn when create with invalid type","suites":["vnode"],"updatePoint":{"line":47,"column":47},"line":47,"code":"  test('show warn when create with invalid type', () => {\n    const vnode = createVNode('')\n    expect('Invalid vnode type when creating vnode').toHaveBeenWarned()\n    expect(vnode.type).toBe(Comment)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create from an existing vnode","suites":["vnode"],"updatePoint":{"line":53,"column":37},"line":53,"code":"  test('create from an existing vnode', () => {\n    const vnode1 = createVNode('p', { id: 'foo' })\n    const vnode2 = createVNode(vnode1, { class: 'bar' }, 'baz')\n    expect(vnode2).toMatchObject({\n      type: 'p',\n      props: {\n        id: 'foo',\n        class: 'bar'\n      },\n      children: 'baz',\n      shapeFlag: ShapeFlags.ELEMENT | ShapeFlags.TEXT_CHILDREN\n    })\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"vnode keys","suites":["vnode"],"updatePoint":{"line":67,"column":18},"line":67,"code":"  test('vnode keys', () => {\n    for (const key of ['', 'a', 0, 1, NaN]) {\n      expect(createVNode('div', { key }).key).toBe(key)\n    }\n    expect(createVNode('div').key).toBe(null)\n    expect(createVNode('div', { key: undefined }).key).toBe(null)\n    expect(`VNode created with invalid key (NaN)`).toHaveBeenWarned()\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"create with class component","suites":["vnode"],"updatePoint":{"line":76,"column":35},"line":76,"code":"  test('create with class component', () => {\n    class Component {\n      $props: any\n      static __vccOpts = { template: '<div />' }\n    }\n    const vnode = createVNode(Component)\n    expect(vnode.type).toEqual(Component.__vccOpts)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string","suites":["vnode","class normalization"],"updatePoint":{"line":86,"column":16},"line":86,"code":"    test('string', () => {\n      const vnode = createVNode('p', { class: 'foo baz' })\n      expect(vnode.props).toMatchObject({ class: 'foo baz' })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array<string>","suites":["vnode","class normalization"],"updatePoint":{"line":91,"column":23},"line":91,"code":"    test('array<string>', () => {\n      const vnode = createVNode('p', { class: ['foo', 'baz'] })\n      expect(vnode.props).toMatchObject({ class: 'foo baz' })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array<object>","suites":["vnode","class normalization"],"updatePoint":{"line":96,"column":23},"line":96,"code":"    test('array<object>', () => {\n      const vnode = createVNode('p', {\n        class: [{ foo: 'foo' }, { baz: 'baz' }]\n      })\n      expect(vnode.props).toMatchObject({ class: 'foo baz' })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"object","suites":["vnode","class normalization"],"updatePoint":{"line":103,"column":16},"line":103,"code":"    test('object', () => {\n      const vnode = createVNode('p', { class: { foo: 'foo', baz: 'baz' } })\n      expect(vnode.props).toMatchObject({ class: 'foo baz' })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array","suites":["vnode","style normalization"],"updatePoint":{"line":110,"column":15},"line":110,"code":"    test('array', () => {\n      const vnode = createVNode('p', {\n        style: [{ foo: 'foo' }, { baz: 'baz' }]\n      })\n      expect(vnode.props).toMatchObject({ style: { foo: 'foo', baz: 'baz' } })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"object","suites":["vnode","style normalization"],"updatePoint":{"line":117,"column":16},"line":117,"code":"    test('object', () => {\n      const vnode = createVNode('p', { style: { foo: 'foo', baz: 'baz' } })\n      expect(vnode.props).toMatchObject({ style: { foo: 'foo', baz: 'baz' } })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"null","suites":["vnode","children normalization"],"updatePoint":{"line":126,"column":14},"line":126,"code":"    test('null', () => {\n      const vnode = createVNode('p', null, null)\n      expect(vnode.children).toBe(null)\n      expect(vnode.shapeFlag).toBe(ShapeFlags.ELEMENT)\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"array","suites":["vnode","children normalization"],"updatePoint":{"line":132,"column":15},"line":132,"code":"    test('array', () => {\n      const vnode = createVNode('p', null, ['foo'])\n      expect(vnode.children).toMatchObject(['foo'])\n      expect(vnode.shapeFlag).toBe(\n        ShapeFlags.ELEMENT | ShapeFlags.ARRAY_CHILDREN\n      )\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"object","suites":["vnode","children normalization"],"updatePoint":{"line":140,"column":16},"line":140,"code":"    test('object', () => {\n      const vnode = createVNode({}, null, { foo: 'foo' })\n      expect(vnode.children).toMatchObject({ foo: 'foo' })\n      expect(vnode.shapeFlag).toBe(\n        ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.SLOTS_CHILDREN\n      )\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"function","suites":["vnode","children normalization"],"updatePoint":{"line":148,"column":18},"line":148,"code":"    test('function', () => {\n      const vnode = createVNode('p', null, nop)\n      expect(vnode.children).toMatchObject({ default: nop })\n      expect(vnode.shapeFlag).toBe(\n        ShapeFlags.ELEMENT | ShapeFlags.SLOTS_CHILDREN\n      )\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"string","suites":["vnode","children normalization"],"updatePoint":{"line":156,"column":16},"line":156,"code":"    test('string', () => {\n      const vnode = createVNode('p', null, 'foo')\n      expect(vnode.children).toBe('foo')\n      expect(vnode.shapeFlag).toBe(\n        ShapeFlags.ELEMENT | ShapeFlags.TEXT_CHILDREN\n      )\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element with slots","suites":["vnode","children normalization"],"updatePoint":{"line":164,"column":28},"line":164,"code":"    test('element with slots', () => {\n      const children = [createVNode('span', null, 'hello')]\n      const vnode = createVNode('div', null, {\n        default: () => children\n      })\n\n      expect(vnode.children).toBe(children)\n      expect(vnode.shapeFlag).toBe(\n        ShapeFlags.ELEMENT | ShapeFlags.ARRAY_CHILDREN\n      )\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"normalizeVNode","suites":["vnode","children normalization"],"updatePoint":{"line":177,"column":22},"line":177,"code":"  test('normalizeVNode', () => {\n    // null / undefined -> Comment\n    expect(normalizeVNode(null)).toMatchObject({ type: Comment })\n    expect(normalizeVNode(undefined)).toMatchObject({ type: Comment })\n\n    // boolean -> Comment\n    // this is for usage like `someBoolean && h('div')` and behavior consistency\n    // with 2.x (#574)\n    expect(normalizeVNode(true)).toMatchObject({ type: Comment })\n    expect(normalizeVNode(false)).toMatchObject({ type: Comment })\n\n    // array -> Fragment\n    expect(normalizeVNode(['foo'])).toMatchObject({ type: Fragment })\n\n    // VNode -> VNode\n    const vnode = createVNode('div')\n    expect(normalizeVNode(vnode)).toBe(vnode)\n\n    // mounted VNode -> cloned VNode\n    const mounted = createVNode('div')\n    mounted.el = {}\n    const normalized = normalizeVNode(mounted)\n    expect(normalized).not.toBe(mounted)\n    expect(normalized).toEqual(mounted)\n\n    // primitive types\n    expect(normalizeVNode('foo')).toMatchObject({ type: Text, children: `foo` })\n    expect(normalizeVNode(1)).toMatchObject({ type: Text, children: `1` })\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"type shapeFlag inference","suites":["vnode","children normalization"],"updatePoint":{"line":207,"column":32},"line":207,"code":"  test('type shapeFlag inference', () => {\n    expect(createVNode('div').shapeFlag).toBe(ShapeFlags.ELEMENT)\n    expect(createVNode({}).shapeFlag).toBe(ShapeFlags.STATEFUL_COMPONENT)\n    expect(createVNode(() => {}).shapeFlag).toBe(\n      ShapeFlags.FUNCTIONAL_COMPONENT\n    )\n    expect(createVNode(Text).shapeFlag).toBe(0)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode","suites":["vnode","children normalization"],"updatePoint":{"line":216,"column":18},"line":216,"code":"  test('cloneVNode', () => {\n    const node1 = createVNode('div', { foo: 1 }, null)\n    expect(cloneVNode(node1)).toEqual(node1)\n\n    const node2 = createVNode({}, null, [node1])\n    const cloned2 = cloneVNode(node2)\n    expect(cloned2).toEqual(node2)\n    expect(cloneVNode(node2)).toEqual(cloned2)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode key normalization","suites":["vnode","children normalization"],"updatePoint":{"line":226,"column":36},"line":226,"code":"  test('cloneVNode key normalization', () => {\n    // #1041 should use resolved key/ref\n    expect(cloneVNode(createVNode('div', { key: 1 })).key).toBe(1)\n    expect(cloneVNode(createVNode('div', { key: 1 }), { key: 2 }).key).toBe(2)\n    expect(cloneVNode(createVNode('div'), { key: 2 }).key).toBe(2)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode ref normalization","suites":["vnode","children normalization"],"updatePoint":{"line":234,"column":36},"line":234,"code":"  test('cloneVNode ref normalization', () => {\n    const mockInstance1 = { type: {} } as any\n    const mockInstance2 = { type: {} } as any\n\n    setCurrentRenderingInstance(mockInstance1)\n    const original = createVNode('div', { ref: 'foo' })\n    expect(original.ref).toMatchObject({\n      i: mockInstance1,\n      r: 'foo',\n      f: false\n    })\n\n    // clone and preserve original ref\n    const cloned1 = cloneVNode(original)\n    expect(cloned1.ref).toMatchObject({ i: mockInstance1, r: 'foo', f: false })\n\n    // cloning with new ref, but with same context instance\n    const cloned2 = cloneVNode(original, { ref: 'bar' })\n    expect(cloned2.ref).toMatchObject({ i: mockInstance1, r: 'bar', f: false })\n\n    // cloning and adding ref to original that has no ref\n    const original2 = createVNode('div')\n    const cloned3 = cloneVNode(original2, { ref: 'bar' })\n    expect(cloned3.ref).toMatchObject({ i: mockInstance1, r: 'bar', f: false })\n\n    // cloning with different context instance\n    setCurrentRenderingInstance(mockInstance2)\n\n    // clone and preserve original ref\n    const cloned4 = cloneVNode(original)\n    // #1311 should preserve original context instance!\n    expect(cloned4.ref).toMatchObject({ i: mockInstance1, r: 'foo', f: false })\n\n    // cloning with new ref, but with same context instance\n    const cloned5 = cloneVNode(original, { ref: 'bar' })\n    // new ref should use current context instance and overwrite original\n    expect(cloned5.ref).toMatchObject({ i: mockInstance2, r: 'bar', f: false })\n\n    // cloning and adding ref to original that has no ref\n    const cloned6 = cloneVNode(original2, { ref: 'bar' })\n    expect(cloned6.ref).toMatchObject({ i: mockInstance2, r: 'bar', f: false })\n\n    const original3 = createVNode('div', { ref: 'foo', ref_for: true })\n    expect(original3.ref).toMatchObject({\n      i: mockInstance2,\n      r: 'foo',\n      f: true\n    })\n    const cloned7 = cloneVNode(original3, { ref: 'bar', ref_for: true })\n    expect(cloned7.ref).toMatchObject({ i: mockInstance2, r: 'bar', f: true })\n\n    const r = ref()\n    const original4 = createVNode('div', { ref: r, ref_key: 'foo' })\n    expect(original4.ref).toMatchObject({\n      i: mockInstance2,\n      r,\n      k: 'foo'\n    })\n    const cloned8 = cloneVNode(original4)\n    expect(cloned8.ref).toMatchObject({ i: mockInstance2, r, k: 'foo' })\n\n    setCurrentRenderingInstance(null)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode ref merging","suites":["vnode","children normalization"],"updatePoint":{"line":298,"column":30},"line":298,"code":"  test('cloneVNode ref merging', () => {\n    const mockInstance1 = { type: {} } as any\n    const mockInstance2 = { type: {} } as any\n\n    setCurrentRenderingInstance(mockInstance1)\n    const original = createVNode('div', { ref: 'foo' })\n    expect(original.ref).toMatchObject({ i: mockInstance1, r: 'foo', f: false })\n\n    // clone and preserve original ref\n    setCurrentRenderingInstance(mockInstance2)\n    const cloned1 = cloneVNode(original, { ref: 'bar' }, true)\n    expect(cloned1.ref).toMatchObject([\n      { i: mockInstance1, r: 'foo', f: false },\n      { i: mockInstance2, r: 'bar', f: false }\n    ])\n\n    setCurrentRenderingInstance(null)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode class normalization","suites":["vnode","children normalization"],"updatePoint":{"line":317,"column":38},"line":317,"code":"  test('cloneVNode class normalization', () => {\n    const vnode = createVNode('div')\n    const expectedProps = {\n      class: 'a b'\n    }\n    expect(cloneVNode(vnode, { class: 'a b' }).props).toMatchObject(\n      expectedProps\n    )\n    expect(cloneVNode(vnode, { class: ['a', 'b'] }).props).toMatchObject(\n      expectedProps\n    )\n    expect(\n      cloneVNode(vnode, { class: { a: true, b: true } }).props\n    ).toMatchObject(expectedProps)\n    expect(\n      cloneVNode(vnode, { class: [{ a: true, b: true }] }).props\n    ).toMatchObject(expectedProps)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"cloneVNode style normalization","suites":["vnode","children normalization"],"updatePoint":{"line":336,"column":38},"line":336,"code":"  test('cloneVNode style normalization', () => {\n    const vnode = createVNode('div')\n    const expectedProps = {\n      style: {\n        color: 'blue',\n        width: '300px'\n      }\n    }\n    expect(\n      cloneVNode(vnode, { style: 'color: blue; width: 300px;' }).props\n    ).toMatchObject(expectedProps)\n    expect(\n      cloneVNode(vnode, {\n        style: {\n          color: 'blue',\n          width: '300px'\n        }\n      }).props\n    ).toMatchObject(expectedProps)\n    expect(\n      cloneVNode(vnode, {\n        style: [\n          {\n            color: 'blue',\n            width: '300px'\n          }\n        ]\n      }).props\n    ).toMatchObject(expectedProps)\n  })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"class","suites":["vnode","mergeProps"],"updatePoint":{"line":368,"column":15},"line":368,"code":"    test('class', () => {\n      let props1: Data = { class: { c: true } }\n      let props2: Data = { class: ['cc'] }\n      let props3: Data = { class: [{ ccc: true }] }\n      let props4: Data = { class: { cccc: true } }\n      expect(mergeProps(props1, props2, props3, props4)).toMatchObject({\n        class: 'c cc ccc cccc'\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"style","suites":["vnode","mergeProps"],"updatePoint":{"line":378,"column":15},"line":378,"code":"    test('style', () => {\n      let props1: Data = {\n        style: [\n          {\n            color: 'red',\n            fontSize: 10\n          }\n        ]\n      }\n      let props2: Data = {\n        style: [\n          {\n            color: 'blue',\n            width: '200px'\n          },\n          {\n            width: '300px',\n            height: '300px',\n            fontSize: 30\n          }\n        ]\n      }\n      expect(mergeProps(props1, props2)).toMatchObject({\n        style: {\n          color: 'blue',\n          width: '300px',\n          height: '300px',\n          fontSize: 30\n        }\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"style w/ strings","suites":["vnode","mergeProps"],"updatePoint":{"line":410,"column":26},"line":410,"code":"    test('style w/ strings', () => {\n      let props1: Data = {\n        style: 'width:100px;right:10;top:10'\n      }\n      let props2: Data = {\n        style: [\n          {\n            color: 'blue',\n            width: '200px'\n          },\n          {\n            width: '300px',\n            height: '300px',\n            fontSize: 30\n          }\n        ]\n      }\n      expect(mergeProps(props1, props2)).toMatchObject({\n        style: {\n          color: 'blue',\n          width: '300px',\n          height: '300px',\n          fontSize: 30,\n          right: '10',\n          top: '10'\n        }\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"handlers","suites":["vnode","mergeProps"],"updatePoint":{"line":439,"column":18},"line":439,"code":"    test('handlers', () => {\n      let clickHandler1 = function () {}\n      let clickHandler2 = function () {}\n      let focusHandler2 = function () {}\n\n      let props1: Data = { onClick: clickHandler1 }\n      let props2: Data = { onClick: clickHandler2, onFocus: focusHandler2 }\n      expect(mergeProps(props1, props2)).toMatchObject({\n        onClick: [clickHandler1, clickHandler2],\n        onFocus: focusHandler2\n      })\n      let props3: Data = { onClick: undefined }\n      expect(mergeProps(props1, props3)).toMatchObject({\n        onClick: clickHandler1\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"default","suites":["vnode","mergeProps"],"updatePoint":{"line":456,"column":17},"line":456,"code":"    test('default', () => {\n      let props1: Data = { foo: 'c' }\n      let props2: Data = { foo: {}, bar: ['cc'] }\n      let props3: Data = { baz: { ccc: true } }\n      expect(mergeProps(props1, props2, props3)).toMatchObject({\n        foo: {},\n        bar: ['cc'],\n        baz: { ccc: true }\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with patchFlags","suites":["vnode","dynamic children"],"updatePoint":{"line":469,"column":25},"line":469,"code":"    test('with patchFlags', () => {\n      const hoist = createVNode('div')\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          (vnode1 = createVNode('div', null, 'text', PatchFlags.TEXT))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not track vnodes with only HYDRATE_EVENTS flag","suites":["vnode","dynamic children"],"updatePoint":{"line":481,"column":63},"line":481,"code":"    test('should not track vnodes with only HYDRATE_EVENTS flag', () => {\n      const hoist = createVNode('div')\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          createVNode('div', null, 'text', PatchFlags.HYDRATE_EVENTS)\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"many times call openBlock","suites":["vnode","dynamic children"],"updatePoint":{"line":492,"column":35},"line":492,"code":"    test('many times call openBlock', () => {\n      const hoist = createVNode('div')\n      let vnode1, vnode2, vnode3\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          (vnode1 = createVNode('div', null, 'text', PatchFlags.TEXT)),\n          (vnode2 =\n            (openBlock(),\n            createBlock('div', null, [\n              hoist,\n              (vnode3 = createVNode('div', null, 'text', PatchFlags.TEXT))\n            ])))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1, vnode2])\n      expect(vnode2.dynamicChildren).toStrictEqual([vnode3])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with stateful component","suites":["vnode","dynamic children"],"updatePoint":{"line":511,"column":33},"line":511,"code":"    test('with stateful component', () => {\n      const hoist = createVNode('div')\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          (vnode1 = createVNode({}, null, 'text'))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with functional component","suites":["vnode","dynamic children"],"updatePoint":{"line":523,"column":35},"line":523,"code":"    test('with functional component', () => {\n      const hoist = createVNode('div')\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          (vnode1 = createVNode(() => {}, null, 'text'))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"with suspense","suites":["vnode","dynamic children"],"updatePoint":{"line":535,"column":23},"line":535,"code":"    test('with suspense', () => {\n      const hoist = createVNode('div')\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          hoist,\n          (vnode1 = createVNode(() => {}, null, 'text'))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"element block should track normalized slot children","suites":["vnode","dynamic children"],"updatePoint":{"line":553,"column":61},"line":553,"code":"    test('element block should track normalized slot children', () => {\n      const hoist = createVNode('div')\n      let vnode1: any\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, {\n          default: () => {\n            return [\n              hoist,\n              (vnode1 = createVNode('div', null, 'text', PatchFlags.TEXT))\n            ]\n          }\n        }))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"openBlock w/ disableTracking: true","suites":["vnode","dynamic children"],"updatePoint":{"line":569,"column":44},"line":569,"code":"    test('openBlock w/ disableTracking: true', () => {\n      const hoist = createVNode('div')\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          // a v-for fragment block generated by the compiler\n          // disables tracking because it always diffs its\n          // children.\n          (vnode1 =\n            (openBlock(true),\n            createBlock(Fragment, null, [\n              hoist,\n              /*vnode2*/ createVNode(() => {}, null, 'text')\n            ])))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n      expect(vnode1.dynamicChildren).toStrictEqual([])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"openBlock without disableTracking: true","suites":["vnode","dynamic children"],"updatePoint":{"line":589,"column":49},"line":589,"code":"    test('openBlock without disableTracking: true', () => {\n      const hoist = createVNode('div')\n      let vnode1, vnode2\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          (vnode1 =\n            (openBlock(),\n            createBlock(Fragment, null, [\n              hoist,\n              (vnode2 = createVNode(() => {}, null, 'text'))\n            ])))\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([vnode1])\n      expect(vnode1.dynamicChildren).toStrictEqual([vnode2])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not track openBlock() when tracking is disabled","suites":["vnode","dynamic children"],"updatePoint":{"line":606,"column":64},"line":606,"code":"    test('should not track openBlock() when tracking is disabled', () => {\n      let vnode1\n      const vnode =\n        (openBlock(),\n        createBlock('div', null, [\n          setBlockTracking(-1),\n          (vnode1 = (openBlock(), createBlock('div'))),\n          setBlockTracking(1),\n          vnode1\n        ]))\n      expect(vnode.dynamicChildren).toStrictEqual([])\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"error of slot function execution should not affect block tracking","suites":["vnode","dynamic children"],"updatePoint":{"line":619,"column":75},"line":619,"code":"    test('error of slot function execution should not affect block tracking', () => {\n      expect(isBlockTreeEnabled).toStrictEqual(1)\n      const slotFn = withCtx(\n        () => {\n          throw new Error('slot execution error')\n        },\n        { type: {}, appContext: {} } as any\n      )\n      const Parent = {\n        setup(_: any, { slots }: any) {\n          return () => {\n            try {\n              slots.default()\n            } catch (e) {}\n          }\n        }\n      }\n      const vnode =\n        (openBlock(), createBlock(Parent, null, { default: slotFn }))\n      createApp(vnode).mount(nodeOps.createElement('div'))\n      expect(isBlockTreeEnabled).toStrictEqual(1)\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"no-op pass through","suites":["vnode","transformVNodeArgs"],"updatePoint":{"line":649,"column":28},"line":649,"code":"    test('no-op pass through', () => {\n      transformVNodeArgs(args => args)\n      const vnode = createVNode('div', { id: 'foo' }, 'hello')\n      expect(vnode).toMatchObject({\n        type: 'div',\n        props: { id: 'foo' },\n        children: 'hello',\n        shapeFlag: ShapeFlags.ELEMENT | ShapeFlags.TEXT_CHILDREN\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"direct override","suites":["vnode","transformVNodeArgs"],"updatePoint":{"line":660,"column":25},"line":660,"code":"    test('direct override', () => {\n      transformVNodeArgs(() => ['div', { id: 'foo' }, 'hello'])\n      const vnode = createVNode('p')\n      expect(vnode).toMatchObject({\n        type: 'div',\n        props: { id: 'foo' },\n        children: 'hello',\n        shapeFlag: ShapeFlags.ELEMENT | ShapeFlags.TEXT_CHILDREN\n      })\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"receive component instance as 2nd arg","suites":["vnode","transformVNodeArgs"],"updatePoint":{"line":671,"column":47},"line":671,"code":"    test('receive component instance as 2nd arg', () => {\n      transformVNodeArgs((args, instance) => {\n        if (instance) {\n          return ['h1', null, instance.type.name]\n        } else {\n          return args\n        }\n      })\n      const App = {\n        // this will be the name of the component in the h1\n        name: 'Root Component',\n        render() {\n          return h('p') // this will be overwritten by the transform\n        }\n      }\n      const root = nodeOps.createElement('div')\n      createApp(App).mount(root)\n      expect(serializeInner(root)).toBe('<h1>Root Component</h1>')\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should not be observable","suites":["vnode","transformVNodeArgs"],"updatePoint":{"line":691,"column":34},"line":691,"code":"    test('should not be observable', () => {\n      const a = createVNode('div')\n      const b = reactive(a)\n      expect(b).toBe(a)\n      expect(isReactive(b)).toBe(false)\n    })","file":"vnode.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work on element","suites":["renderer: vnode hooks"],"updatePoint":{"line":42,"column":30},"line":42,"code":"  test('should work on element', () => {\n    const hooks: VNodeProps = {\n      onVnodeBeforeMount: vi.fn(),\n      onVnodeMounted: vi.fn(),\n      onVnodeBeforeUpdate: vi.fn(vnode => {\n        expect((vnode.el as TestElement).children[0]).toMatchObject({\n          type: TestNodeTypes.TEXT,\n          text: 'foo'\n        })\n      }),\n      onVnodeUpdated: vi.fn(vnode => {\n        expect((vnode.el as TestElement).children[0]).toMatchObject({\n          type: TestNodeTypes.TEXT,\n          text: 'bar'\n        })\n      }),\n      onVnodeBeforeUnmount: vi.fn(),\n      onVnodeUnmounted: vi.fn()\n    }\n\n    assertHooks(hooks, h('div', hooks, 'foo'), h('div', hooks, 'bar'))\n  })","file":"vnodeHooks.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"should work on component","suites":["renderer: vnode hooks"],"updatePoint":{"line":65,"column":32},"line":65,"code":"  test('should work on component', () => {\n    const Comp = (props: { msg: string }) => props.msg\n\n    const hooks: VNodeProps = {\n      onVnodeBeforeMount: vi.fn(),\n      onVnodeMounted: vi.fn(),\n      onVnodeBeforeUpdate: vi.fn(vnode => {\n        expect(vnode.el as TestElement).toMatchObject({\n          type: TestNodeTypes.TEXT,\n          text: 'foo'\n        })\n      }),\n      onVnodeUpdated: vi.fn(vnode => {\n        expect(vnode.el as TestElement).toMatchObject({\n          type: TestNodeTypes.TEXT,\n          text: 'bar'\n        })\n      }),\n      onVnodeBeforeUnmount: vi.fn(),\n      onVnodeUnmounted: vi.fn()\n    }\n\n    assertHooks(\n      hooks,\n      h(Comp, {\n        ...hooks,\n        msg: 'foo'\n      }),\n      h(Comp, {\n        ...hooks,\n        msg: 'bar'\n      })\n    )\n  })","file":"vnodeHooks.spec.ts","skipped":false,"dir":"packages/runtime-core/__tests__"},{"name":"mount to SVG container","suites":["createApp for dom"],"updatePoint":{"line":6,"column":30},"line":6,"code":"  test('mount to SVG container', () => {\n    const root = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n    createApp({\n      render() {\n        return h('g')\n      }\n    }).mount(root)\n    expect(root.children.length).toBe(1)\n    expect(root.children[0] instanceof SVGElement).toBe(true)\n  })","file":"createApp.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should not mutate original root component options object","suites":["createApp for dom"],"updatePoint":{"line":18,"column":64},"line":18,"code":"  test('should not mutate original root component options object', () => {\n    const originalObj = {\n      data() {\n        return {\n          counter: 0\n        }\n      }\n    }\n\n    const handler = vi.fn(msg => {\n      expect(msg).toMatch(`Component is missing template or render function`)\n    })\n\n    const Root = { ...originalObj }\n\n    const app = createApp(Root)\n    app.config.warnHandler = handler\n    app.mount(document.createElement('div'))\n\n    // ensure mount is based on a copy of Root object rather than Root object itself\n    expect(app._component).not.toBe(Root)\n\n    // ensure no mutation happened to Root object\n    expect(originalObj).toMatchObject(Root)\n  })","file":"createApp.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work","suites":["defineCustomElement","mounting/unmount"],"updatePoint":{"line":37,"column":21},"line":37,"code":"    test('should work', () => {\n      container.innerHTML = `<my-element></my-element>`\n      const e = container.childNodes[0] as VueElement\n      expect(e).toBeInstanceOf(E)\n      expect(e._instance).toBeTruthy()\n      expect(e.shadowRoot!.innerHTML).toBe(`<div>hello</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work w/ manual instantiation","suites":["defineCustomElement","mounting/unmount"],"updatePoint":{"line":45,"column":45},"line":45,"code":"    test('should work w/ manual instantiation', () => {\n      const e = new E({ msg: 'inline' })\n      // should lazy init\n      expect(e._instance).toBe(null)\n      // should initialize on connect\n      container.appendChild(e)\n      expect(e._instance).toBeTruthy()\n      expect(e.shadowRoot!.innerHTML).toBe(`<div>inline</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should unmount on remove","suites":["defineCustomElement","mounting/unmount"],"updatePoint":{"line":55,"column":34},"line":55,"code":"    test('should unmount on remove', async () => {\n      container.innerHTML = `<my-element></my-element>`\n      const e = container.childNodes[0] as VueElement\n      container.removeChild(e)\n      await nextTick()\n      expect(e._instance).toBe(null)\n      expect(e.shadowRoot!.innerHTML).toBe('')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should not unmount on move","suites":["defineCustomElement","mounting/unmount"],"updatePoint":{"line":64,"column":36},"line":64,"code":"    test('should not unmount on move', async () => {\n      container.innerHTML = `<div><my-element></my-element></div>`\n      const e = container.childNodes[0].childNodes[0] as VueElement\n      const i = e._instance\n      // moving from one parent to another - this will trigger both disconnect\n      // and connected callbacks synchronously\n      container.appendChild(e)\n      await nextTick()\n      // should be the same instance\n      expect(e._instance).toBe(i)\n      expect(e.shadowRoot!.innerHTML).toBe('<div>hello</div>')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"remove then insert again","suites":["defineCustomElement","mounting/unmount"],"updatePoint":{"line":77,"column":34},"line":77,"code":"    test('remove then insert again', async () => {\n      container.innerHTML = `<my-element></my-element>`\n      const e = container.childNodes[0] as VueElement\n      container.removeChild(e)\n      await nextTick()\n      expect(e._instance).toBe(null)\n      expect(e.shadowRoot!.innerHTML).toBe('')\n      container.appendChild(e)\n      expect(e._instance).toBeTruthy()\n      expect(e.shadowRoot!.innerHTML).toBe('<div>hello</div>')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"props via attribute","suites":["defineCustomElement","props"],"updatePoint":{"line":102,"column":29},"line":102,"code":"    test('props via attribute', async () => {\n      // bazQux should map to `baz-qux` attribute\n      container.innerHTML = `<my-el-props foo=\"hello\" baz-qux=\"bye\"></my-el-props>`\n      const e = container.childNodes[0] as VueElement\n      expect(e.shadowRoot!.innerHTML).toBe('<div>hello</div><div>bye</div>')\n\n      // change attr\n      e.setAttribute('foo', 'changed')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe('<div>changed</div><div>bye</div>')\n\n      e.setAttribute('baz-qux', 'changed')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe(\n        '<div>changed</div><div>changed</div>'\n      )\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"props via properties","suites":["defineCustomElement","props"],"updatePoint":{"line":120,"column":30},"line":120,"code":"    test('props via properties', async () => {\n      const e = new E()\n      e.foo = 'one'\n      e.bar = { x: 'two' }\n      container.appendChild(e)\n      expect(e.shadowRoot!.innerHTML).toBe('<div>one</div><div>two</div>')\n\n      // reflect\n      // should reflect primitive value\n      expect(e.getAttribute('foo')).toBe('one')\n      // should not reflect rich data\n      expect(e.hasAttribute('bar')).toBe(false)\n\n      e.foo = 'three'\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe('<div>three</div><div>two</div>')\n      expect(e.getAttribute('foo')).toBe('three')\n\n      e.foo = null\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe('<div></div><div>two</div>')\n      expect(e.hasAttribute('foo')).toBe(false)\n\n      e.bazQux = 'four'\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe('<div></div><div>four</div>')\n      expect(e.getAttribute('baz-qux')).toBe('four')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"attribute -> prop type casting","suites":["defineCustomElement","props"],"updatePoint":{"line":149,"column":40},"line":149,"code":"    test('attribute -> prop type casting', async () => {\n      const E = defineCustomElement({\n        props: {\n          fooBar: Number, // test casting of camelCase prop names\n          bar: Boolean,\n          baz: String\n        },\n        render() {\n          return [\n            this.fooBar,\n            typeof this.fooBar,\n            this.bar,\n            typeof this.bar,\n            this.baz,\n            typeof this.baz\n          ].join(' ')\n        }\n      })\n      customElements.define('my-el-props-cast', E)\n      container.innerHTML = `<my-el-props-cast foo-bar=\"1\" baz=\"12345\"></my-el-props-cast>`\n      const e = container.childNodes[0] as VueElement\n      expect(e.shadowRoot!.innerHTML).toBe(\n        `1 number false boolean 12345 string`\n      )\n\n      e.setAttribute('bar', '')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe(`1 number true boolean 12345 string`)\n\n      e.setAttribute('foo-bar', '2e1')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe(\n        `20 number true boolean 12345 string`\n      )\n\n      e.setAttribute('baz', '2e1')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe(`20 number true boolean 2e1 string`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"attr casting w/ programmatic creation","suites":["defineCustomElement","props"],"updatePoint":{"line":190,"column":47},"line":190,"code":"    test('attr casting w/ programmatic creation', () => {\n      const E = defineCustomElement({\n        props: {\n          foo: Number\n        },\n        render() {\n          return `foo type: ${typeof this.foo}`\n        }\n      })\n      customElements.define('my-element-programmatic', E)\n      const el = document.createElement('my-element-programmatic') as any\n      el.setAttribute('foo', '123')\n      container.appendChild(el)\n      expect(el.shadowRoot.innerHTML).toBe(`foo type: number`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"handling properties set before upgrading","suites":["defineCustomElement","props"],"updatePoint":{"line":206,"column":50},"line":206,"code":"    test('handling properties set before upgrading', () => {\n      const E = defineCustomElement({\n        props: {\n          foo: String,\n          dataAge: Number\n        },\n        setup(props) {\n          expect(props.foo).toBe('hello')\n          expect(props.dataAge).toBe(5)\n        },\n        render() {\n          return h('div', `foo: ${this.foo}`)\n        }\n      })\n      const el = document.createElement('my-el-upgrade') as any\n      el.foo = 'hello'\n      el.dataset.age = 5\n      el.notProp = 1\n      container.appendChild(el)\n      customElements.define('my-el-upgrade', E)\n      expect(el.shadowRoot.firstChild.innerHTML).toBe(`foo: hello`)\n      // should not reflect if not declared as a prop\n      expect(el.hasAttribute('not-prop')).toBe(false)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"handle properties set before connecting","suites":["defineCustomElement","props"],"updatePoint":{"line":231,"column":49},"line":231,"code":"    test('handle properties set before connecting', () => {\n      const obj = { a: 1 }\n      const E = defineCustomElement({\n        props: {\n          foo: String,\n          post: Object\n        },\n        setup(props) {\n          expect(props.foo).toBe('hello')\n          expect(props.post).toBe(obj)\n        },\n        render() {\n          return JSON.stringify(this.post)\n        }\n      })\n      customElements.define('my-el-preconnect', E)\n      const el = document.createElement('my-el-preconnect') as any\n      el.foo = 'hello'\n      el.post = obj\n\n      container.appendChild(el)\n      expect(el.shadowRoot.innerHTML).toBe(JSON.stringify(obj))\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"handle components with no props","suites":["defineCustomElement","props"],"updatePoint":{"line":256,"column":41},"line":256,"code":"    test('handle components with no props', async () => {\n      const E = defineCustomElement({\n        render() {\n          return h('div', 'foo')\n        }\n      })\n      customElements.define('my-element-noprops', E)\n      const el = document.createElement('my-element-noprops')\n      container.appendChild(el)\n      await nextTick()\n      expect(el.shadowRoot!.innerHTML).toMatchInlineSnapshot('\"<div>foo</div>\"')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"set number value in dom property","suites":["defineCustomElement","props"],"updatePoint":{"line":270,"column":42},"line":270,"code":"    test('set number value in dom property', () => {\n      const E = defineCustomElement({\n        props: {\n          'max-age': Number\n        },\n        render() {\n          // @ts-ignore\n          return `max age: ${this.maxAge}/type: ${typeof this.maxAge}`\n        }\n      })\n      customElements.define('my-element-number-property', E)\n      const el = document.createElement('my-element-number-property') as any\n      container.appendChild(el)\n      el.maxAge = 50\n      expect(el.maxAge).toBe(50)\n      expect(el.shadowRoot.innerHTML).toBe('max age: 50/type: number')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"attrs via attribute","suites":["defineCustomElement","attrs"],"updatePoint":{"line":297,"column":29},"line":297,"code":"    test('attrs via attribute', async () => {\n      container.innerHTML = `<my-el-attrs foo=\"hello\"></my-el-attrs>`\n      const e = container.childNodes[0] as VueElement\n      expect(e.shadowRoot!.innerHTML).toBe('<div>hello</div>')\n\n      e.setAttribute('foo', 'changed')\n      await nextTick()\n      expect(e.shadowRoot!.innerHTML).toBe('<div>changed</div>')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"non-declared properties should not show up in $attrs","suites":["defineCustomElement","attrs"],"updatePoint":{"line":307,"column":62},"line":307,"code":"    test('non-declared properties should not show up in $attrs', () => {\n      const e = new E()\n      // @ts-ignore\n      e.foo = '123'\n      container.appendChild(e)\n      expect(e.shadowRoot!.innerHTML).toBe('<div></div>')\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"emit on connect","suites":["defineCustomElement","emits"],"updatePoint":{"line":334,"column":25},"line":334,"code":"    test('emit on connect', () => {\n      const e = new E()\n      const spy = vi.fn()\n      e.addEventListener('created', spy)\n      container.appendChild(e)\n      expect(spy).toHaveBeenCalled()\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"emit on interaction","suites":["defineCustomElement","emits"],"updatePoint":{"line":342,"column":29},"line":342,"code":"    test('emit on interaction', () => {\n      container.innerHTML = `<my-el-emits></my-el-emits>`\n      const e = container.childNodes[0] as VueElement\n      const spy = vi.fn()\n      e.addEventListener('my-click', spy)\n      e.shadowRoot!.childNodes[0].dispatchEvent(new CustomEvent('click'))\n      expect(spy).toHaveBeenCalledTimes(1)\n      expect(spy.mock.calls[0][0]).toMatchObject({\n        detail: [1]\n      })\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"case transform for camelCase event","suites":["defineCustomElement","emits"],"updatePoint":{"line":355,"column":44},"line":355,"code":"    test('case transform for camelCase event', () => {\n      container.innerHTML = `<my-el-emits></my-el-emits>`\n      const e = container.childNodes[0] as VueElement\n      const spy1 = vi.fn()\n      e.addEventListener('myEvent', spy1)\n      const spy2 = vi.fn()\n      // emitting myEvent, but listening for my-event. This happens when\n      // using the custom element in a Vue template\n      e.addEventListener('my-event', spy2)\n      e.shadowRoot!.childNodes[0].dispatchEvent(new CustomEvent('mousedown'))\n      expect(spy1).toHaveBeenCalledTimes(1)\n      expect(spy2).toHaveBeenCalledTimes(1)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"emit from within async component wrapper","suites":["defineCustomElement","emits"],"updatePoint":{"line":369,"column":50},"line":369,"code":"    test('emit from within async component wrapper', async () => {\n      const p = new Promise<typeof CompDef>(res => res(CompDef as any))\n      const E = defineCustomElement(defineAsyncComponent(() => p))\n      customElements.define('my-async-el-emits', E)\n      container.innerHTML = `<my-async-el-emits></my-async-el-emits>`\n      const e = container.childNodes[0] as VueElement\n      const spy = vi.fn()\n      e.addEventListener('my-click', spy)\n      // this feels brittle but seems necessary to reach the node in the DOM.\n      await customElements.whenDefined('my-async-el-emits')\n      await nextTick()\n      await nextTick()\n      e.shadowRoot!.childNodes[0].dispatchEvent(new CustomEvent('click'))\n      expect(spy).toHaveBeenCalled()\n      expect(spy.mock.calls[0][0]).toMatchObject({\n        detail: [1]\n      })\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"emit in an async component wrapper with properties bound","suites":["defineCustomElement","emits"],"updatePoint":{"line":388,"column":66},"line":388,"code":"    test('emit in an async component wrapper with properties bound', async () => {\n      const E = defineCustomElement(\n        defineAsyncComponent(\n          () => new Promise<typeof CompDef>(res => res(CompDef as any))\n        )\n      )\n      customElements.define('my-async-el-props-emits', E)\n      container.innerHTML = `<my-async-el-props-emits id=\"my_async_el_props_emits\"></my-async-el-props-emits>`\n      const e = container.childNodes[0] as VueElement\n      const spy = vi.fn()\n      e.addEventListener('my-click', spy)\n      await customElements.whenDefined('my-async-el-props-emits')\n      await nextTick()\n      await nextTick()\n      e.shadowRoot!.childNodes[0].dispatchEvent(new CustomEvent('click'))\n      expect(spy).toHaveBeenCalled()\n      expect(spy.mock.calls[0][0]).toMatchObject({\n        detail: [1]\n      })\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"default slot","suites":["defineCustomElement","slots"],"updatePoint":{"line":425,"column":22},"line":425,"code":"    test('default slot', () => {\n      container.innerHTML = `<my-el-slots><span>hi</span></my-el-slots>`\n      const e = container.childNodes[0] as VueElement\n      // native slots allocation does not affect innerHTML, so we just\n      // verify that we've rendered the correct native slots here...\n      expect(e.shadowRoot!.innerHTML).toBe(\n        `<div><slot><div>fallback</div></slot></div><div><slot name=\"named\"></slot></div>`\n      )\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"over nested usage","suites":["defineCustomElement","provide/inject"],"updatePoint":{"line":445,"column":27},"line":445,"code":"    test('over nested usage', async () => {\n      const foo = ref('injected!')\n      const Provider = defineCustomElement({\n        provide: {\n          foo\n        },\n        render() {\n          return h('my-consumer')\n        }\n      })\n      customElements.define('my-provider', Provider)\n      container.innerHTML = `<my-provider><my-provider>`\n      const provider = container.childNodes[0] as VueElement\n      const consumer = provider.shadowRoot!.childNodes[0] as VueElement\n\n      expect(consumer.shadowRoot!.innerHTML).toBe(`<div>injected!</div>`)\n\n      foo.value = 'changed!'\n      await nextTick()\n      expect(consumer.shadowRoot!.innerHTML).toBe(`<div>changed!</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"over slot composition","suites":["defineCustomElement","provide/inject"],"updatePoint":{"line":467,"column":31},"line":467,"code":"    test('over slot composition', async () => {\n      const foo = ref('injected!')\n      const Provider = defineCustomElement({\n        provide: {\n          foo\n        },\n        render() {\n          return renderSlot(this.$slots, 'default')\n        }\n      })\n      customElements.define('my-provider-2', Provider)\n\n      container.innerHTML = `<my-provider-2><my-consumer></my-consumer><my-provider-2>`\n      const provider = container.childNodes[0]\n      const consumer = provider.childNodes[0] as VueElement\n      expect(consumer.shadowRoot!.innerHTML).toBe(`<div>injected!</div>`)\n\n      foo.value = 'changed!'\n      await nextTick()\n      expect(consumer.shadowRoot!.innerHTML).toBe(`<div>changed!</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"inherited from ancestors","suites":["defineCustomElement","provide/inject"],"updatePoint":{"line":489,"column":34},"line":489,"code":"    test('inherited from ancestors', async () => {\n      const fooA = ref('FooA!')\n      const fooB = ref('FooB!')\n      const ProviderA = defineCustomElement({\n        provide: {\n          fooA\n        },\n        render() {\n          return h('provider-b')\n        }\n      })\n      const ProviderB = defineCustomElement({\n        provide: {\n          fooB\n        },\n        render() {\n          return h('my-multi-consumer')\n        }\n      })\n\n      const Consumer = defineCustomElement({\n        setup() {\n          const fooA = inject<Ref>('fooA')!\n          const fooB = inject<Ref>('fooB')!\n          return () => h('div', `${fooA.value} ${fooB.value}`)\n        }\n      })\n\n      customElements.define('provider-a', ProviderA)\n      customElements.define('provider-b', ProviderB)\n      customElements.define('my-multi-consumer', Consumer)\n      container.innerHTML = `<provider-a><provider-a>`\n      const providerA = container.childNodes[0] as VueElement\n      const providerB = providerA.shadowRoot!.childNodes[0] as VueElement\n      const consumer = providerB.shadowRoot!.childNodes[0] as VueElement\n\n      expect(consumer.shadowRoot!.innerHTML).toBe(`<div>FooA! FooB!</div>`)\n\n      fooA.value = 'changedA!'\n      fooB.value = 'changedB!'\n      await nextTick()\n      expect(consumer.shadowRoot!.innerHTML).toBe(\n        `<div>changedA! changedB!</div>`\n      )\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should attach styles to shadow dom","suites":["defineCustomElement","styles"],"updatePoint":{"line":537,"column":44},"line":537,"code":"    test('should attach styles to shadow dom', () => {\n      const Foo = defineCustomElement({\n        styles: [`div { color: red; }`],\n        render() {\n          return h('div', 'hello')\n        }\n      })\n      customElements.define('my-el-with-styles', Foo)\n      container.innerHTML = `<my-el-with-styles></my-el-with-styles>`\n      const el = container.childNodes[0] as VueElement\n      const style = el.shadowRoot?.querySelector('style')!\n      expect(style.textContent).toBe(`div { color: red; }`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work","suites":["defineCustomElement","async"],"updatePoint":{"line":553,"column":21},"line":553,"code":"    test('should work', async () => {\n      const loaderSpy = vi.fn()\n      const E = defineCustomElement(\n        defineAsyncComponent(() => {\n          loaderSpy()\n          return Promise.resolve({\n            props: ['msg'],\n            styles: [`div { color: red }`],\n            render(this: any) {\n              return h('div', null, this.msg)\n            }\n          })\n        })\n      )\n      customElements.define('my-el-async', E)\n      container.innerHTML =\n        `<my-el-async msg=\"hello\"></my-el-async>` +\n        `<my-el-async msg=\"world\"></my-el-async>`\n\n      await new Promise(r => setTimeout(r))\n\n      // loader should be called only once\n      expect(loaderSpy).toHaveBeenCalledTimes(1)\n\n      const e1 = container.childNodes[0] as VueElement\n      const e2 = container.childNodes[1] as VueElement\n\n      // should inject styles\n      expect(e1.shadowRoot!.innerHTML).toBe(\n        `<style>div { color: red }</style><div>hello</div>`\n      )\n      expect(e2.shadowRoot!.innerHTML).toBe(\n        `<style>div { color: red }</style><div>world</div>`\n      )\n\n      // attr\n      e1.setAttribute('msg', 'attr')\n      await nextTick()\n      expect((e1 as any).msg).toBe('attr')\n      expect(e1.shadowRoot!.innerHTML).toBe(\n        `<style>div { color: red }</style><div>attr</div>`\n      )\n\n      // props\n      expect(`msg` in e1).toBe(true)\n      ;(e1 as any).msg = 'prop'\n      expect(e1.getAttribute('msg')).toBe('prop')\n      expect(e1.shadowRoot!.innerHTML).toBe(\n        `<style>div { color: red }</style><div>prop</div>`\n      )\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"set DOM property before resolve","suites":["defineCustomElement","async"],"updatePoint":{"line":605,"column":41},"line":605,"code":"    test('set DOM property before resolve', async () => {\n      const E = defineCustomElement(\n        defineAsyncComponent(() => {\n          return Promise.resolve({\n            props: ['msg'],\n            setup(props) {\n              expect(typeof props.msg).toBe('string')\n            },\n            render(this: any) {\n              return h('div', this.msg)\n            }\n          })\n        })\n      )\n      customElements.define('my-el-async-2', E)\n\n      const e1 = new E()\n\n      // set property before connect\n      e1.msg = 'hello'\n\n      const e2 = new E()\n\n      container.appendChild(e1)\n      container.appendChild(e2)\n\n      // set property after connect but before resolve\n      e2.msg = 'world'\n\n      await new Promise(r => setTimeout(r))\n\n      expect(e1.shadowRoot!.innerHTML).toBe(`<div>hello</div>`)\n      expect(e2.shadowRoot!.innerHTML).toBe(`<div>world</div>`)\n\n      e1.msg = 'world'\n      expect(e1.shadowRoot!.innerHTML).toBe(`<div>world</div>`)\n\n      e2.msg = 'hello'\n      expect(e2.shadowRoot!.innerHTML).toBe(`<div>hello</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"Number prop casting before resolve","suites":["defineCustomElement","async"],"updatePoint":{"line":646,"column":44},"line":646,"code":"    test('Number prop casting before resolve', async () => {\n      const E = defineCustomElement(\n        defineAsyncComponent(() => {\n          return Promise.resolve({\n            props: { n: Number },\n            setup(props) {\n              expect(props.n).toBe(20)\n            },\n            render(this: any) {\n              return h('div', this.n + ',' + typeof this.n)\n            }\n          })\n        })\n      )\n      customElements.define('my-el-async-3', E)\n      container.innerHTML = `<my-el-async-3 n=\"2e1\"></my-el-async-3>`\n\n      await new Promise(r => setTimeout(r))\n\n      const e = container.childNodes[0] as VueElement\n      expect(e.shadowRoot!.innerHTML).toBe(`<div>20,number</div>`)\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with slots","suites":["defineCustomElement","async"],"updatePoint":{"line":669,"column":20},"line":669,"code":"    test('with slots', async () => {\n      const E = defineCustomElement(\n        defineAsyncComponent(() => {\n          return Promise.resolve({\n            render(this: any) {\n              return [\n                h('div', null, [\n                  renderSlot(this.$slots, 'default', undefined, () => [\n                    h('div', 'fallback')\n                  ])\n                ]),\n                h('div', null, renderSlot(this.$slots, 'named'))\n              ]\n            }\n          })\n        })\n      )\n      customElements.define('my-el-async-slots', E)\n      container.innerHTML = `<my-el-async-slots><span>hi</span></my-el-async-slots>`\n\n      await new Promise(r => setTimeout(r))\n\n      const e = container.childNodes[0] as VueElement\n      expect(e.shadowRoot!.innerHTML).toBe(\n        `<div><slot><div>fallback</div></slot></div><div><slot name=\"named\"></slot></div>`\n      )\n    })","file":"customElement.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should created element with is option","suites":["customized built-in elements support"],"updatePoint":{"line":10,"column":45},"line":10,"code":"  test('should created element with is option', () => {\n    const root = document.createElement('div')\n    createElement = vi.spyOn(document, 'createElement')\n    render(h('button', { is: 'plastic-button' }), root)\n    expect(createElement.mock.calls[0]).toMatchObject([\n      'button',\n      { is: 'plastic-button' }\n    ])\n    // should also render the attribute\n    expect(root.innerHTML).toBe(`<button is=\"plastic-button\"></button>`)\n  })","file":"customizedBuiltIn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should be removed after compile","suites":["vCloak"],"updatePoint":{"line":4,"column":39},"line":4,"code":"  test('should be removed after compile', () => {\n    const root = document.createElement('div')\n    root.setAttribute('v-cloak', '')\n    createApp({\n      render() {}\n    }).mount(root)\n    expect(root.hasAttribute('v-cloak')).toBe(false)\n  })","file":"directives/vCloak.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with text input","suites":["vModel"],"updatePoint":{"line":32,"column":33},"line":32,"code":"  it('should work with text input', async () => {\n    const manualListener = vi.fn()\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              'onUpdate:modelValue': setValue.bind(this),\n              onInput: () => {\n                manualListener(data.value)\n              }\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')!\n    const data = root._vnode.component.data\n    expect(input.value).toEqual('')\n\n    input.value = 'foo'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(data.value).toEqual('foo')\n    // #1931\n    expect(manualListener).toHaveBeenCalledWith('foo')\n\n    data.value = 'bar'\n    await nextTick()\n    expect(input.value).toEqual('bar')\n\n    data.value = undefined\n    await nextTick()\n    expect(input.value).toEqual('')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with number input","suites":["vModel"],"updatePoint":{"line":74,"column":35},"line":74,"code":"  it('should work with number input', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'number',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')!\n    const data = root._vnode.component.data\n    expect(input.value).toEqual('')\n    expect(input.type).toEqual('number')\n\n    input.value = 1\n    triggerEvent('input', input)\n    await nextTick()\n    expect(typeof data.value).toEqual('number')\n    expect(data.value).toEqual(1)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with multiple listeners","suites":["vModel"],"updatePoint":{"line":105,"column":41},"line":105,"code":"  it('should work with multiple listeners', async () => {\n    const spy = vi.fn()\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              'onUpdate:modelValue': [setValue.bind(this), spy]\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')!\n    const data = root._vnode.component.data\n\n    input.value = 'foo'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(data.value).toEqual('foo')\n    expect(spy).toHaveBeenCalledWith('foo')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with updated listeners","suites":["vModel"],"updatePoint":{"line":134,"column":40},"line":134,"code":"  it('should work with updated listeners', async () => {\n    const spy1 = vi.fn()\n    const spy2 = vi.fn()\n    const toggle = ref(true)\n\n    const component = defineComponent({\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              'onUpdate:modelValue': toggle.value ? spy1 : spy2\n            }),\n            'foo'\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')!\n\n    input.value = 'foo'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(spy1).toHaveBeenCalledWith('foo')\n\n    // update listener\n    toggle.value = false\n    await nextTick()\n\n    input.value = 'bar'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(spy1).not.toHaveBeenCalledWith('bar')\n    expect(spy2).toHaveBeenCalledWith('bar')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with textarea","suites":["vModel"],"updatePoint":{"line":171,"column":31},"line":171,"code":"  it('should work with textarea', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('textarea', {\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('textarea')\n    const data = root._vnode.component.data\n\n    input.value = 'foo'\n    triggerEvent('input', input)\n    await nextTick()\n    expect(data.value).toEqual('foo')\n\n    data.value = 'bar'\n    await nextTick()\n    expect(input.value).toEqual('bar')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support modifiers","suites":["vModel"],"updatePoint":{"line":202,"column":30},"line":202,"code":"  it('should support modifiers', async () => {\n    const component = defineComponent({\n      data() {\n        return { number: null, trim: null, lazy: null, trimNumber: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              class: 'number',\n              'onUpdate:modelValue': (val: any) => {\n                this.number = val\n              }\n            }),\n            this.number,\n            {\n              number: true\n            }\n          ),\n          withVModel(\n            h('input', {\n              class: 'trim',\n              'onUpdate:modelValue': (val: any) => {\n                this.trim = val\n              }\n            }),\n            this.trim,\n            {\n              trim: true\n            }\n          ),\n          withVModel(\n            h('input', {\n              class: 'trim-number',\n              'onUpdate:modelValue': (val: any) => {\n                this.trimNumber = val\n              }\n            }),\n            this.trimNumber,\n            {\n              trim: true,\n              number: true\n            }\n          ),\n          withVModel(\n            h('input', {\n              class: 'lazy',\n              'onUpdate:modelValue': (val: any) => {\n                this.lazy = val\n              }\n            }),\n            this.lazy,\n            {\n              lazy: true\n            }\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const number = root.querySelector('.number')\n    const trim = root.querySelector('.trim')\n    const trimNumber = root.querySelector('.trim-number')\n    const lazy = root.querySelector('.lazy')\n    const data = root._vnode.component.data\n\n    number.value = '+01.2'\n    triggerEvent('input', number)\n    await nextTick()\n    expect(data.number).toEqual(1.2)\n\n    trim.value = '    hello, world    '\n    triggerEvent('input', trim)\n    await nextTick()\n    expect(data.trim).toEqual('hello, world')\n\n    trimNumber.value = '    1    '\n    triggerEvent('input', trimNumber)\n    await nextTick()\n    expect(data.trimNumber).toEqual(1)\n\n    trimNumber.value = '    +01.2    '\n    triggerEvent('input', trimNumber)\n    await nextTick()\n    expect(data.trimNumber).toEqual(1.2)\n\n    lazy.value = 'foo'\n    triggerEvent('change', lazy)\n    await nextTick()\n    expect(data.lazy).toEqual('foo')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with range","suites":["vModel"],"updatePoint":{"line":295,"column":28},"line":295,"code":"  it('should work with range', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: 25 }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'range',\n              min: 1,\n              max: 100,\n              class: 'foo',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value,\n            {\n              number: true\n            }\n          ),\n          withVModel(\n            h('input', {\n              type: 'range',\n              min: 1,\n              max: 100,\n              class: 'bar',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value,\n            {\n              lazy: true\n            }\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const foo = root.querySelector('.foo')\n    const bar = root.querySelector('.bar')\n    const data = root._vnode.component.data\n\n    foo.value = 20\n    triggerEvent('input', foo)\n    await nextTick()\n    expect(data.value).toEqual(20)\n\n    foo.value = 200\n    triggerEvent('input', foo)\n    await nextTick()\n    expect(data.value).toEqual(100)\n\n    foo.value = -1\n    triggerEvent('input', foo)\n    await nextTick()\n    expect(data.value).toEqual(1)\n\n    bar.value = 30\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toEqual('30')\n\n    bar.value = 200\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toEqual('100')\n\n    bar.value = -1\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toEqual('1')\n\n    data.value = 60\n    await nextTick()\n    expect(foo.value).toEqual('60')\n    expect(bar.value).toEqual('60')\n\n    data.value = -1\n    await nextTick()\n    expect(foo.value).toEqual('1')\n    expect(bar.value).toEqual('1')\n\n    data.value = 200\n    await nextTick()\n    expect(foo.value).toEqual('100')\n    expect(bar.value).toEqual('100')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with checkbox","suites":["vModel"],"updatePoint":{"line":383,"column":31},"line":383,"code":"  it('should work with checkbox', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')\n    const data = root._vnode.component.data\n\n    input.checked = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual(true)\n\n    data.value = false\n    await nextTick()\n    expect(input.checked).toEqual(false)\n\n    data.value = true\n    await nextTick()\n    expect(input.checked).toEqual(true)\n\n    input.checked = false\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual(false)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with checkbox and true-value/false-value","suites":["vModel"],"updatePoint":{"line":424,"column":58},"line":424,"code":"  it('should work with checkbox and true-value/false-value', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: 'yes' }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              'true-value': 'yes',\n              'false-value': 'no',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')\n    const data = root._vnode.component.data\n\n    // DOM checked state should respect initial true-value/false-value\n    expect(input.checked).toEqual(true)\n\n    input.checked = false\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual('no')\n\n    data.value = 'yes'\n    await nextTick()\n    expect(input.checked).toEqual(true)\n\n    data.value = 'no'\n    await nextTick()\n    expect(input.checked).toEqual(false)\n\n    input.checked = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual('yes')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with checkbox and true-value/false-value with object values","suites":["vModel"],"updatePoint":{"line":470,"column":77},"line":470,"code":"  it('should work with checkbox and true-value/false-value with object values', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              'true-value': { yes: 'yes' },\n              'false-value': { no: 'no' },\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')\n    const data = root._vnode.component.data\n\n    input.checked = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual({ yes: 'yes' })\n\n    data.value = { no: 'no' }\n    await nextTick()\n    expect(input.checked).toEqual(false)\n\n    data.value = { yes: 'yes' }\n    await nextTick()\n    expect(input.checked).toEqual(true)\n\n    input.checked = false\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual({ no: 'no' })\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support array as a checkbox model","suites":["vModel"],"updatePoint":{"line":513,"column":46},"line":513,"code":"  it(`should support array as a checkbox model`, async () => {\n    const component = defineComponent({\n      data() {\n        return { value: [] }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              class: 'foo',\n              value: 'foo',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          ),\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              class: 'bar',\n              value: 'bar',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const foo = root.querySelector('.foo')\n    const bar = root.querySelector('.bar')\n    const data = root._vnode.component.data\n\n    foo.checked = true\n    triggerEvent('change', foo)\n    await nextTick()\n    expect(data.value).toMatchObject(['foo'])\n\n    bar.checked = true\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toMatchObject(['foo', 'bar'])\n\n    bar.checked = false\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toMatchObject(['foo'])\n\n    foo.checked = false\n    triggerEvent('change', foo)\n    await nextTick()\n    expect(data.value).toMatchObject([])\n\n    data.value = ['foo']\n    await nextTick()\n    expect(bar.checked).toEqual(false)\n    expect(foo.checked).toEqual(true)\n\n    data.value = ['bar']\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(true)\n\n    data.value = []\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(false)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support Set as a checkbox model","suites":["vModel"],"updatePoint":{"line":583,"column":44},"line":583,"code":"  it(`should support Set as a checkbox model`, async () => {\n    const component = defineComponent({\n      data() {\n        return { value: new Set() }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              class: 'foo',\n              value: 'foo',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          ),\n          withVModel(\n            h('input', {\n              type: 'checkbox',\n              class: 'bar',\n              value: 'bar',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const foo = root.querySelector('.foo')\n    const bar = root.querySelector('.bar')\n    const data = root._vnode.component.data\n\n    foo.checked = true\n    triggerEvent('change', foo)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set(['foo']))\n\n    bar.checked = true\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set(['foo', 'bar']))\n\n    bar.checked = false\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set(['foo']))\n\n    foo.checked = false\n    triggerEvent('change', foo)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set())\n\n    data.value = new Set(['foo'])\n    await nextTick()\n    expect(bar.checked).toEqual(false)\n    expect(foo.checked).toEqual(true)\n\n    data.value = new Set(['bar'])\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(true)\n\n    data.value = new Set()\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(false)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with radio","suites":["vModel"],"updatePoint":{"line":653,"column":28},"line":653,"code":"  it('should work with radio', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              type: 'radio',\n              class: 'foo',\n              value: 'foo',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          ),\n          withVModel(\n            h('input', {\n              type: 'radio',\n              class: 'bar',\n              value: 'bar',\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const foo = root.querySelector('.foo')\n    const bar = root.querySelector('.bar')\n    const data = root._vnode.component.data\n\n    foo.checked = true\n    triggerEvent('change', foo)\n    await nextTick()\n    expect(data.value).toEqual('foo')\n\n    bar.checked = true\n    triggerEvent('change', bar)\n    await nextTick()\n    expect(data.value).toEqual('bar')\n\n    data.value = null\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(false)\n\n    data.value = 'foo'\n    await nextTick()\n    expect(foo.checked).toEqual(true)\n    expect(bar.checked).toEqual(false)\n\n    data.value = 'bar'\n    await nextTick()\n    expect(foo.checked).toEqual(false)\n    expect(bar.checked).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with single select","suites":["vModel"],"updatePoint":{"line":713,"column":36},"line":713,"code":"  it('should work with single select', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [h('option', { value: 'foo' }), h('option', { value: 'bar' })]\n            ),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('select')\n    const foo = root.querySelector('option[value=foo]')\n    const bar = root.querySelector('option[value=bar]')\n    const data = root._vnode.component.data\n\n    foo.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual('foo')\n\n    foo.selected = false\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toEqual('bar')\n\n    foo.selected = false\n    bar.selected = false\n    data.value = 'foo'\n    await nextTick()\n    expect(input.value).toEqual('foo')\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(false)\n\n    foo.selected = true\n    bar.selected = false\n    data.value = 'bar'\n    await nextTick()\n    expect(input.value).toEqual('bar')\n    expect(foo.selected).toEqual(false)\n    expect(bar.selected).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"multiple select (model is Array)","suites":["vModel"],"updatePoint":{"line":769,"column":38},"line":769,"code":"  it('multiple select (model is Array)', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: [] }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                multiple: true,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [h('option', { value: 'foo' }), h('option', { value: 'bar' })]\n            ),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('select')\n    const foo = root.querySelector('option[value=foo]')\n    const bar = root.querySelector('option[value=bar]')\n    const data = root._vnode.component.data\n\n    foo.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(['foo'])\n\n    foo.selected = false\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(['bar'])\n\n    foo.selected = true\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(['foo', 'bar'])\n\n    foo.selected = false\n    bar.selected = false\n    data.value = ['foo']\n    await nextTick()\n    expect(input.value).toEqual('foo')\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(false)\n\n    foo.selected = false\n    bar.selected = false\n    data.value = ['foo', 'bar']\n    await nextTick()\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"v-model.number should work with select tag","suites":["vModel"],"updatePoint":{"line":831,"column":48},"line":831,"code":"  it('v-model.number should work with select tag', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: null }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [h('option', { value: '1' }), h('option', { value: '2' })]\n            ),\n            this.value,\n            {\n              number: true\n            }\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('select')\n    const one = root.querySelector('option[value=\"1\"]')\n    const data = root._vnode.component.data\n\n    one.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(typeof data.value).toEqual('number')\n    expect(data.value).toEqual(1)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"v-model.number should work with multiple select","suites":["vModel"],"updatePoint":{"line":868,"column":53},"line":868,"code":"  it('v-model.number should work with multiple select', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: [] }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                multiple: true,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [h('option', { value: '1' }), h('option', { value: '2' })]\n            ),\n            this.value,\n            {\n              number: true\n            }\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('select')\n    const one = root.querySelector('option[value=\"1\"]')\n    const two = root.querySelector('option[value=\"2\"]')\n    const data = root._vnode.component.data\n\n    one.selected = true\n    two.selected = false\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([1])\n\n    one.selected = false\n    two.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([2])\n\n    one.selected = true\n    two.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([1, 2])\n\n    one.selected = false\n    two.selected = false\n    data.value = [1]\n    await nextTick()\n    expect(one.selected).toEqual(true)\n    expect(two.selected).toEqual(false)\n\n    one.selected = false\n    two.selected = false\n    data.value = [1, 2]\n    await nextTick()\n    expect(one.selected).toEqual(true)\n    expect(two.selected).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"multiple select (model is Array, option value is object)","suites":["vModel"],"updatePoint":{"line":933,"column":62},"line":933,"code":"  it('multiple select (model is Array, option value is object)', async () => {\n    const fooValue = { foo: 1 }\n    const barValue = { bar: 1 }\n\n    const component = defineComponent({\n      data() {\n        return { value: [] }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                multiple: true,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [\n                h('option', { value: fooValue }),\n                h('option', { value: barValue })\n              ]\n            ),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    await nextTick()\n\n    const input = root.querySelector('select')\n    const [foo, bar] = root.querySelectorAll('option')\n    const data = root._vnode.component.data\n\n    foo.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([fooValue])\n\n    foo.selected = false\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([barValue])\n\n    foo.selected = true\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject([fooValue, barValue])\n\n    foo.selected = false\n    bar.selected = false\n    data.value = [fooValue, barValue]\n    await nextTick()\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(true)\n\n    foo.selected = false\n    bar.selected = false\n    data.value = [{ foo: 1 }, { bar: 1 }]\n    await nextTick()\n    // looseEqual\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"multiple select (model is Set)","suites":["vModel"],"updatePoint":{"line":1002,"column":36},"line":1002,"code":"  it('multiple select (model is Set)', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: new Set() }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                multiple: true,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [h('option', { value: 'foo' }), h('option', { value: 'bar' })]\n            ),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('select')\n    const foo = root.querySelector('option[value=foo]')\n    const bar = root.querySelector('option[value=bar]')\n    const data = root._vnode.component.data\n\n    foo.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toBeInstanceOf(Set)\n    expect(data.value).toMatchObject(new Set(['foo']))\n\n    foo.selected = false\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toBeInstanceOf(Set)\n    expect(data.value).toMatchObject(new Set(['bar']))\n\n    foo.selected = true\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toBeInstanceOf(Set)\n    expect(data.value).toMatchObject(new Set(['foo', 'bar']))\n\n    foo.selected = false\n    bar.selected = false\n    data.value = new Set(['foo'])\n    await nextTick()\n    expect(input.value).toEqual('foo')\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(false)\n\n    foo.selected = false\n    bar.selected = false\n    data.value = new Set(['foo', 'bar'])\n    await nextTick()\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(true)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"multiple select (model is Set, option value is object)","suites":["vModel"],"updatePoint":{"line":1067,"column":60},"line":1067,"code":"  it('multiple select (model is Set, option value is object)', async () => {\n    const fooValue = { foo: 1 }\n    const barValue = { bar: 1 }\n\n    const component = defineComponent({\n      data() {\n        return { value: new Set() }\n      },\n      render() {\n        return [\n          withVModel(\n            h(\n              'select',\n              {\n                value: null,\n                multiple: true,\n                'onUpdate:modelValue': setValue.bind(this)\n              },\n              [\n                h('option', { value: fooValue }),\n                h('option', { value: barValue })\n              ]\n            ),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    await nextTick()\n\n    const input = root.querySelector('select')\n    const [foo, bar] = root.querySelectorAll('option')\n    const data = root._vnode.component.data\n\n    foo.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set([fooValue]))\n\n    foo.selected = false\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set([barValue]))\n\n    foo.selected = true\n    bar.selected = true\n    triggerEvent('change', input)\n    await nextTick()\n    expect(data.value).toMatchObject(new Set([fooValue, barValue]))\n\n    foo.selected = false\n    bar.selected = false\n    data.value = new Set([fooValue, barValue])\n    await nextTick()\n    expect(foo.selected).toEqual(true)\n    expect(bar.selected).toEqual(true)\n\n    foo.selected = false\n    bar.selected = false\n    data.value = new Set([{ foo: 1 }, { bar: 1 }])\n    await nextTick()\n    // without looseEqual, here is different from Array\n    expect(foo.selected).toEqual(false)\n    expect(bar.selected).toEqual(false)\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work with composition session","suites":["vModel"],"updatePoint":{"line":1136,"column":42},"line":1136,"code":"  it('should work with composition session', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: '' }\n      },\n      render() {\n        return [\n          withVModel(\n            h('input', {\n              'onUpdate:modelValue': setValue.bind(this)\n            }),\n            this.value\n          )\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const input = root.querySelector('input')!\n    const data = root._vnode.component.data\n    expect(input.value).toEqual('')\n\n    //developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event\n    //compositionstart event could be fired after a user starts entering a Chinese character using a Pinyin IME\n    input.value = ''\n    triggerEvent('compositionstart', input)\n    await nextTick()\n    expect(data.value).toEqual('')\n\n    // input event has no effect during composition session\n    input.value = ''\n    triggerEvent('input', input)\n    await nextTick()\n    expect(data.value).toEqual('')\n\n    // After compositionend event being fired, an input event will be automatically trigger\n    triggerEvent('compositionend', input)\n    await nextTick()\n    expect(data.value).toEqual('')\n  })","file":"directives/vModel.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"it should support \"stop\" and \"prevent\"","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":21,"column":46},"line":21,"code":"  test('it should support \"stop\" and \"prevent\"', () => {\n    const parent = document.createElement('div')\n    const child = document.createElement('input')\n    parent.appendChild(child)\n    const childNextValue = withModifiers(vi.fn(), ['prevent', 'stop'])\n    patchEvent(child, 'onClick', null, childNextValue, null)\n    const parentNextValue = vi.fn()\n    patchEvent(parent, 'onClick', null, parentNextValue, null)\n    expect(triggerEvent(child, 'click').defaultPrevented).toBe(true)\n    expect(parentNextValue).not.toBeCalled()\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"it should support \"self\"","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":33,"column":32},"line":33,"code":"  test('it should support \"self\"', () => {\n    const parent = document.createElement('div')\n    const child = document.createElement('input')\n    parent.appendChild(child)\n    const fn = vi.fn()\n    const handler = withModifiers(fn, ['self'])\n    patchEvent(parent, 'onClick', null, handler, null)\n    triggerEvent(child, 'click')\n    expect(fn).not.toBeCalled()\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"it should support key modifiers and system modifiers","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":44,"column":60},"line":44,"code":"  test('it should support key modifiers and system modifiers', () => {\n    const keyNames = ['ctrl', 'shift', 'meta', 'alt']\n\n    keyNames.forEach(keyName => {\n      const el = document.createElement('div')\n      const fn = vi.fn()\n      // <div @keyup[keyName].esc=\"test\"/>\n      const nextValue = withKeys(withModifiers(fn, [keyName]), [\n        'esc',\n        'arrow-left'\n      ])\n      patchEvent(el, 'onKeyup', null, nextValue, null)\n\n      triggerEvent(el, 'keyup', e => (e.key = 'a'))\n      expect(fn).not.toBeCalled()\n\n      triggerEvent(el, 'keyup', e => {\n        e[`${keyName}Key`] = false\n        e.key = 'esc'\n      })\n      expect(fn).not.toBeCalled()\n\n      triggerEvent(el, 'keyup', e => {\n        e[`${keyName}Key`] = true\n        e.key = 'Escape'\n      })\n      expect(fn).toBeCalledTimes(1)\n\n      triggerEvent(el, 'keyup', e => {\n        e[`${keyName}Key`] = true\n        e.key = 'ArrowLeft'\n      })\n      expect(fn).toBeCalledTimes(2)\n    })\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"it should support \"exact\" modifier","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":80,"column":42},"line":80,"code":"  test('it should support \"exact\" modifier', () => {\n    const el = document.createElement('div')\n    // Case 1: <div @keyup.exact=\"test\"/>\n    const fn1 = vi.fn()\n    const next1 = withModifiers(fn1, ['exact'])\n    patchEvent(el, 'onKeyup', null, next1, null)\n    triggerEvent(el, 'keyup')\n    expect(fn1.mock.calls.length).toBe(1)\n    triggerEvent(el, 'keyup', e => (e.ctrlKey = true))\n    expect(fn1.mock.calls.length).toBe(1)\n    // Case 2: <div @keyup.ctrl.a.exact=\"test\"/>\n    const fn2 = vi.fn()\n    const next2 = withKeys(withModifiers(fn2, ['ctrl', 'exact']), ['a'])\n    patchEvent(el, 'onKeyup', null, next2, null)\n    triggerEvent(el, 'keyup', e => (e.key = 'a'))\n    expect(fn2).not.toBeCalled()\n    triggerEvent(el, 'keyup', e => {\n      e.key = 'a'\n      e.ctrlKey = true\n    })\n    expect(fn2.mock.calls.length).toBe(1)\n    triggerEvent(el, 'keyup', e => {\n      // should not trigger if has other system modifiers\n      e.key = 'a'\n      e.ctrlKey = true\n      e.altKey = true\n    })\n    expect(fn2.mock.calls.length).toBe(1)\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support mouse modifiers","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":110,"column":36},"line":110,"code":"  it('should support mouse modifiers', () => {\n    const buttons = ['left', 'middle', 'right'] as const\n    const buttonCodes = { left: 0, middle: 1, right: 2 }\n    buttons.forEach(button => {\n      const el = document.createElement('div')\n      const fn = vi.fn()\n      const handler = withModifiers(fn, [button])\n      patchEvent(el, 'onMousedown', null, handler, null)\n      buttons\n        .filter(b => b !== button)\n        .forEach(button => {\n          triggerEvent(el, 'mousedown', e => (e.button = buttonCodes[button]))\n        })\n      expect(fn).not.toBeCalled()\n      triggerEvent(el, 'mousedown', e => (e.button = buttonCodes[button]))\n      expect(fn).toBeCalled()\n    })\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should handle multiple arguments when using modifiers","suites":["runtime-dom: v-on directive"],"updatePoint":{"line":129,"column":59},"line":129,"code":"  it('should handle multiple arguments when using modifiers', () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    const handler = withModifiers(fn, ['ctrl'])\n    const event = triggerEvent(el, 'click', e => (e.ctrlKey = true))\n    handler(event, 'value', true)\n    expect(fn).toBeCalledWith(event, 'value', true)\n  })","file":"directives/vOn.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should check show value is truthy","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":22,"column":41},"line":22,"code":"  test('should check show value is truthy', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: true }\n      },\n      render() {\n        return [withVShow(h('div'), this.value)]\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n\n    expect($div.style.display).toEqual('')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should check show value is falsy","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":38,"column":40},"line":38,"code":"  test('should check show value is falsy', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: false }\n      },\n      render() {\n        return [withVShow(h('div'), this.value)]\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n\n    expect($div.style.display).toEqual('none')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should update show value changed","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":54,"column":38},"line":54,"code":"  it('should update show value changed', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: true }\n      },\n      render() {\n        return [withVShow(h('div'), this.value)]\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n    const data = root._vnode.component.data\n\n    expect($div.style.display).toEqual('')\n\n    data.value = false\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    data.value = {}\n    await nextTick()\n    expect($div.style.display).toEqual('')\n\n    data.value = 0\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    data.value = []\n    await nextTick()\n    expect($div.style.display).toEqual('')\n\n    data.value = null\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    data.value = '0'\n    await nextTick()\n    expect($div.style.display).toEqual('')\n\n    data.value = undefined\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    data.value = 1\n    await nextTick()\n    expect($div.style.display).toEqual('')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should respect display value in style attribute","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":103,"column":55},"line":103,"code":"  test('should respect display value in style attribute', async () => {\n    const component = defineComponent({\n      data() {\n        return { value: true }\n      },\n      render() {\n        return [\n          withVShow(h('div', { style: { display: 'block' } }), this.value)\n        ]\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n    const data = root._vnode.component.data\n\n    expect($div.style.display).toEqual('block')\n\n    data.value = false\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    data.value = true\n    await nextTick()\n    expect($div.style.display).toEqual('block')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"the value of `display` set by v-show should not be overwritten by the style attribute when updated","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":131,"column":106},"line":131,"code":"  test('the value of `display` set by v-show should not be overwritten by the style attribute when updated', async () => {\n    const style = ref('width: 100px')\n    const display = ref(false)\n    const component = defineComponent({\n      render() {\n        return withVShow(h('div', { style: style.value }), display.value)\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n\n    expect($div.style.display).toEqual('none')\n\n    style.value = 'width: 50px'\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    display.value = true\n    await nextTick()\n    expect($div.style.display).toEqual('')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"the value of `display` set by v-show should not be overwritten by the style attribute when updated (with Transition)","suites":["runtime-dom: v-show directive"],"updatePoint":{"line":155,"column":124},"line":155,"code":"  test('the value of `display` set by v-show should not be overwritten by the style attribute when updated (with Transition)', async () => {\n    const style = ref('width: 100px')\n    const display = ref(false)\n    const component = defineComponent({\n      setup() {\n        const innerValue = ref(false)\n        watch(display, val => {\n          innerValue.value = val\n        })\n        return () => {\n          return h(Transition, () =>\n            withVShow(\n              h('div', { style: style.value }, innerValue.value),\n              display.value\n            )\n          )\n        }\n      }\n    })\n    render(h(component), root)\n\n    const $div = root.querySelector('div')\n\n    expect($div.style.display).toEqual('none')\n\n    style.value = 'width: 50px'\n    await nextTick()\n    expect($div.style.display).toEqual('none')\n\n    display.value = true\n    await nextTick()\n    expect($div.style.display).toEqual('')\n  })","file":"directives/vShow.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"basic usage","suites":["useCssModule"],"updatePoint":{"line":20,"column":19},"line":20,"code":"  test('basic usage', () => {\n    const modules = {\n      $style: {\n        red: 'red'\n      }\n    }\n    expect(mountWithModule(modules)).toMatchObject(modules.$style)\n  })","file":"helpers/useCssModule.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"basic usage","suites":["useCssModule"],"updatePoint":{"line":29,"column":19},"line":29,"code":"  test('basic usage', () => {\n    const modules = {\n      foo: {\n        red: 'red'\n      }\n    }\n    expect(mountWithModule(modules, 'foo')).toMatchObject(modules.foo)\n  })","file":"helpers/useCssModule.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"warn out of setup usage","suites":["useCssModule"],"updatePoint":{"line":38,"column":31},"line":38,"code":"  test('warn out of setup usage', () => {\n    useCssModule()\n    expect('must be called inside setup').toHaveBeenWarned()\n  })","file":"helpers/useCssModule.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"warn missing injection","suites":["useCssModule"],"updatePoint":{"line":43,"column":30},"line":43,"code":"  test('warn missing injection', () => {\n    mountWithModule(undefined)\n    expect('instance does not have CSS modules').toHaveBeenWarned()\n  })","file":"helpers/useCssModule.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"warn missing injection","suites":["useCssModule"],"updatePoint":{"line":48,"column":30},"line":48,"code":"  test('warn missing injection', () => {\n    mountWithModule({ $style: { red: 'red' } }, 'foo')\n    expect('instance does not have CSS module named \"foo\"').toHaveBeenWarned()\n  })","file":"helpers/useCssModule.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"basic","suites":["useCssVars"],"updatePoint":{"line":34,"column":13},"line":34,"code":"  test('basic', async () => {\n    await assertCssVars(state => ({\n      setup() {\n        // test receiving render context\n        useCssVars((ctx: any) => ({\n          color: ctx.color\n        }))\n        return state\n      },\n      render() {\n        return h('div')\n      }\n    }))\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"on fragment root","suites":["useCssVars"],"updatePoint":{"line":49,"column":24},"line":49,"code":"  test('on fragment root', async () => {\n    await assertCssVars(state => ({\n      setup() {\n        useCssVars(() => state)\n        return () => [h('div'), h('div')]\n      }\n    }))\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"on HOCs","suites":["useCssVars"],"updatePoint":{"line":58,"column":15},"line":58,"code":"  test('on HOCs', async () => {\n    const Child = () => [h('div'), h('div')]\n\n    await assertCssVars(state => ({\n      setup() {\n        useCssVars(() => state)\n        return () => h(Child)\n      }\n    }))\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"on suspense root","suites":["useCssVars"],"updatePoint":{"line":69,"column":24},"line":69,"code":"  test('on suspense root', async () => {\n    const state = reactive({ color: 'red' })\n    const root = document.createElement('div')\n\n    let resolveAsync: any\n    let asyncPromise: any\n\n    const AsyncComp = {\n      setup() {\n        asyncPromise = new Promise(r => {\n          resolveAsync = () => {\n            r(() => h('p', 'default'))\n          }\n        })\n        return asyncPromise\n      }\n    }\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () =>\n          h(Suspense, null, {\n            default: h(AsyncComp),\n            fallback: h('div', 'fallback')\n          })\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    // css vars use with fallback tree\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe(`red`)\n    }\n    // AsyncComp resolve\n    resolveAsync()\n    await asyncPromise.then(() => {})\n    // Suspense effects flush\n    await nextTick()\n    // css vars use with default tree\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe(`red`)\n    }\n\n    state.color = 'green'\n    await nextTick()\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('green')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with subTree changed","suites":["useCssVars"],"updatePoint":{"line":121,"column":28},"line":121,"code":"  test('with subTree changed', async () => {\n    const state = reactive({ color: 'red' })\n    const value = ref(true)\n    const root = document.createElement('div')\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () => (value.value ? [h('div')] : [h('div'), h('div')])\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    // css vars use with fallback tree\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe(`red`)\n    }\n\n    value.value = false\n    await nextTick()\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with subTree change inside HOC","suites":["useCssVars"],"updatePoint":{"line":148,"column":38},"line":148,"code":"  test('with subTree change inside HOC', async () => {\n    const state = reactive({ color: 'red' })\n    const value = ref(true)\n    const root = document.createElement('div')\n\n    const Child: FunctionalComponent = (_, { slots }) => slots.default!()\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () =>\n          h(Child, null, () =>\n            value.value ? [h('div')] : [h('div'), h('div')]\n          )\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    // css vars use with fallback tree\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe(`red`)\n    }\n\n    value.value = false\n    await nextTick()\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with createStaticVNode","suites":["useCssVars"],"updatePoint":{"line":179,"column":30},"line":179,"code":"  test('with createStaticVNode', async () => {\n    const state = reactive({ color: 'red' })\n    const root = document.createElement('div')\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () => [\n          h('div'),\n          createStaticVNode('<div>1</div><div><span>2</span></div>', 2),\n          h('div')\n        ]\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    for (const c of [].slice.call(root.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with teleport","suites":["useCssVars"],"updatePoint":{"line":201,"column":21},"line":201,"code":"  test('with teleport', async () => {\n    document.body.innerHTML = ''\n    const state = reactive({ color: 'red' })\n    const root = document.createElement('div')\n    const target = document.body\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () => [h(Teleport, { to: target }, [h('div')])]\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    for (const c of [].slice.call(target.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with teleport in child slot","suites":["useCssVars"],"updatePoint":{"line":221,"column":35},"line":221,"code":"  test('with teleport in child slot', async () => {\n    document.body.innerHTML = ''\n    const state = reactive({ color: 'red' })\n    const root = document.createElement('div')\n    const target = document.body\n\n    const Child: FunctionalComponent = (_, { slots }) => {\n      return h('div', slots.default && slots.default())\n    }\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () => h(Child, () => [h(Teleport, { to: target }, [h('div')])])\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    for (const c of [].slice.call(target.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"with teleport(change subTree)","suites":["useCssVars"],"updatePoint":{"line":245,"column":37},"line":245,"code":"  test('with teleport(change subTree)', async () => {\n    document.body.innerHTML = ''\n    const state = reactive({ color: 'red' })\n    const root = document.createElement('div')\n    const target = document.body\n    const toggle = ref(false)\n\n    const App = {\n      setup() {\n        useCssVars(() => state)\n        return () => [\n          h(Teleport, { to: target }, [\n            h('div'),\n            toggle.value ? h('div') : null\n          ])\n        ]\n      }\n    }\n\n    render(h(App), root)\n    await nextTick()\n    expect(target.children.length).toBe(1)\n    for (const c of [].slice.call(target.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n\n    toggle.value = true\n    await nextTick()\n    expect(target.children.length).toBe(2)\n    for (const c of [].slice.call(target.children as any)) {\n      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')\n    }\n  })","file":"helpers/useCssVars.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"the <select>'s multiple attr should be set in createElement","suites":["runtime-dom: node-ops"],"updatePoint":{"line":4,"column":67},"line":4,"code":"  test(\"the <select>'s multiple attr should be set in createElement\", () => {\n    const el = nodeOps.createElement('select', false, undefined, {\n      multiple: ''\n    }) as HTMLSelectElement\n    const option1 = nodeOps.createElement('option') as HTMLOptionElement\n    const option2 = nodeOps.createElement('option') as HTMLOptionElement\n    option1.selected = true\n    option2.selected = true\n    nodeOps.insert(option1, el)\n    nodeOps.insert(option2, el)\n\n    expect(el.multiple).toBe(true)\n    expect(option1.selected).toBe(true)\n    expect(option2.selected).toBe(true)\n  })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"fresh insertion","suites":["runtime-dom: node-ops","insertStaticContent"],"updatePoint":{"line":21,"column":25},"line":21,"code":"    test('fresh insertion', () => {\n      const content = `<div>one</div><div>two</div>three`\n      const parent = document.createElement('div')\n      const nodes = nodeOps.insertStaticContent!(content, parent, null, false)\n      expect(parent.innerHTML).toBe(content)\n      expect(nodes[0]).toBe(parent.firstChild)\n      expect(nodes[1]).toBe(parent.lastChild)\n    })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"fresh insertion with anchor","suites":["runtime-dom: node-ops","insertStaticContent"],"updatePoint":{"line":30,"column":37},"line":30,"code":"    test('fresh insertion with anchor', () => {\n      const content = `<div>one</div><div>two</div>three`\n      const existing = `<div>existing</div>`\n      const parent = document.createElement('div')\n      parent.innerHTML = existing\n      const anchor = parent.firstChild\n      const nodes = nodeOps.insertStaticContent!(content, parent, anchor, false)\n      expect(parent.innerHTML).toBe(content + existing)\n      expect(nodes[0]).toBe(parent.firstChild)\n      expect(nodes[1]).toBe(parent.childNodes[parent.childNodes.length - 2])\n    })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"fresh insertion as svg","suites":["runtime-dom: node-ops","insertStaticContent"],"updatePoint":{"line":42,"column":32},"line":42,"code":"    test('fresh insertion as svg', () => {\n      const content = `<text>hello</text><circle cx=\"100\" cy=\"100\" r=\"80\"></circle>`\n      const parent = document.createElementNS(svgNS, 'svg')\n      const [first, last] = nodeOps.insertStaticContent!(\n        content,\n        parent,\n        null,\n        true\n      )\n      expect(parent.innerHTML).toBe(content)\n      expect(first).toBe(parent.firstChild)\n      expect(last).toBe(parent.lastChild)\n      expect((first as Element).namespaceURI).toMatch('svg')\n      expect((last as Element).namespaceURI).toMatch('svg')\n    })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"fresh insertion as svg, with anchor","suites":["runtime-dom: node-ops","insertStaticContent"],"updatePoint":{"line":58,"column":45},"line":58,"code":"    test('fresh insertion as svg, with anchor', () => {\n      const content = `<text>hello</text><circle cx=\"100\" cy=\"100\" r=\"80\"></circle>`\n      const existing = `<path></path>`\n      const parent = document.createElementNS(svgNS, 'svg')\n      parent.innerHTML = existing\n      const anchor = parent.firstChild\n      const [first, last] = nodeOps.insertStaticContent!(\n        content,\n        parent,\n        anchor,\n        true\n      )\n      expect(parent.innerHTML).toBe(content + existing)\n      expect(first).toBe(parent.firstChild)\n      expect(last).toBe(parent.childNodes[parent.childNodes.length - 2])\n      expect((first as Element).namespaceURI).toMatch('svg')\n      expect((last as Element).namespaceURI).toMatch('svg')\n    })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"cached insertion","suites":["runtime-dom: node-ops","insertStaticContent"],"updatePoint":{"line":77,"column":26},"line":77,"code":"    test('cached insertion', () => {\n      const content = `<div>one</div><div>two</div>three`\n      const existing = `<div>existing</div>`\n      const parent = document.createElement('div')\n      parent.innerHTML = existing\n      const anchor = parent.firstChild\n\n      const cached = document.createElement('div')\n      cached.innerHTML = content\n\n      const nodes = nodeOps.insertStaticContent!(\n        content,\n        parent,\n        anchor,\n        false,\n        cached.firstChild,\n        cached.lastChild\n      )\n      expect(parent.innerHTML).toBe(content + existing)\n      expect(nodes[0]).toBe(parent.firstChild)\n      expect(nodes[1]).toBe(parent.childNodes[parent.childNodes.length - 2])\n    })","file":"nodeOps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"xlink attributes","suites":["runtime-dom: attrs patching"],"updatePoint":{"line":5,"column":24},"line":5,"code":"  test('xlink attributes', () => {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', 'use')\n    patchProp(el, 'xlink:href', null, 'a', true)\n    expect(el.getAttributeNS(xlinkNS, 'href')).toBe('a')\n    patchProp(el, 'xlink:href', 'a', null, true)\n    expect(el.getAttributeNS(xlinkNS, 'href')).toBe(null)\n  })","file":"patchAttrs.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"textContent attributes /w svg","suites":["runtime-dom: attrs patching"],"updatePoint":{"line":13,"column":37},"line":13,"code":"  test('textContent attributes /w svg', () => {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', 'use')\n    patchProp(el, 'textContent', null, 'foo', true)\n    expect(el.attributes.length).toBe(0)\n    expect(el.innerHTML).toBe('foo')\n  })","file":"patchAttrs.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"boolean attributes","suites":["runtime-dom: attrs patching"],"updatePoint":{"line":20,"column":26},"line":20,"code":"  test('boolean attributes', () => {\n    const el = document.createElement('input')\n    patchProp(el, 'readonly', null, true)\n    expect(el.getAttribute('readonly')).toBe('')\n    patchProp(el, 'readonly', true, false)\n    expect(el.getAttribute('readonly')).toBe(null)\n    patchProp(el, 'readonly', false, '')\n    expect(el.getAttribute('readonly')).toBe('')\n    patchProp(el, 'readonly', '', 0)\n    expect(el.getAttribute('readonly')).toBe(null)\n    patchProp(el, 'readonly', 0, '0')\n    expect(el.getAttribute('readonly')).toBe('')\n    patchProp(el, 'readonly', '0', false)\n    expect(el.getAttribute('readonly')).toBe(null)\n    patchProp(el, 'readonly', false, 1)\n    expect(el.getAttribute('readonly')).toBe('')\n    patchProp(el, 'readonly', 1, undefined)\n    expect(el.getAttribute('readonly')).toBe(null)\n  })","file":"patchAttrs.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"attributes","suites":["runtime-dom: attrs patching"],"updatePoint":{"line":40,"column":18},"line":40,"code":"  test('attributes', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'foo', null, 'a')\n    expect(el.getAttribute('foo')).toBe('a')\n    patchProp(el, 'foo', 'a', null)\n    expect(el.getAttribute('foo')).toBe(null)\n  })","file":"patchAttrs.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"onxxx but non-listener attributes","suites":["runtime-dom: attrs patching"],"updatePoint":{"line":49,"column":41},"line":49,"code":"  test('onxxx but non-listener attributes', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'onwards', null, 'a')\n    expect(el.getAttribute('onwards')).toBe('a')\n    patchProp(el, 'onwards', 'a', null)\n    expect(el.getAttribute('onwards')).toBe(null)\n  })","file":"patchAttrs.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"basics","suites":["runtime-dom: class patching"],"updatePoint":{"line":6,"column":14},"line":6,"code":"  test('basics', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'class', null, 'foo')\n    expect(el.className).toBe('foo')\n    patchProp(el, 'class', null, null)\n    expect(el.className).toBe('')\n  })","file":"patchClass.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"transition class","suites":["runtime-dom: class patching"],"updatePoint":{"line":14,"column":24},"line":14,"code":"  test('transition class', () => {\n    const el = document.createElement('div') as ElementWithTransition\n    el._vtc = new Set(['bar', 'baz'])\n    patchProp(el, 'class', null, 'foo')\n    expect(el.className).toBe('foo bar baz')\n    patchProp(el, 'class', null, null)\n    expect(el.className).toBe('bar baz')\n    delete el._vtc\n    patchProp(el, 'class', null, 'foo')\n    expect(el.className).toBe('foo')\n  })","file":"patchClass.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"svg","suites":["runtime-dom: class patching"],"updatePoint":{"line":26,"column":11},"line":26,"code":"  test('svg', () => {\n    const el = document.createElementNS(svgNS, 'svg')\n    patchProp(el, 'class', null, 'foo', true)\n    expect(el.getAttribute('class')).toBe('foo')\n  })","file":"patchClass.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should assign event handler","suites":["runtime-dom: events patching"],"updatePoint":{"line":7,"column":33},"line":7,"code":"  it('should assign event handler', async () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    patchProp(el, 'onClick', null, fn)\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).toHaveBeenCalledTimes(3)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should update event handler","suites":["runtime-dom: events patching"],"updatePoint":{"line":20,"column":33},"line":20,"code":"  it('should update event handler', async () => {\n    const el = document.createElement('div')\n    const prevFn = vi.fn()\n    const nextFn = vi.fn()\n    patchProp(el, 'onClick', null, prevFn)\n    el.dispatchEvent(new Event('click'))\n    patchProp(el, 'onClick', prevFn, nextFn)\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(prevFn).toHaveBeenCalledTimes(1)\n    expect(nextFn).toHaveBeenCalledTimes(2)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support multiple event handlers","suites":["runtime-dom: events patching"],"updatePoint":{"line":36,"column":44},"line":36,"code":"  it('should support multiple event handlers', async () => {\n    const el = document.createElement('div')\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n    patchProp(el, 'onClick', null, [fn1, fn2])\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledTimes(1)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should unassign event handler","suites":["runtime-dom: events patching"],"updatePoint":{"line":47,"column":35},"line":47,"code":"  it('should unassign event handler', async () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    patchProp(el, 'onClick', null, fn)\n    patchProp(el, 'onClick', fn, null)\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).not.toHaveBeenCalled()\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support event option modifiers","suites":["runtime-dom: events patching"],"updatePoint":{"line":57,"column":43},"line":57,"code":"  it('should support event option modifiers', async () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    patchProp(el, 'onClickOnceCapture', null, fn)\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should unassign event handler with options","suites":["runtime-dom: events patching"],"updatePoint":{"line":68,"column":48},"line":68,"code":"  it('should unassign event handler with options', async () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    patchProp(el, 'onClickCapture', null, fn)\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).toHaveBeenCalledTimes(1)\n\n    patchProp(el, 'onClickCapture', fn, null)\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support native onclick","suites":["runtime-dom: events patching"],"updatePoint":{"line":84,"column":35},"line":84,"code":"  it('should support native onclick', async () => {\n    const el = document.createElement('div')\n\n    // string should be set as attribute\n    const fn = ((el as any).spy = vi.fn())\n    patchProp(el, 'onclick', null, 'this.spy(1)')\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn).toHaveBeenCalledWith(1)\n\n    const fn2 = vi.fn()\n    patchProp(el, 'onclick', 'this.spy(1)', fn2)\n    const event = new Event('click')\n    el.dispatchEvent(event)\n    await timeout()\n    expect(fn).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledWith(event)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support stopImmediatePropagation on multiple listeners","suites":["runtime-dom: events patching"],"updatePoint":{"line":103,"column":67},"line":103,"code":"  it('should support stopImmediatePropagation on multiple listeners', async () => {\n    const el = document.createElement('div')\n    const fn1 = vi.fn((e: Event) => {\n      e.stopImmediatePropagation()\n    })\n    const fn2 = vi.fn()\n    patchProp(el, 'onClick', null, [fn1, fn2])\n    el.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(fn1).toHaveBeenCalledTimes(1)\n    expect(fn2).toHaveBeenCalledTimes(0)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should handle same computed handler function being bound on multiple targets","suites":["runtime-dom: events patching"],"updatePoint":{"line":117,"column":82},"line":117,"code":"  it('should handle same computed handler function being bound on multiple targets', async () => {\n    const el1 = document.createElement('div')\n    const el2 = document.createElement('div')\n\n    // const event = new Event('click')\n    const prevFn = vi.fn()\n    const nextFn = vi.fn()\n\n    patchProp(el1, 'onClick', null, prevFn)\n    patchProp(el2, 'onClick', null, prevFn)\n\n    el1.dispatchEvent(new Event('click'))\n    el2.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(prevFn).toHaveBeenCalledTimes(2)\n    expect(nextFn).toHaveBeenCalledTimes(0)\n\n    patchProp(el1, 'onClick', prevFn, nextFn)\n    patchProp(el2, 'onClick', prevFn, nextFn)\n\n    el1.dispatchEvent(new Event('click'))\n    el2.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(prevFn).toHaveBeenCalledTimes(2)\n    expect(nextFn).toHaveBeenCalledTimes(2)\n\n    el1.dispatchEvent(new Event('click'))\n    el2.dispatchEvent(new Event('click'))\n    await timeout()\n    expect(prevFn).toHaveBeenCalledTimes(2)\n    expect(nextFn).toHaveBeenCalledTimes(4)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should not fire handler attached by the event itself","suites":["runtime-dom: events patching"],"updatePoint":{"line":151,"column":58},"line":151,"code":"  it('should not fire handler attached by the event itself', async () => {\n    const el = document.createElement('div')\n    const child = document.createElement('div')\n    el.appendChild(child)\n    document.body.appendChild(el)\n    const childFn = vi.fn()\n    const parentFn = vi.fn()\n\n    patchProp(child, 'onClick', null, () => {\n      childFn()\n      patchProp(el, 'onClick', null, parentFn)\n    })\n\n    await timeout()\n    child.dispatchEvent(new Event('click', { bubbles: true }))\n\n    expect(childFn).toHaveBeenCalled()\n    expect(parentFn).not.toHaveBeenCalled()\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should patch event correctly in web-components","suites":["runtime-dom: events patching"],"updatePoint":{"line":172,"column":54},"line":172,"code":"  test('should patch event correctly in web-components', async () => {\n    class TestElement extends HTMLElement {\n      constructor() {\n        super()\n      }\n    }\n    window.customElements.define('test-element', TestElement)\n    const testElement = document.createElement('test-element', {\n      is: 'test-element'\n    })\n    const fn1 = vi.fn()\n    const fn2 = vi.fn()\n\n    // in webComponents, @foo-bar will patch prop 'onFooBar'\n    // and @foobar will patch prop 'onFoobar'\n\n    patchProp(testElement, 'onFooBar', null, fn1)\n    testElement.dispatchEvent(new CustomEvent('foo-bar'))\n    expect(fn1).toHaveBeenCalledTimes(1)\n\n    patchProp(testElement, 'onFoobar', null, fn2)\n    testElement.dispatchEvent(new CustomEvent('foobar'))\n    expect(fn2).toHaveBeenCalledTimes(1)\n  })","file":"patchEvents.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"basic","suites":["runtime-dom: props patching"],"updatePoint":{"line":6,"column":13},"line":6,"code":"  test('basic', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'id', null, 'foo')\n    expect(el.id).toBe('foo')\n    // prop with string value should be set to empty string on null values\n    patchProp(el, 'id', null, null)\n    expect(el.id).toBe('')\n    expect(el.getAttribute('id')).toBe(null)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"value","suites":["runtime-dom: props patching"],"updatePoint":{"line":16,"column":13},"line":16,"code":"  test('value', () => {\n    const el = document.createElement('input')\n    patchProp(el, 'value', null, 'foo')\n    expect(el.value).toBe('foo')\n    patchProp(el, 'value', null, null)\n    expect(el.value).toBe('')\n    expect(el.getAttribute('value')).toBe(null)\n    const obj = {}\n    patchProp(el, 'value', null, obj)\n    expect(el.value).toBe(obj.toString())\n    expect((el as any)._value).toBe(obj)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"value for custom elements","suites":["runtime-dom: props patching"],"updatePoint":{"line":29,"column":33},"line":29,"code":"  test('value for custom elements', () => {\n    class TestElement extends HTMLElement {\n      constructor() {\n        super()\n      }\n\n      // intentionally uses _value because this is used in \"normal\" HTMLElement for storing the object of the set property value\n      private _value: any\n      get value() {\n        return this._value\n      }\n\n      set value(val) {\n        this._value = val\n        this.setterCalled++\n      }\n\n      public setterCalled: number = 0\n    }\n    window.customElements.define('patch-props-test-element', TestElement)\n    const el = document.createElement('patch-props-test-element') as TestElement\n    patchProp(el, 'value', null, 'foo')\n    expect(el.value).toBe('foo')\n    expect(el.setterCalled).toBe(1)\n    patchProp(el, 'value', null, null)\n    expect(el.value).toBe('')\n    expect(el.setterCalled).toBe(2)\n    expect(el.getAttribute('value')).toBe(null)\n    const obj = {}\n    patchProp(el, 'value', null, obj)\n    expect(el.value).toBe(obj)\n    expect(el.setterCalled).toBe(3)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"value for non-text input","suites":["runtime-dom: props patching"],"updatePoint":{"line":65,"column":32},"line":65,"code":"  test('value for non-text input', () => {\n    const el = document.createElement('option')\n    el.textContent = 'foo' // #4956\n    patchProp(el, 'value', null, 'foo')\n    expect(el.getAttribute('value')).toBe('foo')\n    expect(el.value).toBe('foo')\n    patchProp(el, 'value', null, null)\n    el.textContent = ''\n    expect(el.value).toBe('')\n    // #3475\n    expect(el.getAttribute('value')).toBe(null)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"boolean prop","suites":["runtime-dom: props patching"],"updatePoint":{"line":78,"column":20},"line":78,"code":"  test('boolean prop', () => {\n    const el = document.createElement('select')\n    patchProp(el, 'multiple', null, '')\n    expect(el.multiple).toBe(true)\n    patchProp(el, 'multiple', null, null)\n    expect(el.multiple).toBe(false)\n    patchProp(el, 'multiple', null, true)\n    expect(el.multiple).toBe(true)\n    patchProp(el, 'multiple', null, 0)\n    expect(el.multiple).toBe(false)\n    patchProp(el, 'multiple', null, '0')\n    expect(el.multiple).toBe(true)\n    patchProp(el, 'multiple', null, false)\n    expect(el.multiple).toBe(false)\n    patchProp(el, 'multiple', null, 1)\n    expect(el.multiple).toBe(true)\n    patchProp(el, 'multiple', null, undefined)\n    expect(el.multiple).toBe(false)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"innerHTML unmount prev children","suites":["runtime-dom: props patching"],"updatePoint":{"line":98,"column":39},"line":98,"code":"  test('innerHTML unmount prev children', () => {\n    const fn = vi.fn()\n    const comp = {\n      render: () => 'foo',\n      unmounted: fn\n    }\n    const root = document.createElement('div')\n    render(h('div', null, [h(comp)]), root)\n    expect(root.innerHTML).toBe(`<div>foo</div>`)\n\n    render(h('div', { innerHTML: 'bar' }), root)\n    expect(root.innerHTML).toBe(`<div>bar</div>`)\n    expect(fn).toHaveBeenCalled()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"(svg) innerHTML unmount prev children","suites":["runtime-dom: props patching"],"updatePoint":{"line":114,"column":45},"line":114,"code":"  test('(svg) innerHTML unmount prev children', () => {\n    const fn = vi.fn()\n    const comp = {\n      render: () => 'foo',\n      unmounted: fn\n    }\n    const root = document.createElement('div')\n    render(h('div', null, [h(comp)]), root)\n    expect(root.innerHTML).toBe(`<div>foo</div>`)\n\n    render(h('svg', { innerHTML: '<g></g>' }), root)\n    expect(root.innerHTML).toBe(`<svg><g></g></svg>`)\n    expect(fn).toHaveBeenCalled()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"textContent unmount prev children","suites":["runtime-dom: props patching"],"updatePoint":{"line":129,"column":41},"line":129,"code":"  test('textContent unmount prev children', () => {\n    const fn = vi.fn()\n    const comp = {\n      render: () => 'foo',\n      unmounted: fn\n    }\n    const root = document.createElement('div')\n    render(h('div', null, [h(comp)]), root)\n    expect(root.innerHTML).toBe(`<div>foo</div>`)\n\n    render(h('div', { textContent: 'bar' }), root)\n    expect(root.innerHTML).toBe(`<div>bar</div>`)\n    expect(fn).toHaveBeenCalled()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"set value as-is for non string-value props","suites":["runtime-dom: props patching"],"updatePoint":{"line":145,"column":50},"line":145,"code":"  test('set value as-is for non string-value props', () => {\n    const el = document.createElement('video')\n    // jsdom doesn't really support video playback. srcObject in a real browser\n    // should default to `null`, but in jsdom it's `undefined`.\n    // anyway, here we just want to make sure Vue doesn't set non-string props\n    // to an empty string on nullish values - it should reset to its default\n    // value.\n    const initialValue = el.srcObject\n    const fakeObject = {}\n    patchProp(el, 'srcObject', null, fakeObject)\n    expect(el.srcObject).not.toBe(fakeObject)\n    patchProp(el, 'srcObject', null, null)\n    expect(el.srcObject).toBe(initialValue)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"catch and warn prop set TypeError","suites":["runtime-dom: props patching"],"updatePoint":{"line":160,"column":41},"line":160,"code":"  test('catch and warn prop set TypeError', () => {\n    const el = document.createElement('div')\n    Object.defineProperty(el, 'someProp', {\n      set() {\n        throw new TypeError('Invalid type')\n      }\n    })\n    patchProp(el, 'someProp', null, 'foo')\n\n    expect(`Failed setting prop \"someProp\" on <div>`).toHaveBeenWarnedLast()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"remove attribute when value is falsy","suites":["runtime-dom: props patching"],"updatePoint":{"line":173,"column":44},"line":173,"code":"  test('remove attribute when value is falsy', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'id', null, '')\n    expect(el.hasAttribute('id')).toBe(true)\n    patchProp(el, 'id', null, null)\n    expect(el.hasAttribute('id')).toBe(false)\n\n    patchProp(el, 'id', null, '')\n    expect(el.hasAttribute('id')).toBe(true)\n    patchProp(el, 'id', null, undefined)\n    expect(el.hasAttribute('id')).toBe(false)\n\n    patchProp(el, 'id', null, '')\n    expect(el.hasAttribute('id')).toBe(true)\n\n    // #2677\n    const img = document.createElement('img')\n    patchProp(img, 'width', null, '')\n    expect(el.hasAttribute('width')).toBe(false)\n    patchProp(img, 'width', null, 0)\n    expect(img.hasAttribute('width')).toBe(true)\n\n    patchProp(img, 'width', null, null)\n    expect(img.hasAttribute('width')).toBe(false)\n    patchProp(img, 'width', null, 0)\n    expect(img.hasAttribute('width')).toBe(true)\n\n    patchProp(img, 'width', null, undefined)\n    expect(img.hasAttribute('width')).toBe(false)\n    patchProp(img, 'width', null, 0)\n    expect(img.hasAttribute('width')).toBe(true)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"form attribute","suites":["runtime-dom: props patching"],"updatePoint":{"line":206,"column":22},"line":206,"code":"  test('form attribute', () => {\n    const el = document.createElement('input')\n    patchProp(el, 'form', null, 'foo')\n    // non existent element\n    expect(el.form).toBe(null)\n    expect(el.getAttribute('form')).toBe('foo')\n    // remove attribute\n    patchProp(el, 'form', 'foo', null)\n    expect(el.getAttribute('form')).toBe(null)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"readonly type prop on textarea","suites":["runtime-dom: props patching"],"updatePoint":{"line":217,"column":38},"line":217,"code":"  test('readonly type prop on textarea', () => {\n    const el = document.createElement('textarea')\n    // just to verify that it doesn't throw when i.e. switching a dynamic :is from an 'input' to a 'textarea'\n    // see https://github.com/vuejs/core/issues/2766\n    patchProp(el, 'type', 'text', null)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"force patch as prop","suites":["runtime-dom: props patching"],"updatePoint":{"line":224,"column":27},"line":224,"code":"  test('force patch as prop', () => {\n    const el = document.createElement('div') as any\n    patchProp(el, '.x', null, 1)\n    expect(el.x).toBe(1)\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"force patch as attribute","suites":["runtime-dom: props patching"],"updatePoint":{"line":230,"column":32},"line":230,"code":"  test('force patch as attribute', () => {\n    const el = document.createElement('div') as any\n    el.x = 1\n    patchProp(el, '^x', null, 2)\n    expect(el.x).toBe(1)\n    expect(el.getAttribute('x')).toBe('2')\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"input with size (number property)","suites":["runtime-dom: props patching"],"updatePoint":{"line":238,"column":41},"line":238,"code":"  test('input with size (number property)', () => {\n    const el = document.createElement('input')\n    patchProp(el, 'size', null, 100)\n    expect(el.size).toBe(100)\n    patchProp(el, 'size', 100, null)\n    expect(el.getAttribute('size')).toBe(null)\n    expect('Failed setting prop \"size\" on <input>').not.toHaveBeenWarned()\n    patchProp(el, 'size', null, 'foobar')\n    expect('Failed setting prop \"size\" on <input>').toHaveBeenWarnedLast()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"select with type (string property)","suites":["runtime-dom: props patching"],"updatePoint":{"line":249,"column":42},"line":249,"code":"  test('select with type (string property)', () => {\n    const el = document.createElement('select')\n    patchProp(el, 'type', null, 'test')\n    expect(el.type).toBe('select-one')\n    expect('Failed setting prop \"type\" on <select>').toHaveBeenWarnedLast()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"select with willValidate (boolean property)","suites":["runtime-dom: props patching"],"updatePoint":{"line":256,"column":51},"line":256,"code":"  test('select with willValidate (boolean property)', () => {\n    const el = document.createElement('select')\n    patchProp(el, 'willValidate', true, null)\n    expect(el.willValidate).toBe(true)\n    expect(\n      'Failed setting prop \"willValidate\" on <select>'\n    ).toHaveBeenWarnedLast()\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"patch value for select","suites":["runtime-dom: props patching"],"updatePoint":{"line":265,"column":30},"line":265,"code":"  test('patch value for select', () => {\n    const root = document.createElement('div')\n    render(\n      h('select', { value: 'foo' }, [\n        h('option', { value: 'foo' }, 'foo'),\n        h('option', { value: 'bar' }, 'bar')\n      ]),\n      root\n    )\n    const el = root.children[0] as HTMLSelectElement\n    expect(el.value).toBe('foo')\n\n    render(\n      h('select', { value: 'baz' }, [\n        h('option', { value: 'foo' }, 'foo'),\n        h('option', { value: 'baz' }, 'baz')\n      ]),\n      root\n    )\n    expect(el.value).toBe('baz')\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"translate attribute","suites":["runtime-dom: props patching"],"updatePoint":{"line":287,"column":27},"line":287,"code":"  test('translate attribute', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'translate', null, 'no')\n    expect(el.translate).toBeFalsy()\n    expect(el.getAttribute('translate')).toBe('no')\n  })","file":"patchProps.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"string","suites":["runtime-dom: style patching"],"updatePoint":{"line":5,"column":12},"line":5,"code":"  it('string', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, 'color:red')\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('color:red;')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should not patch same string style","suites":["runtime-dom: style patching"],"updatePoint":{"line":12,"column":40},"line":12,"code":"  it('should not patch same string style', () => {\n    const el = document.createElement('div')\n    const fn = vi.fn()\n    const value = (el.style.cssText = 'color:red;')\n    Object.defineProperty(el.style, 'cssText', {\n      get(): any {\n        return value\n      },\n      set: fn\n    })\n    patchProp(el, 'style', value, value)\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('color:red;')\n    expect(fn).not.toBeCalled()\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"plain object","suites":["runtime-dom: style patching"],"updatePoint":{"line":27,"column":18},"line":27,"code":"  it('plain object', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, { color: 'red' })\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('color:red;')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"camelCase","suites":["runtime-dom: style patching"],"updatePoint":{"line":33,"column":15},"line":33,"code":"  it('camelCase', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, { marginRight: '10px' })\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('margin-right:10px;')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"remove if falsy value","suites":["runtime-dom: style patching"],"updatePoint":{"line":39,"column":27},"line":39,"code":"  it('remove if falsy value', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', null, {\n      color: undefined,\n      borderRadius: null\n    })\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('')\n\n    patchProp(\n      el,\n      'style',\n      { color: 'red' },\n      { color: null, borderRadius: undefined }\n    )\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"!important","suites":["runtime-dom: style patching"],"updatePoint":{"line":56,"column":16},"line":56,"code":"  it('!important', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, { color: 'red !important' })\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe('color:red!important;')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"camelCase with !important","suites":["runtime-dom: style patching"],"updatePoint":{"line":62,"column":31},"line":62,"code":"  it('camelCase with !important', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, { marginRight: '10px !important' })\n    expect(el.style.cssText.replace(/\\s/g, '')).toBe(\n      'margin-right:10px!important;'\n    )\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"object with multiple entries","suites":["runtime-dom: style patching"],"updatePoint":{"line":70,"column":34},"line":70,"code":"  it('object with multiple entries', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', {}, { color: 'red', marginRight: '10px' })\n    expect(el.style.getPropertyValue('color')).toBe('red')\n    expect(el.style.getPropertyValue('margin-right')).toBe('10px')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"patch with falsy style value","suites":["runtime-dom: style patching"],"updatePoint":{"line":77,"column":34},"line":77,"code":"  it('patch with falsy style value', () => {\n    const el = document.createElement('div')\n    patchProp(el as any, 'style', { width: '100px' }, { width: 0 })\n    expect(el.style.width).toBe('0px')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should remove style attribute on falsy value","suites":["runtime-dom: style patching"],"updatePoint":{"line":83,"column":50},"line":83,"code":"  it('should remove style attribute on falsy value', () => {\n    const el = document.createElement('div')\n    el.style.cssText = 'color: red;'\n    patchProp(el as any, 'style', {}, null)\n    expect(el.hasAttribute('style')).toBe(false)\n    expect(el.style.cssText).toBe('')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should warn for trailing semicolons","suites":["runtime-dom: style patching"],"updatePoint":{"line":91,"column":41},"line":91,"code":"  it('should warn for trailing semicolons', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', null, { color: 'red;' })\n    expect(\n      `Unexpected semicolon at the end of 'color' style value: 'red;'`\n    ).toHaveBeenWarned()\n\n    patchProp(el, 'style', null, { '--custom': '100; ' })\n    expect(\n      `Unexpected semicolon at the end of '--custom' style value: '100; '`\n    ).toHaveBeenWarned()\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should not warn for escaped trailing semicolons","suites":["runtime-dom: style patching"],"updatePoint":{"line":104,"column":53},"line":104,"code":"  it('should not warn for escaped trailing semicolons', () => {\n    const el = document.createElement('div')\n    patchProp(el, 'style', null, { '--custom': '100\\\\;' })\n    expect(el.style.getPropertyValue('--custom')).toBe('100\\\\;')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"shorthand properties","suites":["runtime-dom: style patching"],"updatePoint":{"line":110,"column":26},"line":110,"code":"  it('shorthand properties', () => {\n    const el = document.createElement('div')\n    patchProp(\n      el as any,\n      'style',\n      { borderBottom: '1px solid red' },\n      { border: '1px solid green' }\n    )\n    expect(el.style.border).toBe('1px solid green')\n    expect(el.style.borderBottom).toBe('1px solid green')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"CSS custom properties","suites":["runtime-dom: style patching"],"updatePoint":{"line":140,"column":27},"line":140,"code":"  it('CSS custom properties', () => {\n    const el = mockElementWithStyle()\n    patchProp(el as any, 'style', {}, { '--theme': 'red' } as any)\n    expect(el.style.getPropertyValue('--theme')).toBe('red')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"auto vendor prefixing","suites":["runtime-dom: style patching"],"updatePoint":{"line":146,"column":27},"line":146,"code":"  it('auto vendor prefixing', () => {\n    const el = mockElementWithStyle()\n    patchProp(el as any, 'style', {}, { transition: 'all 1s' })\n    expect(el.style.WebkitTransition).toBe('all 1s')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"multiple values","suites":["runtime-dom: style patching"],"updatePoint":{"line":152,"column":21},"line":152,"code":"  it('multiple values', () => {\n    const el = mockElementWithStyle()\n    patchProp(\n      el as any,\n      'style',\n      {},\n      { display: ['-webkit-box', '-ms-flexbox', 'flex'] }\n    )\n    expect(el.style.display).toBe('flex')\n  })","file":"patchStyle.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should mount from string","suites":["static vnode handling"],"updatePoint":{"line":10,"column":32},"line":10,"code":"  test('should mount from string', () => {\n    const root = document.createElement('div')\n    render(h('div', [s]), root)\n    expect(root.innerHTML).toBe(`<div>${content}</div>`)\n  })","file":"rendererStaticNode.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should support reusing the same hoisted node","suites":["static vnode handling"],"updatePoint":{"line":16,"column":52},"line":16,"code":"  test('should support reusing the same hoisted node', () => {\n    const root = document.createElement('div')\n    render(h('div', [s, s]), root)\n    expect(root.innerHTML).toBe(`<div>${content}${content}</div>`)\n  })","file":"rendererStaticNode.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should update","suites":["static vnode handling"],"updatePoint":{"line":23,"column":21},"line":23,"code":"  test('should update', () => {\n    const root = document.createElement('div')\n    render(h('div', [s]), root)\n    expect(root.innerHTML).toBe(`<div>${content}</div>`)\n    render(h('div', [s2]), root)\n    expect(root.innerHTML).toBe(`<div>${content2}</div>`)\n  })","file":"rendererStaticNode.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should move","suites":["static vnode handling"],"updatePoint":{"line":31,"column":19},"line":31,"code":"  test('should move', () => {\n    const root = document.createElement('div')\n    render(h('div', [h('b'), s, h('b')]), root)\n    expect(root.innerHTML).toBe(`<div><b></b>${content}<b></b></div>`)\n    render(h('div', [s, h('b'), h('b')]), root)\n    expect(root.innerHTML).toBe(`<div>${content}<b></b><b></b></div>`)\n    render(h('div', [h('b'), h('b'), s]), root)\n    expect(root.innerHTML).toBe(`<div><b></b><b></b>${content}</div>`)\n  })","file":"rendererStaticNode.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should remove","suites":["static vnode handling"],"updatePoint":{"line":41,"column":21},"line":41,"code":"  test('should remove', () => {\n    const root = document.createElement('div')\n    render(h('div', [h('b'), s, h('b')]), root)\n    expect(root.innerHTML).toBe(`<div><b></b>${content}<b></b></div>`)\n    render(h('div', [h('b'), h('b')]), root)\n    expect(root.innerHTML).toBe(`<div><b></b><b></b></div>`)\n    render(h('div', [h('b'), h('b'), s]), root)\n    expect(root.innerHTML).toBe(`<div><b></b><b></b>${content}</div>`)\n  })","file":"rendererStaticNode.spec.ts","skipped":false,"dir":"packages/runtime-dom/__tests__"},{"name":"should work","suites":["test renderer"],"updatePoint":{"line":19,"column":17},"line":19,"code":"  it('should work', () => {\n    const root = nodeOps.createElement('div')\n    render(\n      h(\n        'div',\n        {\n          id: 'test'\n        },\n        'hello'\n      ),\n      root\n    )\n\n    expect(root.children.length).toBe(1)\n\n    const el = root.children[0] as TestElement\n    expect(el.type).toBe(TestNodeTypes.ELEMENT)\n    expect(el.props.id).toBe('test')\n    expect(el.children.length).toBe(1)\n\n    const text = el.children[0] as TestText\n    expect(text.type).toBe(TestNodeTypes.TEXT)\n    expect(text.text).toBe('hello')\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should record ops","suites":["test renderer"],"updatePoint":{"line":44,"column":23},"line":44,"code":"  it('should record ops', async () => {\n    const state = reactive({\n      id: 'test',\n      text: 'hello'\n    })\n\n    const App = {\n      render() {\n        return h(\n          'div',\n          {\n            id: state.id\n          },\n          state.text\n        )\n      }\n    }\n    const root = nodeOps.createElement('div')\n\n    resetOps()\n    render(h(App), root)\n    const ops = dumpOps()\n\n    expect(ops.length).toBe(4)\n\n    expect(ops[0]).toEqual({\n      type: NodeOpTypes.CREATE,\n      nodeType: TestNodeTypes.ELEMENT,\n      tag: 'div',\n      targetNode: root.children[0]\n    })\n\n    expect(ops[1]).toEqual({\n      type: NodeOpTypes.SET_ELEMENT_TEXT,\n      text: 'hello',\n      targetNode: root.children[0]\n    })\n\n    expect(ops[2]).toEqual({\n      type: NodeOpTypes.PATCH,\n      targetNode: root.children[0],\n      propKey: 'id',\n      propPrevValue: null,\n      propNextValue: 'test'\n    })\n\n    expect(ops[3]).toEqual({\n      type: NodeOpTypes.INSERT,\n      targetNode: root.children[0],\n      parentNode: root,\n      refNode: null\n    })\n\n    // test update ops\n    state.id = 'foo'\n    state.text = 'bar'\n    await nextTick()\n\n    const updateOps = dumpOps()\n    expect(updateOps.length).toBe(2)\n\n    expect(updateOps[0]).toEqual({\n      type: NodeOpTypes.SET_ELEMENT_TEXT,\n      targetNode: root.children[0],\n      text: 'bar'\n    })\n\n    expect(updateOps[1]).toEqual({\n      type: NodeOpTypes.PATCH,\n      targetNode: root.children[0],\n      propKey: 'id',\n      propPrevValue: 'test',\n      propNextValue: 'foo'\n    })\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should be able to serialize nodes","suites":["test renderer"],"updatePoint":{"line":120,"column":39},"line":120,"code":"  it('should be able to serialize nodes', () => {\n    const App = {\n      render() {\n        return h(\n          'div',\n          {\n            id: 'test',\n            boolean: ''\n          },\n          [h('span', 'foo'), 'hello']\n        )\n      }\n    }\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    expect(serialize(root)).toEqual(\n      `<div><div id=\"test\" boolean><span>foo</span>hello</div></div>`\n    )\n    // indented output\n    expect(serialize(root, 2)).toEqual(\n      `<div>\n  <div id=\"test\" boolean>\n    <span>\n      foo\n    </span>\n    hello\n  </div>\n</div>`\n    )\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should be able to trigger events","suites":["test renderer"],"updatePoint":{"line":151,"column":38},"line":151,"code":"  it('should be able to trigger events', async () => {\n    const count = ref(0)\n\n    const App = () => {\n      return h(\n        'span',\n        {\n          onClick: () => {\n            count.value++\n          }\n        },\n        count.value\n      )\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    triggerEvent(root.children[0] as TestElement, 'click')\n    expect(count.value).toBe(1)\n    await nextTick()\n    expect(serialize(root)).toBe(`<div><span>1</span></div>`)\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should be able to trigger events with multiple listeners","suites":["test renderer"],"updatePoint":{"line":174,"column":62},"line":174,"code":"  it('should be able to trigger events with multiple listeners', async () => {\n    const count = ref(0)\n    const count2 = ref(1)\n\n    const App = () => {\n      return h(\n        'span',\n        {\n          onClick: [\n            () => {\n              count.value++\n            },\n            () => {\n              count2.value++\n            }\n          ]\n        },\n        `${count.value}, ${count2.value}`\n      )\n    }\n\n    const root = nodeOps.createElement('div')\n    render(h(App), root)\n    triggerEvent(root.children[0] as TestElement, 'click')\n    expect(count.value).toBe(1)\n    expect(count2.value).toBe(2)\n    await nextTick()\n    expect(serialize(root)).toBe(`<div><span>1, 2</span></div>`)\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should mock warn","suites":["test renderer"],"updatePoint":{"line":204,"column":22},"line":204,"code":"  it('should mock warn', () => {\n    console.warn('warn!!!')\n    expect('warn!!!').toHaveBeenWarned()\n    expect('warn!!!').toHaveBeenWarnedTimes(1)\n\n    console.warn('warn!!!')\n    expect('warn!!!').toHaveBeenWarnedTimes(2)\n\n    console.warn('warning')\n    expect('warn!!!').toHaveBeenWarnedTimes(2)\n    expect('warning').toHaveBeenWarnedLast()\n  })","file":"testRuntime.spec.ts","skipped":false,"dir":"packages/runtime-test/__tests__"},{"name":"should apply app context","suites":["ssr: "],"updatePoint":{"line":68,"column":34},"line":68,"code":"    test('should apply app context', async () => {\n      const app = createApp({\n        render() {\n          const Foo = resolveComponent('foo') as ComponentOptions\n          return h(Foo)\n        }\n      })\n      app.component('foo', {\n        render: () => h('div', 'foo')\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>foo</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"vnode components","suites":["ssr: ","components"],"updatePoint":{"line":83,"column":28},"line":83,"code":"      test('vnode components', async () => {\n        expect(\n          await render(\n            createApp({\n              data() {\n                return { msg: 'hello' }\n              },\n              render(this: any) {\n                return h('div', this.msg)\n              }\n            })\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"option components returning render from setup","suites":["ssr: ","components"],"updatePoint":{"line":98,"column":57},"line":98,"code":"      test('option components returning render from setup', async () => {\n        expect(\n          await render(\n            createApp({\n              setup() {\n                const msg = ref('hello')\n                return () => h('div', msg.value)\n              }\n            })\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"setup components returning render from setup","suites":["ssr: ","components"],"updatePoint":{"line":111,"column":56},"line":111,"code":"      test('setup components returning render from setup', async () => {\n        expect(\n          await render(\n            createApp(\n              defineComponent(() => {\n                const msg = ref('hello')\n                return () => h('div', msg.value)\n              })\n            )\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"components using defineComponent with extends option","suites":["ssr: ","components"],"updatePoint":{"line":124,"column":64},"line":124,"code":"      test('components using defineComponent with extends option', async () => {\n        expect(\n          await render(\n            createApp(\n              defineComponent({\n                extends: defineComponent({\n                  data() {\n                    return { msg: 'hello' }\n                  },\n                  render() {\n                    return h('div', this.msg)\n                  }\n                })\n              })\n            )\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"components using defineComponent with mixins option","suites":["ssr: ","components"],"updatePoint":{"line":143,"column":63},"line":143,"code":"      test('components using defineComponent with mixins option', async () => {\n        expect(\n          await render(\n            createApp(\n              defineComponent({\n                mixins: [\n                  defineComponent({\n                    data() {\n                      return { msg: 'hello' }\n                    },\n                    render() {\n                      return h('div', this.msg)\n                    }\n                  })\n                ]\n              })\n            )\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"optimized components","suites":["ssr: ","components"],"updatePoint":{"line":164,"column":32},"line":164,"code":"      test('optimized components', async () => {\n        expect(\n          await render(\n            createApp({\n              data() {\n                return { msg: 'hello' }\n              },\n              ssrRender(ctx, push) {\n                push(`<div>${ctx.msg}</div>`)\n              }\n            })\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested vnode components","suites":["ssr: ","components"],"updatePoint":{"line":179,"column":35},"line":179,"code":"      test('nested vnode components', async () => {\n        const Child = {\n          props: ['msg'],\n          render(this: any) {\n            return h('div', this.msg)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              render() {\n                return h('div', ['parent', h(Child, { msg: 'hello' })])\n              }\n            })\n          )\n        ).toBe(`<div>parent<div>hello</div></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested optimized components","suites":["ssr: ","components"],"updatePoint":{"line":198,"column":39},"line":198,"code":"      test('nested optimized components', async () => {\n        const Child = {\n          props: ['msg'],\n          ssrRender(ctx: any, push: any) {\n            push(`<div>${ctx.msg}</div>`)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(ssrRenderComponent(Child, { msg: 'hello' }, null, parent))\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(`<div>parent<div>hello</div></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested template components","suites":["ssr: ","components"],"updatePoint":{"line":219,"column":38},"line":219,"code":"      test('nested template components', async () => {\n        const Child = {\n          props: ['msg'],\n          template: `<div>{{ msg }}</div>`\n        }\n        const app = createApp({\n          template: `<div>parent<Child msg=\"hello\" /></div>`\n        })\n        app.component('Child', Child)\n\n        expect(await render(app)).toBe(`<div>parent<div>hello</div></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"template components with dynamic class attribute after static","suites":["ssr: ","components"],"updatePoint":{"line":232,"column":73},"line":232,"code":"      test('template components with dynamic class attribute after static', async () => {\n        const app = createApp({\n          template: `<div><div class=\"child\" :class=\"'dynamic'\"></div></div>`\n        })\n        expect(await render(app)).toBe(\n          `<div><div class=\"dynamic child\"></div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"template components with dynamic class attribute before static","suites":["ssr: ","components"],"updatePoint":{"line":241,"column":74},"line":241,"code":"      test('template components with dynamic class attribute before static', async () => {\n        const app = createApp({\n          template: `<div><div :class=\"'dynamic'\" class=\"child\"></div></div>`\n        })\n        expect(await render(app)).toBe(\n          `<div><div class=\"dynamic child\"></div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"mixing optimized / vnode / template components","suites":["ssr: ","components"],"updatePoint":{"line":250,"column":58},"line":250,"code":"      test('mixing optimized / vnode / template components', async () => {\n        const OptimizedChild = {\n          props: ['msg'],\n          ssrRender(ctx: any, push: any) {\n            push(`<div>${ctx.msg}</div>`)\n          }\n        }\n\n        const VNodeChild = {\n          props: ['msg'],\n          render(this: any) {\n            return h('div', this.msg)\n          }\n        }\n\n        const TemplateChild = {\n          props: ['msg'],\n          template: `<div>{{ msg }}</div>`\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(\n                  ssrRenderComponent(\n                    OptimizedChild,\n                    { msg: 'opt' },\n                    null,\n                    parent\n                  )\n                )\n                push(\n                  ssrRenderComponent(VNodeChild, { msg: 'vnode' }, null, parent)\n                )\n                push(\n                  ssrRenderComponent(\n                    TemplateChild,\n                    { msg: 'template' },\n                    null,\n                    parent\n                  )\n                )\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(\n          `<div>parent<div>opt</div><div>vnode</div><div>template</div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"async components","suites":["ssr: ","components"],"updatePoint":{"line":303,"column":28},"line":303,"code":"      test('async components', async () => {\n        const Child = {\n          // should wait for resolved render context from setup()\n          async setup() {\n            return {\n              msg: 'hello'\n            }\n          },\n          ssrRender(ctx: any, push: any) {\n            push(`<div>${ctx.msg}</div>`)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(ssrRenderComponent(Child, null, null, parent))\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(`<div>parent<div>hello</div></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"parallel async components","suites":["ssr: ","components"],"updatePoint":{"line":329,"column":37},"line":329,"code":"      test('parallel async components', async () => {\n        const OptimizedChild = {\n          props: ['msg'],\n          async setup(props: any) {\n            return {\n              localMsg: props.msg + '!'\n            }\n          },\n          ssrRender(ctx: any, push: any) {\n            push(`<div>${ctx.localMsg}</div>`)\n          }\n        }\n\n        const VNodeChild = {\n          props: ['msg'],\n          async setup(props: any) {\n            return {\n              localMsg: props.msg + '!'\n            }\n          },\n          render(this: any) {\n            return h('div', this.localMsg)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(\n                  ssrRenderComponent(\n                    OptimizedChild,\n                    { msg: 'opt' },\n                    null,\n                    parent\n                  )\n                )\n                push(\n                  ssrRenderComponent(VNodeChild, { msg: 'vnode' }, null, parent)\n                )\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(`<div>parent<div>opt!</div><div>vnode!</div></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested components with optimized slots","suites":["ssr: ","slots"],"updatePoint":{"line":379,"column":50},"line":379,"code":"      test('nested components with optimized slots', async () => {\n        const Child = {\n          props: ['msg'],\n          ssrRender(ctx: any, push: any, parent: any) {\n            push(`<div class=\"child\">`)\n            ssrRenderSlot(\n              ctx.$slots,\n              'default',\n              { msg: 'from slot' },\n              () => {\n                push(`fallback`)\n              },\n              push,\n              parent\n            )\n            push(`</div>`)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(\n                  ssrRenderComponent(\n                    Child,\n                    { msg: 'hello' },\n                    {\n                      // optimized slot using string push\n                      default: (({ msg }, push, _p) => {\n                        push(`<span>${msg}</span>`)\n                      }) as SSRSlot,\n                      // important to avoid slots being normalized\n                      _: 1 as any\n                    },\n                    parent\n                  )\n                )\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(\n          `<div>parent<div class=\"child\">` +\n            `<!--[--><span>from slot</span><!--]-->` +\n            `</div></div>`\n        )\n\n        // test fallback\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(ssrRenderComponent(Child, { msg: 'hello' }, null, parent))\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(\n          `<div>parent<div class=\"child\"><!--[-->fallback<!--]--></div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested components with vnode slots","suites":["ssr: ","slots"],"updatePoint":{"line":444,"column":46},"line":444,"code":"      test('nested components with vnode slots', async () => {\n        const Child = {\n          props: ['msg'],\n          ssrRender(ctx: any, push: any, parent: any) {\n            push(`<div class=\"child\">`)\n            ssrRenderSlot(\n              ctx.$slots,\n              'default',\n              { msg: 'from slot' },\n              null,\n              push,\n              parent\n            )\n            push(`</div>`)\n          }\n        }\n\n        expect(\n          await render(\n            createApp({\n              ssrRender(_ctx, push, parent) {\n                push(`<div>parent`)\n                push(\n                  ssrRenderComponent(\n                    Child,\n                    { msg: 'hello' },\n                    {\n                      // bailed slots returning raw vnodes\n                      default: ({ msg }: any) => {\n                        return h('span', msg)\n                      }\n                    },\n                    parent\n                  )\n                )\n                push(`</div>`)\n              }\n            })\n          )\n        ).toBe(\n          `<div>parent<div class=\"child\">` +\n            `<!--[--><span>from slot</span><!--]-->` +\n            `</div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested components with template slots","suites":["ssr: ","slots"],"updatePoint":{"line":490,"column":49},"line":490,"code":"      test('nested components with template slots', async () => {\n        const Child = {\n          props: ['msg'],\n          template: `<div class=\"child\"><slot msg=\"from slot\"></slot></div>`\n        }\n\n        const app = createApp({\n          components: { Child },\n          template: `<div>parent<Child v-slot=\"{ msg }\"><span>{{ msg }}</span></Child></div>`\n        })\n\n        expect(await render(app)).toBe(\n          `<div>parent<div class=\"child\">` +\n            `<!--[--><span>from slot</span><!--]-->` +\n            `</div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested render fn components with template slots","suites":["ssr: ","slots"],"updatePoint":{"line":508,"column":59},"line":508,"code":"      test('nested render fn components with template slots', async () => {\n        const Child = {\n          props: ['msg'],\n          render(this: any) {\n            return h(\n              'div',\n              {\n                class: 'child'\n              },\n              this.$slots.default({ msg: 'from slot' })\n            )\n          }\n        }\n\n        const app = createApp({\n          template: `<div>parent<Child v-slot=\"{ msg }\"><span>{{ msg }}</span></Child></div>`\n        })\n        app.component('Child', Child)\n\n        expect(await render(app)).toBe(\n          `<div>parent<div class=\"child\">` +\n            // no comment anchors because slot is used directly as element children\n            `<span>from slot</span>` +\n            `</div></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"template slots forwarding","suites":["ssr: ","slots"],"updatePoint":{"line":535,"column":37},"line":535,"code":"      test('template slots forwarding', async () => {\n        const Child = {\n          template: `<div><slot/></div>`\n        }\n\n        const Parent = {\n          components: { Child },\n          template: `<Child><slot/></Child>`\n        }\n\n        const app = createApp({\n          components: { Parent },\n          template: `<Parent>hello</Parent>`\n        })\n\n        expect(await render(app)).toBe(\n          `<div><!--[--><!--[-->hello<!--]--><!--]--></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"template slots forwarding, empty slot","suites":["ssr: ","slots"],"updatePoint":{"line":555,"column":49},"line":555,"code":"      test('template slots forwarding, empty slot', async () => {\n        const Child = {\n          template: `<div><slot/></div>`\n        }\n\n        const Parent = {\n          components: { Child },\n          template: `<Child><slot/></Child>`\n        }\n\n        const app = createApp({\n          components: { Parent },\n          template: `<Parent></Parent>`\n        })\n\n        expect(await render(app)).toBe(\n          // should only have a single fragment\n          `<div><!--[--><!--]--></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"template slots forwarding, empty slot w/ fallback","suites":["ssr: ","slots"],"updatePoint":{"line":576,"column":61},"line":576,"code":"      test('template slots forwarding, empty slot w/ fallback', async () => {\n        const Child = {\n          template: `<div><slot>fallback</slot></div>`\n        }\n\n        const Parent = {\n          components: { Child },\n          template: `<Child><slot/></Child>`\n        }\n\n        const app = createApp({\n          components: { Parent },\n          template: `<Parent></Parent>`\n        })\n\n        expect(await render(app)).toBe(\n          // should only have a single fragment\n          `<div><!--[-->fallback<!--]--></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"props","suites":["ssr: ","vnode element"],"updatePoint":{"line":599,"column":17},"line":599,"code":"      test('props', async () => {\n        expect(\n          await render(h('div', { id: 'foo&', class: ['bar', 'baz'] }, 'hello'))\n        ).toBe(`<div id=\"foo&amp;\" class=\"bar baz\">hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"text children","suites":["ssr: ","vnode element"],"updatePoint":{"line":605,"column":25},"line":605,"code":"      test('text children', async () => {\n        expect(await render(h('div', 'hello'))).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"array children","suites":["ssr: ","vnode element"],"updatePoint":{"line":609,"column":26},"line":609,"code":"      test('array children', async () => {\n        expect(\n          await render(\n            h('div', [\n              'foo',\n              h('span', 'bar'),\n              [h('span', 'baz')],\n              createCommentVNode('qux')\n            ])\n          )\n        ).toBe(\n          `<div>foo<span>bar</span><!--[--><span>baz</span><!--]--><!--qux--></div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"void elements","suites":["ssr: ","vnode element"],"updatePoint":{"line":624,"column":25},"line":624,"code":"      test('void elements', async () => {\n        expect(await render(h('input'))).toBe(`<input>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"innerHTML","suites":["ssr: ","vnode element"],"updatePoint":{"line":628,"column":21},"line":628,"code":"      test('innerHTML', async () => {\n        expect(\n          await render(\n            h(\n              'div',\n              {\n                innerHTML: `<span>hello</span>`\n              },\n              'ignored'\n            )\n          )\n        ).toBe(`<div><span>hello</span></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"textContent","suites":["ssr: ","vnode element"],"updatePoint":{"line":642,"column":23},"line":642,"code":"      test('textContent', async () => {\n        expect(\n          await render(\n            h(\n              'div',\n              {\n                textContent: `<span>hello</span>`\n              },\n              'ignored'\n            )\n          )\n        ).toBe(`<div>${escapeHtml(`<span>hello</span>`)}</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"textarea value","suites":["ssr: ","vnode element"],"updatePoint":{"line":656,"column":26},"line":656,"code":"      test('textarea value', async () => {\n        expect(\n          await render(\n            h(\n              'textarea',\n              {\n                value: `<span>hello</span>`\n              },\n              'ignored'\n            )\n          )\n        ).toBe(`<textarea>${escapeHtml(`<span>hello</span>`)}</textarea>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"KeepAlive","suites":["ssr: ","vnode component"],"updatePoint":{"line":672,"column":21},"line":672,"code":"      test('KeepAlive', async () => {\n        const MyComp = {\n          render: () => h('p', 'hello')\n        }\n        expect(await render(h(KeepAlive, () => h(MyComp)))).toBe(`<p>hello</p>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"Transition","suites":["ssr: ","vnode component"],"updatePoint":{"line":679,"column":22},"line":679,"code":"      test('Transition', async () => {\n        const MyComp = {\n          render: () => h('p', 'hello')\n        }\n        expect(await render(h(Transition, () => h(MyComp)))).toBe(\n          `<p>hello</p>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"Text","suites":["ssr: ","raw vnode types"],"updatePoint":{"line":690,"column":16},"line":690,"code":"      test('Text', async () => {\n        expect(await render(createTextVNode('hello <div>'))).toBe(\n          `hello &lt;div&gt;`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"Comment","suites":["ssr: ","raw vnode types"],"updatePoint":{"line":696,"column":19},"line":696,"code":"      test('Comment', async () => {\n        // https://www.w3.org/TR/html52/syntax.html#comments\n        expect(\n          await render(\n            h('div', [\n              createCommentVNode('>foo'),\n              createCommentVNode('->foo'),\n              createCommentVNode('<!--foo-->'),\n              createCommentVNode('--!>foo<!-')\n            ])\n          )\n        ).toBe(`<div><!--foo--><!--foo--><!--foo--><!--foo--></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"Static","suites":["ssr: ","raw vnode types"],"updatePoint":{"line":710,"column":18},"line":710,"code":"      test('Static', async () => {\n        const content = `<div id=\"ok\">hello<span>world</span></div>`\n        expect(await render(createStaticVNode(content, 1))).toBe(content)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"basic","suites":["ssr: ","scopeId"],"updatePoint":{"line":720,"column":17},"line":720,"code":"      test('basic', async () => {\n        const Foo = {\n          __scopeId: 'data-v-test',\n          render() {\n            return h('div')\n          }\n        }\n        expect(await render(h(Foo))).toBe(`<div data-v-test></div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with client-compiled vnode slots","suites":["ssr: ","scopeId"],"updatePoint":{"line":730,"column":44},"line":730,"code":"      test('with client-compiled vnode slots', async () => {\n        const Child = {\n          __scopeId: 'data-v-child',\n          render: function (this: any) {\n            return h('div', null, [renderSlot(this.$slots, 'default')])\n          }\n        }\n\n        const Parent = {\n          __scopeId: 'data-v-test',\n          render: () => {\n            return h(Child, null, {\n              default: withCtx(() => [h('span', 'slot')])\n            })\n          }\n        }\n\n        expect(await render(h(Parent))).toBe(\n          `<div data-v-child data-v-test>` +\n            `<!--[--><span data-v-test data-v-child-s>slot</span><!--]-->` +\n            `</div>`\n        )\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"render","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":756,"column":18},"line":756,"code":"      test('render', async () => {\n        expect(\n          await render(\n            createApp({\n              data() {\n                return { msg: 'hello' }\n              },\n              template: `<div>{{ msg }}</div>`\n            })\n          )\n        ).toBe(`<div>hello</div>`)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"handle compiler errors","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":769,"column":34},"line":769,"code":"      test('handle compiler errors', async () => {\n        await render(\n          // render different content since compilation is cached\n          createApp({ template: `<div>${type}</` })\n        )\n\n        expect(\n          `Template compilation error: Unexpected EOF in tag.`\n        ).toHaveBeenWarned()\n        expect(`Element is missing end tag`).toHaveBeenWarned()\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"reset current instance after rendering error","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":782,"column":56},"line":782,"code":"      test('reset current instance after rendering error', async () => {\n        const prev = getCurrentInstance()\n        expect(prev).toBe(null)\n        try {\n          await render(\n            createApp({\n              data() {\n                return { msg: null }\n              },\n              template: `<div>{{ msg.text }}</div>`\n            })\n          )\n        } catch {}\n        expect(getCurrentInstance()).toBe(prev)\n      })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"serverPrefetch","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":799,"column":24},"line":799,"code":"    test('serverPrefetch', async () => {\n      const msg = Promise.resolve('hello')\n      const app = createApp({\n        data() {\n          return {\n            msg: ''\n          }\n        },\n        async serverPrefetch() {\n          this.msg = await msg\n        },\n        render() {\n          return h('div', this.msg)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>hello</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"error handling w/ async setup","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":819,"column":39},"line":819,"code":"    test('error handling w/ async setup', async () => {\n      const fn = vi.fn()\n      const fn2 = vi.fn()\n\n      const asyncChildren = defineComponent({\n        async setup() {\n          return Promise.reject('async child error')\n        },\n        template: `<div>asyncChildren</div>`\n      })\n      const app = createApp({\n        name: 'App',\n        components: {\n          asyncChildren\n        },\n        template: `<div class=\"app\"><async-children /></div>`,\n        errorCaptured(error) {\n          fn(error)\n        }\n      })\n\n      app.config.errorHandler = error => {\n        fn2(error)\n      }\n\n      const html = await renderToString(app)\n      expect(html).toBe(`<div class=\"app\"><div>asyncChildren</div></div>`)\n\n      expect(fn).toHaveBeenCalledTimes(1)\n      expect(fn).toBeCalledWith('async child error')\n\n      expect(fn2).toHaveBeenCalledTimes(1)\n      expect(fn2).toBeCalledWith('async child error')\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"effect onInvalidate does not error","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":855,"column":44},"line":855,"code":"    test('effect onInvalidate does not error', async () => {\n      const noop = () => {}\n      const app = createApp({\n        setup: () => {\n          watchEffect(onInvalidate => onInvalidate(noop))\n        },\n        render: noop\n      })\n      expect(await render(app)).toBe('<!---->')\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"assets should be resolved correctly","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":867,"column":45},"line":867,"code":"    test('assets should be resolved correctly', async () => {\n      expect(\n        await render(\n          createApp({\n            components: {\n              A: {\n                ssrRender(_ctx, _push) {\n                  _push(`<div>A</div>`)\n                }\n              },\n              B: {\n                render: () => h('div', 'B')\n              }\n            },\n            ssrRender(_ctx, _push, _parent) {\n              const A: any = resolveComponent('A')\n              _push(ssrRenderComponent(A, null, null, _parent))\n              ssrRenderVNode(\n                _push,\n                createVNode(resolveDynamicComponent('B'), null, null),\n                _parent\n              )\n            }\n          })\n        )\n      ).toBe(`<div>A</div><div>B</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"onServerPrefetch","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":895,"column":26},"line":895,"code":"    test('onServerPrefetch', async () => {\n      const msg = Promise.resolve('hello')\n      const app = createApp({\n        setup() {\n          const message = ref('')\n          onServerPrefetch(async () => {\n            message.value = await msg\n          })\n          return {\n            message\n          }\n        },\n        render() {\n          return h('div', this.message)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>hello</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"multiple onServerPrefetch","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":915,"column":35},"line":915,"code":"    test('multiple onServerPrefetch', async () => {\n      const msg = Promise.resolve('hello')\n      const msg2 = Promise.resolve('hi')\n      const msg3 = Promise.resolve('bonjour')\n      const app = createApp({\n        setup() {\n          const message = ref('')\n          const message2 = ref('')\n          const message3 = ref('')\n          onServerPrefetch(async () => {\n            message.value = await msg\n          })\n          onServerPrefetch(async () => {\n            message2.value = await msg2\n          })\n          onServerPrefetch(async () => {\n            message3.value = await msg3\n          })\n          return {\n            message,\n            message2,\n            message3\n          }\n        },\n        render() {\n          return h('div', `${this.message} ${this.message2} ${this.message3}`)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>hello hi bonjour</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"onServerPrefetch are run in parallel","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":947,"column":46},"line":947,"code":"    test('onServerPrefetch are run in parallel', async () => {\n      const first = vi.fn(() => Promise.resolve())\n      const second = vi.fn(() => Promise.resolve())\n      let checkOther = [false, false]\n      let done = [false, false]\n      const app = createApp({\n        setup() {\n          onServerPrefetch(async () => {\n            checkOther[0] = done[1]\n            await first()\n            done[0] = true\n          })\n          onServerPrefetch(async () => {\n            checkOther[1] = done[0]\n            await second()\n            done[1] = true\n          })\n        },\n        render() {\n          return h('div', '')\n        }\n      })\n      await render(app)\n      expect(first).toHaveBeenCalled()\n      expect(second).toHaveBeenCalled()\n      expect(checkOther).toEqual([false, false])\n      expect(done).toEqual([true, true])\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"onServerPrefetch with serverPrefetch option","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":976,"column":53},"line":976,"code":"    test('onServerPrefetch with serverPrefetch option', async () => {\n      const msg = Promise.resolve('hello')\n      const msg2 = Promise.resolve('hi')\n      const app = createApp({\n        data() {\n          return {\n            message: ''\n          }\n        },\n\n        async serverPrefetch() {\n          this.message = await msg\n        },\n\n        setup() {\n          const message2 = ref('')\n          onServerPrefetch(async () => {\n            message2.value = await msg2\n          })\n          return {\n            message2\n          }\n        },\n        render() {\n          return h('div', `${this.message} ${this.message2}`)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>hello hi</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"mixed in serverPrefetch","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":1007,"column":33},"line":1007,"code":"    test('mixed in serverPrefetch', async () => {\n      const msg = Promise.resolve('hello')\n      const app = createApp({\n        data() {\n          return {\n            msg: ''\n          }\n        },\n        mixins: [\n          {\n            async serverPrefetch() {\n              this.msg = await msg\n            }\n          }\n        ],\n        render() {\n          return h('div', this.msg)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>hello</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"many serverPrefetch","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":1030,"column":29},"line":1030,"code":"    test('many serverPrefetch', async () => {\n      const foo = Promise.resolve('foo')\n      const bar = Promise.resolve('bar')\n      const baz = Promise.resolve('baz')\n      const app = createApp({\n        data() {\n          return {\n            foo: '',\n            bar: '',\n            baz: ''\n          }\n        },\n        mixins: [\n          {\n            async serverPrefetch() {\n              this.foo = await foo\n            }\n          },\n          {\n            async serverPrefetch() {\n              this.bar = await bar\n            }\n          }\n        ],\n        async serverPrefetch() {\n          this.baz = await baz\n        },\n        render() {\n          return h('div', `${this.foo}${this.bar}${this.baz}`)\n        }\n      })\n      const html = await render(app)\n      expect(html).toBe(`<div>foobarbaz</div>`)\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"onServerPrefetch throwing error","suites":["ssr: ","integration w/ compiled template"],"updatePoint":{"line":1065,"column":41},"line":1065,"code":"    test('onServerPrefetch throwing error', async () => {\n      let renderError: Error | null = null\n      let capturedError: Error | null = null\n\n      const Child = {\n        setup() {\n          onServerPrefetch(async () => {\n            throw new Error('An error')\n          })\n        },\n        render() {\n          return h('span')\n        }\n      }\n\n      const app = createApp({\n        setup() {\n          onErrorCaptured(e => {\n            capturedError = e\n            return false\n          })\n        },\n        render() {\n          return h('div', h(Child))\n        }\n      })\n\n      try {\n        await render(app)\n      } catch (e: any) {\n        renderError = e\n      }\n      expect(renderError).toBe(null)\n      expect((capturedError as unknown as Error).message).toBe('An error')\n    })","file":"render.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"basic","suites":["ssr: attr fallthrough"],"updatePoint":{"line":5,"column":13},"line":5,"code":"  test('basic', async () => {\n    const Child = {\n      template: `<div class=\"foo\" />`\n    }\n    const Parent = {\n      components: { Child },\n      template: `<child class=\"bar\"/>`\n    }\n    const app = createApp(Parent)\n    expect(await renderToString(app)).toBe(`<div class=\"foo bar\"></div>`)\n  })","file":"ssrAttrFallthrough.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with v-if","suites":["ssr: attr fallthrough"],"updatePoint":{"line":17,"column":17},"line":17,"code":"  test('with v-if', async () => {\n    const Child = {\n      props: ['ok'],\n      template: `<div v-if=\"ok\" class=\"foo\" /><span v-else />`\n    }\n    const Parent = {\n      props: ['ok'],\n      components: { Child },\n      template: `<child :ok=\"ok\" class=\"bar\"/>`\n    }\n    expect(await renderToString(createApp(Parent, { ok: true }))).toBe(\n      `<div class=\"foo bar\"></div>`\n    )\n    expect(await renderToString(createApp(Parent, { ok: false }))).toBe(\n      `<span class=\"bar\"></span>`\n    )\n  })","file":"ssrAttrFallthrough.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with v-model","suites":["ssr: attr fallthrough"],"updatePoint":{"line":35,"column":20},"line":35,"code":"  test('with v-model', async () => {\n    const Child = {\n      props: ['text'],\n      template: `<input v-model=\"text\">`\n    }\n    const Parent = {\n      components: { Child },\n      template: `<child text=\"hello\" class=\"bar\"/>`\n    }\n    expect(await renderToString(createApp(Parent))).toBe(\n      `<input class=\"bar\" value=\"hello\">`\n    )\n  })","file":"ssrAttrFallthrough.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with v-bind","suites":["ssr: attr fallthrough"],"updatePoint":{"line":49,"column":19},"line":49,"code":"  test('with v-bind', async () => {\n    const Child = {\n      props: ['obj'],\n      template: `<div v-bind=\"obj\" />`\n    }\n    const Parent = {\n      components: { Child },\n      template: `<child :obj=\"{ class: 'foo' }\" class=\"bar\"/>`\n    }\n    expect(await renderToString(createApp(Parent))).toBe(\n      `<div class=\"foo bar\"></div>`\n    )\n  })","file":"ssrAttrFallthrough.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"nested fallthrough","suites":["ssr: attr fallthrough"],"updatePoint":{"line":63,"column":26},"line":63,"code":"  test('nested fallthrough', async () => {\n    const Child = {\n      props: ['id'],\n      template: `<div :id=\"id\"></div>`\n    }\n    const Parent = {\n      components: { Child },\n      template: `<child id=\"foo\" class=\"bar\"/>`\n    }\n    // pass to parent, fallthrough to child and merge\n    const app = createApp(Parent, { class: 'baz' })\n    expect(await renderToString(app)).toBe(\n      `<div id=\"foo\" class=\"bar baz\"></div>`\n    )\n  })","file":"ssrAttrFallthrough.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"config.isCustomElement (deprecated)","suites":["ssr: compiler options"],"updatePoint":{"line":5,"column":43},"line":5,"code":"  test('config.isCustomElement (deprecated)', async () => {\n    const app = createApp({\n      template: `<div><x-button/></div>`\n    })\n    app.config.isCustomElement = tag => tag.startsWith('x-')\n    expect(await renderToString(app)).toBe(`<div><x-button></x-button></div>`)\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"config.compilerOptions.isCustomElement","suites":["ssr: compiler options"],"updatePoint":{"line":13,"column":46},"line":13,"code":"  test('config.compilerOptions.isCustomElement', async () => {\n    const app = createApp({\n      template: `<div><x-panel/></div>`\n    })\n    app.config.compilerOptions.isCustomElement = tag => tag.startsWith('x-')\n    expect(await renderToString(app)).toBe(`<div><x-panel></x-panel></div>`)\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"component.compilerOptions.isCustomElement","suites":["ssr: compiler options"],"updatePoint":{"line":21,"column":49},"line":21,"code":"  test('component.compilerOptions.isCustomElement', async () => {\n    const app = createApp({\n      template: `<div><x-card/><y-child/></div>`,\n      compilerOptions: {\n        isCustomElement: (tag: string) => tag.startsWith('x-')\n      },\n      components: {\n        YChild: {\n          template: `<div><y-button/></div>`\n        }\n      }\n    })\n    app.config.compilerOptions.isCustomElement = tag => tag.startsWith('y-')\n    expect(await renderToString(app)).toBe(\n      `<div><x-card></x-card><div><y-button></y-button></div></div>`\n    )\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"component.delimiters (deprecated)","suites":["ssr: compiler options"],"updatePoint":{"line":39,"column":41},"line":39,"code":"  test('component.delimiters (deprecated)', async () => {\n    const app = createApp({\n      template: `<div>[[ 1 + 1 ]]</div>`,\n      delimiters: ['[[', ']]']\n    })\n    expect(await renderToString(app)).toBe(`<div>2</div>`)\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"config.compilerOptions.delimiters","suites":["ssr: compiler options"],"updatePoint":{"line":47,"column":41},"line":47,"code":"  test('config.compilerOptions.delimiters', async () => {\n    const app = createApp({\n      template: `<div>[( 1 + 1 )]</div>`\n    })\n    app.config.compilerOptions.delimiters = ['[(', ')]']\n    expect(await renderToString(app)).toBe(`<div>2</div>`)\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"component.compilerOptions.delimiters","suites":["ssr: compiler options"],"updatePoint":{"line":55,"column":44},"line":55,"code":"  test('component.compilerOptions.delimiters', async () => {\n    const app = createApp({\n      template: `<div>[[ 1 + 1 ]]<ChildComponent/></div>`,\n      compilerOptions: {\n        delimiters: ['[[', ']]']\n      },\n      components: {\n        ChildComponent: {\n          template: `<div>(( 2 + 2 ))</div>`\n        }\n      }\n    })\n    app.config.compilerOptions.delimiters = ['((', '))']\n    expect(await renderToString(app)).toBe(`<div>2<div>4</div></div>`)\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"compilerOptions.whitespace","suites":["ssr: compiler options"],"updatePoint":{"line":71,"column":34},"line":71,"code":"  test('compilerOptions.whitespace', async () => {\n    const app = createApp({\n      template: `<div><span>Hello   world</span><ChildComponent/></div>`,\n      compilerOptions: {\n        whitespace: 'condense'\n      },\n      components: {\n        ChildComponent: {\n          template: `<span>Hello   world</span>`\n        }\n      }\n    })\n    app.config.compilerOptions.whitespace = 'preserve'\n    expect(await renderToString(app)).toBe(\n      `<div><span>Hello world</span><span>Hello   world</span></div>`\n    )\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"caching with compilerOptions","suites":["ssr: compiler options"],"updatePoint":{"line":89,"column":36},"line":89,"code":"  test('caching with compilerOptions', async () => {\n    const template = `<div>{{1 + 1}}   [[1 + 1]]</div>`\n\n    const app = createApp({\n      template: `<div><ChildOne/><ChildTwo/><ChildThree/></div>`,\n      components: {\n        ChildOne: {\n          template\n        },\n        ChildTwo: {\n          template,\n          compilerOptions: {\n            whitespace: 'preserve'\n          }\n        },\n        ChildThree: {\n          template,\n          compilerOptions: {\n            delimiters: ['[[', ']]']\n          }\n        }\n      }\n    })\n    expect(await renderToString(app)).toBe(\n      `<div><div>2 [[1 + 1]]</div><div>2   [[1 + 1]]</div><div>{{1 + 1}} 2</div></div>`\n    )\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"caching with isCustomElement","suites":["ssr: compiler options"],"updatePoint":{"line":117,"column":36},"line":117,"code":"  test('caching with isCustomElement', async () => {\n    const template = `<div><MyChild/></div>`\n\n    const app = createApp({\n      template,\n      // No compilerOptions on the root\n      components: {\n        MyChild: {\n          template,\n          compilerOptions: {\n            isCustomElement: tag => tag.startsWith('x-')\n          },\n          components: {\n            MyChild: {\n              template,\n              compilerOptions: {\n                isCustomElement: tag => tag.startsWith('My')\n              }\n            }\n          }\n        }\n      }\n    })\n    expect(await renderToString(app)).toBe(\n      `<div><div><div><MyChild></MyChild></div></div></div>`\n    )\n  })","file":"ssrCompilerOptions.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"computed reactivity during SSR","suites":[],"updatePoint":{"line":13,"column":36},"line":13,"code":"test('computed reactivity during SSR', async () => {\n  const store = {\n    // initial state could be hydrated\n    state: reactive({ items: null }) as any,\n\n    // pretend to fetch some data from an api\n    async fetchData() {\n      this.state.items = ['hello', 'world']\n    }\n  }\n\n  const getterSpy = vi.fn()\n\n  const App = defineComponent(async () => {\n    const msg = computed(() => {\n      getterSpy()\n      return store.state.items?.join(' ')\n    })\n\n    // If msg value is falsy then we are either in ssr context or on the client\n    // and the initial state was not modified/hydrated.\n    // In both cases we need to fetch data.\n    if (!msg.value) await store.fetchData()\n\n    expect(msg.value).toBe('hello world')\n    return () => h('div', null, msg.value + msg.value + msg.value)\n  })\n\n  const app = createSSRApp(App)\n\n  const html = await renderToString(app)\n  expect(html).toMatch('hello world')\n\n  // should only be called twice since access should be cached\n  // during the render phase\n  expect(getterSpy).toHaveBeenCalledTimes(2)\n})","file":"ssrComputed.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"basic","suites":["ssr: directives","template v-show"],"updatePoint":{"line":17,"column":15},"line":17,"code":"    test('basic', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            template: `<div v-show=\"true\"/>`\n          })\n        )\n      ).toBe(`<div style=\"\"></div>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            template: `<div v-show=\"false\"/>`\n          })\n        )\n      ).toBe(`<div style=\"display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with static style","suites":["ssr: directives","template v-show"],"updatePoint":{"line":35,"column":27},"line":35,"code":"    test('with static style', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            template: `<div style=\"color:red\" v-show=\"false\"/>`\n          })\n        )\n      ).toBe(`<div style=\"color:red;display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with dynamic style","suites":["ssr: directives","template v-show"],"updatePoint":{"line":45,"column":28},"line":45,"code":"    test('with dynamic style', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ style: { color: 'red' } }),\n            template: `<div :style=\"style\" v-show=\"false\"/>`\n          })\n        )\n      ).toBe(`<div style=\"color:red;display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with static + dynamic style","suites":["ssr: directives","template v-show"],"updatePoint":{"line":56,"column":37},"line":56,"code":"    test('with static + dynamic style', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ style: { color: 'red' } }),\n            template: `<div :style=\"style\" style=\"font-size:12;\" v-show=\"false\"/>`\n          })\n        )\n      ).toBe(`<div style=\"color:red;font-size:12;display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"text","suites":["ssr: directives","template v-model"],"updatePoint":{"line":69,"column":14},"line":69,"code":"    test('text', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ text: 'hello' }),\n            template: `<input v-model=\"text\">`\n          })\n        )\n      ).toBe(`<input value=\"hello\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"radio","suites":["ssr: directives","template v-model"],"updatePoint":{"line":80,"column":15},"line":80,"code":"    test('radio', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ selected: 'foo' }),\n            template: `<input type=\"radio\" value=\"foo\" v-model=\"selected\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"foo\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ selected: 'foo' }),\n            template: `<input type=\"radio\" value=\"bar\" v-model=\"selected\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"bar\">`)\n\n      // non-string values\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ selected: 'foo' }),\n            template: `<input type=\"radio\" :value=\"{}\" v-model=\"selected\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"checkbox","suites":["ssr: directives","template v-model"],"updatePoint":{"line":110,"column":18},"line":110,"code":"    test('checkbox', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ checked: true }),\n            template: `<input type=\"checkbox\" v-model=\"checked\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ checked: false }),\n            template: `<input type=\"checkbox\" v-model=\"checked\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ checked: ['foo'] }),\n            template: `<input type=\"checkbox\" value=\"foo\" v-model=\"checked\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ checked: [] }),\n            template: `<input type=\"checkbox\" value=\"foo\" v-model=\"checked\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"textarea","suites":["ssr: directives","template v-model"],"updatePoint":{"line":148,"column":18},"line":148,"code":"    test('textarea', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ foo: 'hello' }),\n            template: `<textarea v-model=\"foo\"/>`\n          })\n        )\n      ).toBe(`<textarea>hello</textarea>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"dynamic type","suites":["ssr: directives","template v-model"],"updatePoint":{"line":159,"column":22},"line":159,"code":"    test('dynamic type', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'text', model: 'hello' }),\n            template: `<input :type=\"type\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"text\" value=\"hello\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'checkbox', model: true }),\n            template: `<input :type=\"type\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'checkbox', model: false }),\n            template: `<input :type=\"type\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'checkbox', model: ['hello'] }),\n            template: `<input :type=\"type\" value=\"hello\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"hello\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'checkbox', model: [] }),\n            template: `<input :type=\"type\" value=\"hello\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"hello\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'radio', model: 'hello' }),\n            template: `<input :type=\"type\" value=\"hello\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({ type: 'radio', model: 'hello' }),\n            template: `<input :type=\"type\" value=\"bar\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"bar\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with v-bind","suites":["ssr: directives","template v-model"],"updatePoint":{"line":224,"column":21},"line":224,"code":"    test('with v-bind', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            data: () => ({\n              obj: { type: 'radio', value: 'hello' },\n              model: 'hello'\n            }),\n            template: `<input v-bind=\"obj\" v-model=\"model\">`\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\" checked>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"basic","suites":["ssr: directives","vnode v-show"],"updatePoint":{"line":240,"column":15},"line":240,"code":"    test('basic', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('div'), [[vShow, true]])\n            }\n          })\n        )\n      ).toBe(`<div></div>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('div'), [[vShow, false]])\n            }\n          })\n        )\n      ).toBe(`<div style=\"display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"with merge","suites":["ssr: directives","vnode v-show"],"updatePoint":{"line":262,"column":20},"line":262,"code":"    test('with merge', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('div', {\n                  style: {\n                    color: 'red'\n                  }\n                }),\n                [[vShow, false]]\n              )\n            }\n          })\n        )\n      ).toBe(`<div style=\"color:red;display:none;\"></div>`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"text","suites":["ssr: directives","vnode v-model"],"updatePoint":{"line":283,"column":14},"line":283,"code":"    test('text', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input'), [[vModelText, 'hello']])\n            }\n          })\n        )\n      ).toBe(`<input value=\"hello\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"radio","suites":["ssr: directives","vnode v-model"],"updatePoint":{"line":295,"column":15},"line":295,"code":"    test('radio', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'radio', value: 'hello' }),\n                [[vModelRadio, 'hello']]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'radio', value: 'hello' }),\n                [[vModelRadio, 'foo']]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"checkbox","suites":["ssr: directives","vnode v-model"],"updatePoint":{"line":323,"column":18},"line":323,"code":"    test('checkbox', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input', { type: 'checkbox' }), [\n                [vModelCheckbox, true]\n              ])\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input', { type: 'checkbox' }), [\n                [vModelCheckbox, false]\n              ])\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'checkbox', value: 'foo' }),\n                [[vModelCheckbox, ['foo']]]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'checkbox', value: 'foo' }),\n                [[vModelCheckbox, []]]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"text","suites":["ssr: directives","vnode v-model dynamic"],"updatePoint":{"line":377,"column":14},"line":377,"code":"    test('text', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input'), [[vModelDynamic, 'hello']])\n            }\n          })\n        )\n      ).toBe(`<input value=\"hello\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"radio","suites":["ssr: directives","vnode v-model dynamic"],"updatePoint":{"line":389,"column":15},"line":389,"code":"    test('radio', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'radio', value: 'hello' }),\n                [[vModelDynamic, 'hello']]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'radio', value: 'hello' }),\n                [[vModelDynamic, 'foo']]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"radio\" value=\"hello\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"checkbox","suites":["ssr: directives","vnode v-model dynamic"],"updatePoint":{"line":417,"column":18},"line":417,"code":"    test('checkbox', async () => {\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input', { type: 'checkbox' }), [\n                [vModelDynamic, true]\n              ])\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(h('input', { type: 'checkbox' }), [\n                [vModelDynamic, false]\n              ])\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\">`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'checkbox', value: 'foo' }),\n                [[vModelDynamic, ['foo']]]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\" checked>`)\n\n      expect(\n        await renderToString(\n          createApp({\n            render() {\n              return withDirectives(\n                h('input', { type: 'checkbox', value: 'foo' }),\n                [[vModelDynamic, []]]\n              )\n            }\n          })\n        )\n      ).toBe(`<input type=\"checkbox\" value=\"foo\">`)\n    })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"custom directive w/ getSSRProps (vdom)","suites":["ssr: directives","vnode v-model dynamic"],"updatePoint":{"line":470,"column":46},"line":470,"code":"  test('custom directive w/ getSSRProps (vdom)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          render() {\n            return withDirectives(h('div'), [\n              [\n                {\n                  getSSRProps({ value }) {\n                    return { id: value }\n                  }\n                },\n                'foo'\n              ]\n            ])\n          }\n        })\n      )\n    ).toBe(`<div id=\"foo\"></div>`)\n  })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"custom directive w/ getSSRProps (optimized)","suites":["ssr: directives","vnode v-model dynamic"],"updatePoint":{"line":491,"column":51},"line":491,"code":"  test('custom directive w/ getSSRProps (optimized)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          data() {\n            return {\n              x: 'foo'\n            }\n          },\n          directives: {\n            xxx: {\n              getSSRProps({ value, arg, modifiers }) {\n                return { id: [value, arg, modifiers.ok].join('-') }\n              }\n            }\n          },\n          ssrRender(_ctx, _push, _parent, _attrs) {\n            const _directive_xxx = resolveDirective('xxx')!\n            _push(\n              `<div${ssrRenderAttrs(\n                ssrGetDirectiveProps(_ctx, _directive_xxx, _ctx.x, 'arg', {\n                  ok: true\n                })\n              )}></div>`\n            )\n          }\n        })\n      )\n    ).toBe(`<div id=\"foo-arg-true\"></div>`)\n  })","file":"ssrDirectives.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"resolved to component","suites":["ssr: dynamic component"],"updatePoint":{"line":5,"column":29},"line":5,"code":"  test('resolved to component', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<div><slot/></div>`\n            }\n          },\n          template: `<component :is=\"'one'\"><span>slot</span></component>`\n        })\n      )\n    ).toBe(`<div><!--[--><span>slot</span><!--]--></div>`)\n  })","file":"ssrDynamicComponent.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"resolve to element","suites":["ssr: dynamic component"],"updatePoint":{"line":20,"column":26},"line":20,"code":"  test('resolve to element', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          template: `<component :is=\"'p'\"><span>slot</span></component>`\n        })\n      )\n    ).toBe(`<p><span>slot</span></p>`)\n  })","file":"ssrDynamicComponent.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"resolve to component vnode","suites":["ssr: dynamic component"],"updatePoint":{"line":30,"column":34},"line":30,"code":"  test('resolve to component vnode', async () => {\n    const Child = {\n      props: ['id'],\n      template: `<div>{{ id }}<slot/></div>`\n    }\n    expect(\n      await renderToString(\n        createApp({\n          setup() {\n            return {\n              vnode: createVNode(Child, { id: 'test' })\n            }\n          },\n          template: `<component :is=\"vnode\"><span>slot</span></component>`\n        })\n      )\n    ).toBe(`<div>test<!--[--><span>slot</span><!--]--></div>`)\n  })","file":"ssrDynamicComponent.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"resolve to element vnode","suites":["ssr: dynamic component"],"updatePoint":{"line":49,"column":32},"line":49,"code":"  test('resolve to element vnode', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          setup() {\n            return {\n              vnode: createVNode('div', { id: 'test' })\n            }\n          },\n          template: `<component :is=\"vnode\"><span>slot</span></component>`\n        })\n      )\n    ).toBe(`<div id=\"test\"><span>slot</span></div>`)\n  })","file":"ssrDynamicComponent.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ssr: interpolate","suites":[],"updatePoint":{"line":4,"column":22},"line":4,"code":"test('ssr: interpolate', () => {\n  expect(ssrInterpolate(0)).toBe(`0`)\n  expect(ssrInterpolate(`foo`)).toBe(`foo`)\n  expect(ssrInterpolate(`<div>`)).toBe(`&lt;div&gt;`)\n  // should escape interpolated values\n  expect(ssrInterpolate([1, 2, 3])).toBe(\n    escapeHtml(JSON.stringify([1, 2, 3], null, 2))\n  )\n  expect(\n    ssrInterpolate({\n      foo: 1,\n      bar: `<div>`\n    })\n  ).toBe(\n    escapeHtml(\n      JSON.stringify(\n        {\n          foo: 1,\n          bar: `<div>`\n        },\n        null,\n        2\n      )\n    )\n  )\n})","file":"ssrInterpolate.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ignore reserved props","suites":["ssr: renderAttrs"],"updatePoint":{"line":10,"column":29},"line":10,"code":"  test('ignore reserved props', () => {\n    expect(\n      ssrRenderAttrs({\n        key: 1,\n        ref_key: 'foo',\n        ref_for: 'bar',\n        ref: () => {},\n        onClick: () => {}\n      })\n    ).toBe('')\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"normal attrs","suites":["ssr: renderAttrs"],"updatePoint":{"line":22,"column":20},"line":22,"code":"  test('normal attrs', () => {\n    expect(\n      ssrRenderAttrs({\n        id: 'foo',\n        title: 'bar'\n      })\n    ).toBe(` id=\"foo\" title=\"bar\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"empty value attrs","suites":["ssr: renderAttrs"],"updatePoint":{"line":31,"column":25},"line":31,"code":"  test('empty value attrs', () => {\n    expect(\n      ssrRenderAttrs({\n        'data-v-abc': ''\n      })\n    ).toBe(` data-v-abc`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"escape attrs","suites":["ssr: renderAttrs"],"updatePoint":{"line":39,"column":20},"line":39,"code":"  test('escape attrs', () => {\n    expect(\n      ssrRenderAttrs({\n        id: '\"><script'\n      })\n    ).toBe(` id=\"&quot;&gt;&lt;script\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"boolean attrs","suites":["ssr: renderAttrs"],"updatePoint":{"line":47,"column":21},"line":47,"code":"  test('boolean attrs', () => {\n    expect(\n      ssrRenderAttrs({\n        checked: true,\n        multiple: false,\n        readonly: 0,\n        disabled: ''\n      })\n    ).toBe(` checked disabled`) // boolean attr w/ false should be ignored\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ignore falsy values","suites":["ssr: renderAttrs"],"updatePoint":{"line":58,"column":27},"line":58,"code":"  test('ignore falsy values', () => {\n    expect(\n      ssrRenderAttrs({\n        foo: false,\n        title: null,\n        baz: undefined\n      })\n    ).toBe(` foo=\"false\"`) // non boolean should render `false` as is\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ignore non-renderable values","suites":["ssr: renderAttrs"],"updatePoint":{"line":68,"column":36},"line":68,"code":"  test('ignore non-renderable values', () => {\n    expect(\n      ssrRenderAttrs({\n        foo: {},\n        bar: [],\n        baz: () => {}\n      })\n    ).toBe(``)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"props to attrs","suites":["ssr: renderAttrs"],"updatePoint":{"line":78,"column":22},"line":78,"code":"  test('props to attrs', () => {\n    expect(\n      ssrRenderAttrs({\n        readOnly: true, // simple lower case conversion\n        htmlFor: 'foobar' // special cases\n      })\n    ).toBe(` readonly for=\"foobar\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"preserve name on custom element","suites":["ssr: renderAttrs"],"updatePoint":{"line":87,"column":39},"line":87,"code":"  test('preserve name on custom element', () => {\n    expect(\n      ssrRenderAttrs(\n        {\n          fooBar: 'ok'\n        },\n        'my-el'\n      )\n    ).toBe(` fooBar=\"ok\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"preserve name on svg elements","suites":["ssr: renderAttrs"],"updatePoint":{"line":98,"column":37},"line":98,"code":"  test('preserve name on svg elements', () => {\n    expect(\n      ssrRenderAttrs(\n        {\n          viewBox: 'foo'\n        },\n        'svg'\n      )\n    ).toBe(` viewBox=\"foo\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"basic","suites":["ssr: renderAttr"],"updatePoint":{"line":111,"column":13},"line":111,"code":"  test('basic', () => {\n    expect(ssrRenderAttr('foo', 'bar')).toBe(` foo=\"bar\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"null and undefined","suites":["ssr: renderAttr"],"updatePoint":{"line":115,"column":26},"line":115,"code":"  test('null and undefined', () => {\n    expect(ssrRenderAttr('foo', null)).toBe(``)\n    expect(ssrRenderAttr('foo', undefined)).toBe(``)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"escape","suites":["ssr: renderAttr"],"updatePoint":{"line":120,"column":14},"line":120,"code":"  test('escape', () => {\n    expect(ssrRenderAttr('foo', '<script>')).toBe(\n      ` foo=\"${escapeHtml(`<script>`)}\"`\n    )\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"via renderProps","suites":["ssr: renderClass"],"updatePoint":{"line":128,"column":23},"line":128,"code":"  test('via renderProps', () => {\n    expect(\n      ssrRenderAttrs({\n        class: ['foo', 'bar']\n      })\n    ).toBe(` class=\"foo bar\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"standalone","suites":["ssr: renderClass"],"updatePoint":{"line":136,"column":18},"line":136,"code":"  test('standalone', () => {\n    expect(ssrRenderClass(`foo`)).toBe(`foo`)\n    expect(ssrRenderClass([`foo`, `bar`])).toBe(`foo bar`)\n    expect(ssrRenderClass({ foo: true, bar: false })).toBe(`foo`)\n    expect(ssrRenderClass([{ foo: true, bar: false }, `baz`])).toBe(`foo baz`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"escape class values","suites":["ssr: renderClass"],"updatePoint":{"line":143,"column":27},"line":143,"code":"  test('escape class values', () => {\n    expect(ssrRenderClass(`\"><script`)).toBe(`&quot;&gt;&lt;script`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"via renderProps","suites":["ssr: renderStyle"],"updatePoint":{"line":149,"column":23},"line":149,"code":"  test('via renderProps', () => {\n    expect(\n      ssrRenderAttrs({\n        style: {\n          color: 'red',\n          '--a': 2,\n          '-webkit-line-clamp': 1\n        }\n      })\n    ).toBe(` style=\"color:red;--a:2;-webkit-line-clamp:1;\"`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"standalone","suites":["ssr: renderStyle"],"updatePoint":{"line":161,"column":18},"line":161,"code":"  test('standalone', () => {\n    expect(ssrRenderStyle(`color:red`)).toBe(`color:red`)\n    expect(\n      ssrRenderStyle({\n        color: `red`\n      })\n    ).toBe(`color:red;`)\n    expect(\n      ssrRenderStyle([\n        { color: `red` },\n        { fontSize: `15px` } // case conversion\n      ])\n    ).toBe(`color:red;font-size:15px;`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"number handling","suites":["ssr: renderStyle"],"updatePoint":{"line":176,"column":23},"line":176,"code":"  test('number handling', () => {\n    expect(\n      ssrRenderStyle({\n        fontSize: null, // invalid value should be ignored\n        opacity: 0.5\n      })\n    ).toBe(`opacity:0.5;`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"escape inline CSS","suites":["ssr: renderStyle"],"updatePoint":{"line":185,"column":25},"line":185,"code":"  test('escape inline CSS', () => {\n    expect(ssrRenderStyle(`\"><script`)).toBe(`&quot;&gt;&lt;script`)\n    expect(\n      ssrRenderStyle({\n        color: `\"><script`\n      })\n    ).toBe(`color:&quot;&gt;&lt;script;`)\n  })","file":"ssrRenderAttrs.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should render items in an array","suites":["ssr: renderList"],"updatePoint":{"line":10,"column":37},"line":10,"code":"  it('should render items in an array', () => {\n    ssrRenderList(['1', '2', '3'], (item, index) =>\n      stack.push(`node ${index}: ${item}`)\n    )\n    expect(stack).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should render characters of a string","suites":["ssr: renderList"],"updatePoint":{"line":17,"column":42},"line":17,"code":"  it('should render characters of a string', () => {\n    ssrRenderList('abc', (item, index) => stack.push(`node ${index}: ${item}`))\n    expect(stack).toEqual(['node 0: a', 'node 1: b', 'node 2: c'])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should render integers 1 through N when given a number N","suites":["ssr: renderList"],"updatePoint":{"line":22,"column":62},"line":22,"code":"  it('should render integers 1 through N when given a number N', () => {\n    ssrRenderList(3, (item, index) => stack.push(`node ${index}: ${item}`))\n    expect(stack).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should warn when given a non-integer N","suites":["ssr: renderList"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  it('should warn when given a non-integer N', () => {\n    ssrRenderList(3.1, () => {})\n    expect(\n      `The v-for range expect an integer value but got 3.1.`\n    ).toHaveBeenWarned()\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should render properties in an object","suites":["ssr: renderList"],"updatePoint":{"line":34,"column":43},"line":34,"code":"  it('should render properties in an object', () => {\n    ssrRenderList({ a: 1, b: 2, c: 3 }, (item, key, index) =>\n      stack.push(`node ${index}/${key}: ${item}`)\n    )\n    expect(stack).toEqual(['node 0/a: 1', 'node 1/b: 2', 'node 2/c: 3'])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should render an item for entry in an iterable","suites":["ssr: renderList"],"updatePoint":{"line":41,"column":52},"line":41,"code":"  it('should render an item for entry in an iterable', () => {\n    const iterable = function* () {\n      yield 1\n      yield 2\n      yield 3\n    }\n\n    ssrRenderList(iterable(), (item, index) =>\n      stack.push(`node ${index}: ${item}`)\n    )\n    expect(stack).toEqual(['node 0: 1', 'node 1: 2', 'node 2: 3'])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should not render items when source is undefined","suites":["ssr: renderList"],"updatePoint":{"line":54,"column":54},"line":54,"code":"  it('should not render items when source is undefined', () => {\n    ssrRenderList(undefined, (item, index) =>\n      stack.push(`node ${index}: ${item}`)\n    )\n    expect(stack).toEqual([])\n  })","file":"ssrRenderList.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"id on component root","suites":["ssr: scopedId runtime behavior"],"updatePoint":{"line":6,"column":28},"line":6,"code":"  test('id on component root', async () => {\n    const Child = {\n      ssrRender: (ctx: any, push: any, parent: any, attrs: any) => {\n        push(`<div${ssrRenderAttrs(attrs)}></div>`)\n      }\n    }\n\n    const Comp = {\n      __scopeId: 'parent',\n      ssrRender: (ctx: any, push: any, parent: any) => {\n        push(ssrRenderComponent(Child), null, null, parent)\n      }\n    }\n\n    const result = await renderToString(createApp(Comp))\n    expect(result).toBe(`<div parent></div>`)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"id and :slotted on component root","suites":["ssr: scopedId runtime behavior"],"updatePoint":{"line":24,"column":41},"line":24,"code":"  test('id and :slotted on component root', async () => {\n    const Child = {\n      // <div></div>\n      ssrRender: (_: any, push: any, _parent: any, attrs: any) => {\n        push(`<div${ssrRenderAttrs(attrs)} child></div>`)\n      }\n    }\n\n    const Wrapper = {\n      __scopeId: 'wrapper',\n      ssrRender: (ctx: any, push: any, parent: any) => {\n        // <slot/>\n        ssrRenderSlot(\n          ctx.$slots,\n          'default',\n          {},\n          null,\n          push,\n          parent,\n          'wrapper-s'\n        )\n      }\n    }\n\n    const Comp = {\n      __scopeId: 'parent',\n      ssrRender: (_: any, push: any, parent: any) => {\n        // <Wrapper><Child/></Wrapper>\n        push(\n          ssrRenderComponent(\n            Wrapper,\n            null,\n            {\n              default: withCtx(\n                (_: any, push: any, parent: any, scopeId: string) => {\n                  push(ssrRenderComponent(Child, null, null, parent, scopeId))\n                }\n              ),\n              _: 1\n            } as any,\n            parent\n          )\n        )\n      }\n    }\n\n    const result = await renderToString(createApp(Comp))\n    expect(result).toBe(`<!--[--><div parent wrapper-s child></div><!--]-->`)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":":slotted on forwarded slots","suites":["ssr: scopedId runtime behavior"],"updatePoint":{"line":75,"column":35},"line":75,"code":"  test(':slotted on forwarded slots', async () => {\n    const Wrapper = {\n      __scopeId: 'wrapper',\n      ssrRender: (ctx: any, push: any, parent: any, attrs: any) => {\n        // <div class=\"wrapper\"><slot/></div>\n        push(\n          `<div${ssrRenderAttrs(\n            mergeProps({ class: 'wrapper' }, attrs)\n          )} wrapper>`\n        )\n        ssrRenderSlot(\n          ctx.$slots,\n          'default',\n          {},\n          null,\n          push,\n          parent,\n          'wrapper-s'\n        )\n        push(`</div>`)\n      }\n    }\n\n    const Slotted = {\n      __scopeId: 'slotted',\n      ssrRender: (ctx: any, push: any, parent: any, attrs: any) => {\n        // <Wrapper><slot/></Wrapper>\n        push(\n          ssrRenderComponent(\n            Wrapper,\n            attrs,\n            {\n              default: withCtx(\n                (_: any, push: any, parent: any, scopeId: string) => {\n                  ssrRenderSlot(\n                    ctx.$slots,\n                    'default',\n                    {},\n                    null,\n                    push,\n                    parent,\n                    'slotted-s' + scopeId\n                  )\n                }\n              ),\n              _: 1\n            } as any,\n            parent\n          )\n        )\n      }\n    }\n\n    const Root = {\n      __scopeId: 'root',\n      // <Slotted><div></div></Slotted>\n      ssrRender: (_: any, push: any, parent: any, attrs: any) => {\n        push(\n          ssrRenderComponent(\n            Slotted,\n            attrs,\n            {\n              default: withCtx(\n                (_: any, push: any, parent: any, scopeId: string) => {\n                  push(`<div root${scopeId}></div>`)\n                }\n              ),\n              _: 1\n            } as any,\n            parent\n          )\n        )\n      }\n    }\n\n    const result = await renderToString(createApp(Root))\n    expect(result).toBe(\n      `<div class=\"wrapper\" root slotted wrapper>` +\n        `<!--[--><!--[--><div root slotted-s wrapper-s></div><!--]--><!--]-->` +\n        `</div>`\n    )\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"scopeId inheritance across ssr-compiled andn on-ssr compiled parent chain","suites":["ssr: scopedId runtime behavior"],"updatePoint":{"line":159,"column":81},"line":159,"code":"  test('scopeId inheritance across ssr-compiled andn on-ssr compiled parent chain', async () => {\n    const Child = {\n      ssrRender: (ctx: any, push: any, parent: any, attrs: any) => {\n        push(`<div${ssrRenderAttrs(attrs)}></div>`)\n      }\n    }\n\n    const Middle = {\n      render() {\n        return h(Child)\n      }\n    }\n\n    const Comp = {\n      __scopeId: 'parent',\n      ssrRender: (ctx: any, push: any, parent: any) => {\n        push(ssrRenderComponent(Middle, null, null, parent))\n      }\n    }\n\n    const result = await renderToString(createApp(Comp)) // output: `<div></div>`\n    expect(result).toBe(`<div parent></div>`)\n  })","file":"ssrScopeId.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"text slot","suites":["ssr: slot"],"updatePoint":{"line":11,"column":17},"line":11,"code":"  test('text slot', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components,\n          template: `<one>hello</one>`\n        })\n      )\n    ).toBe(`<div><!--[-->hello<!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"element slot","suites":["ssr: slot"],"updatePoint":{"line":22,"column":20},"line":22,"code":"  test('element slot', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components,\n          template: `<one><div>hi</div></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><div>hi</div><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"empty slot","suites":["ssr: slot"],"updatePoint":{"line":33,"column":18},"line":33,"code":"  test('empty slot', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<div><slot/></div>`\n            }\n          },\n          template: `<one><template v-if=\"false\"/></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"empty slot (manual comments)","suites":["ssr: slot"],"updatePoint":{"line":48,"column":36},"line":48,"code":"  test('empty slot (manual comments)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<div><slot/></div>`\n            }\n          },\n          template: `<one><!--hello--></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"empty slot (multi-line comments)","suites":["ssr: slot"],"updatePoint":{"line":63,"column":40},"line":63,"code":"  test('empty slot (multi-line comments)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<div><slot/></div>`\n            }\n          },\n          template: `<one><!--he\\nllo--></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"multiple elements","suites":["ssr: slot"],"updatePoint":{"line":78,"column":25},"line":78,"code":"  test('multiple elements', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components,\n          template: `<one><div>one</div><div>two</div></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><div>one</div><div>two</div><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"fragment slot (template v-if)","suites":["ssr: slot"],"updatePoint":{"line":89,"column":37},"line":89,"code":"  test('fragment slot (template v-if)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components,\n          template: `<one><template v-if=\"true\">hello</template></one>`\n        })\n      )\n    ).toBe(`<div><!--[--><!--[-->hello<!--]--><!--]--></div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"fragment slot (template v-if + multiple elements)","suites":["ssr: slot"],"updatePoint":{"line":100,"column":57},"line":100,"code":"  test('fragment slot (template v-if + multiple elements)', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components,\n          template: `<one><template v-if=\"true\"><div>one</div><div>two</div></template></one>`\n        })\n      )\n    ).toBe(\n      `<div><!--[--><!--[--><div>one</div><div>two</div><!--]--><!--]--></div>`\n    )\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"transition slot","suites":["ssr: slot"],"updatePoint":{"line":113,"column":23},"line":113,"code":"  test('transition slot', async () => {\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<transition><slot/></transition>`\n            }\n          },\n          template: `<one><div v-if=\"false\">foo</div></one>`\n        })\n      )\n    ).toBe(`<!---->`)\n\n    expect(\n      await renderToString(\n        createApp({\n          components: {\n            one: {\n              template: `<transition><slot/></transition>`\n            }\n          },\n          template: `<one><div v-if=\"true\">foo</div></one>`\n        })\n      )\n    ).toBe(`<div>foo</div>`)\n  })","file":"ssrSlot.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"content","suites":["SSR Suspense"],"updatePoint":{"line":18,"column":15},"line":18,"code":"  test('content', async () => {\n    const Comp = {\n      render() {\n        return h(Suspense, null, {\n          default: h(ResolvingAsync),\n          fallback: h('div', 'fallback')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(`<div>async</div>`)\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"reject","suites":["SSR Suspense"],"updatePoint":{"line":31,"column":14},"line":31,"code":"  test('reject', async () => {\n    const Comp = {\n      errorCaptured: vi.fn(() => false),\n      render() {\n        return h(Suspense, null, {\n          default: h(RejectingAsync),\n          fallback: h('div', 'fallback')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(`<!---->`)\n\n    expect(Comp.errorCaptured).toHaveBeenCalledTimes(1)\n    expect('missing template').toHaveBeenWarned()\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"2 components","suites":["SSR Suspense"],"updatePoint":{"line":48,"column":20},"line":48,"code":"  test('2 components', async () => {\n    const Comp = {\n      render() {\n        return h(Suspense, null, {\n          default: h('div', [h(ResolvingAsync), h(ResolvingAsync)]),\n          fallback: h('div', 'fallback')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(\n      `<div><div>async</div><div>async</div></div>`\n    )\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"resolving component + rejecting component","suites":["SSR Suspense"],"updatePoint":{"line":63,"column":49},"line":63,"code":"  test('resolving component + rejecting component', async () => {\n    const Comp = {\n      errorCaptured: vi.fn(() => false),\n      render() {\n        return h(Suspense, null, {\n          default: h('div', [h(ResolvingAsync), h(RejectingAsync)]),\n          fallback: h('div', 'fallback')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(\n      `<div><div>async</div><!----></div>`\n    )\n\n    expect(Comp.errorCaptured).toHaveBeenCalledTimes(1)\n    expect('missing template or render function').toHaveBeenWarned()\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"failing suspense in passing suspense","suites":["SSR Suspense"],"updatePoint":{"line":82,"column":44},"line":82,"code":"  test('failing suspense in passing suspense', async () => {\n    const Comp = {\n      errorCaptured: vi.fn(() => false),\n      render() {\n        return h(Suspense, null, {\n          default: h('div', [\n            h(ResolvingAsync),\n            h(Suspense, null, {\n              default: h('div', [h(RejectingAsync)]),\n              fallback: h('div', 'fallback 2')\n            })\n          ]),\n          fallback: h('div', 'fallback 1')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(\n      `<div><div>async</div><div><!----></div></div>`\n    )\n\n    expect(Comp.errorCaptured).toHaveBeenCalledTimes(1)\n    expect('missing template').toHaveBeenWarned()\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"passing suspense in failing suspense","suites":["SSR Suspense"],"updatePoint":{"line":107,"column":44},"line":107,"code":"  test('passing suspense in failing suspense', async () => {\n    const Comp = {\n      errorCaptured: vi.fn(() => false),\n      render() {\n        return h(Suspense, null, {\n          default: h('div', [\n            h(RejectingAsync),\n            h(Suspense, null, {\n              default: h('div', [h(ResolvingAsync)]),\n              fallback: h('div', 'fallback 2')\n            })\n          ]),\n          fallback: h('div', 'fallback 1')\n        })\n      }\n    }\n\n    expect(await renderToString(createApp(Comp))).toBe(\n      `<div><!----><div><div>async</div></div></div>`\n    )\n    expect(Comp.errorCaptured).toHaveBeenCalledTimes(1)\n    expect('missing template').toHaveBeenWarned()\n  })","file":"ssrSuspense.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport rendering (compiled)","suites":["ssrRenderTeleport"],"updatePoint":{"line":8,"column":37},"line":8,"code":"  test('teleport rendering (compiled)', async () => {\n    const ctx: SSRContext = {}\n    const html = await renderToString(\n      createApp({\n        data() {\n          return { msg: 'hello' }\n        },\n        ssrRender(_ctx, _push, _parent) {\n          ssrRenderTeleport(\n            _push,\n            _push => {\n              _push(`<div>content</div>`)\n            },\n            '#target',\n            false,\n            _parent\n          )\n        }\n      }),\n      ctx\n    )\n    expect(html).toBe('<!--teleport start--><!--teleport end-->')\n    expect(ctx.teleports!['#target']).toBe(\n      `<div>content</div><!--teleport anchor-->`\n    )\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport rendering (compiled + disabled)","suites":["ssrRenderTeleport"],"updatePoint":{"line":35,"column":48},"line":35,"code":"  test('teleport rendering (compiled + disabled)', async () => {\n    const ctx: SSRContext = {}\n    const html = await renderToString(\n      createApp({\n        data() {\n          return { msg: 'hello' }\n        },\n        ssrRender(_ctx, _push, _parent) {\n          ssrRenderTeleport(\n            _push,\n            _push => {\n              _push(`<div>content</div>`)\n            },\n            '#target',\n            true,\n            _parent\n          )\n        }\n      }),\n      ctx\n    )\n    expect(html).toBe(\n      '<!--teleport start--><div>content</div><!--teleport end-->'\n    )\n    expect(ctx.teleports!['#target']).toBe(`<!--teleport anchor-->`)\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport rendering (vnode)","suites":["ssrRenderTeleport"],"updatePoint":{"line":62,"column":34},"line":62,"code":"  test('teleport rendering (vnode)', async () => {\n    const ctx: SSRContext = {}\n    const html = await renderToString(\n      h(\n        Teleport,\n        {\n          to: `#target`\n        },\n        h('span', 'hello')\n      ),\n      ctx\n    )\n    expect(html).toBe('<!--teleport start--><!--teleport end-->')\n    expect(ctx.teleports!['#target']).toBe(\n      '<span>hello</span><!--teleport anchor-->'\n    )\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport rendering (vnode + disabled)","suites":["ssrRenderTeleport"],"updatePoint":{"line":80,"column":45},"line":80,"code":"  test('teleport rendering (vnode + disabled)', async () => {\n    const ctx: SSRContext = {}\n    const html = await renderToString(\n      h(\n        Teleport,\n        {\n          to: `#target`,\n          disabled: true\n        },\n        h('span', 'hello')\n      ),\n      ctx\n    )\n    expect(html).toBe(\n      '<!--teleport start--><span>hello</span><!--teleport end-->'\n    )\n    expect(ctx.teleports!['#target']).toBe(`<!--teleport anchor-->`)\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"multiple teleports with same target","suites":["ssrRenderTeleport"],"updatePoint":{"line":99,"column":43},"line":99,"code":"  test('multiple teleports with same target', async () => {\n    const ctx: SSRContext = {}\n    const html = await renderToString(\n      h('div', [\n        h(\n          Teleport,\n          {\n            to: `#target`\n          },\n          h('span', 'hello')\n        ),\n        h(Teleport, { to: `#target` }, 'world')\n      ]),\n      ctx\n    )\n    expect(html).toBe(\n      '<div><!--teleport start--><!--teleport end--><!--teleport start--><!--teleport end--></div>'\n    )\n    expect(ctx.teleports!['#target']).toBe(\n      '<span>hello</span><!--teleport anchor-->world<!--teleport anchor-->'\n    )\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport inside async component","suites":["ssrRenderTeleport"],"updatePoint":{"line":122,"column":39},"line":122,"code":"  test('teleport inside async component', async () => {\n    const ctx: SSRContext = {}\n    const asyncComponent = {\n      template: '<teleport to=\"#target\"><div>content</div></teleport>',\n      async setup() {}\n    }\n    const html = await renderToString(\n      h({\n        template: '<async-component />',\n        components: { asyncComponent }\n      }),\n      ctx\n    )\n    expect(html).toBe('<!--teleport start--><!--teleport end-->')\n    expect(ctx.teleports!['#target']).toBe(\n      `<div>content</div><!--teleport anchor-->`\n    )\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"teleport inside async component (stream)","suites":["ssrRenderTeleport"],"updatePoint":{"line":141,"column":48},"line":141,"code":"  test('teleport inside async component (stream)', async () => {\n    const ctx: SSRContext = {}\n    const asyncComponent = {\n      template: '<teleport to=\"#target\"><div>content</div></teleport>',\n      async setup() {}\n    }\n    let html = ''\n    let resolve: any\n    const p = new Promise(r => (resolve = r))\n    renderToSimpleStream(\n      h({\n        template: '<async-component />',\n        components: { asyncComponent }\n      }),\n      ctx,\n      {\n        push(chunk) {\n          if (chunk === null) {\n            resolve()\n          } else {\n            html += chunk\n          }\n        },\n        destroy(err) {\n          throw err\n        }\n      }\n    )\n    await p\n    expect(html).toBe('<!--teleport start--><!--teleport end-->')\n    expect(ctx.teleports!['#target']).toBe(\n      `<div>content</div><!--teleport anchor-->`\n    )\n  })","file":"ssrTeleport.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ssrRenderDynamicModel","suites":["ssr: v-model helpers"],"updatePoint":{"line":8,"column":29},"line":8,"code":"  test('ssrRenderDynamicModel', () => {\n    expect(ssrRenderDynamicModel(null, 'foo', null)).toBe(` value=\"foo\"`)\n    expect(ssrRenderDynamicModel('text', 'foo', null)).toBe(` value=\"foo\"`)\n    expect(ssrRenderDynamicModel('email', 'foo', null)).toBe(` value=\"foo\"`)\n\n    expect(ssrRenderDynamicModel('checkbox', true, null)).toBe(` checked`)\n    expect(ssrRenderDynamicModel('checkbox', false, null)).toBe(``)\n    expect(ssrRenderDynamicModel('checkbox', [1], '1')).toBe(` checked`)\n    expect(ssrRenderDynamicModel('checkbox', [1], 1)).toBe(` checked`)\n    expect(ssrRenderDynamicModel('checkbox', [1], 0)).toBe(``)\n\n    expect(ssrRenderDynamicModel('radio', 'foo', 'foo')).toBe(` checked`)\n    expect(ssrRenderDynamicModel('radio', 1, '1')).toBe(` checked`)\n    expect(ssrRenderDynamicModel('radio', 1, 0)).toBe(``)\n  })","file":"ssrVModelHelpers.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"ssrGetDynamicModelProps","suites":["ssr: v-model helpers"],"updatePoint":{"line":24,"column":31},"line":24,"code":"  test('ssrGetDynamicModelProps', () => {\n    expect(ssrGetDynamicModelProps({}, 'foo')).toMatchObject({ value: 'foo' })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'text'\n        },\n        'foo'\n      )\n    ).toMatchObject({ value: 'foo' })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'email'\n        },\n        'foo'\n      )\n    ).toMatchObject({ value: 'foo' })\n\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'checkbox'\n        },\n        true\n      )\n    ).toMatchObject({ checked: true })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'checkbox'\n        },\n        false\n      )\n    ).toBe(null)\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'checkbox',\n          value: '1'\n        },\n        [1]\n      )\n    ).toMatchObject({ checked: true })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'checkbox',\n          value: 1\n        },\n        [1]\n      )\n    ).toMatchObject({ checked: true })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'checkbox',\n          value: 0\n        },\n        [1]\n      )\n    ).toBe(null)\n\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'radio',\n          value: 'foo'\n        },\n        'foo'\n      )\n    ).toMatchObject({ checked: true })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'radio',\n          value: '1'\n        },\n        1\n      )\n    ).toMatchObject({ checked: true })\n    expect(\n      ssrGetDynamicModelProps(\n        {\n          type: 'radio',\n          value: 0\n        },\n        1\n      )\n    ).toBe(null)\n  })","file":"ssrVModelHelpers.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"should work w/ flush:sync","suites":["ssr: watch"],"updatePoint":{"line":6,"column":33},"line":6,"code":"  test('should work w/ flush:sync', async () => {\n    const App = defineComponent(() => {\n      const count = ref(0)\n      let msg = ''\n      watch(\n        count,\n        () => {\n          msg = 'hello world'\n        },\n        { flush: 'sync' }\n      )\n      count.value = 1\n      expect(msg).toBe('hello world')\n      return () => h('div', null, msg)\n    })\n\n    const app = createSSRApp(App)\n    const ctx: SSRContext = {}\n    const html = await renderToString(app, ctx)\n\n    expect(ctx.__watcherHandles!.length).toBe(1)\n\n    expect(html).toMatch('hello world')\n  })","file":"ssrWatch.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"renderToWebStream","suites":[],"updatePoint":{"line":15,"column":23},"line":15,"code":"test('renderToWebStream', async () => {\n  const Async = defineAsyncComponent(() =>\n    Promise.resolve({\n      render: () => h('div', 'async')\n    })\n  )\n  const App = {\n    render: () => [h('div', 'parent'), h(Async)]\n  }\n\n  const stream = renderToWebStream(createApp(App))\n\n  const reader = stream.getReader()\n  const decoder = new TextDecoder()\n\n  let res = ''\n  await reader.read().then(function read({ done, value }): any {\n    if (!done) {\n      res += decoder.decode(value)\n      return reader.read().then(read)\n    }\n  })\n\n  expect(res).toBe(`<!--[--><div>parent</div><div>async</div><!--]-->`)\n})","file":"webStream.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"pipeToWebWritable","suites":[],"updatePoint":{"line":41,"column":23},"line":41,"code":"test('pipeToWebWritable', async () => {\n  const Async = defineAsyncComponent(() =>\n    Promise.resolve({\n      render: () => h('div', 'async')\n    })\n  )\n  const App = {\n    render: () => [h('div', 'parent'), h(Async)]\n  }\n\n  const { readable, writable } = new TransformStream()\n  pipeToWebWritable(createApp(App), {}, writable)\n\n  const reader = readable.getReader()\n  const decoder = new TextDecoder()\n\n  let res = ''\n  await reader.read().then(function read({ done, value }): any {\n    if (!done) {\n      res += decoder.decode(value)\n      return reader.read().then(read)\n    }\n  })\n\n  expect(res).toBe(`<!--[--><div>parent</div><div>async</div><!--]-->`)\n})","file":"webStream.spec.ts","skipped":false,"dir":"packages/server-renderer/__tests__"},{"name":"line near top","suites":["compiler: codeframe"],"updatePoint":{"line":14,"column":21},"line":14,"code":"  test('line near top', () => {\n    const keyStart = source.indexOf(`key=\"one\"`)\n    const keyEnd = keyStart + `key=\"one\"`.length\n    expect(generateCodeFrame(source, keyStart, keyEnd)).toMatchSnapshot()\n  })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"line in middle","suites":["compiler: codeframe"],"updatePoint":{"line":20,"column":22},"line":20,"code":"  test('line in middle', () => {\n    // should cover 5 lines\n    const forStart = source.indexOf(`v-for=`)\n    const forEnd = forStart + `v-for=\"foobar\"`.length\n    expect(generateCodeFrame(source, forStart, forEnd)).toMatchSnapshot()\n  })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"line near bottom","suites":["compiler: codeframe"],"updatePoint":{"line":27,"column":24},"line":27,"code":"  test('line near bottom', () => {\n    const keyStart = source.indexOf(`key=\"two\"`)\n    const keyEnd = keyStart + `key=\"two\"`.length\n    expect(generateCodeFrame(source, keyStart, keyEnd)).toMatchSnapshot()\n  })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"multi-line highlights","suites":["compiler: codeframe"],"updatePoint":{"line":33,"column":29},"line":33,"code":"  test('multi-line highlights', () => {\n    const source = `\n<div attr=\"some\n  multiline\nattr\n\">\n</div>\n    `.trim()\n\n    const attrStart = source.indexOf(`attr=`)\n    const attrEnd = source.indexOf(`\">`) + 1\n    expect(generateCodeFrame(source, attrStart, attrEnd)).toMatchSnapshot()\n  })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"newline sequences - windows","suites":["compiler: codeframe"],"updatePoint":{"line":73,"column":37},"line":73,"code":"    test('newline sequences - windows', () => {\n      const keyStart = windowsNewLineSource.indexOf(startToken)\n      const keyEnd =\n        windowsNewLineSource.indexOf(endToken, keyStart) + endToken.length\n      expect(\n        generateCodeFrame(windowsNewLineSource, keyStart, keyEnd)\n      ).toMatchSnapshot()\n    })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"newline sequences - unix","suites":["compiler: codeframe"],"updatePoint":{"line":82,"column":34},"line":82,"code":"    test('newline sequences - unix', () => {\n      const keyStart = unixNewlineSource.indexOf(startToken)\n      const keyEnd =\n        unixNewlineSource.indexOf(endToken, keyStart) + endToken.length\n      expect(\n        generateCodeFrame(unixNewlineSource, keyStart, keyEnd)\n      ).toMatchSnapshot()\n    })","file":"codeframe.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"ssr: escapeHTML","suites":[],"updatePoint":{"line":3,"column":21},"line":3,"code":"test('ssr: escapeHTML', () => {\n  expect(escapeHtml(`foo`)).toBe(`foo`)\n  expect(escapeHtml(true)).toBe(`true`)\n  expect(escapeHtml(false)).toBe(`false`)\n  expect(escapeHtml(`a && b`)).toBe(`a &amp;&amp; b`)\n  expect(escapeHtml(`\"foo\"`)).toBe(`&quot;foo&quot;`)\n  expect(escapeHtml(`'bar'`)).toBe(`&#39;bar&#39;`)\n  expect(escapeHtml(`<div>`)).toBe(`&lt;div&gt;`)\n})","file":"escapeHtml.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares booleans correctly","suites":["utils/looseEqual"],"updatePoint":{"line":7,"column":35},"line":7,"code":"  test('compares booleans correctly', () => {\n    expect(looseEqual(true, true)).toBe(true)\n    expect(looseEqual(false, false)).toBe(true)\n    expect(looseEqual(true, false)).toBe(false)\n    expect(looseEqual(true, 1)).toBe(false)\n    expect(looseEqual(false, 0)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares strings correctly","suites":["utils/looseEqual"],"updatePoint":{"line":15,"column":34},"line":15,"code":"  test('compares strings correctly', () => {\n    const text = 'Lorem ipsum'\n    const number = 1\n    const bool = true\n\n    expect(looseEqual(text, text)).toBe(true)\n    expect(looseEqual(text, text.slice(0, -1))).toBe(false)\n    expect(looseEqual(String(number), number)).toBe(true)\n    expect(looseEqual(String(bool), bool)).toBe(true)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares numbers correctly","suites":["utils/looseEqual"],"updatePoint":{"line":26,"column":34},"line":26,"code":"  test('compares numbers correctly', () => {\n    const number = 100\n    const decimal = 2.5\n    const multiplier = 1.0000001\n\n    expect(looseEqual(number, number)).toBe(true)\n    expect(looseEqual(number, number - 1)).toBe(false)\n    expect(looseEqual(decimal, decimal)).toBe(true)\n    expect(looseEqual(decimal, decimal * multiplier)).toBe(false)\n    expect(looseEqual(number, number * multiplier)).toBe(false)\n    expect(looseEqual(multiplier, multiplier)).toBe(true)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares dates correctly","suites":["utils/looseEqual"],"updatePoint":{"line":39,"column":32},"line":39,"code":"  test('compares dates correctly', () => {\n    const date1 = new Date(2019, 1, 2, 3, 4, 5, 6)\n    const date2 = new Date(2019, 1, 2, 3, 4, 5, 6)\n    const date3 = new Date(2019, 1, 2, 3, 4, 5, 7)\n    const date4 = new Date(2219, 1, 2, 3, 4, 5, 6)\n\n    // Identical date object references\n    expect(looseEqual(date1, date1)).toBe(true)\n    // Different date references with identical values\n    expect(looseEqual(date1, date2)).toBe(true)\n    // Dates with slightly different time (ms)\n    expect(looseEqual(date1, date3)).toBe(false)\n    // Dates with different year\n    expect(looseEqual(date1, date4)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares symbols correctly","suites":["utils/looseEqual"],"updatePoint":{"line":55,"column":34},"line":55,"code":"  test('compares symbols correctly', () => {\n    const symbol1 = Symbol('a')\n    const symbol2 = Symbol('a')\n    const symbol3 = Symbol('b')\n    const notSymbol = 0\n\n    expect(looseEqual(symbol1, symbol1)).toBe(true)\n    expect(looseEqual(symbol1, symbol2)).toBe(false)\n    expect(looseEqual(symbol1, symbol3)).toBe(false)\n    expect(looseEqual(symbol1, notSymbol)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares files correctly","suites":["utils/looseEqual"],"updatePoint":{"line":67,"column":32},"line":67,"code":"  test('compares files correctly', () => {\n    const date1 = new Date(2019, 1, 2, 3, 4, 5, 6)\n    const date2 = new Date(2019, 1, 2, 3, 4, 5, 7)\n    const file1 = new File([''], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date1.getTime()\n    })\n    const file2 = new File([''], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date1.getTime()\n    })\n    const file3 = new File([''], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date2.getTime()\n    })\n    const file4 = new File([''], 'filename.csv', {\n      type: 'text/csv',\n      lastModified: date1.getTime()\n    })\n    const file5 = new File(['abcdef'], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date1.getTime()\n    })\n    const file6 = new File(['12345'], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date1.getTime()\n    })\n\n    // Identical file object references\n    expect(looseEqual(file1, file1)).toBe(true)\n    // Different file references with identical values\n    expect(looseEqual(file1, file2)).toBe(true)\n    // Files with slightly different dates\n    expect(looseEqual(file1, file3)).toBe(false)\n    // Two different file types\n    expect(looseEqual(file1, file4)).toBe(false)\n    // Two files with same name, modified date, but different content\n    expect(looseEqual(file5, file6)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares arrays correctly","suites":["utils/looseEqual"],"updatePoint":{"line":107,"column":33},"line":107,"code":"  test('compares arrays correctly', () => {\n    const arr1 = [1, 2, 3, 4]\n    const arr2 = [1, 2, 3, '4']\n    const arr3 = [1, 2, 3, 4, 5]\n    const arr4 = [1, 2, 3, 4, { a: 5 }]\n\n    // Identical array references\n    expect(looseEqual(arr1, arr1)).toBe(true)\n    // Different array references with identical values\n    expect(looseEqual(arr1, arr1.slice())).toBe(true)\n    expect(looseEqual(arr4, arr4.slice())).toBe(true)\n    // Array with one value different (loose)\n    expect(looseEqual(arr1, arr2)).toBe(true)\n    // Array with one value different\n    expect(looseEqual(arr3, arr4)).toBe(false)\n    // Arrays with different lengths\n    expect(looseEqual(arr1, arr3)).toBe(false)\n    // Arrays with values in different order\n    expect(looseEqual(arr1, arr1.slice().reverse())).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares RegExp correctly","suites":["utils/looseEqual"],"updatePoint":{"line":128,"column":33},"line":128,"code":"  test('compares RegExp correctly', () => {\n    const rx1 = /^foo$/\n    const rx2 = /^foo$/\n    const rx3 = /^bar$/\n    const rx4 = /^bar$/i\n\n    // Identical regex references\n    expect(looseEqual(rx1, rx1)).toBe(true)\n    // Different regex references with identical values\n    expect(looseEqual(rx1, rx2)).toBe(true)\n    // Different regex\n    expect(looseEqual(rx1, rx3)).toBe(false)\n    // Same regex with different options\n    expect(looseEqual(rx3, rx4)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares objects correctly","suites":["utils/looseEqual"],"updatePoint":{"line":144,"column":34},"line":144,"code":"  test('compares objects correctly', () => {\n    const obj1 = { foo: 'bar' }\n    const obj2 = { foo: 'bar1' }\n    const obj3 = { a: 1, b: 2, c: 3 }\n    const obj4 = { b: 2, c: 3, a: 1 }\n    const obj5 = { ...obj4, z: 999 }\n    const nestedObj1 = { ...obj1, bar: [{ ...obj1 }, { ...obj1 }] }\n    const nestedObj2 = { ...obj1, bar: [{ ...obj1 }, { ...obj2 }] }\n\n    // Identical object references\n    expect(looseEqual(obj1, obj1)).toBe(true)\n    // Two objects with identical keys/values\n    expect(looseEqual(obj1, { ...obj1 })).toBe(true)\n    // Different key values\n    expect(looseEqual(obj1, obj2)).toBe(false)\n    // Keys in different orders\n    expect(looseEqual(obj3, obj4)).toBe(true)\n    // One object has additional key\n    expect(looseEqual(obj4, obj5)).toBe(false)\n    // Identical object references with nested array\n    expect(looseEqual(nestedObj1, nestedObj1)).toBe(true)\n    // Identical object definitions with nested array\n    expect(looseEqual(nestedObj1, { ...nestedObj1 })).toBe(true)\n    // Object definitions with nested array (which has different order)\n    expect(looseEqual(nestedObj1, nestedObj2)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares different types correctly","suites":["utils/looseEqual"],"updatePoint":{"line":171,"column":42},"line":171,"code":"  test('compares different types correctly', () => {\n    const obj1 = {}\n    const obj2 = { a: 1 }\n    const obj3 = { 0: 0, 1: 1, 2: 2 }\n    const arr1: any[] = []\n    const arr2 = [1]\n    const arr3 = [0, 1, 2]\n    const date1 = new Date(2019, 1, 2, 3, 4, 5, 6)\n    const file1 = new File([''], 'filename.txt', {\n      type: 'text/plain',\n      lastModified: date1.getTime()\n    })\n\n    expect(looseEqual(123, '123')).toBe(true)\n    expect(looseEqual(123, new Date(123))).toBe(false)\n    expect(looseEqual(`123`, new Date(123))).toBe(false)\n    expect(looseEqual([1, 2, 3], '1,2,3')).toBe(false)\n    expect(looseEqual(obj1, arr1)).toBe(false)\n    expect(looseEqual(obj2, arr2)).toBe(false)\n    expect(looseEqual(obj1, '[object Object]')).toBe(false)\n    expect(looseEqual(arr1, '[object Array]')).toBe(false)\n    expect(looseEqual(obj1, date1)).toBe(false)\n    expect(looseEqual(obj2, date1)).toBe(false)\n    expect(looseEqual(arr1, date1)).toBe(false)\n    expect(looseEqual(arr2, date1)).toBe(false)\n    expect(looseEqual(obj2, file1)).toBe(false)\n    expect(looseEqual(arr2, file1)).toBe(false)\n    expect(looseEqual(date1, file1)).toBe(false)\n    // Special case where an object's keys are the same as keys (indexes) of an array\n    expect(looseEqual(obj3, arr3)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares null and undefined values correctly","suites":["utils/looseEqual"],"updatePoint":{"line":203,"column":52},"line":203,"code":"  test('compares null and undefined values correctly', () => {\n    expect(looseEqual(null, null)).toBe(true)\n    expect(looseEqual(undefined, undefined)).toBe(true)\n    expect(looseEqual(void 0, undefined)).toBe(true)\n    expect(looseEqual(null, undefined)).toBe(false)\n    expect(looseEqual(null, void 0)).toBe(false)\n    expect(looseEqual(null, '')).toBe(false)\n    expect(looseEqual(null, false)).toBe(false)\n    expect(looseEqual(undefined, false)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"compares sparse arrays correctly","suites":["utils/looseEqual"],"updatePoint":{"line":214,"column":40},"line":214,"code":"  test('compares sparse arrays correctly', () => {\n    // The following arrays all have a length of 3\n    // But the first two are \"sparse\"\n    const arr1 = []\n    arr1[2] = true\n    const arr2 = []\n    arr2[2] = true\n    const arr3 = [false, false, true]\n    const arr4 = [undefined, undefined, true]\n    // This one is also sparse (missing index 1)\n    const arr5 = []\n    arr5[0] = arr5[2] = true\n\n    expect(looseEqual(arr1, arr2)).toBe(true)\n    expect(looseEqual(arr2, arr1)).toBe(true)\n    expect(looseEqual(arr1, arr3)).toBe(false)\n    expect(looseEqual(arr3, arr1)).toBe(false)\n    expect(looseEqual(arr1, arr4)).toBe(true)\n    expect(looseEqual(arr4, arr1)).toBe(true)\n    expect(looseEqual(arr1, arr5)).toBe(false)\n    expect(looseEqual(arr5, arr1)).toBe(false)\n  })","file":"looseEqual.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"handles string correctly","suites":["normalizeClass"],"updatePoint":{"line":4,"column":32},"line":4,"code":"  test('handles string correctly', () => {\n    expect(normalizeClass('foo')).toEqual('foo')\n  })","file":"normalizeProp.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"handles array correctly","suites":["normalizeClass"],"updatePoint":{"line":8,"column":31},"line":8,"code":"  test('handles array correctly', () => {\n    expect(normalizeClass(['foo', undefined, true, false, 'bar'])).toEqual(\n      'foo bar'\n    )\n  })","file":"normalizeProp.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"handles object correctly","suites":["normalizeClass"],"updatePoint":{"line":14,"column":32},"line":14,"code":"  test('handles object correctly', () => {\n    expect(normalizeClass({ foo: true, bar: false, baz: true })).toEqual(\n      'foo baz'\n    )\n  })","file":"normalizeProp.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"parse multi-line inline style","suites":["normalizeClass"],"updatePoint":{"line":21,"column":37},"line":21,"code":"  test('parse multi-line inline style', () => {\n    expect(\n      parseStringStyle(`border: 1px solid transparent;\n    background: linear-gradient(white, white) padding-box,\n      repeating-linear-gradient(\n        -45deg,\n        #ccc 0,\n        #ccc 0.5em,\n        white 0,\n        white 0.75em\n      );`)\n    ).toMatchInlineSnapshot(`\n      {\n        \"background\": \"linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(\n              -45deg,\n              #ccc 0,\n              #ccc 0.5em,\n              white 0,\n              white 0.75em\n            )\",\n        \"border\": \"1px solid transparent\",\n      }\n    `)\n  })","file":"normalizeProp.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"nullish values","suites":["toDisplayString"],"updatePoint":{"line":8,"column":22},"line":8,"code":"  test('nullish values', () => {\n    expect(toDisplayString(null)).toBe('')\n    expect(toDisplayString(undefined)).toBe('')\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"primitive values","suites":["toDisplayString"],"updatePoint":{"line":13,"column":24},"line":13,"code":"  test('primitive values', () => {\n    expect(toDisplayString(1)).toBe('1')\n    expect(toDisplayString(true)).toBe('true')\n    expect(toDisplayString(false)).toBe('false')\n    expect(toDisplayString('hello')).toBe('hello')\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"Object and Arrays","suites":["toDisplayString"],"updatePoint":{"line":20,"column":25},"line":20,"code":"  test('Object and Arrays', () => {\n    const obj = { foo: 123 }\n    expect(toDisplayString(obj)).toBe(JSON.stringify(obj, null, 2))\n    const arr = [obj]\n    expect(toDisplayString(arr)).toBe(JSON.stringify(arr, null, 2))\n\n    const objWithToStringOverride = {\n      foo: 555,\n      toString() {\n        return 'override'\n      }\n    }\n    expect(toDisplayString(objWithToStringOverride)).toBe('override')\n\n    const objWithNonInvokableToString = {\n      foo: 555,\n      toString: null\n    }\n    expect(toDisplayString(objWithNonInvokableToString)).toBe(\n      `{\n  \"foo\": 555,\n  \"toString\": null\n}`\n    )\n\n    // object created from null does not have .toString in its prototype\n    const nullObjectWithoutToString = Object.create(null)\n    nullObjectWithoutToString.bar = 1\n    expect(toDisplayString(nullObjectWithoutToString)).toBe(\n      `{\n  \"bar\": 1\n}`\n    )\n\n    // array toString override is ignored\n    const arrWithToStringOverride = [1, 2, 3]\n    arrWithToStringOverride.toString = () =>\n      'override for array is not supported'\n    expect(toDisplayString(arrWithToStringOverride)).toBe(\n      `[\n  1,\n  2,\n  3\n]`\n    )\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"refs","suites":["toDisplayString"],"updatePoint":{"line":67,"column":12},"line":67,"code":"  test('refs', () => {\n    const n = ref(1)\n    const np = computed(() => n.value + 1)\n    expect(\n      toDisplayString({\n        n,\n        np\n      })\n    ).toBe(JSON.stringify({ n: 1, np: 2 }, null, 2))\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"objects with custom toString","suites":["toDisplayString"],"updatePoint":{"line":78,"column":36},"line":78,"code":"  test('objects with custom toString', () => {\n    class TestClass {\n      toString() {\n        return 'foo'\n      }\n    }\n    const instance = new TestClass()\n    expect(toDisplayString(instance)).toBe('foo')\n    const obj = { toString: () => 'bar' }\n    expect(toDisplayString(obj)).toBe('bar')\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"native objects","suites":["toDisplayString"],"updatePoint":{"line":90,"column":22},"line":90,"code":"  test('native objects', () => {\n    const div = document.createElement('div')\n    expect(toDisplayString(div)).toMatch('[object HTMLDivElement]')\n    expect(toDisplayString({ div })).toMatchInlineSnapshot(`\n      \"{\n        \\\\\"div\\\\\": \\\\\"[object HTMLDivElement]\\\\\"\n      }\"\n    `)\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"Map and Set","suites":["toDisplayString"],"updatePoint":{"line":100,"column":19},"line":100,"code":"  test('Map and Set', () => {\n    const m = new Map<any, any>([\n      [1, 'foo'],\n      [{ baz: 1 }, { foo: 'bar', qux: 2 }]\n    ])\n    const s = new Set<any>([1, { foo: 'bar' }, m])\n\n    expect(toDisplayString(m)).toMatchInlineSnapshot(`\n      \"{\n        \\\\\"Map(2)\\\\\": {\n          \\\\\"1 =>\\\\\": \\\\\"foo\\\\\",\n          \\\\\"[object Object] =>\\\\\": {\n            \\\\\"foo\\\\\": \\\\\"bar\\\\\",\n            \\\\\"qux\\\\\": 2\n          }\n        }\n      }\"\n    `)\n    expect(toDisplayString(s)).toMatchInlineSnapshot(`\n      \"{\n        \\\\\"Set(3)\\\\\": [\n          1,\n          {\n            \\\\\"foo\\\\\": \\\\\"bar\\\\\"\n          },\n          {\n            \\\\\"Map(2)\\\\\": {\n              \\\\\"1 =>\\\\\": \\\\\"foo\\\\\",\n              \\\\\"[object Object] =>\\\\\": {\n                \\\\\"foo\\\\\": \\\\\"bar\\\\\",\n                \\\\\"qux\\\\\": 2\n              }\n            }\n          }\n        ]\n      }\"\n    `)\n\n    expect(\n      toDisplayString({\n        m,\n        s\n      })\n    ).toMatchInlineSnapshot(`\n      \"{\n        \\\\\"m\\\\\": {\n          \\\\\"Map(2)\\\\\": {\n            \\\\\"1 =>\\\\\": \\\\\"foo\\\\\",\n            \\\\\"[object Object] =>\\\\\": {\n              \\\\\"foo\\\\\": \\\\\"bar\\\\\",\n              \\\\\"qux\\\\\": 2\n            }\n          }\n        },\n        \\\\\"s\\\\\": {\n          \\\\\"Set(3)\\\\\": [\n            1,\n            {\n              \\\\\"foo\\\\\": \\\\\"bar\\\\\"\n            },\n            {\n              \\\\\"Map(2)\\\\\": {\n                \\\\\"1 =>\\\\\": \\\\\"foo\\\\\",\n                \\\\\"[object Object] =>\\\\\": {\n                  \\\\\"foo\\\\\": \\\\\"bar\\\\\",\n                  \\\\\"qux\\\\\": 2\n                }\n              }\n            }\n          ]\n        }\n      }\"\n    `)\n  })","file":"toDisplayString.spec.ts","skipped":false,"dir":"packages/shared/__tests__"},{"name":"COMPILER_IS_ON_ELEMENT","suites":[],"updatePoint":{"line":23,"column":28},"line":23,"code":"test('COMPILER_IS_ON_ELEMENT', () => {\n  const MyButton = {\n    template: `<div><slot/></div>`\n  }\n\n  const vm = new Vue({\n    template: `<button is=\"my-button\">text</button>`,\n    components: {\n      MyButton\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.outerHTML).toBe(`<div>text</div>`)\n  expect(CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_IS_ON_ELEMENT (dynamic)","suites":[],"updatePoint":{"line":40,"column":38},"line":40,"code":"test('COMPILER_IS_ON_ELEMENT (dynamic)', () => {\n  const MyButton = {\n    template: `<div><slot/></div>`\n  }\n\n  const vm = new Vue({\n    template: `<button :is=\"'MyButton'\">text</button>`,\n    components: {\n      MyButton\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.outerHTML).toBe(`<div>text</div>`)\n  expect(CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_V_BIND_SYNC","suites":[],"updatePoint":{"line":57,"column":26},"line":57,"code":"test('COMPILER_V_BIND_SYNC', async () => {\n  const MyButton = {\n    props: ['foo'],\n    template: `<button @click=\"$emit('update:foo', 1)\">{{ foo }}</button>`\n  }\n\n  const vm = new Vue({\n    data() {\n      return {\n        foo: 0\n      }\n    },\n    template: `<my-button :foo.sync=\"foo\" />`,\n    components: {\n      MyButton\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLButtonElement)\n  expect(vm.$el.textContent).toBe(`0`)\n\n  triggerEvent(vm.$el as Element, 'click')\n  await nextTick()\n  expect(vm.$el.textContent).toBe(`1`)\n\n  expect(CompilerDeprecationTypes.COMPILER_V_BIND_SYNC).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_V_BIND_PROP","suites":[],"updatePoint":{"line":85,"column":26},"line":85,"code":"test('COMPILER_V_BIND_PROP', () => {\n  const vm = new Vue({\n    template: `<div :id.prop=\"'foo'\"/>`\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.id).toBe('foo')\n  expect(CompilerDeprecationTypes.COMPILER_V_BIND_PROP).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_V_BIND_OBJECT_ORDER","suites":[],"updatePoint":{"line":95,"column":34},"line":95,"code":"test('COMPILER_V_BIND_OBJECT_ORDER', () => {\n  const vm = new Vue({\n    template: `<div id=\"foo\" v-bind=\"{ id: 'bar', class: 'baz' }\" />`\n  }).$mount()\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.id).toBe('foo')\n  expect(vm.$el.className).toBe('baz')\n  expect(\n    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER\n  ).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_V_ON_NATIVE","suites":[],"updatePoint":{"line":107,"column":26},"line":107,"code":"test('COMPILER_V_ON_NATIVE', () => {\n  const spy = vi.fn()\n  const vm = new Vue({\n    template: `<child @click=\"spy\" @click.native=\"spy\" />`,\n    components: {\n      child: {\n        template: `<button />`\n      }\n    },\n    methods: {\n      spy\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLButtonElement)\n  triggerEvent(vm.$el as HTMLButtonElement, 'click')\n  expect(spy).toHaveBeenCalledTimes(1)\n  expect(CompilerDeprecationTypes.COMPILER_V_ON_NATIVE).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_V_IF_V_FOR_PRECEDENCE","suites":[],"updatePoint":{"line":127,"column":36},"line":127,"code":"test('COMPILER_V_IF_V_FOR_PRECEDENCE', () => {\n  new Vue({ template: `<div v-if=\"true\" v-for=\"i in 1\"/>` }).$mount()\n  expect(\n    CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE\n  ).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_NATIVE_TEMPLATE","suites":[],"updatePoint":{"line":134,"column":30},"line":134,"code":"test('COMPILER_NATIVE_TEMPLATE', () => {\n  const vm = new Vue({\n    template: `<div><template><div/></template></div>`\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.innerHTML).toBe(`<div></div>`)\n  expect(CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"COMPILER_INLINE_TEMPLATE","suites":[],"updatePoint":{"line":144,"column":30},"line":144,"code":"test('COMPILER_INLINE_TEMPLATE', () => {\n  const vm = new Vue({\n    template: `<foo inline-template><div>{{ n }}</div></foo>`,\n    components: {\n      foo: {\n        data() {\n          return { n: 123 }\n        }\n      }\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el?.outerHTML).toBe(`<div>123</div>`)\n  expect(CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE).toHaveBeenWarned()\n})","file":"compiler.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"resolve/reject","suites":["COMPONENT_ASYNC"],"updatePoint":{"line":24,"column":22},"line":24,"code":"  test('resolve/reject', async () => {\n    let resolve: any\n    const comp = (r: any) => {\n      resolve = r\n    }\n    const vm = new Vue({\n      template: `<div><comp/></div>`,\n      components: { comp }\n    }).$mount()\n\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.innerHTML).toBe(`<!---->`)\n\n    resolve({ template: 'foo' })\n    await timeout(0)\n    expect(vm.$el.innerHTML).toBe(`foo`)\n\n    expect(\n      (deprecationData[DeprecationTypes.COMPONENT_ASYNC].message as Function)(\n        comp\n      )\n    ).toHaveBeenWarned()\n  })","file":"componentAsync.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"Promise","suites":["COMPONENT_ASYNC"],"updatePoint":{"line":48,"column":15},"line":48,"code":"  test('Promise', async () => {\n    const comp = () => Promise.resolve({ template: 'foo' })\n    const vm = new Vue({\n      template: `<div><comp/></div>`,\n      components: { comp }\n    }).$mount()\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.innerHTML).toBe(`<!---->`)\n    await timeout(0)\n    expect(vm.$el.innerHTML).toBe(`foo`)\n\n    expect(\n      (deprecationData[DeprecationTypes.COMPONENT_ASYNC].message as Function)(\n        comp\n      )\n    ).toHaveBeenWarned()\n  })","file":"componentAsync.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"object syntax","suites":["COMPONENT_ASYNC"],"updatePoint":{"line":66,"column":21},"line":66,"code":"  test('object syntax', async () => {\n    const comp = () => ({\n      component: Promise.resolve({ template: 'foo' })\n    })\n\n    const vm = new Vue({\n      template: `<div><comp/></div>`,\n      components: { comp }\n    }).$mount()\n\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.innerHTML).toBe(`<!---->`)\n    await timeout(0)\n    expect(vm.$el.innerHTML).toBe(`foo`)\n\n    expect(\n      (deprecationData[DeprecationTypes.COMPONENT_ASYNC].message as Function)(\n        comp\n      )\n    ).toHaveBeenWarned()\n  })","file":"componentAsync.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"basic usage","suites":["COMPONENT_FUNCTIONAL"],"updatePoint":{"line":22,"column":19},"line":22,"code":"  test('basic usage', async () => {\n    const func = {\n      name: 'Func',\n      functional: true,\n      props: {\n        x: String\n      },\n      inject: ['foo'],\n      render: (h: any, { data, props, injections, slots }: any) => {\n        return h('div', { id: props.x, class: data.class }, [\n          h('div', { class: 'inject' }, injections.foo),\n          h('div', { class: 'slot' }, slots().default)\n        ])\n      }\n    }\n\n    const vm = new Vue({\n      provide() {\n        return {\n          foo: 123\n        }\n      },\n      components: {\n        func\n      },\n      template: `<func class=\"foo\" x=\"foo\">hello</func>`\n    }).$mount()\n\n    expect(vm.$el.id).toBe('foo')\n    expect(vm.$el.className).toBe('foo')\n    expect(vm.$el.querySelector('.inject').textContent).toBe('123')\n    expect(vm.$el.querySelector('.slot').textContent).toBe('hello')\n    expect(vm.$el.outerHTML).toMatchInlineSnapshot(\n      '\"<div id=\\\\\"foo\\\\\" class=\\\\\"foo\\\\\"><div class=\\\\\"inject\\\\\">123</div><div class=\\\\\"slot\\\\\">hello</div></div>\"'\n    )\n\n    expect(\n      (\n        deprecationData[DeprecationTypes.COMPONENT_FUNCTIONAL]\n          .message as Function\n      )(func)\n    ).toHaveBeenWarned()\n  })","file":"componentFunctional.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"copies compatConfig option","suites":["COMPONENT_FUNCTIONAL"],"updatePoint":{"line":66,"column":34},"line":66,"code":"  test('copies compatConfig option', () => {\n    const func = {\n      name: 'Func',\n      functional: true,\n      compatConfig: {\n        ATTR_FALSE_VALUE: 'suppress-warning' as const\n      },\n      render: (h: any) => {\n        // should not render required: false due to compatConfig\n        return h('div', { 'data-some-attr': false })\n      }\n    }\n\n    const vm = new Vue({\n      components: { func },\n      template: `<func class=\"foo\" x=\"foo\">hello</func>`\n    }).$mount()\n\n    expect(vm.$el.outerHTML).toMatchInlineSnapshot(`\"<div></div>\"`)\n    expect(\n      (\n        deprecationData[DeprecationTypes.COMPONENT_FUNCTIONAL]\n          .message as Function\n      )(func)\n    ).toHaveBeenWarned()\n    expect(\n      (deprecationData[DeprecationTypes.ATTR_FALSE_VALUE].message as Function)(\n        func\n      )\n    ).not.toHaveBeenWarned()\n  })","file":"componentFunctional.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"basic usage","suites":["COMPONENT_V_MODEL"],"updatePoint":{"line":66,"column":19},"line":66,"code":"  test('basic usage', async () => {\n    await runTest({\n      name: 'CustomInput',\n      props: ['value'],\n      template: `<input :value=\"value\" @input=\"$emit('input', $event.target.value)\">`\n    })\n  })","file":"componentVModel.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"with model option","suites":["COMPONENT_V_MODEL"],"updatePoint":{"line":74,"column":25},"line":74,"code":"  test('with model option', async () => {\n    await runTest({\n      name: 'CustomInput',\n      props: ['input'],\n      model: {\n        prop: 'input',\n        event: 'update'\n      },\n      template: `<input :value=\"input\" @input=\"$emit('update', $event.target.value)\">`\n    })\n  })","file":"componentVModel.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"global registration","suites":["FILTERS"],"updatePoint":{"line":36,"column":25},"line":36,"code":"  it('global registration', () => {\n    toggleDeprecationWarning(true)\n    Vue.filter('globalUpper', upper)\n    expect(Vue.filter('globalUpper')).toBe(upper)\n    const vm = new Vue({\n      template: '<div>{{ msg | globalUpper }}</div>',\n      data: () => ({\n        msg: 'hi'\n      })\n    }).$mount()\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.textContent).toBe('HI')\n    expect(deprecationData[DeprecationTypes.FILTERS].message).toHaveBeenWarned()\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n    Vue.filter('globalUpper', undefined)\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"basic usage","suites":["FILTERS"],"updatePoint":{"line":53,"column":17},"line":53,"code":"  it('basic usage', () => {\n    const vm = new Vue({\n      template: '<div>{{ msg | upper }}</div>',\n      data: () => ({\n        msg: 'hi'\n      }),\n      filters: {\n        upper\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('HI')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"chained usage","suites":["FILTERS"],"updatePoint":{"line":67,"column":19},"line":67,"code":"  it('chained usage', () => {\n    const vm = new Vue({\n      template: '<div>{{ msg | upper | reverse }}</div>',\n      data: () => ({\n        msg: 'hi'\n      }),\n      filters: {\n        upper,\n        reverse\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('IH')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"in v-bind","suites":["FILTERS"],"updatePoint":{"line":82,"column":15},"line":82,"code":"  it('in v-bind', () => {\n    const vm = new Vue({\n      template: `\n        <div\n          v-bind:id=\"id | upper | reverse\"\n          :class=\"cls | reverse\"\n          :ref=\"ref | lower\">\n        </div>\n      `,\n      filters: {\n        upper,\n        reverse,\n        lower\n      },\n      data: () => ({\n        id: 'abc',\n        cls: 'foo',\n        ref: 'BAR'\n      })\n    }).$mount()\n    expect(vm.$el.id).toBe('CBA')\n    expect(vm.$el.className).toBe('oof')\n    expect(vm.$refs.bar).toBe(vm.$el)\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle regex with pipe","suites":["FILTERS"],"updatePoint":{"line":108,"column":28},"line":108,"code":"  it('handle regex with pipe', () => {\n    const vm = new Vue({\n      template: `<test ref=\"test\" :pattern=\"/a|b\\\\// | identity\"></test>`,\n      filters: { identity: (v: any) => v },\n      components: {\n        test: {\n          props: ['pattern'],\n          template: '<div></div>'\n        }\n      }\n    }).$mount() as any\n    expect(vm.$refs.test.pattern instanceof RegExp).toBe(true)\n    expect(vm.$refs.test.pattern.toString()).toBe('/a|b\\\\//')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division","suites":["FILTERS"],"updatePoint":{"line":124,"column":21},"line":124,"code":"  it('handle division', () => {\n    const vm = new Vue({\n      data: () => ({ a: 2 }),\n      template: `<div>{{ 1/a / 4 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(1 / 4))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division with parenthesis","suites":["FILTERS"],"updatePoint":{"line":134,"column":38},"line":134,"code":"  it('handle division with parenthesis', () => {\n    const vm = new Vue({\n      data: () => ({ a: 20 }),\n      template: `<div>{{ (a*2) / 5 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(16))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division with dot","suites":["FILTERS"],"updatePoint":{"line":144,"column":30},"line":144,"code":"  it('handle division with dot', () => {\n    const vm = new Vue({\n      template: `<div>{{ 20. / 5 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(8))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division with array values","suites":["FILTERS"],"updatePoint":{"line":153,"column":39},"line":153,"code":"  it('handle division with array values', () => {\n    const vm = new Vue({\n      data: () => ({ a: [20] }),\n      template: `<div>{{ a[0] / 5 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(8))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division with hash values","suites":["FILTERS"],"updatePoint":{"line":163,"column":38},"line":163,"code":"  it('handle division with hash values', () => {\n    const vm = new Vue({\n      data: () => ({ a: { n: 20 } }),\n      template: `<div>{{ a['n'] / 5 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(8))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"handle division with variable_","suites":["FILTERS"],"updatePoint":{"line":173,"column":36},"line":173,"code":"  it('handle division with variable_', () => {\n    const vm = new Vue({\n      data: () => ({ a_: 8 }),\n      template: `<div>{{ a_ / 2 | double }}</div>`,\n      filters: { double }\n    }).$mount()\n    expect(vm.$el.textContent).toBe(String(8))\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"arguments","suites":["FILTERS"],"updatePoint":{"line":183,"column":15},"line":183,"code":"  it('arguments', () => {\n    const vm = new Vue({\n      template: `<div>{{ msg | add(a, 3) }}</div>`,\n      data: () => ({\n        msg: 1,\n        a: 2\n      }),\n      filters: {\n        add: (v: number, arg1: number, arg2: number) => v + arg1 + arg2\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('6')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"quotes","suites":["FILTERS"],"updatePoint":{"line":198,"column":12},"line":198,"code":"  it('quotes', () => {\n    const vm = new Vue({\n      template: `<div>{{ msg + \"b | c\" + 'd' | upper }}</div>`,\n      data: () => ({\n        msg: 'a'\n      }),\n      filters: {\n        upper\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('AB | CD')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"double pipe","suites":["FILTERS"],"updatePoint":{"line":212,"column":17},"line":212,"code":"  it('double pipe', () => {\n    const vm = new Vue({\n      template: `<div>{{ b || msg | upper }}</div>`,\n      data: () => ({\n        b: false,\n        msg: 'a'\n      }),\n      filters: {\n        upper\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('A')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"object literal","suites":["FILTERS"],"updatePoint":{"line":227,"column":20},"line":227,"code":"  it('object literal', () => {\n    const vm = new Vue({\n      template: `<div>{{ { a: 123 } | pick('a') }}</div>`,\n      filters: {\n        pick: (v: any, key: string) => v[key]\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('123')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"array literal","suites":["FILTERS"],"updatePoint":{"line":238,"column":19},"line":238,"code":"  it('array literal', () => {\n    const vm = new Vue({\n      template: `<div>{{ [1, 2, 3] | reverse }}</div>`,\n      filters: {\n        reverse: (arr: any[]) => arr.reverse().join(',')\n      }\n    }).$mount()\n    expect(vm.$el.textContent).toBe('3,2,1')\n    expect(CompilerDeprecationTypes.COMPILER_FILTERS).toHaveBeenWarned()\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"bigint support","suites":["FILTERS"],"updatePoint":{"line":249,"column":20},"line":249,"code":"  it('bigint support', () => {\n    const vm = new Vue({\n      template: `<div>{{ BigInt(BigInt(10000000)) + BigInt(2000000000n) * 3000000n }}</div>`\n    }).$mount()\n    expect(vm.$el.textContent).toBe('6000000010000000')\n  })","file":"filters.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"new Vue() with el","suites":["GLOBAL_MOUNT"],"updatePoint":{"line":24,"column":25},"line":24,"code":"  test('new Vue() with el', () => {\n    toggleDeprecationWarning(true)\n\n    const el = document.createElement('div')\n    el.innerHTML = `{{ msg }}`\n    new Vue({\n      el,\n      compatConfig: { GLOBAL_MOUNT: true },\n      data() {\n        return {\n          msg: 'hello'\n        }\n      }\n    })\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_MOUNT].message\n    ).toHaveBeenWarned()\n    expect(el.innerHTML).toBe('hello')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"new Vue() + $mount","suites":["GLOBAL_MOUNT"],"updatePoint":{"line":44,"column":26},"line":44,"code":"  test('new Vue() + $mount', () => {\n    const el = document.createElement('div')\n    el.innerHTML = `{{ msg }}`\n    new Vue({\n      data() {\n        return {\n          msg: 'hello'\n        }\n      }\n    }).$mount(el)\n    expect(el.innerHTML).toBe('hello')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should warn","suites":["GLOBAL_MOUNT_CONTAINER"],"updatePoint":{"line":59,"column":19},"line":59,"code":"  test('should warn', () => {\n    toggleDeprecationWarning(true)\n\n    const el = document.createElement('div')\n    el.innerHTML = `test`\n    el.setAttribute('v-bind:id', 'foo')\n    new Vue().$mount(el)\n    // warning only\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_MOUNT].message\n    ).toHaveBeenWarned()\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_MOUNT_CONTAINER].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should correctly merge options","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":78,"column":36},"line":78,"code":"  it('should correctly merge options', () => {\n    toggleDeprecationWarning(true)\n\n    const Test = Vue.extend({\n      name: 'test',\n      a: 1,\n      b: 2\n    })\n    expect(Test.options.a).toBe(1)\n    expect(Test.options.b).toBe(2)\n    expect(Test.super).toBe(Vue)\n    const t = new Test({\n      a: 2\n    })\n    expect(t.$options.a).toBe(2)\n    expect(t.$options.b).toBe(2)\n    // inheritance\n    const Test2 = Test.extend({\n      a: 2\n    })\n    expect(Test2.options.a).toBe(2)\n    expect(Test2.options.b).toBe(2)\n    const t2 = new Test2({\n      a: 3\n    })\n    expect(t2.$options.a).toBe(3)\n    expect(t2.$options.b).toBe(2)\n\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_MOUNT].message\n    ).toHaveBeenWarned()\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_EXTEND].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should work when used as components","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":114,"column":41},"line":114,"code":"  it('should work when used as components', () => {\n    const foo = Vue.extend({\n      template: '<span>foo</span>'\n    })\n    const bar = Vue.extend({\n      template: '<span>bar</span>'\n    })\n    const vm = new Vue({\n      template: '<div><foo></foo><bar></bar></div>',\n      components: { foo, bar }\n    }).$mount()\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.innerHTML).toBe('<span>foo</span><span>bar</span>')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should merge lifecycle hooks","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":129,"column":34},"line":129,"code":"  it('should merge lifecycle hooks', () => {\n    const calls: number[] = []\n    const A = Vue.extend({\n      created() {\n        calls.push(1)\n      }\n    })\n    const B = A.extend({\n      created() {\n        calls.push(2)\n      }\n    })\n    new B({\n      created() {\n        calls.push(3)\n      }\n    })\n    expect(calls).toEqual([1, 2, 3])\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should not merge nested mixins created with Vue.extend","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":149,"column":60},"line":149,"code":"  it('should not merge nested mixins created with Vue.extend', () => {\n    const a = vi.fn()\n    const b = vi.fn()\n    const c = vi.fn()\n    const d = vi.fn()\n    const A = Vue.extend({\n      created: a\n    })\n    const B = Vue.extend({\n      mixins: [A],\n      created: b\n    })\n    const C = Vue.extend({\n      extends: B,\n      created: c\n    })\n    const D = Vue.extend({\n      mixins: [C],\n      created: d,\n      render() {\n        return null\n      }\n    })\n    new D().$mount()\n    expect(a.mock.calls.length).toStrictEqual(1)\n    expect(b.mock.calls.length).toStrictEqual(1)\n    expect(c.mock.calls.length).toStrictEqual(1)\n    expect(d.mock.calls.length).toStrictEqual(1)\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should merge methods","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":179,"column":26},"line":179,"code":"  it('should merge methods', () => {\n    const A = Vue.extend({\n      methods: {\n        a() {\n          return this.n\n        }\n      }\n    })\n    const B = A.extend({\n      methods: {\n        b() {\n          return this.n + 1\n        }\n      }\n    })\n    const b = new B({\n      data: () => ({ n: 0 }),\n      methods: {\n        c() {\n          return this.n + 2\n        }\n      }\n    }) as any\n    expect(b.a()).toBe(0)\n    expect(b.b()).toBe(1)\n    expect(b.c()).toBe(2)\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should merge assets","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":207,"column":25},"line":207,"code":"  it('should merge assets', () => {\n    const A = Vue.extend({\n      components: {\n        aa: {\n          template: '<div>A</div>'\n        }\n      }\n    })\n    const B = A.extend({\n      components: {\n        bb: {\n          template: '<div>B</div>'\n        }\n      }\n    })\n    const b = new B({\n      template: '<div><aa></aa><bb></bb></div>'\n    }).$mount()\n    expect(b.$el).toBeInstanceOf(HTMLDivElement)\n    expect(b.$el.innerHTML).toBe('<div>A</div><div>B</div>')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"caching","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":229,"column":13},"line":229,"code":"  it('caching', () => {\n    const options = {\n      template: '<div></div>'\n    }\n    const A = Vue.extend(options)\n    const B = Vue.extend(options)\n    expect(A).toBe(B)\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"extended options should use different identify from parent","suites":["GLOBAL_EXTEND"],"updatePoint":{"line":238,"column":64},"line":238,"code":"  it('extended options should use different identify from parent', () => {\n    const A = Vue.extend({ computed: {} })\n    const B = A.extend()\n    B.options.computed.b = () => 'foo'\n    expect(B.options.computed).not.toBe(A.options.computed)\n    expect(A.options.computed.b).toBeUndefined()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"plain properties","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":248,"column":24},"line":248,"code":"  test('plain properties', () => {\n    toggleDeprecationWarning(true)\n    Vue.prototype.$test = 1\n    const vm = new Vue() as any\n    expect(vm.$test).toBe(1)\n    delete Vue.prototype.$test\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_MOUNT].message\n    ).toHaveBeenWarned()\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_PROTOTYPE].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"method this context","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":262,"column":27},"line":262,"code":"  test('method this context', () => {\n    Vue.prototype.$test = function () {\n      return this.msg\n    }\n    const vm = new Vue({\n      data() {\n        return { msg: 'method' }\n      }\n    }) as any\n    expect(vm.$test()).toBe('method')\n    delete Vue.prototype.$test\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defined properties","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":275,"column":26},"line":275,"code":"  test('defined properties', () => {\n    Object.defineProperty(Vue.prototype, '$test', {\n      configurable: true,\n      get() {\n        return this.msg\n      }\n    })\n    const vm = new Vue({\n      data() {\n        return { msg: 'getter' }\n      }\n    }) as any\n    expect(vm.$test).toBe('getter')\n    delete Vue.prototype.$test\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"functions keeps additional properties","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":291,"column":45},"line":291,"code":"  test('functions keeps additional properties', () => {\n    function test(this: any) {\n      return this.msg\n    }\n    test.additionalFn = () => {\n      return 'additional fn'\n    }\n\n    Vue.prototype.$test = test\n    const vm = new Vue({\n      data() {\n        return {\n          msg: 'test'\n        }\n      }\n    }) as any\n    expect(typeof vm.$test).toBe('function')\n    expect(typeof vm.$test.additionalFn).toBe('function')\n    expect(vm.$test.additionalFn()).toBe('additional fn')\n    delete Vue.prototype.$test\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"extended prototype","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":313,"column":26},"line":313,"code":"  test('extended prototype', async () => {\n    const Foo = Vue.extend()\n    Foo.prototype.$test = 1\n    const vm = new Foo() as any\n    expect(vm.$test).toBe(1)\n    const plain = new Vue() as any\n    expect(plain.$test).toBeUndefined()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should affect apps created via createApp()","suites":["GLOBAL_PROTOTYPE"],"updatePoint":{"line":322,"column":50},"line":322,"code":"  test('should affect apps created via createApp()', () => {\n    Vue.prototype.$test = 1\n    const vm = createApp({\n      template: 'foo'\n    }).mount(document.createElement('div')) as any\n    expect(vm.$test).toBe(1)\n    delete Vue.prototype.$test\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"set","suites":["GLOBAL_SET/DELETE"],"updatePoint":{"line":333,"column":11},"line":333,"code":"  test('set', () => {\n    toggleDeprecationWarning(true)\n    const obj: any = {}\n    Vue.set(obj, 'foo', 1)\n    expect(obj.foo).toBe(1)\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_SET].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"delete","suites":["GLOBAL_SET/DELETE"],"updatePoint":{"line":343,"column":14},"line":343,"code":"  test('delete', () => {\n    toggleDeprecationWarning(true)\n    const obj: any = { foo: 1 }\n    Vue.delete(obj, 'foo')\n    expect('foo' in obj).toBe(false)\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_DELETE].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should work","suites":["GLOBAL_OBSERVABLE"],"updatePoint":{"line":355,"column":19},"line":355,"code":"  test('should work', () => {\n    toggleDeprecationWarning(true)\n    const obj = Vue.observable({})\n    expect(isReactive(obj)).toBe(true)\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_OBSERVABLE].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defineReactive","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":366,"column":22},"line":366,"code":"  test('defineReactive', () => {\n    toggleDeprecationWarning(true)\n    const obj: any = {}\n    // @ts-ignore\n    Vue.util.defineReactive(obj, 'test', 1)\n\n    let n\n    effect(() => {\n      n = obj.test\n    })\n    expect(n).toBe(1)\n    obj.test++\n    expect(n).toBe(2)\n\n    expect(\n      deprecationData[DeprecationTypes.GLOBAL_PRIVATE_UTIL].message\n    ).toHaveBeenWarned()\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defineReactive on instance","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":385,"column":34},"line":385,"code":"  test('defineReactive on instance', async () => {\n    const vm = new Vue({\n      beforeCreate() {\n        // @ts-ignore\n        Vue.util.defineReactive(this, 'foo', 1)\n      },\n      template: `<div>{{ foo }}</div>`\n    }).$mount() as any\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.textContent).toBe('1')\n    vm.foo = 2\n    await nextTick()\n    expect(vm.$el.textContent).toBe('2')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defineReactive on instance with key that starts with $","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":400,"column":62},"line":400,"code":"  test('defineReactive on instance with key that starts with $', async () => {\n    const vm = new Vue({\n      beforeCreate() {\n        // @ts-ignore\n        Vue.util.defineReactive(this, '$foo', 1)\n      },\n      template: `<div>{{ $foo }}</div>`\n    }).$mount() as any\n    expect(vm.$el.textContent).toBe('1')\n    vm.$foo = 2\n    await nextTick()\n    expect(vm.$el.textContent).toBe('2')\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defineReactive with object value","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":414,"column":40},"line":414,"code":"  test('defineReactive with object value', () => {\n    const obj: any = {}\n    const val = { a: 1 }\n    // @ts-ignore\n    Vue.util.defineReactive(obj, 'foo', val)\n\n    let n\n    effect(() => {\n      n = obj.foo.a\n    })\n    expect(n).toBe(1)\n    // mutating original\n    val.a++\n    expect(n).toBe(2)\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"defineReactive with array value","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":430,"column":39},"line":430,"code":"  test('defineReactive with array value', () => {\n    const obj: any = {}\n    const val = [1]\n    // @ts-ignore\n    Vue.util.defineReactive(obj, 'foo', val)\n\n    let n\n    effect(() => {\n      n = obj.foo.length\n    })\n    expect(n).toBe(1)\n    // mutating original\n    val.push(2)\n    expect(n).toBe(2)\n  })","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"global asset registration should affect apps created via createApp","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":447,"column":72},"line":447,"code":"test('global asset registration should affect apps created via createApp', () => {\n  Vue.component('foo', { template: 'foo' })\n  const vm = createApp({\n    template: '<foo/>'\n  }).mount(document.createElement('div')) as any\n  expect(vm.$el.textContent).toBe('foo')\n  delete singletonApp._context.components.foo\n})","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"post-facto global asset registration should affect apps created via createApp","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":456,"column":83},"line":456,"code":"test('post-facto global asset registration should affect apps created via createApp', () => {\n  const app = createApp({\n    template: '<foo/>'\n  })\n  Vue.component('foo', { template: 'foo' })\n  const vm = app.mount(document.createElement('div'))\n  expect(vm.$el.textContent).toBe('foo')\n  delete singletonApp._context.components.foo\n})","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"local asset registration should not affect other local apps","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":466,"column":65},"line":466,"code":"test('local asset registration should not affect other local apps', () => {\n  const app1 = createApp({})\n  const app2 = createApp({})\n\n  app1.component('foo', {})\n  app2.component('foo', {})\n\n  expect(\n    `Component \"foo\" has already been registered in target app`\n  ).not.toHaveBeenWarned()\n})","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"local app-level mixin registration should not affect other local apps","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":478,"column":75},"line":478,"code":"test('local app-level mixin registration should not affect other local apps', () => {\n  const app1 = createApp({ render: () => h('div') })\n  const app2 = createApp({})\n\n  const mixin = { created: vi.fn() }\n  app1.mixin(mixin)\n  app2.mixin(mixin)\n\n  expect(`Mixin has already been applied`).not.toHaveBeenWarned()\n\n  app1.mount(document.createElement('div'))\n  expect(mixin.created).toHaveBeenCalledTimes(1)\n})","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"local app config should not affect other local apps in v3 mode","suites":["GLOBAL_PRIVATE_UTIL"],"updatePoint":{"line":493,"column":68},"line":493,"code":"test('local app config should not affect other local apps in v3 mode', () => {\n  Vue.configureCompat({ MODE: 3 })\n  const app1 = createApp({\n    render: () => h('div'),\n    provide() {\n      return {\n        test: 123\n      }\n    }\n  })\n  app1.config.globalProperties.test = () => {}\n  app1.mount(document.createElement('div'))\n\n  const app2 = createApp({})\n  expect(app2.config.globalProperties.test).toBe(undefined)\n})","file":"global.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"GLOBAL_KEY_CODES","suites":[],"updatePoint":{"line":22,"column":22},"line":22,"code":"test('GLOBAL_KEY_CODES', () => {\n  Vue.config.keyCodes = {\n    foo: 86,\n    bar: [38, 87]\n  }\n\n  const onFoo = vi.fn()\n  const onBar = vi.fn()\n\n  const el = document.createElement('div')\n  new Vue({\n    el,\n    template: `<input type=\"text\" @keyup.foo=\"onFoo\" @keyup.bar=\"onBar\">`,\n    methods: {\n      onFoo,\n      onBar\n    }\n  })\n\n  triggerEvent(el.children[0], 'keyup', e => {\n    e.key = '_'\n    e.keyCode = 86\n  })\n  expect(onFoo).toHaveBeenCalledTimes(1)\n  expect(onBar).toHaveBeenCalledTimes(0)\n\n  triggerEvent(el.children[0], 'keyup', e => {\n    e.key = '_'\n    e.keyCode = 38\n  })\n  expect(onFoo).toHaveBeenCalledTimes(1)\n  expect(onBar).toHaveBeenCalledTimes(1)\n\n  triggerEvent(el.children[0], 'keyup', e => {\n    e.key = '_'\n    e.keyCode = 87\n  })\n  expect(onFoo).toHaveBeenCalledTimes(1)\n  expect(onBar).toHaveBeenCalledTimes(2)\n})","file":"globalConfig.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"GLOBAL_IGNORED_ELEMENTS","suites":[],"updatePoint":{"line":63,"column":29},"line":63,"code":"test('GLOBAL_IGNORED_ELEMENTS', () => {\n  Vue.config.ignoredElements = [/^v-/, 'foo']\n  const el = document.createElement('div')\n  new Vue({\n    el,\n    template: `<v-foo/><foo/>`\n  })\n  expect(el.innerHTML).toBe(`<v-foo></v-foo><foo></foo>`)\n})","file":"globalConfig.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"singleton config should affect apps created with createApp()","suites":[],"updatePoint":{"line":73,"column":66},"line":73,"code":"test('singleton config should affect apps created with createApp()', () => {\n  Vue.config.ignoredElements = [/^v-/, 'foo']\n  const el = document.createElement('div')\n  createApp({\n    template: `<v-foo/><foo/>`\n  }).mount(el)\n  expect(el.innerHTML).toBe(`<v-foo></v-foo><foo></foo>`)\n})","file":"globalConfig.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"config.optionMergeStrategies","suites":[],"updatePoint":{"line":82,"column":34},"line":82,"code":"test('config.optionMergeStrategies', () => {\n  toggleDeprecationWarning(true)\n  expect(typeof Vue.config.optionMergeStrategies.created).toBe('function')\n  expect(DeprecationTypes.CONFIG_OPTION_MERGE_STRATS).toHaveBeenWarned()\n})","file":"globalConfig.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_SET","suites":[],"updatePoint":{"line":25,"column":18},"line":25,"code":"test('INSTANCE_SET', () => {\n  const obj: any = {}\n  new Vue().$set(obj, 'foo', 1)\n  expect(obj.foo).toBe(1)\n  expect(\n    deprecationData[DeprecationTypes.INSTANCE_SET].message\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_DELETE","suites":[],"updatePoint":{"line":34,"column":21},"line":34,"code":"test('INSTANCE_DELETE', () => {\n  const obj: any = { foo: 1 }\n  new Vue().$delete(obj, 'foo')\n  expect('foo' in obj).toBe(false)\n  expect(\n    deprecationData[DeprecationTypes.INSTANCE_DELETE].message\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_DESTROY","suites":[],"updatePoint":{"line":43,"column":22},"line":43,"code":"test('INSTANCE_DESTROY', () => {\n  new Vue({ template: 'foo' }).$mount().$destroy()\n  expect(\n    deprecationData[DeprecationTypes.INSTANCE_DESTROY].message\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$on","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":60,"column":9},"line":60,"code":"  it('$on', () => {\n    vm.$on('test', function (this: any) {\n      // expect correct context\n      expect(this).toBe(vm)\n      spy.apply(this, arguments as unknown as any[])\n    })\n    vm.$emit('test', 1, 2, 3, 4)\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(spy).toHaveBeenCalledWith(1, 2, 3, 4)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$on multi event","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":74,"column":21},"line":74,"code":"  it('$on multi event', () => {\n    vm.$on(['test1', 'test2'], function (this: any) {\n      expect(this).toBe(vm)\n      spy.apply(this, arguments as unknown as any[])\n    })\n    vm.$emit('test1', 1, 2, 3, 4)\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(spy).toHaveBeenCalledWith(1, 2, 3, 4)\n    vm.$emit('test2', 5, 6, 7, 8)\n    expect(spy).toHaveBeenCalledTimes(2)\n    expect(spy).toHaveBeenCalledWith(5, 6, 7, 8)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off multi event","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":90,"column":22},"line":90,"code":"  it('$off multi event', () => {\n    vm.$on(['test1', 'test2', 'test3'], spy)\n    vm.$off(['test1', 'test2'], spy)\n    vm.$emit('test1')\n    vm.$emit('test2')\n    expect(spy).not.toHaveBeenCalled()\n    vm.$emit('test3', 1, 2, 3, 4)\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off multi event without callback","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":103,"column":39},"line":103,"code":"  it('$off multi event without callback', () => {\n    vm.$on(['test1', 'test2'], spy)\n    vm.$off(['test1', 'test2'])\n    vm.$emit('test1')\n    expect(spy).not.toHaveBeenCalled()\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$once","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":113,"column":11},"line":113,"code":"  it('$once', () => {\n    vm.$once('test', spy)\n    vm.$emit('test', 1, 2, 3)\n    vm.$emit('test', 2, 3, 4)\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(spy).toHaveBeenCalledWith(1, 2, 3)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off event added by $once","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":124,"column":31},"line":124,"code":"  it('$off event added by $once', () => {\n    vm.$once('test', spy)\n    vm.$off('test', spy) // test off event and this event added by once\n    vm.$emit('test', 1, 2, 3)\n    expect(spy).not.toHaveBeenCalled()\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":134,"column":10},"line":134,"code":"  it('$off', () => {\n    vm.$on('test1', spy)\n    vm.$on('test2', spy)\n    vm.$off()\n    vm.$emit('test1')\n    vm.$emit('test2')\n    expect(spy).not.toHaveBeenCalled()\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off event","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":146,"column":16},"line":146,"code":"  it('$off event', () => {\n    vm.$on('test1', spy)\n    vm.$on('test2', spy)\n    vm.$off('test1')\n    vm.$off('test1') // test off something that's already off\n    vm.$emit('test1', 1)\n    vm.$emit('test2', 2)\n    expect(spy).toHaveBeenCalledTimes(1)\n    expect(spy).toHaveBeenCalledWith(2)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"$off event + fn","suites":["INSTANCE_EVENT_EMITTER"],"updatePoint":{"line":160,"column":21},"line":160,"code":"  it('$off event + fn', () => {\n    const spy2 = vi.fn()\n    vm.$on('test', spy)\n    vm.$on('test', spy2)\n    vm.$off('test', spy)\n    vm.$emit('test', 1, 2, 3)\n    expect(spy).not.toHaveBeenCalled()\n    expect(spy2).toHaveBeenCalledTimes(1)\n    expect(spy2).toHaveBeenCalledWith(1, 2, 3)\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_EVENT_EMITTER].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"instance API","suites":["INSTANCE_EVENT_HOOKS"],"updatePoint":{"line":176,"column":20},"line":176,"code":"  test('instance API', () => {\n    const spy = vi.fn()\n    const vm = new Vue({ template: 'foo' })\n    vm.$on('hook:mounted', spy)\n    vm.$mount()\n    expect(spy).toHaveBeenCalled()\n    expect(\n      (\n        deprecationData[DeprecationTypes.INSTANCE_EVENT_HOOKS]\n          .message as Function\n      )('hook:mounted')\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"via template","suites":["INSTANCE_EVENT_HOOKS"],"updatePoint":{"line":190,"column":20},"line":190,"code":"  test('via template', () => {\n    const spy = vi.fn()\n    new Vue({\n      template: `<child @hook:mounted=\"spy\"/>`,\n      methods: { spy },\n      components: {\n        child: {\n          template: 'foo'\n        }\n      }\n    }).$mount()\n    expect(spy).toHaveBeenCalled()\n    expect(\n      (\n        deprecationData[DeprecationTypes.INSTANCE_EVENT_HOOKS]\n          .message as Function\n      )('hook:mounted')\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_EVENT_CHILDREN","suites":["INSTANCE_EVENT_HOOKS"],"updatePoint":{"line":211,"column":29},"line":211,"code":"test('INSTANCE_EVENT_CHILDREN', () => {\n  const vm = new Vue({\n    template: `<child/><div><child v-for=\"i in 3\"/></div>`,\n    components: {\n      child: {\n        template: 'foo',\n        data() {\n          return { n: 1 }\n        }\n      }\n    }\n  }).$mount()\n  expect(vm.$children.length).toBe(4)\n  vm.$children.forEach((c: any) => {\n    expect(c.n).toBe(1)\n  })\n  expect(\n    deprecationData[DeprecationTypes.INSTANCE_CHILDREN].message\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_LISTENERS","suites":["INSTANCE_EVENT_HOOKS"],"updatePoint":{"line":232,"column":24},"line":232,"code":"test('INSTANCE_LISTENERS', () => {\n  const foo = () => 'foo'\n  const bar = () => 'bar'\n  let listeners: Record<string, Function>\n\n  new Vue({\n    template: `<child @click=\"foo\" @custom=\"bar\" />`,\n    methods: { foo, bar },\n    components: {\n      child: {\n        template: `<div/>`,\n        mounted() {\n          listeners = this.$listeners\n        }\n      }\n    }\n  }).$mount()\n\n  expect(Object.keys(listeners!)).toMatchObject(['click', 'custom'])\n  expect(listeners!.click()).toBe('foo')\n  expect(listeners!.custom()).toBe('bar')\n\n  expect(\n    deprecationData[DeprecationTypes.INSTANCE_LISTENERS].message\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"explicit usage","suites":["INSTANCE_SCOPED_SLOTS"],"updatePoint":{"line":260,"column":22},"line":260,"code":"  test('explicit usage', () => {\n    let slots: Slots\n    new Vue({\n      template: `<child v-slot=\"{ msg }\">{{ msg }}</child>`,\n      components: {\n        child: {\n          compatConfig: { RENDER_FUNCTION: false },\n          render() {\n            slots = this.$scopedSlots\n          }\n        }\n      }\n    }).$mount()\n\n    expect(slots!.default!({ msg: 'hi' })).toMatchObject([\n      {\n        type: Text,\n        children: 'hi'\n      }\n    ])\n\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_SCOPED_SLOTS].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should not include legacy slot usage in $scopedSlots","suites":["INSTANCE_SCOPED_SLOTS"],"updatePoint":{"line":286,"column":60},"line":286,"code":"  test('should not include legacy slot usage in $scopedSlots', () => {\n    let normalSlots: Slots\n    let scopedSlots: Slots\n    new Vue({\n      template: `<child><div>default</div></child>`,\n      components: {\n        child: {\n          compatConfig: { RENDER_FUNCTION: false },\n          render() {\n            normalSlots = this.$slots\n            scopedSlots = this.$scopedSlots\n          }\n        }\n      }\n    }).$mount()\n\n    expect('default' in normalSlots!).toBe(true)\n    expect('default' in scopedSlots!).toBe(false)\n\n    expect(\n      deprecationData[DeprecationTypes.INSTANCE_SCOPED_SLOTS].message\n    ).toHaveBeenWarned()\n  })","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"INSTANCE_ATTR_CLASS_STYLE","suites":["INSTANCE_SCOPED_SLOTS"],"updatePoint":{"line":311,"column":31},"line":311,"code":"test('INSTANCE_ATTR_CLASS_STYLE', () => {\n  const vm = new Vue({\n    template: `<child class=\"foo\" style=\"color:red\" id=\"ok\" />`,\n    components: {\n      child: {\n        inheritAttrs: false,\n        template: `<div><div v-bind=\"$attrs\" /></div>`\n      }\n    }\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.outerHTML).toBe(\n    `<div class=\"foo\" style=\"color: red;\"><div id=\"ok\"></div></div>`\n  )\n\n  expect(\n    (\n      deprecationData[DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE]\n        .message as Function\n    )('Anonymous')\n  ).toHaveBeenWarned()\n})","file":"instance.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"mode as function","suites":[],"updatePoint":{"line":25,"column":22},"line":25,"code":"test('mode as function', () => {\n  const Foo = {\n    name: 'Foo',\n    render: (h: any) => h('div', 'foo')\n  }\n\n  const Bar = {\n    name: 'Bar',\n    data: () => ({ msg: 'bar' }),\n    render: (ctx: any) => h('div', ctx.msg)\n  }\n\n  toggleDeprecationWarning(false)\n  Vue.configureCompat({\n    MODE: comp => (comp && comp.name === 'Bar' ? 3 : 2)\n  })\n\n  const vm = new Vue({\n    components: { Foo, Bar },\n    template: `<div><foo/><bar/></div>`\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.innerHTML).toBe(`<div>foo</div><div>bar</div>`)\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"WATCH_ARRAY","suites":[],"updatePoint":{"line":51,"column":17},"line":51,"code":"test('WATCH_ARRAY', async () => {\n  const spy = vi.fn()\n  const vm = new Vue({\n    data() {\n      return {\n        foo: []\n      }\n    },\n    watch: {\n      foo: spy\n    }\n  }) as any\n  expect(\n    deprecationData[DeprecationTypes.WATCH_ARRAY].message\n  ).toHaveBeenWarned()\n\n  expect(spy).not.toHaveBeenCalled()\n  vm.foo.push(1)\n  await nextTick()\n  expect(spy).toHaveBeenCalledTimes(1)\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"PROPS_DEFAULT_THIS","suites":[],"updatePoint":{"line":73,"column":24},"line":73,"code":"test('PROPS_DEFAULT_THIS', () => {\n  let thisCtx: any\n  const Child = {\n    customOption: 1,\n    inject: ['provided'],\n    props: {\n      foo: null,\n      bar: {\n        default(this: any) {\n          // copy values since injection must be sync\n          thisCtx = {\n            foo: this.foo,\n            $options: this.$options,\n            provided: this.provided\n          }\n          return this.foo + 1\n        }\n      }\n    },\n    template: `{{ bar }}`\n  }\n\n  const vm = new Vue({\n    components: { Child },\n    provide: {\n      provided: 2\n    },\n    template: `<child :foo=\"0\" />`\n  }).$mount()\n\n  expect(vm.$el.textContent).toBe('1')\n  // other props\n  expect(thisCtx.foo).toBe(0)\n  // $options\n  expect(thisCtx.$options.customOption).toBe(1)\n  // injections\n  expect(thisCtx.provided).toBe(2)\n\n  expect(\n    (deprecationData[DeprecationTypes.PROPS_DEFAULT_THIS].message as Function)(\n      'bar'\n    )\n  ).toHaveBeenWarned()\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"V_ON_KEYCODE_MODIFIER","suites":[],"updatePoint":{"line":118,"column":27},"line":118,"code":"test('V_ON_KEYCODE_MODIFIER', () => {\n  const spy = vi.fn()\n  const vm = new Vue({\n    template: `<input @keyup.1=\"spy\">`,\n    methods: { spy }\n  }).$mount()\n  expect(vm.$el).toBeInstanceOf(HTMLInputElement)\n  triggerEvent(vm.$el, 'keyup', e => {\n    e.key = '_'\n    e.keyCode = 1\n  })\n  expect(spy).toHaveBeenCalled()\n  expect(\n    deprecationData[DeprecationTypes.V_ON_KEYCODE_MODIFIER].message\n  ).toHaveBeenWarned()\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"CUSTOM_DIR","suites":[],"updatePoint":{"line":135,"column":16},"line":135,"code":"test('CUSTOM_DIR', async () => {\n  const myDir = {\n    bind: vi.fn(),\n    inserted: vi.fn(),\n    update: vi.fn(),\n    componentUpdated: vi.fn(),\n    unbind: vi.fn()\n  } as any\n\n  const getCalls = () =>\n    Object.keys(myDir).map(key => myDir[key].mock.calls.length)\n\n  const vm = new Vue({\n    data() {\n      return {\n        ok: true,\n        foo: 1\n      }\n    },\n    template: `<div v-if=\"ok\" v-my-dir=\"foo\"/>`,\n    directives: {\n      myDir\n    }\n  }).$mount() as any\n\n  expect(getCalls()).toMatchObject([1, 1, 0, 0, 0])\n\n  expect(\n    (deprecationData[DeprecationTypes.CUSTOM_DIR].message as Function)(\n      'bind',\n      'beforeMount'\n    )\n  ).toHaveBeenWarned()\n  expect(\n    (deprecationData[DeprecationTypes.CUSTOM_DIR].message as Function)(\n      'inserted',\n      'mounted'\n    )\n  ).toHaveBeenWarned()\n\n  vm.foo++\n  await nextTick()\n  expect(getCalls()).toMatchObject([1, 1, 1, 1, 0])\n\n  expect(\n    (deprecationData[DeprecationTypes.CUSTOM_DIR].message as Function)(\n      'update',\n      'updated'\n    )\n  ).toHaveBeenWarned()\n  expect(\n    (deprecationData[DeprecationTypes.CUSTOM_DIR].message as Function)(\n      'componentUpdated',\n      'updated'\n    )\n  ).toHaveBeenWarned()\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"ATTR_FALSE_VALUE","suites":[],"updatePoint":{"line":193,"column":22},"line":193,"code":"test('ATTR_FALSE_VALUE', () => {\n  const vm = new Vue({\n    template: `<div :id=\"false\" :foo=\"false\"/>`\n  }).$mount()\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.hasAttribute('id')).toBe(false)\n  expect(vm.$el.hasAttribute('foo')).toBe(false)\n  expect(\n    (deprecationData[DeprecationTypes.ATTR_FALSE_VALUE].message as Function)(\n      'id'\n    )\n  ).toHaveBeenWarned()\n  expect(\n    (deprecationData[DeprecationTypes.ATTR_FALSE_VALUE].message as Function)(\n      'foo'\n    )\n  ).toHaveBeenWarned()\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"ATTR_ENUMERATED_COERCION","suites":[],"updatePoint":{"line":212,"column":30},"line":212,"code":"test('ATTR_ENUMERATED_COERCION', () => {\n  const vm = new Vue({\n    template: `<div :draggable=\"null\" :spellcheck=\"0\" contenteditable=\"foo\" />`\n  }).$mount()\n\n  expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n  expect(vm.$el.getAttribute('draggable')).toBe('false')\n  expect(vm.$el.getAttribute('spellcheck')).toBe('true')\n  expect(vm.$el.getAttribute('contenteditable')).toBe('true')\n  expect(\n    (\n      deprecationData[DeprecationTypes.ATTR_ENUMERATED_COERCION]\n        .message as Function\n    )('draggable', null, 'false')\n  ).toHaveBeenWarned()\n  expect(\n    (\n      deprecationData[DeprecationTypes.ATTR_ENUMERATED_COERCION]\n        .message as Function\n    )('spellcheck', 0, 'true')\n  ).toHaveBeenWarned()\n  expect(\n    (\n      deprecationData[DeprecationTypes.ATTR_ENUMERATED_COERCION]\n        .message as Function\n    )('contenteditable', 'foo', 'true')\n  ).toHaveBeenWarned()\n})","file":"misc.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"root data plain object","suites":[],"updatePoint":{"line":24,"column":28},"line":24,"code":"test('root data plain object', () => {\n  const vm = new Vue({\n    data: { foo: 1 } as any,\n    template: `{{ foo }}`\n  }).$mount()\n  expect(vm.$el.textContent).toBe('1')\n  expect(\n    deprecationData[DeprecationTypes.OPTIONS_DATA_FN].message\n  ).toHaveBeenWarned()\n})","file":"options.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"data deep merge","suites":[],"updatePoint":{"line":35,"column":21},"line":35,"code":"test('data deep merge', () => {\n  const mixin = {\n    data() {\n      return {\n        foo: {\n          baz: 2\n        }\n      }\n    }\n  }\n\n  const vm = new Vue({\n    mixins: [mixin],\n    data: () => ({\n      foo: {\n        bar: 1\n      },\n      selfData: 3\n    }),\n    template: `{{ { selfData, foo } }}`\n  }).$mount()\n\n  expect(vm.$el.textContent).toBe(\n    JSON.stringify({ selfData: 3, foo: { baz: 2, bar: 1 } }, null, 2)\n  )\n  expect(\n    (deprecationData[DeprecationTypes.OPTIONS_DATA_MERGE].message as Function)(\n      'foo'\n    )\n  ).toHaveBeenWarned()\n})","file":"options.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"data deep merge w/ extended constructor","suites":[],"updatePoint":{"line":68,"column":45},"line":68,"code":"test('data deep merge w/ extended constructor', () => {\n  const App = Vue.extend({\n    template: `<pre>{{ { mixinData, selfData } }}</pre>`,\n    mixins: [{ data: () => ({ mixinData: 'mixinData' }) }],\n    data: () => ({ selfData: 'selfData' })\n  })\n  const vm = new App().$mount()\n  expect(vm.$el.textContent).toBe(\n    JSON.stringify(\n      {\n        mixinData: 'mixinData',\n        selfData: 'selfData'\n      },\n      null,\n      2\n    )\n  )\n})","file":"options.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"beforeDestroy/destroyed","suites":[],"updatePoint":{"line":87,"column":29},"line":87,"code":"test('beforeDestroy/destroyed', async () => {\n  const beforeDestroy = vi.fn()\n  const destroyed = vi.fn()\n\n  const child = {\n    template: `foo`,\n    beforeDestroy,\n    destroyed\n  }\n\n  const vm = new Vue({\n    template: `<child v-if=\"ok\"/>`,\n    data() {\n      return { ok: true }\n    },\n    components: { child }\n  }).$mount() as any\n\n  vm.ok = false\n  await nextTick()\n  expect(beforeDestroy).toHaveBeenCalled()\n  expect(destroyed).toHaveBeenCalled()\n\n  expect(\n    deprecationData[DeprecationTypes.OPTIONS_BEFORE_DESTROY].message\n  ).toHaveBeenWarned()\n\n  expect(\n    deprecationData[DeprecationTypes.OPTIONS_DESTROYED].message\n  ).toHaveBeenWarned()\n})","file":"options.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"beforeDestroy/destroyed in Vue.extend components","suites":[],"updatePoint":{"line":119,"column":54},"line":119,"code":"test('beforeDestroy/destroyed in Vue.extend components', async () => {\n  const beforeDestroy = vi.fn()\n  const destroyed = vi.fn()\n\n  const child = Vue.extend({\n    template: `foo`,\n    beforeDestroy,\n    destroyed\n  })\n\n  const vm = new Vue({\n    template: `<child v-if=\"ok\"/>`,\n    data() {\n      return { ok: true }\n    },\n    components: { child }\n  }).$mount() as any\n\n  vm.ok = false\n  await nextTick()\n  expect(beforeDestroy).toHaveBeenCalled()\n  expect(destroyed).toHaveBeenCalled()\n\n  expect(\n    deprecationData[DeprecationTypes.OPTIONS_BEFORE_DESTROY].message\n  ).toHaveBeenWarned()\n\n  expect(\n    deprecationData[DeprecationTypes.OPTIONS_DESTROYED].message\n  ).toHaveBeenWarned()\n})","file":"options.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"string component lookup","suites":["compat: render function"],"updatePoint":{"line":50,"column":31},"line":50,"code":"  test('string component lookup', () => {\n    expect(h('foo')).toMatchObject({\n      type: mockChildComp\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"class / style / attrs / domProps / props","suites":["compat: render function"],"updatePoint":{"line":56,"column":48},"line":56,"code":"  test('class / style / attrs / domProps / props', () => {\n    expect(\n      h('div', {\n        class: 'foo',\n        style: { color: 'red' },\n        attrs: {\n          id: 'foo'\n        },\n        domProps: {\n          innerHTML: 'hi'\n        },\n        props: {\n          myProp: 'foo'\n        }\n      })\n    ).toMatchObject({\n      props: {\n        class: 'foo',\n        style: { color: 'red' },\n        id: 'foo',\n        innerHTML: 'hi',\n        myProp: 'foo'\n      }\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"staticClass + class","suites":["compat: render function"],"updatePoint":{"line":82,"column":27},"line":82,"code":"  test('staticClass + class', () => {\n    expect(\n      h('div', {\n        class: { foo: true },\n        staticClass: 'bar'\n      })\n    ).toMatchObject({\n      props: {\n        class: 'bar foo'\n      }\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"staticStyle + style","suites":["compat: render function"],"updatePoint":{"line":95,"column":27},"line":95,"code":"  test('staticStyle + style', () => {\n    expect(\n      h('div', {\n        style: { color: 'red' },\n        staticStyle: { fontSize: '14px' }\n      })\n    ).toMatchObject({\n      props: {\n        style: {\n          color: 'red',\n          fontSize: '14px'\n        }\n      }\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"on / nativeOn","suites":["compat: render function"],"updatePoint":{"line":111,"column":21},"line":111,"code":"  test('on / nativeOn', () => {\n    const fn = () => {}\n    expect(\n      h('div', {\n        on: {\n          click: fn,\n          fooBar: fn\n        },\n        nativeOn: {\n          click: fn,\n          'bar-baz': fn\n        }\n      })\n    ).toMatchObject({\n      props: {\n        onClick: fn,\n        onClickNative: fn,\n        onFooBar: fn,\n        'onBar-bazNative': fn\n      }\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"v2 legacy event prefixes","suites":["compat: render function"],"updatePoint":{"line":134,"column":32},"line":134,"code":"  test('v2 legacy event prefixes', () => {\n    const fn = () => {}\n    expect(\n      h('div', {\n        on: {\n          '&click': fn,\n          '~keyup': fn,\n          '!touchend': fn\n        }\n      })\n    ).toMatchObject({\n      props: {\n        onClickPassive: fn,\n        onKeyupOnce: fn,\n        onTouchendCapture: fn\n      }\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"directives","suites":["compat: render function"],"updatePoint":{"line":153,"column":18},"line":153,"code":"  test('directives', () => {\n    expect(\n      h('div', {\n        directives: [\n          {\n            name: 'mock-dir',\n            value: '2',\n            // expression: '1 + 1',\n            arg: 'foo',\n            modifiers: {\n              bar: true\n            }\n          }\n        ]\n      })\n    ).toMatchObject({\n      dirs: [\n        {\n          dir: mockDir,\n          instance: mockInstance.proxy,\n          value: '2',\n          oldValue: void 0,\n          arg: 'foo',\n          modifiers: {\n            bar: true\n          }\n        }\n      ] as DirectiveBinding[]\n    })\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"scopedSlots","suites":["compat: render function"],"updatePoint":{"line":184,"column":19},"line":184,"code":"  test('scopedSlots', () => {\n    const scopedSlots = {\n      default() {}\n    }\n    const vnode = h(mockComponent, {\n      scopedSlots\n    })\n    expect(vnode).toMatchObject({\n      children: scopedSlots\n    })\n    expect('scopedSlots' in vnode.props!).toBe(false)\n    expect(vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN).toBeTruthy()\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"legacy named slot","suites":["compat: render function"],"updatePoint":{"line":198,"column":25},"line":198,"code":"  test('legacy named slot', () => {\n    const vnode = h(mockComponent, [\n      'text',\n      h('div', { slot: 'foo' }, 'one'),\n      h('div', { slot: 'bar' }, 'two'),\n      h('div', { slot: 'foo' }, 'three'),\n      h('div', 'four')\n    ])\n    expect(vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN).toBeTruthy()\n    const slots = vnode.children as any\n\n    // default\n    expect(slots.default()).toMatchObject(['text', { children: 'four' }])\n    expect(slots.foo()).toMatchObject([\n      { children: 'one' },\n      { children: 'three' }\n    ])\n    expect(slots.bar()).toMatchObject([{ children: 'two' }])\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"in component usage","suites":["compat: render function"],"updatePoint":{"line":218,"column":26},"line":218,"code":"  test('in component usage', () => {\n    toggleDeprecationWarning(true)\n\n    const vm = new Vue({\n      render(h: any) {\n        return h(\n          'div',\n          {\n            class: 'foo',\n            attrs: { id: 'bar' }\n          },\n          'hello'\n        )\n      }\n    }).$mount()\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.outerHTML).toBe(`<div class=\"foo\" id=\"bar\">hello</div>`)\n    expect(\n      deprecationData[DeprecationTypes.RENDER_FUNCTION].message\n    ).toHaveBeenWarned()\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"should detect v3 compiled render fn","suites":["compat: render function"],"updatePoint":{"line":240,"column":43},"line":240,"code":"  test('should detect v3 compiled render fn', () => {\n    const vm = new Vue({\n      data() {\n        return {\n          a: 'hello'\n        }\n      },\n      // check is arg length based\n      render(c: any, _c: any) {\n        return createVNode('div', null, c.a)\n      }\n    }).$mount()\n    expect(vm.$el).toBeInstanceOf(HTMLDivElement)\n    expect(vm.$el.outerHTML).toBe(`<div>hello</div>`)\n  })","file":"renderFn.spec.ts","skipped":false,"dir":"packages/vue-compat/__tests__"},{"name":"custom element event casing","suites":[],"updatePoint":{"line":7,"column":33},"line":7,"code":"test('custom element event casing', () => {\n  customElements.define(\n    'custom-event-casing',\n    class Foo extends HTMLElement {\n      connectedCallback() {\n        this.dispatchEvent(new Event('camelCase'))\n        this.dispatchEvent(new Event('CAPScase'))\n        this.dispatchEvent(new Event('PascalCase'))\n      }\n    }\n  )\n\n  const container = document.createElement('div')\n  document.body.appendChild(container)\n\n  const handler = vi.fn()\n  const handler2 = vi.fn()\n  createApp({\n    template: `\n    <custom-event-casing\n      @camelCase=\"handler\"\n      @CAPScase=\"handler\"\n      @PascalCase=\"handler\"\n      v-on=\"{\n        camelCase: handler2,\n        CAPScase: handler2,\n        PascalCase: handler2\n      }\" />`,\n    methods: {\n      handler,\n      handler2\n    }\n  }).mount(container)\n\n  expect(handler).toHaveBeenCalledTimes(3)\n  expect(handler2).toHaveBeenCalledTimes(3)\n})","file":"customElementCasing.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: commits"],"updatePoint":{"line":50,"column":12},"line":49,"code":"  test(\n    'classic',\n    async () => {\n      await testCommits('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/commits.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: commits"],"updatePoint":{"line":58,"column":16},"line":57,"code":"  test(\n    'composition',\n    async () => {\n      await testCommits('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/commits.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: grid"],"updatePoint":{"line":107,"column":12},"line":106,"code":"  test(\n    'classic',\n    async () => {\n      await testGrid('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/grid.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: grid"],"updatePoint":{"line":115,"column":16},"line":114,"code":"  test(\n    'composition',\n    async () => {\n      await testGrid('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/grid.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: markdown"],"updatePoint":{"line":33,"column":12},"line":32,"code":"  test(\n    'classic',\n    async () => {\n      await testMarkdown('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/markdown.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: markdown"],"updatePoint":{"line":41,"column":16},"line":40,"code":"  test(\n    'composition',\n    async () => {\n      await testMarkdown('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/markdown.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: svg"],"updatePoint":{"line":143,"column":12},"line":142,"code":"  test(\n    'classic',\n    async () => {\n      await testSvg('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/svg.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: svg"],"updatePoint":{"line":151,"column":16},"line":150,"code":"  test(\n    'composition',\n    async () => {\n      await testSvg('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/svg.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: todomvc"],"updatePoint":{"line":173,"column":12},"line":172,"code":"  test(\n    'classic',\n    async () => {\n      await testTodomvc('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/todomvc.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: todomvc"],"updatePoint":{"line":181,"column":16},"line":180,"code":"  test(\n    'composition',\n    async () => {\n      await testTodomvc('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/todomvc.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"basic transition","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":31,"column":23},"line":30,"code":"    test(\n      'basic transition',\n      async () => {\n        await page().goto(baseUrl)\n        await page().waitForSelector('#app')\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition>\n                <div v-if=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'v-leave-from',\n          'v-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-leave-active',\n          'v-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'v-enter-from',\n          'v-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-enter-active',\n          'v-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"named transition","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":89,"column":23},"line":88,"code":"    test(\n      'named transition',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"custom transition classes","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":145,"column":32},"line":144,"code":"    test(\n      'custom transition classes',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n          <div id=\"container\">\n            <transition enter-from-class=\"hello-from\"\n              enter-active-class=\"hello-active\"\n              enter-to-class=\"hello-to\"\n              leave-from-class=\"bye-from\"\n              leave-active-class=\"bye-active\"\n              leave-to-class=\"bye-to\">\n              <div v-if=\"toggle\" class=\"test\">content</div>\n            </transition>\n          </div>\n          <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'bye-from',\n          'bye-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'bye-active',\n          'bye-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'hello-from',\n          'hello-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'hello-active',\n          'hello-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition with dynamic name","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":206,"column":35},"line":205,"code":"    test(\n      'transition with dynamic name',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n          <div id=\"container\">\n            <transition :name=\"name\">\n              <div v-if=\"toggle\" class=\"test\">content</div>\n            </transition>\n          </div>\n          <button id=\"toggleBtn\" @click=\"click\">button</button>\n          <button id=\"changeNameBtn\" @click=\"changeName\">button</button>\n          `,\n            setup: () => {\n              const name = ref('test')\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              const changeName = () => (name.value = 'changed')\n              return { toggle, click, name, changeName }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        await page().evaluate(() => {\n          ;(document.querySelector('#changeNameBtn') as any).click()\n        })\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'changed-enter-from',\n          'changed-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'changed-enter-active',\n          'changed-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition events without appear","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":268,"column":39},"line":267,"code":"    test(\n      'transition events without appear',\n      async () => {\n        const beforeLeaveSpy = vi.fn()\n        const onLeaveSpy = vi.fn()\n        const afterLeaveSpy = vi.fn()\n        const beforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('beforeLeaveSpy', beforeLeaveSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('afterLeaveSpy', afterLeaveSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n\n        await page().evaluate(() => {\n          const {\n            beforeEnterSpy,\n            onEnterSpy,\n            afterEnterSpy,\n            beforeLeaveSpy,\n            onLeaveSpy,\n            afterLeaveSpy\n          } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition\n                name=\"test\"\n                @before-enter=\"beforeEnterSpy\"\n                @enter=\"onEnterSpy\"\n                @after-enter=\"afterEnterSpy\"\n                @before-leave=\"beforeLeaveSpy\"\n                @leave=\"onLeaveSpy\"\n                @after-leave=\"afterLeaveSpy\">\n                <div v-if=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeEnterSpy,\n                onEnterSpy,\n                afterEnterSpy,\n                beforeLeaveSpy,\n                onLeaveSpy,\n                afterLeaveSpy\n              }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        expect(beforeLeaveSpy).toBeCalled()\n        expect(onLeaveSpy).toBeCalled()\n        expect(afterLeaveSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        expect(afterLeaveSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n        expect(afterLeaveSpy).toBeCalled()\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        expect(beforeEnterSpy).toBeCalled()\n        expect(onEnterSpy).toBeCalled()\n        expect(afterEnterSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        expect(afterEnterSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n        expect(afterEnterSpy).toBeCalled()\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"events with arguments","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":372,"column":28},"line":371,"code":"    test(\n      'events with arguments',\n      async () => {\n        const beforeLeaveSpy = vi.fn()\n        const onLeaveSpy = vi.fn()\n        const afterLeaveSpy = vi.fn()\n        const beforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('beforeLeaveSpy', beforeLeaveSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('afterLeaveSpy', afterLeaveSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n\n        await page().evaluate(() => {\n          const {\n            beforeEnterSpy,\n            onEnterSpy,\n            afterEnterSpy,\n            beforeLeaveSpy,\n            onLeaveSpy,\n            afterLeaveSpy\n          } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition\n                :css=\"false\"\n                name=\"test\"\n                @before-enter=\"beforeEnterSpy\"\n                @enter=\"onEnterSpy\"\n                @after-enter=\"afterEnterSpy\"\n                @before-leave=\"beforeLeaveSpy\"\n                @leave=\"onLeaveSpy\"\n                @after-leave=\"afterLeaveSpy\">\n                <div v-if=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeEnterSpy(el: Element) {\n                  beforeEnterSpy()\n                  el.classList.add('before-enter')\n                },\n                onEnterSpy(el: Element, done: () => void) {\n                  onEnterSpy()\n                  el.classList.add('enter')\n                  setTimeout(done, 200)\n                },\n                afterEnterSpy(el: Element) {\n                  afterEnterSpy()\n                  el.classList.add('after-enter')\n                },\n                beforeLeaveSpy(el: HTMLDivElement) {\n                  beforeLeaveSpy()\n                  el.classList.add('before-leave')\n                },\n                onLeaveSpy(el: HTMLDivElement, done: () => void) {\n                  onLeaveSpy()\n                  el.classList.add('leave')\n                  setTimeout(done, 200)\n                },\n                afterLeaveSpy: (el: Element) => {\n                  afterLeaveSpy()\n                }\n              }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        await click('#toggleBtn')\n        expect(beforeLeaveSpy).toBeCalled()\n        expect(onLeaveSpy).toBeCalled()\n        expect(afterLeaveSpy).not.toBeCalled()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'before-leave',\n          'leave'\n        ])\n\n        await timeout(200 + buffer)\n        expect(afterLeaveSpy).toBeCalled()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        await click('#toggleBtn')\n        expect(beforeEnterSpy).toBeCalled()\n        expect(onEnterSpy).toBeCalled()\n        expect(afterEnterSpy).not.toBeCalled()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'before-enter',\n          'enter'\n        ])\n\n        await timeout(200 + buffer)\n        expect(afterEnterSpy).toBeCalled()\n        expect(await html('#container')).toBe(\n          '<div class=\"test before-enter enter after-enter\">content</div>'\n        )\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"onEnterCancelled","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":487,"column":26},"line":487,"code":"    test('onEnterCancelled', async () => {\n      const enterCancelledSpy = vi.fn()\n\n      await page().exposeFunction('enterCancelledSpy', enterCancelledSpy)\n\n      await page().evaluate(() => {\n        const { enterCancelledSpy } = window as any\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n            <div id=\"container\">\n              <transition\n                name=\"test\"\n                @enter-cancelled=\"enterCancelledSpy\">\n                <div v-if=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n          setup: () => {\n            const toggle = ref(false)\n            const click = () => (toggle.value = !toggle.value)\n            return {\n              toggle,\n              click,\n              enterCancelledSpy\n            }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe('<!--v-if-->')\n\n      // enter\n      expect(await classWhenTransitionStart()).toStrictEqual([\n        'test',\n        'test-enter-from',\n        'test-enter-active'\n      ])\n      await nextFrame()\n      expect(await classList('.test')).toStrictEqual([\n        'test',\n        'test-enter-active',\n        'test-enter-to'\n      ])\n\n      // cancel (leave)\n      expect(await classWhenTransitionStart()).toStrictEqual([\n        'test',\n        'test-leave-from',\n        'test-leave-active'\n      ])\n      expect(enterCancelledSpy).toBeCalled()\n      await nextFrame()\n      expect(await classList('.test')).toStrictEqual([\n        'test',\n        'test-leave-active',\n        'test-leave-to'\n      ])\n      await transitionFinish()\n      expect(await html('#container')).toBe('<!--v-if-->')\n    })","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition on appear","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":550,"column":27},"line":549,"code":"    test(\n      'transition on appear',\n      async () => {\n        const appearClass = await page().evaluate(async () => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\"\n                            appear\n                            appear-from-class=\"test-appear-from\"\n                            appear-to-class=\"test-appear-to\"\n                            appear-active-class=\"test-appear-active\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n          return Promise.resolve().then(() => {\n            return document.querySelector('.test')!.className.split(/\\s+/g)\n          })\n        })\n        // appear\n        expect(appearClass).toStrictEqual([\n          'test',\n          'test-appear-from',\n          'test-appear-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-appear-active',\n          'test-appear-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition events with appear","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":626,"column":36},"line":625,"code":"    test(\n      'transition events with appear',\n      async () => {\n        const onLeaveSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const onAppearSpy = vi.fn()\n        const beforeLeaveSpy = vi.fn()\n        const beforeEnterSpy = vi.fn()\n        const beforeAppearSpy = vi.fn()\n        const afterLeaveSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n        const afterAppearSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('onAppearSpy', onAppearSpy)\n        await page().exposeFunction('beforeLeaveSpy', beforeLeaveSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('beforeAppearSpy', beforeAppearSpy)\n        await page().exposeFunction('afterLeaveSpy', afterLeaveSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n        await page().exposeFunction('afterAppearSpy', afterAppearSpy)\n\n        const appearClass = await page().evaluate(async () => {\n          const {\n            beforeAppearSpy,\n            onAppearSpy,\n            afterAppearSpy,\n            beforeEnterSpy,\n            onEnterSpy,\n            afterEnterSpy,\n            beforeLeaveSpy,\n            onLeaveSpy,\n            afterLeaveSpy\n          } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition\n                  name=\"test\"\n                  appear\n                  appear-from-class=\"test-appear-from\"\n                  appear-to-class=\"test-appear-to\"\n                  appear-active-class=\"test-appear-active\"\n                  @before-enter=\"beforeEnterSpy\"\n                  @enter=\"onEnterSpy\"\n                  @after-enter=\"afterEnterSpy\"\n                  @before-leave=\"beforeLeaveSpy\"\n                  @leave=\"onLeaveSpy\"\n                  @after-leave=\"afterLeaveSpy\"\n                  @before-appear=\"beforeAppearSpy\"\n                  @appear=\"onAppearSpy\"\n                  @after-appear=\"afterAppearSpy\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeAppearSpy,\n                onAppearSpy,\n                afterAppearSpy,\n                beforeEnterSpy,\n                onEnterSpy,\n                afterEnterSpy,\n                beforeLeaveSpy,\n                onLeaveSpy,\n                afterLeaveSpy\n              }\n            }\n          }).mount('#app')\n          return Promise.resolve().then(() => {\n            return document.querySelector('.test')!.className.split(/\\s+/g)\n          })\n        })\n        // appear\n        expect(appearClass).toStrictEqual([\n          'test',\n          'test-appear-from',\n          'test-appear-active'\n        ])\n        expect(beforeAppearSpy).toBeCalled()\n        expect(onAppearSpy).toBeCalled()\n        expect(afterAppearSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-appear-active',\n          'test-appear-to'\n        ])\n        expect(afterAppearSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n        expect(afterAppearSpy).toBeCalled()\n\n        expect(beforeEnterSpy).not.toBeCalled()\n        expect(onEnterSpy).not.toBeCalled()\n        expect(afterEnterSpy).not.toBeCalled()\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        expect(beforeLeaveSpy).toBeCalled()\n        expect(onLeaveSpy).toBeCalled()\n        expect(afterLeaveSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        expect(afterLeaveSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n        expect(afterLeaveSpy).toBeCalled()\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        expect(beforeEnterSpy).toBeCalled()\n        expect(onEnterSpy).toBeCalled()\n        expect(afterEnterSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        expect(afterEnterSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n        expect(afterEnterSpy).toBeCalled()\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"css: false","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":774,"column":17},"line":773,"code":"    test(\n      'css: false',\n      async () => {\n        const onBeforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const onAfterEnterSpy = vi.fn()\n        const onBeforeLeaveSpy = vi.fn()\n        const onLeaveSpy = vi.fn()\n        const onAfterLeaveSpy = vi.fn()\n\n        await page().exposeFunction('onBeforeEnterSpy', onBeforeEnterSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('onAfterEnterSpy', onAfterEnterSpy)\n        await page().exposeFunction('onBeforeLeaveSpy', onBeforeLeaveSpy)\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onAfterLeaveSpy', onAfterLeaveSpy)\n\n        await page().evaluate(() => {\n          const {\n            onBeforeEnterSpy,\n            onEnterSpy,\n            onAfterEnterSpy,\n            onBeforeLeaveSpy,\n            onLeaveSpy,\n            onAfterLeaveSpy\n          } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition\n                :css=\"false\"\n                name=\"test\"\n                @before-enter=\"onBeforeEnterSpy\"\n                @enter=\"onEnterSpy\"\n                @after-enter=\"onAfterEnterSpy\"\n                @before-leave=\"onBeforeLeaveSpy\"\n                @leave=\"onLeaveSpy\"\n                @after-leave=\"onAfterLeaveSpy\">\n                <div v-if=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\"></button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                onBeforeEnterSpy,\n                onEnterSpy,\n                onAfterEnterSpy,\n                onBeforeLeaveSpy,\n                onLeaveSpy,\n                onAfterLeaveSpy\n              }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        await click('#toggleBtn')\n        expect(onBeforeLeaveSpy).toBeCalled()\n        expect(onLeaveSpy).toBeCalled()\n        expect(onAfterLeaveSpy).toBeCalled()\n        expect(await html('#container')).toBe('<!--v-if-->')\n        // enter\n        await classWhenTransitionStart()\n        expect(onBeforeEnterSpy).toBeCalled()\n        expect(onEnterSpy).toBeCalled()\n        expect(onAfterEnterSpy).toBeCalled()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"no transition detected","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":852,"column":29},"line":851,"code":"    test(\n      'no transition detected',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition name=\"noop\">\n                <div v-if=\"toggle\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div>content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'noop-leave-from',\n          'noop-leave-active'\n        ])\n        await nextFrame()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'noop-enter-from',\n          'noop-enter-active'\n        ])\n        await nextFrame()\n        expect(await html('#container')).toBe('<div class=\"\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"animations","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":894,"column":17},"line":893,"code":"    test(\n      'animations',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test-anim\">\n                  <div v-if=\"toggle\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div>content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test-anim-leave-from',\n          'test-anim-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('#container div')).toStrictEqual([\n          'test-anim-leave-active',\n          'test-anim-leave-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test-anim-enter-from',\n          'test-anim-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('#container div')).toStrictEqual([\n          'test-anim-enter-active',\n          'test-anim-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"explicit transition type","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":946,"column":31},"line":945,"code":"    test(\n      'explicit transition type',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\"><transition name=\"test-anim-long\" type=\"animation\"><div v-if=\"toggle\">content</div></transition></div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div>content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test-anim-long-leave-from',\n          'test-anim-long-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('#container div')).toStrictEqual([\n          'test-anim-long-leave-active',\n          'test-anim-long-leave-to'\n        ])\n\n        if (!process.env.CI) {\n          await new Promise(r => {\n            setTimeout(r, duration - buffer)\n          })\n          expect(await classList('#container div')).toStrictEqual([\n            'test-anim-long-leave-active',\n            'test-anim-long-leave-to'\n          ])\n        }\n\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test-anim-long-enter-from',\n          'test-anim-long-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('#container div')).toStrictEqual([\n          'test-anim-long-enter-active',\n          'test-anim-long-enter-to'\n        ])\n\n        if (!process.env.CI) {\n          await new Promise(r => {\n            setTimeout(r, duration - buffer)\n          })\n          expect(await classList('#container div')).toStrictEqual([\n            'test-anim-long-enter-active',\n            'test-anim-long-enter-to'\n          ])\n        }\n\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<div class=\"\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition on SVG elements","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":1016,"column":33},"line":1015,"code":"    test(\n      'transition on SVG elements',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <svg id=\"container\">\n                <transition name=\"test\">\n                  <circle v-if=\"toggle\" cx=\"0\" cy=\"0\" r=\"10\" class=\"test\"></circle>\n                </transition>\n              </svg>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe(\n          '<circle cx=\"0\" cy=\"0\" r=\"10\" class=\"test\"></circle>'\n        )\n\n        const svgTransitionStart = () =>\n          page().evaluate(() => {\n            document.querySelector('button')!.click()\n            return Promise.resolve().then(() => {\n              return document\n                .querySelector('.test')!\n                .getAttribute('class')!\n                .split(/\\s+/g)\n            })\n          })\n\n        // leave\n        expect(await svgTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await svgTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<circle cx=\"0\" cy=\"0\" r=\"10\" class=\"test\"></circle>'\n        )\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"custom transition higher-order component","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":1087,"column":47},"line":1086,"code":"    test(\n      'custom transition higher-order component',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref, h, Transition } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\"><my-transition><div v-if=\"toggle\" class=\"test\">content</div></my-transition></div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            components: {\n              'my-transition': (props: any, { slots }: any) => {\n                return h(Transition, { name: 'test' }, slots)\n              }\n            },\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition on child components with empty root node","suites":["e2e: Transition","transition with v-if"],"updatePoint":{"line":1144,"column":58},"line":1143,"code":"    test(\n      'transition on child components with empty root node',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\">\n                  <component class=\"test\" :is=\"view\"></component>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n              <button id=\"changeViewBtn\" @click=\"change\">button</button>\n            `,\n            components: {\n              one: {\n                template: '<div v-if=\"false\">one</div>'\n              },\n              two: {\n                template: '<div>two</div>'\n              }\n            },\n            setup: () => {\n              const toggle = ref(true)\n              const view = ref('one')\n              const click = () => (toggle.value = !toggle.value)\n              const change = () =>\n                (view.value = view.value === 'one' ? 'two' : 'one')\n              return { toggle, click, change, view }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // change view -> 'two'\n        await page().evaluate(() => {\n          ;(document.querySelector('#changeViewBtn') as any)!.click()\n        })\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">two</div>')\n\n        // change view -> 'one'\n        await page().evaluate(() => {\n          ;(document.querySelector('#changeViewBtn') as any)!.click()\n        })\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"async component transition inside Suspense","suites":["e2e: Transition","transition with Suspense"],"updatePoint":{"line":1223,"column":49},"line":1222,"code":"    test(\n      'async component transition inside Suspense',\n      async () => {\n        const onLeaveSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n\n        await page().evaluate(() => {\n          const { onEnterSpy, onLeaveSpy } = window as any\n          const { createApp, ref, h } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition @enter=\"onEnterSpy\" @leave=\"onLeaveSpy\">\n                <Suspense>\n                  <Comp v-if=\"toggle\" class=\"test\">content</Comp>\n                </Suspense>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            components: {\n              Comp: {\n                async setup() {\n                  return () => h('div', { class: 'test' }, 'content')\n                }\n              }\n            },\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click, onEnterSpy, onLeaveSpy }\n            }\n          }).mount('#app')\n        })\n\n        expect(onEnterSpy).toBeCalledTimes(1)\n        await nextFrame()\n        expect(await html('#container')).toBe(\n          '<div class=\"test v-enter-active v-enter-to\">content</div>'\n        )\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'v-leave-from',\n          'v-leave-active'\n        ])\n        expect(onLeaveSpy).toBeCalledTimes(1)\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-leave-active',\n          'v-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        const enterClass = await page().evaluate(async () => {\n          ;(document.querySelector('#toggleBtn') as any)!.click()\n          // nextTrick for patch start\n          await Promise.resolve()\n          // nextTrick for Suspense resolve\n          await Promise.resolve()\n          // nextTrick for dom transition start\n          await Promise.resolve()\n          return document\n            .querySelector('#container div')!\n            .className.split(/\\s+/g)\n        })\n        expect(enterClass).toStrictEqual([\n          'test',\n          'v-enter-from',\n          'v-enter-active'\n        ])\n        expect(onEnterSpy).toBeCalledTimes(2)\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-enter-active',\n          'v-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"static node transition inside Suspense","suites":["e2e: Transition","transition with Suspense"],"updatePoint":{"line":1317,"column":45},"line":1316,"code":"    test(\n      'static node transition inside Suspense',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition>\n                <Suspense>\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </Suspense>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'v-leave-from',\n          'v-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-leave-active',\n          'v-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'v-enter-from',\n          'v-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'v-enter-active',\n          'v-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"out-in mode with Suspense","suites":["e2e: Transition","transition with Suspense"],"updatePoint":{"line":1375,"column":32},"line":1374,"code":"    test(\n      'out-in mode with Suspense',\n      async () => {\n        const onLeaveSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n\n        await page().evaluate(() => {\n          const { createApp, shallowRef, h } = (window as any).Vue\n          const One = {\n            async setup() {\n              return () => h('div', { class: 'test' }, 'one')\n            }\n          }\n          const Two = {\n            async setup() {\n              return () => h('div', { class: 'test' }, 'two')\n            }\n          }\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition mode=\"out-in\">\n                  <Suspense>\n                    <component :is=\"view\"/>\n                  </Suspense>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const view = shallowRef(One)\n              const click = () => {\n                view.value = view.value === One ? Two : One\n              }\n              return { view, click }\n            }\n          }).mount('#app')\n        })\n\n        await nextFrame()\n        expect(await html('#container')).toBe(\n          '<div class=\"test v-enter-active v-enter-to\">one</div>'\n        )\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">one</div>')\n\n        // leave\n        await classWhenTransitionStart()\n        await nextFrame()\n        expect(await html('#container')).toBe(\n          '<div class=\"test v-leave-active v-leave-to\">one</div>'\n        )\n        await transitionFinish()\n        await nextFrame()\n        // expect(await html('#container')).toBe(\n        //   '<div class=\"test v-enter-active v-enter-to\">two</div>'\n        // )\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">two</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"Suspense fallback should work with transition","suites":["e2e: Transition","transition with Suspense"],"updatePoint":{"line":1442,"column":52},"line":1441,"code":"    test(\n      'Suspense fallback should work with transition',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, shallowRef, h } = (window as any).Vue\n\n          const One = {\n            template: `<div>{{ msg }}</div>`,\n            setup() {\n              return new Promise(_resolve => {\n                // @ts-ignore\n                window.resolve = () =>\n                  _resolve({\n                    msg: 'success'\n                  })\n              })\n            }\n          }\n\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition mode=\"out-in\">\n                  <Suspense :timeout=\"0\">\n                    <template #default>\n                      <component :is=\"view\" />\n                    </template>\n                    <template #fallback>\n                      <div>Loading...</div>\n                    </template>\n                  </Suspense>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const view = shallowRef(null)\n              const click = () => {\n                view.value = view.value ? null : h(One)\n              }\n              return { view, click }\n            }\n          }).mount('#app')\n        })\n\n        expect(await html('#container')).toBe('<!---->')\n\n        await click('#toggleBtn')\n        await nextFrame()\n        expect(await html('#container')).toBe('<div class=\"\">Loading...</div>')\n\n        await page().evaluate(() => {\n          // @ts-ignore\n          window.resolve()\n        })\n\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<div class=\"\">success</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"named transition with v-show","suites":["e2e: Transition","transition with v-show"],"updatePoint":{"line":1506,"column":35},"line":1505,"code":"    test(\n      'named transition with v-show',\n      async () => {\n        await page().evaluate(() => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition name=\"test\">\n                <div v-show=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n        expect(await isVisible('.test')).toBe(true)\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await isVisible('.test')).toBe(false)\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<div class=\"test\" style=\"\">content</div>'\n        )\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition events with v-show","suites":["e2e: Transition","transition with v-show"],"updatePoint":{"line":1565,"column":36},"line":1564,"code":"    test(\n      'transition events with v-show',\n      async () => {\n        const beforeLeaveSpy = vi.fn()\n        const onLeaveSpy = vi.fn()\n        const afterLeaveSpy = vi.fn()\n        const beforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('beforeLeaveSpy', beforeLeaveSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('afterLeaveSpy', afterLeaveSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n\n        await page().evaluate(() => {\n          const {\n            beforeEnterSpy,\n            onEnterSpy,\n            afterEnterSpy,\n            beforeLeaveSpy,\n            onLeaveSpy,\n            afterLeaveSpy\n          } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition\n                name=\"test\"\n                @before-enter=\"beforeEnterSpy\"\n                @enter=\"onEnterSpy\"\n                @after-enter=\"afterEnterSpy\"\n                @before-leave=\"beforeLeaveSpy\"\n                @leave=\"onLeaveSpy\"\n                @after-leave=\"afterLeaveSpy\">\n                <div v-show=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeEnterSpy,\n                onEnterSpy,\n                afterEnterSpy,\n                beforeLeaveSpy,\n                onLeaveSpy,\n                afterLeaveSpy\n              }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        expect(beforeLeaveSpy).toBeCalled()\n        expect(onLeaveSpy).toBeCalled()\n        expect(afterLeaveSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        expect(afterLeaveSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await isVisible('.test')).toBe(false)\n        expect(afterLeaveSpy).toBeCalled()\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        expect(beforeEnterSpy).toBeCalled()\n        expect(onEnterSpy).toBeCalled()\n        expect(afterEnterSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        expect(afterEnterSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<div class=\"test\" style=\"\">content</div>'\n        )\n        expect(afterEnterSpy).toBeCalled()\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"onLeaveCancelled (v-show only)","suites":["e2e: Transition","transition with v-show"],"updatePoint":{"line":1671,"column":37},"line":1670,"code":"    test(\n      'onLeaveCancelled (v-show only)',\n      async () => {\n        const onLeaveCancelledSpy = vi.fn()\n\n        await page().exposeFunction('onLeaveCancelledSpy', onLeaveCancelledSpy)\n        await page().evaluate(() => {\n          const { onLeaveCancelledSpy } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition name=\"test\" @leave-cancelled=\"onLeaveCancelledSpy\">\n                <div v-show=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click, onLeaveCancelledSpy }\n            }\n          }).mount('#app')\n        })\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n        expect(await isVisible('.test')).toBe(true)\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n\n        // cancel (enter)\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        expect(onLeaveCancelledSpy).toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<div class=\"test\" style=\"\">content</div>'\n        )\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition on appear with v-show","suites":["e2e: Transition","transition with v-show"],"updatePoint":{"line":1733,"column":39},"line":1732,"code":"    test(\n      'transition on appear with v-show',\n      async () => {\n        const beforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n\n        const appearClass = await page().evaluate(async () => {\n          const { createApp, ref } = (window as any).Vue\n          const { beforeEnterSpy, onEnterSpy, afterEnterSpy } = window as any\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\"\n                            appear\n                            appear-from-class=\"test-appear-from\"\n                            appear-to-class=\"test-appear-to\"\n                            appear-active-class=\"test-appear-active\"\n                            @before-enter=\"beforeEnterSpy\"\n                            @enter=\"onEnterSpy\"\n                            @after-enter=\"afterEnterSpy\">\n                  <div v-show=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeEnterSpy,\n                onEnterSpy,\n                afterEnterSpy\n              }\n            }\n          }).mount('#app')\n          return Promise.resolve().then(() => {\n            return document.querySelector('.test')!.className.split(/\\s+/g)\n          })\n        })\n\n        expect(beforeEnterSpy).toBeCalledTimes(1)\n        expect(onEnterSpy).toBeCalledTimes(1)\n        expect(afterEnterSpy).toBeCalledTimes(0)\n\n        // appear\n        expect(appearClass).toStrictEqual([\n          'test',\n          'test-appear-from',\n          'test-appear-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-appear-active',\n          'test-appear-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        expect(beforeEnterSpy).toBeCalledTimes(1)\n        expect(onEnterSpy).toBeCalledTimes(1)\n        expect(afterEnterSpy).toBeCalledTimes(1)\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await isVisible('.test')).toBe(false)\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<div class=\"test\" style=\"\">content</div>'\n        )\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"transition events should not call onEnter with v-show false","suites":["e2e: Transition","transition with v-show"],"updatePoint":{"line":1839,"column":66},"line":1838,"code":"    test(\n      'transition events should not call onEnter with v-show false',\n      async () => {\n        const beforeEnterSpy = vi.fn()\n        const onEnterSpy = vi.fn()\n        const afterEnterSpy = vi.fn()\n\n        await page().exposeFunction('onEnterSpy', onEnterSpy)\n        await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n        await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n\n        await page().evaluate(() => {\n          const { beforeEnterSpy, onEnterSpy, afterEnterSpy } = window as any\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n            <div id=\"container\">\n              <transition\n                name=\"test\"\n                appear\n                @before-enter=\"beforeEnterSpy\"\n                @enter=\"onEnterSpy\"\n                @after-enter=\"afterEnterSpy\">\n                <div v-show=\"toggle\" class=\"test\">content</div>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n            setup: () => {\n              const toggle = ref(false)\n              const click = () => (toggle.value = !toggle.value)\n              return {\n                toggle,\n                click,\n                beforeEnterSpy,\n                onEnterSpy,\n                afterEnterSpy\n              }\n            }\n          }).mount('#app')\n        })\n        await nextTick()\n\n        expect(await isVisible('.test')).toBe(false)\n\n        expect(beforeEnterSpy).toBeCalledTimes(0)\n        expect(onEnterSpy).toBeCalledTimes(0)\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        expect(beforeEnterSpy).toBeCalledTimes(1)\n        expect(onEnterSpy).toBeCalledTimes(1)\n        expect(afterEnterSpy).not.toBeCalled()\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        expect(afterEnterSpy).not.toBeCalled()\n        await transitionFinish()\n        expect(await html('#container')).toBe(\n          '<div class=\"test\" style=\"\">content</div>'\n        )\n        expect(afterEnterSpy).toBeCalled()\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"single value","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":1913,"column":19},"line":1912,"code":"    test(\n      'single value',\n      async () => {\n        await page().evaluate(duration => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\" duration=\"${duration * 2}\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        }, duration)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"enter with explicit durations","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":1969,"column":36},"line":1968,"code":"    test(\n      'enter with explicit durations',\n      async () => {\n        await page().evaluate(duration => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\" :duration=\"{ enter: ${duration * 2} }\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        }, duration)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"leave with explicit durations","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2025,"column":36},"line":2024,"code":"    test(\n      'leave with explicit durations',\n      async () => {\n        await page().evaluate(duration => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\" :duration=\"{ leave: ${duration * 2} }\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        }, duration)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish()\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"separate enter and leave","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2081,"column":31},"line":2080,"code":"    test(\n      'separate enter and leave',\n      async () => {\n        await page().evaluate(duration => {\n          const { createApp, ref } = (window as any).Vue\n          createApp({\n            template: `\n              <div id=\"container\">\n                <transition name=\"test\" :duration=\"{\n                  enter: ${duration * 4},\n                  leave: ${duration * 2}\n                }\">\n                  <div v-if=\"toggle\" class=\"test\">content</div>\n                </transition>\n              </div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n            setup: () => {\n              const toggle = ref(true)\n              const click = () => (toggle.value = !toggle.value)\n              return { toggle, click }\n            }\n          }).mount('#app')\n        }, duration)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n\n        // leave\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-leave-from',\n          'test-leave-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-leave-active',\n          'test-leave-to'\n        ])\n        await transitionFinish(duration * 2)\n        expect(await html('#container')).toBe('<!--v-if-->')\n\n        // enter\n        expect(await classWhenTransitionStart()).toStrictEqual([\n          'test',\n          'test-enter-from',\n          'test-enter-active'\n        ])\n        await nextFrame()\n        expect(await classList('.test')).toStrictEqual([\n          'test',\n          'test-enter-active',\n          'test-enter-to'\n        ])\n        await transitionFinish(duration * 4)\n        expect(await html('#container')).toBe('<div class=\"test\">content</div>')\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"warn invalid durations","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2140,"column":29},"line":2139,"code":"    test(\n      'warn invalid durations',\n      async () => {\n        createApp({\n          template: `\n            <div id=\"container\">\n              <transition name=\"test\" :duration=\"NaN\">\n                <div class=\"test\">content</div>\n              </transition>\n            </div>\n          `\n        }).mount(document.createElement('div'))\n        expect(\n          `[Vue warn]: <transition> explicit duration is NaN - ` +\n            'the duration expression might be incorrect.'\n        ).toHaveBeenWarned()\n\n        createApp({\n          template: `\n            <div id=\"container\">\n              <transition name=\"test\" :duration=\"{\n                enter: {},\n                leave: {}\n              }\">\n                <div class=\"test\">content</div>\n              </transition>\n            </div>\n          `\n        }).mount(document.createElement('div'))\n        expect(\n          `[Vue warn]: <transition> explicit duration is not a valid number - ` +\n            `got ${JSON.stringify({})}`\n        ).toHaveBeenWarned()\n      },\n      E2E_TIMEOUT\n    )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"warn when used on multiple elements","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2177,"column":43},"line":2177,"code":"  test('warn when used on multiple elements', async () => {\n    createApp({\n      render() {\n        return h(Transition, null, {\n          default: () => [h('div'), h('div')]\n        })\n      }\n    }).mount(document.createElement('div'))\n    expect(\n      '<transition> can only be used on a single element or component'\n    ).toHaveBeenWarned()\n  })","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"warn when invalid transition mode","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2190,"column":41},"line":2190,"code":"  test('warn when invalid transition mode', () => {\n    createApp({\n      template: `\n        <div id=\"container\">\n          <transition name=\"test\" mode=\"none\">\n            <div class=\"test\">content</div>\n          </transition>\n        </div>\n      `\n    }).mount(document.createElement('div'))\n    expect(`invalid <transition> mode: none`).toHaveBeenWarned()\n  })","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"HOC w/ merged hooks","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2204,"column":27},"line":2204,"code":"  test(`HOC w/ merged hooks`, async () => {\n    const innerSpy = vi.fn()\n    const outerSpy = vi.fn()\n\n    const MyTransition = {\n      render(this: any) {\n        return h(\n          Transition,\n          {\n            onLeave(el, end) {\n              innerSpy()\n              end()\n            }\n          },\n          this.$slots.default\n        )\n      }\n    }\n\n    const toggle = ref(true)\n\n    const root = document.createElement('div')\n    createApp({\n      render() {\n        return h(MyTransition, { onLeave: () => outerSpy() }, () =>\n          toggle.value ? h('div') : null\n        )\n      }\n    }).mount(root)\n\n    expect(root.innerHTML).toBe(`<div></div>`)\n\n    toggle.value = false\n    await nextTick()\n    expect(innerSpy).toHaveBeenCalledTimes(1)\n    expect(outerSpy).toHaveBeenCalledTimes(1)\n    expect(root.innerHTML).toBe(`<!---->`)\n  })","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should work with dev root fragment","suites":["e2e: Transition","explicit durations"],"updatePoint":{"line":2244,"column":39},"line":2243,"code":"  test(\n    'should work with dev root fragment',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          components: {\n            Comp: {\n              template: `\n                  <!-- Broken! -->\n                  <div><slot /></div>\n                `\n            }\n          },\n          template: `\n            <div id=\"container\">\n              <transition>\n                <Comp class=\"test\" v-if=\"toggle\">\n                  <div>content</div>\n                </Comp>\n              </transition>\n            </div>\n            <button id=\"toggleBtn\" @click=\"click\">button</button>\n          `,\n          setup: () => {\n            const toggle = ref(true)\n            const click = () => (toggle.value = !toggle.value)\n            return { toggle, click }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        '<!-- Broken! --><div class=\"test\"><div>content</div></div>'\n      )\n\n      // leave\n      expect(await classWhenTransitionStart()).toStrictEqual([\n        'test',\n        'v-leave-from',\n        'v-leave-active'\n      ])\n      await nextFrame()\n      expect(await classList('.test')).toStrictEqual([\n        'test',\n        'v-leave-active',\n        'v-leave-to'\n      ])\n      await transitionFinish()\n      expect(await html('#container')).toBe('<!--v-if-->')\n\n      // enter\n      expect(await classWhenTransitionStart()).toStrictEqual([\n        'test',\n        'v-enter-from',\n        'v-enter-active'\n      ])\n      await nextFrame()\n      expect(await classList('.test')).toStrictEqual([\n        'test',\n        'v-enter-active',\n        'v-enter-to'\n      ])\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        '<!-- Broken! --><div class=\"test\"><div>content</div></div>'\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/Transition.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"enter","suites":["e2e: TransitionGroup"],"updatePoint":{"line":29,"column":10},"line":28,"code":"  test(\n    'enter',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group name=\"test\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => items.value.push('d', 'e')\n            return { click, items }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">d</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">e</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">d</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">e</div>`\n      )\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test\">d</div>` +\n          `<div class=\"test\">e</div>`\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"leave","suites":["e2e: TransitionGroup"],"updatePoint":{"line":83,"column":10},"line":82,"code":"  test(\n    'leave',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group name=\"test\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => (items.value = ['b'])\n            return { click, items }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test test-leave-from test-leave-active\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test test-leave-from test-leave-active\">c</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test test-leave-active test-leave-to\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test test-leave-active test-leave-to\">c</div>`\n      )\n      await transitionFinish()\n      expect(await html('#container')).toBe(`<div class=\"test\">b</div>`)\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"enter + leave","suites":["e2e: TransitionGroup"],"updatePoint":{"line":127,"column":18},"line":126,"code":"  test(\n    'enter + leave',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group name=\"test\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => (items.value = ['b', 'c', 'd'])\n            return { click, items }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test test-leave-from test-leave-active\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">d</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test test-leave-active test-leave-to\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">d</div>`\n      )\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test\">d</div>`\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"appear","suites":["e2e: TransitionGroup"],"updatePoint":{"line":177,"column":11},"line":176,"code":"  test(\n    'appear',\n    async () => {\n      const appearHtml = await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group appear\n\t\t\t\t\t\t\t\t\t\tappear-from-class=\"test-appear-from\"\n\t\t\t\t\t\t\t\t\t\tappear-to-class=\"test-appear-to\"\n\t\t\t\t\t\t\t\t\t\tappear-active-class=\"test-appear-active\"\n\t\t\t\t\t\t\t\t\t\tname=\"test\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => items.value.push('d', 'e')\n            return { click, items }\n          }\n        }).mount('#app')\n        return Promise.resolve().then(() => {\n          return document.querySelector('#container')!.innerHTML\n        })\n      })\n      // appear\n      expect(appearHtml).toBe(\n        `<div class=\"test test-appear-from test-appear-active\">a</div>` +\n          `<div class=\"test test-appear-from test-appear-active\">b</div>` +\n          `<div class=\"test test-appear-from test-appear-active\">c</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test test-appear-active test-appear-to\">a</div>` +\n          `<div class=\"test test-appear-active test-appear-to\">b</div>` +\n          `<div class=\"test test-appear-active test-appear-to\">c</div>`\n      )\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      // enter\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">d</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">e</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">d</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">e</div>`\n      )\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test\">d</div>` +\n          `<div class=\"test\">e</div>`\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"move","suites":["e2e: TransitionGroup"],"updatePoint":{"line":252,"column":9},"line":251,"code":"  test(\n    'move',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group name=\"group\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n            `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => (items.value = ['d', 'b', 'a'])\n            return { click, items }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test group-enter-from group-enter-active\">d</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test group-move\" style=\"\">a</div>` +\n          `<div class=\"test group-leave-from group-leave-active group-move\" style=\"\">c</div>`\n      )\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test group-enter-active group-enter-to\">d</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test group-move\" style=\"\">a</div>` +\n          `<div class=\"test group-leave-active group-move group-leave-to\" style=\"\">c</div>`\n      )\n      await transitionFinish(duration * 2)\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">d</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\" style=\"\">a</div>`\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"dynamic name","suites":["e2e: TransitionGroup"],"updatePoint":{"line":302,"column":17},"line":301,"code":"  test(\n    'dynamic name',\n    async () => {\n      await page().evaluate(() => {\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n              <div id=\"container\">\n\t\t\t\t\t\t\t\t<transition-group :name=\"name\">\n\t\t\t\t\t\t\t\t\t<div v-for=\"item in items\" :key=\"item\" >{{item}}</div>\n\t\t\t\t\t\t\t\t</transition-group>\n\t\t\t\t\t\t\t</div>\n              <button id=\"toggleBtn\" @click=\"click\">button</button>\n              <button id=\"changeNameBtn\" @click=\"changeName\">button</button>\n\t\t\t\t\t`,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const name = ref('invalid')\n            const click = () => (items.value = ['b', 'c', 'a'])\n            const changeName = () => {\n              name.value = 'group'\n              items.value = ['a', 'b', 'c']\n            }\n            return { click, items, name, changeName }\n          }\n        }).mount('#app')\n      })\n      expect(await html('#container')).toBe(\n        `<div>a</div>` + `<div>b</div>` + `<div>c</div>`\n      )\n\n      // invalid name\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div>b</div>` + `<div>c</div>` + `<div>a</div>`\n      )\n      // change name\n      const moveHtml = await page().evaluate(() => {\n        ;(document.querySelector('#changeNameBtn') as any).click()\n        return Promise.resolve().then(() => {\n          return document.querySelector('#container')!.innerHTML\n        })\n      })\n      expect(moveHtml).toBe(\n        `<div class=\"group-move\" style=\"\">a</div>` +\n          `<div class=\"group-move\" style=\"\">b</div>` +\n          `<div class=\"group-move\" style=\"\">c</div>`\n      )\n      // not sure why but we just have to wait really long for this to\n      // pass consistently :/\n      await transitionFinish(duration * 4 + buffer)\n      expect(await html('#container')).toBe(\n        `<div class=\"\" style=\"\">a</div>` +\n          `<div class=\"\" style=\"\">b</div>` +\n          `<div class=\"\" style=\"\">c</div>`\n      )\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"events","suites":["e2e: TransitionGroup"],"updatePoint":{"line":361,"column":11},"line":360,"code":"  test(\n    'events',\n    async () => {\n      const onLeaveSpy = vi.fn()\n      const onEnterSpy = vi.fn()\n      const onAppearSpy = vi.fn()\n      const beforeLeaveSpy = vi.fn()\n      const beforeEnterSpy = vi.fn()\n      const beforeAppearSpy = vi.fn()\n      const afterLeaveSpy = vi.fn()\n      const afterEnterSpy = vi.fn()\n      const afterAppearSpy = vi.fn()\n\n      await page().exposeFunction('onLeaveSpy', onLeaveSpy)\n      await page().exposeFunction('onEnterSpy', onEnterSpy)\n      await page().exposeFunction('onAppearSpy', onAppearSpy)\n      await page().exposeFunction('beforeLeaveSpy', beforeLeaveSpy)\n      await page().exposeFunction('beforeEnterSpy', beforeEnterSpy)\n      await page().exposeFunction('beforeAppearSpy', beforeAppearSpy)\n      await page().exposeFunction('afterLeaveSpy', afterLeaveSpy)\n      await page().exposeFunction('afterEnterSpy', afterEnterSpy)\n      await page().exposeFunction('afterAppearSpy', afterAppearSpy)\n\n      const appearHtml = await page().evaluate(() => {\n        const {\n          beforeAppearSpy,\n          onAppearSpy,\n          afterAppearSpy,\n          beforeEnterSpy,\n          onEnterSpy,\n          afterEnterSpy,\n          beforeLeaveSpy,\n          onLeaveSpy,\n          afterLeaveSpy\n        } = window as any\n        const { createApp, ref } = (window as any).Vue\n        createApp({\n          template: `\n                <div id=\"container\">\n                  <transition-group name=\"test\"\n                      appear\n                      appear-from-class=\"test-appear-from\"\n                      appear-to-class=\"test-appear-to\"\n                      appear-active-class=\"test-appear-active\"\n                      @before-enter=\"beforeEnterSpy\"\n                      @enter=\"onEnterSpy\"\n                      @after-enter=\"afterEnterSpy\"\n                      @before-leave=\"beforeLeaveSpy\"\n                      @leave=\"onLeaveSpy\"\n                      @after-leave=\"afterLeaveSpy\"\n                      @before-appear=\"beforeAppearSpy\"\n                      @appear=\"onAppearSpy\"\n                      @after-appear=\"afterAppearSpy\">\n                    <div v-for=\"item in items\" :key=\"item\" class=\"test\">{{item}}</div>\n                  </transition-group>\n                </div>\n                <button id=\"toggleBtn\" @click=\"click\">button</button>\n              `,\n          setup: () => {\n            const items = ref(['a', 'b', 'c'])\n            const click = () => (items.value = ['b', 'c', 'd'])\n            return {\n              click,\n              items,\n              beforeAppearSpy,\n              onAppearSpy,\n              afterAppearSpy,\n              beforeEnterSpy,\n              onEnterSpy,\n              afterEnterSpy,\n              beforeLeaveSpy,\n              onLeaveSpy,\n              afterLeaveSpy\n            }\n          }\n        }).mount('#app')\n        return Promise.resolve().then(() => {\n          return document.querySelector('#container')!.innerHTML\n        })\n      })\n      expect(beforeAppearSpy).toBeCalled()\n      expect(onAppearSpy).toBeCalled()\n      expect(afterAppearSpy).not.toBeCalled()\n      expect(appearHtml).toBe(\n        `<div class=\"test test-appear-from test-appear-active\">a</div>` +\n          `<div class=\"test test-appear-from test-appear-active\">b</div>` +\n          `<div class=\"test test-appear-from test-appear-active\">c</div>`\n      )\n      await nextFrame()\n      expect(afterAppearSpy).not.toBeCalled()\n      expect(await html('#container')).toBe(\n        `<div class=\"test test-appear-active test-appear-to\">a</div>` +\n          `<div class=\"test test-appear-active test-appear-to\">b</div>` +\n          `<div class=\"test test-appear-active test-appear-to\">c</div>`\n      )\n      await transitionFinish()\n      expect(afterAppearSpy).toBeCalled()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>`\n      )\n\n      // enter + leave\n      expect(await htmlWhenTransitionStart()).toBe(\n        `<div class=\"test test-leave-from test-leave-active\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-from test-enter-active\">d</div>`\n      )\n      expect(beforeLeaveSpy).toBeCalled()\n      expect(onLeaveSpy).toBeCalled()\n      expect(afterLeaveSpy).not.toBeCalled()\n      expect(beforeEnterSpy).toBeCalled()\n      expect(onEnterSpy).toBeCalled()\n      expect(afterEnterSpy).not.toBeCalled()\n      await nextFrame()\n      expect(await html('#container')).toBe(\n        `<div class=\"test test-leave-active test-leave-to\">a</div>` +\n          `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test test-enter-active test-enter-to\">d</div>`\n      )\n      expect(afterLeaveSpy).not.toBeCalled()\n      expect(afterEnterSpy).not.toBeCalled()\n      await transitionFinish()\n      expect(await html('#container')).toBe(\n        `<div class=\"test\">b</div>` +\n          `<div class=\"test\">c</div>` +\n          `<div class=\"test\">d</div>`\n      )\n      expect(afterLeaveSpy).toBeCalled()\n      expect(afterEnterSpy).toBeCalled()\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"warn unkeyed children","suites":["e2e: TransitionGroup"],"updatePoint":{"line":497,"column":29},"line":497,"code":"  test('warn unkeyed children', () => {\n    createApp({\n      template: `\n        <transition-group name=\"test\">\n          <div v-for=\"item in items\" class=\"test\">{{item}}</div>\n        </transition-group>\n            `,\n      setup: () => {\n        const items = ref(['a', 'b', 'c'])\n        return { items }\n      }\n    }).mount(document.createElement('div'))\n\n    expect(`<TransitionGroup> children must be keyed`).toHaveBeenWarned()\n  })","file":"e2e/TransitionGroup.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"classic","suites":["e2e: tree"],"updatePoint":{"line":101,"column":12},"line":100,"code":"  test(\n    'classic',\n    async () => {\n      await testTree('classic')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/tree.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"composition","suites":["e2e: tree"],"updatePoint":{"line":109,"column":16},"line":108,"code":"  test(\n    'composition',\n    async () => {\n      await testTree('composition')\n    },\n    E2E_TIMEOUT\n  )","file":"e2e/tree.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support runtime template compilation","suites":["compiler + runtime integration"],"updatePoint":{"line":6,"column":49},"line":6,"code":"  it('should support runtime template compilation', () => {\n    const container = document.createElement('div')\n    const App = {\n      template: `{{ count }}`,\n      data() {\n        return {\n          count: 0\n        }\n      }\n    }\n    createApp(App).mount(container)\n    expect(container.innerHTML).toBe(`0`)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"keep-alive with compiler + runtime integration","suites":["compiler + runtime integration"],"updatePoint":{"line":20,"column":52},"line":20,"code":"  it('keep-alive with compiler + runtime integration', async () => {\n    const container = document.createElement('div')\n    const one = {\n      name: 'one',\n      template: 'one',\n      created: vi.fn(),\n      mounted: vi.fn(),\n      activated: vi.fn(),\n      deactivated: vi.fn(),\n      unmounted: vi.fn()\n    }\n\n    const toggle = ref(true)\n\n    const App = {\n      template: `\n        <keep-alive>\n          <one v-if=\"toggle\"></one>\n        </keep-alive>\n      `,\n      data() {\n        return {\n          toggle\n        }\n      },\n      components: {\n        One: one\n      }\n    }\n    createApp(App).mount(container)\n    expect(container.innerHTML).toBe(`one`)\n    expect(one.created).toHaveBeenCalledTimes(1)\n    expect(one.mounted).toHaveBeenCalledTimes(1)\n    expect(one.activated).toHaveBeenCalledTimes(1)\n    expect(one.deactivated).toHaveBeenCalledTimes(0)\n    expect(one.unmounted).toHaveBeenCalledTimes(0)\n\n    toggle.value = false\n    await nextTick()\n    expect(container.innerHTML).toBe(`<!--v-if-->`)\n    expect(one.created).toHaveBeenCalledTimes(1)\n    expect(one.mounted).toHaveBeenCalledTimes(1)\n    expect(one.activated).toHaveBeenCalledTimes(1)\n    expect(one.deactivated).toHaveBeenCalledTimes(1)\n    expect(one.unmounted).toHaveBeenCalledTimes(0)\n\n    toggle.value = true\n    await nextTick()\n    expect(container.innerHTML).toBe(`one`)\n    expect(one.created).toHaveBeenCalledTimes(1)\n    expect(one.mounted).toHaveBeenCalledTimes(1)\n    expect(one.activated).toHaveBeenCalledTimes(2)\n    expect(one.deactivated).toHaveBeenCalledTimes(1)\n    expect(one.unmounted).toHaveBeenCalledTimes(0)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support runtime template via CSS ID selector","suites":["compiler + runtime integration"],"updatePoint":{"line":76,"column":57},"line":76,"code":"  it('should support runtime template via CSS ID selector', () => {\n    const container = document.createElement('div')\n    const template = document.createElement('div')\n    template.id = 'template'\n    template.innerHTML = '{{ count }}'\n    document.body.appendChild(template)\n\n    const App = {\n      template: `#template`,\n      data() {\n        return {\n          count: 0\n        }\n      }\n    }\n    createApp(App).mount(container)\n    expect(container.innerHTML).toBe(`0`)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support runtime template via direct DOM node","suites":["compiler + runtime integration"],"updatePoint":{"line":95,"column":57},"line":95,"code":"  it('should support runtime template via direct DOM node', () => {\n    const container = document.createElement('div')\n    const template = document.createElement('div')\n    template.id = 'template'\n    template.innerHTML = '{{ count }}'\n\n    const App = {\n      template,\n      data() {\n        return {\n          count: 0\n        }\n      }\n    }\n    createApp(App).mount(container)\n    expect(container.innerHTML).toBe(`0`)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should warn template compilation errors with codeframe","suites":["compiler + runtime integration"],"updatePoint":{"line":113,"column":60},"line":113,"code":"  it('should warn template compilation errors with codeframe', () => {\n    const container = document.createElement('div')\n    const App = {\n      template: `<div v-if>`\n    }\n    createApp(App).mount(container)\n    expect(\n      `Template compilation error: Element is missing end tag`\n    ).toHaveBeenWarned()\n    expect(\n      `\n1  |  <div v-if>\n   |  ^`.trim()\n    ).toHaveBeenWarned()\n    expect(`v-if/v-else-if is missing expression`).toHaveBeenWarned()\n    expect(\n      `\n1  |  <div v-if>\n   |       ^^^^`.trim()\n    ).toHaveBeenWarned()\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support custom element via config.isCustomElement (deprecated)","suites":["compiler + runtime integration"],"updatePoint":{"line":135,"column":75},"line":135,"code":"  it('should support custom element via config.isCustomElement (deprecated)', () => {\n    const app = createApp({\n      template: '<custom></custom>'\n    })\n    const container = document.createElement('div')\n    app.config.isCustomElement = tag => tag === 'custom'\n    app.mount(container)\n    expect(container.innerHTML).toBe('<custom></custom>')\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support custom element via config.compilerOptions.isCustomElement","suites":["compiler + runtime integration"],"updatePoint":{"line":145,"column":78},"line":145,"code":"  it('should support custom element via config.compilerOptions.isCustomElement', () => {\n    const app = createApp({\n      template: '<custom></custom>'\n    })\n    const container = document.createElement('div')\n    app.config.compilerOptions.isCustomElement = tag => tag === 'custom'\n    app.mount(container)\n    expect(container.innerHTML).toBe('<custom></custom>')\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support using element innerHTML as template","suites":["compiler + runtime integration"],"updatePoint":{"line":155,"column":56},"line":155,"code":"  it('should support using element innerHTML as template', () => {\n    const app = createApp({\n      data: () => ({\n        msg: 'hello'\n      })\n    })\n    const container = document.createElement('div')\n    container.innerHTML = '{{msg}}'\n    app.mount(container)\n    expect(container.innerHTML).toBe('hello')\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should support selector of rootContainer","suites":["compiler + runtime integration"],"updatePoint":{"line":167,"column":46},"line":167,"code":"  it('should support selector of rootContainer', () => {\n    const container = document.createElement('div')\n    const origin = document.querySelector\n    document.querySelector = vi.fn().mockReturnValue(container)\n\n    const App = {\n      template: `{{ count }}`,\n      data() {\n        return {\n          count: 0\n        }\n      }\n    }\n    createApp(App).mount('#app')\n    expect(container.innerHTML).toBe(`0`)\n    document.querySelector = origin\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should warn when template is not available","suites":["compiler + runtime integration"],"updatePoint":{"line":185,"column":48},"line":185,"code":"  it('should warn when template is not available', () => {\n    const app = createApp({\n      template: {}\n    })\n    const container = document.createElement('div')\n    app.mount(container)\n    expect('[Vue warn]: invalid template option:').toHaveBeenWarned()\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should warn when template is is not found","suites":["compiler + runtime integration"],"updatePoint":{"line":194,"column":47},"line":194,"code":"  it('should warn when template is is not found', () => {\n    const app = createApp({\n      template: '#not-exist-id'\n    })\n    const container = document.createElement('div')\n    app.mount(container)\n    expect(\n      '[Vue warn]: Template element not found or is empty: #not-exist-id'\n    ).toHaveBeenWarned()\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should warn when container is not found","suites":["compiler + runtime integration"],"updatePoint":{"line":205,"column":45},"line":205,"code":"  it('should warn when container is not found', () => {\n    const origin = document.querySelector\n    document.querySelector = vi.fn().mockReturnValue(null)\n    const App = {\n      template: `{{ count }}`,\n      data() {\n        return {\n          count: 0\n        }\n      }\n    }\n    createApp(App).mount('#not-exist-id')\n\n    expect(\n      '[Vue warn]: Failed to mount app: mount target selector \"#not-exist-id\" returned null.'\n    ).toHaveBeenWarned()\n    document.querySelector = origin\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should not report an error when \"0\" as patchFlag value","suites":["compiler + runtime integration"],"updatePoint":{"line":225,"column":60},"line":225,"code":"  it('should not report an error when \"0\" as patchFlag value', async () => {\n    const container = document.createElement('div')\n    const target = document.createElement('div')\n    const count = ref(0)\n    const origin = document.querySelector\n    document.querySelector = vi.fn().mockReturnValue(target)\n\n    const App = {\n      template: `\n      <teleport v-if=\"count < 2\" to=\"#target\">\n        <div>\n          <div>{{ count }}</div>\n        </div>\n      </teleport>\n      `,\n      data() {\n        return {\n          count\n        }\n      }\n    }\n    createApp(App).mount(container)\n    expect(container.innerHTML).toBe(`<!--teleport start--><!--teleport end-->`)\n    expect(target.innerHTML).toBe(`<div><div>0</div></div>`)\n\n    count.value++\n    await nextTick()\n    expect(container.innerHTML).toBe(`<!--teleport start--><!--teleport end-->`)\n    expect(target.innerHTML).toBe(`<div><div>1</div></div>`)\n\n    count.value++\n    await nextTick()\n    expect(container.innerHTML).toBe(`<!--v-if-->`)\n    expect(target.innerHTML).toBe(``)\n\n    document.querySelector = origin\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"v-if + v-once","suites":["compiler + runtime integration"],"updatePoint":{"line":263,"column":21},"line":263,"code":"  test('v-if + v-once', async () => {\n    const ok = ref(true)\n    const App = {\n      setup() {\n        return { ok }\n      },\n      template: `<div>{{ ok }}<div v-if=\"ok\" v-once>{{ ok }}</div></div>`\n    }\n    const container = document.createElement('div')\n    createApp(App).mount(container)\n\n    expect(container.innerHTML).toBe(`<div>true<div>true</div></div>`)\n    ok.value = false\n    await nextTick()\n    expect(container.innerHTML).toBe(`<div>false<div>true</div></div>`)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"v-for + v-once","suites":["compiler + runtime integration"],"updatePoint":{"line":280,"column":22},"line":280,"code":"  test('v-for + v-once', async () => {\n    const list = reactive([1])\n    const App = {\n      setup() {\n        return { list }\n      },\n      template: `<div>{{ list.length }}<div v-for=\"i in list\" v-once>{{ i }}</div></div>`\n    }\n    const container = document.createElement('div')\n    createApp(App).mount(container)\n\n    expect(container.innerHTML).toBe(`<div>1<div>1</div></div>`)\n    list.push(2)\n    await nextTick()\n    expect(container.innerHTML).toBe(`<div>2<div>1</div></div>`)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"EMPTY_ARR should not change","suites":["compiler + runtime integration"],"updatePoint":{"line":298,"column":33},"line":298,"code":"  it('EMPTY_ARR should not change', () => {\n    const App = {\n      template: `<div v-for=\"v of ['a']\">{{ v }}</div>`\n    }\n    const container = document.createElement('div')\n    createApp(App).mount(container)\n    expect(EMPTY_ARR.length).toBe(0)\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"BigInt support","suites":["compiler + runtime integration"],"updatePoint":{"line":307,"column":22},"line":307,"code":"  test('BigInt support', () => {\n    const app = createApp({\n      template: `<div>{{ BigInt(BigInt(100000111)) + BigInt(2000000000n) * 30000000n }}</div>`\n    })\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.innerHTML).toBe('<div>60000000100000111</div>')\n  })","file":"index.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"isCustomElement","suites":["config.compilerOptions"],"updatePoint":{"line":4,"column":23},"line":4,"code":"  test('isCustomElement', () => {\n    const app = createApp({\n      template: `<foo/>`\n    })\n    app.config.compilerOptions.isCustomElement = (tag: string) => tag === 'foo'\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.innerHTML).toBe('<foo></foo>')\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"comments","suites":["config.compilerOptions"],"updatePoint":{"line":14,"column":16},"line":14,"code":"  test('comments', () => {\n    const app = createApp({\n      template: `<div/><!--test--><div/>`\n    })\n    app.config.compilerOptions.comments = true\n    // the comments option is only relevant in production mode\n    __DEV__ = false\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.innerHTML).toBe('<div></div><!--test--><div></div>')\n    __DEV__ = true\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"whitespace","suites":["config.compilerOptions"],"updatePoint":{"line":27,"column":18},"line":27,"code":"  test('whitespace', () => {\n    const app = createApp({\n      template: `<div><span/>\\n  <span/></div>`\n    })\n    app.config.compilerOptions.whitespace = 'preserve'\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.firstChild!.childNodes.length).toBe(3)\n    expect(root.firstChild!.childNodes[1].nodeType).toBe(Node.TEXT_NODE)\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"delimiters","suites":["config.compilerOptions"],"updatePoint":{"line":38,"column":18},"line":38,"code":"  test('delimiters', () => {\n    const app = createApp({\n      data: () => ({ foo: 'hi' }),\n      template: `[[ foo ]]`\n    })\n    app.config.compilerOptions.delimiters = [`[[`, `]]`]\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.textContent).toBe('hi')\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"isCustomElement","suites":["per-component compilerOptions"],"updatePoint":{"line":51,"column":23},"line":51,"code":"  test('isCustomElement', () => {\n    const app = createApp({\n      template: `<foo/>`,\n      compilerOptions: {\n        isCustomElement: (tag: string) => tag === 'foo'\n      }\n    })\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.innerHTML).toBe('<foo></foo>')\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"comments","suites":["per-component compilerOptions"],"updatePoint":{"line":63,"column":16},"line":63,"code":"  test('comments', () => {\n    const app = createApp({\n      template: `<div/><!--test--><div/>`,\n      compilerOptions: {\n        comments: true\n      }\n    })\n    app.config.compilerOptions.comments = false\n    // the comments option is only relevant in production mode\n    __DEV__ = false\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.innerHTML).toBe('<div></div><!--test--><div></div>')\n    __DEV__ = true\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"whitespace","suites":["per-component compilerOptions"],"updatePoint":{"line":79,"column":18},"line":79,"code":"  test('whitespace', () => {\n    const app = createApp({\n      template: `<div><span/>\\n  <span/></div>`,\n      compilerOptions: {\n        whitespace: 'preserve'\n      }\n    })\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.firstChild!.childNodes.length).toBe(3)\n    expect(root.firstChild!.childNodes[1].nodeType).toBe(Node.TEXT_NODE)\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"delimiters","suites":["per-component compilerOptions"],"updatePoint":{"line":92,"column":18},"line":92,"code":"  test('delimiters', () => {\n    const app = createApp({\n      data: () => ({ foo: 'hi' }),\n      template: `[[ foo ]]`,\n      compilerOptions: {\n        delimiters: [`[[`, `]]`]\n      }\n    })\n    const root = document.createElement('div')\n    app.mount(root)\n    expect(root.textContent).toBe('hi')\n  })","file":"runtimeCompilerOptions.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should mount elements with correct namespaces","suites":["SVG support"],"updatePoint":{"line":11,"column":53},"line":11,"code":"  test('should mount elements with correct namespaces', () => {\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    const App = {\n      template: `\n        <div id=\"e0\">\n          <svg id=\"e1\">\n            <foreignObject id=\"e2\">\n              <div id=\"e3\"/>\n            </foreignObject>\n          </svg>\n        </div>\n      `\n    }\n    render(h(App), root)\n    const e0 = document.getElementById('e0')!\n    expect(e0.namespaceURI).toMatch('xhtml')\n    expect(e0.querySelector('#e1')!.namespaceURI).toMatch('svg')\n    expect(e0.querySelector('#e2')!.namespaceURI).toMatch('svg')\n    expect(e0.querySelector('#e3')!.namespaceURI).toMatch('xhtml')\n  })","file":"svgNamespace.spec.ts","skipped":false,"dir":"packages/vue/__tests__"},{"name":"should patch elements with correct namespaces","suites":["SVG support"],"updatePoint":{"line":33,"column":53},"line":33,"code":"  test('should patch elements with correct namespaces', async () => {\n    const root = document.createElement('div')\n    document.body.appendChild(root)\n    const cls = ref('foo')\n    const App = {\n      setup: () => ({ cls }),\n      template: `\n        <div>\n          <svg id=\"f1\" :class=\"cls\">\n            <foreignObject>\n              <div id=\"f2\" :class=\"cls\"/>\n            </foreignObject>\n          </svg>\n        </div>\n      `\n    }\n    render(h(App), root)\n    const f1 = document.querySelector('#f1')!\n    const f2 = document.querySelector('#f2')!\n    expect(f1.getAttribute('class')).toBe('foo')\n    expect(f2.className).toBe('foo')\n\n    // set a transition class on the <div> - which is only respected on non-svg\n    // patches\n    ;(f2 as any)._vtc = ['baz']\n    cls.value = 'bar'\n    await nextTick()\n    expect(f1.getAttribute('class')).toBe('bar')\n    expect(f2.className).toBe('bar baz')\n  })","file":"svgNamespace.spec.ts","skipped":false,"dir":"packages/vue/__tests__"}]}