{"repo":"auth0/node-jsonwebtoken","url":"https://github.com/auth0/node-jsonwebtoken","branch":"master","configs":[{"package":"jsonwebtoken","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should error with with value ","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":34,"column":64,"index":830},"line":34,"code":"      it(`should error with with value ${util.inspect(audience)}`, function (done) {\n        signWithAudience(audience, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"audience\" must be a string or array');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":44,"column":46,"index":1261},"line":44,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        audience: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"audience\" must be a string or array');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error when \"aud\" is in payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":55,"column":45,"index":1657},"line":55,"code":"    it('should error when \"aud\" is in payload', function (done) {\n      signWithAudience('my_aud', {\n        aud: ''\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.audience\" option. The payload already has an \"aud\" property.');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":65,"column":42,"index":2037},"line":65,"code":"    it('should error with a string payload', function (done) {\n      signWithAudience('my_aud', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for string payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":73,"column":42,"index":2379},"line":73,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithAudience('my_aud', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for object payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":92,"column":95,"index":3315},"line":92,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud', 'urn:foo');\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":101,"column":73,"index":3678},"line":101,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":109,"column":83,"index":4088},"line":109,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":117,"column":72,"index":4529},"line":117,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":125,"column":82,"index":4944},"line":125,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":133,"column":100,"index":5425},"line":133,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":151,"column":95,"index":6375},"line":151,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":160,"column":73,"index":6763},"line":160,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":168,"column":83,"index":7173},"line":168,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":176,"column":72,"index":7614},"line":176,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":184,"column":82,"index":8029},"line":184,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":192,"column":100,"index":8510},"line":192,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of stings verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":201,"column":74,"index":9044},"line":201,"code":"        it('should verify with an array of stings verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:foo', 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":209,"column":63,"index":9426},"line":209,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:[a-z]{3}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":217,"column":73,"index":9812},"line":217,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:f[o]{2}$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":227,"column":57,"index":10286},"line":227,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:foo', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":235,"column":63,"index":10655},"line":235,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:f[o]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":243,"column":66,"index":11033},"line":243,"code":"        it('should verify with an array of Regex verify \"audience\"', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":251,"column":96,"index":11461},"line":251,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":259,"column":96,"index":11887},"line":259,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:foo'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":269,"column":57,"index":12349},"line":269,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:bar', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":277,"column":63,"index":12718},"line":277,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:b[ar]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":285,"column":73,"index":13104},"line":285,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":293,"column":96,"index":13533},"line":293,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":301,"column":96,"index":13960},"line":301,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode without verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":319,"column":67,"index":14604},"line":319,"code":"      it('should verify and decode without verify \"audience\" option', function (done) {\n        verifyWithAudience(token, undefined, (err, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.null;\n            expect(decoded).to.not.have.property('aud');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":327,"column":73,"index":14937},"line":327,"code":"      it('should error on no match with a string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":335,"column":83,"index":15347},"line":335,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":343,"column":72,"index":15788},"line":343,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":351,"column":82,"index":16203},"line":351,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":359,"column":100,"index":16684},"line":359,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":33,"column":65,"index":875},"line":33,"code":"      it(`should error with with value ${util.inspect(expiresIn)}`, function (done) {\n        signWithExpiresIn(expiresIn, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"expiresIn\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":43,"column":46,"index":1359},"line":43,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        expiresIn: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"expiresIn\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error when \"exp\" is in payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":54,"column":45,"index":1796},"line":54,"code":"    it('should error when \"exp\" is in payload', function (done) {\n      signWithExpiresIn(100, {\n        exp: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.expiresIn\" option the payload already has an \"exp\" property.');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":64,"column":42,"index":2173},"line":64,"code":"    it('should error with a string payload', function (done) {\n      signWithExpiresIn(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for string payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":72,"column":42,"index":2512},"line":72,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithExpiresIn(100, Buffer.from('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for object payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"exp\" claim validation"],"updatePoint":{"line":85,"column":59,"index":3064},"line":85,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        signWithExpiresIn(undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"exp\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","\"exp\" in payload validation"],"updatePoint":{"line":101,"column":59,"index":3639},"line":101,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          exp\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid exp value');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":127,"column":64,"index":4477},"line":127,"code":"    it('should set correct \"exp\" with negative number of seconds', function (done) {\n      signWithExpiresIn(-10, {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":139,"column":64,"index":4935},"line":139,"code":"    it('should set correct \"exp\" with positive number of seconds', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":150,"column":50,"index":5346},"line":150,"code":"    it('should set correct \"exp\" with zero seconds', function (done) {\n      signWithExpiresIn(0, {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":162,"column":62,"index":5796},"line":162,"code":"    it('should set correct \"exp\" with negative string timespan', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":174,"column":62,"index":6256},"line":174,"code":"    it('should set correct \"exp\" with positive string timespan', function (done) {\n      signWithExpiresIn('10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":186,"column":58,"index":6711},"line":186,"code":"    it('should set correct \"exp\" with zero string timespan', function (done) {\n      signWithExpiresIn('0 s', {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    }); // TODO an exp of -Infinity should fail validation","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given -Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":199,"column":50,"index":7205},"line":199,"code":"    it('should set null \"exp\" when given -Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    }); // TODO an exp of Infinity should fail validation","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":211,"column":55,"index":7626},"line":211,"code":"    it('should set null \"exp\" when given value Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    }); // TODO an exp of NaN should fail validation","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value NaN","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":223,"column":50,"index":8036},"line":223,"code":"    it('should set null \"exp\" when given value NaN', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" when \"iat\" is passed","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":234,"column":53,"index":8398},"line":234,"code":"    it('should set correct \"exp\" when \"iat\" is passed', function (done) {\n      signWithExpiresIn(-10, {\n        iat: 80\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTimestamp\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":247,"column":50,"index":8833},"line":247,"code":"    it('should verify \"exp\" using \"clockTimestamp\"', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 69\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTolerance\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":261,"column":50,"index":9339},"line":261,"code":"    it('should verify \"exp\" using \"clockTolerance\"', function (done) {\n      signWithExpiresIn(5, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 65);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should ignore a expired token when \"ignoreExpiration\" is true","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":276,"column":69,"index":9893},"line":276,"code":"    it('should ignore a expired token when \"ignoreExpiration\" is true', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreExpiration: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is at current time","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":290,"column":58,"index":10416},"line":290,"code":"    it('should error on verify if \"exp\" is at current time', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: 60\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is before current time using clockTolerance","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":303,"column":83,"index":10918},"line":303,"code":"    it('should error on verify if \"exp\" is before current time using clockTolerance', function (done) {\n      signWithExpiresIn(-5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 5\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":43,"column":55,"index":1127},"line":43,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        signWithIssueAt(iat, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err.message).to.equal('\"iat\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of undefined","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":53,"column":42,"index":1536},"line":53,"code":"    it('should error with iat of undefined', function (done) {\n      testUtils.signJWTHelper({\n        iat: undefined\n      }, 'secret', {\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err.message).to.equal('\"iat\" should be a number of seconds');\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","\"iat\" in payload with \"maxAge\" option validation"],"updatePoint":{"line":70,"column":55,"index":2150},"line":70,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          iat\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        verifyWithIssueAt(token, '1 min', {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err.message).to.equal('iat required when maxAge is specified');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to string","suites":["issue at","with string payload"],"updatePoint":{"line":240,"column":36,"index":7425},"line":240,"code":"    it('should not add iat to string', function (done) {\n      const payload = 'string payload';\n      const options = {\n        algorithm: 'none'\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to stringified object","suites":["issue at","with string payload"],"updatePoint":{"line":253,"column":48,"index":7864},"line":253,"code":"    it('should not add iat to stringified object', function (done) {\n      const payload = '{}';\n      const options = {\n        algorithm: 'none',\n        header: {\n          typ: 'JWT'\n        }\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.equal(null);\n          expect(JSON.stringify(decoded)).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":28,"column":62,"index":688},"line":28,"code":"      it(`should error with with value ${util.inspect(issuer)}`, function (done) {\n        signWithIssuer(issuer, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"issuer\" must be a string');\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":38,"column":46,"index":1107},"line":38,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        issuer: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"issuer\" must be a string');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error when \"iss\" is in payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":49,"column":45,"index":1491},"line":49,"code":"    it('should error when \"iss\" is in payload', function (done) {\n      signWithIssuer('foo', {\n        iss: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.issuer\" option. The payload already has an \"iss\" property.');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":59,"column":42,"index":1867},"line":59,"code":"    it('should error with a string payload', function (done) {\n      signWithIssuer('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for string payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":67,"column":42,"index":2202},"line":67,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithIssuer('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for object payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"iss\" if verify \"issuer\" option not provided","suites":["issuer","when signing and verifying a token"],"updatePoint":{"line":77,"column":70,"index":2646},"line":77,"code":"    it('should not verify \"iss\" if verify \"issuer\" option not provided', function (done) {\n      signWithIssuer(undefined, {\n        iss: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iss', 'foo');\n          });\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":91,"column":46,"index":3144},"line":91,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":104,"column":43,"index":3608},"line":104,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":119,"column":69,"index":4132},"line":119,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":134,"column":68,"index":4705},"line":134,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":149,"column":46,"index":5288},"line":149,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('bar', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":162,"column":43,"index":5761},"line":162,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":177,"column":69,"index":6294},"line":177,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":192,"column":68,"index":6880},"line":192,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":28,"column":61,"index":679},"line":28,"code":"      it(`should error with with value ${util.inspect(jwtid)}`, function (done) {\n        signWithJWTId(jwtid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"jwtid\" must be a string');\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":38,"column":46,"index":1094},"line":38,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        jwtid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"jwtid\" must be a string');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error when \"jti\" is in payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":49,"column":45,"index":1476},"line":49,"code":"    it('should error when \"jti\" is in payload', function (done) {\n      signWithJWTId('foo', {\n        jti: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.jwtid\" option. The payload already has an \"jti\" property.');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":59,"column":42,"index":1850},"line":59,"code":"    it('should error with a string payload', function (done) {\n      signWithJWTId('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for string payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":67,"column":42,"index":2183},"line":67,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithJWTId('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for object payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"jti\" if verify \"jwtid\" option not provided","suites":["jwtid","when signing and verifying a token"],"updatePoint":{"line":77,"column":69,"index":2624},"line":77,"code":"    it('should not verify \"jti\" if verify \"jwtid\" option not provided', function (done) {\n      signWithJWTId(undefined, {\n        jti: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('jti', 'foo');\n          });\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":91,"column":43,"index":3110},"line":91,"code":"      it('should verify with \"jwtid\" option', function (done) {\n        signWithJWTId('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jti\" in payload","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":104,"column":45,"index":3574},"line":104,"code":"      it('should verify with \"jti\" in payload', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jetid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error if \"jti\" does not match verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":119,"column":68,"index":4095},"line":119,"code":"      it('should error if \"jti\" does not match verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'bar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error without \"jti\" and with verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":134,"column":67,"index":4661},"line":134,"code":"      it('should error without \"jti\" and with verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":33,"column":65,"index":878},"line":33,"code":"      it(`should error with with value ${util.inspect(notBefore)}`, function (done) {\n        signWithNotBefore(notBefore, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"notBefore\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":43,"column":46,"index":1362},"line":43,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        notBefore: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"notBefore\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error when \"nbf\" is in payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":54,"column":45,"index":1799},"line":54,"code":"    it('should error when \"nbf\" is in payload', function (done) {\n      signWithNotBefore(100, {\n        nbf: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.notBefore\" option the payload already has an \"nbf\" property.');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":64,"column":42,"index":2176},"line":64,"code":"    it('should error with a string payload', function (done) {\n      signWithNotBefore(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for string payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":72,"column":42,"index":2515},"line":72,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithNotBefore(100, new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for object payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"nbf\" claim validation"],"updatePoint":{"line":85,"column":59,"index":3066},"line":85,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        signWithNotBefore(undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"nbf\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","\"nbf\" in payload validation"],"updatePoint":{"line":101,"column":59,"index":3641},"line":101,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          nbf\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid nbf value');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":127,"column":64,"index":4483},"line":127,"code":"    it('should set correct \"nbf\" with negative number of seconds', function (done) {\n      signWithNotBefore(-10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":138,"column":64,"index":4909},"line":138,"code":"    it('should set correct \"nbf\" with positive number of seconds', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":150,"column":50,"index":5351},"line":150,"code":"    it('should set correct \"nbf\" with zero seconds', function (done) {\n      signWithNotBefore(0, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":161,"column":62,"index":5773},"line":161,"code":"    it('should set correct \"nbf\" with negative string timespan', function (done) {\n      signWithNotBefore('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":172,"column":62,"index":6201},"line":172,"code":"    it('should set correct \"nbf\" with positive string timespan', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":184,"column":58,"index":6655},"line":184,"code":"    it('should set correct \"nbf\" with zero string timespan', function (done) {\n      signWithNotBefore('0 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    }); // TODO an nbf of -Infinity should fail validation","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given -Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":196,"column":50,"index":7121},"line":196,"code":"    it('should set null \"nbf\" when given -Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    }); // TODO an nbf of Infinity should fail validation","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":208,"column":55,"index":7542},"line":208,"code":"    it('should set null \"nbf\" when given value Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    }); // TODO an nbf of NaN should fail validation","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value NaN","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":220,"column":50,"index":7952},"line":220,"code":"    it('should set null \"nbf\" when given value NaN', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" when \"iat\" is passed","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":231,"column":53,"index":8314},"line":231,"code":"    it('should set correct \"nbf\" when \"iat\" is passed', function (done) {\n      signWithNotBefore(-10, {\n        iat: 40\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 30);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTimestamp\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":244,"column":50,"index":8749},"line":244,"code":"    it('should verify \"nbf\" using \"clockTimestamp\"', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 70\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTolerance\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":258,"column":50,"index":9255},"line":258,"code":"    it('should verify \"nbf\" using \"clockTolerance\"', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 65);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should ignore a not active token when \"ignoreNotBefore\" is true","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":272,"column":71,"index":9780},"line":272,"code":"    it('should ignore a not active token when \"ignoreNotBefore\" is true', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreNotBefore: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":286,"column":61,"index":10304},"line":286,"code":"    it('should error on verify if \"nbf\" is after current time', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: 61\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time using clockTolerance","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":299,"column":82,"index":10805},"line":299,"code":"    it('should error on verify if \"nbf\" is after current time using clockTolerance', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 4\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":28,"column":61,"index":679},"line":28,"code":"      it(`should error with with value ${util.inspect(keyid)}`, function (done) {\n        signWithKeyId(keyid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"keyid\" must be a string');\n          });\n        });\n      });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":38,"column":46,"index":1094},"line":38,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        keyid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"keyid\" must be a string');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should not add \"kid\" header when \"keyid\" option not provided","suites":["keyid","when signing a token"],"updatePoint":{"line":51,"column":68,"index":1554},"line":51,"code":"    it('should not add \"kid\" header when \"keyid\" option not provided', function (done) {\n      signWithKeyId(undefined, {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.not.have.property('kid');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and an object payload","suites":["keyid","when signing a token"],"updatePoint":{"line":62,"column":85,"index":1969},"line":62,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and an object payload', function (done) {\n      signWithKeyId('foo', {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a Buffer payload","suites":["keyid","when signing a token"],"updatePoint":{"line":73,"column":84,"index":2382},"line":73,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a Buffer payload', function (done) {\n      signWithKeyId('foo', new Buffer('a Buffer payload'), (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a string payload","suites":["keyid","when signing a token"],"updatePoint":{"line":84,"column":84,"index":2823},"line":84,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a string payload', function (done) {\n      signWithKeyId('foo', 'a string payload', (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["maxAge option"],"updatePoint":{"line":55,"column":55,"index":1255},"line":55,"code":"    it(`should error with value ${util.inspect(maxAge)}`, function (done) {\n      expect(() => jwt.verify(token, undefined, {\n        maxAge\n      })).to.throw(jwt.JsonWebTokenError, '\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n      jwt.verify(token, undefined, {\n        maxAge\n      }, err => {\n        expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n        expect(err.message).to.equal('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n        done();\n      });\n    });","file":"option-maxAge.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["nonce option"],"updatePoint":{"line":38,"column":54,"index":961},"line":38,"code":"    it(`should error with value ${util.inspect(nonce)}`, function (done) {\n      testUtils.verifyJWTHelper(token, undefined, {\n        nonce\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n          expect(err).to.have.property('message', 'nonce must be a non-empty string');\n        });\n      });\n    });","file":"option-nonce.test.js","skipped":false,"dir":"test"}]}