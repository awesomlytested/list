{"repo":"streamich/react-use","url":"https://github.com/streamich/react-use","branch":"master","configs":[{"package":"react-use","lang":"ts","dir":"tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should use default","suites":["createBreakpoint"],"updatePoint":{"line":13,"column":26},"line":13,"code":"  test('should use default', () => {\n    const { result } = renderHook(() => useBreakpointA());\n    act(() => {\n      changeInnerWidth(100);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('tablet');\n\n    act(() => {\n      changeInnerWidth(200);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('tablet');\n\n    act(() => {\n      changeInnerWidth(1100);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('laptop');\n\n    act(() => {\n      changeInnerWidth(1500);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('laptopL');\n\n    act(() => {\n      revert();\n    });\n  });","file":"createBreakpoint.test.ts","skipped":false,"dir":"tests"},{"name":"should use custom","suites":["createBreakpoint"],"updatePoint":{"line":44,"column":25},"line":44,"code":"  test('should use custom', () => {\n    const { result } = renderHook(() => useBreakpointB());\n    act(() => {\n      changeInnerWidth(100);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('mobileM');\n\n    act(() => {\n      changeInnerWidth(200);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('mobileM');\n\n    act(() => {\n      changeInnerWidth(800);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('tablet');\n\n    act(() => {\n      changeInnerWidth(1100);\n      window.dispatchEvent(new Event('resize'));\n    });\n    expect(result.current).toBe('laptop');\n\n    act(() => {\n      revert();\n    });\n  });","file":"createBreakpoint.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useGlobalState"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(createGlobalState).toBeDefined();\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"both components should be updated","suites":["useGlobalState"],"updatePoint":{"line":9,"column":39},"line":9,"code":"  it('both components should be updated', () => {\n    const useGlobalValue = createGlobalState(0);\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(0);\n    expect(result2.current[0]).toBe(0);\n    act(() => {\n      result1.current[1](1);\n    });\n    expect(result1.current[0]).toBe(1);\n    expect(result2.current[0]).toBe(1);\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"allows setting state with function and previous value","suites":["useGlobalState"],"updatePoint":{"line":22,"column":59},"line":22,"code":"  it('allows setting state with function and previous value', () => {\n    const useGlobalValue = createGlobalState(0);\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(0);\n    expect(result2.current[0]).toBe(0);\n    act(() => {\n      result1.current[1]((value) => value + 1);\n    });\n    expect(result1.current[0]).toBe(1);\n    expect(result2.current[0]).toBe(1);\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"allows setting state with function and no previous value","suites":["useGlobalState"],"updatePoint":{"line":35,"column":62},"line":35,"code":"  it('allows setting state with function and no previous value', () => {\n    const useGlobalValue = createGlobalState(0);\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(0);\n    expect(result2.current[0]).toBe(0);\n    act(() => {\n      result1.current[1](() => 1);\n    });\n    expect(result1.current[0]).toBe(1);\n    expect(result2.current[0]).toBe(1);\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"initializes and updates with undefined","suites":["useGlobalState"],"updatePoint":{"line":48,"column":44},"line":48,"code":"  it('initializes and updates with undefined', () => {\n    const useGlobalValue = createGlobalState<number>();\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(undefined);\n    expect(result2.current[0]).toBe(undefined);\n    act(() => {\n      // this is the only case where types fail, it should guard the number\n      result1.current[1]((value) => value);\n    });\n    expect(result1.current[0]).toBe(undefined);\n    expect(result2.current[0]).toBe(undefined);\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"initializes with undefined and updates with different type","suites":["useGlobalState"],"updatePoint":{"line":62,"column":64},"line":62,"code":"  it('initializes with undefined and updates with different type', () => {\n    const useGlobalValue = createGlobalState();\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(undefined);\n    expect(result2.current[0]).toBe(undefined);\n    act(() => {\n      // @ts-expect-error this case it checks correctly, hence the comment\n      result1.current[1]((value) => 1);\n    });\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"initializes with function","suites":["useGlobalState"],"updatePoint":{"line":74,"column":31},"line":74,"code":"  it('initializes with function', () => {\n    const useGlobalValue = createGlobalState(() => 0);\n    const { result: result1 } = renderHook(() => useGlobalValue());\n    const { result: result2 } = renderHook(() => useGlobalValue());\n    expect(result1.current[0]).toBe(0);\n    expect(result2.current[0]).toBe(0);\n    act(() => {\n      result1.current[1](1);\n    });\n    expect(result1.current[0]).toBe(1);\n    expect(result2.current[0]).toBe(1);\n  });","file":"createGlobalState.test.ts","skipped":false,"dir":"tests"},{"name":"should init memo hook","suites":[],"updatePoint":{"line":6,"column":25},"line":6,"code":"it('should init memo hook', () => {\n  const useMemoGetDouble = createMemo(getDouble);\n\n  expect(useMemoGetDouble).toBeInstanceOf(Function);\n});","file":"createMemo.test.ts","skipped":false,"dir":"tests"},{"name":"should return same result as original function for argument %d","suites":["when using created memo hook"],"line":19,"code":"  it.each([[1], [3], [5]])(\n    'should return same result as original function for argument %d',\n    (val: number) => {\n      const { result } = renderHook(() => useMemoGetDouble(val));\n      expect(result.current).toBe(getDouble(val));\n    }\n  );","file":"createMemo.test.ts","skipped":false,"dir":"tests"},{"name":"should NOT call original function for same arguments","suites":["when using created memo hook"],"updatePoint":{"line":27,"column":58},"line":27,"code":"  it('should NOT call original function for same arguments', () => {\n    let initialValue = 5;\n    expect(getDouble).not.toHaveBeenCalled();\n\n    // it's called first time calculating for argument 5\n    const { rerender } = renderHook(() => useMemoGetDouble(initialValue));\n    expect(getDouble).toHaveBeenCalled();\n\n    getDouble.mockClear();\n\n    // it's NOT called second time calculating for argument 5\n    rerender();\n    expect(getDouble).not.toHaveBeenCalled();\n\n    getDouble.mockClear();\n\n    // it's called again calculating for different argument\n    initialValue = 7;\n    rerender();\n    expect(getDouble).toHaveBeenCalled();\n  });","file":"createMemo.test.ts","skipped":false,"dir":"tests"},{"name":"should init reducer hook function","suites":[],"updatePoint":{"line":6,"column":37},"line":6,"code":"it('should init reducer hook function', () => {\n  const useSomeReducer = createReducer();\n  expect(useSomeReducer).toBeInstanceOf(Function);\n});","file":"createReducer.test.ts","skipped":false,"dir":"tests"},{"name":"should init state and dispatcher","suites":["when using created reducer hook"],"updatePoint":{"line":67,"column":38},"line":67,"code":"  it('should init state and dispatcher', () => {\n    const { result } = setUp();\n    const [state, dispatch] = result.current;\n\n    expect(state).toEqual({ count: 1 });\n    expect(dispatch).toBeInstanceOf(Function);\n  });","file":"createReducer.test.ts","skipped":false,"dir":"tests"},{"name":"should handle \"$actionType\" action","suites":["when using created reducer hook"],"line":75,"code":"  it.each`\n    actionType     | expectedCount | payload\n    ${'increment'} | ${2}          | ${undefined}\n    ${'decrement'} | ${0}          | ${undefined}\n    ${'reset'}     | ${1}          | ${1}\n  `('should handle \"$actionType\" action', ({ actionType, expectedCount, payload }) => {\n    const { result } = setUp();\n    const [, dispatch] = result.current;\n    expect(mockLog).not.toHaveBeenCalled();\n\n    act(() => {\n      dispatch({ type: actionType, payload });\n    });\n\n    expect(result.current[0]).toEqual({ count: expectedCount });\n    expect(mockLog).toHaveBeenCalled();\n  });","file":"createReducer.test.ts","skipped":false,"dir":"tests"},{"name":"should handle async action with several middlewares","suites":["when using created reducer hook"],"updatePoint":{"line":93,"column":57},"line":93,"code":"  it('should handle async action with several middlewares', () => {\n    const { result } = setUp();\n    const [, dispatch] = result.current;\n    expect(mockLog).not.toHaveBeenCalled();\n\n    act(() => {\n      dispatch(addAndReset());\n    });\n\n    expect(result.current[0]).toEqual({ count: 2 });\n    expect(mockLog).toHaveBeenCalled();\n\n    // fast-forward until all timers have been executed\n    act(() => {\n      jest.runAllTimers();\n    });\n\n    expect(result.current[0]).toEqual({ count: 1 });\n  });","file":"createReducer.test.ts","skipped":false,"dir":"tests"},{"name":"should defined","suites":["resolveHookState"],"updatePoint":{"line":4,"column":20},"line":4,"code":"  it('should defined', () => {\n    expect(resolveHookState).toBeDefined();\n  });","file":"misc/hookState.test.ts","skipped":false,"dir":"tests"},{"name":"should return value as is if it's not a function","suites":["resolveHookState"],"updatePoint":{"line":8,"column":54},"line":8,"code":"  it(`should return value as is if it's not a function`, () => {\n    expect(resolveHookState(1)).toBe(1);\n    expect(resolveHookState('HI!')).toBe('HI!');\n    expect(resolveHookState(undefined)).toBe(undefined);\n  });","file":"misc/hookState.test.ts","skipped":false,"dir":"tests"},{"name":"should call passed function","suites":["resolveHookState"],"updatePoint":{"line":14,"column":33},"line":14,"code":"  it('should call passed function', () => {\n    const spy = jest.fn();\n    resolveHookState(spy);\n    expect(spy).toHaveBeenCalled();\n  });","file":"misc/hookState.test.ts","skipped":false,"dir":"tests"},{"name":"should pass 2nd parameter to function if it awaited","suites":["resolveHookState"],"updatePoint":{"line":20,"column":57},"line":20,"code":"  it('should pass 2nd parameter to function if it awaited', () => {\n    const spy = jest.fn((n: number) => n);\n    resolveHookState(spy, 123);\n    expect(spy).toHaveBeenCalled();\n    expect(spy.mock.calls[0][0]).toBe(123);\n  });","file":"misc/hookState.test.ts","skipped":false,"dir":"tests"},{"name":"should not pass 2nd parameter to function if it not awaited","suites":["resolveHookState"],"updatePoint":{"line":27,"column":65},"line":27,"code":"  it('should not pass 2nd parameter to function if it not awaited', () => {\n    const spy = jest.fn(() => {});\n    /* @ts-expect-error */\n    resolveHookState(spy, 123);\n    expect(spy).toHaveBeenCalled();\n    expect(spy.mock.calls[0].length).toBe(0);\n  });","file":"misc/hookState.test.ts","skipped":false,"dir":"tests"},{"name":"should init audio and utils","suites":[],"updatePoint":{"line":8,"column":31},"line":8,"code":"it('should init audio and utils', () => {\n  global.console.error = jest.fn();\n\n  const MOCK_AUDIO_SRC = 'MOCK_AUDIO_SRC';\n  const MOCK_AUTO_PLAY_STATE = true;\n  const { result } = setUp(MOCK_AUDIO_SRC, MOCK_AUTO_PLAY_STATE);\n  const [audio, state, controls, ref] = result.current;\n  // if not production mode, it will show the error message, cause audio do not render\n  expect(console.error).toHaveBeenCalledTimes(1);\n\n  // Test the audio comp\n  expect(audio.type).toBe('audio');\n  expect(audio.props.src).toBe(MOCK_AUDIO_SRC);\n  expect(audio.props.autoPlay).toBe(MOCK_AUTO_PLAY_STATE);\n\n  // Test state value\n  expect(state.time).toBe(0);\n  expect(state.paused).toBe(true);\n  expect(state.playing).toBe(false);\n  expect(state.muted).toBe(false);\n  expect(state.volume).toBe(1);\n\n  // Test controls\n  ref.current = document.createElement('audio');\n  // Mock ref current for controls testing\n\n  expect(ref.current.muted).toBe(false);\n  controls.mute();\n  expect(ref.current.muted).toBe(true);\n  controls.unmute();\n  expect(ref.current.muted).toBe(false);\n\n  expect(ref.current.volume).toBe(1);\n  controls.volume(0.5);\n  expect(ref.current.volume).toBe(0.5);\n});","file":"useAudio.test.ts","skipped":false,"dir":"tests"},{"name":"should be an alias for useToggle ","suites":[],"updatePoint":{"line":4,"column":37},"line":4,"code":"it('should be an alias for useToggle ', () => {\n  expect(useBoolean).toBe(useToggle);\n});","file":"useBoolean.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined ","suites":["useCopyToClipboard"],"updatePoint":{"line":28,"column":24},"line":28,"code":"  it('should be defined ', () => {\n    expect(useCopyToClipboard).toBeDefined();\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should pass a given value to copy to clipboard and set state","suites":["useCopyToClipboard"],"updatePoint":{"line":32,"column":66},"line":32,"code":"  it('should pass a given value to copy to clipboard and set state', () => {\n    const testValue = 'test';\n    let [state, copyToClipboard] = hook.result.current;\n    act(() => copyToClipboard(testValue));\n    [state, copyToClipboard] = hook.result.current;\n\n    expect(writeText).toBeCalled();\n    expect(state.value).toBe(testValue);\n    expect(state.noUserInteraction).toBe(true);\n    expect(state.error).not.toBeDefined();\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should not call writeText if passed an invalid input and set state","suites":["useCopyToClipboard"],"updatePoint":{"line":44,"column":72},"line":44,"code":"  it('should not call writeText if passed an invalid input and set state', () => {\n    let testValue = {}; // invalid value\n    let [state, copyToClipboard] = hook.result.current;\n    act(() => copyToClipboard(testValue));\n    [state, copyToClipboard] = hook.result.current;\n\n    expect(writeText).not.toBeCalled();\n    expect(state.value).toBe(testValue);\n    expect(state.noUserInteraction).toBe(true);\n    expect(state.error).toBeDefined();\n\n    testValue = ''; // empty string is also invalid\n    act(() => copyToClipboard(testValue));\n    [state, copyToClipboard] = hook.result.current;\n\n    expect(writeText).not.toBeCalled();\n    expect(state.value).toBe(testValue);\n    expect(state.noUserInteraction).toBe(true);\n    expect(state.error).toBeDefined();\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should catch exception thrown by copy-to-clipboard and set state","suites":["useCopyToClipboard"],"updatePoint":{"line":65,"column":70},"line":65,"code":"  it('should catch exception thrown by copy-to-clipboard and set state', () => {\n    let [state, copyToClipboard] = hook.result.current;\n    act(() => copyToClipboard(valueToRaiseMockException));\n    [state, copyToClipboard] = hook.result.current;\n\n    expect(writeText).toBeCalledWith(valueToRaiseMockException);\n    expect(state.value).toBe(valueToRaiseMockException);\n    expect(state.noUserInteraction).not.toBeDefined();\n    expect(state.error).toStrictEqual(new Error(valueToRaiseMockException));\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should return initial state while unmounted","suites":["useCopyToClipboard"],"updatePoint":{"line":76,"column":49},"line":76,"code":"  it('should return initial state while unmounted', () => {\n    hook.unmount();\n    const [state, copyToClipboard] = hook.result.current;\n\n    act(() => copyToClipboard('value'));\n    expect(state.value).not.toBeDefined();\n    expect(state.error).not.toBeDefined();\n    expect(state.noUserInteraction).toBe(true);\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should console error if in dev environment","suites":["useCopyToClipboard"],"updatePoint":{"line":86,"column":48},"line":86,"code":"  it('should console error if in dev environment', () => {\n    const ORIGINAL_NODE_ENV = process.env.NODE_ENV;\n    const testValue = {}; // invalid value\n\n    process.env.NODE_ENV = 'development';\n    let [state, copyToClipboard] = hook.result.current;\n    act(() => copyToClipboard(testValue));\n    process.env.NODE_ENV = ORIGINAL_NODE_ENV;\n\n    [state, copyToClipboard] = hook.result.current;\n\n    expect(writeText).not.toBeCalled();\n    expect(consoleErrorSpy).toBeCalled();\n    expect(state.value).toBe(testValue);\n    expect(state.noUserInteraction).toBe(true);\n    expect(state.error).toBeDefined();\n  });","file":"useCopyToClipboard.test.ts","skipped":false,"dir":"tests"},{"name":"should init counter and utils","suites":[],"updatePoint":{"line":7,"column":33},"line":7,"code":"it('should init counter and utils', () => {\n  const { result } = setUp(5);\n\n  expect(result.current[0]).toBe(5);\n  expect(result.current[1]).toStrictEqual({\n    inc: expect.any(Function),\n    dec: expect.any(Function),\n    get: expect.any(Function),\n    set: expect.any(Function),\n    reset: expect.any(Function),\n  });\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should init counter to 0 if not initial value received","suites":[],"updatePoint":{"line":20,"column":58},"line":20,"code":"it('should init counter to 0 if not initial value received', () => {\n  const { result } = setUp();\n\n  expect(result.current[0]).toBe(0);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should init counter to negative number","suites":[],"updatePoint":{"line":26,"column":42},"line":26,"code":"it('should init counter to negative number', () => {\n  const { result } = setUp(-2);\n\n  expect(result.current[0]).toBe(-2);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should get current counter","suites":[],"updatePoint":{"line":32,"column":30},"line":32,"code":"it('should get current counter', () => {\n  const { result } = setUp(5);\n  const { get } = result.current[1];\n\n  expect(get()).toBe(5);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should increment by 1 if not value received","suites":[],"updatePoint":{"line":39,"column":47},"line":39,"code":"it('should increment by 1 if not value received', () => {\n  const { result } = setUp(5);\n  const { get, inc } = result.current[1];\n\n  act(() => inc());\n\n  expect(result.current[0]).toBe(6);\n  expect(get()).toBe(6);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should increment by value received","suites":[],"updatePoint":{"line":49,"column":38},"line":49,"code":"it('should increment by value received', () => {\n  const { result } = setUp(5);\n  const { get, inc } = result.current[1];\n\n  act(() => inc(9));\n\n  expect(result.current[0]).toBe(14);\n  expect(get()).toBe(14);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should decrement by 1 if not value received","suites":[],"updatePoint":{"line":59,"column":47},"line":59,"code":"it('should decrement by 1 if not value received', () => {\n  const { result } = setUp(5);\n  const { get, dec } = result.current[1];\n\n  act(() => dec());\n\n  expect(result.current[0]).toBe(4);\n  expect(get()).toBe(4);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should decrement by value received","suites":[],"updatePoint":{"line":69,"column":38},"line":69,"code":"it('should decrement by value received', () => {\n  const { result } = setUp(5);\n  const { get, dec } = result.current[1];\n\n  act(() => dec(9));\n\n  expect(result.current[0]).toBe(-4);\n  expect(get()).toBe(-4);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should set to value received","suites":[],"updatePoint":{"line":79,"column":32},"line":79,"code":"it('should set to value received', () => {\n  const { result } = setUp(5);\n  const { get, set } = result.current[1];\n\n  act(() => set(17));\n\n  expect(result.current[0]).toBe(17);\n  expect(get()).toBe(17);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should reset to original value","suites":[],"updatePoint":{"line":89,"column":34},"line":89,"code":"it('should reset to original value', () => {\n  const { result } = setUp(5);\n  const { get, set, reset } = result.current[1];\n\n  // set different value than initial one...\n  act(() => set(17));\n  expect(result.current[0]).toBe(17);\n\n  // ... and reset it to initial one\n  act(() => reset());\n  expect(result.current[0]).toBe(5);\n  expect(get()).toBe(5);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should reset and set new original value","suites":[],"updatePoint":{"line":103,"column":43},"line":103,"code":"it('should reset and set new original value', () => {\n  const { result } = setUp(5);\n  const { get, set, reset } = result.current[1];\n\n  // set different value than initial one...\n  act(() => set(17));\n  expect(result.current[0]).toBe(17);\n\n  // ... now reset and set it to different than initial one...\n  act(() => reset(8));\n  expect(result.current[0]).toBe(8);\n\n  // ... and set different value than initial one again...\n  act(() => set(32));\n  expect(result.current[0]).toBe(32);\n\n  // ... and reset it to new initial value\n  act(() => reset());\n  expect(result.current[0]).toBe(8);\n  expect(get()).toBe(8);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should not exceed max value","suites":[],"updatePoint":{"line":125,"column":31},"line":125,"code":"it('should not exceed max value', () => {\n  const { result } = setUp(10, 5);\n  expect(result.current[0]).toBe(5);\n\n  const { get, inc, reset } = result.current[1];\n\n  act(() => reset(10));\n  expect(get()).toBe(5);\n\n  act(() => reset(4));\n  expect(get()).toBe(4);\n\n  act(() => inc());\n  expect(get()).toBe(5);\n\n  act(() => inc());\n  expect(get()).toBe(5);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should not exceed min value","suites":[],"updatePoint":{"line":144,"column":31},"line":144,"code":"it('should not exceed min value', () => {\n  const { result } = setUp(3, null, 5);\n  expect(result.current[0]).toBe(5);\n\n  const { get, dec, reset } = result.current[1];\n\n  act(() => reset(4));\n  expect(get()).toBe(5);\n\n  act(() => reset(6));\n  expect(get()).toBe(6);\n\n  act(() => dec());\n  expect(get()).toBe(5);\n\n  act(() => dec());\n  expect(get()).toBe(5);\n});","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"on any of call parameters","suites":["should `console.error` on unexpected inputs"],"updatePoint":{"line":164,"column":31},"line":164,"code":"  it('on any of call parameters', () => {\n    const spy = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n    // @ts-ignore\n    setUp(false);\n    expect(spy.mock.calls[0][0]).toBe('initialValue has to be a number, got boolean');\n\n    // @ts-ignore\n    setUp(10, false);\n    expect(spy.mock.calls[1][0]).toBe('max has to be a number, got boolean');\n\n    // @ts-ignore\n    setUp(10, 5, {});\n    expect(spy.mock.calls[2][0]).toBe('min has to be a number, got object');\n\n    spy.mockRestore();\n  });","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"on any of returned methods has unexpected input","suites":["should `console.error` on unexpected inputs"],"updatePoint":{"line":182,"column":53},"line":182,"code":"  it('on any of returned methods has unexpected input', () => {\n    const { result } = setUp(10);\n    const { inc, dec, reset } = result.current[1];\n\n    const spy = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n    // @ts-ignore\n    act(() => inc(false));\n    expect(spy.mock.calls[0][0]).toBe(\n      'delta has to be a number or function returning a number, got boolean'\n    );\n\n    // @ts-ignore\n    act(() => dec(false));\n    expect(spy.mock.calls[1][0]).toBe(\n      'delta has to be a number or function returning a number, got boolean'\n    );\n\n    // @ts-ignore\n    act(() => reset({}));\n    expect(spy.mock.calls[2][0]).toBe(\n      'value has to be a number or function returning a number, got object'\n    );\n\n    spy.mockRestore();\n  });","file":"useCounter.test.ts","skipped":false,"dir":"tests"},{"name":"should run provided object once","suites":[],"updatePoint":{"line":12,"column":35},"line":12,"code":"it('should run provided object once', () => {\n  const { rerender: rerenderNormal } = renderHook(() => useEffect(mockEffectNormal, [options]));\n  const { rerender: rerenderDeep } = renderHook(() =>\n    useCustomCompareEffect(mockEffectDeep, [options], isDeepEqual)\n  );\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(1);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n\n  options = { max: 10 };\n  rerenderDeep();\n  rerenderNormal();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(2);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n\n  options = { max: 10 };\n  rerenderNormal();\n  rerenderDeep();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(3);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n});","file":"useCustomCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should run clean-up provided on unmount","suites":[],"updatePoint":{"line":36,"column":43},"line":36,"code":"it('should run clean-up provided on unmount', () => {\n  const { unmount } = renderHook(() =>\n    useCustomCompareEffect(mockEffectCallback, [options], isDeepEqual)\n  );\n  expect(mockEffectCleanup).not.toHaveBeenCalled();\n\n  unmount();\n  expect(mockEffectCleanup).toHaveBeenCalledTimes(1);\n});","file":"useCustomCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useDebounce"],"updatePoint":{"line":19,"column":23},"line":19,"code":"  it('should be defined', () => {\n    expect(useDebounce).toBeDefined();\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should return two functions","suites":["useDebounce"],"updatePoint":{"line":23,"column":33},"line":23,"code":"  it('should return two functions', () => {\n    const hook = renderHook(() => useDebounce(() => {}, 5));\n\n    expect(hook.result.current.length).toBe(2);\n    expect(typeof hook.result.current[0]).toBe('function');\n    expect(typeof hook.result.current[1]).toBe('function');\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should call passed function after given amount of time","suites":["useDebounce"],"updatePoint":{"line":47,"column":60},"line":47,"code":"  it('should call passed function after given amount of time', () => {\n    const [spy] = getHook();\n\n    expect(spy).not.toHaveBeenCalled();\n    jest.advanceTimersByTime(5);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel function call on unmount","suites":["useDebounce"],"updatePoint":{"line":55,"column":44},"line":55,"code":"  it('should cancel function call on unmount', () => {\n    const [spy, hook] = getHook();\n\n    expect(spy).not.toHaveBeenCalled();\n    hook.unmount();\n    jest.advanceTimersByTime(5);\n    expect(spy).not.toHaveBeenCalled();\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"first function should return actual state of debounce","suites":["useDebounce"],"updatePoint":{"line":64,"column":59},"line":64,"code":"  it('first function should return actual state of debounce', () => {\n    let [, hook] = getHook();\n    let [isReady] = hook.result.current;\n\n    expect(isReady()).toBe(false);\n    hook.unmount();\n    expect(isReady()).toBe(null);\n\n    [, hook] = getHook();\n    [isReady] = hook.result.current;\n    jest.advanceTimersByTime(5);\n    expect(isReady()).toBe(true);\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"second function should cancel debounce","suites":["useDebounce"],"updatePoint":{"line":78,"column":44},"line":78,"code":"  it('second function should cancel debounce', () => {\n    const [spy, hook] = getHook();\n    const [isReady, cancel] = hook.result.current;\n\n    expect(spy).not.toHaveBeenCalled();\n    expect(isReady()).toBe(false);\n\n    act(() => {\n      cancel();\n    });\n    jest.advanceTimersByTime(5);\n\n    expect(spy).not.toHaveBeenCalled();\n    expect(isReady()).toBe(null);\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should reset timeout on delay change","suites":["useDebounce"],"updatePoint":{"line":94,"column":42},"line":94,"code":"  it('should reset timeout on delay change', () => {\n    const [spy, hook] = getHook(50);\n\n    expect(spy).not.toHaveBeenCalled();\n    hook.rerender({ delay: 5, deps: [] });\n\n    jest.advanceTimersByTime(5);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should reset timeout on deps change","suites":["useDebounce"],"updatePoint":{"line":104,"column":41},"line":104,"code":"  it('should reset timeout on deps change', () => {\n    const [spy, hook] = getHook(50, [5, 6]);\n\n    jest.advanceTimersByTime(45);\n    expect(spy).not.toHaveBeenCalled();\n    hook.rerender({ delay: 50, deps: [6, 6] });\n\n    jest.advanceTimersByTime(45);\n    expect(spy).not.toHaveBeenCalled();\n    jest.advanceTimersByTime(5);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useDebounce.test.ts","skipped":false,"dir":"tests"},{"name":"should run provided object once","suites":[],"updatePoint":{"line":11,"column":35},"line":11,"code":"it('should run provided object once', () => {\n  const { rerender: rerenderNormal } = renderHook(() => useEffect(mockEffectNormal, [options]));\n  const { rerender: rerenderDeep } = renderHook(() =>\n    useDeepCompareEffect(mockEffectDeep, [options])\n  );\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(1);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n\n  options = { max: 10 };\n  rerenderDeep();\n  rerenderNormal();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(2);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n\n  options = { max: 10 };\n  rerenderNormal();\n  rerenderDeep();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(3);\n  expect(mockEffectDeep).toHaveBeenCalledTimes(1);\n});","file":"useDeepCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should run clean-up provided on unmount","suites":[],"updatePoint":{"line":35,"column":43},"line":35,"code":"it('should run clean-up provided on unmount', () => {\n  const { unmount } = renderHook(() => useDeepCompareEffect(mockEffectCallback, [options]));\n  expect(mockEffectCleanup).not.toHaveBeenCalled();\n\n  unmount();\n  expect(mockEffectCleanup).toHaveBeenCalledTimes(1);\n});","file":"useDeepCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"when value type is $valueType","suites":[],"line":7,"code":"describe.each`\n  valueType    | defaultValue | initialValue            | anotherValue\n  ${'number'}  | ${0}         | ${5}                    | ${77}\n  ${'object'}  | ${{}}        | ${{ name: 'John Doe' }} | ${{ name: 'Solid Snake' }}\n  ${'boolean'} | ${false}     | ${false}                | ${true}\n  ${'string'}  | ${''}        | ${'foo'}                | ${'bar'}\n`('when value type is $valueType', ({ defaultValue, initialValue, anotherValue }) => {\n  it('should init state with initial value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [value, setValue] = result.current;\n\n    expect(value).toBe(initialValue);\n    expect(setValue).toBeInstanceOf(Function);\n  });\n\n  it('should set state to another value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(anotherValue));\n\n    expect(result.current[0]).toBe(anotherValue);\n  });\n\n  it('should return default value if state set to null', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(null));\n\n    expect(result.current[0]).toBe(defaultValue);\n  });\n\n  it('should return default value if state set to undefined', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(undefined));\n\n    expect(result.current[0]).toBe(defaultValue);\n  });\n\n  it('should handle state properly after being set to nil and then to another value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(undefined));\n    expect(result.current[0]).toBe(defaultValue);\n\n    act(() => setValue(null));\n    expect(result.current[0]).toBe(defaultValue);\n\n    act(() => setValue(anotherValue));\n    expect(result.current[0]).toBe(anotherValue);\n  });\n});","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should init state with initial value","suites":[],"updatePoint":{"line":14,"column":42},"line":14,"code":"  it('should init state with initial value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [value, setValue] = result.current;\n\n    expect(value).toBe(initialValue);\n    expect(setValue).toBeInstanceOf(Function);\n  });","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should set state to another value","suites":[],"updatePoint":{"line":22,"column":39},"line":22,"code":"  it('should set state to another value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(anotherValue));\n\n    expect(result.current[0]).toBe(anotherValue);\n  });","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should return default value if state set to null","suites":[],"updatePoint":{"line":31,"column":54},"line":31,"code":"  it('should return default value if state set to null', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(null));\n\n    expect(result.current[0]).toBe(defaultValue);\n  });","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should return default value if state set to undefined","suites":[],"updatePoint":{"line":40,"column":59},"line":40,"code":"  it('should return default value if state set to undefined', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(undefined));\n\n    expect(result.current[0]).toBe(defaultValue);\n  });","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should handle state properly after being set to nil and then to another value","suites":[],"updatePoint":{"line":49,"column":83},"line":49,"code":"  it('should handle state properly after being set to nil and then to another value', () => {\n    const { result } = setUp(defaultValue, initialValue);\n    const [, setValue] = result.current;\n\n    act(() => setValue(undefined));\n    expect(result.current[0]).toBe(defaultValue);\n\n    act(() => setValue(null));\n    expect(result.current[0]).toBe(defaultValue);\n\n    act(() => setValue(anotherValue));\n    expect(result.current[0]).toBe(anotherValue);\n  });","file":"useDefault.test.ts","skipped":false,"dir":"tests"},{"name":"should run provided effect only once","suites":[],"updatePoint":{"line":7,"column":40},"line":7,"code":"it('should run provided effect only once', () => {\n  const { rerender } = renderHook(() => useEffectOnce(mockEffectCallback));\n  expect(mockEffectCallback).toHaveBeenCalledTimes(1);\n\n  rerender();\n  expect(mockEffectCallback).toHaveBeenCalledTimes(1);\n});","file":"useEffectOnce.test.ts","skipped":false,"dir":"tests"},{"name":"should run clean-up provided on unmount","suites":[],"updatePoint":{"line":15,"column":43},"line":15,"code":"it('should run clean-up provided on unmount', () => {\n  const { unmount } = renderHook(() => useEffectOnce(mockEffectCallback));\n  expect(mockEffectCleanup).not.toHaveBeenCalled();\n\n  unmount();\n  expect(mockEffectCleanup).toHaveBeenCalledTimes(1);\n});","file":"useEffectOnce.test.ts","skipped":false,"dir":"tests"},{"name":"should throw an error on error dispatch","suites":[],"updatePoint":{"line":14,"column":43},"line":14,"code":"it('should throw an error on error dispatch', () => {\n  const errorStr = 'some_error';\n\n  try {\n    const { result } = setup();\n\n    act(() => {\n      result.current(new Error(errorStr));\n    });\n  } catch (err) {\n    expect(err.message).toEqual(errorStr);\n  }\n});","file":"useError.test.ts","skipped":false,"dir":"tests"},{"name":"should call addEventListener/removeEventListener on mount/unmount","suites":[],"updatePoint":{"line":49,"column":69},"line":49,"code":"it('should call addEventListener/removeEventListener on mount/unmount', () => {\n  checkOnMountAndUnmount(propsList1[0], 'addEventListener', 'removeEventListener');\n});","file":"useEvent.test.ts","skipped":false,"dir":"tests"},{"name":"should call on/off on mount/unmount","suites":[],"updatePoint":{"line":53,"column":39},"line":53,"code":"it('should call on/off on mount/unmount', () => {\n  checkOnMountAndUnmount(propsList2[0], 'on', 'off');\n});","file":"useEvent.test.ts","skipped":false,"dir":"tests"},{"name":"should call addEventListener/removeEventListener on deps changes","suites":[],"updatePoint":{"line":57,"column":68},"line":57,"code":"it('should call addEventListener/removeEventListener on deps changes', () => {\n  checkOnDepsChanges(propsList1[0], propsList1[1], 'addEventListener', 'removeEventListener');\n});","file":"useEvent.test.ts","skipped":false,"dir":"tests"},{"name":"should call on/off on deps changes","suites":[],"updatePoint":{"line":61,"column":38},"line":61,"code":"it('should call on/off on deps changes', () => {\n  checkOnDepsChanges(propsList2[0], propsList2[1], 'on', 'off');\n});","file":"useEvent.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useFirstMountState"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useFirstMountState).toBeDefined();\n  });","file":"useFirstMountState.test.ts","skipped":false,"dir":"tests"},{"name":"should return boolean","suites":["useFirstMountState"],"updatePoint":{"line":9,"column":27},"line":9,"code":"  it('should return boolean', () => {\n    expect(renderHook(() => useFirstMountState()).result.current).toEqual(expect.any(Boolean));\n  });","file":"useFirstMountState.test.ts","skipped":false,"dir":"tests"},{"name":"should return true on first render and false on all others","suites":["useFirstMountState"],"updatePoint":{"line":13,"column":64},"line":13,"code":"  it('should return true on first render and false on all others', () => {\n    const hook = renderHook(() => useFirstMountState());\n\n    expect(hook.result.current).toBe(true);\n    hook.rerender();\n    expect(hook.result.current).toBe(false);\n    hook.rerender();\n    expect(hook.result.current).toBe(false);\n  });","file":"useFirstMountState.test.ts","skipped":false,"dir":"tests"},{"name":"should init getter and setter","suites":[],"updatePoint":{"line":10,"column":33},"line":10,"code":"it('should init getter and setter', () => {\n  const { result } = setUp('foo');\n  const [get, set] = result.current;\n\n  expect(get).toBeInstanceOf(Function);\n  expect(set).toBeInstanceOf(Function);\n});","file":"useGetSet.test.ts","skipped":false,"dir":"tests"},{"name":"should get current value","suites":[],"updatePoint":{"line":18,"column":28},"line":18,"code":"it('should get current value', () => {\n  const { result } = setUp('foo');\n  const [get] = result.current;\n\n  const currentValue = get();\n\n  expect(currentValue).toBe('foo');\n});","file":"useGetSet.test.ts","skipped":false,"dir":"tests"},{"name":"should set new value","suites":[],"updatePoint":{"line":27,"column":24},"line":27,"code":"it('should set new value', () => {\n  const { result } = setUp('foo');\n  const [get, set] = result.current;\n\n  act(() => set('bar'));\n\n  const currentValue = get();\n  expect(currentValue).toBe('bar');\n});","file":"useGetSet.test.ts","skipped":false,"dir":"tests"},{"name":"should get and set expected values when used in nested functions","suites":[],"updatePoint":{"line":41,"column":68},"line":41,"code":"it('should get and set expected values when used in nested functions', () => {\n  const onClick = jest.fn(() => {\n    setTimeout(() => {\n      set(get() + 1);\n    }, 1000);\n  });\n\n  const { result } = setUp(0);\n  const [get, set] = result.current;\n\n  // simulate 3 clicks\n  onClick();\n  onClick();\n  onClick();\n\n  // fast-forward until all timers have been executed\n  act(() => {\n    jest.runAllTimers();\n  });\n\n  const currentValue = get();\n  expect(currentValue).toBe(3);\n  expect(onClick).toHaveBeenCalledTimes(3);\n});","file":"useGetSet.test.ts","skipped":false,"dir":"tests"},{"name":"should init getter and setter","suites":[],"updatePoint":{"line":21,"column":33},"line":21,"code":"it('should init getter and setter', () => {\n  const { result } = setUp({ foo: 'initialValue' });\n  const [get, set] = result.current;\n\n  expect(get).toBeInstanceOf(Function);\n  expect(set).toBeInstanceOf(Function);\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should log an error if init with something different than an object","suites":[],"updatePoint":{"line":29,"column":71},"line":29,"code":"it('should log an error if init with something different than an object', () => {\n  expect(mockConsoleError).not.toHaveBeenCalled();\n\n  setUp('not an object');\n\n  expect(mockConsoleError).toHaveBeenCalledTimes(1);\n  expect(mockConsoleError).toHaveBeenCalledWith('useGetSetState initial state must be an object.');\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should get current state","suites":[],"updatePoint":{"line":38,"column":28},"line":38,"code":"it('should get current state', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get] = result.current;\n\n  const currentState = get();\n\n  expect(currentState).toEqual({ foo: 'a', bar: 'z' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should set new state by applying patch with existing keys","suites":[],"updatePoint":{"line":47,"column":61},"line":47,"code":"it('should set new state by applying patch with existing keys', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get, set] = result.current;\n\n  act(() => set({ bar: 'y' }));\n\n  const currentState = get();\n  expect(currentState).toEqual({ foo: 'a', bar: 'y' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should set new state by applying patch with new keys","suites":[],"updatePoint":{"line":57,"column":56},"line":57,"code":"it('should set new state by applying patch with new keys', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get, set] = result.current;\n\n  act(() => set({ qux: 'f' }));\n\n  const currentState = get();\n  expect(currentState).toEqual({ foo: 'a', bar: 'z', qux: 'f' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should set new state by applying patch with both new and old keys","suites":[],"updatePoint":{"line":67,"column":69},"line":67,"code":"it('should set new state by applying patch with both new and old keys', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get, set] = result.current;\n\n  act(() => set({ bar: 'y', qux: 'f' }));\n\n  const currentState = get();\n  expect(currentState).toEqual({ foo: 'a', bar: 'y', qux: 'f' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should NOT set new state if empty patch received","suites":[],"updatePoint":{"line":77,"column":52},"line":77,"code":"it('should NOT set new state if empty patch received', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get, set] = result.current;\n\n  act(() => set({}));\n\n  const currentState = get();\n  expect(currentState).toEqual({ foo: 'a', bar: 'z' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should NOT set new state if no patch received","suites":[],"updatePoint":{"line":87,"column":49},"line":87,"code":"it('should NOT set new state if no patch received', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [get, set] = result.current;\n\n  // @ts-ignore\n  act(() => set());\n\n  const currentState = get();\n  expect(currentState).toEqual({ foo: 'a', bar: 'z' });\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should log an error if set with a patch different than an object","suites":[],"updatePoint":{"line":98,"column":68},"line":98,"code":"it('should log an error if set with a patch different than an object', () => {\n  const { result } = setUp({ foo: 'a', bar: 'z' });\n  const [, set] = result.current;\n  expect(mockConsoleError).not.toHaveBeenCalled();\n\n  act(() => set('not an object' as any));\n\n  expect(mockConsoleError).toHaveBeenCalledTimes(1);\n  expect(mockConsoleError).toHaveBeenCalledWith('useGetSetState setter patch must be an object.');\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should get and set expected state when used in nested functions","suites":[],"updatePoint":{"line":112,"column":67},"line":112,"code":"it('should get and set expected state when used in nested functions', () => {\n  const onClick = jest.fn(() => {\n    setTimeout(() => {\n      set({ counter: get().counter + 1 });\n    }, 1000);\n  });\n\n  const { result } = setUp({ counter: 0 });\n  const [get, set] = result.current;\n\n  // simulate 3 clicks\n  onClick();\n  onClick();\n  onClick();\n\n  // fast-forward until all timers have been executed\n  act(() => {\n    jest.runAllTimers();\n  });\n\n  const currentState = get();\n  expect(currentState).toEqual({ counter: 3 });\n  expect(onClick).toHaveBeenCalledTimes(3);\n});","file":"useGetSetState.test.ts","skipped":false,"dir":"tests"},{"name":"returns current url hash","suites":[],"updatePoint":{"line":24,"column":30},"line":24,"code":"test('returns current url hash', () => {\n  window.location.hash = '#abc';\n\n  const { result } = renderHook(() => useHash());\n\n  const hash = result.current[0];\n  expect(hash).toBe('#abc');\n});","file":"useHash.test.ts","skipped":false,"dir":"tests"},{"name":"returns latest url hash when change the hash with setHash","suites":[],"updatePoint":{"line":33,"column":63},"line":33,"code":"test('returns latest url hash when change the hash with setHash', () => {\n  const { result } = renderHook(() => useHash());\n  const hash = result.current[0];\n  const setHash = result.current[1];\n  expect(hash).toBe('#');\n  act(() => {\n    setHash('#abc');\n  });\n  const hash2 = result.current[0];\n  expect(hash2).toBe('#abc');\n});","file":"useHash.test.ts","skipped":false,"dir":"tests"},{"name":"returns latest url hash when change the hash with \"hashchange\" event","suites":[],"updatePoint":{"line":45,"column":72},"line":45,"code":"it('returns latest url hash when change the hash with \"hashchange\" event', () => {\n  const { result } = renderHook(() => useHash());\n  const hash = result.current[0];\n  expect(hash).toBe('#');\n  act(() => {\n    window.location.hash = '#abc';\n  });\n  const hash2 = result.current[0];\n  expect(hash2).toBe('#abc');\n});","file":"useHash.test.ts","skipped":false,"dir":"tests"},{"name":"should init hook with default delay","suites":[],"updatePoint":{"line":23,"column":39},"line":23,"code":"it('should init hook with default delay', () => {\n  const { result } = renderHook(() => useInterval(callback));\n\n  expect(result.current).toBeUndefined();\n  expect(setInterval).toHaveBeenCalledTimes(1);\n  // if not delay provided, it's assumed as 0\n  expect(setInterval).toHaveBeenCalledWith(expect.any(Function), 0);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should init hook with custom delay","suites":[],"updatePoint":{"line":32,"column":38},"line":32,"code":"it('should init hook with custom delay', () => {\n  const { result } = renderHook(() => useInterval(callback, 5000));\n\n  expect(result.current).toBeUndefined();\n  expect(setInterval).toHaveBeenCalledTimes(1);\n  expect(setInterval).toHaveBeenCalledWith(expect.any(Function), 5000);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should init hook without delay","suites":[],"updatePoint":{"line":40,"column":34},"line":40,"code":"it('should init hook without delay', () => {\n  const { result } = renderHook(() => useInterval(callback, null));\n\n  expect(result.current).toBeUndefined();\n  // if null delay provided, it's assumed as no delay\n  expect(setInterval).not.toHaveBeenCalled();\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should repeatedly calls provided callback with a fixed time delay between each call","suites":[],"updatePoint":{"line":48,"column":87},"line":48,"code":"it('should repeatedly calls provided callback with a fixed time delay between each call', () => {\n  renderHook(() => useInterval(callback, 200));\n  expect(callback).not.toHaveBeenCalled();\n\n  // fast-forward time until 1s before it should be executed\n  jest.advanceTimersByTime(199);\n  expect(callback).not.toHaveBeenCalled();\n\n  // fast-forward until 1st call should be executed\n  jest.advanceTimersByTime(1);\n  expect(callback).toHaveBeenCalledTimes(1);\n\n  // fast-forward until next timer should be executed\n  jest.advanceTimersToNextTimer();\n  expect(callback).toHaveBeenCalledTimes(2);\n\n  // fast-forward until 3 more timers should be executed\n  jest.advanceTimersToNextTimer(3);\n  expect(callback).toHaveBeenCalledTimes(5);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should clear interval on unmount","suites":[],"updatePoint":{"line":69,"column":36},"line":69,"code":"it('should clear interval on unmount', () => {\n  const { unmount } = renderHook(() => useInterval(callback, 200));\n  const initialTimerCount = jest.getTimerCount();\n  expect(clearInterval).not.toHaveBeenCalled();\n\n  unmount();\n\n  expect(clearInterval).toHaveBeenCalledTimes(1);\n  expect(jest.getTimerCount()).toBe(initialTimerCount - 1);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should handle new interval when delay is updated","suites":[],"updatePoint":{"line":80,"column":52},"line":80,"code":"it('should handle new interval when delay is updated', () => {\n  let delay = 200;\n  const { rerender } = renderHook(() => useInterval(callback, delay));\n  expect(callback).not.toHaveBeenCalled();\n\n  // fast-forward initial delay\n  jest.advanceTimersByTime(200);\n  expect(callback).toHaveBeenCalledTimes(1);\n\n  // update delay by increasing previous one\n  delay = 500;\n  rerender();\n\n  // fast-forward initial delay again but this time it should not execute the cb\n  jest.advanceTimersByTime(200);\n  expect(callback).toHaveBeenCalledTimes(1);\n\n  // fast-forward remaining time for new delay\n  jest.advanceTimersByTime(300);\n  expect(callback).toHaveBeenCalledTimes(2);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should clear pending interval when delay is updated","suites":[],"updatePoint":{"line":102,"column":55},"line":102,"code":"it('should clear pending interval when delay is updated', () => {\n  let delay = 200;\n  const { rerender } = renderHook(() => useInterval(callback, delay));\n  expect(clearInterval).not.toHaveBeenCalled();\n  const initialTimerCount = jest.getTimerCount();\n\n  // update delay while there is a pending interval\n  delay = 500;\n  rerender();\n\n  expect(clearInterval).toHaveBeenCalledTimes(1);\n  expect(jest.getTimerCount()).toBe(initialTimerCount);\n});","file":"useInterval.test.ts","skipped":false,"dir":"tests"},{"name":"should return a ref with the latest value on initial render","suites":[],"updatePoint":{"line":6,"column":63},"line":6,"code":"it('should return a ref with the latest value on initial render', () => {\n  const { result } = setUp();\n\n  expect(result.current).toEqual({ current: 0 });\n});","file":"useLatest.test.ts","skipped":false,"dir":"tests"},{"name":"should always return a ref with the latest value after each update","suites":[],"updatePoint":{"line":12,"column":70},"line":12,"code":"it('should always return a ref with the latest value after each update', () => {\n  const { result, rerender } = setUp();\n\n  rerender({ state: 2 });\n  expect(result.current).toEqual({ current: 2 });\n\n  rerender({ state: 4 });\n  expect(result.current).toEqual({ current: 4 });\n\n  rerender({ state: 6 });\n  expect(result.current).toEqual({ current: 6 });\n});","file":"useLatest.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useList"],"updatePoint":{"line":6,"column":23},"line":6,"code":"  it('should be defined', () => {\n    expect(useList).toBeDefined();\n  });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should init with 1st parameter and actions","suites":["useList"],"updatePoint":{"line":21,"column":48},"line":21,"code":"  it('should init with 1st parameter and actions', () => {\n    const hook = getHook([1, 2, 3]);\n    const [, [list, actions]] = hook.result.current;\n\n    expect(list).toEqual([1, 2, 3]);\n    expect(actions).toStrictEqual({\n      set: expect.any(Function),\n      push: expect.any(Function),\n      updateAt: expect.any(Function),\n      insertAt: expect.any(Function),\n      update: expect.any(Function),\n      updateFirst: expect.any(Function),\n      upsert: expect.any(Function),\n      sort: expect.any(Function),\n      filter: expect.any(Function),\n      removeAt: expect.any(Function),\n      remove: expect.any(Function),\n      clear: expect.any(Function),\n      reset: expect.any(Function),\n    });\n  });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should return the same actions object each render","suites":["useList"],"updatePoint":{"line":43,"column":55},"line":43,"code":"  it('should return the same actions object each render', () => {\n    const hook = getHook([1, 2, 3]);\n    const [, [, actions]] = hook.result.current;\n\n    act(() => {\n      actions.set([1, 2, 3, 4]);\n    });\n\n    expect(actions).toBe(hook.result.current[1][1]);\n  });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should default with empty array","suites":["useList"],"updatePoint":{"line":54,"column":37},"line":54,"code":"  it('should default with empty array', () => {\n    expect(getHook().result.current[1][0]).toEqual([]);\n  });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should reset list with given array and cause re-render","suites":["useList","set()"],"updatePoint":{"line":59,"column":62},"line":59,"code":"    it('should reset list with given array and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { set }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        set([1, 2, 3, 4]);\n      });\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, 4]);\n      expect(hook.result.current[0]).toBe(2);\n\n      act(() => {\n        set([1, 2, 3, 4, 5]);\n      });\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, 4, 5]);\n      expect(hook.result.current[0]).toBe(3);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should add arbitrary amount of items to the end and cause re-render","suites":["useList","push()"],"updatePoint":{"line":79,"column":75},"line":79,"code":"    it('should add arbitrary amount of items to the end and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { push }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        push(1, 2, 3, 4);\n      });\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, 1, 2, 3, 4]);\n      expect(hook.result.current[0]).toBe(2);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should not do anything if called with no parameters","suites":["useList","push()"],"updatePoint":{"line":91,"column":59},"line":91,"code":"    it('should not do anything if called with no parameters', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [list, { push }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        push();\n      });\n      expect(hook.result.current[0]).toBe(1);\n      expect(list).toBe(hook.result.current[1][0]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should replace item at given index with given value and cause re-render","suites":["useList","updateAt()"],"updatePoint":{"line":105,"column":79},"line":105,"code":"    it('should replace item at given index with given value and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { updateAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        updateAt(1, 5);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 5, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should work fine if target index is out of array length","suites":["useList","updateAt()"],"updatePoint":{"line":117,"column":63},"line":117,"code":"    it('should work fine if target index is out of array length', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { updateAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        updateAt(5, 6);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, undefined, undefined, 6]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should insert item at given index shifting all the right elements and cause re-render","suites":["useList","insertAt()"],"updatePoint":{"line":131,"column":93},"line":131,"code":"    it('should insert item at given index shifting all the right elements and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { insertAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        insertAt(1, 5);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 5, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should work if index is out of array length","suites":["useList","insertAt()"],"updatePoint":{"line":143,"column":51},"line":143,"code":"    it('should work if index is out of array length', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { insertAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        insertAt(5, 6);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, undefined, undefined, 6]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should replace all items that matches the predicate and cause re-render","suites":["useList","update()"],"updatePoint":{"line":157,"column":79},"line":157,"code":"    it('should replace all items that matches the predicate and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { update }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        update((a, _) => a % 2 === 1, 0);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([0, 2, 0]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should pass two parameters to the predicate, iterated element and new one","suites":["useList","update()"],"updatePoint":{"line":169,"column":81},"line":169,"code":"    it('should pass two parameters to the predicate, iterated element and new one', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { update }]] = hook.result.current;\n      const spy = jest.fn();\n\n      act(() => {\n        update(spy, 0);\n      });\n\n      expect(spy.mock.calls[0][0]).toBe(1);\n      expect(spy.mock.calls[0][1]).toBe(0);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should replace first items that matches the predicate and cause re-render","suites":["useList","updateFirst()"],"updatePoint":{"line":184,"column":81},"line":184,"code":"    it('should replace first items that matches the predicate and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { updateFirst }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        updateFirst((a, _) => a % 2 === 1, 0);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([0, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should pass two parameters to the predicate, iterated element and new one","suites":["useList","updateFirst()"],"updatePoint":{"line":196,"column":81},"line":196,"code":"    it('should pass two parameters to the predicate, iterated element and new one', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { updateFirst }]] = hook.result.current;\n      const spy = jest.fn();\n\n      act(() => {\n        updateFirst(spy, 0);\n      });\n\n      expect(spy.mock.calls[0].length).toBe(2);\n      expect(spy.mock.calls[0][0]).toBe(1);\n      expect(spy.mock.calls[0][1]).toBe(0);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should replace first item that matches the predicate and cause re-render","suites":["useList","upsert()"],"updatePoint":{"line":212,"column":80},"line":212,"code":"    it('should replace first item that matches the predicate and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { upsert }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        upsert((a, _) => a === 1, 0);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([0, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"otherwise should push it to the list and cause re-render","suites":["useList","upsert()"],"updatePoint":{"line":224,"column":64},"line":224,"code":"    it('otherwise should push it to the list and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { upsert }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        upsert((a, _) => a === 5, 0);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, 0]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should pass two parameters to the predicate, iterated element and new one","suites":["useList","upsert()"],"updatePoint":{"line":236,"column":81},"line":236,"code":"    it('should pass two parameters to the predicate, iterated element and new one', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { upsert }]] = hook.result.current;\n      const spy = jest.fn();\n\n      act(() => {\n        upsert(spy, 0);\n      });\n\n      expect(spy.mock.calls[0].length).toBe(2);\n      expect(spy.mock.calls[0][0]).toBe(1);\n      expect(spy.mock.calls[0][1]).toBe(0);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should sort the list with given comparator and cause re-render","suites":["useList","sort()"],"updatePoint":{"line":252,"column":70},"line":252,"code":"    it('should sort the list with given comparator and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { sort }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        sort((a, b) => (a === b ? 0 : a < b ? 1 : -1));\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([3, 2, 1]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should use default array`s sorting function of called without parameters","suites":["useList","sort()"],"updatePoint":{"line":264,"column":80},"line":264,"code":"    it('should use default array`s sorting function of called without parameters', () => {\n      const hook = getHook([2, 3, 1]);\n      const [, [, { sort }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        sort();\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should filter the list with given predicate and cause re-render","suites":["useList","filter()"],"updatePoint":{"line":278,"column":71},"line":278,"code":"    it('should filter the list with given predicate and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { filter }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        filter((val) => val % 2 === 1);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should pass three parameters to the predicate, iterated element, it`s index and filtered array","suites":["useList","filter()"],"updatePoint":{"line":290,"column":102},"line":290,"code":"    it('should pass three parameters to the predicate, iterated element, it`s index and filtered array', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [list, { filter }]] = hook.result.current;\n      const spy = jest.fn((_, _2, _3) => false);\n\n      act(() => {\n        filter(spy);\n      });\n\n      expect(spy.mock.calls[0].length).toBe(3);\n      expect(spy.mock.calls[0][0]).toBe(1);\n      expect(spy.mock.calls[0][1]).toBe(0);\n      expect(spy.mock.calls[0][2]).toEqual(list);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should remove item at given index and cause re-render","suites":["useList","removeAt()"],"updatePoint":{"line":307,"column":61},"line":307,"code":"    it('should remove item at given index and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { removeAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        removeAt(1);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing if index is out of array length, although it should cause re-render","suites":["useList","removeAt()"],"updatePoint":{"line":319,"column":93},"line":319,"code":"    it('should do nothing if index is out of array length, although it should cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { removeAt }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        removeAt(5);\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should be a ref to removeAt","suites":["useList","remove()"],"updatePoint":{"line":333,"column":35},"line":333,"code":"    it('should be a ref to removeAt', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { remove, removeAt }]] = hook.result.current;\n\n      expect(remove).toBe(removeAt);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should clear the list and cause re-render","suites":["useList","clear()"],"updatePoint":{"line":342,"column":49},"line":342,"code":"    it('should clear the list and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { clear }]] = hook.result.current;\n\n      expect(hook.result.current[0]).toBe(1);\n      act(() => {\n        clear();\n      });\n      expect(hook.result.current[0]).toBe(2);\n      expect(hook.result.current[1][0]).toEqual([]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"should reset list to initial values and cause re-render","suites":["useList","reset()"],"updatePoint":{"line":356,"column":63},"line":356,"code":"    it('should reset list to initial values and cause re-render', () => {\n      const hook = getHook([1, 2, 3]);\n      const [, [, { set, reset }]] = hook.result.current;\n\n      act(() => {\n        set([1, 2, 3, 4, 6, 7, 8]);\n      });\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3, 4, 6, 7, 8]);\n\n      expect(hook.result.current[0]).toBe(2);\n      act(() => {\n        reset();\n      });\n      expect(hook.result.current[0]).toBe(3);\n      expect(hook.result.current[1][0]).toEqual([1, 2, 3]);\n    });","file":"useList.test.ts","skipped":false,"dir":"tests"},{"name":"retrieves an existing value from localStorage","suites":[],"updatePoint":{"line":11,"column":51},"line":11,"code":"  it('retrieves an existing value from localStorage', () => {\n    localStorage.setItem('foo', '\"bar\"');\n    const { result } = renderHook(() => useLocalStorage('foo'));\n    const [state] = result.current;\n    expect(state).toEqual('bar');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"should return initialValue if localStorage empty and set that to localStorage","suites":[],"updatePoint":{"line":18,"column":83},"line":18,"code":"  it('should return initialValue if localStorage empty and set that to localStorage', () => {\n    const { result } = renderHook(() => useLocalStorage('foo', 'bar'));\n    const [state] = result.current;\n    expect(state).toEqual('bar');\n    expect(localStorage.__STORE__.foo).toEqual('\"bar\"');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"prefers existing value over initial state","suites":[],"updatePoint":{"line":25,"column":47},"line":25,"code":"  it('prefers existing value over initial state', () => {\n    localStorage.setItem('foo', '\"bar\"');\n    const { result } = renderHook(() => useLocalStorage('foo', 'baz'));\n    const [state] = result.current;\n    expect(state).toEqual('bar');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"does not clobber existing localStorage with initialState","suites":[],"updatePoint":{"line":32,"column":62},"line":32,"code":"  it('does not clobber existing localStorage with initialState', () => {\n    localStorage.setItem('foo', '\"bar\"');\n    const { result } = renderHook(() => useLocalStorage('foo', 'buzz'));\n    expect(result.current).toBeTruthy();\n    expect(localStorage.__STORE__.foo).toEqual('\"bar\"');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"correctly updates localStorage","suites":[],"updatePoint":{"line":39,"column":36},"line":39,"code":"  it('correctly updates localStorage', () => {\n    const { result, rerender } = renderHook(() => useLocalStorage('foo', 'bar'));\n\n    const [, setFoo] = result.current;\n    act(() => setFoo('baz'));\n    rerender();\n\n    expect(localStorage.__STORE__.foo).toEqual('\"baz\"');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"should return undefined if no initialValue provided and localStorage empty","suites":[],"updatePoint":{"line":49,"column":80},"line":49,"code":"  it('should return undefined if no initialValue provided and localStorage empty', () => {\n    const { result } = renderHook(() => useLocalStorage('some_key'));\n\n    expect(result.current[0]).toBeUndefined();\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"returns and allows null setting","suites":[],"updatePoint":{"line":55,"column":37},"line":55,"code":"  it('returns and allows null setting', () => {\n    localStorage.setItem('foo', 'null');\n    const { result, rerender } = renderHook(() => useLocalStorage('foo'));\n    const [foo1, setFoo] = result.current;\n    act(() => setFoo(null));\n    rerender();\n\n    const [foo2] = result.current;\n    expect(foo1).toEqual(null);\n    expect(foo2).toEqual(null);\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"sets initialState if initialState is an object","suites":[],"updatePoint":{"line":67,"column":52},"line":67,"code":"  it('sets initialState if initialState is an object', () => {\n    renderHook(() => useLocalStorage('foo', { bar: true }));\n    expect(localStorage.__STORE__.foo).toEqual('{\"bar\":true}');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"correctly and promptly returns a new value","suites":[],"updatePoint":{"line":72,"column":48},"line":72,"code":"  it('correctly and promptly returns a new value', () => {\n    const { result, rerender } = renderHook(() => useLocalStorage('foo', 'bar'));\n\n    const [, setFoo] = result.current;\n    act(() => setFoo('baz'));\n    rerender();\n\n    const [foo] = result.current;\n    expect(foo).toEqual('baz');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"reinitializes state when key changes","suites":[],"updatePoint":{"line":83,"column":42},"line":83,"code":"  it('reinitializes state when key changes', () => {\n    let key = 'foo';\n    const { result, rerender } = renderHook(() => useLocalStorage(key, 'bar'));\n\n    const [, setState] = result.current;\n    act(() => setState('baz'));\n    key = 'bar';\n    rerender();\n\n    const [state] = result.current;\n    expect(state).toEqual('bar');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"parses out objects from localStorage","suites":[],"updatePoint":{"line":116,"column":42},"line":116,"code":"  it('parses out objects from localStorage', () => {\n    localStorage.setItem('foo', JSON.stringify({ ok: true }));\n    const { result } = renderHook(() => useLocalStorage<{ ok: boolean }>('foo'));\n    const [foo] = result.current;\n    expect(foo!.ok).toEqual(true);\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"safely initializes objects to localStorage","suites":[],"updatePoint":{"line":123,"column":48},"line":123,"code":"  it('safely initializes objects to localStorage', () => {\n    const { result } = renderHook(() => useLocalStorage<{ ok: boolean }>('foo', { ok: true }));\n    const [foo] = result.current;\n    expect(foo!.ok).toEqual(true);\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"safely sets objects to localStorage","suites":[],"updatePoint":{"line":129,"column":41},"line":129,"code":"  it('safely sets objects to localStorage', () => {\n    const { result, rerender } = renderHook(() =>\n      useLocalStorage<{ ok: any }>('foo', { ok: true })\n    );\n\n    const [, setFoo] = result.current;\n    act(() => setFoo({ ok: 'bar' }));\n    rerender();\n\n    const [foo] = result.current;\n    expect(foo!.ok).toEqual('bar');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"safely returns objects from updates","suites":[],"updatePoint":{"line":142,"column":41},"line":142,"code":"  it('safely returns objects from updates', () => {\n    const { result, rerender } = renderHook(() =>\n      useLocalStorage<{ ok: any }>('foo', { ok: true })\n    );\n\n    const [, setFoo] = result.current;\n    act(() => setFoo({ ok: 'bar' }));\n    rerender();\n\n    const [foo] = result.current;\n    expect(foo).toBeInstanceOf(Object);\n    expect(foo!.ok).toEqual('bar');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"sets localStorage from the function updater","suites":[],"updatePoint":{"line":156,"column":49},"line":156,"code":"  it('sets localStorage from the function updater', () => {\n    const { result, rerender } = renderHook(() =>\n      useLocalStorage<{ foo: string; fizz?: string }>('foo', { foo: 'bar' })\n    );\n\n    const [, setFoo] = result.current;\n    act(() => setFoo((state) => ({ ...state!, fizz: 'buzz' })));\n    rerender();\n\n    const [value] = result.current;\n    expect(value!.foo).toEqual('bar');\n    expect(value!.fizz).toEqual('buzz');\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"rejects nullish or undefined keys","suites":[],"updatePoint":{"line":170,"column":39},"line":170,"code":"  it('rejects nullish or undefined keys', () => {\n    const { result } = renderHook(() => useLocalStorage(null as any));\n    try {\n      (() => {\n        return result.current;\n      })();\n      fail('hook should have thrown');\n    } catch (e) {\n      expect(String(e)).toMatch(/key may not be/i);\n    }\n  });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"memoizes an object between rerenders","suites":["eslint react-hooks/rules-of-hooks"],"updatePoint":{"line":184,"column":44},"line":184,"code":"    it('memoizes an object between rerenders', () => {\n      const { result, rerender } = renderHook(() => useLocalStorage('foo', { ok: true }));\n      (() => {\n        return result.current; // if localStorage isn't set then r1 and r2 will be different\n      })();\n      rerender();\n      const [r2] = result.current;\n      rerender();\n      const [r3] = result.current;\n      expect(r2).toBe(r3);\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"memoizes an object immediately if localStorage is already set","suites":["eslint react-hooks/rules-of-hooks"],"updatePoint":{"line":196,"column":69},"line":196,"code":"    it('memoizes an object immediately if localStorage is already set', () => {\n      localStorage.setItem('foo', JSON.stringify({ ok: true }));\n      const { result, rerender } = renderHook(() => useLocalStorage('foo', { ok: true }));\n\n      const [r1] = result.current; // if localStorage isn't set then r1 and r2 will be different\n      rerender();\n      const [r2] = result.current;\n      expect(r1).toBe(r2);\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"memoizes the setState function","suites":["eslint react-hooks/rules-of-hooks"],"updatePoint":{"line":206,"column":38},"line":206,"code":"    it('memoizes the setState function', () => {\n      localStorage.setItem('foo', JSON.stringify({ ok: true }));\n      const { result, rerender } = renderHook(() => useLocalStorage('foo', { ok: true }));\n      const [, s1] = result.current;\n      rerender();\n      const [, s2] = result.current;\n      expect(s1).toBe(s2);\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"returns a string when localStorage is a stringified object","suites":["Options: raw"],"updatePoint":{"line":217,"column":66},"line":217,"code":"    it('returns a string when localStorage is a stringified object', () => {\n      localStorage.setItem('foo', JSON.stringify({ fizz: 'buzz' }));\n      const { result } = renderHook(() => useLocalStorage('foo', null, { raw: true }));\n      const [foo] = result.current;\n      expect(typeof foo).toBe('string');\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"returns a string after an update","suites":["Options: raw"],"updatePoint":{"line":224,"column":40},"line":224,"code":"    it('returns a string after an update', () => {\n      localStorage.setItem('foo', JSON.stringify({ fizz: 'buzz' }));\n      const { result, rerender } = renderHook(() => useLocalStorage('foo', null, { raw: true }));\n\n      const [, setFoo] = result.current;\n\n      act(() => setFoo({ fizz: 'bang' } as any));\n      rerender();\n\n      const [foo] = result.current;\n      expect(typeof foo).toBe('string');\n\n      expect(JSON.parse(foo!)).toBeInstanceOf(Object);\n\n      // expect(JSON.parse(foo!).fizz).toEqual('bang');\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"still forces setState to a string","suites":["Options: raw"],"updatePoint":{"line":241,"column":41},"line":241,"code":"    it('still forces setState to a string', () => {\n      localStorage.setItem('foo', JSON.stringify({ fizz: 'buzz' }));\n      const { result, rerender } = renderHook(() => useLocalStorage('foo', null, { raw: true }));\n\n      const [, setFoo] = result.current;\n\n      act(() => setFoo({ fizz: 'bang' } as any));\n      rerender();\n\n      const [value] = result.current;\n\n      expect(JSON.parse(value!).fizz).toEqual('bang');\n    });","file":"useLocalStorage.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useLogger"],"updatePoint":{"line":7,"column":23},"line":7,"code":"  it('should be defined', () => {\n    expect(useLogger).toBeDefined();\n  });","file":"useLogger.test.ts","skipped":false,"dir":"tests"},{"name":"should log the provided props on mount","suites":["useLogger"],"updatePoint":{"line":11,"column":44},"line":11,"code":"  it('should log the provided props on mount', () => {\n    const props = { question: 'What is the meaning?', answer: 42 };\n    renderHook(() => useLogger('Test', props));\n\n    expect(logSpy).toBeCalledTimes(1);\n    expect(logSpy).toHaveBeenLastCalledWith('Test mounted', props);\n  });","file":"useLogger.test.ts","skipped":false,"dir":"tests"},{"name":"should log when the component has unmounted","suites":["useLogger"],"updatePoint":{"line":19,"column":49},"line":19,"code":"  it('should log when the component has unmounted', () => {\n    const props = { question: 'What is the meaning?', answer: 42 };\n    const { unmount } = renderHook(() => useLogger('Test', props));\n\n    unmount();\n\n    expect(logSpy).toHaveBeenLastCalledWith('Test unmounted');\n  });","file":"useLogger.test.ts","skipped":false,"dir":"tests"},{"name":"should log updates as props change","suites":["useLogger"],"updatePoint":{"line":28,"column":40},"line":28,"code":"  it('should log updates as props change', () => {\n    const { rerender } = renderHook(\n      ({ componentName, props }: { componentName: string; props: any }) =>\n        useLogger(componentName, props),\n      {\n        initialProps: { componentName: 'Test', props: { one: 1 } },\n      }\n    );\n\n    const newProps = { one: 1, two: 2 };\n    rerender({ componentName: 'Test', props: newProps });\n\n    expect(logSpy).toHaveBeenLastCalledWith('Test updated', newProps);\n  });","file":"useLogger.test.ts","skipped":false,"dir":"tests"},{"name":"should init map and utils","suites":[],"updatePoint":{"line":6,"column":29},"line":6,"code":"it('should init map and utils', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n  const [map, utils] = result.current;\n\n  expect(map).toEqual({ foo: 'bar', a: 1 });\n  expect(utils).toStrictEqual({\n    get: expect.any(Function),\n    set: expect.any(Function),\n    setAll: expect.any(Function),\n    remove: expect.any(Function),\n    reset: expect.any(Function),\n  });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should init empty map if not initial object provided","suites":[],"updatePoint":{"line":20,"column":56},"line":20,"code":"it('should init empty map if not initial object provided', () => {\n  const { result } = setUp();\n\n  expect(result.current[0]).toEqual({});\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should get corresponding value for initial provided key","suites":[],"updatePoint":{"line":26,"column":59},"line":26,"code":"it('should get corresponding value for initial provided key', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  let value;\n  act(() => {\n    value = utils.get('a');\n  });\n\n  expect(value).toBe(1);\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should get corresponding value for existing provided key","suites":[],"updatePoint":{"line":38,"column":60},"line":38,"code":"it('should get corresponding value for existing provided key', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n\n  act(() => {\n    result.current[1].set('a', 99);\n  });\n\n  let value;\n  act(() => {\n    value = result.current[1].get('a');\n  });\n\n  expect(value).toBe(99);\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should get undefined for non-existing provided key","suites":[],"updatePoint":{"line":53,"column":54},"line":53,"code":"it('should get undefined for non-existing provided key', () => {\n  const { result } = setUp<{ foo: string; a: number; nonExisting?: any }>({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  let value;\n  act(() => {\n    value = utils.get('nonExisting');\n  });\n\n  expect(value).toBeUndefined();\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should set new key-value pair","suites":[],"updatePoint":{"line":65,"column":33},"line":65,"code":"it('should set new key-value pair', () => {\n  const { result } = setUp<{ foo: string; a: number; newKey?: number }>({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.set('newKey', 99);\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', a: 1, newKey: 99 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should override current value if setting existing key","suites":[],"updatePoint":{"line":76,"column":57},"line":76,"code":"it('should override current value if setting existing key', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.set('foo', 'qux');\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'qux', a: 1 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should set new map","suites":[],"updatePoint":{"line":87,"column":22},"line":87,"code":"it('should set new map', () => {\n  const { result } = setUp<{ foo: string; a: number; newKey?: number }>({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.setAll({ foo: 'foo', a: 2 });\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'foo', a: 2 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should remove corresponding key-value pair for existing provided key","suites":[],"updatePoint":{"line":98,"column":72},"line":98,"code":"it('should remove corresponding key-value pair for existing provided key', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.remove('foo');\n  });\n\n  expect(result.current[0]).toEqual({ a: 1 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing if removing non-existing provided key","suites":[],"updatePoint":{"line":109,"column":59},"line":109,"code":"it('should do nothing if removing non-existing provided key', () => {\n  const { result } = setUp<{ foo: string; a: number; nonExisting?: any }>({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.remove('nonExisting');\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', a: 1 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should reset map to initial object provided","suites":[],"updatePoint":{"line":120,"column":47},"line":120,"code":"it('should reset map to initial object provided', () => {\n  const { result } = setUp<{ foo: string; a: number; z?: number }>({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.set('z', 99);\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', a: 1, z: 99 });\n\n  act(() => {\n    utils.reset();\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', a: 1 });\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"should memoize actions with side effects","suites":[],"updatePoint":{"line":137,"column":44},"line":137,"code":"it('should memoize actions with side effects', () => {\n  const { result } = setUp({ foo: 'bar', a: 1 });\n  const [, utils] = result.current;\n  const { set, remove, reset } = utils;\n\n  act(() => {\n    set('foo', 'baz');\n  });\n\n  expect(result.current[1].set).toBe(set);\n  expect(result.current[1].remove).toBe(remove);\n  expect(result.current[1].reset).toBe(reset);\n});","file":"useMap.test.ts","skipped":false,"dir":"tests"},{"name":"by default, state defaults every value to -1","suites":[],"updatePoint":{"line":4,"column":48},"line":4,"code":"it('by default, state defaults every value to -1', () => {\n  const { result } = renderHook(() => useMeasure());\n\n  act(() => {\n    const div = document.createElement('div');\n    (result.current[0] as UseMeasureRef)(div);\n  });\n\n  expect(result.current[1]).toMatchObject({\n    width: 0,\n    height: 0,\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  });\n});","file":"useMeasure.test.ts","skipped":false,"dir":"tests"},{"name":"synchronously sets up ResizeObserver listener","suites":[],"updatePoint":{"line":22,"column":49},"line":22,"code":"it('synchronously sets up ResizeObserver listener', () => {\n  let listener: ((rect: any) => void) | undefined = undefined;\n  (window as any).ResizeObserver = class ResizeObserver {\n    constructor(ls) {\n      listener = ls;\n    }\n    observe() {}\n    disconnect() {}\n  };\n\n  const { result } = renderHook(() => useMeasure());\n\n  act(() => {\n    const div = document.createElement('div');\n    (result.current[0] as UseMeasureRef)(div);\n  });\n\n  expect(typeof listener).toBe('function');\n});","file":"useMeasure.test.ts","skipped":false,"dir":"tests"},{"name":"tracks rectangle of a DOM element","suites":[],"updatePoint":{"line":42,"column":37},"line":42,"code":"it('tracks rectangle of a DOM element', () => {\n  let listener: ((rect: any) => void) | undefined = undefined;\n  (window as any).ResizeObserver = class ResizeObserver {\n    constructor(ls) {\n      listener = ls;\n    }\n    observe() {}\n    disconnect() {}\n  };\n\n  const { result } = renderHook(() => useMeasure());\n\n  act(() => {\n    const div = document.createElement('div');\n    (result.current[0] as UseMeasureRef)(div);\n  });\n\n  act(() => {\n    listener!([\n      {\n        contentRect: {\n          x: 1,\n          y: 2,\n          width: 200,\n          height: 200,\n          top: 100,\n          bottom: 0,\n          left: 100,\n          right: 0,\n        },\n      },\n    ]);\n  });\n\n  expect(result.current[1]).toMatchObject({\n    x: 1,\n    y: 2,\n    width: 200,\n    height: 200,\n    top: 100,\n    bottom: 0,\n    left: 100,\n    right: 0,\n  });\n});","file":"useMeasure.test.ts","skipped":false,"dir":"tests"},{"name":"tracks multiple updates","suites":[],"updatePoint":{"line":88,"column":27},"line":88,"code":"it('tracks multiple updates', () => {\n  let listener: ((rect: any) => void) | undefined = undefined;\n  (window as any).ResizeObserver = class ResizeObserver {\n    constructor(ls) {\n      listener = ls;\n    }\n    observe() {}\n    disconnect() {}\n  };\n\n  const { result } = renderHook(() => useMeasure());\n\n  act(() => {\n    const div = document.createElement('div');\n    (result.current[0] as UseMeasureRef)(div);\n  });\n\n  act(() => {\n    listener!([\n      {\n        contentRect: {\n          x: 1,\n          y: 1,\n          width: 1,\n          height: 1,\n          top: 1,\n          bottom: 1,\n          left: 1,\n          right: 1,\n        },\n      },\n    ]);\n  });\n\n  expect(result.current[1]).toMatchObject({\n    x: 1,\n    y: 1,\n    width: 1,\n    height: 1,\n    top: 1,\n    bottom: 1,\n    left: 1,\n    right: 1,\n  });\n\n  act(() => {\n    listener!([\n      {\n        contentRect: {\n          x: 2,\n          y: 2,\n          width: 2,\n          height: 2,\n          top: 2,\n          bottom: 2,\n          left: 2,\n          right: 2,\n        },\n      },\n    ]);\n  });\n\n  expect(result.current[1]).toMatchObject({\n    x: 2,\n    y: 2,\n    width: 2,\n    height: 2,\n    top: 2,\n    bottom: 2,\n    left: 2,\n    right: 2,\n  });\n});","file":"useMeasure.test.ts","skipped":false,"dir":"tests"},{"name":"calls .disconnect() on ResizeObserver when component unmounts","suites":[],"updatePoint":{"line":162,"column":65},"line":162,"code":"it('calls .disconnect() on ResizeObserver when component unmounts', () => {\n  const disconnect = jest.fn();\n  (window as any).ResizeObserver = class ResizeObserver {\n    observe() {}\n    disconnect() {\n      disconnect();\n    }\n  };\n\n  const { result, unmount } = renderHook(() => useMeasure());\n\n  act(() => {\n    const div = document.createElement('div');\n    (result.current[0] as UseMeasureRef)(div);\n  });\n\n  expect(disconnect).toHaveBeenCalledTimes(0);\n\n  unmount();\n\n  expect(disconnect).toHaveBeenCalledTimes(1);\n});","file":"useMeasure.test.ts","skipped":false,"dir":"tests"},{"name":"should return true if media query matches","suites":["useMedia"],"updatePoint":{"line":18,"column":47},"line":18,"code":"  it('should return true if media query matches', () => {\n    const { result } = renderHook(() => useMedia('(min-width: 500px)'));\n    expect(result.current).toBe(true);\n  });","file":"useMedia.test.ts","skipped":false,"dir":"tests"},{"name":"should return false if media query does not match","suites":["useMedia"],"updatePoint":{"line":22,"column":55},"line":22,"code":"  it('should return false if media query does not match', () => {\n    const { result } = renderHook(() => useMedia('(min-width: 1200px)'));\n    expect(result.current).toBe(false);\n  });","file":"useMedia.test.ts","skipped":false,"dir":"tests"},{"name":"should return default state before hydration","suites":["useMedia"],"updatePoint":{"line":26,"column":50},"line":26,"code":"  it('should return default state before hydration', () => {\n    const { result } = renderHookSSR(() => useMedia('(min-width: 500px)', false));\n    expect(result.current).toBe(false);\n  });","file":"useMedia.test.ts","skipped":false,"dir":"tests"},{"name":"should return media query result after hydration","suites":["useMedia"],"updatePoint":{"line":30,"column":54},"line":30,"code":"  it('should return media query result after hydration', async () => {\n    const { result, hydrate } = renderHookSSR(() => useMedia('(min-width: 500px)', false));\n    expect(result.current).toBe(false);\n    hydrate();\n    expect(result.current).toBe(true);\n  });","file":"useMedia.test.ts","skipped":false,"dir":"tests"},{"name":"should return media query result after hydration","suites":["useMedia"],"updatePoint":{"line":36,"column":54},"line":36,"code":"  it('should return media query result after hydration', async () => {\n    const { result, hydrate } = renderHookSSR(() => useMedia('(min-width: 1200px)', true));\n    expect(result.current).toBe(true);\n    hydrate();\n    expect(result.current).toBe(false);\n  });","file":"useMedia.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useMediatedState"],"updatePoint":{"line":7,"column":23},"line":7,"code":"  it('should be defined', () => {\n    expect(useMediatedState).toBeDefined();\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"should return array of two elements","suites":["useMediatedState"],"updatePoint":{"line":18,"column":41},"line":18,"code":"  it('should return array of two elements', () => {\n    const [, hook] = getHook();\n\n    expect(Array.isArray(hook.result.current)).toBe(true);\n    expect(hook.result.current[0]).toBe(2);\n    expect(typeof hook.result.current[1]).toBe('function');\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"should act like regular useState but with mediator call on each setState","suites":["useMediatedState"],"updatePoint":{"line":26,"column":78},"line":26,"code":"  it('should act like regular useState but with mediator call on each setState', () => {\n    const [spy, hook] = getHook();\n\n    expect(hook.result.current[0]).toBe(2);\n\n    act(() => hook.result.current[1](3));\n    expect(hook.result.current[0]).toBe(1.5);\n    expect(spy).toHaveBeenCalledTimes(1);\n\n    act(() => hook.result.current[1](4));\n    expect(hook.result.current[0]).toBe(2);\n    expect(spy).toHaveBeenCalledTimes(2);\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"should not call mediator on init","suites":["useMediatedState"],"updatePoint":{"line":40,"column":38},"line":40,"code":"  it('should not call mediator on init', () => {\n    const [spy] = getHook();\n\n    expect(spy).toHaveBeenCalledTimes(0);\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"mediator should receive setState argument as first argument","suites":["useMediatedState"],"updatePoint":{"line":46,"column":65},"line":46,"code":"  it('mediator should receive setState argument as first argument', () => {\n    let val;\n    const spy = jest.fn((newState) => {\n      val = newState;\n      return newState * 2;\n    });\n    const [, hook] = getHook(1, spy);\n\n    act(() => hook.result.current[1](3));\n    expect(val).toBe(3);\n    expect(hook.result.current[0]).toBe(6);\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"if mediator expects 2 args, second should be a function setting the state","suites":["useMediatedState"],"updatePoint":{"line":59,"column":79},"line":59,"code":"  it('if mediator expects 2 args, second should be a function setting the state', () => {\n    const spy = jest.fn((newState: number, setState: Dispatch<SetStateAction<number>>): void => {\n      setState(newState * 2);\n    }) as unknown as StateMediator<number>;\n    const [, hook] = getHook(1, spy);\n\n    act(() => hook.result.current[1](3));\n    expect(hook.result.current[0]).toBe(6);\n  });","file":"useMediatedState.test.ts","skipped":false,"dir":"tests"},{"name":"should have initialState value as the returned state value","suites":[],"updatePoint":{"line":4,"column":62},"line":4,"code":"it('should have initialState value as the returned state value', () => {\n  const initialState = {\n    count: 10,\n  };\n\n  const createMethods = (state) => ({\n    doStuff: () => state,\n  });\n\n  const { result } = renderHook(() => useMethods(createMethods, initialState));\n\n  expect(result.current[0]).toEqual(initialState);\n});","file":"useMethods.test.ts","skipped":false,"dir":"tests"},{"name":"should return wrappedMethods object containing all the methods defined in createMethods","suites":[],"updatePoint":{"line":18,"column":91},"line":18,"code":"it('should return wrappedMethods object containing all the methods defined in createMethods', () => {\n  const initialState = {\n    count: 10,\n  };\n\n  const createMethods = (state) => ({\n    reset() {\n      return initialState;\n    },\n    increment() {\n      return { ...state, count: state.count + 1 };\n    },\n    decrement() {\n      return { ...state, count: state.count - 1 };\n    },\n  });\n\n  const { result } = renderHook(() => useMethods(createMethods, initialState));\n\n  for (const key of Object.keys(createMethods(initialState))) {\n    expect(result.current[1][key]).toBeDefined();\n  }\n});","file":"useMethods.test.ts","skipped":false,"dir":"tests"},{"name":"should properly update the state based on the createMethods","suites":[],"updatePoint":{"line":42,"column":63},"line":42,"code":"it('should properly update the state based on the createMethods', () => {\n  const count = 10;\n  const initialState = {\n    count,\n  };\n\n  const createMethods = (state) => ({\n    reset() {\n      return initialState;\n    },\n    increment() {\n      return { ...state, count: state.count + 1 };\n    },\n    decrement() {\n      return { ...state, count: state.count - 1 };\n    },\n  });\n\n  const { result } = renderHook(() => useMethods(createMethods, initialState));\n\n  act(() => {\n    result.current[1].increment();\n  });\n  expect(result.current[0].count).toBe(count + 1);\n\n  act(() => {\n    result.current[1].decrement();\n  });\n  expect(result.current[0].count).toBe(count);\n\n  act(() => {\n    result.current[1].decrement();\n  });\n  expect(result.current[0].count).toBe(count - 1);\n\n  act(() => {\n    result.current[1].reset();\n  });\n  expect(result.current[0].count).toBe(count);\n});","file":"useMethods.test.ts","skipped":false,"dir":"tests"},{"name":"should call provided callback on mount","suites":[],"updatePoint":{"line":10,"column":42},"line":10,"code":"it('should call provided callback on mount', () => {\n  renderHook(() => useMount(mockCallback));\n\n  expect(mockCallback).toHaveBeenCalledTimes(1);\n});","file":"useMount.test.ts","skipped":false,"dir":"tests"},{"name":"should not call provided callback on unmount","suites":[],"updatePoint":{"line":16,"column":48},"line":16,"code":"it('should not call provided callback on unmount', () => {\n  const { unmount } = renderHook(() => useMount(mockCallback));\n  expect(mockCallback).toHaveBeenCalledTimes(1);\n\n  unmount();\n\n  expect(mockCallback).toHaveBeenCalledTimes(1);\n});","file":"useMount.test.ts","skipped":false,"dir":"tests"},{"name":"should not call provided callback on rerender","suites":[],"updatePoint":{"line":25,"column":49},"line":25,"code":"it('should not call provided callback on rerender', () => {\n  const { rerender } = renderHook(() => useMount(mockCallback));\n  expect(mockCallback).toHaveBeenCalledTimes(1);\n\n  rerender();\n\n  expect(mockCallback).toHaveBeenCalledTimes(1);\n});","file":"useMount.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useMultiStateValidator"],"updatePoint":{"line":9,"column":23},"line":9,"code":"  it('should be defined', () => {\n    expect(useMultiStateValidator).toBeDefined();\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should return an array of two elements","suites":["useMultiStateValidator"],"updatePoint":{"line":42,"column":44},"line":42,"code":"  it('should return an array of two elements', () => {\n    const [, hook] = getHook();\n    const res = hook.result.current[1];\n\n    expect(Array.isArray(res)).toBe(true);\n    expect(res.length).toBe(2);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should call validator on init","suites":["useMultiStateValidator"],"updatePoint":{"line":50,"column":35},"line":50,"code":"  it('should call validator on init', () => {\n    const [spy] = getHook();\n\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should call validator on any of states changed","suites":["useMultiStateValidator"],"updatePoint":{"line":56,"column":52},"line":56,"code":"  it('should call validator on any of states changed', () => {\n    const [spy, hook] = getHook();\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    act(() => hook.result.current[0]([4, 2]));\n    expect(spy).toHaveBeenCalledTimes(2);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should NOT call validator on it's change","suites":["useMultiStateValidator"],"updatePoint":{"line":64,"column":46},"line":64,"code":"  it(\"should NOT call validator on it's change\", () => {\n    const [spy, hook] = getHook();\n    const newValidator: MultiStateValidator<any, number[]> = jest.fn((states) => [\n      states!.every((num) => !!(num % 2)),\n    ]);\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    hook.rerender({ validator: newValidator });\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should throw if states is not an object","suites":["useMultiStateValidator"],"updatePoint":{"line":75,"column":45},"line":75,"code":"  it('should throw if states is not an object', () => {\n    expect(() => {\n      // @ts-ignore\n      const [, hook] = getHook(defaultStatesValidator, 123);\n\n      if (hook.result.error) {\n        throw hook.result.error;\n      }\n    }).toThrowError('states expected to be an object or array, got number');\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"first returned element should represent current validity state","suites":["useMultiStateValidator"],"updatePoint":{"line":86,"column":68},"line":86,"code":"  it('first returned element should represent current validity state', () => {\n    const [, hook] = getHook();\n    let [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([false]);\n\n    act(() => setState([4, 2]));\n    [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([true]);\n\n    act(() => setState([4, 5]));\n    [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([false]);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"second returned element should re-call validation","suites":["useMultiStateValidator"],"updatePoint":{"line":100,"column":55},"line":100,"code":"  it('second returned element should re-call validation', () => {\n    const [spy, hook] = getHook();\n    const [, [, revalidate]] = hook.result.current;\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    act(() => revalidate());\n    expect(spy).toHaveBeenCalledTimes(2);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"validator should receive states as a firs argument","suites":["useMultiStateValidator"],"updatePoint":{"line":109,"column":56},"line":109,"code":"  it('validator should receive states as a firs argument', () => {\n    const [spy, hook] = getHook();\n    const [setState] = hook.result.current;\n\n    expect((spy as Mock).mock.calls[0].length).toBe(1);\n    expect((spy as Mock).mock.calls[0][0]).toEqual([1, 2]);\n    act(() => setState([4, 6]));\n    expect((spy as Mock).mock.calls[1][0]).toEqual([4, 6]);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"if validator expects 2nd parameters it should pass a validity setter there","suites":["useMultiStateValidator"],"updatePoint":{"line":119,"column":80},"line":119,"code":"  it('if validator expects 2nd parameters it should pass a validity setter there', () => {\n    const spy = jest.fn((states: number[], done) => {\n      done([states.every((num) => !!(num % 2))]);\n    }) as unknown as MultiStateValidator<[boolean], number[]>;\n    const [, hook] = getHook(spy, [1, 3]);\n    const [, [validity]] = hook.result.current;\n\n    expect((spy as Mock).mock.calls[0].length).toBe(2);\n    expect((spy as Mock).mock.calls[0][0]).toEqual([1, 3]);\n    expect(validity).toEqual([true]);\n  });","file":"useMultiStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useNetworkState"],"updatePoint":{"line":6,"column":23},"line":6,"code":"  it('should be defined', () => {\n    expect(useNetworkState).toBeDefined();\n  });","file":"useNetworkState.test.ts","skipped":false,"dir":"tests"},{"name":"should return an object of certain structure","suites":["useNetworkState"],"updatePoint":{"line":10,"column":50},"line":10,"code":"  it('should return an object of certain structure', () => {\n    const hook = renderHook(() => useNetworkState(), { initialProps: false });\n\n    expect(typeof hook.result.current).toEqual('object');\n    expect(Object.keys(hook.result.current)).toEqual([\n      'online',\n      'previous',\n      'since',\n      'downlink',\n      'downlinkMax',\n      'effectiveType',\n      'rtt',\n      'saveData',\n      'type',\n    ]);\n  });","file":"useNetworkState.test.ts","skipped":false,"dir":"tests"},{"name":"should be an alias for useCounter","suites":[],"updatePoint":{"line":4,"column":37},"line":4,"code":"it('should be an alias for useCounter', () => {\n  expect(useNumber).toBe(useCounter);\n});","file":"useNumber.test.ts","skipped":false,"dir":"tests"},{"name":"should init to initial value provided","suites":[],"updatePoint":{"line":9,"column":41},"line":9,"code":"it('should init to initial value provided', () => {\n  const subject$ = new Subject();\n  const { result } = setUp(subject$, 123);\n\n  expect(result.current).toBe(123);\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should init to undefined if not initial value provided","suites":[],"updatePoint":{"line":16,"column":58},"line":16,"code":"it('should init to undefined if not initial value provided', () => {\n  const subject$ = new Subject();\n  const { result } = setUp(subject$);\n\n  expect(result.current).toBeUndefined();\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should return latest value of observables","suites":[],"updatePoint":{"line":23,"column":45},"line":23,"code":"it('should return latest value of observables', () => {\n  const subject$ = new Subject();\n  const { result } = setUp(subject$, 123);\n\n  act(() => {\n    subject$.next(125);\n  });\n  expect(result.current).toBe(125);\n\n  act(() => {\n    subject$.next(300);\n    subject$.next(400);\n  });\n  expect(result.current).toBe(400);\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should use layout effect to subscribe synchronously","suites":[],"updatePoint":{"line":39,"column":55},"line":39,"code":"it('should use layout effect to subscribe synchronously', async () => {\n  const subject$ = new Subject();\n  const spy = jest.spyOn(useIsomorphicLayoutEffect, 'default');\n\n  expect(spy).toHaveBeenCalledTimes(0);\n\n  setUp(subject$, 123);\n\n  expect(spy).toHaveBeenCalledTimes(1);\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should subscribe to observable only once","suites":[],"updatePoint":{"line":50,"column":44},"line":50,"code":"it('should subscribe to observable only once', () => {\n  const subject$ = new Subject();\n  const spy = jest.spyOn(subject$, 'subscribe');\n  expect(spy).not.toHaveBeenCalled();\n\n  setUp(subject$, 123);\n\n  expect(spy).toHaveBeenCalledTimes(1);\n\n  act(() => {\n    subject$.next('a');\n  });\n\n  act(() => {\n    subject$.next('b');\n  });\n\n  expect(spy).toHaveBeenCalledTimes(1);\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should return updated value when observable changes","suites":[],"updatePoint":{"line":70,"column":55},"line":70,"code":"it('should return updated value when observable changes', () => {\n  const subject$ = new Subject();\n  const { result } = setUp(subject$);\n  expect(result.current).toBeUndefined();\n\n  act(() => {\n    subject$.next('foo');\n  });\n  expect(result.current).toBe('foo');\n\n  act(() => {\n    subject$.next('bar');\n  });\n  expect(result.current).toBe('bar');\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should unsubscribe from observable","suites":[],"updatePoint":{"line":86,"column":38},"line":86,"code":"it('should unsubscribe from observable', () => {\n  const subject$ = new Subject();\n  const unsubscribeMock = jest.fn();\n  subject$.subscribe = jest.fn().mockReturnValue({\n    unsubscribe: unsubscribeMock,\n  });\n\n  const { unmount } = setUp(subject$);\n  expect(unsubscribeMock).not.toHaveBeenCalled();\n\n  act(() => {\n    subject$.next('foo');\n  });\n  expect(unsubscribeMock).not.toHaveBeenCalled();\n\n  act(() => {\n    subject$.next('bar');\n  });\n  expect(unsubscribeMock).not.toHaveBeenCalled();\n\n  unmount();\n  expect(unsubscribeMock).toHaveBeenCalledTimes(1);\n});","file":"useObservable.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useOrientation"],"updatePoint":{"line":27,"column":23},"line":27,"code":"  it('should be defined', () => {\n    expect(useOrientation).toBeDefined();\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should return current window orientation","suites":["useOrientation"],"updatePoint":{"line":42,"column":46},"line":42,"code":"  it('should return current window orientation', () => {\n    const hook = getHook();\n\n    expect(typeof hook.result.current).toBe('object');\n    expect(typeof hook.result.current.type).toBe('string');\n    expect(typeof hook.result.current.angle).toBe('number');\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should use initial values in case of no parameters","suites":["useOrientation"],"updatePoint":{"line":50,"column":56},"line":50,"code":"  it('should use initial values in case of no parameters', () => {\n    const hook = getHook();\n\n    expect(hook.result.current.type).toBe('landscape-primary');\n    expect(hook.result.current.angle).toBe(0);\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should re-render after orientation change on closest RAF","suites":["useOrientation"],"updatePoint":{"line":57,"column":62},"line":57,"code":"  it('should re-render after orientation change on closest RAF', () => {\n    const hook = getHook();\n\n    act(() => {\n      triggerOrientation('portrait-secondary', 180);\n      requestAnimationFrame.step();\n    });\n\n    expect(hook.result.current.type).toBe('portrait-secondary');\n    expect(hook.result.current.angle).toBe(180);\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should return window.orientation number if window.screen.orientation is missing","suites":["useOrientation"],"updatePoint":{"line":69,"column":85},"line":69,"code":"  it('should return window.orientation number if window.screen.orientation is missing', () => {\n    (window.screen.orientation as unknown) = undefined;\n\n    const hook = getHook();\n\n    expect(hook.result.current.type).toBe('');\n    expect(hook.result.current.angle).toBe(0);\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should return 0 if window.orientation is not a number and if window.screen.orientation is missing","suites":["useOrientation"],"updatePoint":{"line":78,"column":103},"line":78,"code":"  it('should return 0 if window.orientation is not a number and if window.screen.orientation is missing', () => {\n    (window.screen.orientation as unknown) = undefined;\n    (window.orientation as unknown) = null;\n\n    const hook = getHook();\n\n    expect(hook.result.current.type).toBe('');\n    expect(hook.result.current.angle).toBe(0);\n  });","file":"useOrientation.test.ts","skipped":false,"dir":"tests"},{"name":"should return undefined on initial render","suites":[],"updatePoint":{"line":6,"column":45},"line":6,"code":"it('should return undefined on initial render', () => {\n  const { result } = setUp();\n\n  expect(result.current).toBeUndefined();\n});","file":"usePrevious.test.ts","skipped":false,"dir":"tests"},{"name":"should always return previous state after each update","suites":[],"updatePoint":{"line":12,"column":57},"line":12,"code":"it('should always return previous state after each update', () => {\n  const { result, rerender } = setUp();\n\n  rerender({ state: 2 });\n  expect(result.current).toBe(0);\n\n  rerender({ state: 4 });\n  expect(result.current).toBe(2);\n\n  rerender({ state: 6 });\n  expect(result.current).toBe(4);\n});","file":"usePrevious.test.ts","skipped":false,"dir":"tests"},{"name":"takes initial state","suites":[],"updatePoint":{"line":6,"column":23},"line":6,"code":"it('takes initial state', () => {\n  const { result } = setUp([1, 2, 3]);\n  const { first, last, size } = result.current;\n  expect(first).toEqual(1);\n  expect(last).toEqual(3);\n  expect(size).toEqual(3);\n});","file":"useQueue.test.ts","skipped":false,"dir":"tests"},{"name":"appends new member","suites":[],"updatePoint":{"line":14,"column":22},"line":14,"code":"it('appends new member', () => {\n  const { result } = setUp([1, 2]);\n  act(() => {\n    result.current.add(3);\n  });\n  const { first, last, size } = result.current;\n  expect(first).toEqual(1);\n  expect(last).toEqual(3);\n  expect(size).toEqual(3);\n});","file":"useQueue.test.ts","skipped":false,"dir":"tests"},{"name":"pops oldest member","suites":[],"updatePoint":{"line":25,"column":22},"line":25,"code":"it('pops oldest member', () => {\n  const { result } = setUp([1, 2]);\n  act(() => {\n    result.current.remove();\n  });\n  const { first, size } = result.current;\n  expect(first).toEqual(2);\n  expect(size).toEqual(1);\n});","file":"useQueue.test.ts","skipped":false,"dir":"tests"},{"name":"should init percentage of time elapsed","suites":[],"updatePoint":{"line":30,"column":42},"line":30,"code":"it('should init percentage of time elapsed', () => {\n  const { result } = renderHook(() => useRaf());\n  const timeElapsed = result.current;\n\n  expect(timeElapsed).toBe(0);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should return corresponding percentage of time elapsed for default ms","suites":[],"updatePoint":{"line":37,"column":73},"line":37,"code":"it('should return corresponding percentage of time elapsed for default ms', () => {\n  const { result } = renderHook(() => useRaf());\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.runOnlyPendingTimers(); // start after delay\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12 * 0.25); // 25%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.25);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12 * 0.5); // 50%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.5);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12 * 0.75); // 75%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.75);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12); // 100%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(1);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should return corresponding percentage of time elapsed for custom ms","suites":[],"updatePoint":{"line":67,"column":72},"line":67,"code":"it('should return corresponding percentage of time elapsed for custom ms', () => {\n  const customMs = 2000;\n\n  const { result } = renderHook(() => useRaf(customMs));\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.runOnlyPendingTimers(); // start after delay\n    spyDateNow.mockImplementationOnce(() => fixedStart + customMs * 0.25); // 25%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.25);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + customMs * 0.5); // 50%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.5);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + customMs * 0.75); // 75%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(0.75);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + customMs); // 100%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(1);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should return always 1 after corresponding ms reached","suites":[],"updatePoint":{"line":99,"column":57},"line":99,"code":"it('should return always 1 after corresponding ms reached', () => {\n  const { result } = renderHook(() => useRaf());\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.runOnlyPendingTimers(); // start after delay\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12); // 100%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(1);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12 * 1.1); // 110%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(1);\n\n  act(() => {\n    spyDateNow.mockImplementationOnce(() => fixedStart + 1e12 * 3); // 300%\n    requestAnimationFrame.step();\n  });\n  expect(result.current).toBe(1);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should wait until delay reached to start calculating elapsed percentage","suites":[],"updatePoint":{"line":123,"column":75},"line":123,"code":"it('should wait until delay reached to start calculating elapsed percentage', () => {\n  const { result } = renderHook(() => useRaf(undefined, 500));\n\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.advanceTimersByTime(250); // fast-forward only half of custom delay\n  });\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.advanceTimersByTime(249); // fast-forward 1ms less than custom delay\n  });\n  expect(result.current).toBe(0);\n\n  act(() => {\n    jest.advanceTimersByTime(1); // fast-forward exactly to custom delay\n  });\n  expect(result.current).not.toBe(0);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should clear pending timers on unmount","suites":[],"updatePoint":{"line":144,"column":42},"line":144,"code":"it('should clear pending timers on unmount', () => {\n  const spyRafStop = jest.spyOn(global, 'cancelAnimationFrame' as any);\n  const { unmount } = renderHook(() => useRaf());\n\n  expect(clearTimeout).not.toHaveBeenCalled();\n  expect(spyRafStop).not.toHaveBeenCalled();\n\n  unmount();\n\n  expect(clearTimeout).toHaveBeenCalledTimes(2);\n  expect(spyRafStop).toHaveBeenCalledTimes(1);\n});","file":"useRaf.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useRafState"],"updatePoint":{"line":23,"column":23},"line":23,"code":"  it('should be defined', () => {\n    expect(useRafState).toBeDefined();\n  });","file":"useRafState.test.ts","skipped":false,"dir":"tests"},{"name":"should only update state after requestAnimationFrame when providing an object","suites":["useRafState"],"updatePoint":{"line":27,"column":83},"line":27,"code":"  it('should only update state after requestAnimationFrame when providing an object', () => {\n    const { result } = renderHook(() => useRafState(0));\n\n    act(() => {\n      result.current[1](1);\n    });\n    expect(result.current[0]).toBe(0);\n\n    act(() => {\n      requestAnimationFrame.step();\n    });\n    expect(result.current[0]).toBe(1);\n\n    act(() => {\n      result.current[1](2);\n      requestAnimationFrame.step();\n    });\n    expect(result.current[0]).toBe(2);\n\n    act(() => {\n      result.current[1]((prevState) => prevState * 2);\n      requestAnimationFrame.step();\n    });\n    expect(result.current[0]).toBe(4);\n  });","file":"useRafState.test.ts","skipped":false,"dir":"tests"},{"name":"should only update state after requestAnimationFrame when providing a function","suites":["useRafState"],"updatePoint":{"line":53,"column":84},"line":53,"code":"  it('should only update state after requestAnimationFrame when providing a function', () => {\n    const { result } = renderHook(() => useRafState(0));\n\n    act(() => {\n      result.current[1]((prevState) => prevState + 1);\n    });\n    expect(result.current[0]).toBe(0);\n\n    act(() => {\n      requestAnimationFrame.step();\n    });\n    expect(result.current[0]).toBe(1);\n\n    act(() => {\n      result.current[1]((prevState) => prevState * 3);\n      requestAnimationFrame.step();\n    });\n    expect(result.current[0]).toBe(3);\n  });","file":"useRafState.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel update state on unmount","suites":["useRafState"],"updatePoint":{"line":73,"column":43},"line":73,"code":"  it('should cancel update state on unmount', () => {\n    const { unmount } = renderHook(() => useRafState(0));\n    const spyRafCancel = jest.spyOn(global, 'cancelAnimationFrame' as any);\n\n    expect(spyRafCancel).not.toHaveBeenCalled();\n\n    unmount();\n\n    expect(spyRafCancel).toHaveBeenCalledTimes(1);\n  });","file":"useRafState.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useRendersCount"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useRendersCount).toBeDefined();\n  });","file":"useRendersCount.test.ts","skipped":false,"dir":"tests"},{"name":"should return number","suites":["useRendersCount"],"updatePoint":{"line":9,"column":26},"line":9,"code":"  it('should return number', () => {\n    expect(renderHook(() => useRendersCount()).result.current).toEqual(expect.any(Number));\n  });","file":"useRendersCount.test.ts","skipped":false,"dir":"tests"},{"name":"should return actual number of renders","suites":["useRendersCount"],"updatePoint":{"line":13,"column":44},"line":13,"code":"  it('should return actual number of renders', () => {\n    const hook = renderHook(() => useRendersCount());\n\n    expect(hook.result.current).toBe(1);\n    hook.rerender();\n    expect(hook.result.current).toBe(2);\n    hook.rerender();\n    expect(hook.result.current).toBe(3);\n  });","file":"useRendersCount.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useScrollbarWidth"],"updatePoint":{"line":23,"column":23},"line":23,"code":"  it('should be defined', () => {\n    expect(useScrollbarWidth).toBeDefined();\n  });","file":"useScrollbarWidth.test.ts","skipped":false,"dir":"tests"},{"name":"should return value of scrollbarWidth result","suites":["useScrollbarWidth"],"updatePoint":{"line":27,"column":50},"line":27,"code":"  it('should return value of scrollbarWidth result', () => {\n    scrollbarWidth.__cache = 21;\n    const { result } = renderHook(() => useScrollbarWidth());\n\n    expect(result.current).toBe(21);\n  });","file":"useScrollbarWidth.test.ts","skipped":false,"dir":"tests"},{"name":"should re-call scrollbar width in RAF in case `scrollbarWidth()` returned undefined","suites":["useScrollbarWidth"],"updatePoint":{"line":34,"column":89},"line":34,"code":"  it('should re-call scrollbar width in RAF in case `scrollbarWidth()` returned undefined', () => {\n    scrollbarWidth.__cache = undefined;\n    const { result } = renderHook(() => useScrollbarWidth());\n    expect(result.current).toBe(undefined);\n    scrollbarWidth.__cache = 34;\n    act(() => {\n      requestAnimationFrame.step();\n    });\n\n    expect(result.current).toBe(34);\n  });","file":"useScrollbarWidth.test.ts","skipped":false,"dir":"tests"},{"name":"returns current location.search value","suites":[],"updatePoint":{"line":22,"column":41},"line":22,"code":"it('returns current location.search value', () => {\n  mockSearch = 'foo=bar&baz=quux';\n\n  const { result } = renderHook(() => useSearchParam('foo'));\n\n  expect(result.current).toBe('bar');\n});","file":"useSearchParam.test.ts","skipped":false,"dir":"tests"},{"name":"returns null if search param not found","suites":[],"updatePoint":{"line":30,"column":42},"line":30,"code":"it('returns null if search param not found', () => {\n  mockSearch = 'foo=bar&baz=quux';\n\n  const { result } = renderHook(() => useSearchParam('foo2'));\n\n  expect(result.current).toBe(null);\n});","file":"useSearchParam.test.ts","skipped":false,"dir":"tests"},{"name":"tracks the latest search param value","suites":[],"updatePoint":{"line":38,"column":40},"line":38,"code":"it('tracks the latest search param value', () => {\n  mockSearch = 'foo=bar&baz=quux';\n\n  let callback;\n  const window$addEventListener = window.addEventListener;\n  window.addEventListener = (event, cb) => {\n    if (event === 'pushstate') {\n      callback = cb;\n    }\n  };\n\n  const { result } = renderHook(() => useSearchParam('baz'));\n\n  expect(result.current).toBe('quux');\n\n  act(() => {\n    mockSearch = 'foo=1&baz=2';\n    callback();\n  });\n\n  expect(result.current).toBe('2');\n\n  window.addEventListener = window$addEventListener;\n});","file":"useSearchParam.test.ts","skipped":false,"dir":"tests"},{"name":"should init set and utils","suites":[],"updatePoint":{"line":6,"column":29},"line":6,"code":"it('should init set and utils', () => {\n  const { result } = setUp(new Set([1, 2]));\n  const [set, utils] = result.current;\n\n  expect(set).toEqual(new Set([1, 2]));\n  expect(utils).toStrictEqual({\n    has: expect.any(Function),\n    add: expect.any(Function),\n    remove: expect.any(Function),\n    toggle: expect.any(Function),\n    reset: expect.any(Function),\n  });\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should init empty set if no initial set provided","suites":[],"updatePoint":{"line":20,"column":52},"line":20,"code":"it('should init empty set if no initial set provided', () => {\n  const { result } = setUp();\n\n  expect(result.current[0]).toEqual(new Set());\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should have an initially provided key","suites":[],"updatePoint":{"line":26,"column":41},"line":26,"code":"it('should have an initially provided key', () => {\n  const { result } = setUp(new Set(['a']));\n  const [, utils] = result.current;\n\n  let value;\n  act(() => {\n    value = utils.has('a');\n  });\n\n  expect(value).toBe(true);\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should have an added key","suites":[],"updatePoint":{"line":38,"column":28},"line":38,"code":"it('should have an added key', () => {\n  const { result } = setUp(new Set());\n\n  act(() => {\n    result.current[1].add('newKey');\n  });\n\n  let value;\n  act(() => {\n    value = result.current[1].has('newKey');\n  });\n\n  expect(value).toBe(true);\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should get false for non-existing key","suites":[],"updatePoint":{"line":53,"column":41},"line":53,"code":"it('should get false for non-existing key', () => {\n  const { result } = setUp(new Set(['a']));\n  const [, utils] = result.current;\n\n  let value;\n  act(() => {\n    value = utils.has('nonExisting');\n  });\n\n  expect(value).toBe(false);\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should add a new key","suites":[],"updatePoint":{"line":65,"column":24},"line":65,"code":"it('should add a new key', () => {\n  const { result } = setUp(new Set(['oldKey']));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.add('newKey');\n  });\n\n  expect(result.current[0]).toEqual(new Set(['oldKey', 'newKey']));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should work if setting existing key","suites":[],"updatePoint":{"line":76,"column":39},"line":76,"code":"it('should work if setting existing key', () => {\n  const { result } = setUp(new Set(['oldKey']));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.add('oldKey');\n  });\n\n  expect(result.current[0]).toEqual(new Set(['oldKey']));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should remove existing key","suites":[],"updatePoint":{"line":87,"column":30},"line":87,"code":"it('should remove existing key', () => {\n  const { result } = setUp(new Set([1, 2]));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.remove(2);\n  });\n\n  expect(result.current[0]).toEqual(new Set([1]));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should remove an existing key on toggle","suites":[],"updatePoint":{"line":98,"column":43},"line":98,"code":"it('should remove an existing key on toggle', () => {\n  const { result } = setUp(new Set([1, 2]));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.toggle(2);\n  });\n\n  expect(result.current[0]).toEqual(new Set([1]));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should add a new key on toggle","suites":[],"updatePoint":{"line":109,"column":34},"line":109,"code":"it('should add a new key on toggle', () => {\n  const { result } = setUp(new Set([1]));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.toggle(2);\n  });\n\n  expect(result.current[0]).toEqual(new Set([1, 2]));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing if removing non-existing key","suites":[],"updatePoint":{"line":120,"column":50},"line":120,"code":"it('should do nothing if removing non-existing key', () => {\n  const { result } = setUp(new Set(['a', 'b']));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.remove('nonExisting');\n  });\n\n  expect(result.current[0]).toEqual(new Set(['a', 'b']));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should reset to initial set provided","suites":[],"updatePoint":{"line":131,"column":40},"line":131,"code":"it('should reset to initial set provided', () => {\n  const { result } = setUp(new Set([1]));\n  const [, utils] = result.current;\n\n  act(() => {\n    utils.add(2);\n  });\n\n  expect(result.current[0]).toEqual(new Set([1, 2]));\n\n  act(() => {\n    utils.reset();\n  });\n\n  expect(result.current[0]).toEqual(new Set([1]));\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should memoized its utils methods","suites":[],"updatePoint":{"line":148,"column":37},"line":148,"code":"it('should memoized its utils methods', () => {\n  const { result } = setUp(new Set(['a', 'b']));\n  const [, utils] = result.current;\n  const { add, remove, reset, toggle } = utils;\n\n  act(() => {\n    add('foo');\n  });\n\n  expect(result.current[1].add).toBe(add);\n  expect(result.current[1].remove).toBe(remove);\n  expect(result.current[1].toggle).toBe(toggle);\n  expect(result.current[1].reset).toBe(reset);\n});","file":"useSet.test.ts","skipped":false,"dir":"tests"},{"name":"should init state and setter","suites":[],"updatePoint":{"line":6,"column":32},"line":6,"code":"it('should init state and setter', () => {\n  const { result } = setUp({ foo: 'bar' });\n  const [state, setState] = result.current;\n\n  expect(state).toEqual({ foo: 'bar' });\n  expect(setState).toBeInstanceOf(Function);\n});","file":"useSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should init empty state if not initial state provided","suites":[],"updatePoint":{"line":14,"column":57},"line":14,"code":"it('should init empty state if not initial state provided', () => {\n  const { result } = setUp();\n\n  expect(result.current[0]).toEqual({});\n});","file":"useSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should merge changes into current state when providing object","suites":[],"updatePoint":{"line":20,"column":65},"line":20,"code":"it('should merge changes into current state when providing object', () => {\n  const { result } = setUp({ foo: 'bar', count: 1 });\n  const [state, setState] = result.current;\n\n  act(() => {\n    // @ts-ignore\n    setState({ count: state.count + 1, someBool: true });\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', count: 2, someBool: true });\n});","file":"useSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should merge changes into current state when providing function","suites":[],"updatePoint":{"line":32,"column":67},"line":32,"code":"it('should merge changes into current state when providing function', () => {\n  const { result } = setUp({ foo: 'bar', count: 1 });\n  const [, setState] = result.current;\n\n  act(() => {\n    // @ts-ignore\n    setState((prevState) => ({ count: prevState.count + 1, someBool: true }));\n  });\n\n  expect(result.current[0]).toEqual({ foo: 'bar', count: 2, someBool: true });\n});","file":"useSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should return a memoized setState callback","suites":[],"updatePoint":{"line":48,"column":46},"line":48,"code":"it('should return a memoized setState callback', () => {\n  const { result, rerender } = setUp({ ok: false });\n  const [, setState1] = result.current;\n\n  act(() => {\n    setState1({ ok: true });\n  });\n  rerender();\n\n  const [, setState2] = result.current;\n\n  expect(setState1).toBe(setState2);\n});","file":"useSetState.test.ts","skipped":false,"dir":"tests"},{"name":"should shallow compare dependencies","suites":[],"updatePoint":{"line":12,"column":39},"line":12,"code":"it('should shallow compare dependencies', () => {\n  const { rerender: rerenderNormal } = renderHook(() =>\n    useEffect(mockEffectNormal, [options1, options2])\n  );\n  const { rerender: rerenderShallow } = renderHook(() =>\n    useShallowCompareEffect(mockEffectShallow, [options1, options2])\n  );\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(1);\n  expect(mockEffectShallow).toHaveBeenCalledTimes(1);\n\n  options1 = { max: 10, range: options1.range };\n  rerenderShallow();\n  rerenderNormal();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(2);\n  expect(mockEffectShallow).toHaveBeenCalledTimes(1);\n\n  options1 = { max: 10, range: { from: 0, to: 10 } };\n  rerenderNormal();\n  rerenderShallow();\n\n  expect(mockEffectNormal).toHaveBeenCalledTimes(3);\n  expect(mockEffectShallow).toHaveBeenCalledTimes(2);\n});","file":"useShallowCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should run clean-up provided on unmount","suites":[],"updatePoint":{"line":38,"column":43},"line":38,"code":"it('should run clean-up provided on unmount', () => {\n  const { unmount } = renderHook(() =>\n    useShallowCompareEffect(mockEffectCallback, [options1, options2])\n  );\n  expect(mockEffectCleanup).not.toHaveBeenCalled();\n\n  unmount();\n  expect(mockEffectCleanup).toHaveBeenCalledTimes(1);\n});","file":"useShallowCompareEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should init value to provided target","suites":[],"updatePoint":{"line":60,"column":40},"line":60,"code":"it('should init value to provided target', () => {\n  const { result } = renderHook(() => useSpring(70));\n\n  expect(result.current).toBe(70);\n  expect(mockSetCurrentValue).toHaveBeenCalledTimes(1);\n  expect(mockSetCurrentValue).toHaveBeenCalledWith(70);\n  expect(mockCreateSpring).toHaveBeenCalledTimes(1);\n  expect(mockCreateSpring).toHaveBeenCalledWith(50, 3);\n});","file":"useSpring.test.ts","skipped":false,"dir":"tests"},{"name":"should create spring with custom tension and friction args provided","suites":[],"updatePoint":{"line":70,"column":71},"line":70,"code":"it('should create spring with custom tension and friction args provided', () => {\n  renderHook(() => useSpring(500, 20, 7));\n\n  expect(mockCreateSpring).toHaveBeenCalledTimes(1);\n  expect(mockCreateSpring).toHaveBeenCalledWith(20, 7);\n});","file":"useSpring.test.ts","skipped":false,"dir":"tests"},{"name":"should subscribe only once","suites":[],"updatePoint":{"line":77,"column":30},"line":77,"code":"it('should subscribe only once', () => {\n  const { rerender } = renderHook(() => useSpring());\n\n  expect(mockAddListener).toHaveBeenCalledTimes(1);\n  expect(mockAddListener).toHaveBeenCalledWith(springListener);\n\n  rerender();\n\n  expect(mockAddListener).toHaveBeenCalledTimes(1);\n});","file":"useSpring.test.ts","skipped":false,"dir":"tests"},{"name":"should handle spring update","suites":[],"updatePoint":{"line":88,"column":31},"line":88,"code":"it('should handle spring update', () => {\n  let targetValue = 70;\n  let lastSpringValue = targetValue;\n  const { result, rerender } = renderHook(() => useSpring(targetValue));\n\n  targetValue = 100;\n  rerender();\n  expect(result.current).toBe(lastSpringValue);\n\n  act(() => {\n    triggerSpringUpdate(); // simulate new spring value\n  });\n  expect(result.current).toBeGreaterThan(lastSpringValue);\n  expect(result.current).toBeLessThanOrEqual(targetValue);\n\n  lastSpringValue = result.current;\n  act(() => {\n    triggerSpringUpdate(); // simulate another new spring value\n  });\n  expect(result.current).toBeGreaterThan(lastSpringValue);\n  expect(result.current).toBeLessThanOrEqual(targetValue);\n});","file":"useSpring.test.ts","skipped":false,"dir":"tests"},{"name":"should remove listener on unmount","suites":[],"updatePoint":{"line":111,"column":37},"line":111,"code":"it('should remove listener on unmount', () => {\n  const { unmount } = renderHook(() => useSpring());\n  expect(mockRemoveListener).not.toHaveBeenCalled();\n\n  unmount();\n\n  expect(mockRemoveListener).toHaveBeenCalledTimes(1);\n  expect(mockRemoveListener).toHaveBeenCalledWith(springListener);\n});","file":"useSpring.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useStateList"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useStateList).toBeDefined();\n  });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should return an object containing `state`, `next` and `prev`","suites":["useStateList"],"updatePoint":{"line":13,"column":67},"line":13,"code":"  it('should return an object containing `state`, `next` and `prev`', () => {\n    const res = getHook().result.current;\n\n    expect(res).toStrictEqual({\n      state: expect.any(String),\n      currentIndex: expect.any(Number),\n      prev: expect.any(Function),\n      next: expect.any(Function),\n      setStateAt: expect.any(Function),\n      setState: expect.any(Function),\n    });\n  });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should return the first state on init","suites":["useStateList"],"updatePoint":{"line":26,"column":43},"line":26,"code":"  it('should return the first state on init', () => {\n    expect(getHook().result.current.state).toBe('a');\n  });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should set state value if it exists in states list","suites":["useStateList","setState()"],"updatePoint":{"line":31,"column":58},"line":31,"code":"    it('should set state value if it exists in states list', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => hook.result.current.setState('c'));\n\n      expect(hook.result.current.state).toBe('c');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should throw if required state not exists","suites":["useStateList","setState()"],"updatePoint":{"line":41,"column":49},"line":41,"code":"    it('should throw if required state not exists', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      expect(() => hook.result.current.setState('d')).toThrow(\n        `State 'd' is not a valid state (does not exist in state list)`\n      );\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing on unmounted component","suites":["useStateList","setState()"],"updatePoint":{"line":51,"column":48},"line":51,"code":"    it('should do nothing on unmounted component', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n      hook.unmount();\n\n      expect(() => hook.result.current.setState('c')).not.toThrow(Error);\n      expect(hook.result.current.state).toBe('a');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should set state by it`s index in states list","suites":["useStateList","setStateAt()"],"updatePoint":{"line":63,"column":53},"line":63,"code":"    it('should set state by it`s index in states list', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => hook.result.current.setStateAt(2));\n      expect(hook.result.current.state).toBe('c');\n      act(() => hook.result.current.setStateAt(1));\n      expect(hook.result.current.state).toBe('b');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should cyclically travel through the right border","suites":["useStateList","setStateAt()"],"updatePoint":{"line":74,"column":57},"line":74,"code":"    it('should cyclically travel through the right border', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => hook.result.current.setStateAt(5));\n      expect(hook.result.current.state).toBe('c');\n      act(() => hook.result.current.setStateAt(9));\n      expect(hook.result.current.state).toBe('a');\n      act(() => hook.result.current.setStateAt(10));\n      expect(hook.result.current.state).toBe('b');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should cyclically travel through the left border","suites":["useStateList","setStateAt()"],"updatePoint":{"line":87,"column":56},"line":87,"code":"    it('should cyclically travel through the left border', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => hook.result.current.setStateAt(-1));\n      expect(hook.result.current.state).toBe('c');\n      act(() => hook.result.current.setStateAt(-2));\n      expect(hook.result.current.state).toBe('b');\n      act(() => hook.result.current.setStateAt(-17));\n      expect(hook.result.current.state).toBe('b');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should switch states forward and cause re-render","suites":["useStateList","next()"],"updatePoint":{"line":102,"column":56},"line":102,"code":"    it('should switch states forward and cause re-render', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => {\n        hook.result.current.next();\n      });\n      expect(hook.result.current.state).toBe('b');\n\n      act(() => {\n        hook.result.current.next();\n      });\n      expect(hook.result.current.state).toBe('c');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"on overflow should switch to first element (should be cycled)","suites":["useStateList","next()"],"updatePoint":{"line":118,"column":69},"line":118,"code":"    it('on overflow should switch to first element (should be cycled)', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => {\n        hook.result.current.next();\n        hook.result.current.next();\n        hook.result.current.next();\n      });\n      expect(hook.result.current.state).toBe('a');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"on overflow should switch to last element (should be cycled)","suites":["useStateList","prev()"],"updatePoint":{"line":133,"column":68},"line":133,"code":"    it('on overflow should switch to last element (should be cycled)', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('c');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should switch states backward and cause re-render","suites":["useStateList","prev()"],"updatePoint":{"line":144,"column":57},"line":144,"code":"    it('should switch states backward and cause re-render', () => {\n      const hook = getHook();\n\n      expect(hook.result.current.state).toBe('a');\n\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('c');\n\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('b');\n\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('a');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should have `undefined` state","suites":["useStateList","with empty states list"],"updatePoint":{"line":167,"column":37},"line":167,"code":"    it('should have `undefined` state', () => {\n      expect(getHook([]).result.current.state).toBe(undefined);\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing on next() call","suites":["useStateList","with empty states list"],"updatePoint":{"line":171,"column":40},"line":171,"code":"    it('should do nothing on next() call', () => {\n      const hook = getHook([]);\n      act(() => {\n        hook.result.current.next();\n      });\n\n      expect(hook.result.current.state).toBe(undefined);\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing on prev() call","suites":["useStateList","with empty states list"],"updatePoint":{"line":180,"column":40},"line":180,"code":"    it('should do nothing on prev() call', () => {\n      const hook = getHook([]);\n      act(() => {\n        hook.result.current.prev();\n      });\n\n      expect(hook.result.current.state).toBe(undefined);\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should set last element as state if index was beyond new last element","suites":["useStateList","on state list shrink"],"updatePoint":{"line":191,"column":77},"line":191,"code":"    it('should set last element as state if index was beyond new last element', () => {\n      const hook = getHook();\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('c');\n\n      hook.rerender({ states: ['a', 'b'] });\n\n      expect(hook.result.current.state).toBe('b');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should so nothing if current index within new range","suites":["useStateList","on state list shrink"],"updatePoint":{"line":203,"column":59},"line":203,"code":"    it('should so nothing if current index within new range', () => {\n      const hook = getHook();\n      act(() => {\n        hook.result.current.prev();\n      });\n      expect(hook.result.current.state).toBe('c');\n\n      hook.rerender({ states: ['a', 'b', 'c', 'd'] });\n\n      expect(hook.result.current.state).toBe('c');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"next() should not do anything","suites":["useStateList","ou unmounted component"],"updatePoint":{"line":217,"column":37},"line":217,"code":"    it('next() should not do anything', () => {\n      const hook = getHook();\n      const { next } = hook.result.current;\n\n      hook.unmount();\n      act(() => next());\n\n      expect(hook.result.current.state).toBe('a');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"prev() should not do anything","suites":["useStateList","ou unmounted component"],"updatePoint":{"line":227,"column":37},"line":227,"code":"    it('prev() should not do anything', () => {\n      const hook = getHook();\n      const { prev } = hook.result.current;\n\n      hook.unmount();\n      act(() => prev());\n\n      expect(hook.result.current.state).toBe('a');\n    });","file":"useStateList.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useStateValidator"],"updatePoint":{"line":11,"column":23},"line":11,"code":"  it('should be defined', () => {\n    expect(useStateValidator).toBeDefined();\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should return an array of two elements","suites":["useStateValidator"],"updatePoint":{"line":28,"column":44},"line":28,"code":"  it('should return an array of two elements', () => {\n    const [, hook] = getHook();\n    const res = hook.result.current[1];\n\n    expect(Array.isArray(res)).toBe(true);\n    expect(res[0]).toEqual([true]);\n    expect(typeof res[1]).toBe('function');\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"first element should represent current validity state","suites":["useStateValidator"],"updatePoint":{"line":37,"column":59},"line":37,"code":"  it('first element should represent current validity state', () => {\n    const [, hook] = getHook();\n    let [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([true]);\n\n    act(() => setState(3));\n    [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([true]);\n\n    act(() => setState(4));\n    [setState, [validity]] = hook.result.current;\n    expect(validity).toEqual([false]);\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"second element should re-call validation","suites":["useStateValidator"],"updatePoint":{"line":51,"column":46},"line":51,"code":"  it('second element should re-call validation', () => {\n    const [spy, hook] = getHook();\n    const [, [, revalidate]] = hook.result.current;\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    act(() => revalidate());\n    expect(spy).toHaveBeenCalledTimes(2);\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"validator have to be called on init plus on each state update","suites":["useStateValidator"],"updatePoint":{"line":60,"column":67},"line":60,"code":"  it('validator have to be called on init plus on each state update', () => {\n    const [spy, hook] = getHook(jest.fn());\n    const [setState] = hook.result.current;\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    act(() => setState(4));\n    expect(spy).toHaveBeenCalledTimes(2);\n    act(() => setState((prevState) => prevState + 1));\n    expect(spy).toHaveBeenCalledTimes(3);\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should pass to validator one parameter - current state","suites":["useStateValidator"],"updatePoint":{"line":71,"column":60},"line":71,"code":"  it('should pass to validator one parameter - current state', () => {\n    const [spy, hook] = getHook(jest.fn());\n    const [setState] = hook.result.current;\n\n    act(() => setState(4));\n    act(() => setState(5));\n    expect((spy as Mock).mock.calls[0].length).toBe(1);\n    expect((spy as Mock).mock.calls[0].length).toBe(1);\n    expect((spy as Mock).mock.calls[0][0]).toBe(1);\n    expect((spy as Mock).mock.calls[1].length).toBe(1);\n    expect((spy as Mock).mock.calls[1][0]).toBe(4);\n    expect((spy as Mock).mock.calls[2].length).toBe(1);\n    expect((spy as Mock).mock.calls[2][0]).toBe(5);\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"if validator expects 2nd parameter it should pass a validity setter there","suites":["useStateValidator"],"updatePoint":{"line":86,"column":79},"line":86,"code":"  it('if validator expects 2nd parameter it should pass a validity setter there', () => {\n    const [spy, hook] = getHook(\n      jest.fn((state, setValidity): void => {\n        setValidity([state % 2 === 0]);\n      }) as unknown as StateValidator<[boolean], number>\n    );\n    let [setState, [[isValid]]] = hook.result.current;\n\n    expect((spy as Mock).mock.calls[0].length).toBe(2);\n    expect(typeof (spy as Mock).mock.calls[0][1]).toBe('function');\n\n    expect(isValid).toBe(false);\n    act(() => setState((prevState) => prevState + 1));\n\n    [setState, [[isValid]]] = hook.result.current;\n    expect(isValid).toBe(true);\n    act(() => setState(5));\n\n    [setState, [[isValid]]] = hook.result.current;\n    expect(isValid).toBe(false);\n  });","file":"useStateValidator.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useStateWithHistory"],"updatePoint":{"line":7,"column":23},"line":7,"code":"  it('should be defined', () => {\n    expect(useStateWithHistory).toBeDefined();\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should return state, state setter and history structure","suites":["useStateWithHistory"],"updatePoint":{"line":35,"column":61},"line":35,"code":"  it('should return state, state setter and history structure', () => {\n    const res = getHook(0).result.current[0];\n\n    expect(res).toStrictEqual([expect.any(Number), expect.any(Function), expect.any(Object)]);\n    expect(res[2]).toStrictEqual({\n      history: expect.any(Array),\n      position: expect.any(Number),\n      capacity: expect.any(Number),\n      back: expect.any(Function),\n      forward: expect.any(Function),\n      go: expect.any(Function),\n    });\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should act like regular setState","suites":["useStateWithHistory"],"updatePoint":{"line":49,"column":38},"line":49,"code":"  it('should act like regular setState', () => {\n    const hook = getHook(() => 1);\n\n    expect(hook.result.current[0][0]).toBe(1);\n    act(() => {\n      hook.result.current[0][1](321);\n    });\n    expect(hook.result.current[0][0]).toBe(321);\n    act(() => {\n      hook.result.current[0][1]((current) => (current ?? 0) + 111);\n    });\n    expect(hook.result.current[0][0]).toBe(432);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should receive initial history","suites":["useStateWithHistory"],"updatePoint":{"line":63,"column":36},"line":63,"code":"  it('should receive initial history', () => {\n    const hook = getHook(3, undefined, [1, 2, 3]);\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3]);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should push initial state to initial history if last element not equals it","suites":["useStateWithHistory"],"updatePoint":{"line":68,"column":80},"line":68,"code":"  it('should push initial state to initial history if last element not equals it', () => {\n    const hook = getHook(1, undefined, [1, 2, 3]);\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3, 1]);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should crop initial history in case it exceeds capacity","suites":["useStateWithHistory"],"updatePoint":{"line":73,"column":61},"line":73,"code":"  it('should crop initial history in case it exceeds capacity', () => {\n    const hook = getHook(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n    expect(hook.result.current[0][2].history).toEqual([6, 7, 8, 9, 10]);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should apply capacity change only with next state set","suites":["useStateWithHistory"],"updatePoint":{"line":78,"column":59},"line":78,"code":"  it('should apply capacity change only with next state set', () => {\n    const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n    expect(hook.result.current[0][2].capacity).toBe(5);\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3, 4, 5]);\n\n    hook.rerender({ state: 5, capacity: 4, history: [1, 2, 3, 4, 5] });\n\n    expect(hook.result.current[0][2].capacity).toBe(5);\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3, 4, 5]);\n\n    act(() => {\n      hook.result.current[0][1](() => 111);\n    });\n\n    expect(hook.result.current[0][0]).toBe(111);\n    expect(hook.result.current[0][2].capacity).toBe(4);\n    expect(hook.result.current[0][2].history).toEqual([3, 4, 5, 111]);\n\n    hook.rerender({ state: 5, capacity: 3, history: [1, 2, 3, 4, 5] });\n    expect(hook.result.current[0][2].capacity).toBe(4);\n    expect(hook.result.current[0][2].history).toEqual([3, 4, 5, 111]);\n\n    act(() => {\n      hook.result.current[0][1](() => 321);\n    });\n\n    expect(hook.result.current[0][0]).toBe(321);\n    expect(hook.result.current[0][2].capacity).toBe(3);\n    expect(hook.result.current[0][2].history).toEqual([5, 111, 321]);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should cause rerender","suites":["useStateWithHistory","history.back()"],"updatePoint":{"line":110,"column":29},"line":110,"code":"    it('should cause rerender', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      expect(hook.result.current[1]).toBe(1);\n      act(() => {\n        hook.result.current[0][2].back(1);\n      });\n      expect(hook.result.current[1]).toBe(2);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should travel history back one step at a time if called without arguments","suites":["useStateWithHistory","history.back()"],"updatePoint":{"line":120,"column":81},"line":120,"code":"    it('should travel history back one step at a time if called without arguments', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      expect(hook.result.current[0][0]).toBe(5);\n\n      act(() => {\n        hook.result.current[0][2].back();\n      });\n      expect(hook.result.current[0][0]).toBe(4);\n      act(() => {\n        hook.result.current[0][2].back();\n      });\n      expect(hook.result.current[0][0]).toBe(3);\n      act(() => {\n        hook.result.current[0][2].back();\n      });\n      expect(hook.result.current[0][0]).toBe(2);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should travel history back by arbitrary amount of elements passed as 1st argument","suites":["useStateWithHistory","history.back()"],"updatePoint":{"line":139,"column":89},"line":139,"code":"    it('should travel history back by arbitrary amount of elements passed as 1st argument', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      expect(hook.result.current[0][0]).toBe(5);\n\n      act(() => {\n        hook.result.current[0][2].back(2);\n      });\n      expect(hook.result.current[0][0]).toBe(3);\n\n      act(() => {\n        hook.result.current[0][2].back(3);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should stop on first element if traveled to the left border","suites":["useStateWithHistory","history.back()"],"updatePoint":{"line":155,"column":67},"line":155,"code":"    it('should stop on first element if traveled to the left border', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      expect(hook.result.current[0][0]).toBe(5);\n\n      act(() => {\n        hook.result.current[0][2].back(6);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].back(150);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].back();\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should cause rerender","suites":["useStateWithHistory","history.forward()"],"updatePoint":{"line":178,"column":29},"line":178,"code":"    it('should cause rerender', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].back(3);\n      });\n      expect(hook.result.current[1]).toBe(2);\n      act(() => {\n        hook.result.current[0][2].forward(1);\n      });\n      expect(hook.result.current[1]).toBe(3);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should travel history forward one step at a time if called without arguments","suites":["useStateWithHistory","history.forward()"],"updatePoint":{"line":191,"column":84},"line":191,"code":"    it('should travel history forward one step at a time if called without arguments', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].back(6);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].forward();\n      });\n      expect(hook.result.current[0][0]).toBe(2);\n\n      act(() => {\n        hook.result.current[0][2].forward();\n      });\n      expect(hook.result.current[0][0]).toBe(3);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should travel history forward by arbitrary amount of elements passed as 1st argument","suites":["useStateWithHistory","history.forward()"],"updatePoint":{"line":210,"column":92},"line":210,"code":"    it('should travel history forward by arbitrary amount of elements passed as 1st argument', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].back(6);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].forward(2);\n      });\n      expect(hook.result.current[0][0]).toBe(3);\n\n      act(() => {\n        hook.result.current[0][2].forward(2);\n      });\n      expect(hook.result.current[0][0]).toBe(5);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should stop on last element if traveled to the right border","suites":["useStateWithHistory","history.forward()"],"updatePoint":{"line":229,"column":67},"line":229,"code":"    it('should stop on last element if traveled to the right border', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].back(6);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].forward(7);\n      });\n      expect(hook.result.current[0][0]).toBe(5);\n\n      act(() => {\n        hook.result.current[0][2].forward(250);\n      });\n      expect(hook.result.current[0][0]).toBe(5);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should cause rerender","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":250,"column":29},"line":250,"code":"    it('should cause rerender', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      expect(hook.result.current[1]).toBe(1);\n      act(() => {\n        hook.result.current[0][2].go(1);\n      });\n      expect(hook.result.current[1]).toBe(2);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should go to arbitrary position passed as 1st element","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":260,"column":61},"line":260,"code":"    it('should go to arbitrary position passed as 1st element', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].go(1);\n      });\n      expect(hook.result.current[0][0]).toBe(2);\n\n      act(() => {\n        hook.result.current[0][2].go(3);\n      });\n      expect(hook.result.current[0][0]).toBe(4);\n\n      act(() => {\n        hook.result.current[0][2].go(0);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should count from the right if position is negative","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":279,"column":59},"line":279,"code":"    it('should count from the right if position is negative', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].go(-1);\n      });\n      expect(hook.result.current[0][0]).toBe(5);\n\n      act(() => {\n        hook.result.current[0][2].go(-3);\n      });\n      expect(hook.result.current[0][0]).toBe(3);\n\n      act(() => {\n        hook.result.current[0][2].go(-5);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should properly handle too big values","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":298,"column":45},"line":298,"code":"    it('should properly handle too big values', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].go(-150);\n      });\n      expect(hook.result.current[0][0]).toBe(1);\n\n      act(() => {\n        hook.result.current[0][2].go(250);\n      });\n      expect(hook.result.current[0][0]).toBe(5);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should do nothing is position is equals current","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":312,"column":55},"line":312,"code":"    it('should do nothing is position is equals current', () => {\n      const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n\n      act(() => {\n        hook.result.current[0][2].go(4);\n      });\n      expect(hook.result.current[1]).toBe(1);\n      expect(hook.result.current[0][0]).toBe(5);\n      expect(hook.result.current[1]).toBe(1);\n    });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should pop elements to the right when setting state being not in the end of history","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":324,"column":89},"line":324,"code":"  it('should pop elements to the right when setting state being not in the end of history', () => {\n    const hook = getHook(5, 5, [1, 2, 3, 4, 5]);\n    act(() => {\n      hook.result.current[0][2].back(2);\n    });\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3, 4, 5]);\n    act(() => {\n      hook.result.current[0][1](8);\n    });\n    expect(hook.result.current[0][2].history).toEqual([1, 2, 3, 8]);\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should throw if capacity is 0 or negative","suites":["useStateWithHistory","history.go()"],"updatePoint":{"line":336,"column":47},"line":336,"code":"  it('should throw if capacity is 0 or negative', () => {\n    let hook = getHook(3, -1);\n    expect(hook.result.error).toEqual(new Error(`Capacity has to be greater than 1, got '-1'`));\n\n    hook = getHook(3, 0);\n    expect(hook.result.error).toEqual(new Error(`Capacity has to be greater than 1, got '0'`));\n  });","file":"useStateWithHistory.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useThrottle"],"updatePoint":{"line":17,"column":23},"line":17,"code":"  it('should be defined', () => {\n    expect(useThrottle).toBeDefined();\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should have a value to be returned","suites":["useThrottle"],"updatePoint":{"line":21,"column":40},"line":21,"code":"  it('should have a value to be returned', () => {\n    const { result } = renderHook(() => useThrottle(0, 100));\n    expect(result.current).toBe(0);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should has same value if time is advanced less than the given time","suites":["useThrottle"],"updatePoint":{"line":26,"column":72},"line":26,"code":"  it('should has same value if time is advanced less than the given time', () => {\n    const { result, rerender } = renderHook((props) => useThrottle(props, 100), {\n      initialProps: 0,\n    });\n    expect(result.current).toBe(0);\n    rerender(1);\n    jest.advanceTimersByTime(50);\n    expect(result.current).toBe(0);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should update the value after the given time when prop change","suites":["useThrottle"],"updatePoint":{"line":36,"column":67},"line":36,"code":"  it('should update the value after the given time when prop change', (done) => {\n    const hook = renderHook((props) => useThrottle(props, 100), { initialProps: 0 });\n    expect(hook.result.current).toBe(0);\n    hook.rerender(1);\n    expect(hook.result.current).toBe(0);\n    hook.waitForNextUpdate().then(() => {\n      expect(hook.result.current).toBe(1);\n      done();\n    });\n    jest.advanceTimersByTime(100);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should use the default ms value when missing","suites":["useThrottle"],"updatePoint":{"line":48,"column":50},"line":48,"code":"  it('should use the default ms value when missing', (done) => {\n    const hook = renderHook((props) => useThrottle(props), { initialProps: 0 });\n    expect(hook.result.current).toBe(0);\n    hook.rerender(1);\n    hook.waitForNextUpdate().then(() => {\n      expect(hook.result.current).toBe(1);\n      done();\n    });\n    jest.advanceTimersByTime(200);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should not update the value after the given time","suites":["useThrottle"],"updatePoint":{"line":59,"column":54},"line":59,"code":"  it('should not update the value after the given time', () => {\n    const hook = renderHook((props) => useThrottle(props, 100), { initialProps: 0 });\n    expect(hook.result.current).toBe(0);\n    jest.advanceTimersByTime(100);\n    expect(hook.result.current).toBe(0);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel timeout on unmount","suites":["useThrottle"],"updatePoint":{"line":66,"column":38},"line":66,"code":"  it('should cancel timeout on unmount', () => {\n    const hook = renderHook((props) => useThrottle(props, 100), { initialProps: 0 });\n    expect(hook.result.current).toBe(0);\n    hook.rerender(1);\n    hook.unmount();\n    expect(jest.getTimerCount()).toBe(0);\n    jest.advanceTimersByTime(100);\n    expect(hook.result.current).toBe(0);\n  });","file":"useThrottle.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useThrottleFn"],"updatePoint":{"line":15,"column":23},"line":15,"code":"  it('should be defined', () => {\n    expect(useThrottleFn).toBeDefined();\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should return the value that the given function return","suites":["useThrottleFn"],"updatePoint":{"line":24,"column":60},"line":24,"code":"  it('should return the value that the given function return', () => {\n    const [fn, hook] = getHook(10, 100);\n\n    expect(hook.result.current).toBe(10);\n    expect(fn).toHaveBeenCalledTimes(1);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should has same value if time is advanced less than the given time","suites":["useThrottleFn"],"updatePoint":{"line":31,"column":72},"line":31,"code":"  it('should has same value if time is advanced less than the given time', () => {\n    const [fn, hook] = getHook(10, 100);\n\n    expect(hook.result.current).toBe(10);\n    expect(fn).toHaveBeenCalledTimes(1);\n\n    hook.rerender(20);\n    jest.advanceTimersByTime(50);\n\n    expect(hook.result.current).toBe(10);\n    expect(fn).toHaveBeenCalledTimes(1);\n    expect(jest.getTimerCount()).toBe(1);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should update the value after the given time when arguments change","suites":["useThrottleFn"],"updatePoint":{"line":45,"column":72},"line":45,"code":"  it('should update the value after the given time when arguments change', (done) => {\n    const [fn, hook] = getHook('boo', 100);\n\n    expect(hook.result.current).toBe('boo');\n    expect(fn).toHaveBeenCalledTimes(1);\n\n    hook.rerender('foo');\n    hook.waitForNextUpdate().then(() => {\n      expect(hook.result.current).toBe('foo');\n      expect(fn).toHaveBeenCalledTimes(2);\n      done();\n    });\n    jest.advanceTimersByTime(100);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should use the default ms value when missing","suites":["useThrottleFn"],"updatePoint":{"line":60,"column":50},"line":60,"code":"  it('should use the default ms value when missing', (done) => {\n    const [fn, hook] = getHook('boo');\n\n    expect(hook.result.current).toBe('boo');\n    expect(fn).toHaveBeenCalledTimes(1);\n\n    hook.rerender('foo');\n    hook.waitForNextUpdate().then(() => {\n      expect(hook.result.current).toBe('foo');\n      expect(fn).toHaveBeenCalledTimes(2);\n      done();\n    });\n    jest.advanceTimersByTime(200);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should not exist timer when arguments did not update after the given time","suites":["useThrottleFn"],"updatePoint":{"line":74,"column":79},"line":74,"code":"  it('should not exist timer when arguments did not update after the given time', () => {\n    const [fn, hook] = getHook('boo', 100);\n\n    expect(hook.result.current).toBe('boo');\n    expect(fn).toHaveBeenCalledTimes(1);\n    expect(jest.getTimerCount()).toBe(1);\n\n    jest.advanceTimersByTime(100);\n\n    expect(jest.getTimerCount()).toBe(0);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel timeout on unmount","suites":["useThrottleFn"],"updatePoint":{"line":85,"column":38},"line":85,"code":"  it('should cancel timeout on unmount', () => {\n    const [fn, hook] = getHook('boo', 100);\n\n    expect(hook.result.current).toBe('boo');\n    expect(fn).toHaveBeenCalledTimes(1);\n\n    hook.rerender('foo');\n    hook.unmount();\n\n    expect(jest.getTimerCount()).toBe(0);\n    jest.advanceTimersByTime(100);\n    expect(fn).toHaveBeenCalledTimes(1);\n  });","file":"useThrottleFn.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":[],"updatePoint":{"line":17,"column":21},"line":17,"code":"it('should be defined', () => {\n  expect(useTimeout).toBeDefined();\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"should return three functions","suites":[],"updatePoint":{"line":21,"column":33},"line":21,"code":"it('should return three functions', () => {\n  const hook = renderHook(() => useTimeout(5));\n\n  expect(hook.result.current.length).toBe(3);\n  expect(typeof hook.result.current[0]).toBe('function');\n  expect(typeof hook.result.current[1]).toBe('function');\n  expect(typeof hook.result.current[2]).toBe('function');\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"should re-render component after given amount of time","suites":[],"updatePoint":{"line":46,"column":57},"line":46,"code":"it('should re-render component after given amount of time', (done) => {\n  const [spy, hook] = getHook();\n  expect(spy).toHaveBeenCalledTimes(1);\n  hook.waitForNextUpdate().then(() => {\n    expect(spy).toHaveBeenCalledTimes(2);\n    done();\n  });\n  jest.advanceTimersByTime(5);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel timeout on unmount","suites":[],"updatePoint":{"line":56,"column":36},"line":56,"code":"it('should cancel timeout on unmount', () => {\n  const [spy, hook] = getHook();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  hook.unmount();\n  jest.advanceTimersByTime(5);\n  expect(spy).toHaveBeenCalledTimes(1);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"first function should return actual state of timeout","suites":[],"updatePoint":{"line":65,"column":56},"line":65,"code":"it('first function should return actual state of timeout', (done) => {\n  let [, hook] = getHook();\n  let [isReady] = hook.result.current;\n\n  expect(isReady()).toBe(false);\n  hook.unmount();\n  expect(isReady()).toBe(null);\n\n  [, hook] = getHook();\n  [isReady] = hook.result.current;\n  hook.waitForNextUpdate().then(() => {\n    expect(isReady()).toBe(true);\n\n    done();\n  });\n  jest.advanceTimersByTime(5);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"second function should cancel timeout","suites":[],"updatePoint":{"line":83,"column":41},"line":83,"code":"it('second function should cancel timeout', () => {\n  const [spy, hook] = getHook();\n  const [isReady, cancel] = hook.result.current;\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  expect(isReady()).toBe(false);\n\n  act(() => {\n    cancel();\n  });\n  jest.advanceTimersByTime(5);\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  expect(isReady()).toBe(null);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"third function should reset timeout","suites":[],"updatePoint":{"line":99,"column":39},"line":99,"code":"it('third function should reset timeout', (done) => {\n  const [spy, hook] = getHook();\n  const [isReady, cancel, reset] = hook.result.current;\n\n  expect(isReady()).toBe(false);\n\n  act(() => {\n    cancel();\n  });\n  jest.advanceTimersByTime(5);\n\n  expect(isReady()).toBe(null);\n\n  act(() => {\n    reset();\n  });\n  expect(isReady()).toBe(false);\n\n  hook.waitForNextUpdate().then(() => {\n    expect(spy).toHaveBeenCalledTimes(2);\n    expect(isReady()).toBe(true);\n\n    done();\n  });\n  jest.advanceTimersByTime(5);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"should reset timeout on delay change","suites":[],"updatePoint":{"line":126,"column":40},"line":126,"code":"it('should reset timeout on delay change', (done) => {\n  const [spy, hook] = getHook(15);\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  hook.rerender({ delay: 5 });\n\n  hook.waitForNextUpdate().then(() => {\n    expect(spy).toHaveBeenCalledTimes(3);\n\n    done();\n  });\n  jest.advanceTimersByTime(15);\n});","file":"useTimeout.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useTimeoutFn"],"updatePoint":{"line":18,"column":23},"line":18,"code":"  it('should be defined', () => {\n    expect(useTimeoutFn).toBeDefined();\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should return three functions","suites":["useTimeoutFn"],"updatePoint":{"line":22,"column":35},"line":22,"code":"  it('should return three functions', () => {\n    const hook = renderHook(() => useTimeoutFn(() => {}, 5));\n\n    expect(hook.result.current.length).toBe(3);\n    expect(typeof hook.result.current[0]).toBe('function');\n    expect(typeof hook.result.current[1]).toBe('function');\n    expect(typeof hook.result.current[2]).toBe('function');\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should call passed function after given amount of time","suites":["useTimeoutFn"],"updatePoint":{"line":43,"column":60},"line":43,"code":"  it('should call passed function after given amount of time', () => {\n    const [spy] = getHook();\n\n    expect(spy).not.toHaveBeenCalled();\n    jest.advanceTimersByTime(5);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should cancel function call on unmount","suites":["useTimeoutFn"],"updatePoint":{"line":51,"column":44},"line":51,"code":"  it('should cancel function call on unmount', () => {\n    const [spy, hook] = getHook();\n\n    expect(spy).not.toHaveBeenCalled();\n    hook.unmount();\n    jest.advanceTimersByTime(5);\n    expect(spy).not.toHaveBeenCalled();\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"first function should return actual state of timeout","suites":["useTimeoutFn"],"updatePoint":{"line":60,"column":58},"line":60,"code":"  it('first function should return actual state of timeout', () => {\n    let [, hook] = getHook();\n    let [isReady] = hook.result.current;\n\n    expect(isReady()).toBe(false);\n    hook.unmount();\n    expect(isReady()).toBe(null);\n\n    [, hook] = getHook();\n    [isReady] = hook.result.current;\n    jest.advanceTimersByTime(5);\n    expect(isReady()).toBe(true);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"second function should cancel timeout","suites":["useTimeoutFn"],"updatePoint":{"line":74,"column":43},"line":74,"code":"  it('second function should cancel timeout', () => {\n    const [spy, hook] = getHook();\n    const [isReady, cancel] = hook.result.current;\n\n    expect(spy).not.toHaveBeenCalled();\n    expect(isReady()).toBe(false);\n\n    act(() => {\n      cancel();\n    });\n    jest.advanceTimersByTime(5);\n\n    expect(spy).not.toHaveBeenCalled();\n    expect(isReady()).toBe(null);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"third function should reset timeout","suites":["useTimeoutFn"],"updatePoint":{"line":90,"column":41},"line":90,"code":"  it('third function should reset timeout', () => {\n    const [spy, hook] = getHook();\n    const [isReady, cancel, reset] = hook.result.current;\n\n    expect(isReady()).toBe(false);\n\n    act(() => {\n      cancel();\n    });\n    jest.advanceTimersByTime(5);\n\n    expect(isReady()).toBe(null);\n\n    act(() => {\n      reset();\n    });\n    expect(isReady()).toBe(false);\n\n    jest.advanceTimersByTime(5);\n\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(isReady()).toBe(true);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should reset timeout on delay change","suites":["useTimeoutFn"],"updatePoint":{"line":114,"column":42},"line":114,"code":"  it('should reset timeout on delay change', () => {\n    const [spy, hook] = getHook(50);\n\n    expect(spy).not.toHaveBeenCalled();\n    hook.rerender({ delay: 5, cb: spy });\n\n    jest.advanceTimersByTime(5);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should NOT reset timeout on function change","suites":["useTimeoutFn"],"updatePoint":{"line":124,"column":49},"line":124,"code":"  it('should NOT reset timeout on function change', () => {\n    const [spy, hook] = getHook(50);\n\n    jest.advanceTimersByTime(25);\n    expect(spy).not.toHaveBeenCalled();\n\n    const spy2 = jest.fn();\n    hook.rerender({ delay: 50, cb: spy2 });\n\n    jest.advanceTimersByTime(25);\n    expect(spy).not.toHaveBeenCalled();\n    expect(spy2).toHaveBeenCalledTimes(1);\n  });","file":"useTimeoutFn.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useTitle"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useTitle).toBeDefined();\n  });","file":"useTitle.test.ts","skipped":false,"dir":"tests"},{"name":"should update document title","suites":["useTitle"],"updatePoint":{"line":9,"column":34},"line":9,"code":"  it('should update document title', () => {\n    const hook = renderHook((props) => useTitle(props), { initialProps: 'My page title' });\n\n    expect(document.title).toBe('My page title');\n    hook.rerender('My other page title');\n    expect(document.title).toBe('My other page title');\n  });","file":"useTitle.test.ts","skipped":false,"dir":"tests"},{"name":"should restore document title on unmount","suites":["useTitle"],"updatePoint":{"line":17,"column":46},"line":17,"code":"  it('should restore document title on unmount', () => {\n    renderHook((props) => useTitle(props), { initialProps: 'Old Title' });\n    expect(document.title).toBe('Old Title');\n\n    const hook = renderHook((props) => useTitle(props.title, { restoreOnUnmount: props.restore }), {\n      initialProps: { title: 'New Title', restore: true },\n    });\n    expect(document.title).toBe('New Title');\n    hook.unmount();\n    expect(document.title).toBe('Old Title');\n  });","file":"useTitle.test.ts","skipped":false,"dir":"tests"},{"name":"should init state to true","suites":[],"updatePoint":{"line":6,"column":29},"line":6,"code":"it('should init state to true', () => {\n  const { result } = setUp(true);\n\n  expect(result.current[0]).toBe(true);\n  expect(typeof result.current[1]).toBe('function');\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should init state to false","suites":[],"updatePoint":{"line":13,"column":30},"line":13,"code":"it('should init state to false', () => {\n  const { result } = setUp(false);\n\n  expect(result.current[0]).toBe(false);\n  expect(result.current[1]).toBeInstanceOf(Function);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should set state to true","suites":[],"updatePoint":{"line":20,"column":28},"line":20,"code":"it('should set state to true', () => {\n  const { result } = setUp(false);\n  const [, toggle] = result.current;\n\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    toggle(true);\n  });\n\n  expect(result.current[0]).toBe(true);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should set state to false","suites":[],"updatePoint":{"line":33,"column":29},"line":33,"code":"it('should set state to false', () => {\n  const { result } = setUp(true);\n  const [, toggle] = result.current;\n\n  expect(result.current[0]).toBe(true);\n\n  act(() => {\n    toggle(false);\n  });\n\n  expect(result.current[0]).toBe(false);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should toggle state from true","suites":[],"updatePoint":{"line":46,"column":33},"line":46,"code":"it('should toggle state from true', () => {\n  const { result } = setUp(true);\n  const [, toggle] = result.current;\n\n  act(() => {\n    toggle();\n  });\n\n  expect(result.current[0]).toBe(false);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should toggle state from false","suites":[],"updatePoint":{"line":57,"column":34},"line":57,"code":"it('should toggle state from false', () => {\n  const { result } = setUp(false);\n  const [, toggle] = result.current;\n\n  act(() => {\n    toggle();\n  });\n\n  expect(result.current[0]).toBe(true);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should ignore non-boolean parameters and toggle state","suites":[],"updatePoint":{"line":68,"column":57},"line":68,"code":"it('should ignore non-boolean parameters and toggle state', () => {\n  const { result } = setUp(true);\n  const [, toggle] = result.current;\n\n  act(() => {\n    toggle('string');\n  });\n\n  expect(result.current[0]).toBe(false);\n\n  act(() => {\n    toggle({});\n  });\n\n  expect(result.current[0]).toBe(true);\n});","file":"useToggle.test.ts","skipped":false,"dir":"tests"},{"name":"should init corresponding utils with default values","suites":[],"updatePoint":{"line":20,"column":55},"line":20,"code":"it('should init corresponding utils with default values', () => {\n  const { result } = renderHook(() => useTween());\n\n  expect(result.current).toBe(999999);\n  expect(spyEasingInCirc).toHaveBeenCalledTimes(1);\n  expect(spyEasingInCirc).toHaveBeenCalledWith(17);\n  expect(spyUseRaf).toHaveBeenCalledTimes(1);\n  expect(spyUseRaf).toHaveBeenCalledWith(200, 0);\n});","file":"useTween.test.ts","skipped":false,"dir":"tests"},{"name":"should init corresponding utils with custom values","suites":[],"updatePoint":{"line":30,"column":54},"line":30,"code":"it('should init corresponding utils with custom values', () => {\n  const { result } = renderHook(() => useTween('outCirc', 500, 15));\n\n  expect(result.current).toBe(101010);\n  expect(spyEasingOutCirc).toHaveBeenCalledTimes(1);\n  expect(spyEasingOutCirc).toHaveBeenCalledWith(17);\n  expect(spyUseRaf).toHaveBeenCalledTimes(1);\n  expect(spyUseRaf).toHaveBeenCalledWith(500, 15);\n});","file":"useTween.test.ts","skipped":false,"dir":"tests"},{"name":"should log an error","suites":["when invalid easing name is provided"],"updatePoint":{"line":46,"column":25},"line":46,"code":"  it('should log an error', () => {\n    const { result } = renderHook(() => useTween('grijanderl'));\n\n    expect(result.current).toBe(0);\n    expect(console.error).toHaveBeenCalledTimes(1);\n    expect(console.error).toHaveBeenCalledWith(\n      expect.stringContaining(\n        'useTween() expected \"easingName\" property to be a valid easing function name'\n      )\n    );\n    expect(console.trace).toHaveBeenCalledTimes(1);\n  });","file":"useTween.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useUnmount"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useUnmount).toBeDefined();\n  });","file":"useUnmount.test.ts","skipped":false,"dir":"tests"},{"name":"should not call provided callback on mount","suites":["useUnmount"],"updatePoint":{"line":9,"column":48},"line":9,"code":"  it('should not call provided callback on mount', () => {\n    const spy = jest.fn();\n    renderHook(() => useUnmount(spy));\n\n    expect(spy).not.toHaveBeenCalled();\n  });","file":"useUnmount.test.ts","skipped":false,"dir":"tests"},{"name":"should not call provided callback on re-renders","suites":["useUnmount"],"updatePoint":{"line":16,"column":53},"line":16,"code":"  it('should not call provided callback on re-renders', () => {\n    const spy = jest.fn();\n    const hook = renderHook(() => useUnmount(spy));\n\n    hook.rerender();\n    hook.rerender();\n    hook.rerender();\n    hook.rerender();\n\n    expect(spy).not.toHaveBeenCalled();\n  });","file":"useUnmount.test.ts","skipped":false,"dir":"tests"},{"name":"should call provided callback on unmount","suites":["useUnmount"],"updatePoint":{"line":28,"column":46},"line":28,"code":"  it('should call provided callback on unmount', () => {\n    const spy = jest.fn();\n    const hook = renderHook(() => useUnmount(spy));\n\n    hook.unmount();\n\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"useUnmount.test.ts","skipped":false,"dir":"tests"},{"name":"should call provided callback if is has been changed","suites":["useUnmount"],"updatePoint":{"line":37,"column":58},"line":37,"code":"  it('should call provided callback if is has been changed', () => {\n    const spy = jest.fn();\n    const spy2 = jest.fn();\n    const spy3 = jest.fn();\n    const hook = renderHook((cb) => useUnmount(cb), { initialProps: spy });\n\n    hook.rerender(spy2);\n    hook.rerender(spy3);\n    hook.unmount();\n\n    expect(spy).not.toHaveBeenCalled();\n    expect(spy2).not.toHaveBeenCalled();\n    expect(spy3).toHaveBeenCalledTimes(1);\n  });","file":"useUnmount.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useUnmountPromise"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useUnmountPromise).toBeDefined();\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"should return a function","suites":["useUnmountPromise"],"updatePoint":{"line":9,"column":30},"line":9,"code":"  it('should return a function', () => {\n    const hook = renderHook(() => useUnmountPromise());\n\n    expect(typeof hook.result.current).toBe('function');\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"when component is mounted function should resolve with wrapped promises","suites":["useUnmountPromise"],"updatePoint":{"line":15,"column":77},"line":15,"code":"  it('when component is mounted function should resolve with wrapped promises', async () => {\n    const hook = renderHook(() => useUnmountPromise());\n\n    const mounted = hook.result.current;\n    const res = await mounted(new Promise((r) => setTimeout(() => r(25), 10)));\n\n    expect(res).toBe(25);\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"when component is unmounted promise never resolves","suites":["useUnmountPromise"],"updatePoint":{"line":24,"column":56},"line":24,"code":"  it('when component is unmounted promise never resolves', async () => {\n    const hook = renderHook(() => useUnmountPromise());\n\n    const mounted = hook.result.current;\n    const promise = mounted(new Promise((r) => setTimeout(() => r(25), 10)));\n\n    hook.unmount();\n\n    const res = await Promise.race([\n      promise,\n      new Promise((r) => setTimeout(() => r('UNMOUNTED'), 20)),\n    ]);\n    expect(res).toBe('UNMOUNTED');\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"should resolve promise when component is updated","suites":["useUnmountPromise"],"updatePoint":{"line":39,"column":54},"line":39,"code":"  it('should resolve promise when component is updated', async () => {\n    const hook = renderHook(() => useUnmountPromise());\n\n    const mounted = hook.result.current;\n    const pRes = mounted(new Promise((r) => setTimeout(() => r(25), 10)));\n\n    hook.rerender();\n\n    const res = await pRes;\n\n    expect(res).toBe(25);\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"when component is mounted function should resolve with wrapped promises - 2","suites":["useUnmountPromise"],"updatePoint":{"line":52,"column":81},"line":52,"code":"  it('when component is mounted function should resolve with wrapped promises - 2', async () => {\n    const hook = renderHook(() => useUnmountPromise());\n\n    const mounted = hook.result.current;\n    const promise = mounted(new Promise((r) => setTimeout(() => r(25), 10)));\n\n    // hook.unmount();\n\n    const res = await Promise.race([\n      promise,\n      new Promise((r) => setTimeout(() => r('UNMOUNTED'), 20)),\n    ]);\n    expect(res).toBe(25);\n  });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"onError callback is not called","suites":["useUnmountPromise","when promise throws","when component is mounted"],"updatePoint":{"line":69,"column":40},"line":69,"code":"      it('onError callback is not called', async () => {\n        const hook = renderHook(() => useUnmountPromise());\n\n        const mounted = hook.result.current;\n        const onError = jest.fn();\n        try {\n          await mounted(new Promise((r, reject) => setTimeout(() => reject(r), 10)), onError);\n        } catch {}\n\n        expect(onError).toHaveBeenCalledTimes(0);\n      });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"onError callback is called","suites":["useUnmountPromise","when promise throws","when component is un-mounted"],"updatePoint":{"line":83,"column":36},"line":83,"code":"      it('onError callback is called', async () => {\n        const hook = renderHook(() => useUnmountPromise());\n\n        const mounted = hook.result.current;\n        const onError = jest.fn();\n        const promise = mounted(\n          new Promise((r, reject) => setTimeout(() => reject(r), 10)),\n          onError\n        );\n\n        hook.unmount();\n        await Promise.race([promise, new Promise((r) => setTimeout(r, 20))]);\n\n        expect(onError).toHaveBeenCalledTimes(1);\n        expect(typeof onError.mock.calls[0][0]).toBe('function');\n      });","file":"useUnmountPromise.test.ts","skipped":false,"dir":"tests"},{"name":"should be defined","suites":["useUpdate"],"updatePoint":{"line":5,"column":23},"line":5,"code":"  it('should be defined', () => {\n    expect(useUpdate).toBeDefined();\n  });","file":"useUpdate.test.ts","skipped":false,"dir":"tests"},{"name":"should return a function","suites":["useUpdate"],"updatePoint":{"line":9,"column":30},"line":9,"code":"  it('should return a function', () => {\n    const { result } = renderHook(() => useUpdate());\n\n    expect(typeof result.current).toBe('function');\n  });","file":"useUpdate.test.ts","skipped":false,"dir":"tests"},{"name":"should re-render component each time returned function is called","suites":["useUpdate"],"updatePoint":{"line":15,"column":70},"line":15,"code":"  it('should re-render component each time returned function is called', () => {\n    let renders = 0;\n    const {\n      result: { current: update },\n    } = renderHook(() => {\n      renders++;\n      return useUpdate();\n    });\n\n    expect(renders).toBe(1);\n\n    act(() => update());\n    expect(renders).toBe(2);\n\n    act(() => update());\n    expect(renders).toBe(3);\n  });","file":"useUpdate.test.ts","skipped":false,"dir":"tests"},{"name":"should return exact same function in between renders","suites":["useUpdate"],"updatePoint":{"line":33,"column":58},"line":33,"code":"  it('should return exact same function in between renders', () => {\n    let renders = 0;\n    const { result } = renderHook(() => {\n      renders++;\n      return useUpdate();\n    });\n    let initialUpdateFn = result.current;\n\n    expect(renders).toBe(1);\n\n    act(() => result.current());\n    expect(renders).toBe(2);\n    expect(initialUpdateFn).toBe(result.current);\n\n    act(() => result.current());\n    expect(renders).toBe(3);\n    expect(initialUpdateFn).toBe(result.current);\n  });","file":"useUpdate.test.ts","skipped":false,"dir":"tests"},{"name":"passing the argument to returned function should not affect the use","suites":["useUpdate"],"updatePoint":{"line":52,"column":73},"line":52,"code":"  it('passing the argument to returned function should not affect the use', () => {\n    let renders = 0;\n    const { result } = renderHook(() => {\n      renders++;\n      return useUpdate();\n    });\n    let initialUpdateFn = result.current;\n\n    expect(renders).toBe(1);\n\n    /* @ts-expect-error */\n    act(() => result.current(1));\n    expect(renders).toBe(2);\n    expect(initialUpdateFn).toBe(result.current);\n\n    /* @ts-expect-error */\n    act(() => result.current(1));\n    expect(renders).toBe(3);\n    expect(initialUpdateFn).toBe(result.current);\n  });","file":"useUpdate.test.ts","skipped":false,"dir":"tests"},{"name":"should run effect on update","suites":[],"updatePoint":{"line":4,"column":31},"line":4,"code":"it('should run effect on update', () => {\n  const effect = jest.fn();\n\n  const { rerender } = renderHook(() => useUpdateEffect(effect));\n  expect(effect).not.toHaveBeenCalled();\n\n  rerender();\n  expect(effect).toHaveBeenCalledTimes(1);\n});","file":"useUpdateEffect.test.ts","skipped":false,"dir":"tests"},{"name":"should run cleanup on unmount","suites":[],"updatePoint":{"line":14,"column":33},"line":14,"code":"it('should run cleanup on unmount', () => {\n  const cleanup = jest.fn();\n  const effect = jest.fn().mockReturnValue(cleanup);\n  const hook = renderHook(() => useUpdateEffect(effect));\n\n  hook.rerender();\n  hook.unmount();\n\n  expect(cleanup).toHaveBeenCalledTimes(1);\n});","file":"useUpdateEffect.test.ts","skipped":false,"dir":"tests"},{"name":"properly initiates the list content","suites":["useUpsert","initialization"],"updatePoint":{"line":26,"column":43},"line":26,"code":"    it('properly initiates the list content', () => {\n      expect(list).toEqual(testItems);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"returns an upsert function","suites":["useUpsert","initialization"],"updatePoint":{"line":30,"column":34},"line":30,"code":"    it('returns an upsert function', () => {\n      expect(utils.upsert).toBeInstanceOf(Function);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"inserts a new item","suites":["useUpsert","upserting a new item"],"updatePoint":{"line":47,"column":26},"line":47,"code":"    it('inserts a new item', () => {\n      expect(result.current[0]).toContain(newItem);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"works immutably","suites":["useUpsert","upserting a new item"],"updatePoint":{"line":50,"column":23},"line":50,"code":"    it('works immutably', () => {\n      expect(result.current[0]).not.toBe(testItems);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"has the same length","suites":["useUpsert","upserting an existing item"],"updatePoint":{"line":68,"column":27},"line":68,"code":"    it('has the same length', () => {\n      expect(updatedList).toHaveLength(testItems.length);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"updates the item","suites":["useUpsert","upserting an existing item"],"updatePoint":{"line":71,"column":24},"line":71,"code":"    it('updates the item', () => {\n      expect(updatedList).toContain(newItem);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"},{"name":"works immutably","suites":["useUpsert","upserting an existing item"],"updatePoint":{"line":74,"column":23},"line":74,"code":"    it('works immutably', () => {\n      expect(updatedList).not.toBe(testItems);\n    });","file":"useUpsert.test.ts","skipped":false,"dir":"tests"}]}