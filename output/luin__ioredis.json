{"repo":"luin/ioredis","url":"https://github.com/luin/ioredis","branch":"master","configs":[{"package":"ioredis","lang":"js","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should send auth before other commands","suites":["auth"],"updatePoint":{"line":7,"column":44,"index":274},"line":7,"code":"  it(\"should send auth before other commands\", function (done) {\n    let authed = false;\n    new MockServer(17379, argv => {\n      if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n        authed = true;\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(authed).to.eql(true);\n        redis.disconnect();\n        done();\n      }\n    });\n    var redis = new Redis({\n      port: 17379,\n      password: \"pass\"\n    });\n    redis.get(\"foo\").catch(function () {});\n  });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should resend auth after reconnect","suites":["auth"],"updatePoint":{"line":24,"column":40,"index":756},"line":24,"code":"  it(\"should resend auth after reconnect\", function (done) {\n    let begin = false;\n    let authed = false;\n    new MockServer(17379, function (argv) {\n      if (!begin) {\n        return;\n      }\n\n      if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n        authed = true;\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(authed).to.eql(true);\n        redis.disconnect();\n        done();\n      }\n    });\n    var redis = new Redis({\n      port: 17379,\n      password: \"pass\"\n    });\n    redis.once(\"ready\", function () {\n      begin = true;\n      redis.disconnect({\n        reconnect: true\n      });\n      redis.get(\"foo\").catch(function () {});\n    });\n  });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle auth with Redis URL string (redis://:foo@bar.com/) correctly","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":53,"column":82,"index":1532},"line":53,"code":"    it(\"should handle auth with Redis URL string (redis://:foo@bar.com/) correctly\", function (done) {\n      const password = \"pass\";\n      let redis;\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis(`redis://:${password}@localhost:17379/`);\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should not emit \"error\" when the server doesn't need auth","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":64,"column":66,"index":1913},"line":64,"code":"    it('should not emit \"error\" when the server doesn\\'t need auth', function (done) {\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR Client sent AUTH, but no password is set\");\n        }\n      });\n      let errorEmited = false;\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      redis.on(\"error\", function () {\n        errorEmited = true;\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"but a password was supplied\") !== -1) {\n          stub.restore();\n          setTimeout(function () {\n            expect(errorEmited).to.eql(false);\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when the password is wrong","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":89,"column":54,"index":2719},"line":89,"code":"    it('should emit \"error\" when the password is wrong', function (done) {\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR invalid password\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      let pending = 2;\n\n      function check() {\n        if (! --pending) {\n          redis.disconnect();\n          done();\n        }\n      }\n\n      redis.on(\"error\", function (error) {\n        expect(error).to.have.property(\"message\", \"ERR invalid password\");\n        check();\n      });\n      redis.get(\"foo\", function (err, res) {\n        expect(err.message).to.eql(\"ERR invalid password\");\n        check();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when password is not provided","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":117,"column":57,"index":3487},"line":117,"code":"    it('should emit \"error\" when password is not provided', function (done) {\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"info\") {\n          return new Error(\"NOAUTH Authentication required.\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379\n      });\n      redis.on(\"error\", function (error) {\n        expect(error).to.have.property(\"message\", \"NOAUTH Authentication required.\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when username and password are set for a Redis 5 server","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":132,"column":83,"index":4007},"line":132,"code":"    it('should emit \"error\" when username and password are set for a Redis 5 server', function (done) {\n      let username = \"user\";\n      let password = \"password\";\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          return new Error(\"ERR wrong number of arguments for 'auth' command\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379,\n        username,\n        password\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"You are probably passing both username and password to Redis version 5 or below\") !== -1) {\n          stub.restore();\n          setTimeout(function () {\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle username and password auth (Redis >=6) correctly","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":158,"column":70,"index":4916},"line":158,"code":"    it(\"should handle username and password auth (Redis >=6) correctly\", function (done) {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username,\n        password\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle auth with Redis URL string with username and password (Redis >=6) (redis://foo:bar@baz.com/) correctly","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":174,"column":124,"index":5432},"line":174,"code":"    it(\"should handle auth with Redis URL string with username and password (Redis >=6) (redis://foo:bar@baz.com/) correctly\", function (done) {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis(`redis://user:pass@localhost:17379/?allowUsernameInURI=true`);\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should not emit \"error\" when the Redis >=6 server doesn't need auth","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":186,"column":76,"index":5895},"line":186,"code":"    it('should not emit \"error\" when the Redis >=6 server doesn\\'t need auth', function (done) {\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR AUTH <password> called without any password configured for the default user. Are you sure your configuration is correct?\");\n        }\n      });\n      let errorEmited = false;\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      redis.on(\"error\", function () {\n        console.log(\"boop\");\n        errorEmited = true;\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"`default` user does not require a password\") !== -1) {\n          stub.restore();\n          setTimeout(function () {\n            expect(errorEmited).to.eql(false);\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when passing username but not password to Redis >=6 instance","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":212,"column":88,"index":6859},"line":212,"code":"    it('should emit \"error\" when passing username but not password to Redis >=6 instance', function (done) {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\") {\n          if (argv[1] === username && argv[2] === password) {\n            return \"OK\";\n          } else {\n            return new Error(\"WRONGPASS invalid username-password pair\");\n          }\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username\n      });\n      redis.on(\"error\", function (error) {\n        expect(error).to.have.property(\"message\", \"WRONGPASS invalid username-password pair\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when the password is wrong","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":235,"column":54,"index":7575},"line":235,"code":"    it('should emit \"error\" when the password is wrong', function (done) {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"auth\") {\n          if (argv[1] === username && argv[2] === password) {\n            return \"OK\";\n          } else {\n            return new Error(\"WRONGPASS invalid username-password pair\");\n          }\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username,\n        password: \"notpass\"\n      });\n      redis.on(\"error\", function (error) {\n        expect(error).to.have.property(\"message\", \"WRONGPASS invalid username-password pair\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when password is required but not provided","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":259,"column":70,"index":8336},"line":259,"code":"    it('should emit \"error\" when password is required but not provided', function (done) {\n      new MockServer(17379, function (argv) {\n        if (argv[0] === \"info\") {\n          return new Error(\"NOAUTH Authentication required.\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379\n      });\n      redis.on(\"error\", function (error) {\n        expect(error).to.have.property(\"message\", \"NOAUTH Authentication required.\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should automatic add commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":5,"column":53,"index":218},"line":5,"code":"  it(\"should automatic add commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise = redis.get(\"foo\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    const res = await promise;\n    expect(res).to.eql(\"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add non-compatible commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":17,"column":62,"index":662},"line":17,"code":"  it(\"should not add non-compatible commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promises = [];\n    promises.push(redis.subscribe(\"subscribe\").catch(() => {}));\n    promises.push(redis.unsubscribe(\"subscribe\").catch(() => {}));\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    await promises;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add blacklisted commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":28,"column":59,"index":1094},"line":28,"code":"  it(\"should not add blacklisted commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true,\n      autoPipeliningIgnoredCommands: [\"hmget\"]\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise = redis.hmget(\"foo\").catch(() => {});\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    await promise;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support buffer commands","suites":["autoPipelining for single node"],"updatePoint":{"line":38,"column":36,"index":1449},"line":38,"code":"  it(\"should support buffer commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    const buffer = Buffer.from(\"bar\");\n    await redis.setBuffer(\"foo\", buffer);\n    const promise = redis.getBuffer(\"foo\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql(buffer);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support custom commands","suites":["autoPipelining for single node"],"updatePoint":{"line":48,"column":36,"index":1797},"line":48,"code":"  it(\"should support custom commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    redis.defineCommand(\"echo\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n    const promise = redis.echo(\"foo1\", \"foo2\", \"bar1\", \"bar2\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql([\"foo1\", \"foo2\", \"bar1\", \"bar2\"]);\n    await redis.echo(\"foo1\", \"foo2\", \"bar1\", \"bar2\");\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support multiple commands","suites":["autoPipelining for single node"],"updatePoint":{"line":61,"column":38,"index":2285},"line":61,"code":"  it(\"should support multiple commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    expect(await Promise.all([redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\")])).to.eql([\"bar\", \"bar\", \"bar\", \"bar\", \"bar\"]);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support commands queued after a pipeline is already queued for execution","suites":["autoPipelining for single node"],"updatePoint":{"line":68,"column":85,"index":2666},"line":68,"code":"  it(\"should support commands queued after a pipeline is already queued for execution\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    let value1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", () => {});\n    redis.set(\"foo2\", \"bar2\", () => {});\n    redis.get(\"foo1\", (err, v1) => {\n      expect(err).to.eql(null);\n      value1 = v1;\n    });\n    process.nextTick(() => {\n      redis.get(\"foo2\", (err, value2) => {\n        expect(err).to.eql(null);\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar2\");\n        expect(redis.autoPipelineQueueSize).to.eql(0);\n        done();\n      });\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(3);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should correctly track pipeline length","suites":["autoPipelining for single node"],"updatePoint":{"line":91,"column":44,"index":3369},"line":91,"code":"  it(\"should correctly track pipeline length\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise1 = redis.set(\"foo\", \"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    await promise1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise2 = Promise.all([redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\")]);\n    expect(redis.autoPipelineQueueSize).to.eql(5);\n    await promise2;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle rejections","suites":["autoPipelining for single node"],"updatePoint":{"line":104,"column":30,"index":3909},"line":104,"code":"  it(\"should handle rejections\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    await expect(redis.set(\"foo\")).to.eventually.be.rejectedWith(\"ERR wrong number of arguments for 'set' command\");\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the happy case","suites":["autoPipelining for single node"],"updatePoint":{"line":111,"column":48,"index":4203},"line":111,"code":"  it(\"should support callbacks in the happy case\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    let value1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", () => {});\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    redis.set(\"foo2\", \"bar2\", () => {\n      redis.get(\"foo1\", (err, v1) => {\n        expect(err).to.eql(null);\n        value1 = v1;\n      });\n      expect(redis.autoPipelineQueueSize).to.eql(1);\n      redis.get(\"foo2\", (err, value2) => {\n        expect(err).to.eql(null);\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar2\");\n        expect(redis.autoPipelineQueueSize).to.eql(0);\n        done();\n      });\n      expect(redis.autoPipelineQueueSize).to.eql(2);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the failure case","suites":["autoPipelining for single node"],"updatePoint":{"line":136,"column":50,"index":5045},"line":136,"code":"  it(\"should support callbacks in the failure case\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", err => {\n      expect(err).to.eql(null);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    redis.set(\"foo2\", err => {\n      expect(err.message).to.include(\"ERR wrong number of arguments for 'set' command\");\n      done();\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle callbacks failures","suites":["autoPipelining for single node"],"updatePoint":{"line":151,"column":38,"index":5547},"line":151,"code":"  it(\"should handle callbacks failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n\n      done();\n    });\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", err => {\n      expect(err).to.eql(null);\n      throw new Error(\"ERROR\");\n    });\n    redis.set(\"foo2\", \"bar2\", err => {\n      expect(err).to.eql(null);\n      expect(redis.autoPipelineQueueSize).to.eql(0);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support ASK","suites":["cluster:ASK"],"updatePoint":{"line":6,"column":24,"index":237},"line":6,"code":"  it(\"should support ASK\", function (done) {\n    let asked = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n      } else if (argv[0] === \"asking\") {\n        asked = true;\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (++times === 2) {\n          process.nextTick(function () {\n            cluster.disconnect();\n            done();\n          });\n        } else {\n          return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n        }\n      }\n    });\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\", function () {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/ask.ts","skipped":false,"dir":"test"},{"name":"should be able to redirect a command to a unknown node","suites":["cluster:ASK"],"updatePoint":{"line":47,"column":60,"index":1400},"line":47,"code":"  it(\"should be able to redirect a command to a unknown node\", function (done) {\n    let asked = false;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n        return \"bar\";\n      } else if (argv[0] === \"asking\") {\n        asked = true;\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }]);\n    cluster.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/ask.ts","skipped":false,"dir":"test"},{"name":"should automatic add commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":85,"column":53,"index":2329},"line":85,"code":"  it(\"should automatic add commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise = cluster.get(\"foo1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(1);\n    const res = await promise;\n    expect(res).to.eql(\"bar1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add non-compatible commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":99,"column":62,"index":2892},"line":99,"code":"  it(\"should not add non-compatible commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promises = [];\n    promises.push(cluster.subscribe(\"subscribe\").catch(() => {}));\n    promises.push(cluster.unsubscribe(\"subscribe\").catch(() => {}));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    await promises;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add blacklisted commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":112,"column":59,"index":3437},"line":112,"code":"  it(\"should not add blacklisted commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      autoPipeliningIgnoredCommands: [\"hmget\"]\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise = cluster.hmget(\"foo1\").catch(() => {});\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    await promise;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support custom commands","suites":["autoPipelining for cluster"],"updatePoint":{"line":124,"column":36,"index":3904},"line":124,"code":"  it(\"should support custom commands\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    cluster.defineCommand(\"echo\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n    const promise = cluster.echo(\"foo1\", \"foo1\", \"bar1\", \"bar2\");\n    expect(cluster.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql([\"foo1\", \"foo1\", \"bar1\", \"bar2\"]);\n    await cluster.echo(\"foo1\", \"foo1\", \"bar1\", \"bar2\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support multiple commands","suites":["autoPipelining for cluster"],"updatePoint":{"line":139,"column":38,"index":4505},"line":139,"code":"  it(\"should support multiple commands\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo5\", \"bar5\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")])).to.eql([\"bar1\", \"bar5\", \"bar1\", \"bar5\", \"bar1\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support building pipelines when a prefix is used","suites":["autoPipelining for cluster"],"updatePoint":{"line":149,"column":61,"index":5030},"line":149,"code":"  it(\"should support building pipelines when a prefix is used\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      keyPrefix: \"baz:\"\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo10\", \"bar10\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo10\")])).to.eql([\"bar1\", \"bar10\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support building pipelines when a prefix is used with arrays to flatten","suites":["autoPipelining for cluster"],"updatePoint":{"line":160,"column":84,"index":5520},"line":160,"code":"  it(\"should support building pipelines when a prefix is used with arrays to flatten\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      keyPrefix: \"baz:\"\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set([\"foo1\"], \"bar1\");\n    await cluster.set([\"foo10\"], \"bar10\");\n    expect(await Promise.all([cluster.get([\"foo1\"]), cluster.get([\"foo10\"])])).to.eql([\"bar1\", \"bar10\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support commands queued after a pipeline is already queued for execution","suites":["autoPipelining for cluster"],"updatePoint":{"line":171,"column":85,"index":6019},"line":171,"code":"  it(\"should support commands queued after a pipeline is already queued for execution\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let value1;\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", () => {});\n      cluster.set(\"foo5\", \"bar5\", () => {});\n      cluster.get(\"foo1\", (err, v1) => {\n        expect(err).to.eql(null);\n        value1 = v1;\n      });\n      process.nextTick(() => {\n        cluster.get(\"foo5\", (err, value2) => {\n          expect(err).to.eql(null);\n          expect(value1).to.eql(\"bar1\");\n          expect(value2).to.eql(\"bar5\");\n          expect(cluster.autoPipelineQueueSize).to.eql(0);\n          cluster.disconnect();\n          done();\n        });\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should correctly track pipeline length","suites":["autoPipelining for cluster"],"updatePoint":{"line":197,"column":44,"index":6859},"line":197,"code":"  it(\"should correctly track pipeline length\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise1 = cluster.set(\"foo1\", \"bar\");\n    const promise2 = cluster.set(\"foo5\", \"bar\");\n    expect(cluster.autoPipelineQueueSize).to.eql(2);\n    await promise1;\n    await promise2;\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise3 = Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")]);\n    expect(cluster.autoPipelineQueueSize).to.eql(5);\n    await promise3;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle rejections","suites":["autoPipelining for cluster"],"updatePoint":{"line":214,"column":30,"index":7599},"line":214,"code":"  it(\"should handle rejections\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await cluster.set(\"foo1\", \"bar\");\n    await expect(cluster.set(\"foo1\")).to.eventually.be.rejectedWith(\"ERR wrong number of arguments for 'set' command\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the happy case","suites":["autoPipelining for cluster"],"updatePoint":{"line":222,"column":48,"index":7936},"line":222,"code":"  it(\"should support callbacks in the happy case\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let value1, value2;\n\n      function cb() {\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar5\");\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n        cluster.disconnect();\n        done();\n      }\n\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      /*\n        In this test, foo1 and foo5 usually (like in the case of 3 nodes scenario) belongs\n        to different nodes group.\n        Therefore we are also testing callback scenario with multiple pipelines fired together.\n      */\n\n      cluster.set(\"foo1\", \"bar1\", () => {});\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo5\", \"bar5\", () => {\n        cluster.get(\"foo1\", (err, v1) => {\n          expect(err).to.eql(null);\n          value1 = v1; // This is needed as we cannot really predict which nodes responds first\n\n          if (value1 && value2) {\n            cb();\n          }\n        });\n        expect(cluster.autoPipelineQueueSize).to.eql(1);\n        cluster.get(\"foo5\", (err, v2) => {\n          expect(err).to.eql(null);\n          value2 = v2; // This is needed as we cannot really predict which nodes responds first\n\n          if (value1 && value2) {\n            cb();\n          }\n        });\n        expect(cluster.autoPipelineQueueSize).to.eql(2);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the failure case","suites":["autoPipelining for cluster"],"updatePoint":{"line":269,"column":50,"index":9490},"line":269,"code":"  it(\"should support callbacks in the failure case\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo5\", err => {\n        expect(err.message).to.include(\"ERR wrong number of arguments for 'set' command\");\n        cluster.disconnect();\n        done();\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle callbacks failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":287,"column":38,"index":10107},"line":287,"code":"  it(\"should handle callbacks failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n\n      cluster.disconnect();\n      done();\n    });\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n        throw new Error(\"ERROR\");\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        expect(err).to.eql(null);\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":316,"column":45,"index":11030},"line":316,"code":"  it(\"should handle general pipeline failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n\n      cluster.disconnect();\n      done();\n    });\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n        throw new Error(\"ERROR\");\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        expect(err).to.eql(null);\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline rejections","suites":["autoPipelining for cluster"],"updatePoint":{"line":345,"column":47,"index":11955},"line":345,"code":"  it(\"should handle general pipeline rejections\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    const promise1 = cluster.set(\"foo1\", \"bar\");\n    const promise2 = cluster.set(\"foo5\", \"bar\");\n    const promise3 = cluster.set(\"foo2\", \"bar\");\n    const promise4 = cluster.set(\"foo6\", \"bar\"); // Override slots to induce a failure\n\n    const key1Slot = calculateKeySlot(\"foo1\");\n    const key2Slot = calculateKeySlot(\"foo2\");\n    const key5Slot = calculateKeySlot(\"foo5\");\n    changeSlot(cluster, key1Slot, key2Slot);\n    changeSlot(cluster, key2Slot, key5Slot);\n    await expect(promise1).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise2).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise3).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise4).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":366,"column":45,"index":13205},"line":366,"code":"  it(\"should handle general pipeline failures\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let err1, err2, err3, err4;\n\n      function cb() {\n        expect(err1.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err2.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err3.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err4.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n        cluster.disconnect();\n        done();\n      }\n\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        err1 = err;\n\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo2\", \"bar2\", err => {\n        err2 = err;\n\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n      cluster.set(\"foo5\", \"bar5\", err => {\n        err3 = err;\n\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n      cluster.set(\"foo6\", \"bar6\", err => {\n        err4 = err;\n\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(4); // Override slots to induce a failure\n\n      const key1Slot = calculateKeySlot(\"foo1\");\n      const key2Slot = calculateKeySlot(\"foo2\");\n      const key5Slot = calculateKeySlot(\"foo5\");\n      changeSlot(cluster, key1Slot, key2Slot);\n      changeSlot(cluster, key2Slot, key5Slot);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures callbacks failure","suites":["autoPipelining for cluster"],"updatePoint":{"line":424,"column":63,"index":15169},"line":424,"code":"  it(\"should handle general pipeline failures callbacks failure\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    cluster.once(\"connect\", () => {\n      let err1, err5;\n      process.once(\"uncaughtException\", err => {\n        expect(err.message).to.eql(\"ERROR\");\n        expect(err1.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err5.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n\n        for (const listener of listeners) {\n          process.on(\"uncaughtException\", listener);\n        }\n\n        cluster.disconnect();\n        done();\n      });\n      cluster.set(\"foo1\", \"bar1\", err => {\n        err1 = err;\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        err5 = err;\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n      cluster.set(\"foo2\", err => {\n        throw new Error(\"ERROR\");\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n      const key1Slot = calculateKeySlot(\"foo1\");\n      const key2Slot = calculateKeySlot(\"foo2\");\n      changeSlot(cluster, key1Slot, key2Slot);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support lazyConnect","suites":["autoPipelining for cluster"],"updatePoint":{"line":460,"column":32,"index":16450},"line":460,"code":"  it(\"should support lazyConnect\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      lazyConnect: true\n    });\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo5\", \"bar5\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")])).to.eql([\"bar1\", \"bar5\", \"bar1\", \"bar5\", \"bar1\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should redirect the command to a random node","suites":["cluster:CLUSTERDOWN"],"updatePoint":{"line":5,"column":50,"index":220},"line":5,"code":"  it(\"should redirect the command to a random node\", function (done) {\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"CLUSTERDOWN\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false,\n      retryDelayOnClusterDown: 1\n    });\n    cluster.get(\"foo\", function (_, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/clusterdown.ts","skipped":false,"dir":"test"},{"name":"cleans up subscribers when selecting a new one","suites":["ClusterSubscriber"],"updatePoint":{"line":7,"column":52,"index":351},"line":7,"code":"  it(\"cleans up subscribers when selecting a new one\", async () => {\n    const pool = new ConnectionPool({});\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    let rejectSubscribes = false;\n    const server = new MockServer(30000, argv => {\n      if (rejectSubscribes && argv[0] === \"subscribe\") {\n        return new Error(\"Failed to subscribe\");\n      }\n\n      return \"OK\";\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    rejectSubscribes = true;\n    subscriber.start();\n    await subscriber.getInstance().echo(\"hello\");\n    subscriber.start();\n    await subscriber.getInstance().echo(\"hello\");\n    expect(server.getAllClients()).to.have.lengthOf(1);\n    subscriber.stop();\n    pool.reset([]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"sets correct connection name when connectionName is set","suites":["ClusterSubscriber"],"updatePoint":{"line":33,"column":61,"index":1203},"line":33,"code":"  it(\"sets correct connection name when connectionName is set\", async () => {\n    const pool = new ConnectionPool({\n      connectionName: \"test\"\n    });\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    const clientNames = [];\n    new MockServer(30000, argv => {\n      if (argv[0] === \"client\" && argv[1] === \"setname\") {\n        clientNames.push(argv[2]);\n      }\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    subscriber.stop();\n    pool.reset([]);\n    expect(clientNames).to.eql([\"ioredis-cluster(subscriber):test\"]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"sets correct connection name when connectionName is absent","suites":["ClusterSubscriber"],"updatePoint":{"line":54,"column":64,"index":1876},"line":54,"code":"  it(\"sets correct connection name when connectionName is absent\", async () => {\n    const pool = new ConnectionPool({});\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    const clientNames = [];\n    new MockServer(30000, argv => {\n      if (argv[0] === \"client\" && argv[1] === \"setname\") {\n        clientNames.push(argv[2]);\n      }\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    subscriber.stop();\n    pool.reset([]);\n    expect(clientNames).to.eql([\"ioredis-cluster(subscriber)\"]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"should flush the queue when all startup nodes are unreachable","suites":["cluster:connect"],"updatePoint":{"line":6,"column":67,"index":265},"line":6,"code":"  it(\"should flush the queue when all startup nodes are unreachable\", function (done) {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      clusterRetryStrategy: null\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(err.message).to.match(/None of startup nodes is available/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should invoke clusterRetryStrategy when all startup nodes are unreachable","suites":["cluster:connect"],"updatePoint":{"line":19,"column":79,"index":666},"line":19,"code":"  it(\"should invoke clusterRetryStrategy when all startup nodes are unreachable\", function (done) {\n    let t = 0;\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: function (times) {\n        expect(times).to.eql(++t);\n\n        if (times === 3) {\n          return;\n        }\n\n        return 0;\n      }\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(t).to.eql(3);\n      expect(err.message).to.match(/None of startup nodes is available/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should invoke clusterRetryStrategy when none nodes are ready","suites":["cluster:connect"],"updatePoint":{"line":45,"column":66,"index":1282},"line":45,"code":"  it(\"should invoke clusterRetryStrategy when none nodes are ready\", function (done) {\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\") {\n        return new Error(\"CLUSTERDOWN\");\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    let t = 0;\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: function (times) {\n        expect(times).to.eql(++t);\n\n        if (times === 3) {\n          cluster.disconnect();\n          done();\n          return;\n        }\n\n        return 0;\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should connect to cluster successfully","suites":["cluster:connect"],"updatePoint":{"line":75,"column":44,"index":1947},"line":75,"code":"  it(\"should connect to cluster successfully\", function (done) {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    node.once(\"connect\", function () {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should wait for ready state before resolving","suites":["cluster:connect"],"updatePoint":{"line":86,"column":50,"index":2242},"line":86,"code":"  it(\"should wait for ready state before resolving\", function (done) {\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"info\") {// return 'role:master'\n      }\n\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"cluster\" && argv[1] === \"info\") {\n        return \"cluster_state:ok\";\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: true\n    });\n    cluster.connect().then(function () {\n      expect(cluster.status).to.eql(\"ready\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should support url schema","suites":["cluster:connect"],"updatePoint":{"line":115,"column":31,"index":2965},"line":115,"code":"  it(\"should support url schema\", function (done) {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([\"redis://127.0.0.1:30001\"]);\n    node.once(\"connect\", function () {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should support a single port","suites":["cluster:connect"],"updatePoint":{"line":123,"column":34,"index":3217},"line":123,"code":"  it(\"should support a single port\", function (done) {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([30001]);\n    node.once(\"connect\", function () {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should return a promise to be resolved when connected","suites":["cluster:connect"],"updatePoint":{"line":131,"column":59,"index":3474},"line":131,"code":"  it(\"should return a promise to be resolved when connected\", function (done) {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    new MockServer(30003, argvHandler);\n    sinon.stub(Cluster.prototype, \"connect\").callsFake(() => Promise.resolve());\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    Cluster.prototype.connect.restore();\n    cluster.connect().then(function () {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should return a promise to be rejected when closed","suites":["cluster:connect"],"updatePoint":{"line":156,"column":56,"index":4288},"line":156,"code":"  it(\"should return a promise to be rejected when closed\", function (done) {\n    sinon.stub(Cluster.prototype, \"connect\").callsFake(() => Promise.resolve());\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    Cluster.prototype.connect.restore();\n    cluster.connect().catch(function () {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting when disconnected","suites":["cluster:connect"],"updatePoint":{"line":170,"column":48,"index":4700},"line":170,"code":"  it(\"should stop reconnecting when disconnected\", function (done) {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      clusterRetryStrategy: function () {\n        return 0;\n      }\n    });\n    cluster.on(\"close\", function () {\n      cluster.disconnect();\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      setTimeout(function () {\n        stub.restore();\n        done();\n      }, 1);\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should discover other nodes automatically","suites":["cluster:connect"],"updatePoint":{"line":188,"column":47,"index":5211},"line":188,"code":"  it(\"should discover other nodes automatically\", function (done) {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    };\n\n    const node1 = new MockServer(30001, argvHandler);\n    const node2 = new MockServer(30002, argvHandler);\n    const node3 = new MockServer(30003, argvHandler);\n    let pending = 3;\n    node1.once(\"connect\", check);\n    node2.once(\"connect\", check);\n    node3.once(\"connect\", check);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      redisOptions: {\n        lazyConnect: false\n      }\n    });\n\n    function check() {\n      if (! --pending) {\n        cluster.disconnect();\n        done();\n      }\n    }\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should send command to the correct node","suites":["cluster:connect"],"updatePoint":{"line":220,"column":45,"index":6107},"line":220,"code":"  it(\"should send command to the correct node\", function (done) {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        process.nextTick(function () {\n          cluster.disconnect();\n          done();\n        });\n      }\n    });\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should emit errors when cluster cannot be connected","suites":["cluster:connect"],"updatePoint":{"line":242,"column":57,"index":6748},"line":242,"code":"  it(\"should emit errors when cluster cannot be connected\", function (done) {\n    const errorMessage = \"ERR This instance has cluster support disabled\";\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return new Error(errorMessage);\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    let pending = 2;\n    let retry = 0;\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: function () {\n        cluster.once(\"error\", function (err) {\n          retry = false;\n          expect(err.message).to.eql(\"Failed to refresh slots cache.\");\n          expect(err.lastNodeError.message).to.eql(errorMessage);\n          checkDone();\n        });\n        return retry;\n      }\n    });\n    cluster.once(\"node error\", function (err, key) {\n      expect(err.message).to.eql(errorMessage);\n      expect([\"127.0.0.1:30001\", \"127.0.0.1:30002\"]).to.include(key);\n      checkDone();\n    });\n\n    function checkDone() {\n      if (! --pending) {\n        cluster.disconnect();\n        done();\n      }\n    }\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should using the specified password","suites":["cluster:connect"],"updatePoint":{"line":285,"column":41,"index":7946},"line":285,"code":"  it(\"should using the specified password\", function (done) {\n    let cluster;\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n\n    const argvHandler = function (port, argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"auth\") {\n        const password = argv[1];\n\n        if (port === 30001) {\n          expect(password).to.eql(\"other password\");\n        } else if (port === 30002) {\n          throw new Error(\"30002 got password\");\n        } else if (port === 30003) {\n          expect(password).to.eql(\"default password\");\n          cluster.disconnect();\n          done();\n        }\n      }\n    };\n\n    new MockServer(30001, argvHandler.bind(null, 30001));\n    new MockServer(30002, argvHandler.bind(null, 30002));\n    new MockServer(30003, argvHandler.bind(null, 30003));\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\",\n      password: \"other password\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\",\n      password: null\n    }], {\n      redisOptions: {\n        lazyConnect: false,\n        password: \"default password\"\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should discover other nodes automatically every slotsRefreshInterval","suites":["cluster:connect"],"updatePoint":{"line":327,"column":74,"index":9213},"line":327,"code":"  it(\"should discover other nodes automatically every slotsRefreshInterval\", function (done) {\n    let times = 0;\n    let cluster;\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        times++;\n\n        if (times === 1) {\n          return [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30001]], [10923, 16383, [\"127.0.0.1\", 30001]]];\n        }\n\n        return [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30001]], [10923, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    };\n\n    const node1 = new MockServer(30001, argvHandler);\n    const node2 = new MockServer(30002, argvHandler);\n    node1.once(\"connect\", function () {\n      node2.once(\"connect\", function () {\n        cluster.disconnect();\n        done();\n      });\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      slotsRefreshInterval: 100,\n      redisOptions: {\n        lazyConnect: false\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"throws when startupNodes is empty","suites":["cluster:connect"],"updatePoint":{"line":361,"column":39,"index":10176},"line":361,"code":"  it(\"throws when startupNodes is empty\", done => {\n    const message = \"`startupNodes` should contain at least one node.\";\n    let pending = 2;\n    const cluster = new Cluster(null, {\n      lazyConnect: true,\n\n      clusterRetryStrategy(_, reason) {\n        expect(reason.message).to.eql(message);\n\n        if (! --pending) {\n          done();\n        }\n\n        return false;\n      }\n\n    });\n    cluster.connect().catch(err => {\n      expect(err.message).to.eql(message);\n      cluster.disconnect();\n\n      if (! --pending) {\n        done();\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should reconnect after multiple consecutive disconnect(true) are called","suites":["cluster:connect","multiple reconnect"],"updatePoint":{"line":388,"column":79,"index":10830},"line":388,"code":"    it(\"should reconnect after multiple consecutive disconnect(true) are called\", function (done) {\n      new MockServer(30001);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        enableReadyCheck: false\n      });\n      cluster.once(\"reconnecting\", function () {\n        cluster.disconnect(true);\n      });\n      cluster.once(\"ready\", function () {\n        cluster.disconnect(true);\n        const rejectTimeout = setTimeout(function () {\n          cluster.disconnect();\n          done(new Error(\"second disconnect(true) didn't reconnect redis\"));\n        }, 1000);\n        process.nextTick(function () {\n          cluster.once(\"ready\", function () {\n            clearTimeout(rejectTimeout);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });\n    });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should clear the added script hashes interval when disconnecting","suites":["cluster:disconnect"],"updatePoint":{"line":417,"column":70,"index":11720},"line":417,"code":"  it(\"should clear the added script hashes interval when disconnecting\", function (done) {\n    new MockServer(30001);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      enableReadyCheck: false\n    });\n    cluster.once(\"ready\", function () {\n      cluster.disconnect();\n      expect(cluster._addedScriptHashesCleanInterval).to.be.null;\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should clear the added script hashes interval when quitting","suites":["cluster:disconnect"],"updatePoint":{"line":431,"column":65,"index":12123},"line":431,"code":"  it(\"should clear the added script hashes interval when quitting\", function (done) {\n    new MockServer(30001);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      enableReadyCheck: false\n    });\n    cluster.once(\"ready\", function () {\n      cluster.quit();\n      expect(cluster._addedScriptHashesCleanInterval).to.be.null;\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should clear the added script hashes interval even when no connection succeeded","suites":["cluster:disconnect"],"updatePoint":{"line":445,"column":85,"index":12540},"line":445,"code":"  it(\"should clear the added script hashes interval even when no connection succeeded\", function (done) {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"0\"\n    }], {\n      enableReadyCheck: false\n    });\n    let attempt = 0;\n    cluster.on(\"error\", function () {\n      if (attempt < 5) {\n        attempt++;\n        return;\n      }\n\n      cluster.quit();\n      expect(cluster._addedScriptHashesCleanInterval).to.be.null;\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on disconnect","suites":["disconnection"],"updatePoint":{"line":10,"column":43,"index":326},"line":10,"code":"  it(\"should clear all timers on disconnect\", function (done) {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30000\"\n    }]);\n    cluster.on(\"connect\", function () {\n      cluster.disconnect();\n    });\n    cluster.on(\"end\", function () {\n      setTimeout(() => {\n        // wait for disconnect with refresher.\n        expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n        server.disconnect();\n        done();\n      }, 500);\n    });\n  });","file":"functional/cluster/disconnection.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on server exits","suites":["disconnection"],"updatePoint":{"line":30,"column":45,"index":994},"line":30,"code":"  it(\"should clear all timers on server exits\", function (done) {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30000\"\n    }], {\n      clusterRetryStrategy: null\n    });\n    cluster.on(\"end\", function () {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      done();\n    });\n    server.disconnect();\n  });","file":"functional/cluster/disconnection.ts","skipped":false,"dir":"test"},{"name":"resolve hostnames to IPs","suites":["cluster:dnsLookup"],"updatePoint":{"line":5,"column":30,"index":192},"line":5,"code":"  it(\"resolve hostnames to IPs\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }]);\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(2);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(nodes[1].options.host).to.eql(\"127.0.0.1\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"support customize dnsLookup function","suites":["cluster:dnsLookup"],"updatePoint":{"line":22,"column":42,"index":825},"line":22,"code":"  it(\"support customize dnsLookup function\", done => {\n    let dnsLookupCalledCount = 0;\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    const cluster = new Cluster([{\n      host: \"a.com\",\n      port: \"30001\"\n    }], {\n      dnsLookup(hostname, callback) {\n        dnsLookupCalledCount += 1;\n\n        if (hostname === \"a.com\") {\n          callback(null, \"127.0.0.1\");\n        } else {\n          callback(new Error(\"Unknown hostname\"));\n        }\n      }\n\n    });\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(2);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(nodes[1].options.host).to.eql(\"127.0.0.1\");\n      expect(dnsLookupCalledCount).to.eql(1);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"reconnects when dns lookup fails","suites":["cluster:dnsLookup"],"updatePoint":{"line":52,"column":38,"index":1775},"line":52,"code":"  it(\"reconnects when dns lookup fails\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    let retried = false;\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }], {\n      dnsLookup(_, callback) {\n        if (retried) {\n          callback(null, \"127.0.0.1\");\n        } else {\n          callback(new Error(\"Random Exception\"));\n        }\n      },\n\n      clusterRetryStrategy: function (_, reason) {\n        expect(reason.message).to.eql(\"Random Exception\");\n        expect(retried).to.eql(false);\n        retried = true;\n        return 0;\n      }\n    });\n    cluster.on(\"ready\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"reconnects when dns lookup thrown an error","suites":["cluster:dnsLookup"],"updatePoint":{"line":81,"column":48,"index":2631},"line":81,"code":"  it(\"reconnects when dns lookup thrown an error\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    let retried = false;\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }], {\n      dnsLookup(_, callback) {\n        if (retried) {\n          callback(null, \"127.0.0.1\");\n        } else {\n          throw new Error(\"Random Exception\");\n        }\n      },\n\n      clusterRetryStrategy: function (_, reason) {\n        expect(reason.message).to.eql(\"Random Exception\");\n        expect(retried).to.eql(false);\n        retried = true;\n        return 0;\n      }\n    });\n    cluster.on(\"ready\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"clone the options","suites":["cluster:duplicate"],"updatePoint":{"line":5,"column":23,"index":185},"line":5,"code":"  it(\"clone the options\", done => {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([]);\n    const duplicatedCluster = cluster.duplicate([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    node.once(\"connect\", function () {\n      expect(duplicatedCluster.nodes()).to.have.lengthOf(1);\n      expect(duplicatedCluster.nodes()[0].options.port).to.eql(30001);\n      cluster.disconnect();\n      duplicatedCluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/duplicate.ts","skipped":false,"dir":"test"},{"name":"should return the error successfully","suites":["cluster"],"updatePoint":{"line":7,"column":42,"index":295},"line":7,"code":"  it(\"should return the error successfully\", function (done) {\n    let called = false;\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n\n      if (argv.toString() === \"get,foo,bar\") {\n        called = true;\n        return new Error(\"Wrong arguments count\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", \"bar\", function (err) {\n      expect(called).to.eql(true);\n      expect(err.message).to.match(/Wrong arguments count/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should get value successfully","suites":["cluster"],"updatePoint":{"line":30,"column":35,"index":962},"line":30,"code":"  it(\"should get value successfully\", function (done) {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should reconnect when cluster state is not ok","suites":["cluster","enableReadyCheck"],"updatePoint":{"line":52,"column":53,"index":1643},"line":52,"code":"    it(\"should reconnect when cluster state is not ok\", function (done) {\n      let state = \"fail\";\n      new MockServer(30001, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return [[0, 16383, [\"127.0.0.1\", 30001]]];\n        } else if (argv[0] === \"cluster\" && argv[1] === \"info\") {\n          return \"cluster_state:\" + state;\n        }\n      });\n      let count = 0;\n      const client = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        clusterRetryStrategy: function (times) {\n          expect(++count).to.eql(times);\n\n          if (count === 3) {\n            state = \"ok\";\n          }\n\n          return 0;\n        }\n      });\n      client.on(\"ready\", function () {\n        client.disconnect();\n        done();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should allow updating startupNodes","suites":["cluster","startupNodes"],"updatePoint":{"line":83,"column":42,"index":2486},"line":83,"code":"    it(\"should allow updating startupNodes\", function (done) {\n      new MockServer(30001, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return [[0, 16383, [\"127.0.0.1\", 30001]]];\n        }\n\n        if (argv[0] === \"cluster\" && argv[1] === \"info\") {\n          return \"cluster_state:fail\";\n        }\n      });\n      const client = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        clusterRetryStrategy: function () {\n          this.startupNodes = [{\n            port: 30002\n          }];\n          return 0;\n        }\n      });\n      let hasDone = false;\n      new MockServer(30002, function () {\n        if (hasDone) {\n          return;\n        }\n\n        hasDone = true;\n        client.disconnect();\n        done();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should only send reads to master","suites":["cluster","scaleReads","master"],"updatePoint":{"line":132,"column":42,"index":3964},"line":132,"code":"      it(\"should only send reads to master\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }]);\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should only send reads to slave","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":149,"column":41,"index":4503},"line":149,"code":"      it(\"should only send reads to slave\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(1);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send writes to masters","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":170,"column":39,"index":5222},"line":170,"code":"      it(\"should send writes to masters\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.set(\"foo\", \"bar\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send custom readOnly scripts to a slave","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":187,"column":56,"index":5783},"line":187,"code":"      it(\"should send custom readOnly scripts to a slave\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", function () {\n          const redis = cluster;\n          redis.defineCommand(\"test\", {\n            numberOfKeys: 1,\n            lua: \"return {KEYS[1],ARGV[1],ARGV[2]}\",\n            readOnly: true\n          });\n          const stub = sinon.stub(utils, \"sample\").returns(\"127.0.0.1:30003\");\n          redis.test(\"k1\", \"a1\", \"a2\", function (err, result) {\n            stub.restore();\n            expect(stub.callCount).to.eql(1); // because of the beforeEach handler this will be the port of the slave called\n\n            expect(result).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send to selected slave","suites":["cluster","scaleReads","custom"],"updatePoint":{"line":214,"column":39,"index":6702},"line":214,"code":"      it(\"should send to selected slave\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: function (node, command) {\n            if (command.name === \"get\") {\n              return node[1];\n            }\n\n            return node[2];\n          }\n        });\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(1);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.hgetall(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30004);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send writes to masters","suites":["cluster","scaleReads","custom"],"updatePoint":{"line":241,"column":39,"index":7571},"line":241,"code":"      it(\"should send writes to masters\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: function (node, command) {\n            if (command.name === \"get\") {\n              return node[1];\n            }\n\n            return node[2];\n          }\n        });\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.set(\"foo\", \"bar\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send reads to all nodes randomly","suites":["cluster","scaleReads","all"],"updatePoint":{"line":266,"column":49,"index":8312},"line":266,"code":"      it(\"should send reads to all nodes randomly\", function (done) {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"all\"\n        });\n        cluster.on(\"ready\", function () {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(undefined);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should return the corrent nodes","suites":["cluster","#nodes()"],"updatePoint":{"line":290,"column":39,"index":9088},"line":290,"code":"    it(\"should return the corrent nodes\", function (done) {\n      const slotTable = [[0, 16381, [\"127.0.0.1\", 30001], [\"127.0.0.1\", 30003]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n      const node = new MockServer(30001, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30002, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30003, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]); // Make sure 30001 has been connected\n\n      cluster.get(\"foo\", function () {\n        expect(cluster.nodes()).to.have.lengthOf(3);\n        expect(cluster.nodes(\"all\")).to.have.lengthOf(3);\n        expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n        expect(cluster.nodes(\"slave\")).to.have.lengthOf(1);\n        cluster.once(\"-node\", function () {\n          expect(cluster.nodes()).to.have.lengthOf(2);\n          expect(cluster.nodes(\"all\")).to.have.lengthOf(2);\n          expect(cluster.nodes(\"master\")).to.have.lengthOf(1);\n          expect(cluster.nodes(\"slave\")).to.have.lengthOf(1);\n          cluster.disconnect();\n          done();\n        });\n        node.disconnect();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should refresh master nodes","suites":["cluster","#getInfoFromNode"],"updatePoint":{"line":330,"column":35,"index":10588},"line":330,"code":"    it(\"should refresh master nodes\", function (done) {\n      let slotTable = [[0, 5460, [\"127.0.0.1\", 30001], [\"127.0.0.1\", 30003]], [5461, 10922, [\"127.0.0.1\", 30002]]];\n      new MockServer(30001, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30002, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30003, function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      });\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        redisOptions: {\n          showFriendlyErrorStack: true\n        }\n      });\n      cluster.on(\"ready\", function () {\n        expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n        slotTable = [[0, 5460, [\"127.0.0.1\", 30003]], [5461, 10922, [\"127.0.0.1\", 30002]]];\n        cluster.refreshSlotsCache(function () {\n          cluster.once(\"-node\", function (removed) {\n            expect(removed.options.port).to.eql(30001);\n            expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n            expect([cluster.nodes(\"master\")[0].options.port, cluster.nodes(\"master\")[1].options.port].sort()).to.eql([30002, 30003]);\n            cluster.nodes(\"master\").forEach(function (node) {\n              expect(node.options).to.have.property(\"readOnly\", false);\n            });\n            cluster.disconnect();\n            done();\n          });\n        });\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should quit the connection gracefully","suites":["cluster","#quit()"],"updatePoint":{"line":374,"column":45,"index":12252},"line":374,"code":"    it(\"should quit the connection gracefully\", function (done) {\n      const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002], [\"127.0.0.1\", 30003]]];\n\n      const argvHandler = function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n      };\n\n      new MockServer(30001, argvHandler);\n      new MockServer(30002, argvHandler);\n      new MockServer(30003, argvHandler);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]);\n      let setCommandHandled = false;\n      cluster.on(\"ready\", function () {\n        cluster.set(\"foo\", \"bar\", function () {\n          setCommandHandled = true;\n        });\n        cluster.quit(function (err, state) {\n          expect(setCommandHandled).to.eql(true);\n          expect(state).to.eql(\"OK\");\n          cluster.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should return error when reached max redirection","suites":["cluster:maxRedirections"],"updatePoint":{"line":6,"column":54,"index":279},"line":6,"code":"  it(\"should return error when reached max redirection\", function (done) {\n    let redirectTimes = 0;\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        redirectTimes += 1;\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      maxRedirections: 5\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(redirectTimes).to.eql(6);\n      expect(err.message).to.match(/Too many Cluster redirections/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/maxRedirections.ts","skipped":false,"dir":"test"},{"name":"should auto redirect the command to the correct nodes","suites":["cluster:MOVED"],"updatePoint":{"line":7,"column":59,"index":306},"line":7,"code":"  it(\"should auto redirect the command to the correct nodes\", function (done) {\n    let cluster = undefined;\n    let moved = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          expect(moved).to.eql(true);\n          process.nextTick(function () {\n            cluster.disconnect();\n            done();\n          });\n        }\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(moved).to.eql(false);\n        moved = true;\n        slotTable[0][1] = 16381;\n        slotTable[1][0] = 16382;\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", function () {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should be able to redirect a command to a unknown node","suites":["cluster:MOVED"],"updatePoint":{"line":48,"column":60,"index":1507},"line":48,"code":"  it(\"should be able to redirect a command to a unknown node\", function (done) {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30002\");\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16381, [\"127.0.0.1\", 30001]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnFailover: 1\n    });\n    cluster.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should auto redirect the command within a pipeline","suites":["cluster:MOVED"],"updatePoint":{"line":79,"column":56,"index":2446},"line":79,"code":"  it(\"should auto redirect the command within a pipeline\", function (done) {\n    let cluster = undefined;\n    let moved = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          expect(moved).to.eql(true);\n          process.nextTick(function () {\n            cluster.disconnect();\n            done();\n          });\n        }\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(moved).to.eql(false);\n        moved = true;\n        slotTable[0][1] = 16381;\n        slotTable[1][0] = 16382;\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\", function () {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should supports retryDelayOnMoved","suites":["cluster:MOVED"],"updatePoint":{"line":122,"column":39,"index":3660},"line":122,"code":"  it(\"should supports retryDelayOnMoved\", done => {\n    let cluster = undefined;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30002\");\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    });\n    const retryDelayOnMoved = 789;\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnMoved\n    });\n    cluster.on(\"ready\", function () {\n      sinon.stub(global, \"setTimeout\").callsFake((body, ms) => {\n        if (ms === retryDelayOnMoved) {\n          process.nextTick(() => {\n            body();\n          });\n        }\n      });\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"works for normal case","suites":["NAT"],"updatePoint":{"line":7,"column":27,"index":258},"line":7,"code":"  it(\"works for normal case\", done => {\n    const slotTable = [[0, 1, [\"192.168.1.1\", 30001]], [2, 16383, [\"192.168.1.2\", 30001]]];\n    let cluster;\n    new MockServer(30001, null, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works if natMap does not match all the cases","suites":["NAT"],"updatePoint":{"line":34,"column":50,"index":972},"line":34,"code":"  it(\"works if natMap does not match all the cases\", done => {\n    const slotTable = [[0, 1, [\"192.168.1.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    let cluster;\n    new MockServer(30001, null, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works for moved","suites":["NAT"],"updatePoint":{"line":57,"column":21,"index":1562},"line":57,"code":"  it(\"works for moved\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    let cluster;\n    new MockServer(30001, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 192.168.1.2:30001\");\n      }\n    }, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works for ask","suites":["NAT"],"updatePoint":{"line":88,"column":19,"index":2374},"line":88,"code":"  it(\"works for ask\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    let cluster;\n    let asked = false;\n    new MockServer(30001, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 192.168.1.2:30001\");\n      }\n    }, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"asking\") {\n        asked = true;\n      }\n\n      if (command === \"get\" && arg === \"foo\") {\n        if (!asked) {\n          throw new Error(\"expected asked to be true\");\n        }\n\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"keeps options immutable","suites":["NAT"],"updatePoint":{"line":128,"column":29,"index":3371},"line":128,"code":"  it(\"keeps options immutable\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    new MockServer(30001, null, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], Object.freeze({\n      natMap: Object.freeze({\n        \"192.168.1.1:30001\": Object.freeze({\n          host: \"127.0.0.1\",\n          port: 30001\n        })\n      })\n    }));\n    const reset = sinon.spy(cluster.connectionPool, \"reset\");\n    cluster.on(\"ready\", () => {\n      expect(reset.secondCall.args[0]).to.deep.equal([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"should throw when not all keys in a pipeline command belong to the same slot","suites":["cluster:pipeline"],"updatePoint":{"line":7,"column":82,"index":332},"line":7,"code":"  it(\"should throw when not all keys in a pipeline command belong to the same slot\", function (done) {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().set(\"foo\", \"bar\").mget(\"foo1\", \"foo2\").exec().catch(function (err) {\n      expect(err.message).to.match(/All the keys in a pipeline command should belong to the same slot/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should throw when not all keys in different pipeline commands belong to the same allocation group","suites":["cluster:pipeline"],"updatePoint":{"line":29,"column":103,"index":1182},"line":29,"code":"  it(\"should throw when not all keys in different pipeline commands belong to the same allocation group\", function (done) {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().set(\"foo1\", \"bar\").get(\"foo2\").exec().catch(function (err) {\n      expect(err.message).to.match(/All keys in the pipeline should belong to the same slots allocation group/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should auto redirect commands on MOVED","suites":["cluster:pipeline"],"updatePoint":{"line":51,"column":44,"index":1973},"line":51,"code":"  it(\"should auto redirect commands on MOVED\", function (done) {\n    let moved = false;\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[1] === \"foo\") {\n        if (argv[0] === \"set\") {\n          expect(moved).to.eql(false);\n          moved = true;\n        }\n\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should auto redirect commands on ASK","suites":["cluster:pipeline"],"updatePoint":{"line":89,"column":42,"index":3105},"line":89,"code":"  it(\"should auto redirect commands on ASK\", function (done) {\n    let asked = false;\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"asking\") {\n        asked = true;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n        return \"bar\";\n      }\n\n      if (argv[0] !== \"asking\") {\n        asked = false;\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[1] === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should retry the command on TRYAGAIN","suites":["cluster:pipeline"],"updatePoint":{"line":131,"column":42,"index":4295},"line":131,"code":"  it(\"should retry the command on TRYAGAIN\", function (done) {\n    let times = 0;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[1] === \"foo\") {\n        if (times++ < 2) {\n          return new Error(\"TRYAGAIN Multiple keys request during rehashing of slot\");\n        }\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnTryAgain: 1\n    });\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(result[0][1]).to.eql(\"OK\");\n      expect(result[1][1]).to.eql(\"OK\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should not redirect commands on a non-readonly command is successful","suites":["cluster:pipeline"],"updatePoint":{"line":158,"column":74,"index":5123},"line":158,"code":"  it(\"should not redirect commands on a non-readonly command is successful\", function (done) {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0][0].message).to.match(/MOVED/);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should retry when redis is down","suites":["cluster:pipeline"],"updatePoint":{"line":190,"column":37,"index":6148},"line":190,"code":"  it(\"should retry when redis is down\", function (done) {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    });\n    const node2 = new MockServer(30002, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnFailover: 1\n    });\n    const stub = sinon.stub(cluster, \"refreshSlotsCache\").callsFake((...args) => {\n      node2.connect();\n      stub.restore();\n      cluster.refreshSlotsCache(...args);\n    });\n    node2.disconnect();\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should receive messages","suites":["cluster:pub/sub"],"updatePoint":{"line":8,"column":29,"index":333},"line":8,"code":"  it(\"should receive messages\", function (done) {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    };\n\n    const node1 = new MockServer(30001, handler);\n    new MockServer(30002, handler);\n    const options = [{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }];\n    const sub = new Cluster(options);\n    sub.subscribe(\"test cluster\", function () {\n      node1.write(node1.findClientByName(\"ioredis-cluster(subscriber)\"), [\"message\", \"test channel\", \"hi\"]);\n    });\n    sub.on(\"message\", function (channel, message) {\n      expect(channel).to.eql(\"test channel\");\n      expect(message).to.eql(\"hi\");\n      sub.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should works when sending regular commands","suites":["cluster:pub/sub"],"updatePoint":{"line":32,"column":48,"index":1146},"line":32,"code":"  it(\"should works when sending regular commands\", function (done) {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n\n    new MockServer(30001, handler);\n    const sub = new Cluster([{\n      port: \"30001\"\n    }]);\n    sub.subscribe(\"test cluster\", function () {\n      sub.set(\"foo\", \"bar\").then(res => {\n        expect(res).to.eql(\"OK\");\n        done();\n      });\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"supports password","suites":["cluster:pub/sub"],"updatePoint":{"line":50,"column":23,"index":1613},"line":50,"code":"  it(\"supports password\", function (done) {\n    const handler = function (argv, c) {\n      if (argv[0] === \"auth\") {\n        c.password = argv[1];\n        return;\n      }\n\n      if (argv[0] === \"subscribe\") {\n        expect(c.password).to.eql(\"abc\");\n        expect(getConnectionName(c)).to.eql(\"ioredis-cluster(subscriber)\");\n      }\n\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n\n    new MockServer(30001, handler);\n    const sub = new Cluster([{\n      port: \"30001\",\n      password: \"abc\"\n    }]);\n    sub.subscribe(\"test cluster\", function () {\n      done();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should re-subscribe after reconnection","suites":["cluster:pub/sub"],"updatePoint":{"line":76,"column":44,"index":2290},"line":76,"code":"  it(\"should re-subscribe after reconnection\", function (done) {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      } else if (argv[0] === \"subscribe\" || argv[0] === \"psubscribe\") {\n        return [argv[0], argv[1]];\n      }\n    });\n    const client = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    client.subscribe(\"test cluster\", function () {\n      const stub = sinon.stub(Redis.prototype, \"subscribe\").callsFake(channels => {\n        expect(channels).to.eql([\"test cluster\"]);\n        stub.restore();\n        client.disconnect();\n        done();\n        return Redis.prototype.subscribe.apply(this, arguments);\n      });\n      client.once(\"end\", function () {\n        client.connect().catch(noop);\n      });\n      client.disconnect();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should re-psubscribe after reconnection","suites":["cluster:pub/sub"],"updatePoint":{"line":102,"column":45,"index":3178},"line":102,"code":"  it(\"should re-psubscribe after reconnection\", function (done) {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      } else if (argv[0] === \"subscribe\" || argv[0] === \"psubscribe\") {\n        return [argv[0], argv[1]];\n      }\n    });\n    const client = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    client.psubscribe(\"test?\", function () {\n      const stub = sinon.stub(Redis.prototype, \"psubscribe\").callsFake(channels => {\n        expect(channels).to.eql([\"test?\"]);\n        stub.restore();\n        client.disconnect();\n        done();\n        return Redis.prototype.psubscribe.apply(this, arguments);\n      });\n      client.once(\"end\", function () {\n        client.connect().catch(noop);\n      });\n      client.disconnect();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"quit successfully when server is disconnecting","suites":["cluster:quit"],"updatePoint":{"line":5,"column":52,"index":209},"line":5,"code":"  it(\"quit successfully when server is disconnecting\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    const server = new MockServer(30001, (argv, c) => {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    new MockServer(30002, (argv, c) => {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.on(\"ready\", () => {\n      server.disconnect();\n      cluster.quit((err, res) => {\n        expect(err).to.eql(null);\n        expect(res).to.eql(\"OK\");\n        cluster.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/quit.ts","skipped":false,"dir":"test"},{"name":"failed when quit returns error","suites":["cluster:quit"],"updatePoint":{"line":31,"column":36,"index":930},"line":31,"code":"  it(\"failed when quit returns error\", function (done) {\n    const ERROR_MESSAGE = \"quit random error\";\n    const slotTable = [[0, 16381, [\"127.0.0.1\", 30001]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv, c) {\n      if (argv[0] === \"quit\") {\n        return new Error(ERROR_MESSAGE);\n      }\n    }, slotTable);\n    new MockServer(30002, function (argv, c) {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", () => {\n      cluster.quit(err => {\n        expect(err.message).to.eql(ERROR_MESSAGE);\n        cluster.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/quit.ts","skipped":false,"dir":"test"},{"name":"support customize resolveSrv function","suites":["cluster:resolveSrv"],"updatePoint":{"line":5,"column":43,"index":206},"line":5,"code":"  it(\"support customize resolveSrv function\", done => {\n    let resolveSrvCalledCount = 0;\n    new MockServer(30001, (argv, c) => {}, [[0, 1000, [\"127.0.0.1\", 30001]]]);\n    const cluster = new Cluster([{\n      host: \"a.com\"\n    }], {\n      useSRVRecords: true,\n\n      resolveSrv(hostname, callback) {\n        resolveSrvCalledCount++;\n\n        if (hostname === \"a.com\") {\n          callback(null, [{\n            priority: 1,\n            weight: 1,\n            port: 30001,\n            name: \"127.0.0.1\"\n          }]);\n        } else {\n          callback(new Error(\"Unknown hostname\"));\n        }\n      }\n\n    });\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(1);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(resolveSrvCalledCount).to.eql(1);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/resolveSrv.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["cluster:tls option"],"updatePoint":{"line":8,"column":18,"index":269},"line":8,"code":"  it(\"supports tls\", done => {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n    };\n\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    new MockServer(30003, argvHandler); // @ts-ignore\n\n    const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n      // @ts-ignore\n      expect(op.ca).to.eql(\"123\"); // @ts-ignore\n\n      expect(op.port).to.be.oneOf([30001, 30003, 30003]);\n      const stream = net.createConnection(op);\n      stream.on(\"connect\", data => {\n        stream.emit(\"secureConnect\", data);\n      });\n      return stream;\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30003\"\n    }], {\n      redisOptions: {\n        tls: {\n          ca: \"123\"\n        }\n      }\n    });\n    cluster.on(\"ready\", () => {\n      expect(cluster.subscriber.subscriber.options.tls).to.deep.equal({\n        ca: \"123\"\n      });\n      cluster.disconnect();\n      stub.restore();\n      cluster.on(\"end\", () => done());\n    });\n  });","file":"functional/cluster/tls.ts","skipped":false,"dir":"test"},{"name":"should retry the command","suites":["cluster:TRYAGAIN"],"updatePoint":{"line":4,"column":30,"index":166},"line":4,"code":"  it(\"should retry the command\", function (done) {\n    let cluster;\n    let times = 0;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n        return slotTable;\n      }\n\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          process.nextTick(function () {\n            cluster.disconnect();\n            done();\n          });\n        } else {\n          return new Error(\"TRYAGAIN Multiple keys request during rehashing of slot\");\n        }\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnTryAgain: 1\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/tryagain.ts","skipped":false,"dir":"test"},{"name":"rejects if command timed out","suites":["commandTimeout"],"updatePoint":{"line":6,"column":34,"index":225},"line":6,"code":"  it(\"rejects if command timed out\", function (done) {\n    const server = new MockServer(30001, function (argv, socket, flags) {\n      if (argv[0] === \"hget\") {\n        flags.hang = true;\n        return;\n      }\n    });\n    const redis = new Redis({\n      port: 30001,\n      commandTimeout: 1000\n    });\n    const clock = sinon.useFakeTimers();\n    redis.hget(\"foo\", err => {\n      expect(err.message).to.eql(\"Command timed out\");\n      clock.restore();\n      redis.disconnect();\n      server.disconnect(() => done());\n    });\n    clock.tick(1000);\n  });","file":"functional/commandTimeout.ts","skipped":false,"dir":"test"},{"name":"does not leak timers for commands in offline queue","suites":["commandTimeout"],"updatePoint":{"line":26,"column":56,"index":802},"line":26,"code":"  it(\"does not leak timers for commands in offline queue\", async function () {\n    const server = new MockServer(30001);\n    const redis = new Redis({\n      port: 30001,\n      commandTimeout: 1000\n    });\n    const clock = sinon.useFakeTimers();\n    await redis.hget(\"foo\");\n    expect(clock.countTimers()).to.eql(0);\n    clock.restore();\n    redis.disconnect();\n    await server.disconnectPromise();\n  });","file":"functional/commandTimeout.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on disconnect","suites":["disconnection"],"updatePoint":{"line":9,"column":43,"index":280},"line":9,"code":"  it(\"should clear all timers on disconnect\", function (done) {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const redis = new Redis({});\n    redis.on(\"connect\", function () {\n      redis.disconnect();\n    });\n    redis.on(\"end\", function () {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      server.disconnect();\n      done();\n    });\n  });","file":"functional/disconnection.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on server exits","suites":["disconnection"],"updatePoint":{"line":23,"column":45,"index":793},"line":23,"code":"  it(\"should clear all timers on server exits\", function (done) {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const redis = new Redis({\n      port: 30000,\n      retryStrategy: null\n    });\n    redis.on(\"end\", function () {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      done();\n    });\n    server.disconnect();\n  });","file":"functional/disconnection.ts","skipped":false,"dir":"test"},{"name":"should be disabled by default","suites":["dropBufferSupport"],"updatePoint":{"line":4,"column":35,"index":148},"line":4,"code":"  it(\"should be disabled by default\", function () {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    expect(redis.options).to.have.property(\"dropBufferSupport\", false);\n  });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should return strings correctly","suites":["dropBufferSupport"],"updatePoint":{"line":10,"column":37,"index":342},"line":10,"code":"  it(\"should return strings correctly\", function (done) {\n    const redis = new Redis({\n      dropBufferSupport: false\n    });\n    redis.set(\"foo\", Buffer.from(\"bar\"), function (err, res) {\n      expect(err).to.eql(null);\n      expect(res).to.eql(\"OK\");\n      redis.get(\"foo\", function (err, res) {\n        expect(err).to.eql(null);\n        expect(res).to.eql(\"bar\");\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should reject the buffer commands","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":26,"column":41,"index":817},"line":26,"code":"    it(\"should reject the buffer commands\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.getBuffer(\"foo\", function (err) {\n        expect(err.message).to.match(/Buffer methods are not available/);\n        redis.callBuffer(\"get\", \"foo\", function (err) {\n          expect(err.message).to.match(/Buffer methods are not available/);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should reject the custom buffer commands","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":39,"column":48,"index":1290},"line":39,"code":"    it(\"should reject the custom buffer commands\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.defineCommand(\"geteval\", {\n        numberOfKeys: 0,\n        lua: 'return \"string\"'\n      });\n      redis.getevalBuffer(function (err) {\n        expect(err.message).to.match(/Buffer methods are not available/);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should return strings correctly","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":53,"column":39,"index":1708},"line":53,"code":"    it(\"should return strings correctly\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.set(\"foo\", Buffer.from(\"bar\"), function (err, res) {\n        expect(err).to.eql(null);\n        expect(res).to.eql(\"OK\");\n        redis.get(\"foo\", function (err, res) {\n          expect(err).to.eql(null);\n          expect(res).to.eql(\"bar\");\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should return strings for custom commands","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":68,"column":49,"index":2183},"line":68,"code":"    it(\"should return strings for custom commands\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.defineCommand(\"geteval\", {\n        numberOfKeys: 0,\n        lua: 'return \"string\"'\n      });\n      redis.geteval(function (err, res) {\n        expect(err).to.eql(null);\n        expect(res).to.eql(\"string\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should work with pipeline","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":83,"column":33,"index":2592},"line":83,"code":"    it(\"should work with pipeline\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      const pipeline = redis.pipeline();\n      pipeline.set(\"foo\", \"bar\");\n      pipeline.get(Buffer.from(\"foo\"));\n      pipeline.exec(function (err, res) {\n        expect(err).to.eql(null);\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(\"bar\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should work with transaction","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":98,"column":36,"index":3057},"line":98,"code":"    it(\"should work with transaction\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.multi().set(\"foo\", \"bar\").get(\"foo\").exec(function (err, res) {\n        expect(err).to.eql(null);\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(\"bar\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should fail early with Buffer transaction","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":110,"column":49,"index":3454},"line":110,"code":"    it(\"should fail early with Buffer transaction\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true\n      });\n      redis.multi().set(\"foo\", \"bar\").getBuffer(Buffer.from(\"foo\"), function (err) {\n        expect(err.message).to.match(/Buffer methods are not available/);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"should work with internal select command","suites":["dropBufferSupport","enabled"],"updatePoint":{"line":120,"column":48,"index":3818},"line":120,"code":"    it(\"should work with internal select command\", function (done) {\n      const redis = new Redis({\n        dropBufferSupport: true,\n        db: 1\n      });\n      const check = new Redis({\n        db: 1\n      });\n      redis.set(\"foo\", \"bar\", function () {\n        check.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"bar\");\n          redis.disconnect();\n          check.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/drop_buffer_support.ts","skipped":false,"dir":"test"},{"name":"clone the options","suites":["duplicate"],"updatePoint":{"line":4,"column":23,"index":122},"line":4,"code":"  it(\"clone the options\", () => {\n    const redis = new Redis();\n    const duplicatedRedis = redis.duplicate();\n    redis.options.port = 1234;\n    expect(duplicatedRedis.options.port).to.eql(6379);\n  });","file":"functional/duplicate.ts","skipped":false,"dir":"test"},{"name":"should abort a failed transaction when connection is lost","suites":["elasticache"],"updatePoint":{"line":49,"column":63,"index":1340},"line":49,"code":"  it(\"should abort a failed transaction when connection is lost\", function (done) {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: true\n    });\n    redis.multi().del(\"foo\").del(\"bar\").exec(err => {\n      expectAbortError(err);\n      expect(err.command).to.eql({\n        name: \"exec\",\n        args: []\n      });\n      expect(err.previousErrors).to.have.lengthOf(2);\n      expectReplyError(err.previousErrors[0]);\n      expect(err.previousErrors[0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(err.previousErrors[1]);\n      expect(err.previousErrors[1].command).to.eql({\n        name: \"del\",\n        args: [\"bar\"]\n      }); // ensure we've recovered into a healthy state\n\n      redis.get(\"foo\", (err, res) => {\n        expect(res).to.eql(\"foo\");\n        done();\n      });\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should not resend failed transaction commands","suites":["elasticache"],"updatePoint":{"line":77,"column":51,"index":2183},"line":77,"code":"  it(\"should not resend failed transaction commands\", function (done) {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: 2\n    });\n    redis.multi().del(\"foo\").get(\"bar\").exec(err => {\n      expectAbortError(err);\n      expect(err.command).to.eql({\n        name: \"exec\",\n        args: []\n      });\n      expect(err.previousErrors).to.have.lengthOf(2);\n      expectAbortError(err.previousErrors[0]);\n      expect(err.previousErrors[0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(err.previousErrors[1]);\n      expect(err.previousErrors[1].command).to.eql({\n        name: \"get\",\n        args: [\"bar\"]\n      }); // ensure we've recovered into a healthy state\n\n      redis.get(\"foo\", (err, res) => {\n        expect(res).to.eql(\"foo\");\n        done();\n      });\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should resend intact pipelines","suites":["elasticache"],"updatePoint":{"line":105,"column":36,"index":3008},"line":105,"code":"  it(\"should resend intact pipelines\", function (done) {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: true\n    });\n    let p1Result;\n    redis.pipeline().del(\"foo\").get(\"bar\").exec((err, result) => p1Result = result);\n    redis.pipeline().get(\"baz\").get(\"qux\").exec((err, p2Result) => {\n      // First pipeline should have been aborted\n      expect(p1Result).to.have.lengthOf(2);\n      expect(p1Result[0]).to.have.lengthOf(1);\n      expect(p1Result[1]).to.have.lengthOf(1);\n      expectReplyError(p1Result[0][0]);\n      expect(p1Result[0][0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(p1Result[1][0]);\n      expect(p1Result[1][0].command).to.eql({\n        name: \"get\",\n        args: [\"bar\"]\n      }); // Second pipeline was intact and should have been retried successfully\n\n      expect(p2Result).to.have.lengthOf(2);\n      expect(p2Result[0]).to.eql([null, \"baz\"]);\n      expect(p2Result[1]).to.eql([null, \"qux\"]);\n      done();\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should be `Command`","suites":["exports",".Command"],"updatePoint":{"line":5,"column":27,"index":188},"line":5,"code":"    it(\"should be `Command`\", function () {\n      expect(Command).to.eql(require(\"../../lib/command\").default);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should be `Cluster`","suites":["exports",".Cluster"],"updatePoint":{"line":10,"column":27,"index":351},"line":10,"code":"    it(\"should be `Cluster`\", function () {\n      expect(Cluster).to.eql(require(\"../../lib/cluster\").default);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should be `ReplyError`","suites":["exports",".ReplyError"],"updatePoint":{"line":15,"column":30,"index":520},"line":15,"code":"    it(\"should be `ReplyError`\", function () {\n      expect(ReplyError).to.eql(require(\"redis-errors\").ReplyError);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should handle fatal error of parser","suites":["fatal_error"],"updatePoint":{"line":5,"column":41,"index":197},"line":5,"code":"  it(\"should handle fatal error of parser\", function (done) {\n    let recovered = false;\n    new MockServer(30000, argv => {\n      if (recovered) {\n        return;\n      }\n\n      if (argv[0] === \"get\") {\n        return MockServer.raw(\"&\");\n      }\n    });\n    const redis = new Redis(30000);\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/Protocol error/);\n      recovered = true;\n      redis.get(\"bar\", function (err) {\n        expect(err).to.eql(null);\n        done();\n      });\n    });\n  });","file":"functional/fatal_error.ts","skipped":false,"dir":"test"},{"name":"should not call `connect` when init","suites":["lazy connect"],"updatePoint":{"line":7,"column":41,"index":261},"line":7,"code":"  it(\"should not call `connect` when init\", function () {\n    // TODO: use spy\n    const stub = sinon.stub(Redis.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n    new Redis({\n      lazyConnect: true\n    });\n    stub.restore();\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should connect when calling a command","suites":["lazy connect"],"updatePoint":{"line":15,"column":43,"index":525},"line":15,"code":"  it(\"should connect when calling a command\", function (done) {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect when disconnected manually","suites":["lazy connect"],"updatePoint":{"line":25,"column":60,"index":807},"line":25,"code":"  it(\"should not try to reconnect when disconnected manually\", function (done) {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.get(\"foo\", function () {\n      redis.disconnect();\n      redis.get(\"foo\", function (err) {\n        expect(err.message).to.match(/Connection is closed/);\n        done();\n      });\n    });\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should be able to disconnect","suites":["lazy connect"],"updatePoint":{"line":37,"column":34,"index":1127},"line":37,"code":"  it(\"should be able to disconnect\", function (done) {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.on(\"end\", function () {\n      done();\n    });\n    redis.disconnect();\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should not call `connect` when init","suites":["lazy connect","Cluster"],"updatePoint":{"line":47,"column":43,"index":1375},"line":47,"code":"    it(\"should not call `connect` when init\", function () {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      new Cluster([], {\n        lazyConnect: true\n      });\n      stub.restore();\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should call connect when pipeline exec","suites":["lazy connect","Cluster"],"updatePoint":{"line":54,"column":46,"index":1641},"line":54,"code":"    it(\"should call connect when pipeline exec\", done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      const pipline = new Pipeline(cluster);\n      pipline.get(\"fool1\").exec(() => {});\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should call connect when transction exec","suites":["lazy connect","Cluster"],"updatePoint":{"line":65,"column":48,"index":2002},"line":65,"code":"    it(\"should call connect when transction exec\", done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.multi().get(\"fool1\").exec(() => {});\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should quit before \"close\" being emited","suites":["lazy connect","Cluster"],"updatePoint":{"line":75,"column":47,"index":2325},"line":75,"code":"    it('should quit before \"close\" being emited', function (done) {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.quit(function () {\n        cluster.once(\"close\", function () {\n          cluster.once(\"end\", function () {\n            stub.restore();\n            done();\n          });\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should disconnect before \"close\" being emited","suites":["lazy connect","Cluster"],"updatePoint":{"line":89,"column":53,"index":2801},"line":89,"code":"    it('should disconnect before \"close\" being emited', function (done) {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.disconnect();\n      cluster.once(\"close\", function () {\n        cluster.once(\"end\", function () {\n          stub.restore();\n          done();\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should support disconnecting with reconnect","suites":["lazy connect","Cluster"],"updatePoint":{"line":102,"column":51,"index":3248},"line":102,"code":"    it(\"should support disconnecting with reconnect\", function (done) {\n      let stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true,\n        clusterRetryStrategy: function () {\n          return 1;\n        }\n      });\n      cluster.disconnect(true);\n      cluster.once(\"close\", function () {\n        stub.restore();\n        stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n          stub.restore();\n          done();\n          return Promise.resolve();\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"throw the correct error when reached the limit","suites":["maxRetriesPerRequest"],"updatePoint":{"line":5,"column":52,"index":230},"line":5,"code":"  it(\"throw the correct error when reached the limit\", function (done) {\n    const redis = new Redis(9999, {\n      connectTimeout: 1,\n\n      retryStrategy() {\n        return 1;\n      }\n\n    });\n    redis.get(\"foo\", err => {\n      expect(err).instanceOf(MaxRetriesPerRequestError);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"defaults to max 20 retries","suites":["maxRetriesPerRequest"],"updatePoint":{"line":20,"column":32,"index":545},"line":20,"code":"  it(\"defaults to max 20 retries\", function (done) {\n    const redis = new Redis(9999, {\n      connectTimeout: 1,\n\n      retryStrategy() {\n        return 1;\n      }\n\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(21);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(42);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"can be changed","suites":["maxRetriesPerRequest"],"updatePoint":{"line":38,"column":20,"index":929},"line":38,"code":"  it(\"can be changed\", function (done) {\n    const redis = new Redis(9999, {\n      maxRetriesPerRequest: 1,\n\n      retryStrategy() {\n        return 1;\n      }\n\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(2);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(4);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"allows 0","suites":["maxRetriesPerRequest"],"updatePoint":{"line":56,"column":14,"index":1311},"line":56,"code":"  it(\"allows 0\", function (done) {\n    const redis = new Redis(9999, {\n      maxRetriesPerRequest: 0,\n\n      retryStrategy() {\n        return 1;\n      }\n\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(1);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(2);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"should receive commands","suites":["monitor"],"updatePoint":{"line":5,"column":29,"index":164},"line":5,"code":"  it(\"should receive commands\", function (done) {\n    const redis = new Redis();\n    redis.on(\"ready\", function () {\n      redis.monitor(function (err, monitor) {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        monitor.on(\"monitor\", function (time, args) {\n          expect(args[0]).to.eql(\"get\");\n          expect(args[1]).to.eql(\"foo\");\n          redis.disconnect();\n          monitor.disconnect();\n          done();\n        });\n        redis.get(\"foo\");\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should reject processing commands","suites":["monitor"],"updatePoint":{"line":25,"column":39,"index":684},"line":25,"code":"  it(\"should reject processing commands\", function (done) {\n    const redis = new Redis();\n    redis.monitor(function (err, monitor) {\n      monitor.get(\"foo\", function (err) {\n        expect(err.message).to.match(/Connection is in monitoring mode/);\n        redis.disconnect();\n        monitor.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should continue monitoring after reconnection","suites":["monitor"],"updatePoint":{"line":36,"column":51,"index":1045},"line":36,"code":"  it(\"should continue monitoring after reconnection\", function (done) {\n    const redis = new Redis();\n    redis.monitor(function (err, monitor) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      monitor.on(\"monitor\", function (time, args) {\n        if (args[0] === \"set\") {\n          redis.disconnect();\n          monitor.disconnect();\n          done();\n        }\n      });\n      monitor.disconnect(true);\n      monitor.on(\"ready\", function () {\n        redis.set(\"foo\", \"bar\");\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should wait for the ready event before monitoring","suites":["monitor"],"updatePoint":{"line":57,"column":55,"index":1571},"line":57,"code":"  it(\"should wait for the ready event before monitoring\", function (done) {\n    const redis = new Redis();\n    redis.on(\"ready\", function () {\n      const readyCheck = sinon.spy(Redis.prototype, \"_readyCheck\");\n      redis.monitor(function (err, monitor) {\n        expect(readyCheck.callCount).to.eql(1);\n\n        Redis.prototype._readyCheck.restore();\n\n        redis.disconnect();\n        monitor.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should return correct result","suites":["pipeline"],"updatePoint":{"line":5,"column":34,"index":170},"line":5,"code":"  it(\"should return correct result\", function (done) {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\", \"1\").get(\"foo\").set(\"foo\", \"2\").incr(\"foo\").get(\"foo\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"1\"], [null, \"OK\"], [null, 3], [null, \"3\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should return an empty array on empty pipeline","suites":["pipeline"],"updatePoint":{"line":14,"column":52,"index":575},"line":14,"code":"  it(\"should return an empty array on empty pipeline\", function (done) {\n    const redis = new Redis();\n    redis.pipeline().exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support mix string command and buffer command","suites":["pipeline"],"updatePoint":{"line":23,"column":58,"index":857},"line":23,"code":"  it(\"should support mix string command and buffer command\", function (done) {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\", \"bar\").set(\"foo\", Buffer.from(\"bar\")).getBuffer(\"foo\").get(Buffer.from(\"foo\")).exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"OK\"], [null, Buffer.from(\"bar\")], [null, \"bar\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should handle error correctly","suites":["pipeline"],"updatePoint":{"line":32,"column":35,"index":1275},"line":32,"code":"  it(\"should handle error correctly\", function (done) {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results.length).to.eql(1);\n      expect(results[0].length).to.eql(1);\n      expect(results[0][0].toString()).to.match(/wrong number of arguments/);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should also invoke the command's callback","suites":["pipeline"],"updatePoint":{"line":43,"column":47,"index":1684},"line":43,"code":"  it(\"should also invoke the command's callback\", function (done) {\n    const redis = new Redis();\n    let pending = 1;\n    redis.pipeline().set(\"foo\", \"bar\").get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      pending -= 1;\n    }).exec(function (err, results) {\n      expect(pending).to.eql(0);\n      expect(results[1][1]).to.eql(\"bar\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support inline transaction","suites":["pipeline"],"updatePoint":{"line":56,"column":39,"index":2095},"line":56,"code":"  it(\"should support inline transaction\", function (done) {\n    const redis = new Redis();\n    redis.pipeline().multi().set(\"foo\", \"bar\").get(\"foo\").exec().exec(function (err, result) {\n      expect(result[0][1]).to.eql(\"OK\");\n      expect(result[1][1]).to.eql(\"QUEUED\");\n      expect(result[2][1]).to.eql(\"QUEUED\");\n      expect(result[3][1]).to.eql([\"OK\", \"bar\"]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should have the same options as its container","suites":["pipeline"],"updatePoint":{"line":67,"column":51,"index":2528},"line":67,"code":"  it(\"should have the same options as its container\", function () {\n    const redis = new Redis({\n      showFriendlyErrorStack: true\n    });\n    const pipeline = redis.pipeline();\n    expect(pipeline.options).to.have.property(\"showFriendlyErrorStack\", true);\n    redis.disconnect();\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["pipeline"],"updatePoint":{"line":75,"column":34,"index":2800},"line":75,"code":"  it(\"should support key prefixing\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.pipeline().set(\"bar\", \"baz\").get(\"bar\").lpush(\"app1\", \"test1\").lpop(\"app1\").keys(\"*\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"baz\"], [null, 1], [null, \"test1\"], [null, [\"foo:bar\"]]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should include added built in commands","suites":["pipeline"],"updatePoint":{"line":86,"column":44,"index":3250},"line":86,"code":"  it(\"should include added built in commands\", async () => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.addBuiltinCommand(\"someCommand\");\n    sinon.stub(redis, \"sendCommand\").callsFake(command => {\n      command.resolve(Buffer.from(\"OK\"));\n    });\n    const result = await redis.pipeline().someCommand().exec();\n    expect(result).to.eql([[null, \"OK\"]]);\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["pipeline","custom commands"],"updatePoint":{"line":109,"column":19,"index":3927},"line":109,"code":"    it(\"should work\", function (done) {\n      redis.pipeline().echo(\"foo\", \"bar\", \"123\", \"abc\").exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results).to.eql([[null, [\"foo\", \"bar\", \"123\", \"abc\"]]]);\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support callbacks","suites":["pipeline","custom commands"],"updatePoint":{"line":116,"column":32,"index":4207},"line":116,"code":"    it(\"should support callbacks\", function (done) {\n      let pending = 1;\n      redis.pipeline().echo(\"foo\", \"bar\", \"123\", \"abc\", function (err, result) {\n        pending -= 1;\n        expect(err).to.eql(null);\n        expect(result).to.eql([\"foo\", \"bar\", \"123\", \"abc\"]);\n      }).exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results).to.eql([[null, [\"foo\", \"bar\", \"123\", \"abc\"]]]);\n        expect(pending).to.eql(0);\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should be supported in transaction blocks","suites":["pipeline","custom commands"],"updatePoint":{"line":129,"column":49,"index":4713},"line":129,"code":"    it(\"should be supported in transaction blocks\", function (done) {\n      redis.pipeline().multi().set(\"foo\", \"asdf\").echo(\"bar\", \"baz\", \"123\", \"abc\").get(\"foo\").exec().exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results[4][1][1]).to.eql([\"bar\", \"baz\", \"123\", \"abc\"]);\n        expect(results[4][1][2]).to.eql(\"asdf\");\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should accept commands in constructor","suites":["pipeline","#addBatch"],"updatePoint":{"line":139,"column":45,"index":5143},"line":139,"code":"    it(\"should accept commands in constructor\", function (done) {\n      const redis = new Redis();\n      let pending = 1;\n      redis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\", function (err, result) {\n        expect(result).to.eql(\"bar\");\n        pending -= 1;\n      }]]).exec(function (err, results) {\n        expect(pending).to.eql(0);\n        expect(results[1][1]).to.eql(\"bar\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should group results","suites":["pipeline","exec"],"updatePoint":{"line":154,"column":28,"index":5616},"line":154,"code":"    it(\"should group results\", function (done) {\n      const redis = new Redis();\n      redis.multi({\n        pipeline: false\n      });\n      redis.set(\"foo\", \"bar\");\n      redis.get(\"foo\");\n      redis.exec().then(function () {\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should allow omitting callback","suites":["pipeline","exec"],"updatePoint":{"line":166,"column":38,"index":5917},"line":166,"code":"    it(\"should allow omitting callback\", function (done) {\n      const redis = new Redis();\n      redis.exec().catch(function (err) {\n        expect(err.message).to.eql(\"ERR EXEC without MULTI\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should batch all commands before ready event","suites":["pipeline","exec"],"updatePoint":{"line":174,"column":52,"index":6189},"line":174,"code":"    it(\"should batch all commands before ready event\", function (done) {\n      const redis = new Redis();\n      redis.on(\"connect\", function () {\n        redis.pipeline().info().config(\"get\", \"maxmemory\").exec(function (err, res) {\n          expect(err).to.eql(null);\n          expect(res).to.have.lengthOf(2);\n          expect(res[0][0]).to.eql(null);\n          expect(typeof res[0][1]).to.eql(\"string\");\n          expect(res[1][0]).to.eql(null);\n          expect(Array.isArray(res[1][1])).to.eql(true);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should check and load uniq scripts only","suites":["pipeline","exec"],"updatePoint":{"line":189,"column":47,"index":6767},"line":189,"code":"    it(\"should check and load uniq scripts only\", function (done) {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 2,\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n      redis.defineCommand(\"echo\", {\n        numberOfKeys: 1,\n        lua: \"return {KEYS[1],ARGV[1]}\"\n      });\n      redis.once(\"ready\", function () {\n        const expectedCommands = [[\"script\", \"exists\"], [\"script\", \"load\", \"return {KEYS[1],ARGV[1]}\"], [\"script\", \"load\", \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"], [\"evalsha\"], [\"evalsha\"], [\"evalsha\"], [\"evalsha\"], [\"evalsha\"], [\"evalsha\"]];\n        const expectedResults = [[null, [\"a\", \"1\"]], [null, [\"b\", \"2\"]], [null, [\"k1\", \"k2\", \"v1\", \"v2\"]], [null, [\"k3\", \"k4\", \"v3\", \"v4\"]], [null, [\"c\", \"3\"]], [null, [\"k5\", \"k6\", \"v5\", \"v6\"]]];\n        redis.monitor(function (err, monitor) {\n          monitor.on(\"monitor\", function (_, command) {\n            const expectedCommand = expectedCommands.shift();\n            expectedCommand.forEach((arg, i) => expect(arg).to.eql(command[i]));\n\n            if (!expectedCommands.length) {\n              monitor.disconnect();\n              redis.disconnect();\n              done();\n            }\n          });\n          const pipe = redis.pipeline();\n          pipe.echo(\"a\", \"1\").echo(\"b\", \"2\").test(\"k1\", \"k2\", \"v1\", \"v2\").test(\"k3\", \"k4\", \"v3\", \"v4\").echo(\"c\", \"3\").test(\"k5\", \"k6\", \"v5\", \"v6\").exec(function (err, results) {\n            expect(err).to.eql(null);\n            expect(results).to.eql(expectedResults);\n          });\n        });\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support parallel script execution","suites":["pipeline","exec"],"updatePoint":{"line":221,"column":48,"index":8356},"line":221,"code":"    it(\"should support parallel script execution\", function (done) {\n      const random = `${Math.random()}`;\n      const redis = new Redis();\n      redis.defineCommand(\"something\", {\n        numberOfKeys: 0,\n        lua: `return \"${random}\"`\n      });\n      Promise.all([redis.multi([[\"something\"]]).exec(), redis.multi([[\"something\"]]).exec()]).then(([[first], [second]]) => {\n        expect(first[0]).to.equal(null);\n        expect(first[1]).to.equal(random);\n        expect(second[0]).to.equal(null);\n        expect(second[1]).to.equal(random);\n        redis.disconnect();\n        done();\n      }).catch(done);\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should reload scripts on redis restart (reconnect)","suites":["pipeline","exec"],"updatePoint":{"line":237,"column":58,"index":8989},"line":237,"code":"    it(\"should reload scripts on redis restart (reconnect)\", async function () {\n      const redis = new Redis({\n        connectionName: \"load-script-on-reconnect\"\n      });\n      const redis2 = new Redis();\n      redis.defineCommand(\"exeecafterreconnect\", {\n        numberOfKeys: 0,\n        lua: `return \"OK\"`\n      });\n      const [[err, res]] = await redis.multi([[\"exeecafterreconnect\"]]).exec();\n      expect(err).to.equal(null);\n      expect(res).to.equal(\"OK\");\n      const client = await redis.client(\"list\").then(clients => {\n        const myInfo = clients.split(\"\\n\").find(client => client.includes(\"load-script-on-reconnect\"));\n        const match = / addr=([^ ]+)/.exec(myInfo);\n        if (match) return match[1];\n      });\n      await redis2.script(\"flush\");\n      await redis2.client(\"kill\", \"addr\", client); // Wait for reconnect, at the moment scripts are not loaded\n      // if the pipeline starts before ioredis reconnects\n\n      await redis.ping();\n      const [[err2, res2]] = await redis.multi([[\"exeecafterreconnect\"]]).exec();\n      expect(err2).to.equal(null);\n      expect(res2).to.equal(\"OK\");\n      redis.disconnect();\n      redis2.disconnect();\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"return the command count","suites":["pipeline","#length"],"updatePoint":{"line":267,"column":32,"index":10187},"line":267,"code":"    it(\"return the command count\", function () {\n      const redis = new Redis();\n      const pipeline1 = redis.pipeline().multi().set(\"foo\", \"bar\").get(\"foo\").exec();\n      expect(pipeline1.length).to.eql(4);\n      const pipeline2 = redis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]);\n      expect(pipeline2.length).to.eql(2);\n      redis.disconnect();\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"uses native promise by default","suites":["Promise"],"updatePoint":{"line":6,"column":36,"index":222},"line":6,"code":"  it(\"uses native promise by default\", function () {\n    const redis = new Redis();\n    expect(redis.get(\"foo\").constructor).to.eql(nativePromise);\n  });","file":"functional/promise.ts","skipped":false,"dir":"test"},{"name":"can switch to a custom Promise implementation","suites":["Promise"],"updatePoint":{"line":10,"column":51,"index":391},"line":10,"code":"  it(\"can switch to a custom Promise implementation\", function () {\n    const origin = Promise; // @ts-ignore\n\n    Redis.Promise = bluebirdPromise;\n    const redis = new Redis();\n    expect(redis.get(\"foo\").constructor).to.eql(bluebirdPromise); // @ts-ignore\n\n    Redis.Promise = origin;\n    expect(redis.get(\"foo\").constructor).to.eql(origin);\n  });","file":"functional/promise.ts","skipped":false,"dir":"test"},{"name":"should invoke the callback when subscribe successfully","suites":["pub/sub"],"updatePoint":{"line":4,"column":60,"index":163},"line":4,"code":"  it(\"should invoke the callback when subscribe successfully\", function (done) {\n    const redis = new Redis();\n    let pending = 1;\n    redis.subscribe(\"foo\", \"bar\", function (err, count) {\n      expect(count).to.eql(2);\n      pending -= 1;\n    });\n    redis.subscribe(\"foo\", \"zoo\", function (err, count) {\n      expect(count).to.eql(3);\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should reject when issue a command in the subscriber mode","suites":["pub/sub"],"updatePoint":{"line":18,"column":63,"index":592},"line":18,"code":"  it(\"should reject when issue a command in the subscriber mode\", function (done) {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", function () {\n      redis.set(\"foo\", \"bar\", function (err) {\n        expect(err instanceof Error);\n        expect(err.toString()).to.match(/subscriber mode/);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should exit subscriber mode using unsubscribe","suites":["pub/sub"],"updatePoint":{"line":29,"column":51,"index":949},"line":29,"code":"  it(\"should exit subscriber mode using unsubscribe\", function (done) {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", \"bar\", function () {\n      redis.unsubscribe(\"foo\", \"bar\", function (err, count) {\n        expect(count).to.eql(0);\n        redis.set(\"foo\", \"bar\", function (err) {\n          expect(err).to.eql(null);\n          redis.subscribe(\"zoo\", \"foo\", function () {\n            redis.unsubscribe(function (err, count) {\n              expect(count).to.eql(0);\n              redis.set(\"foo\", \"bar\", function (err) {\n                expect(err).to.eql(null);\n                redis.disconnect();\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should receive messages when subscribe a channel","suites":["pub/sub"],"updatePoint":{"line":50,"column":54,"index":1671},"line":50,"code":"  it(\"should receive messages when subscribe a channel\", function (done) {\n    const redis = new Redis();\n    const pub = new Redis();\n    let pending = 2;\n    redis.subscribe(\"foo\", function () {\n      pub.publish(\"foo\", \"bar\");\n    });\n    redis.on(\"message\", function (channel, message) {\n      expect(channel).to.eql(\"foo\");\n      expect(message).to.eql(\"bar\");\n\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n    redis.on(\"messageBuffer\", function (channel, message) {\n      expect(channel).to.be.instanceof(Buffer);\n      expect(channel.toString()).to.eql(\"foo\");\n      expect(message).to.be.instanceof(Buffer);\n      expect(message.toString()).to.eql(\"bar\");\n\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should receive messages when psubscribe a pattern","suites":["pub/sub"],"updatePoint":{"line":78,"column":55,"index":2468},"line":78,"code":"  it(\"should receive messages when psubscribe a pattern\", function (done) {\n    const redis = new Redis();\n    const pub = new Redis();\n    let pending = 2;\n    redis.psubscribe(\"f?oo\", function () {\n      pub.publish(\"fzoo\", \"bar\");\n    });\n    redis.on(\"pmessage\", function (pattern, channel, message) {\n      expect(pattern).to.eql(\"f?oo\");\n      expect(channel).to.eql(\"fzoo\");\n      expect(message).to.eql(\"bar\");\n\n      if (! --pending) {\n        redis.disconnect();\n        pub.disconnect();\n        done();\n      }\n    });\n    redis.on(\"pmessageBuffer\", function (pattern, channel, message) {\n      expect(pattern).to.eql(\"f?oo\");\n      expect(channel).to.be.instanceof(Buffer);\n      expect(channel.toString()).to.eql(\"fzoo\");\n      expect(message).to.be.instanceof(Buffer);\n      expect(message.toString()).to.eql(\"bar\");\n\n      if (! --pending) {\n        redis.disconnect();\n        pub.disconnect();\n        done();\n      }\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should exit subscriber mode using punsubscribe","suites":["pub/sub"],"updatePoint":{"line":110,"column":52,"index":3415},"line":110,"code":"  it(\"should exit subscriber mode using punsubscribe\", function (done) {\n    const redis = new Redis();\n    redis.psubscribe(\"f?oo\", \"b?ar\", function () {\n      redis.punsubscribe(\"f?oo\", \"b?ar\", function (err, count) {\n        expect(count).to.eql(0);\n        redis.set(\"foo\", \"bar\", function (err) {\n          expect(err).to.eql(null);\n          redis.psubscribe(\"z?oo\", \"f?oo\", function () {\n            redis.punsubscribe(function (err, count) {\n              expect(count).to.eql(0);\n              redis.set(\"foo\", \"bar\", function (err) {\n                expect(err).to.eql(null);\n                redis.disconnect();\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should be able to send quit command in the subscriber mode","suites":["pub/sub"],"updatePoint":{"line":131,"column":64,"index":4157},"line":131,"code":"  it(\"should be able to send quit command in the subscriber mode\", function (done) {\n    const redis = new Redis();\n    let pending = 1;\n    redis.subscribe(\"foo\", function () {\n      redis.quit(function () {\n        pending -= 1;\n      });\n    });\n    redis.on(\"end\", function () {\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should restore subscription after reconnecting(subscribe)","suites":["pub/sub"],"updatePoint":{"line":145,"column":63,"index":4526},"line":145,"code":"  it(\"should restore subscription after reconnecting(subscribe)\", function (done) {\n    const redis = new Redis();\n    const pub = new Redis();\n    redis.subscribe(\"foo\", \"bar\", function () {\n      redis.on(\"ready\", function () {\n        // Execute a random command to make sure that `subscribe`\n        // is sent\n        redis.ping(function () {\n          let pending = 2;\n          redis.on(\"message\", function (channel, message) {\n            if (! --pending) {\n              redis.disconnect();\n              pub.disconnect();\n              done();\n            }\n          });\n          pub.publish(\"foo\", \"hi1\");\n          pub.publish(\"bar\", \"hi2\");\n        });\n      });\n      redis.disconnect({\n        reconnect: true\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should restore subscription after reconnecting(psubscribe)","suites":["pub/sub"],"updatePoint":{"line":170,"column":64,"index":5278},"line":170,"code":"  it(\"should restore subscription after reconnecting(psubscribe)\", function (done) {\n    const redis = new Redis();\n    const pub = new Redis();\n    redis.psubscribe(\"fo?o\", \"ba?r\", function () {\n      redis.on(\"ready\", function () {\n        redis.ping(function () {\n          let pending = 2;\n          redis.on(\"pmessage\", function (pattern, channel, message) {\n            if (! --pending) {\n              redis.disconnect();\n              pub.disconnect();\n              done();\n            }\n          });\n          pub.publish(\"fo1o\", \"hi1\");\n          pub.publish(\"ba1r\", \"hi2\");\n        });\n      });\n      redis.disconnect({\n        reconnect: true\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should retry when redis is not ready","suites":["ready_check"],"updatePoint":{"line":5,"column":42,"index":190},"line":5,"code":"  it(\"should retry when redis is not ready\", function (done) {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    sinon.stub(redis, \"info\").callsFake(callback => {\n      callback(null, \"loading:1\\r\\nloading_eta_seconds:7\");\n    }); // @ts-ignore\n\n    const stub = sinon.stub(global, \"setTimeout\").callsFake((body, ms) => {\n      if (ms === 7000) {\n        redis.info.restore();\n        stub.restore();\n        done();\n      }\n    });\n    redis.connect().catch(noop);\n  });","file":"functional/ready_check.ts","skipped":false,"dir":"test"},{"name":"should reconnect when info return a error","suites":["ready_check"],"updatePoint":{"line":22,"column":47,"index":683},"line":22,"code":"  it(\"should reconnect when info return a error\", function (done) {\n    const redis = new Redis({\n      lazyConnect: true,\n      retryStrategy: function () {\n        done();\n        return;\n      }\n    });\n    sinon.stub(redis, \"info\").callsFake(callback => {\n      callback(new Error(\"info error\"));\n    });\n    redis.connect().catch(noop);\n  });","file":"functional/ready_check.ts","skipped":false,"dir":"test"},{"name":"should pass the error as the first param","suites":["reconnectOnError"],"updatePoint":{"line":5,"column":46,"index":190},"line":5,"code":"  it(\"should pass the error as the first param\", function (done) {\n    let pending = 2;\n\n    function assert(err) {\n      expect(err.name).to.eql(\"ReplyError\");\n      expect(err.command.name).to.eql(\"set\");\n      expect(err.command.args).to.eql([\"foo\"]);\n\n      if (! --pending) {\n        done();\n      }\n    }\n\n    const redis = new Redis({\n      reconnectOnError: function (err) {\n        assert(err);\n        return 1;\n      }\n    });\n    redis.set(\"foo\", function (err) {\n      assert(err);\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should not reconnect if reconnectOnError returns false","suites":["reconnectOnError"],"updatePoint":{"line":28,"column":60,"index":713},"line":28,"code":"  it(\"should not reconnect if reconnectOnError returns false\", function (done) {\n    const redis = new Redis({\n      reconnectOnError: function (err) {\n        return false;\n      }\n    });\n\n    redis.disconnect = function () {\n      throw new Error(\"should not disconnect\");\n    };\n\n    redis.set(\"foo\", function (err) {\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should reconnect if reconnectOnError returns true or 1","suites":["reconnectOnError"],"updatePoint":{"line":43,"column":60,"index":1063},"line":43,"code":"  it(\"should reconnect if reconnectOnError returns true or 1\", function (done) {\n    const redis = new Redis({\n      reconnectOnError: function () {\n        return true;\n      }\n    });\n    redis.set(\"foo\", function () {\n      redis.on(\"ready\", function () {\n        done();\n      });\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should reconnect and retry the command if reconnectOnError returns 2","suites":["reconnectOnError"],"updatePoint":{"line":55,"column":74,"index":1376},"line":55,"code":"  it(\"should reconnect and retry the command if reconnectOnError returns 2\", function (done) {\n    var redis = new Redis({\n      reconnectOnError: function () {\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.sadd(\"foo\", \"a\", function (err, res) {\n      expect(res).to.eql(1);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should select the currect database","suites":["reconnectOnError"],"updatePoint":{"line":68,"column":40,"index":1698},"line":68,"code":"  it(\"should select the currect database\", function (done) {\n    var redis = new Redis({\n      reconnectOnError: function () {\n        redis.select(3);\n        redis.del(\"foo\");\n        redis.select(0);\n        return 2;\n      }\n    });\n    redis.select(3);\n    redis.set(\"foo\", \"bar\");\n    redis.sadd(\"foo\", \"a\", function (err, res) {\n      expect(res).to.eql(1);\n      redis.select(3);\n      redis.type(\"foo\", function (err, type) {\n        expect(type).to.eql(\"set\");\n        done();\n      });\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should work with pipeline","suites":["reconnectOnError"],"updatePoint":{"line":88,"column":31,"index":2200},"line":88,"code":"  it(\"should work with pipeline\", function (done) {\n    var redis = new Redis({\n      reconnectOnError: function () {\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.pipeline().get(\"foo\").sadd(\"foo\", \"a\").exec(function (err, res) {\n      expect(res).to.eql([[null, \"bar\"], [null, 1]]);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should work with pipelined multi","suites":["reconnectOnError"],"updatePoint":{"line":101,"column":38,"index":2572},"line":101,"code":"  it(\"should work with pipelined multi\", function (done) {\n    var redis = new Redis({\n      reconnectOnError: function () {\n        // deleting foo allows sadd below to succeed on the second try\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    const delSpy = sinon.spy(redis, \"del\");\n    redis.set(\"foo\", \"bar\");\n    redis.set(\"i\", 1);\n    redis.pipeline().sadd(\"foo\", \"a\") // trigger a WRONGTYPE error\n    .multi().get(\"foo\").incr(\"i\").exec().exec(function (err, res) {\n      expect(delSpy.calledOnce).to.eql(true);\n      expect(delSpy.firstCall.args[0]).to.eql(\"foo\");\n      expect(err).to.be.null;\n      expect(res).to.eql([[null, 1], [null, \"OK\"], [null, \"QUEUED\"], [null, \"QUEUED\"], [null, [\"bar\", 2]]]);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should return a readable stream","suites":["*scanStream","scanStream"],"updatePoint":{"line":10,"column":39,"index":389},"line":10,"code":"    it(\"should return a readable stream\", function () {\n      const redis = new Redis();\n      const stream = redis.scanStream();\n      expect(stream instanceof Readable).to.eql(true);\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should iterate all keys","suites":["*scanStream","scanStream"],"updatePoint":{"line":15,"column":31,"index":574},"line":15,"code":"    it(\"should iterate all keys\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, function () {\n        const stream = redis.scanStream();\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys.sort()).to.eql([\"foo1\", \"foo10\", \"foo2\", \"foo3\", \"foo4\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `MATCH`","suites":["*scanStream","scanStream"],"updatePoint":{"line":30,"column":32,"index":1101},"line":30,"code":"    it(\"should recognize `MATCH`\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, function () {\n        const stream = redis.scanStream({\n          match: \"foo??\"\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys).to.eql([\"foo10\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `TYPE`","suites":["*scanStream","scanStream"],"updatePoint":{"line":47,"column":31,"index":1624},"line":47,"code":"    it(\"should recognize `TYPE`\", async function () {\n      let keys = [];\n      const redis = new Redis();\n      const [major] = await getRedisVersion(redis);\n\n      if (major < 6) {\n        return;\n      }\n\n      redis.set(\"foo1\", \"bar\");\n      redis.set(\"foo2\", \"bar\");\n      redis.set(\"foo3\", \"bar\");\n      redis.lpush(\"loo1\", \"1\");\n      redis.lpush(\"loo2\", \"1\");\n      redis.lpush(\"loo3\", \"1\");\n      const stream = redis.scanStream({\n        type: \"list\"\n      });\n      stream.on(\"data\", function (data) {\n        keys = keys.concat(data);\n      });\n      return new Promise(resolve => {\n        stream.on(\"end\", function () {\n          expect(keys.sort()).to.eql([\"loo1\", \"loo2\", \"loo3\"]);\n          redis.disconnect();\n          resolve();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `COUNT`","suites":["*scanStream","scanStream"],"updatePoint":{"line":76,"column":32,"index":2405},"line":76,"code":"    it(\"should recognize `COUNT`\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      sinon.spy(Redis.prototype, \"scan\");\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, function () {\n        const stream = redis.scanStream({\n          count: 2\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys.sort()).to.eql([\"foo1\", \"foo10\", \"foo2\", \"foo3\", \"foo4\"]);\n          const [args] = Redis.prototype.scan.getCall(0).args;\n          let count;\n\n          for (let i = 0; i < args.length; ++i) {\n            if (typeof args[i] === \"string\" && args[i].toUpperCase() === \"COUNT\") {\n              count = args[i + 1];\n              break;\n            }\n          }\n\n          expect(count).to.eql(\"2\");\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should emit an error when connection is down","suites":["*scanStream","scanStream"],"updatePoint":{"line":105,"column":52,"index":3363},"line":105,"code":"    it(\"should emit an error when connection is down\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, function () {\n        redis.disconnect();\n        const stream = redis.scanStream({\n          count: 1\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"error\", function (err) {\n          expect(err.message).to.eql(\"Connection is closed.\");\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should return buffer","suites":["*scanStream","scanBufferStream"],"updatePoint":{"line":124,"column":28,"index":3952},"line":124,"code":"    it(\"should return buffer\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, function () {\n        const stream = redis.scanBufferStream();\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys.sort()).to.eql([Buffer.from(\"foo1\"), Buffer.from(\"foo10\"), Buffer.from(\"foo2\"), Buffer.from(\"foo3\"), Buffer.from(\"foo4\")]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should iterate all values in the set","suites":["*scanStream","sscanStream"],"updatePoint":{"line":141,"column":44,"index":4608},"line":141,"code":"    it(\"should iterate all values in the set\", function (done) {\n      let keys = [];\n      const redis = new Redis();\n      redis.sadd(\"set\", \"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo10\", function () {\n        const stream = redis.sscanStream(\"set\", {\n          match: \"foo??\"\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys).to.eql([\"foo10\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should work in cluster mode","suites":["*scanStream","Cluster"],"updatePoint":{"line":160,"column":35,"index":5177},"line":160,"code":"    it(\"should work in cluster mode\", function (done) {\n      const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n      const serverKeys = [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo10\"];\n\n      const argvHandler = function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"slots\") {\n          return slotTable;\n        }\n\n        if (argv[0] === \"sscan\" && argv[1] === \"set\") {\n          const cursor = Number(argv[2]);\n\n          if (cursor >= serverKeys.length) {\n            return [\"0\", []];\n          }\n\n          return [String(cursor + 1), [serverKeys[cursor]]];\n        }\n      };\n\n      new MockServer(30001, argvHandler);\n      new MockServer(30002, argvHandler);\n      new MockServer(30003, argvHandler);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]);\n      let keys = []; // @ts-ignore\n\n      cluster.sadd(\"set\", serverKeys, function () {\n        // @ts-ignore\n        const stream = cluster.sscanStream(\"set\");\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", function () {\n          expect(keys).to.eql(serverKeys);\n          cluster.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize the numberOfKeys property","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":5,"column":50,"index":197},"line":5,"code":"    it(\"should recognize the numberOfKeys property\", function (done) {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 2,\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n      redis.test(\"k1\", \"k2\", \"a1\", \"a2\", function (err, result) {\n        expect(result).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support dynamic key count","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":17,"column":40,"index":603},"line":17,"code":"    it(\"should support dynamic key count\", function (done) {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n      redis.test(2, \"k1\", \"k2\", \"a1\", \"a2\", function (err, result) {\n        expect(result).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support numberOfKeys being 0","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":28,"column":43,"index":990},"line":28,"code":"    it(\"should support numberOfKeys being 0\", function (done) {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 0,\n        lua: \"return {ARGV[1],ARGV[2]}\"\n      });\n      redis.test(\"2\", \"a2\", function (err, result) {\n        expect(result).to.eql([\"2\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should throw when numberOfKeys is omit","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":40,"column":46,"index":1360},"line":40,"code":"    it(\"should throw when numberOfKeys is omit\", function (done) {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n      redis.test(\"k1\", \"k2\", \"a1\", \"a2\", function (err, result) {\n        expect(err).to.be.instanceof(Error);\n        expect(err.toString()).to.match(/value is not an integer/);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should have a buffer version","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":53,"column":34,"index":1797},"line":53,"code":"  it(\"should have a buffer version\", function (done) {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n    redis.testBuffer(\"k1\", \"k2\", \"a1\", \"a2\", function (err, result) {\n      expect(result).to.eql([Buffer.from(\"k1\"), Buffer.from(\"k2\"), Buffer.from(\"a1\"), Buffer.from(\"a2\")]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should work well with pipeline","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":65,"column":36,"index":2235},"line":65,"code":"  it(\"should work well with pipeline\", function (done) {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.pipeline().set(\"test\", \"pipeline\").test(\"test\").exec(function (err, results) {\n      expect(results).to.eql([[null, \"OK\"], [null, \"pipeline\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should following pipeline style when throw","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":77,"column":48,"index":2656},"line":77,"code":"  it(\"should following pipeline style when throw\", function (done) {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.pipeline().set(\"test\", \"pipeline\").test(\"test\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results[1][0]).to.be.instanceof(Error);\n      expect(results[1][0].toString()).to.match(/value is not an integer/);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should use evalsha when script is loaded","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":90,"column":46,"index":3147},"line":90,"code":"  it(\"should use evalsha when script is loaded\", function (done) {\n    const redis = new Redis();\n    redis.on(\"ready\", function () {\n      redis.defineCommand(\"test\", {\n        lua: \"return 1\"\n      });\n      redis.monitor(function (err, monitor) {\n        let sent = false;\n        monitor.on(\"monitor\", function (_, command) {\n          if (!sent) {\n            sent = true;\n            expect(command[0]).to.eql(\"evalsha\");\n            monitor.disconnect();\n            done();\n          }\n        });\n        redis.test(0, function () {\n          redis.disconnect();\n        });\n      });\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should try to use EVALSHA and fallback to EVAL if fails","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":112,"column":61,"index":3770},"line":112,"code":"  it(\"should try to use EVALSHA and fallback to EVAL if fails\", function (done) {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.once(\"ready\", function () {\n      const flush = new Redis();\n      flush.script(\"flush\", function () {\n        const expectedComands = [\"evalsha\", \"eval\", \"get\", \"evalsha\", \"get\"];\n        redis.monitor(function (err, monitor) {\n          monitor.on(\"monitor\", function (_, command) {\n            const name = expectedComands.shift();\n            expect(name).to.eql(command[0]);\n\n            if (!expectedComands.length) {\n              monitor.disconnect();\n              redis.disconnect();\n              done();\n            }\n          });\n          redis.test(\"bar\", function () {\n            redis.test(\"foo\");\n          });\n        });\n      });\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should load scripts first before execute pipeline","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":140,"column":55,"index":4666},"line":140,"code":"  it(\"should load scripts first before execute pipeline\", function (done) {\n    const redis = new Redis();\n    redis.defineCommand(\"testGet\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.testGet(\"init\", function () {\n      redis.defineCommand(\"testSet\", {\n        numberOfKeys: 1,\n        lua: 'return redis.call(\"set\", KEYS[1], \"bar\")'\n      });\n      const expectedComands = [\"script\", \"script\", \"evalsha\", \"get\", \"evalsha\", \"set\", \"get\"];\n      redis.monitor(function (err, monitor) {\n        monitor.on(\"monitor\", function (_, command) {\n          const name = expectedComands.shift();\n          expect(name).to.eql(command[0]);\n\n          if (!expectedComands.length) {\n            monitor.disconnect();\n            redis.disconnect();\n            done();\n          }\n        });\n        const pipe = redis.pipeline();\n        pipe.testGet(\"foo\").testSet(\"foo\").get(\"foo\").exec();\n      });\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":168,"column":34,"index":5600},"line":168,"code":"  it(\"should support key prefixing\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.defineCommand(\"echo\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n    redis.echo(\"k1\", \"k2\", \"a1\", \"a2\", function (err, result) {\n      expect(result).to.eql([\"foo:k1\", \"foo:k2\", \"a1\", \"a2\"]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support auto select","suites":["select"],"updatePoint":{"line":4,"column":32,"index":134},"line":4,"code":"  it(\"should support auto select\", function (done) {\n    const redis = new Redis({\n      db: 2\n    });\n    redis.set(\"foo\", \"2\");\n    redis.select(\"2\");\n    redis.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"2\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should resend commands to the correct db","suites":["select"],"updatePoint":{"line":16,"column":46,"index":429},"line":16,"code":"  it(\"should resend commands to the correct db\", function (done) {\n    const redis = new Redis();\n    redis.once(\"ready\", function () {\n      redis.set(\"foo\", \"2\", function () {\n        redis.stream.destroy();\n        redis.select(\"3\");\n        redis.set(\"foo\", \"3\");\n        redis.select(\"0\");\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"2\");\n          redis.select(\"3\");\n          redis.get(\"foo\", function (err, res) {\n            expect(res).to.eql(\"3\");\n            redis.disconnect();\n            done();\n          });\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should re-select the current db when reconnect","suites":["select"],"updatePoint":{"line":36,"column":52,"index":1029},"line":36,"code":"  it(\"should re-select the current db when reconnect\", function (done) {\n    const redis = new Redis();\n    redis.once(\"ready\", function () {\n      redis.set(\"foo\", \"bar\");\n      redis.select(2);\n      redis.set(\"foo\", \"2\", function () {\n        redis.stream.destroy();\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"2\");\n          redis.disconnect();\n          done();\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should emit \"select\" event when db changes","suites":["select"],"updatePoint":{"line":51,"column":48,"index":1461},"line":51,"code":"  it('should emit \"select\" event when db changes', function (done) {\n    const changes = [];\n    const redis = new Redis();\n    redis.on(\"select\", function (db) {\n      changes.push(db);\n    });\n    redis.select(\"2\", function () {\n      expect(changes).to.eql([2]);\n      redis.select(\"4\", function () {\n        expect(changes).to.eql([2, 4]);\n        redis.select(\"4\", function () {\n          expect(changes).to.eql([2, 4]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should be sent on the connect event","suites":["select"],"updatePoint":{"line":69,"column":41,"index":1964},"line":69,"code":"  it(\"should be sent on the connect event\", function (done) {\n    const redis = new Redis({\n      db: 2\n    });\n    const select = redis.select;\n\n    redis.select = function () {\n      return select.apply(redis, arguments).then(function () {\n        redis.select = select;\n        redis.disconnect();\n        done();\n      });\n    };\n\n    redis.on(\"connect\", function () {\n      redis.subscribe(\"anychannel\");\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should support callback","suites":["send command"],"updatePoint":{"line":4,"column":29,"index":137},"line":4,"code":"  it(\"should support callback\", function (done) {\n    const redis = new Redis();\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support promise","suites":["send command"],"updatePoint":{"line":12,"column":28,"index":356},"line":12,"code":"  it(\"should support promise\", function () {\n    const redis = new Redis();\n    redis.set(\"foo\", \"bar\");\n    return redis.get(\"foo\").then(function (result) {\n      expect(result).to.eql(\"bar\");\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should keep the response order when mix using callback & promise","suites":["send command"],"updatePoint":{"line":19,"column":70,"index":606},"line":19,"code":"  it(\"should keep the response order when mix using callback & promise\", function (done) {\n    const redis = new Redis();\n    let order = 0;\n    redis.get(\"foo\").then(function () {\n      expect(++order).to.eql(1);\n    });\n    redis.get(\"foo\", function () {\n      expect(++order).to.eql(2);\n    });\n    redis.get(\"foo\").then(function () {\n      expect(++order).to.eql(3);\n    });\n    redis.get(\"foo\", function () {\n      expect(++order).to.eql(4);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support get & set buffer","suites":["send command"],"updatePoint":{"line":36,"column":37,"index":1048},"line":36,"code":"  it(\"should support get & set buffer\", function (done) {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"foo\"), Buffer.from(\"bar\"), function (err, res) {\n      expect(res).to.eql(\"OK\");\n    });\n    redis.getBuffer(Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support get & set buffer via `call`","suites":["send command"],"updatePoint":{"line":47,"column":48,"index":1451},"line":47,"code":"  it(\"should support get & set buffer via `call`\", function (done) {\n    const redis = new Redis();\n    redis.call(\"set\", Buffer.from(\"foo\"), Buffer.from(\"bar\"), function (err, res) {\n      expect(res).to.eql(\"OK\");\n    });\n    redis.callBuffer(\"get\", Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should handle empty buffer","suites":["send command"],"updatePoint":{"line":58,"column":32,"index":1854},"line":58,"code":"  it(\"should handle empty buffer\", function (done) {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"foo\"), Buffer.from(\"\"));\n    redis.getBuffer(Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support utf8","suites":["send command"],"updatePoint":{"line":67,"column":25,"index":2167},"line":67,"code":"  it(\"should support utf8\", function (done) {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"\"), String(\"\"));\n    redis.getBuffer(\"\", function (err, result) {\n      expect(result.toString()).to.eql(\"\");\n      redis.get(\"\", function (err, result) {\n        expect(result).to.eql(\"\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should consider null as empty str","suites":["send command"],"updatePoint":{"line":78,"column":39,"index":2527},"line":78,"code":"  it(\"should consider null as empty str\", function (done) {\n    const redis = new Redis();\n    redis.set(\"foo\", null, function () {\n      redis.get(\"foo\", function (err, res) {\n        expect(res).to.eql(\"\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support return int value","suites":["send command"],"updatePoint":{"line":87,"column":37,"index":2774},"line":87,"code":"  it(\"should support return int value\", function (done) {\n    const redis = new Redis();\n    redis.exists(\"foo\", function (err, exists) {\n      expect(typeof exists).to.eql(\"number\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject when disconnected","suites":["send command"],"updatePoint":{"line":94,"column":37,"index":2986},"line":94,"code":"  it(\"should reject when disconnected\", function (done) {\n    const redis = new Redis();\n    redis.disconnect();\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/Connection is closed./);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject when enableOfflineQueue is disabled","suites":["send command"],"updatePoint":{"line":102,"column":55,"index":3244},"line":102,"code":"  it(\"should reject when enableOfflineQueue is disabled\", function (done) {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/enableOfflineQueue options is false/);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["send command"],"updatePoint":{"line":111,"column":34,"index":3510},"line":111,"code":"  it(\"should support key prefixing\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.set(\"bar\", \"baz\");\n    redis.get(\"bar\", function (err, result) {\n      expect(result).to.eql(\"baz\");\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.eql([\"foo:bar\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing with multiple keys","suites":["send command"],"updatePoint":{"line":124,"column":53,"index":3888},"line":124,"code":"  it(\"should support key prefixing with multiple keys\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.lpush(\"app1\", \"test1\");\n    redis.lpush(\"app2\", \"test2\");\n    redis.lpush(\"app3\", \"test3\");\n    redis.blpop(\"app1\", \"app2\", \"app3\", 0, function (err, result) {\n      expect(result).to.eql([\"foo:app1\", \"test1\"]);\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.have.members([\"foo:app2\", \"foo:app3\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing for zunionstore","suites":["send command"],"updatePoint":{"line":139,"column":50,"index":4396},"line":139,"code":"  it(\"should support key prefixing for zunionstore\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.zadd(\"zset1\", 1, \"one\");\n    redis.zadd(\"zset1\", 2, \"two\");\n    redis.zadd(\"zset2\", 1, \"one\");\n    redis.zadd(\"zset2\", 2, \"two\");\n    redis.zadd(\"zset2\", 3, \"three\");\n    redis.zunionstore(\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3, function (err, result) {\n      expect(result).to.eql(3);\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.have.members([\"foo:zset1\", \"foo:zset2\", \"foo:out\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing for sort","suites":["send command"],"updatePoint":{"line":156,"column":43,"index":4989},"line":156,"code":"  it(\"should support key prefixing for sort\", function (done) {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.hset(\"object_1\", \"name\", \"better\");\n    redis.hset(\"weight_1\", \"value\", \"20\");\n    redis.hset(\"object_2\", \"name\", \"best\");\n    redis.hset(\"weight_2\", \"value\", \"30\");\n    redis.hset(\"object_3\", \"name\", \"good\");\n    redis.hset(\"weight_3\", \"value\", \"10\");\n    redis.lpush(\"src\", \"1\", \"2\", \"3\");\n    redis.sort(\"src\", \"BY\", \"weight_*->value\", \"GET\", \"object_*->name\", \"STORE\", \"dest\", function (err, result) {\n      redis.lrange(\"dest\", 0, -1, function (err, result) {\n        expect(result).to.eql([\"good\", \"better\", \"best\"]);\n        redis.keys(\"*\", function (err, result) {\n          expect(result).to.have.members([\"foo:object_1\", \"foo:weight_1\", \"foo:object_2\", \"foo:weight_2\", \"foo:object_3\", \"foo:weight_3\", \"foo:src\", \"foo:dest\"]);\n          done();\n        });\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should allow sending the loading valid commands in connect event","suites":["send command"],"updatePoint":{"line":177,"column":70,"index":5942},"line":177,"code":"  it(\"should allow sending the loading valid commands in connect event\", function (done) {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.on(\"connect\", function () {\n      redis.select(2, function (err, res) {\n        expect(res).to.eql(\"OK\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject loading invalid commands in connect event","suites":["send command"],"updatePoint":{"line":188,"column":61,"index":6250},"line":188,"code":"  it(\"should reject loading invalid commands in connect event\", function (done) {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.on(\"connect\", function () {\n      redis.get(\"foo\", function (err) {\n        expect(err.message).to.eql(\"Stream isn't writeable and enableOfflineQueue options is false\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"throws for invalid command","suites":["send command"],"updatePoint":{"line":199,"column":32,"index":6593},"line":199,"code":"  it(\"throws for invalid command\", async () => {\n    const redis = new Redis();\n    const invalidCommand = \"\";\n    let err;\n\n    try {\n      await redis.call(invalidCommand, []);\n    } catch (e) {\n      err = e.message;\n    }\n\n    expect(err).to.contain(\"unknown command\");\n    expect(err).to.contain(invalidCommand);\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"connects to server as expected","suites":["sentinel_nat"],"updatePoint":{"line":4,"column":36,"index":162},"line":4,"code":"  it(\"connects to server as expected\", function (done) {\n    const sentinel = new MockServer(27379, function (argv) {\n      if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n        return [\"127.0.0.1\", \"17380\"];\n      }\n    });\n    const redis = new Redis({\n      sentinels: [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }],\n      natMap: {\n        \"127.0.0.1:17380\": {\n          host: \"localhost\",\n          port: 6379\n        }\n      },\n      name: \"master\",\n      lazyConnect: true\n    });\n    redis.connect(function (err) {\n      if (err) {\n        sentinel.disconnect(function () {});\n        return done(err);\n      }\n\n      sentinel.disconnect(done);\n    });\n  });","file":"functional/sentinel_nat.ts","skipped":false,"dir":"test"},{"name":"rejects connection if host is not defined in map","suites":["sentinel_nat"],"updatePoint":{"line":33,"column":54,"index":884},"line":33,"code":"  it(\"rejects connection if host is not defined in map\", function (done) {\n    const sentinel = new MockServer(27379, function (argv) {\n      if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n        return [\"127.0.0.1\", \"17380\"];\n      }\n\n      if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\" && argv[2] === \"master\") {\n        return [\"127.0.0.1\", \"27379\"];\n      }\n    });\n    const redis = new Redis({\n      sentinels: [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }],\n      natMap: {\n        \"127.0.0.1:17381\": {\n          host: \"localhost\",\n          port: 6379\n        }\n      },\n      maxRetriesPerRequest: 1,\n      name: \"master\",\n      lazyConnect: true\n    });\n    redis.connect().then(function () {\n      throw new Error(\"Should not call\");\n    }).catch(function (err) {\n      if (err.message === \"Connection is closed.\") {\n        return done(null);\n      }\n\n      sentinel.disconnect(done);\n    });\n  });","file":"functional/sentinel_nat.ts","skipped":false,"dir":"test"},{"name":"should connect to sentinel successfully","suites":["sentinel","connect"],"updatePoint":{"line":16,"column":47,"index":518},"line":16,"code":"    it(\"should connect to sentinel successfully\", function (done) {\n      const sentinel = new MockServer(27379);\n      sentinel.once(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should default to the default sentinel port","suites":["sentinel","connect"],"updatePoint":{"line":30,"column":51,"index":910},"line":30,"code":"    it(\"should default to the default sentinel port\", function (done) {\n      const sentinel = new MockServer(26379);\n      sentinel.once(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\"\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should try to connect to all sentinel","suites":["sentinel","connect"],"updatePoint":{"line":43,"column":45,"index":1273},"line":43,"code":"    it(\"should try to connect to all sentinel\", function (done) {\n      const sentinel = new MockServer(27380);\n      sentinel.once(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should skip an unresponsive sentinel","suites":["sentinel","connect"],"updatePoint":{"line":60,"column":44,"index":1722},"line":60,"code":"    it(\"should skip an unresponsive sentinel\", async function () {\n      const sentinel1 = new MockServer(27379, function (argv, socket, flags) {\n        flags.hang = true;\n      });\n      const sentinel2 = new MockServer(27380, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      const clock = sinon.useFakeTimers();\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        sentinelCommandTimeout: 1000\n      });\n      clock.tick(1000);\n      clock.restore();\n      await once(master, \"connect\");\n      redis.disconnect();\n      await Promise.all([sentinel1.disconnectPromise(), sentinel2.disconnectPromise(), master.disconnectPromise()]);\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should call sentinelRetryStrategy when all sentinels are unreachable","suites":["sentinel","connect"],"updatePoint":{"line":88,"column":76,"index":2715},"line":88,"code":"    it(\"should call sentinelRetryStrategy when all sentinels are unreachable\", function (done) {\n      let t = 0;\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        sentinelRetryStrategy: function (times) {\n          expect(times).to.eql(++t);\n          const sentinel = new MockServer(27380);\n          sentinel.once(\"connect\", function () {\n            redis.disconnect();\n            sentinel.disconnect(done);\n          });\n          return 0;\n        },\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should raise error when all sentinel are unreachable and retry is disabled","suites":["sentinel","connect"],"updatePoint":{"line":110,"column":82,"index":3357},"line":110,"code":"    it(\"should raise error when all sentinel are unreachable and retry is disabled\", function (done) {\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        sentinelRetryStrategy: null,\n        name: \"master\"\n      });\n      redis.get(\"foo\", function (error) {\n        finish();\n        expect(error.message).to.match(/are unreachable/);\n      });\n      redis.on(\"error\", function (error) {\n        expect(error.message).to.match(/are unreachable/);\n        finish();\n      });\n      redis.on(\"end\", function () {\n        finish();\n      });\n      let pending = 3;\n\n      function finish() {\n        if (! --pending) {\n          redis.disconnect();\n          done();\n        }\n      }\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should close the connection to the sentinel when resolving unsuccessfully","suites":["sentinel","connect"],"updatePoint":{"line":142,"column":81,"index":4184},"line":142,"code":"    it(\"should close the connection to the sentinel when resolving unsuccessfully\", function (done) {\n      const sentinel = new MockServer(27379); // Does not respond properly to get-master-addr-by-name\n\n      sentinel.once(\"disconnect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should add additionally discovered sentinels when resolving successfully","suites":["sentinel","connect"],"updatePoint":{"line":157,"column":80,"index":4665},"line":157,"code":"    it(\"should add additionally discovered sentinels when resolving successfully\", function (done) {\n      const sentinels = [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }];\n      let cloned;\n      sinon.stub(sentinels, \"slice\").callsFake((start, end) => {\n        cloned = [].slice.call(sentinels, start, end);\n        return cloned;\n      });\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        } else if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"27379\"], [\"ip\", \"127.0.0.1\", \"port\", \"27380\"]];\n        }\n      });\n      const master = new MockServer(17380);\n      const redis = new Redis({\n        sentinels: sentinels,\n        name: \"master\"\n      });\n      redis.on(\"ready\", function () {\n        redis.disconnect();\n        master.disconnect(function () {\n          expect(cloned.length).to.eql(2);\n          sentinel.disconnect(done);\n        });\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should skip additionally discovered sentinels even if they are resolved successfully","suites":["sentinel","connect"],"updatePoint":{"line":187,"column":92,"index":5758},"line":187,"code":"    it(\"should skip additionally discovered sentinels even if they are resolved successfully\", function (done) {\n      const sentinels = [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }];\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        } else if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"27379\"], [\"ip\", \"127.0.0.1\", \"port\", \"27380\"]];\n        }\n      });\n      const master = new MockServer(17380);\n      const redis = new Redis({\n        sentinels: sentinels,\n        updateSentinels: false,\n        name: \"master\"\n      });\n      redis.on(\"ready\", function () {\n        redis.disconnect();\n        master.disconnect(function () {\n          expect(sentinels.length).to.eql(1);\n          expect(sentinels[0].port).to.eql(27379);\n          sentinel.disconnect(done);\n        });\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to sentinel with authentication successfully","suites":["sentinel","connect"],"updatePoint":{"line":214,"column":67,"index":6741},"line":214,"code":"    it(\"should connect to sentinel with authentication successfully\", function (done) {\n      let authed = false;\n      var redisServer = new MockServer(17380, function (argv) {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          authed = true;\n        } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n          expect(authed).to.eql(true);\n          redisServer.disconnect();\n          done();\n        }\n      });\n      var sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          sentinel.disconnect(done);\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const redis = new Redis({\n        sentinelPassword: \"pass\",\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n      redis.get(\"foo\").catch(function () {});\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the master successfully","suites":["sentinel","master"],"updatePoint":{"line":243,"column":49,"index":7673},"line":243,"code":"    it(\"should connect to the master successfully\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      master.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          master.disconnect(done);\n        });\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should reject when sentinel is rejected","suites":["sentinel","master"],"updatePoint":{"line":264,"column":47,"index":8312},"line":264,"code":"    it(\"should reject when sentinel is rejected\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return new Error(\"just rejected\");\n        }\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        sentinelRetryStrategy: null,\n        lazyConnect: true\n      });\n      redis.connect().then(function () {\n        throw new Error(\"Expect `connect` to be thrown\");\n      }).catch(function (err) {\n        expect(err.message).to.eql(\"All sentinels are unreachable and retry is disabled. Last error: just rejected\");\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if getting master failed","suites":["sentinel","master"],"updatePoint":{"line":287,"column":68,"index":9152},"line":287,"code":"    it(\"should connect to the next sentinel if getting master failed\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return null;\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          sentinel2.disconnect(done);\n        });\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if the role is wrong","suites":["sentinel","master"],"updatePoint":{"line":311,"column":64,"index":9863},"line":311,"code":"    it(\"should connect to the next sentinel if the role is wrong\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\" && argv[2] === \"master\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          sentinel2.disconnect(done);\n        });\n      });\n      new MockServer(17380, function (argv) {\n        if (argv[0] === \"info\") {\n          return \"role:slave\";\n        }\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully","suites":["sentinel","slave"],"updatePoint":{"line":342,"column":48,"index":10770},"line":342,"code":"    it(\"should connect to the slave successfully\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      });\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          slave.disconnect(done);\n        });\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n        preferredSlaves: [{\n          ip: \"127.0.0.1\",\n          port: \"17381\",\n          prio: 10\n        }]\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully based on preferred slave priority","suites":["sentinel","slave"],"updatePoint":{"line":369,"column":82,"index":11616},"line":369,"code":"    it(\"should connect to the slave successfully based on preferred slave priority\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"44444\", \"flags\", \"slave\"], [\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"], [\"ip\", \"127.0.0.1\", \"port\", \"55555\", \"flags\", \"slave\"]];\n        }\n      });\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          slave.disconnect(done);\n        });\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n        // for code coverage (sorting, etc), use multiple valid values that resolve to prio 1\n        preferredSlaves: [{\n          ip: \"127.0.0.1\",\n          port: \"11111\",\n          prio: 100\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\",\n          prio: 1\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"22222\",\n          prio: 100\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\"\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\"\n        }]\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully based on preferred slave filter function","suites":["sentinel","slave"],"updatePoint":{"line":411,"column":89,"index":12972},"line":411,"code":"    it(\"should connect to the slave successfully based on preferred slave filter function\", function (done) {\n      new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      }); // only one running slave, which we will prefer\n\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", function () {\n        redis.disconnect();\n        done();\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n\n        preferredSlaves(slaves) {\n          for (let i = 0; i < slaves.length; i++) {\n            const slave = slaves[i];\n\n            if (slave.ip == \"127.0.0.1\" && slave.port == \"17381\") {\n              return slave;\n            }\n          }\n\n          return null;\n        }\n\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if getting slave failed","suites":["sentinel","slave"],"updatePoint":{"line":445,"column":67,"index":13935},"line":445,"code":"    it(\"should connect to the next sentinel if getting slave failed\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", function () {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          sentinel2.disconnect(done);\n        });\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        role: \"slave\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if the role is wrong","suites":["sentinel","slave"],"updatePoint":{"line":470,"column":64,"index":14674},"line":470,"code":"    it(\"should connect to the next sentinel if the role is wrong\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", function (c) {\n        redis.disconnect();\n        sentinel.disconnect(function () {\n          slave.disconnect(function () {\n            sentinel2.disconnect(done);\n          });\n        });\n      });\n      var slave = new MockServer(17381, function (argv) {\n        if (argv[0] === \"info\") {\n          return \"role:master\";\n        }\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        role: \"slave\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should switch to new master automatically without any commands being lost","suites":["sentinel","failover"],"updatePoint":{"line":504,"column":81,"index":15729},"line":504,"code":"    it(\"should switch to new master automatically without any commands being lost\", function (done) {\n      const sentinel = new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      master.on(\"connect\", function (c) {\n        c.destroy();\n        master.disconnect();\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"bar\");\n          redis.disconnect();\n          newMaster.disconnect(function () {\n            sentinel.disconnect(done);\n          });\n        });\n        var newMaster = new MockServer(17381, function (argv) {\n          if (argv[0] === \"get\" && argv[1] === \"foo\") {\n            return \"bar\";\n          }\n        });\n\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n      });\n      var redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to new master after +switch-master","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":542,"column":59,"index":16942},"line":542,"code":"      it(\"should connect to new master after +switch-master\", async function () {\n        const sentinel = new MockServer(27379, function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }],\n          failoverDetector: true,\n          name: \"master\"\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]);\n\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n\n        sentinel.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"), // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover from secondary sentinel","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":573,"column":56,"index":18255},"line":573,"code":"      it(\"should detect failover from secondary sentinel\", async function () {\n        const sentinel1 = new MockServer(27379, function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const sentinel2 = new MockServer(27380);\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }, {\n            host: \"127.0.0.1\",\n            port: 27380\n          }],\n          name: \"master\",\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]); // In this test, only the first sentinel is used to resolve the master\n\n        sentinel1.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        }; // But only the second sentinel broadcasts +switch-master\n\n\n        sentinel2.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"), // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel1.disconnectPromise(), sentinel2.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover when some sentinels fail","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":609,"column":57,"index":19853},"line":609,"code":"      it(\"should detect failover when some sentinels fail\", async function () {\n        // Will disconnect before failover\n        const sentinel1 = new MockServer(27379, function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        }); // Will emit an error before failover\n\n        let sentinel2Socket = null;\n        const sentinel2 = new MockServer(27380, function (argv, socket) {\n          sentinel2Socket = socket;\n        }); // Fails to subscribe\n\n        const sentinel3 = new MockServer(27381, function (argv, socket, flags) {\n          if (argv[0] === \"subscribe\") {\n            triggerParseError(socket);\n          }\n        }); // The only sentinel that can successfully publish the failover message\n\n        const sentinel4 = new MockServer(27382);\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }, {\n            host: \"127.0.0.1\",\n            port: 27380\n          }, {\n            host: \"127.0.0.1\",\n            port: 27381\n          }, {\n            host: \"127.0.0.1\",\n            port: 27382\n          }],\n          name: \"master\",\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"), // Must resolve even though subscribing to sentinel3 fails\n        once(redis, \"failoverSubscribed\")]); // Fail sentinels 1 and 2\n\n        await sentinel1.disconnectPromise();\n        triggerParseError(sentinel2Socket);\n\n        sentinel4.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n\n        sentinel4.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"), // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([// sentinel1 is already disconnected\n        sentinel2.disconnectPromise(), sentinel3.disconnectPromise(), sentinel4.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover after sentinel disconnects and reconnects","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":668,"column":74,"index":22258},"line":668,"code":"      it(\"should detect failover after sentinel disconnects and reconnects\", async function () {\n        const sentinel = new MockServer(27379, function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }],\n          name: \"master\",\n          sentinelReconnectStrategy: () => 1000,\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]);\n        await sentinel.disconnectPromise();\n\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n\n          if (argv[0] === \"subscribe\") {\n            sentinel.emit(\"test:resubscribed\"); // Custom event only used in tests\n          }\n        };\n\n        sentinel.connect();\n        const clock = sinon.useFakeTimers();\n        await once(redis, \"sentinelReconnecting\"); // Wait for the timeout to be set\n\n        clock.tick(1000);\n        clock.restore();\n        await once(sentinel, \"test:resubscribed\");\n        sentinel.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"), // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should show friendly error stack","suites":["showFriendlyErrorStack"],"updatePoint":{"line":8,"column":38,"index":234},"line":8,"code":"  it(\"should show friendly error stack\", function (done) {\n    const redis = new Redis({\n      showFriendlyErrorStack: true\n    });\n    redis.set(\"foo\").catch(function (err) {\n      const errors = err.stack.split(\"\\n\");\n      expect(errors[0].indexOf(\"ReplyError\")).not.eql(-1);\n      expect(errors[1].indexOf(scriptName)).not.eql(-1);\n      done();\n    });\n  });","file":"functional/show_friendly_error_stack.ts","skipped":false,"dir":"test"},{"name":"returns numbers as strings","suites":["stringNumbers","enabled"],"updatePoint":{"line":7,"column":34,"index":243},"line":7,"code":"    it(\"returns numbers as strings\", function (done) {\n      const redis = new Redis({\n        stringNumbers: true\n      });\n      let pending = 0;\n      redis.set(\"foo\", MAX_NUMBER);\n      redis.incr(\"foo\", check(\"9007199254740992\"));\n      redis.incr(\"foo\", check(\"9007199254740993\"));\n      redis.incr(\"foo\", check(\"9007199254740994\")); // also works for small interger\n\n      redis.set(\"foo\", 123);\n      redis.incr(\"foo\", check(\"124\")); // and floats\n\n      redis.set(\"foo\", 123.23);\n      redis.incrbyfloat(\"foo\", 1.2, check(\"124.43\"));\n\n      function check(expected) {\n        pending += 1;\n        return function (err, res) {\n          expect(res).to.eql(expected);\n\n          if (! --pending) {\n            redis.disconnect();\n            done();\n          }\n        };\n      }\n    });","file":"functional/string_numbers.ts","skipped":false,"dir":"test"},{"name":"returns numbers","suites":["stringNumbers","disabled"],"updatePoint":{"line":37,"column":23,"index":1071},"line":37,"code":"    it(\"returns numbers\", function (done) {\n      const redis = new Redis();\n      redis.set(\"foo\", \"123\");\n      redis.incr(\"foo\", function (err, res) {\n        expect(res).to.eql(124);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/string_numbers.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["tls option","Standalone"],"updatePoint":{"line":9,"column":20,"index":290},"line":9,"code":"    it(\"supports tls\", done => {\n      let redis; // @ts-ignore\n\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-ignore\n        expect(op.ca).to.eql(\"123\"); // @ts-ignore\n\n        expect(op.servername).to.eql(\"localhost\"); // @ts-ignore\n\n        expect(op.rejectUnauthorized).to.eql(false); // @ts-ignore\n\n        expect(op.port).to.eql(6379);\n        const stream = net.createConnection(op);\n        stream.on(\"connect\", data => {\n          stream.emit(\"secureConnect\", data);\n        });\n        return stream;\n      });\n      redis = new Redis({\n        tls: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        redis.on(\"end\", () => done());\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"does not use tls option by default","suites":["tls option","Sentinel"],"updatePoint":{"line":42,"column":42,"index":1197},"line":42,"code":"    it(\"does not use tls option by default\", done => {\n      new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      const stub = sinon.stub(tls, \"connect\").callsFake(() => {\n        throw new Error(\"called\");\n      });\n      const redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        tls: {\n          ca: \"123\"\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        done();\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"can be enabled by `enableTLSForSentinelMode`","suites":["tls option","Sentinel"],"updatePoint":{"line":66,"column":52,"index":1837},"line":66,"code":"    it(\"can be enabled by `enableTLSForSentinelMode`\", done => {\n      new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      let redis;\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-ignore\n        expect(op.ca).to.eql(\"123\"); // @ts-ignore\n\n        expect(op.servername).to.eql(\"localhost\"); // @ts-ignore\n\n        expect(op.rejectUnauthorized).to.eql(false);\n        redis.disconnect();\n        stub.restore();\n        process.nextTick(done);\n        return tls.connect(op);\n      });\n      redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        tls: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        },\n        enableTLSForSentinelMode: true\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"supports sentinelTLS","suites":["tls option","Sentinel"],"updatePoint":{"line":98,"column":28,"index":2740},"line":98,"code":"    it(\"supports sentinelTLS\", done => {\n      new MockServer(27379, function (argv) {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      let redis; // @ts-ignore\n\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-ignore\n        expect(op.ca).to.eql(\"123\"); // @ts-ignore\n\n        expect(op.servername).to.eql(\"localhost\"); // @ts-ignore\n\n        expect(op.rejectUnauthorized).to.eql(false); // @ts-ignore\n\n        expect(op.port).to.eql(27379);\n        const stream = net.createConnection(op);\n        stream.on(\"connect\", data => {\n          stream.emit(\"secureConnect\", data);\n        });\n        return stream;\n      });\n      redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        sentinelTLS: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        redis.on(\"end\", () => done());\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"should works like pipeline by default","suites":["transaction"],"updatePoint":{"line":5,"column":43,"index":191},"line":5,"code":"  it(\"should works like pipeline by default\", function (done) {\n    const redis = new Redis();\n    redis.multi().set(\"foo\", \"transaction\").get(\"foo\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result).to.eql([[null, \"OK\"], [null, \"transaction\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle runtime errors correctly","suites":["transaction"],"updatePoint":{"line":13,"column":44,"index":500},"line":13,"code":"  it(\"should handle runtime errors correctly\", function (done) {\n    const redis = new Redis();\n    redis.multi().set(\"foo\", \"bar\").lpush(\"foo\", \"abc\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result.length).to.eql(2);\n      expect(result[0]).to.eql([null, \"OK\"]);\n      expect(result[1][0]).to.be.instanceof(Error);\n      expect(result[1][0].toString()).to.match(/wrong kind of value/);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle compile-time errors correctly","suites":["transaction"],"updatePoint":{"line":24,"column":49,"index":955},"line":24,"code":"  it(\"should handle compile-time errors correctly\", function (done) {\n    const redis = new Redis();\n    redis.multi().set(\"foo\").get(\"foo\").exec(function (err) {\n      expect(err).to.be.instanceof(Error);\n      expect(err.toString()).to.match(/Transaction discarded because of previous errors/);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should also support command callbacks","suites":["transaction"],"updatePoint":{"line":32,"column":43,"index":1274},"line":32,"code":"  it(\"should also support command callbacks\", function (done) {\n    const redis = new Redis();\n    let pending = 1;\n    redis.multi().set(\"foo\", \"bar\").get(\"foo\", function (err, value) {\n      pending -= 1;\n      expect(value).to.eql(\"QUEUED\");\n    }).exec(function (err, result) {\n      expect(pending).to.eql(0);\n      expect(result).to.eql([[null, \"OK\"], [null, \"bar\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should also handle errors in command callbacks","suites":["transaction"],"updatePoint":{"line":44,"column":52,"index":1686},"line":44,"code":"  it(\"should also handle errors in command callbacks\", function (done) {\n    const redis = new Redis();\n    let pending = 1;\n    redis.multi().set(\"foo\", function (err) {\n      expect(err.toString()).to.match(/wrong number of arguments/);\n      pending -= 1;\n    }).exec(function (err) {\n      expect(err.toString()).to.match(/Transaction discarded because of previous errors/);\n\n      if (!pending) {\n        done();\n      }\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should work without pipeline","suites":["transaction"],"updatePoint":{"line":58,"column":34,"index":2108},"line":58,"code":"  it(\"should work without pipeline\", function (done) {\n    const redis = new Redis();\n    redis.multi({\n      pipeline: false\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\");\n    redis.exec(function (err, results) {\n      expect(results).to.eql([[null, \"OK\"], [null, \"bar\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should trigger transformer","suites":["transaction","transformer"],"updatePoint":{"line":71,"column":34,"index":2463},"line":71,"code":"    it(\"should trigger transformer\", function (done) {\n      const redis = new Redis();\n      let pending = 2;\n      const data = {\n        name: \"Bob\",\n        age: \"17\"\n      };\n      redis.multi().hmset(\"foo\", data).hgetall(\"foo\", function (err, res) {\n        expect(res).to.eql(\"QUEUED\");\n\n        if (! --pending) {\n          done();\n        }\n      }).hgetallBuffer(\"foo\").get(\"foo\").getBuffer(\"foo\").exec(function (err, res) {\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(data);\n        expect(res[2][1]).to.eql({\n          name: Buffer.from(\"Bob\"),\n          age: Buffer.from(\"17\")\n        });\n        expect(res[3][0]).to.have.property(\"message\", \"WRONGTYPE Operation against a key holding the wrong kind of value\");\n        expect(res[4][0]).to.have.property(\"message\", \"WRONGTYPE Operation against a key holding the wrong kind of value\");\n\n        if (! --pending) {\n          done();\n        }\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should trigger transformer inside pipeline","suites":["transaction","transformer"],"updatePoint":{"line":99,"column":50,"index":3432},"line":99,"code":"    it(\"should trigger transformer inside pipeline\", function (done) {\n      const redis = new Redis();\n      const data = {\n        name: \"Bob\",\n        age: \"17\"\n      };\n      redis.pipeline().hmset(\"foo\", data).multi().typeBuffer(\"foo\").hgetall(\"foo\").exec().hgetall(\"foo\").exec(function (err, res) {\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(\"OK\");\n        expect(res[2][1]).to.eql(Buffer.from(\"QUEUED\"));\n        expect(res[3][1]).to.eql(\"QUEUED\");\n        expect(res[4][1]).to.eql([Buffer.from(\"hash\"), data]);\n        expect(res[5][1]).to.eql(data);\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle custom transformer exception","suites":["transaction","transformer"],"updatePoint":{"line":115,"column":50,"index":4055},"line":115,"code":"    it(\"should handle custom transformer exception\", function (done) {\n      const transformError = \"transformer error\"; // @ts-ignore\n\n      Command._transformer.reply.get = function () {\n        throw new Error(transformError);\n      };\n\n      const redis = new Redis();\n      redis.multi().get(\"foo\").exec(function (err, res) {\n        expect(res[0][0]).to.have.property(\"message\", transformError); // @ts-ignore\n\n        delete Command._transformer.reply.get;\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should accept commands in constructor","suites":["transaction","#addBatch"],"updatePoint":{"line":132,"column":45,"index":4592},"line":132,"code":"    it(\"should accept commands in constructor\", function (done) {\n      const redis = new Redis();\n      let pending = 1;\n      redis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\", function (err, result) {\n        expect(result).to.eql(\"QUEUED\");\n        pending -= 1;\n      }]]).exec(function (err, results) {\n        expect(pending).to.eql(0);\n        expect(results[1][1]).to.eql(\"bar\");\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should batch all commands before ready event","suites":["transaction","#exec"],"updatePoint":{"line":146,"column":52,"index":5062},"line":146,"code":"    it(\"should batch all commands before ready event\", function (done) {\n      const redis = new Redis();\n      redis.on(\"connect\", function () {\n        redis.multi().info().config(\"get\", \"maxmemory\").exec(function (err, res) {\n          expect(err).to.eql(null);\n          expect(res).to.have.lengthOf(2);\n          expect(res[0][0]).to.eql(null);\n          expect(typeof res[0][1]).to.eql(\"string\");\n          expect(res[1][0]).to.eql(null);\n          expect(Array.isArray(res[1][1])).to.eql(true);\n          done();\n        });\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":7,"column":31,"index":273},"line":7,"code":"      it(\"should support object\", function (done) {\n        const redis = new Redis();\n        redis.hmset(\"foo\", {\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.hget(\"foo\", \"b\", function (err, result) {\n            expect(result).to.eql(\"2\");\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":20,"column":28,"index":648},"line":20,"code":"      it(\"should support Map\", function (done) {\n        if (typeof Map === \"undefined\") {\n          return done();\n        }\n\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        redis.hmset(\"foo\", map, function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.hget(\"foo\", \"b\", function (err, result) {\n            expect(result).to.eql(\"2\");\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":37,"column":39,"index":1154},"line":37,"code":"      it(\"should not affect the old way\", function (done) {\n        const redis = new Redis();\n        redis.hmset(\"foo\", \"a\", 1, \"b\", \"2\", function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.hget(\"foo\", \"b\", function (err, result) {\n            expect(result).to.eql(\"2\");\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","mset"],"updatePoint":{"line":49,"column":31,"index":1547},"line":49,"code":"      it(\"should support object\", function (done) {\n        const redis = new Redis();\n        redis.mset({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","mset"],"updatePoint":{"line":62,"column":28,"index":1919},"line":62,"code":"      it(\"should support Map\", function (done) {\n        if (typeof Map === \"undefined\") {\n          return done();\n        }\n\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        redis.mset(map, function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","mset"],"updatePoint":{"line":79,"column":39,"index":2422},"line":79,"code":"      it(\"should not affect the old way\", function (done) {\n        const redis = new Redis();\n        redis.mset(\"a\", 1, \"b\", \"2\", function (err, result) {\n          expect(result).to.eql(\"OK\");\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should work with keyPrefix option","suites":["transformer","default transformer","mset"],"updatePoint":{"line":89,"column":43,"index":2781},"line":89,"code":"      it(\"should work with keyPrefix option\", function (done) {\n        const redis = new Redis({\n          keyPrefix: \"foo:\"\n        });\n        redis.mset({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(\"OK\");\n          const otherRedis = new Redis();\n          otherRedis.mget(\"foo:a\", \"foo:b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":107,"column":31,"index":3295},"line":107,"code":"      it(\"should support object\", function (done) {\n        const redis = new Redis();\n        redis.msetnx({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":120,"column":28,"index":3666},"line":120,"code":"      it(\"should support Map\", function (done) {\n        if (typeof Map === \"undefined\") {\n          return done();\n        }\n\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        redis.msetnx(map, function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":137,"column":39,"index":4168},"line":137,"code":"      it(\"should not affect the old way\", function (done) {\n        const redis = new Redis();\n        redis.msetnx(\"a\", 1, \"b\", \"2\", function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should work with keyPrefix option","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":147,"column":43,"index":4526},"line":147,"code":"      it(\"should work with keyPrefix option\", function (done) {\n        const redis = new Redis({\n          keyPrefix: \"foo:\"\n        });\n        redis.msetnx({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(1);\n          const otherRedis = new Redis();\n          otherRedis.mget(\"foo:a\", \"foo:b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should return an object","suites":["transformer","default transformer","hgetall"],"updatePoint":{"line":165,"column":33,"index":5042},"line":165,"code":"      it(\"should return an object\", function (done) {\n        const redis = new Redis();\n        redis.hmset(\"foo\", \"k1\", \"v1\", \"k2\", \"v2\", function () {\n          redis.hgetall(\"foo\", function (err, result) {\n            expect(result).to.eql({\n              k1: \"v1\",\n              k2: \"v2\"\n            });\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should return {} when key not exists","suites":["transformer","default transformer","hgetall"],"updatePoint":{"line":177,"column":46,"index":5420},"line":177,"code":"      it(\"should return {} when key not exists\", function (done) {\n        const redis = new Redis();\n        redis.hgetall(\"foo\", function (err, result) {\n          expect(result).to.eql({});\n          done();\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","hset"],"updatePoint":{"line":186,"column":31,"index":5681},"line":186,"code":"      it(\"should support object\", async function () {\n        const redis = new Redis();\n        const [major] = await getRedisVersion(redis);\n\n        if (major < 4) {\n          // Skip if redis is too outdated to hset multiple pairs at once.\n          return;\n        } // NOTE: could simplify these tests using await redis.hset instead,\n        // but not sure if this is deliberately testing the transformers with callbacks\n\n\n        return new Promise((resolve, reject) => {\n          redis.hset(\"foo\", {\n            a: 1,\n            b: \"e\",\n            c: 123\n          }, function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            expect(result).to.eql(3);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","hset"],"updatePoint":{"line":215,"column":28,"index":6572},"line":215,"code":"      it(\"should support Map\", async function () {\n        if (typeof Map === \"undefined\") {\n          return;\n        }\n\n        const redis = new Redis();\n        const [major] = await getRedisVersion(redis);\n\n        if (major < 4) {\n          // Skip if redis is too outdated to hset multiple pairs at once.\n          return;\n        }\n\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"e\");\n        return new Promise((resolve, reject) => {\n          redis.hset(\"foo\", map, function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            expect(result).to.eql(2);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              if (err) {\n                return reject(err);\n              }\n\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should affect the old way","suites":["transformer","default transformer","hset"],"updatePoint":{"line":249,"column":35,"index":7478},"line":249,"code":"      it(\"should affect the old way\", async function () {\n        const redis = new Redis();\n        const [major] = await getRedisVersion(redis);\n\n        if (major < 4) {\n          // Skip if redis is too outdated to hset multiple pairs at once.\n          return;\n        }\n\n        return new Promise(resolve => {\n          redis.hset(\"foo\", \"a\", 1, \"b\", \"e\", function (err, result) {\n            expect(result).to.eql(2);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support watch/exec transactions","suites":["watch-exec"],"updatePoint":{"line":4,"column":44,"index":150},"line":4,"code":"  it(\"should support watch/exec transactions\", function () {\n    const redis1 = new Redis();\n    return redis1.watch(\"watchkey\").then(function () {\n      return redis1.multi().set(\"watchkey\", \"1\").exec();\n    }).then(function (result) {\n      expect(result.length).to.eql(1);\n      expect(result[0]).to.eql([null, \"OK\"]);\n    });\n  });","file":"functional/watch-exec.ts","skipped":false,"dir":"test"},{"name":"should support watch/exec transaction rollback","suites":["watch-exec"],"updatePoint":{"line":13,"column":52,"index":494},"line":13,"code":"  it(\"should support watch/exec transaction rollback\", function () {\n    const redis1 = new Redis();\n    const redis2 = new Redis();\n    return redis1.watch(\"watchkey\").then(function () {\n      return redis2.set(\"watchkey\", \"2\");\n    }).then(function () {\n      return redis1.multi().set(\"watchkey\", \"1\").exec();\n    }).then(function (result) {\n      expect(result).to.be.null;\n    });\n  });","file":"functional/watch-exec.ts","skipped":false,"dir":"test"},{"name":"should be able to efficiently get array args","suites":["autoPipelining"],"updatePoint":{"line":12,"column":50,"index":542},"line":12,"code":"  it(\"should be able to efficiently get array args\", function () {\n    expectGetFirstValueIs([], undefined);\n    expectGetFirstValueIs([null, \"key\"], null);\n    expectGetFirstValueIs([\"key\", \"value\"], \"key\");\n    expectGetFirstValueIs([[], \"key\"], \"key\");\n    expectGetFirstValueIs([[\"key\"]], \"key\"); // @ts-ignore\n\n    expectGetFirstValueIs([[[\"key\"]]], [\"key\"]); // @ts-ignore\n\n    expectGetFirstValueIs([0, 1, 2, 3, 4], 0); // @ts-ignore\n\n    expectGetFirstValueIs([[true]], true); // @ts-ignore\n\n    expectGetFirstValueIs([Buffer.from(\"test\")], Buffer.from(\"test\")); // @ts-ignore\n\n    expectGetFirstValueIs([{}], {}); // lodash.isArguments is true for this legacy js way to get argument lists\n\n    const createArguments = function () {\n      return arguments;\n    }; // @ts-ignore\n\n\n    expectGetFirstValueIs([createArguments(), createArguments(\"key\")], \"key\"); // @ts-ignore\n\n    expectGetFirstValueIs([createArguments(\"\")], \"\");\n  });","file":"unit/autoPipelining.ts","skipped":false,"dir":"test"},{"name":"prefers to master if there are two same node for a slot","suites":["ConnectionPool","#reset"],"updatePoint":{"line":6,"column":63,"index":257},"line":6,"code":"    it(\"prefers to master if there are two same node for a slot\", () => {\n      const pool = new ConnectionPool({});\n      const stub = sinon.stub(pool, \"findOrCreate\");\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: true\n      }, {\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }]);\n      expect(stub.callCount).to.eql(1);\n      expect(stub.firstCall.args[1]).to.eql(false);\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }, {\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: true\n      }]);\n      expect(stub.callCount).to.eql(2);\n      expect(stub.firstCall.args[1]).to.eql(false);\n    });","file":"unit/clusters/ConnectionPool.ts","skipped":false,"dir":"test"},{"name":"remove the node immediately instead of waiting for 'end' event","suites":["ConnectionPool","#reset"],"updatePoint":{"line":32,"column":70,"index":996},"line":32,"code":"    it(\"remove the node immediately instead of waiting for 'end' event\", () => {\n      const pool = new ConnectionPool({});\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 300001\n      }]);\n      expect(pool.getNodes().length).to.eql(1);\n      pool.reset([]);\n      expect(pool.getNodes().length).to.eql(0);\n    });","file":"unit/clusters/ConnectionPool.ts","skipped":false,"dir":"test"},{"name":"should support frozen options","suites":["cluster"],"updatePoint":{"line":12,"column":35,"index":427},"line":12,"code":"  it(\"should support frozen options\", function () {\n    const options = Object.freeze({\n      maxRedirections: 1000\n    });\n    const cluster = new Cluster([{\n      port: 7777\n    }], options);\n    expect(cluster.options).to.have.property(\"maxRedirections\", 1000);\n    expect(cluster.options).to.have.property(\"showFriendlyErrorStack\", false);\n    expect(cluster.options).to.have.property(\"scaleReads\", \"master\");\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"should allow overriding Commander options","suites":["cluster"],"updatePoint":{"line":23,"column":47,"index":859},"line":23,"code":"  it(\"should allow overriding Commander options\", function () {\n    const cluster = new Cluster([{\n      port: 7777\n    }], {\n      showFriendlyErrorStack: true\n    });\n    expect(cluster.options).to.have.property(\"showFriendlyErrorStack\", true);\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"throws when scaleReads is invalid","suites":["cluster"],"updatePoint":{"line":31,"column":39,"index":1104},"line":31,"code":"  it(\"throws when scaleReads is invalid\", function () {\n    expect(function () {\n      new Cluster([{}], {\n        scaleReads: \"invalid\"\n      });\n    }).to.throw(/Invalid option scaleReads/);\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"throws when role is invalid","suites":["cluster","#nodes()"],"updatePoint":{"line":39,"column":35,"index":1336},"line":39,"code":"    it(\"throws when role is invalid\", function () {\n      const cluster = new Cluster([{}]);\n      expect(function () {\n        cluster.nodes(\"invalid\");\n      }).to.throw(/Invalid role/);\n    });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"returns correct result","suites":["nodeKeyToRedisOptions()"],"updatePoint":{"line":48,"column":28,"index":1580},"line":48,"code":"  it(\"returns correct result\", () => {\n    expect(nodeKeyToRedisOptions(\"127.0.0.1:6379\")).to.eql({\n      port: 6379,\n      host: \"127.0.0.1\"\n    });\n    expect(nodeKeyToRedisOptions(\"192.168.1.1:30001\")).to.eql({\n      port: 30001,\n      host: \"192.168.1.1\"\n    });\n    expect(nodeKeyToRedisOptions(\"::0:6379\")).to.eql({\n      port: 6379,\n      host: \"::0\"\n    });\n    expect(nodeKeyToRedisOptions(\"0:0:6379\")).to.eql({\n      port: 6379,\n      host: \"0:0\"\n    });\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"should flatten the args","suites":["Command","constructor()"],"updatePoint":{"line":5,"column":31,"index":180},"line":5,"code":"    it(\"should flatten the args\", function () {\n      const command = new Command(\"get\", [\"foo\", [\"bar\", [\"zoo\", \"zoo\"]]]);\n      expect(command.args).to.eql([\"foo\", \"bar\", \"zoo,zoo\"]);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correct string","suites":["Command","#toWritable()"],"updatePoint":{"line":11,"column":36,"index":427},"line":11,"code":"    it(\"should return correct string\", function () {\n      const command = new Command(\"get\", [\"foo\", \"bar\", \"zooo\"]);\n      expect(command.toWritable()).to.eql(\"*4\\r\\n$3\\r\\nget\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n$4\\r\\nzooo\\r\\n\");\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return buffer when there's at least one arg is a buffer","suites":["Command","#toWritable()"],"updatePoint":{"line":15,"column":70,"index":694},"line":15,"code":"    it(\"should return buffer when there's at least one arg is a buffer\", function () {\n      const command = new Command(\"get\", [\"foo\", Buffer.from(\"bar\"), \"zooo\"]);\n      const result = command.toWritable();\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"*4\\r\\n$3\\r\\nget\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n$4\\r\\nzooo\\r\\n\");\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return buffer when replyEncoding is not set","suites":["Command","#resolve()"],"updatePoint":{"line":23,"column":58,"index":1094},"line":23,"code":"    it(\"should return buffer when replyEncoding is not set\", function (done) {\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: null\n      }, function (err, result) {\n        expect(result).to.be.instanceof(Buffer);\n        expect(result.toString()).to.eql(\"foo\");\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should covert result to string if replyEncoding is specified","suites":["Command","#resolve()"],"updatePoint":{"line":33,"column":68,"index":1472},"line":33,"code":"    it(\"should covert result to string if replyEncoding is specified\", function (done) {\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: \"utf8\"\n      }, function (err, result) {\n        expect(result).to.eql(\"foo\");\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should regard replyEncoding","suites":["Command","#resolve()"],"updatePoint":{"line":42,"column":35,"index":1759},"line":42,"code":"    it(\"should regard replyEncoding\", function (done) {\n      const base64 = Buffer.from(\"foo\").toString(\"base64\");\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: \"base64\"\n      }, function (err, result) {\n        expect(result).to.eql(base64);\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return keys","suites":["Command","#getKeys()"],"updatePoint":{"line":54,"column":26,"index":2145},"line":54,"code":"    it(\"should return keys\", function () {\n      expect(getKeys(\"get\", [\"foo\"])).to.eql([\"foo\"]);\n      expect(getKeys(\"mget\", [\"foo\", \"bar\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"mset\", [\"foo\", \"v1\", \"bar\", \"v2\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"hmset\", [\"key\", \"foo\", \"v1\", \"bar\", \"v2\"])).to.eql([\"key\"]);\n      expect(getKeys(\"blpop\", [\"key1\", \"key2\", \"17\"])).to.eql([\"key1\", \"key2\"]);\n      expect(getKeys(\"evalsha\", [\"23123\", \"2\", \"foo\", \"bar\", \"zoo\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"evalsha\", [\"23123\", 2, \"foo\", \"bar\", \"zoo\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"sort\", [\"key\"])).to.eql([\"key\"]);\n      expect(getKeys(\"sort\", [\"key\", \"BY\", \"hash:*->field\"])).to.eql([\"key\", \"hash:*->field\"]);\n      expect(getKeys(\"sort\", [\"key\", \"BY\", \"hash:*->field\", \"LIMIT\", 2, 3, \"GET\", \"gk\", \"GET\", \"#\", \"Get\", \"gh->f*\", \"DESC\", \"ALPHA\", \"STORE\", \"store\"])).to.eql([\"key\", \"hash:*->field\", \"gk\", \"gh->f*\", \"store\"]);\n      expect(getKeys(\"zunionstore\", [\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3])).to.eql([\"out\", \"zset1\", \"zset2\"]);\n      expect(getKeys(\"zinterstore\", [\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3])).to.eql([\"out\", \"zset1\", \"zset2\"]);\n\n      function getKeys(commandName, args) {\n        const command = new Command(commandName, args);\n        return command.getKeys();\n      }\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["Command","#getSlot()"],"updatePoint":{"line":79,"column":31,"index":3657},"line":79,"code":"    it(\"should return correctly\", function () {\n      expectSlot(\"123\", 5970);\n      expectSlot(123, 5970);\n      expectSlot(\"ab{c\", 4619);\n      expectSlot(\"ab{c}2\", 7365);\n      expectSlot(\"ab{{c}2\", 2150);\n      expectSlot(\"ab{qq}{c}2\", 5598);\n      expectSlot(\"ab}\", 11817);\n      expectSlot(\"encoding\", 3060);\n      expectSlot(true, 13635);\n      expectSlot(\"true\", 13635);\n      expectSlot(\"\", 0);\n      expectSlot(null, 0);\n      expectSlot(undefined, 0);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"supports buffers","suites":["Command","#getSlot()"],"updatePoint":{"line":94,"column":24,"index":4121},"line":94,"code":"    it(\"supports buffers\", () => {\n      expectSlot(Buffer.from(\"encoding\"), 3060);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correct result","suites":["Command",".checkFlag()"],"updatePoint":{"line":99,"column":36,"index":4272},"line":99,"code":"    it(\"should return correct result\", function () {\n      expect(Command.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", \"ping\")).to.eql(true);\n      expect(Command.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", \"get\")).to.eql(false);\n      expect(Command.checkFlag(\"WILL_DISCONNECT\", \"quit\")).to.eql(true);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"returns a new copy of commands","suites":["Commander","#getBuiltinCommands()"],"updatePoint":{"line":6,"column":38,"index":227},"line":6,"code":"    it(\"returns a new copy of commands\", () => {\n      const c = new Commander();\n      const commands = c.getBuiltinCommands();\n      commands.unshift(\"abc\");\n      const commandsNew = c.getBuiltinCommands();\n      expect(commands.slice(1)).to.eql(commandsNew);\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"adds string command","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":17,"column":27,"index":643},"line":17,"code":"    it(\"adds string command\", () => {\n      const c = new Commander();\n      c.addBuiltinCommand(\"someCommand\");\n      c.someCommand();\n      const command = Commander.prototype.sendCommand.getCall(0).args[0];\n      expect(command.name).to.eql(\"someCommand\");\n      expect(command.replyEncoding).to.eql(\"utf8\");\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"adds buffer command","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":25,"column":27,"index":963},"line":25,"code":"    it(\"adds buffer command\", () => {\n      const c = new Commander();\n      c.addBuiltinCommand(\"someCommand\");\n      c.someCommandBuffer();\n      const command = Commander.prototype.sendCommand.getCall(0).args[0];\n      expect(command.name).to.eql(\"someCommand\");\n      expect(command.replyEncoding).to.eql(null);\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"should pass the correct arguments","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":34,"column":39,"index":1305},"line":34,"code":"  it(\"should pass the correct arguments\", function () {\n    sinon.stub(Commander.prototype, \"sendCommand\").callsFake(command => {\n      return command;\n    });\n    let command;\n    const c = new Commander();\n    command = c.call(\"set\", \"foo\", \"bar\");\n    expect(command.name).to.eql(\"set\");\n    expect(command.args[0]).to.eql(\"foo\");\n    expect(command.args[1]).to.eql(\"bar\");\n    command = c.callBuffer(\"set\", [\"foo\", \"bar\"]);\n    expect(command.name).to.eql(\"set\");\n    expect(command.args[0]).to.eql(\"foo\");\n    expect(command.args[1]).to.eql(\"bar\");\n    command = c.call(\"set\", \"foo\", \"bar\", function () {});\n    expect(command.name).to.eql(\"set\");\n    expect(command.args.length).to.eql(2);\n    command = c.callBuffer(\"set\", \"foo\", \"bar\", function () {});\n    expect(command.name).to.eql(\"set\");\n    expect(command.args.length).to.eql(2);\n    Commander.prototype.sendCommand.restore();\n  });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"first tries path","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":8,"column":24,"index":279},"line":8,"code":"    it(\"first tries path\", async () => {\n      const spy = sinon.spy(net, \"createConnection\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        path: \"/tmp\"\n      });\n\n      try {\n        const stream = await connector.connect(() => {});\n        stream.on(\"error\", () => {});\n      } catch (err) {// ignore errors\n      }\n\n      expect(spy.calledOnce).to.eql(true);\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"ignore path when port is set and path is null","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":24,"column":53,"index":741},"line":24,"code":"    it(\"ignore path when port is set and path is null\", async () => {\n      const spy = sinon.spy(net, \"createConnection\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        path: null\n      });\n      await connector.connect(() => {});\n      expect(spy.calledOnce).to.eql(true);\n      expect(spy.firstCall.args[0]).to.eql({\n        port: 6379\n      });\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":37,"column":20,"index":1127},"line":37,"code":"    it(\"supports tls\", async () => {\n      const spy = sinon.spy(tls, \"connect\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        tls: {\n          ca: \"on\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      await connector.connect(() => {});\n      expect(spy.calledOnce).to.eql(true);\n      expect(spy.firstCall.args[0]).to.eql({\n        port: 6379,\n        ca: \"on\",\n        servername: \"localhost\",\n        rejectUnauthorized: false\n      });\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"keep the options immutable","suites":["SentinelIterator"],"updatePoint":{"line":4,"column":32,"index":195},"line":4,"code":"  it(\"keep the options immutable\", () => {\n    function getSentinels() {\n      return [{\n        host: \"127.0.0.1\",\n        port: 30001\n      }];\n    }\n\n    const sentinels = getSentinels();\n    const iter = new SentinelIterator(sentinels);\n    iter.add({\n      host: \"127.0..0.1\",\n      port: 30002\n    });\n    expect(sentinels).to.eql(getSentinels());\n    expect(iter.next().value.port).to.eql(30001);\n    expect(iter.next().value.port).to.eql(30002);\n  });","file":"unit/connectors/SentinelConnector/SentinelIterator.ts","skipped":false,"dir":"test"},{"name":"prints logs","suites":["index","print()"],"updatePoint":{"line":6,"column":19,"index":186},"line":6,"code":"    it(\"prints logs\", function () {\n      const stub = sinon.stub(console, \"log\");\n      print(new Error(\"err\"));\n      print(null, \"success\");\n      expect(stub.calledTwice).to.eql(true);\n      stub.restore();\n    });","file":"unit/index.ts","skipped":false,"dir":"test"},{"name":"should properly mark commands as transactions","suites":["Pipeline"],"updatePoint":{"line":16,"column":51,"index":508},"line":16,"code":"  it(\"should properly mark commands as transactions\", function () {\n    const redis = new Redis();\n    const p = new Pipeline(redis);\n    let i = 0;\n\n    function validate(name, inTransaction) {\n      const command = p._queue[i++];\n      expect(command.name).to.eql(name);\n      expect(command.inTransaction).to.eql(inTransaction);\n    }\n\n    p.get();\n    p.multi();\n    p.get();\n    p.multi();\n    p.exec();\n    p.exec();\n    p.get();\n    validate(\"get\", false);\n    validate(\"multi\", true);\n    validate(\"get\", true);\n    validate(\"multi\", true);\n    validate(\"exec\", true);\n    validate(\"exec\", false);\n    validate(\"get\", false);\n  });","file":"unit/pipeline.ts","skipped":false,"dir":"test"},{"name":"should properly set pipelineIndex on commands","suites":["Pipeline"],"updatePoint":{"line":42,"column":51,"index":1148},"line":42,"code":"  it(\"should properly set pipelineIndex on commands\", function () {\n    const redis = new Redis();\n    const p = new Pipeline(redis);\n    let i = 0;\n\n    function validate(name) {\n      const command = p._queue[i];\n      expect(command.name).to.eql(name);\n      expect(command.pipelineIndex).to.eql(i);\n      i++;\n    }\n\n    p.get();\n    p.set();\n    p.del();\n    p.ping();\n    validate(\"get\");\n    validate(\"set\");\n    validate(\"del\");\n    validate(\"ping\");\n  });","file":"unit/pipeline.ts","skipped":false,"dir":"test"},{"name":"should parse options correctly","suites":["Redis","constructor"],"updatePoint":{"line":6,"column":38,"index":211},"line":6,"code":"    it(\"should parse options correctly\", function () {\n      const stub = sinon.stub(Redis.prototype, \"connect\").returns(Promise.resolve());\n      let option;\n\n      try {\n        option = getOption();\n        expect(option).to.have.property(\"port\", 6379);\n        expect(option).to.have.property(\"host\", \"localhost\");\n        expect(option).to.have.property(\"family\", 4);\n        option = getOption(6380);\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"localhost\");\n        option = getOption(\"6380\");\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption(6381, \"192.168.1.1\");\n        expect(option).to.have.property(\"port\", 6381);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption(6381, \"192.168.1.1\", {\n          password: \"123\",\n          db: 2\n        });\n        expect(option).to.have.property(\"port\", 6381);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        expect(option).to.have.property(\"password\", \"123\");\n        expect(option).to.have.property(\"db\", 2);\n        option = getOption(\"redis://:authpassword@127.0.0.1:6380/4\");\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"127.0.0.1\");\n        expect(option).to.have.property(\"password\", \"authpassword\");\n        expect(option).to.have.property(\"db\", 4);\n        option = getOption(\"redis://:1+1@127.0.0.1:6380\");\n        expect(option).to.have.property(\"password\", \"1+1\");\n        option = getOption(`redis://127.0.0.1:6380/?password=${encodeURIComponent(\"1+1\")}`);\n        expect(option).to.have.property(\"password\", \"1+1\");\n        option = getOption(\"redis://127.0.0.1/\");\n        expect(option).to.have.property(\"db\", 0);\n        option = getOption(\"/tmp/redis.sock\");\n        expect(option).to.have.property(\"path\", \"/tmp/redis.sock\");\n        option = getOption({\n          port: 6380,\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption({\n          path: \"/tmp/redis.sock\"\n        });\n        expect(option).to.have.property(\"path\", \"/tmp/redis.sock\");\n        option = getOption({\n          port: \"6380\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption({\n          showFriendlyErrorStack: true\n        });\n        expect(option).to.have.property(\"showFriendlyErrorStack\", true);\n        option = getOption(6380, {\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption(\"6380\", {\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption(\"rediss://host\");\n        expect(option).to.have.property(\"tls\", true);\n        option = getOption(\"rediss://example.test\", {\n          tls: {\n            hostname: \"example.test\"\n          }\n        });\n        expect(option.tls).to.deep.equal({\n          hostname: \"example.test\"\n        });\n      } catch (err) {\n        stub.restore();\n        throw err;\n      }\n\n      stub.restore();\n\n      function getOption(...args) {\n        // @ts-ignore\n        const redis = new Redis(...args);\n        return redis.options;\n      }\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should throw when arguments is invalid","suites":["Redis","constructor"],"updatePoint":{"line":94,"column":46,"index":3650},"line":94,"code":"    it(\"should throw when arguments is invalid\", function () {\n      expect(function () {\n        // @ts-ignore\n        new Redis(function () {});\n      }).to.throw(Error);\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should redirect to constructor","suites":["Redis",".createClient"],"updatePoint":{"line":102,"column":38,"index":3871},"line":102,"code":"    it(\"should redirect to constructor\", function () {\n      const redis = Redis.createClient({\n        name: \"pass\",\n        lazyConnect: true\n      });\n      expect(redis.options).to.have.property(\"name\", \"pass\");\n      expect(redis.options).to.have.property(\"lazyConnect\", true);\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should redirect to #disconnect","suites":["Redis","#end"],"updatePoint":{"line":112,"column":38,"index":4201},"line":112,"code":"    it(\"should redirect to #disconnect\", function (done) {\n      const redis = new Redis({\n        lazyConnect: true\n      });\n      const stub = sinon.stub(redis, \"disconnect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      redis.end();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should flush all queues by default","suites":["Redis","#flushQueue"],"updatePoint":{"line":124,"column":42,"index":4524},"line":124,"code":"    it(\"should flush all queues by default\", function () {\n      const flushQueue = Redis.prototype.flushQueue;\n      const redis = {\n        offlineQueue: [{\n          command: {\n            reject: function () {}\n          }\n        }],\n        commandQueue: [{\n          command: {\n            reject: function () {}\n          }\n        }]\n      };\n      const offline = sinon.mock(redis.offlineQueue[0].command);\n      const command = sinon.mock(redis.commandQueue[0].command);\n      offline.expects(\"reject\").once();\n      command.expects(\"reject\").once();\n      flushQueue.call(redis);\n      offline.verify();\n      command.verify();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should be able to ignore a queue","suites":["Redis","#flushQueue"],"updatePoint":{"line":146,"column":40,"index":5170},"line":146,"code":"    it(\"should be able to ignore a queue\", function () {\n      const flushQueue = Redis.prototype.flushQueue;\n      const redis = {\n        offlineQueue: [{\n          command: {\n            reject: function () {}\n          }\n        }],\n        commandQueue: [{\n          command: {\n            reject: function () {}\n          }\n        }]\n      };\n      const offline = sinon.mock(redis.offlineQueue[0].command);\n      const command = sinon.mock(redis.commandQueue[0].command);\n      offline.expects(\"reject\").once();\n      command.expects(\"reject\").never();\n      flushQueue.call(redis, new Error(), {\n        commandQueue: false\n      });\n      offline.verify();\n      command.verify();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".bufferEqual"],"updatePoint":{"line":7,"column":31,"index":269},"line":7,"code":"    it(\"should return correctly\", function () {\n      expect(utils.bufferEqual(Buffer.from(\"123\"), Buffer.from(\"abc\"))).to.eql(false);\n      expect(utils.bufferEqual(Buffer.from(\"abc\"), Buffer.from(\"abc\"))).to.eql(true);\n      expect(utils.bufferEqual(Buffer.from(\"bc\"), Buffer.from(\"abc\"))).to.eql(false);\n      expect(utils.bufferEqual(Buffer.from(\"\"), Buffer.from(\"\"))).to.eql(true);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should work when Buffer#equals not exists","suites":["utils",".bufferEqual"],"updatePoint":{"line":13,"column":49,"index":682},"line":13,"code":"    it(\"should work when Buffer#equals not exists\", function () {\n      const equals = Buffer.prototype.equals;\n      delete Buffer.prototype.equals;\n      expect(utils.bufferEqual(Buffer.from(\"123\"), Buffer.from(\"abc\"))).to.eql(false);\n      expect(utils.bufferEqual(Buffer.from(\"abc\"), Buffer.from(\"abc\"))).to.eql(true);\n      expect(utils.bufferEqual(Buffer.from(\"bc\"), Buffer.from(\"abc\"))).to.eql(false);\n      expect(utils.bufferEqual(Buffer.from(\"\"), Buffer.from(\"\"))).to.eql(true);\n      Buffer.prototype.equals = equals;\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertBufferToString"],"updatePoint":{"line":24,"column":31,"index":1258},"line":24,"code":"    it(\"should return correctly\", function () {\n      expect(utils.convertBufferToString(Buffer.from(\"123\"))).to.eql(\"123\");\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), Buffer.from(\"abc\")])).to.eql([\"abc\", \"abc\"]);\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), [[Buffer.from(\"abc\")]]])).to.eql([\"abc\", [[\"abc\"]]]);\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), 5, \"b\", [[Buffer.from(\"abc\"), 4]]])).to.eql([\"abc\", 5, \"b\", [[\"abc\", 4]]]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".wrapMultiResult"],"updatePoint":{"line":32,"column":31,"index":1804},"line":32,"code":"    it(\"should return correctly\", function () {\n      expect(utils.wrapMultiResult(null)).to.eql(null);\n      expect(utils.wrapMultiResult([1, 2])).to.eql([[null, 1], [null, 2]]);\n      const error = new Error(\"2\");\n      expect(utils.wrapMultiResult([1, 2, error])).to.eql([[null, 1], [null, 2], [error]]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".isInt"],"updatePoint":{"line":40,"column":31,"index":2161},"line":40,"code":"    it(\"should return correctly\", function () {\n      expect(utils.isInt(2)).to.eql(true);\n      expect(utils.isInt(\"2231\")).to.eql(true);\n      expect(utils.isInt(\"s\")).to.eql(false);\n      expect(utils.isInt(\"1s\")).to.eql(false);\n      expect(utils.isInt(false)).to.eql(false);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".packObject"],"updatePoint":{"line":49,"column":31,"index":2495},"line":49,"code":"    it(\"should return correctly\", function () {\n      expect(utils.packObject([1, 2])).to.eql({\n        1: 2\n      });\n      expect(utils.packObject([1, \"2\"])).to.eql({\n        1: \"2\"\n      });\n      expect(utils.packObject([1, \"2\", \"abc\", \"def\"])).to.eql({\n        1: \"2\",\n        abc: \"def\"\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return a callback","suites":["utils",".timeout"],"updatePoint":{"line":63,"column":32,"index":2850},"line":63,"code":"    it(\"should return a callback\", function (done) {\n      let invoked = false;\n      const wrappedCallback1 = utils.timeout(function () {\n        invoked = true;\n      }, 0);\n      wrappedCallback1();\n      let invokedTimes = 0;\n      var wrappedCallback2 = utils.timeout(function (err) {\n        expect(err.message).to.match(/timeout/);\n        invokedTimes += 1;\n        wrappedCallback2();\n        setTimeout(function () {\n          expect(invoked).to.eql(true);\n          expect(invokedTimes).to.eql(1);\n          done();\n        }, 0);\n      }, 0);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertObjectToArray"],"updatePoint":{"line":83,"column":31,"index":3468},"line":83,"code":"    it(\"should return correctly\", function () {\n      const nullObject = Object.create(null);\n      nullObject.abc = \"def\";\n      expect(utils.convertObjectToArray(nullObject)).to.eql([\"abc\", \"def\"]);\n      expect(utils.convertObjectToArray({\n        1: 2\n      })).to.eql([\"1\", 2]);\n      expect(utils.convertObjectToArray({\n        1: \"2\"\n      })).to.eql([\"1\", \"2\"]);\n      expect(utils.convertObjectToArray({\n        1: \"2\",\n        abc: \"def\"\n      })).to.eql([\"1\", \"2\", \"abc\", \"def\"]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertMapToArray"],"updatePoint":{"line":100,"column":31,"index":4021},"line":100,"code":"    it(\"should return correctly\", function () {\n      if (typeof Map !== \"undefined\") {\n        expect(utils.convertMapToArray(new Map([[\"1\", 2]]))).to.eql([\"1\", 2]);\n        expect(utils.convertMapToArray(new Map([[1, 2]]))).to.eql([1, 2]);\n        expect(utils.convertMapToArray(new Map() < number | string, string > [[1, \"2\"], [\"abc\", \"def\"]])).to.eql([1, \"2\", \"abc\", \"def\"]);\n      }\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".toArg"],"updatePoint":{"line":109,"column":31,"index":4458},"line":109,"code":"    it(\"should return correctly\", function () {\n      expect(utils.toArg(null)).to.eql(\"\");\n      expect(utils.toArg(undefined)).to.eql(\"\");\n      expect(utils.toArg(\"abc\")).to.eql(\"abc\");\n      expect(utils.toArg(123)).to.eql(\"123\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".optimizeErrorStack"],"updatePoint":{"line":117,"column":31,"index":4755},"line":117,"code":"    it(\"should return correctly\", function () {\n      const error = new Error();\n      const res = utils.optimizeErrorStack(error, new Error().stack + \"\\n@\", __dirname);\n      expect(res.stack.split(\"\\n\").pop()).to.eql(\"@\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".parseURL"],"updatePoint":{"line":124,"column":31,"index":5032},"line":124,"code":"    it(\"should return correctly\", function () {\n      expect(utils.parseURL(\"/tmp.sock\")).to.eql({\n        path: \"/tmp.sock\"\n      });\n      expect(utils.parseURL(\"127.0.0.1\")).to.eql({\n        host: \"127.0.0.1\"\n      });\n      expect(utils.parseURL(\"6379\")).to.eql({\n        port: \"6379\"\n      });\n      expect(utils.parseURL(\"127.0.0.1:6379\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6379\"\n      });\n      expect(utils.parseURL(\"127.0.0.1:6379?db=2&key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6379\",\n        db: \"2\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user:pass@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        password: \"pass\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user:pass:word@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        password: \"pass:word\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        password: \"\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://127.0.0.1/\")).to.eql({\n        host: \"127.0.0.1\"\n      });\n      expect(utils.parseURL(\"rediss://user:pass@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        password: \"pass\",\n        key: \"value\"\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"supports allowUsernameInURI","suites":["utils",".parseURL"],"updatePoint":{"line":176,"column":35,"index":6559},"line":176,"code":"    it(\"supports allowUsernameInURI\", function () {\n      expect(utils.parseURL(\"redis://user:pass@127.0.0.1:6380/4?allowUsernameInURI=true\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"pass\"\n      });\n      expect(utils.parseURL(\"redis://user:pass@127.0.0.1:6380/4?allowUsernameInURI=false\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        password: \"pass\"\n      });\n      expect(utils.parseURL(\"redis://user:pass:word@127.0.0.1:6380/4?key=value&allowUsernameInURI=true\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"pass:word\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user@127.0.0.1:6380/4?key=value&allowUsernameInURI=true\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://127.0.0.1/?allowUsernameInURI=true\")).to.eql({\n        host: \"127.0.0.1\"\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should leave options alone when no tls profile is set","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":212,"column":61,"index":7766},"line":212,"code":"    it(\"should leave options alone when no tls profile is set\", function () {\n      [{}, {\n        tls: true\n      }, {\n        tls: false\n      }, {\n        tls: \"foo\"\n      }, {\n        tls: {}\n      }, {\n        tls: {\n          ca: \"foo\"\n        }\n      }, {\n        tls: {\n          profile: \"foo\"\n        }\n      }].forEach(options => {\n        expect(utils.resolveTLSProfile(options)).to.eql(options);\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should have redis.com profiles defined","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":233,"column":46,"index":8178},"line":233,"code":"    it(\"should have redis.com profiles defined\", function () {\n      expect(TLSProfiles).to.have.property(\"RedisCloudFixed\");\n      expect(TLSProfiles).to.have.property(\"RedisCloudFlexible\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should read profile from options.tls.profile","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":237,"column":52,"index":8384},"line":237,"code":"    it(\"should read profile from options.tls.profile\", function () {\n      const input = {\n        tls: {\n          profile: \"RedisCloudFixed\"\n        }\n      };\n      const expected = {\n        tls: TLSProfiles.RedisCloudFixed\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should read profile from options.tls","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":248,"column":44,"index":8684},"line":248,"code":"    it(\"should read profile from options.tls\", function () {\n      const input = {\n        tls: \"RedisCloudFixed\"\n      };\n      const expected = {\n        tls: TLSProfiles.RedisCloudFixed\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"supports extra options when using options.tls.profile","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":257,"column":61,"index":8970},"line":257,"code":"    it(\"supports extra options when using options.tls.profile\", function () {\n      const input = {\n        tls: {\n          profile: \"RedisCloudFixed\",\n          key: \"foo\"\n        }\n      };\n      const expected = {\n        tls: { ...TLSProfiles.RedisCloudFixed,\n          key: \"foo\"\n        }\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return a random value","suites":["utils",".sample"],"updatePoint":{"line":273,"column":36,"index":9363},"line":273,"code":"    it(\"should return a random value\", function () {\n      let stub = sinon.stub(Math, \"random\").callsFake(() => 0);\n      expect(utils.sample([1, 2, 3])).to.eql(1);\n      expect(utils.sample([1, 2, 3], 1)).to.eql(2);\n      expect(utils.sample([1, 2, 3], 2)).to.eql(3);\n      stub.restore();\n      stub = sinon.stub(Math, \"random\").callsFake(() => 0.999999);\n      expect(utils.sample([1, 2, 3])).to.eql(3);\n      expect(utils.sample([1, 2, 3], 1)).to.eql(3);\n      expect(utils.sample([1, 2, 3], 2)).to.eql(3);\n      stub.restore();\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"contains all items","suites":["utils",".shuffle"],"updatePoint":{"line":309,"column":26,"index":10382},"line":309,"code":"    it(\"contains all items\", () => {\n      testShuffle([1]);\n      testShuffle([1, 2]);\n      testShuffle([2, 1]);\n      testShuffle([1, 1, 1]);\n      testShuffle([1, 2, 3]);\n      testShuffle([3, -1, 0, 2, -1]);\n      testShuffle([\"a\", \"b\", \"d\", \"c\"]);\n      testShuffle([\"c\", \"b\"]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"mutates the original array","suites":["utils",".shuffle"],"updatePoint":{"line":319,"column":34,"index":10683},"line":319,"code":"    it(\"mutates the original array\", () => {\n      const arr = [3, 7];\n      const ret = utils.shuffle(arr);\n      expect(arr === ret).to.eql(true);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"shuffles the array","suites":["utils",".shuffle"],"updatePoint":{"line":324,"column":26,"index":10832},"line":324,"code":"    it(\"shuffles the array\", () => {\n      const arr = [1, 2, 3, 4];\n      const copy = arr.slice(0); // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        utils.shuffle(copy);\n\n        for (let i = 0; i < copy.length; i++) {\n          if (arr[i] !== copy[i]) {\n            return;\n          }\n        }\n      }\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"}]}