{"repo":"n8n-io/n8n","url":"https://github.com/n8n-io/n8n","branch":"master","configs":[{"package":"n8n","lang":"ts","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-core","lang":"ts","dir":"packages/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-editor-ui","lang":"js","dir":"packages/editor-ui/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-nodes-base","lang":"ts","dir":"packages/nodes-base/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-workflow","lang":"ts","dir":"packages/workflow/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should report credentials not in any use","suites":[],"updatePoint":{"line":22,"column":46},"line":22,"code":"test('should report credentials not in any use', async () => {\n\tconst credentialDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Slack Credential',\n\t\tdata: 'U2FsdGVkX18WjITBG4IDqrGB1xE/uzVNjtwDAG3lP7E=',\n\t\ttype: 'slackApi',\n\t\tnodesAccess: [{ nodeType: 'n8n-nodes-base.slack', date: '2022-12-21T11:23:00.561Z' }],\n\t};\n\n\tconst workflowDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Test Workflow',\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodeTypes: {},\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: uuid(),\n\t\t\t\tname: 'My Node',\n\t\t\t\ttype: 'n8n-nodes-base.slack',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t},\n\t\t],\n\t};\n\n\tawait Promise.all([\n\t\tDb.collections.Credentials.save(credentialDetails),\n\t\tDb.collections.Workflow.save(workflowDetails),\n\t]);\n\n\tconst testAudit = await audit(['credentials']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tCREDENTIALS_REPORT.RISK,\n\t\tCREDENTIALS_REPORT.SECTIONS.CREDS_NOT_IN_ANY_USE,\n\t);\n\n\texpect(section.location).toHaveLength(1);\n\texpect(section.location[0]).toMatchObject({\n\t\tid: credentialDetails.id,\n\t\tname: 'My Slack Credential',\n\t});\n});","file":"integration/audit/credentials.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report credentials not in active use","suites":[],"updatePoint":{"line":68,"column":49},"line":68,"code":"test('should report credentials not in active use', async () => {\n\tconst credentialDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Slack Credential',\n\t\tdata: 'U2FsdGVkX18WjITBG4IDqrGB1xE/uzVNjtwDAG3lP7E=',\n\t\ttype: 'slackApi',\n\t\tnodesAccess: [{ nodeType: 'n8n-nodes-base.slack', date: '2022-12-21T11:23:00.561Z' }],\n\t};\n\n\tconst credential = await Db.collections.Credentials.save(credentialDetails);\n\n\tconst workflowDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Test Workflow',\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodeTypes: {},\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: uuid(),\n\t\t\t\tname: 'My Node',\n\t\t\t\ttype: 'n8n-nodes-base.slack',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t},\n\t\t],\n\t};\n\n\tawait Db.collections.Workflow.save(workflowDetails);\n\n\tconst testAudit = await audit(['credentials']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tCREDENTIALS_REPORT.RISK,\n\t\tCREDENTIALS_REPORT.SECTIONS.CREDS_NOT_IN_ACTIVE_USE,\n\t);\n\n\texpect(section.location).toHaveLength(1);\n\texpect(section.location[0]).toMatchObject({\n\t\tid: credential.id,\n\t\tname: 'My Slack Credential',\n\t});\n});","file":"integration/audit/credentials.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report credential in not recently executed workflow","suites":[],"updatePoint":{"line":113,"column":64},"line":113,"code":"test('should report credential in not recently executed workflow', async () => {\n\tconst credentialDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Slack Credential',\n\t\tdata: 'U2FsdGVkX18WjITBG4IDqrGB1xE/uzVNjtwDAG3lP7E=',\n\t\ttype: 'slackApi',\n\t\tnodesAccess: [{ nodeType: 'n8n-nodes-base.slack', date: '2022-12-21T11:23:00.561Z' }],\n\t};\n\n\tconst credential = await Db.collections.Credentials.save(credentialDetails);\n\n\tconst workflowDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Test Workflow',\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodeTypes: {},\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: uuid(),\n\t\t\t\tname: 'My Node',\n\t\t\t\ttype: 'n8n-nodes-base.slack',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\tcredentials: {\n\t\t\t\t\tslackApi: {\n\t\t\t\t\t\tid: credential.id,\n\t\t\t\t\t\tname: credential.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n\n\tconst workflow = await Db.collections.Workflow.save(workflowDetails);\n\n\tconst date = new Date();\n\tdate.setDate(date.getDate() - config.getEnv('security.audit.daysAbandonedWorkflow') - 1);\n\n\tconst savedExecution = await Db.collections.Execution.save({\n\t\tfinished: true,\n\t\tmode: 'manual',\n\t\tstartedAt: date,\n\t\tstoppedAt: date,\n\t\tworkflowId: workflow.id,\n\t\twaitTill: null,\n\t});\n\tawait Db.collections.ExecutionData.save({\n\t\texecution: savedExecution,\n\t\tdata: '[]',\n\t\tworkflowData: workflow,\n\t});\n\n\tconst testAudit = await audit(['credentials']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tCREDENTIALS_REPORT.RISK,\n\t\tCREDENTIALS_REPORT.SECTIONS.CREDS_NOT_RECENTLY_EXECUTED,\n\t);\n\n\texpect(section.location).toHaveLength(1);\n\texpect(section.location[0]).toMatchObject({\n\t\tid: credential.id,\n\t\tname: credential.name,\n\t});\n});","file":"integration/audit/credentials.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report credentials in recently executed workflow","suites":[],"updatePoint":{"line":181,"column":65},"line":181,"code":"test('should not report credentials in recently executed workflow', async () => {\n\tconst credentialDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Slack Credential',\n\t\tdata: 'U2FsdGVkX18WjITBG4IDqrGB1xE/uzVNjtwDAG3lP7E=',\n\t\ttype: 'slackApi',\n\t\tnodesAccess: [{ nodeType: 'n8n-nodes-base.slack', date: '2022-12-21T11:23:00.561Z' }],\n\t};\n\n\tconst credential = await Db.collections.Credentials.save(credentialDetails);\n\n\tconst workflowDetails = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Test Workflow',\n\t\tactive: true,\n\t\tconnections: {},\n\t\tnodeTypes: {},\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: uuid(),\n\t\t\t\tname: 'My Node',\n\t\t\t\ttype: 'n8n-nodes-base.slack',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\tcredentials: {\n\t\t\t\t\tslackApi: {\n\t\t\t\t\t\tid: credential.id,\n\t\t\t\t\t\tname: credential.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n\n\tconst workflow = await Db.collections.Workflow.save(workflowDetails);\n\n\tconst date = new Date();\n\tdate.setDate(date.getDate() - config.getEnv('security.audit.daysAbandonedWorkflow') + 1);\n\n\tconst savedExecution = await Db.collections.Execution.save({\n\t\tfinished: true,\n\t\tmode: 'manual',\n\t\tstartedAt: date,\n\t\tstoppedAt: date,\n\t\tworkflowId: workflow.id,\n\t\twaitTill: null,\n\t});\n\n\tawait Db.collections.ExecutionData.save({\n\t\texecution: savedExecution,\n\t\tdata: '[]',\n\t\tworkflowData: workflow,\n\t});\n\n\tconst testAudit = await audit(['credentials']);\n\n\texpect(testAudit).toBeEmptyArray();\n});","file":"integration/audit/credentials.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report expressions in queries","suites":[],"updatePoint":{"line":25,"column":42},"line":25,"code":"test('should report expressions in queries', async () => {\n\tconst map = [...SQL_NODE_TYPES].reduce<{ [nodeType: string]: string }>((acc, cur) => {\n\t\treturn (acc[cur] = uuid()), acc;\n\t}, {});\n\n\tconst promises = Object.entries(map).map(async ([nodeType, nodeId]) => {\n\t\tconst details = {\n\t\t\tid: generateNanoId(),\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: nodeId,\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\toperation: 'executeQuery',\n\t\t\t\t\t\tquery: '=SELECT * FROM {{ $json.table }}',\n\t\t\t\t\t\tadditionalFields: {},\n\t\t\t\t\t},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['database']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tDATABASE_REPORT.RISK,\n\t\tDATABASE_REPORT.SECTIONS.EXPRESSIONS_IN_QUERIES,\n\t);\n\n\texpect(section.location).toHaveLength(SQL_NODE_TYPES.size);\n\n\tfor (const loc of section.location) {\n\t\tif (loc.kind === 'node') {\n\t\t\texpect(loc.nodeId).toBe(map[loc.nodeType]);\n\t\t}\n\t}\n});","file":"integration/audit/database.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report expressions in query params","suites":[],"updatePoint":{"line":75,"column":47},"line":75,"code":"test('should report expressions in query params', async () => {\n\tconst map = [...SQL_NODE_TYPES_WITH_QUERY_PARAMS].reduce<{ [nodeType: string]: string }>(\n\t\t(acc, cur) => {\n\t\t\treturn (acc[cur] = uuid()), acc;\n\t\t},\n\t\t{},\n\t);\n\n\tconst promises = Object.entries(map).map(async ([nodeType, nodeId]) => {\n\t\tconst details = {\n\t\t\tid: generateNanoId(),\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: nodeId,\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\toperation: 'executeQuery',\n\t\t\t\t\t\tquery: 'SELECT * FROM users WHERE id = $1;',\n\t\t\t\t\t\tadditionalFields: {\n\t\t\t\t\t\t\tqueryParams: '={{ $json.userId }}',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['database']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tDATABASE_REPORT.RISK,\n\t\tDATABASE_REPORT.SECTIONS.EXPRESSIONS_IN_QUERY_PARAMS,\n\t);\n\n\texpect(section.location).toHaveLength(SQL_NODE_TYPES_WITH_QUERY_PARAMS.size);\n\n\tfor (const loc of section.location) {\n\t\tif (loc.kind === 'node') {\n\t\t\texpect(loc.nodeId).toBe(map[loc.nodeType]);\n\t\t}\n\t}\n});","file":"integration/audit/database.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report unused query params","suites":[],"updatePoint":{"line":130,"column":39},"line":130,"code":"test('should report unused query params', async () => {\n\tconst map = [...SQL_NODE_TYPES_WITH_QUERY_PARAMS].reduce<{ [nodeType: string]: string }>(\n\t\t(acc, cur) => {\n\t\t\treturn (acc[cur] = uuid()), acc;\n\t\t},\n\t\t{},\n\t);\n\n\tconst promises = Object.entries(map).map(async ([nodeType, nodeId]) => {\n\t\tconst details = {\n\t\t\tid: generateNanoId(),\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: nodeId,\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\toperation: 'executeQuery',\n\t\t\t\t\t\tquery: 'SELECT * FROM users WHERE id = 123;',\n\t\t\t\t\t},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['database']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tDATABASE_REPORT.RISK,\n\t\tDATABASE_REPORT.SECTIONS.UNUSED_QUERY_PARAMS,\n\t);\n\n\texpect(section.location).toHaveLength(SQL_NODE_TYPES_WITH_QUERY_PARAMS.size);\n\n\tfor (const loc of section.location) {\n\t\tif (loc.kind === 'node') {\n\t\t\texpect(loc.nodeId).toBe(map[loc.nodeType]);\n\t\t}\n\t}\n});","file":"integration/audit/database.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report non-database node","suites":[],"updatePoint":{"line":182,"column":41},"line":182,"code":"test('should not report non-database node', async () => {\n\tawait saveManualTriggerWorkflow();\n\n\tconst testAudit = await audit(['database']);\n\n\texpect(testAudit).toBeEmptyArray();\n});","file":"integration/audit/database.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report filesystem interaction nodes","suites":[],"updatePoint":{"line":20,"column":48},"line":20,"code":"test('should report filesystem interaction nodes', async () => {\n\tconst map = [...FILESYSTEM_INTERACTION_NODE_TYPES].reduce<{ [nodeType: string]: string }>(\n\t\t(acc, cur) => {\n\t\t\treturn (acc[cur] = uuid()), acc;\n\t\t},\n\t\t{},\n\t);\n\n\tconst promises = Object.entries(map).map(async ([nodeType, nodeId]) => {\n\t\tconst details = Db.collections.Workflow.create({\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: nodeId,\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tparameters: {},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['filesystem']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tFILESYSTEM_REPORT.RISK,\n\t\tFILESYSTEM_REPORT.SECTIONS.FILESYSTEM_INTERACTION_NODES,\n\t);\n\n\texpect(section.location).toHaveLength(FILESYSTEM_INTERACTION_NODE_TYPES.size);\n\n\tfor (const loc of section.location) {\n\t\tif (loc.kind === 'node') {\n\t\t\texpect(loc.nodeId).toBe(map[loc.nodeType]);\n\t\t}\n\t}\n});","file":"integration/audit/filesystem.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report non-filesystem-interaction node","suites":[],"updatePoint":{"line":67,"column":55},"line":67,"code":"test('should not report non-filesystem-interaction node', async () => {\n\tawait saveManualTriggerWorkflow();\n\n\tconst testAudit = await audit(['filesystem']);\n\n\texpect(testAudit).toBeEmptyArray();\n});","file":"integration/audit/filesystem.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report webhook lacking authentication","suites":[],"updatePoint":{"line":31,"column":50},"line":31,"code":"test('should report webhook lacking authentication', async () => {\n\tconst targetNodeId = uuid();\n\n\tconst details = {\n\t\tid: generateNanoId(),\n\t\tname: 'My Test Workflow',\n\t\tactive: true,\n\t\tnodeTypes: {},\n\t\tconnections: {},\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tparameters: {\n\t\t\t\t\tpath: uuid(),\n\t\t\t\t\toptions: {},\n\t\t\t\t},\n\t\t\t\tid: targetNodeId,\n\t\t\t\tname: 'Webhook',\n\t\t\t\ttype: 'n8n-nodes-base.webhook',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\twebhookId: uuid(),\n\t\t\t},\n\t\t],\n\t};\n\n\tawait Db.collections.Workflow.save(details);\n\n\tconst testAudit = await audit(['instance']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tINSTANCE_REPORT.RISK,\n\t\tINSTANCE_REPORT.SECTIONS.UNPROTECTED_WEBHOOKS,\n\t);\n\n\tif (!section.location) {\n\t\tfail('Expected section to have locations');\n\t}\n\n\texpect(section.location).toHaveLength(1);\n\n\texpect(section.location[0].nodeId).toBe(targetNodeId);\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report webhooks having basic or header auth","suites":[],"updatePoint":{"line":75,"column":60},"line":75,"code":"test('should not report webhooks having basic or header auth', async () => {\n\tconst promises = ['basicAuth', 'headerAuth'].map(async (authType) => {\n\t\tconst details = {\n\t\t\tid: generateNanoId(),\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: true,\n\t\t\tnodeTypes: {},\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\tpath: uuid(),\n\t\t\t\t\t\tauthentication: authType,\n\t\t\t\t\t\toptions: {},\n\t\t\t\t\t},\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Webhook',\n\t\t\t\t\ttype: 'n8n-nodes-base.webhook',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\twebhookId: uuid(),\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['instance']);\n\tif (Array.isArray(testAudit)) fail('audit is empty');\n\n\tconst report = testAudit[toReportTitle('instance')];\n\tif (!report) {\n\t\tfail('Expected test audit to have instance risk report');\n\t}\n\n\tfor (const section of report.sections) {\n\t\texpect(section.title).not.toBe(INSTANCE_REPORT.SECTIONS.UNPROTECTED_WEBHOOKS);\n\t}\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report webhooks validated by direct children","suites":[],"updatePoint":{"line":118,"column":61},"line":118,"code":"test('should not report webhooks validated by direct children', async () => {\n\tconst promises = [...WEBHOOK_VALIDATOR_NODE_TYPES].map(async (nodeType) => {\n\t\tconst details = {\n\t\t\tid: generateNanoId(),\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: true,\n\t\t\tnodeTypes: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\tpath: uuid(),\n\t\t\t\t\t\toptions: {},\n\t\t\t\t\t},\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Webhook',\n\t\t\t\t\ttype: 'n8n-nodes-base.webhook',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\twebhookId: uuid(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {\n\t\t\t\tWebhook: {\n\t\t\t\t\tmain: [\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnode: 'My Node',\n\t\t\t\t\t\t\t\ttype: 'main',\n\t\t\t\t\t\t\t\tindex: 0,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['instance']);\n\tif (Array.isArray(testAudit)) fail('audit is empty');\n\n\tconst report = testAudit[toReportTitle('instance')];\n\tif (!report) {\n\t\tfail('Expected test audit to have instance risk report');\n\t}\n\n\tfor (const section of report.sections) {\n\t\texpect(section.title).not.toBe(INSTANCE_REPORT.SECTIONS.UNPROTECTED_WEBHOOKS);\n\t}\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report non-webhook node","suites":[],"updatePoint":{"line":179,"column":40},"line":179,"code":"test('should not report non-webhook node', async () => {\n\tawait saveManualTriggerWorkflow();\n\n\tconst testAudit = await audit(['instance']);\n\tif (Array.isArray(testAudit)) fail('audit is empty');\n\n\tconst report = testAudit[toReportTitle('instance')];\n\n\tif (!report) {\n\t\tfail('Expected test audit to have instance risk report');\n\t}\n\n\tfor (const section of report.sections) {\n\t\texpect(section.title).not.toBe(INSTANCE_REPORT.SECTIONS.UNPROTECTED_WEBHOOKS);\n\t}\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report outdated instance when outdated","suites":[],"updatePoint":{"line":196,"column":51},"line":196,"code":"test('should report outdated instance when outdated', async () => {\n\tsimulateOutdatedInstanceOnce();\n\n\tconst testAudit = await audit(['instance']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tINSTANCE_REPORT.RISK,\n\t\tINSTANCE_REPORT.SECTIONS.OUTDATED_INSTANCE,\n\t);\n\n\tif (!section.nextVersions) {\n\t\tfail('Expected section to have next versions');\n\t}\n\n\texpect(section.nextVersions).toHaveLength(1);\n\n\texpect(section.nextVersions[0].name).toBe(MOCK_09990_N8N_VERSION.name);\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report outdated instance when up to date","suites":[],"updatePoint":{"line":216,"column":57},"line":216,"code":"test('should not report outdated instance when up to date', async () => {\n\tconst testAudit = await audit(['instance']);\n\tif (Array.isArray(testAudit)) fail('audit is empty');\n\n\tconst report = testAudit[toReportTitle('instance')];\n\tif (!report) {\n\t\tfail('Expected test audit to have instance risk report');\n\t}\n\n\tfor (const section of report.sections) {\n\t\texpect(section.title).not.toBe(INSTANCE_REPORT.SECTIONS.OUTDATED_INSTANCE);\n\t}\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report security settings","suites":[],"updatePoint":{"line":230,"column":37},"line":230,"code":"test('should report security settings', async () => {\n\tconfig.set('diagnostics.enabled', true);\n\n\tconst testAudit = await audit(['instance']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tINSTANCE_REPORT.RISK,\n\t\tINSTANCE_REPORT.SECTIONS.SECURITY_SETTINGS,\n\t);\n\n\texpect(section.settings).toMatchObject({\n\t\tfeatures: {\n\t\t\tcommunityPackagesEnabled: true,\n\t\t\tversionNotificationsEnabled: true,\n\t\t\ttemplatesEnabled: true,\n\t\t\tpublicApiEnabled: false,\n\t\t},\n\t\tauth: {\n\t\t\tauthExcludeEndpoints: 'none',\n\t\t},\n\t\tnodes: { nodesExclude: 'none', nodesInclude: 'none' },\n\t\ttelemetry: { diagnosticsEnabled: true },\n\t});\n});","file":"integration/audit/instance.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report risky official nodes","suites":[],"updatePoint":{"line":29,"column":40},"line":29,"code":"test('should report risky official nodes', async () => {\n\tconst map = [...OFFICIAL_RISKY_NODE_TYPES].reduce<{ [nodeType: string]: string }>((acc, cur) => {\n\t\treturn (acc[cur] = uuid()), acc;\n\t}, {});\n\n\tconst promises = Object.entries(map).map(async ([nodeType, nodeId]) => {\n\t\tconst details = Db.collections.Workflow.create({\n\t\t\tname: 'My Test Workflow',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: nodeId,\n\t\t\t\t\tname: 'My Node',\n\t\t\t\t\ttype: nodeType,\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tparameters: {},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\treturn Db.collections.Workflow.save(details);\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst testAudit = await audit(['nodes']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tNODES_REPORT.RISK,\n\t\tNODES_REPORT.SECTIONS.OFFICIAL_RISKY_NODES,\n\t);\n\n\texpect(section.location).toHaveLength(OFFICIAL_RISKY_NODE_TYPES.size);\n\n\tfor (const loc of section.location) {\n\t\tif (loc.kind === 'node') {\n\t\t\texpect(loc.nodeId).toBe(map[loc.nodeType]);\n\t\t}\n\t}\n});","file":"integration/audit/nodes.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not report non-risky official nodes","suites":[],"updatePoint":{"line":73,"column":48},"line":73,"code":"test('should not report non-risky official nodes', async () => {\n\tawait saveManualTriggerWorkflow();\n\n\tconst testAudit = await audit(['nodes']);\n\tif (Array.isArray(testAudit)) return;\n\n\tconst report = testAudit[toReportTitle('nodes')];\n\tif (!report) return;\n\n\tfor (const section of report.sections) {\n\t\texpect(section.title).not.toBe(NODES_REPORT.SECTIONS.OFFICIAL_RISKY_NODES);\n\t}\n});","file":"integration/audit/nodes.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report community nodes","suites":[],"updatePoint":{"line":87,"column":35},"line":87,"code":"test('should report community nodes', async () => {\n\tjest.spyOn(packageModel, 'getAllInstalledPackages').mockResolvedValueOnce(MOCK_PACKAGE);\n\n\tconst testAudit = await audit(['nodes']);\n\n\tconst section = getRiskSection(\n\t\ttestAudit,\n\t\tNODES_REPORT.RISK,\n\t\tNODES_REPORT.SECTIONS.COMMUNITY_NODES,\n\t);\n\n\texpect(section.location).toHaveLength(1);\n\n\tif (section.location[0].kind === 'community') {\n\t\texpect(section.location[0].nodeType).toBe(MOCK_PACKAGE[0].installedNodes[0].type);\n\t}\n});","file":"integration/audit/nodes.risk.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should log user in","suites":["POST /login"],"updatePoint":{"line":42,"column":25},"line":42,"code":"\ttest('should log user in', async () => {\n\t\tconst response = await testServer.authlessAgent.post('/login').send({\n\t\t\temail: owner.email,\n\t\t\tpassword: ownerPassword,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email, firstName, lastName, password, personalizationAnswers, globalRole, apiKey } =\n\t\t\tresponse.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(owner.email);\n\t\texpect(firstName).toBe(owner.firstName);\n\t\texpect(lastName).toBe(owner.lastName);\n\t\texpect(password).toBeUndefined();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeDefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw AuthError for non-owner if not within users limit quota","suites":["POST /login"],"updatePoint":{"line":69,"column":75},"line":69,"code":"\ttest('should throw AuthError for non-owner if not within users limit quota', async () => {\n\t\tjest.spyOn(Container.get(License), 'isWithinUsersLimit').mockReturnValueOnce(false);\n\t\tconst password = 'testpassword';\n\t\tconst member = await testDb.createUser({\n\t\t\tpassword,\n\t\t});\n\n\t\tconst response = await testServer.authlessAgent.post('/login').send({\n\t\t\temail: member.email,\n\t\t\tpassword,\n\t\t});\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not throw AuthError for owner if not within users limit quota","suites":["POST /login"],"updatePoint":{"line":83,"column":75},"line":83,"code":"\ttest('should not throw AuthError for owner if not within users limit quota', async () => {\n\t\tjest.spyOn(Container.get(License), 'isWithinUsersLimit').mockReturnValueOnce(false);\n\t\tconst ownerUser = await testDb.createUser({\n\t\t\tpassword: randomValidPassword(),\n\t\t\tglobalRole: globalOwnerRole,\n\t\t\tisOwner: true,\n\t\t});\n\n\t\tconst response = await testServer.authAgentFor(ownerUser).get('/login');\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 401 Unauthorized if no cookie","suites":["GET /login"],"updatePoint":{"line":97,"column":50},"line":97,"code":"\ttest('should return 401 Unauthorized if no cookie', async () => {\n\t\tconst response = await testServer.authlessAgent.get('/login');\n\n\t\texpect(response.statusCode).toBe(401);\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return cookie if UM is disabled and no cookie is already set","suites":["GET /login"],"updatePoint":{"line":106,"column":74},"line":106,"code":"\ttest('should return cookie if UM is disabled and no cookie is already set', async () => {\n\t\tawait testDb.createUserShell(globalOwnerRole);\n\t\tawait utils.setInstanceOwnerSetUp(false);\n\n\t\tconst response = await testServer.authlessAgent.get('/login');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeDefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 401 Unauthorized if invalid cookie","suites":["GET /login"],"updatePoint":{"line":118,"column":55},"line":118,"code":"\ttest('should return 401 Unauthorized if invalid cookie', async () => {\n\t\ttestServer.authlessAgent.jar.setCookie(`${AUTH_COOKIE_NAME}=invalid`);\n\n\t\tconst response = await testServer.authlessAgent.get('/login');\n\n\t\texpect(response.statusCode).toBe(401);\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return logged-in owner shell","suites":["GET /login"],"updatePoint":{"line":129,"column":42},"line":129,"code":"\ttest('should return logged-in owner shell', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\t\tconst response = await testServer.authAgentFor(ownerShell).get('/login');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email, firstName, lastName, password, personalizationAnswers, globalRole, apiKey } =\n\t\t\tresponse.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBeDefined();\n\t\texpect(firstName).toBeNull();\n\t\texpect(lastName).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return logged-in member shell","suites":["GET /login"],"updatePoint":{"line":155,"column":43},"line":155,"code":"\ttest('should return logged-in member shell', async () => {\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\t\tconst response = await testServer.authAgentFor(memberShell).get('/login');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email, firstName, lastName, password, personalizationAnswers, globalRole, apiKey } =\n\t\t\tresponse.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBeDefined();\n\t\texpect(firstName).toBeNull();\n\t\texpect(lastName).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(globalRole.name).toBe('member');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return logged-in owner","suites":["GET /login"],"updatePoint":{"line":181,"column":36},"line":181,"code":"\ttest('should return logged-in owner', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst response = await testServer.authAgentFor(owner).get('/login');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email, firstName, lastName, password, personalizationAnswers, globalRole, apiKey } =\n\t\t\tresponse.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(owner.email);\n\t\texpect(firstName).toBe(owner.firstName);\n\t\texpect(lastName).toBe(owner.lastName);\n\t\texpect(password).toBeUndefined();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return logged-in member","suites":["GET /login"],"updatePoint":{"line":207,"column":37},"line":207,"code":"\ttest('should return logged-in member', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst response = await testServer.authAgentFor(member).get('/login');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email, firstName, lastName, password, personalizationAnswers, globalRole, apiKey } =\n\t\t\tresponse.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(member.email);\n\t\texpect(firstName).toBe(member.firstName);\n\t\texpect(lastName).toBe(member.lastName);\n\t\texpect(password).toBeUndefined();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(globalRole.name).toBe('member');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should validate invite token","suites":["GET /resolve-signup-token"],"updatePoint":{"line":243,"column":35},"line":243,"code":"\ttest('should validate invite token', async () => {\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.get('/resolve-signup-token')\n\t\t\t.query({ inviterId: owner.id })\n\t\t\t.query({ inviteeId: memberShell.id });\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual({\n\t\t\tdata: {\n\t\t\t\tinviter: {\n\t\t\t\t\tfirstName: owner.firstName,\n\t\t\t\t\tlastName: owner.lastName,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 403 if user quota reached","suites":["GET /resolve-signup-token"],"updatePoint":{"line":262,"column":46},"line":262,"code":"\ttest('should return 403 if user quota reached', async () => {\n\t\tjest.spyOn(Container.get(License), 'isWithinUsersLimit').mockReturnValueOnce(false);\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.get('/resolve-signup-token')\n\t\t\t.query({ inviterId: owner.id })\n\t\t\t.query({ inviteeId: memberShell.id });\n\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["GET /resolve-signup-token"],"updatePoint":{"line":274,"column":38},"line":274,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst { id: inviteeId } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst first = await authOwnerAgent.get('/resolve-signup-token').query({ inviterId: owner.id });\n\n\t\tconst second = await authOwnerAgent.get('/resolve-signup-token').query({ inviteeId });\n\n\t\tconst third = await authOwnerAgent.get('/resolve-signup-token').query({\n\t\t\tinviterId: '5531199e-b7ae-425b-a326-a95ef8cca59d',\n\t\t\tinviteeId: 'cb133beb-7729-4c34-8cd1-a06be8834d9d',\n\t\t});\n\n\t\t// user is already set up, so call should error\n\t\tconst fourth = await authOwnerAgent\n\t\t\t.get('/resolve-signup-token')\n\t\t\t.query({ inviterId: owner.id })\n\t\t\t.query({ inviteeId });\n\n\t\t// cause inconsistent DB state\n\t\tawait Db.collections.User.update(owner.id, { email: '' });\n\t\tconst fifth = await authOwnerAgent\n\t\t\t.get('/resolve-signup-token')\n\t\t\t.query({ inviterId: owner.id })\n\t\t\t.query({ inviteeId });\n\n\t\tfor (const response of [first, second, third, fourth, fifth]) {\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should log user out","suites":["POST /logout"],"updatePoint":{"line":306,"column":26},"line":306,"code":"\ttest('should log user out', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst response = await testServer.authAgentFor(owner).post('/logout');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual(LOGGED_OUT_RESPONSE_BODY);\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeUndefined();\n\t});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"  should return 401 Unauthorized if no cookie","suites":["Auth Middleware","Routes requiring Authentication"],"updatePoint":{"line":28,"column":75},"line":28,"code":"\t\t\t\ttest(`${method} ${endpoint} should return 401 Unauthorized if no cookie`, async () => {\n\t\t\t\t\tconst { statusCode } = await testServer.authlessAgent[method.toLowerCase()](endpoint);\n\t\t\t\t\texpect(statusCode).toBe(401);\n\t\t\t\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"  should return 403 Forbidden for member","suites":["Auth Middleware","Routes requiring Authorization"],"updatePoint":{"line":45,"column":69},"line":45,"code":"\t\t\ttest(`${method} ${endpoint} should return 403 Forbidden for member`, async () => {\n\t\t\t\tconst { statusCode } = await authMemberAgent[method.toLowerCase()](endpoint);\n\t\t\t\texpect(statusCode).toBe(403);\n\t\t\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"import:workflow should import active workflow and deactivate it","suites":[],"updatePoint":{"line":20,"column":69},"line":20,"code":"test('import:workflow should import active workflow and deactivate it', async () => {\n\tconst config: Config.IConfig = new Config.Config({ root: __dirname });\n\tconst before = await testDb.getAllWorkflows();\n\texpect(before.length).toBe(0);\n\tconst importer = new ImportWorkflowsCommand(\n\t\t['--separate', '--input=./test/integration/commands/importWorkflows/separate'],\n\t\tconfig,\n\t);\n\tconst mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n\t\tthrow new Error('process.exit');\n\t});\n\n\tawait importer.init();\n\ttry {\n\t\tawait importer.run();\n\t} catch (error) {\n\t\texpect(error.message).toBe('process.exit');\n\t}\n\tconst after = await testDb.getAllWorkflows();\n\texpect(after.length).toBe(2);\n\texpect(after[0].name).toBe('active-workflow');\n\texpect(after[0].active).toBe(false);\n\texpect(after[1].name).toBe('inactive-workflow');\n\texpect(after[1].active).toBe(false);\n\tmockExit.mockRestore();\n});","file":"integration/commands/import.cmd.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"import:workflow should import active workflow from combined file and deactivate it","suites":[],"updatePoint":{"line":47,"column":88},"line":47,"code":"test('import:workflow should import active workflow from combined file and deactivate it', async () => {\n\tconst config: Config.IConfig = new Config.Config({ root: __dirname });\n\tconst before = await testDb.getAllWorkflows();\n\texpect(before.length).toBe(0);\n\tconst importer = new ImportWorkflowsCommand(\n\t\t['--input=./test/integration/commands/importWorkflows/combined/combined.json'],\n\t\tconfig,\n\t);\n\tconst mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n\t\tthrow new Error('process.exit');\n\t});\n\n\tawait importer.init();\n\ttry {\n\t\tawait importer.run();\n\t} catch (error) {\n\t\texpect(error.message).toBe('process.exit');\n\t}\n\tconst after = await testDb.getAllWorkflows();\n\texpect(after.length).toBe(2);\n\texpect(after[0].name).toBe('active-workflow');\n\texpect(after[0].active).toBe(false);\n\texpect(after[1].name).toBe('inactive-workflow');\n\texpect(after[1].active).toBe(false);\n\tmockExit.mockRestore();\n});","file":"integration/commands/import.cmd.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"user-management:reset should reset DB to default user state","suites":[],"line":30,"code":"test.skip('user-management:reset should reset DB to default user state', async () => {","file":"integration/commands/reset.cmd.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"when sharing is disabled","suites":["router should switch based on flag"],"updatePoint":{"line":54,"column":31},"line":54,"code":"\ttest('when sharing is disabled', async () => {\n\t\tsharingSpy.mockReturnValueOnce(false);\n\n\t\tawait authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredentialId}/share`)\n\t\t\t.send({ shareWithIds: [member.id] })\n\t\t\t.expect(404);\n\n\t\tawait authOwnerAgent.get(`/credentials/${savedCredentialId}`).send().expect(200);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"when sharing is enabled","suites":["router should switch based on flag"],"updatePoint":{"line":65,"column":30},"line":65,"code":"\ttest('when sharing is enabled', async () => {\n\t\tawait authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredentialId}/share`)\n\t\t\t.send({ shareWithIds: [member.id] })\n\t\t\t.expect(200);\n\n\t\tawait authOwnerAgent.get(`/credentials/${savedCredentialId}`).send().expect(200);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all creds for owner","suites":["GET /credentials"],"updatePoint":{"line":79,"column":40},"line":79,"code":"\ttest('should return all creds for owner', async () => {\n\t\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tawait saveCredential(randomCredentialPayload(), { user: member1 });\n\n\t\tconst sharedWith = [member1, member2, member3];\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, sharedWith);\n\n\t\tconst response = await authOwnerAgent.get('/credentials');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data).toHaveLength(2); // owner retrieved owner cred and member cred\n\t\tconst ownerCredential = response.body.data.find(\n\t\t\t(e: CredentialWithSharings) => e.ownedBy?.id === owner.id,\n\t\t);\n\t\tconst memberCredential = response.body.data.find(\n\t\t\t(e: CredentialWithSharings) => e.ownedBy?.id === member1.id,\n\t\t);\n\n\t\tvalidateMainCredentialData(ownerCredential);\n\t\texpect(ownerCredential.data).toBeUndefined();\n\n\t\tvalidateMainCredentialData(memberCredential);\n\t\texpect(memberCredential.data).toBeUndefined();\n\n\t\texpect(ownerCredential.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(Array.isArray(ownerCredential.sharedWith)).toBe(true);\n\t\texpect(ownerCredential.sharedWith).toHaveLength(3);\n\n\t\t// Fix order issue (MySQL might return items in any order)\n\t\tconst ownerCredentialsSharedWithOrdered = [...ownerCredential.sharedWith!].sort(\n\t\t\t(a: IUser, b: IUser) => (a.email < b.email ? -1 : 1),\n\t\t);\n\t\tconst orderedSharedWith = [...sharedWith].sort((a, b) => (a.email < b.email ? -1 : 1));\n\n\t\townerCredentialsSharedWithOrdered.forEach((sharee: IUser, idx: number) => {\n\t\t\texpect(sharee).toMatchObject({\n\t\t\t\tid: orderedSharedWith[idx].id,\n\t\t\t\temail: orderedSharedWith[idx].email,\n\t\t\t\tfirstName: orderedSharedWith[idx].firstName,\n\t\t\t\tlastName: orderedSharedWith[idx].lastName,\n\t\t\t});\n\t\t});\n\n\t\texpect(memberCredential.ownedBy).toMatchObject({\n\t\t\tid: member1.id,\n\t\t\temail: member1.email,\n\t\t\tfirstName: member1.firstName,\n\t\t\tlastName: member1.lastName,\n\t\t});\n\n\t\texpect(Array.isArray(memberCredential.sharedWith)).toBe(true);\n\t\texpect(memberCredential.sharedWith).toHaveLength(0);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return only relevant creds for member","suites":["GET /credentials"],"updatePoint":{"line":143,"column":51},"line":143,"code":"\ttest('should return only relevant creds for member', async () => {\n\t\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tawait saveCredential(randomCredentialPayload(), { user: member2 });\n\t\tconst savedMemberCredential = await saveCredential(randomCredentialPayload(), {\n\t\t\tuser: member1,\n\t\t});\n\n\t\tawait testDb.shareCredentialWithUsers(savedMemberCredential, [member2]);\n\n\t\tconst response = await testServer.authAgentFor(member1).get('/credentials');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data).toHaveLength(1); // member retrieved only member cred\n\n\t\tconst [member1Credential] = response.body.data;\n\n\t\tvalidateMainCredentialData(member1Credential);\n\t\texpect(member1Credential.data).toBeUndefined();\n\n\t\texpect(member1Credential.ownedBy).toMatchObject({\n\t\t\tid: member1.id,\n\t\t\temail: member1.email,\n\t\t\tfirstName: member1.firstName,\n\t\t\tlastName: member1.lastName,\n\t\t});\n\n\t\texpect(Array.isArray(member1Credential.sharedWith)).toBe(true);\n\t\texpect(member1Credential.sharedWith).toHaveLength(1);\n\n\t\tconst [sharee] = member1Credential.sharedWith;\n\n\t\texpect(sharee).toMatchObject({\n\t\t\tid: member2.id,\n\t\t\temail: member2.email,\n\t\t\tfirstName: member2.firstName,\n\t\t\tlastName: member2.lastName,\n\t\t});\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve owned cred for owner","suites":["GET /credentials/:id"],"updatePoint":{"line":190,"column":43},"line":190,"code":"\ttest('should retrieve owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst firstResponse = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(firstResponse.statusCode).toBe(200);\n\n\t\tconst { data: firstCredential } = firstResponse.body;\n\t\tvalidateMainCredentialData(firstCredential);\n\t\texpect(firstCredential.data).toBeUndefined();\n\t\texpect(firstCredential.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\t\texpect(firstCredential.sharedWith).toHaveLength(0);\n\n\t\tconst secondResponse = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(secondResponse.statusCode).toBe(200);\n\n\t\tconst { data: secondCredential } = secondResponse.body;\n\t\tvalidateMainCredentialData(secondCredential);\n\t\texpect(secondCredential.data).toBeDefined();\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve non-owned cred for owner","suites":["GET /credentials/:id"],"updatePoint":{"line":219,"column":47},"line":219,"code":"\ttest('should retrieve non-owned cred for owner', async () => {\n\t\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member2]);\n\n\t\tconst response1 = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response1.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(response1.body.data);\n\t\texpect(response1.body.data.data).toBeUndefined();\n\t\texpect(response1.body.data.ownedBy).toMatchObject({\n\t\t\tid: member1.id,\n\t\t\temail: member1.email,\n\t\t\tfirstName: member1.firstName,\n\t\t\tlastName: member1.lastName,\n\t\t});\n\t\texpect(response1.body.data.sharedWith).toHaveLength(1);\n\t\texpect(response1.body.data.sharedWith[0]).toMatchObject({\n\t\t\tid: member2.id,\n\t\t\temail: member2.email,\n\t\t\tfirstName: member2.firstName,\n\t\t\tlastName: member2.lastName,\n\t\t});\n\n\t\tconst response2 = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(response2.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(response2.body.data);\n\t\texpect(response2.body.data.data).toBeUndefined();\n\t\texpect(response2.body.data.sharedWith).toHaveLength(1);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve owned cred for member","suites":["GET /credentials/:id"],"updatePoint":{"line":258,"column":44},"line":258,"code":"\ttest('should retrieve owned cred for member', async () => {\n\t\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\t\tconst authMemberAgent = testServer.authAgentFor(member1);\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member2, member3]);\n\n\t\tconst firstResponse = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(firstResponse.statusCode).toBe(200);\n\n\t\tconst { data: firstCredential } = firstResponse.body;\n\t\tvalidateMainCredentialData(firstCredential);\n\t\texpect(firstCredential.data).toBeUndefined();\n\t\texpect(firstCredential.ownedBy).toMatchObject({\n\t\t\tid: member1.id,\n\t\t\temail: member1.email,\n\t\t\tfirstName: member1.firstName,\n\t\t\tlastName: member1.lastName,\n\t\t});\n\t\texpect(firstCredential.sharedWith).toHaveLength(2);\n\t\tfirstCredential.sharedWith.forEach((sharee: IUser, idx: number) => {\n\t\t\texpect([member2.id, member3.id]).toContain(sharee.id);\n\t\t});\n\n\t\tconst secondResponse = await authMemberAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(secondResponse.statusCode).toBe(200);\n\n\t\tconst { data: secondCredential } = secondResponse.body;\n\t\tvalidateMainCredentialData(secondCredential);\n\t\texpect(secondCredential.data).toBeDefined();\n\t\texpect(firstCredential.sharedWith).toHaveLength(2);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not retrieve non-owned cred for member","suites":["GET /credentials/:id"],"updatePoint":{"line":296,"column":52},"line":296,"code":"\ttest('should not retrieve non-owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await testServer\n\t\t\t.authAgentFor(member)\n\t\t\t.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(403);\n\t\texpect(response.body.data).toBeUndefined(); // owner's cred not returned\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with missing encryption key","suites":["GET /credentials/:id"],"updatePoint":{"line":307,"column":46},"line":307,"code":"\ttest('should fail with missing encryption key', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\t\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(response.statusCode).toBe(500);\n\n\t\tmock.mockRestore();\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 404 if cred not found","suites":["GET /credentials/:id"],"updatePoint":{"line":322,"column":42},"line":322,"code":"\ttest('should return 404 if cred not found', async () => {\n\t\tconst response = await authOwnerAgent.get('/credentials/789');\n\t\texpect(response.statusCode).toBe(404);\n\n\t\tconst responseAbc = await authOwnerAgent.get('/credentials/abc');\n\t\texpect(responseAbc.statusCode).toBe(404);\n\n\t\t// because EE router has precedence, check if forwards this route\n\t\tconst responseNew = await authOwnerAgent.get('/credentials/new');\n\t\texpect(responseNew.statusCode).toBe(200);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should share the credential with the provided userIds and unshare it for missing ones","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":339,"column":92},"line":339,"code":"\ttest('should share the credential with the provided userIds and unshare it for missing ones', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst [member1, member2, member3, member4, member5] = await testDb.createManyUsers(5, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\t\tconst shareWithIds = [member1.id, member2.id, member3.id];\n\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member4, member5]);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds });\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data).toBeUndefined();\n\n\t\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\t\trelations: ['role'],\n\t\t\twhere: { credentialsId: savedCredential.id },\n\t\t});\n\n\t\t// check that sharings have been removed/added correctly\n\t\texpect(sharedCredentials.length).toBe(shareWithIds.length + 1); // +1 for the owner\n\n\t\tsharedCredentials.forEach((sharedCredential) => {\n\t\t\tif (sharedCredential.userId === owner.id) {\n\t\t\t\texpect(sharedCredential.role.name).toBe('owner');\n\t\t\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\texpect(shareWithIds).toContain(sharedCredential.userId);\n\t\t\texpect(sharedCredential.role.name).toBe('user');\n\t\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t\t});\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should share the credential with the provided userIds","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":376,"column":60},"line":376,"code":"\ttest('should share the credential with the provided userIds', async () => {\n\t\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\t\tconst memberIds = [member1.id, member2.id, member3.id];\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: memberIds });\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data).toBeUndefined();\n\n\t\t// check that sharings got correctly set in DB\n\t\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\t\trelations: ['role'],\n\t\t\twhere: { credentialsId: savedCredential.id, userId: In([...memberIds]) },\n\t\t});\n\n\t\texpect(sharedCredentials.length).toBe(memberIds.length);\n\n\t\tsharedCredentials.forEach((sharedCredential) => {\n\t\t\texpect(sharedCredential.role.name).toBe('user');\n\t\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t\t});\n\n\t\t// check that owner still exists\n\t\tconst ownerSharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['role'],\n\t\t\twhere: { credentialsId: savedCredential.id, userId: owner.id },\n\t\t});\n\n\t\texpect(ownerSharedCredential.role.name).toBe('owner');\n\t\texpect(ownerSharedCredential.role.scope).toBe('credential');\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respond 403 for non-existing credentials","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":413,"column":54},"line":413,"code":"\ttest('should respond 403 for non-existing credentials', async () => {\n\t\tconst response = await authOwnerAgent\n\t\t\t.put('/credentials/1234567/share')\n\t\t\t.send({ shareWithIds: [member.id] });\n\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respond 403 for non-owned credentials","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":421,"column":51},"line":421,"code":"\ttest('should respond 403 for non-owned credentials', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id] });\n\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore pending sharee","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":431,"column":35},"line":431,"code":"\ttest('should ignore pending sharee', async () => {\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: [memberShell.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\t\twhere: { credentialsId: savedCredential.id },\n\t\t});\n\n\t\texpect(sharedCredentials).toHaveLength(1);\n\t\texpect(sharedCredentials[0].userId).toBe(owner.id);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore non-existing sharee","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":449,"column":40},"line":449,"code":"\ttest('should ignore non-existing sharee', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: ['bce38a11-5e45-4d1c-a9ee-36e4a20ab0fc'] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\t\twhere: { credentialsId: savedCredential.id },\n\t\t});\n\n\t\texpect(sharedCredentials).toHaveLength(1);\n\t\texpect(sharedCredentials[0].userId).toBe(owner.id);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respond 400 if invalid payload is provided","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":466,"column":56},"line":466,"code":"\ttest('should respond 400 if invalid payload is provided', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst responses = await Promise.all([\n\t\t\tauthOwnerAgent.put(`/credentials/${savedCredential.id}/share`).send(),\n\t\t\tauthOwnerAgent.put(`/credentials/${savedCredential.id}/share`).send({ shareWithIds: [1] }),\n\t\t]);\n\n\t\tresponses.forEach((response) => expect(response.statusCode).toBe(400));\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should unshare the credential","suites":["PUT /credentials/:id/share"],"updatePoint":{"line":476,"column":36},"line":476,"code":"\ttest('should unshare the credential', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member1, member2]);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: [] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\t\twhere: { credentialsId: savedCredential.id },\n\t\t});\n\n\t\texpect(sharedCredentials).toHaveLength(1);\n\t\texpect(sharedCredentials[0].userId).toBe(owner.id);\n\t});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all creds for owner","suites":["GET /credentials"],"updatePoint":{"line":50,"column":40},"line":50,"code":"\ttest('should return all creds for owner', async () => {\n\t\tconst [{ id: savedOwnerCredentialId }, { id: savedMemberCredentialId }] = await Promise.all([\n\t\t\tsaveCredential(randomCredentialPayload(), { user: owner }),\n\t\t\tsaveCredential(randomCredentialPayload(), { user: member }),\n\t\t]);\n\n\t\tconst response = await authOwnerAgent.get('/credentials');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2); // owner retrieved owner cred and member cred\n\n\t\tconst savedCredentialsIds = [savedOwnerCredentialId, savedMemberCredentialId];\n\t\tresponse.body.data.forEach((credential: CredentialsEntity) => {\n\t\t\tvalidateMainCredentialData(credential);\n\t\t\texpect(credential.data).toBeUndefined();\n\t\t\texpect(savedCredentialsIds).toContain(credential.id);\n\t\t});\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return only own creds for member","suites":["GET /credentials"],"updatePoint":{"line":69,"column":46},"line":69,"code":"\ttest('should return only own creds for member', async () => {\n\t\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconst [savedCredential1] = await Promise.all([\n\t\t\tsaveCredential(randomCredentialPayload(), { user: member1 }),\n\t\t\tsaveCredential(randomCredentialPayload(), { user: member2 }),\n\t\t]);\n\n\t\tconst response = await testServer.authAgentFor(member1).get('/credentials');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1); // member retrieved only own cred\n\n\t\tconst [member1Credential] = response.body.data;\n\n\t\tvalidateMainCredentialData(member1Credential);\n\t\texpect(member1Credential.data).toBeUndefined();\n\t\texpect(member1Credential.id).toBe(savedCredential1.id);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create cred","suites":["POST /credentials"],"updatePoint":{"line":93,"column":25},"line":93,"code":"\ttest('should create cred', async () => {\n\t\tconst payload = randomCredentialPayload();\n\n\t\tconst response = await authOwnerAgent.post('/credentials').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\t\texpect(name).toBe(payload.name);\n\t\texpect(type).toBe(payload.type);\n\t\tif (!payload.nodesAccess) {\n\t\t\tfail('Payload did not contain a nodesAccess array');\n\t\t}\n\t\texpect(nodesAccess[0].nodeType).toBe(payload.nodesAccess[0].nodeType);\n\t\texpect(encryptedData).not.toBe(payload.data);\n\n\t\tconst credential = await Db.collections.Credentials.findOneByOrFail({ id });\n\n\t\texpect(credential.name).toBe(payload.name);\n\t\texpect(credential.type).toBe(payload.type);\n\t\texpect(credential.nodesAccess[0].nodeType).toBe(payload.nodesAccess[0].nodeType);\n\t\texpect(credential.data).not.toBe(payload.data);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['user', 'credentials'],\n\t\t\twhere: { credentialsId: credential.id },\n\t\t});\n\n\t\texpect(sharedCredential.user.id).toBe(owner.id);\n\t\texpect(sharedCredential.credentials.name).toBe(payload.name);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /credentials"],"updatePoint":{"line":126,"column":38},"line":126,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tawait Promise.all(\n\t\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\t\tconst response = await authOwnerAgent.post('/credentials').send(invalidPayload);\n\t\t\t\texpect(response.statusCode).toBe(400);\n\t\t\t}),\n\t\t);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with missing encryption key","suites":["POST /credentials"],"updatePoint":{"line":135,"column":46},"line":135,"code":"\ttest('should fail with missing encryption key', async () => {\n\t\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\t\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\t\tconst response = await authOwnerAgent.post('/credentials').send(randomCredentialPayload());\n\n\t\texpect(response.statusCode).toBe(500);\n\n\t\tmock.mockRestore();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore ID in payload","suites":["POST /credentials"],"updatePoint":{"line":146,"column":34},"line":146,"code":"\ttest('should ignore ID in payload', async () => {\n\t\tconst firstResponse = await authOwnerAgent\n\t\t\t.post('/credentials')\n\t\t\t.send({ id: '8', ...randomCredentialPayload() });\n\n\t\texpect(firstResponse.body.data.id).not.toBe('8');\n\n\t\tconst secondResponse = await authOwnerAgent\n\t\t\t.post('/credentials')\n\t\t\t.send({ id: 8, ...randomCredentialPayload() });\n\n\t\texpect(secondResponse.body.data.id).not.toBe(8);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete owned cred for owner","suites":["DELETE /credentials/:id"],"updatePoint":{"line":162,"column":41},"line":162,"code":"\ttest('should delete owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual({ data: true });\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete non-owned cred for owner","suites":["DELETE /credentials/:id"],"updatePoint":{"line":181,"column":45},"line":181,"code":"\ttest('should delete non-owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual({ data: true });\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete owned cred for member","suites":["DELETE /credentials/:id"],"updatePoint":{"line":200,"column":42},"line":200,"code":"\ttest('should delete owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual({ data: true });\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete non-owned cred for member","suites":["DELETE /credentials/:id"],"updatePoint":{"line":219,"column":50},"line":219,"code":"\ttest('should not delete non-owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(404);\n\n\t\tconst shellCredential = await Db.collections.Credentials.findOneBy({ id: savedCredential.id });\n\n\t\texpect(shellCredential).toBeDefined(); // not deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeDefined(); // not deleted\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if cred not found","suites":["DELETE /credentials/:id"],"updatePoint":{"line":235,"column":36},"line":235,"code":"\ttest('should fail if cred not found', async () => {\n\t\tconst response = await authOwnerAgent.delete('/credentials/123');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update owned cred for owner","suites":["PATCH /credentials/:id"],"updatePoint":{"line":243,"column":41},"line":243,"code":"\ttest('should update owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst patchPayload = randomCredentialPayload();\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t.send(patchPayload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\t\texpect(name).toBe(patchPayload.name);\n\t\texpect(type).toBe(patchPayload.type);\n\t\tif (!patchPayload.nodesAccess) {\n\t\t\tfail('Payload did not contain a nodesAccess array');\n\t\t}\n\t\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\t\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\t\tconst credential = await Db.collections.Credentials.findOneByOrFail({ id });\n\n\t\texpect(credential.name).toBe(patchPayload.name);\n\t\texpect(credential.type).toBe(patchPayload.type);\n\t\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\t\texpect(credential.data).not.toBe(patchPayload.data);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['credentials'],\n\t\t\twhere: { credentialsId: credential.id },\n\t\t});\n\n\t\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update non-owned cred for owner","suites":["PATCH /credentials/:id"],"updatePoint":{"line":279,"column":45},"line":279,"code":"\ttest('should update non-owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst patchPayload = randomCredentialPayload();\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t.send(patchPayload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\t\texpect(name).toBe(patchPayload.name);\n\t\texpect(type).toBe(patchPayload.type);\n\n\t\tif (!patchPayload.nodesAccess) {\n\t\t\tfail('Payload did not contain a nodesAccess array');\n\t\t}\n\t\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\t\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\t\tconst credential = await Db.collections.Credentials.findOneByOrFail({ id });\n\n\t\texpect(credential.name).toBe(patchPayload.name);\n\t\texpect(credential.type).toBe(patchPayload.type);\n\t\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\t\texpect(credential.data).not.toBe(patchPayload.data);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['credentials'],\n\t\t\twhere: { credentialsId: credential.id },\n\t\t});\n\n\t\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update owned cred for member","suites":["PATCH /credentials/:id"],"updatePoint":{"line":316,"column":42},"line":316,"code":"\ttest('should update owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst patchPayload = randomCredentialPayload();\n\n\t\tconst response = await authMemberAgent\n\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t.send(patchPayload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\t\texpect(name).toBe(patchPayload.name);\n\t\texpect(type).toBe(patchPayload.type);\n\n\t\tif (!patchPayload.nodesAccess) {\n\t\t\tfail('Payload did not contain a nodesAccess array');\n\t\t}\n\t\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\t\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\t\tconst credential = await Db.collections.Credentials.findOneByOrFail({ id });\n\n\t\texpect(credential.name).toBe(patchPayload.name);\n\t\texpect(credential.type).toBe(patchPayload.type);\n\t\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\t\texpect(credential.data).not.toBe(patchPayload.data);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['credentials'],\n\t\t\twhere: { credentialsId: credential.id },\n\t\t});\n\n\t\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not update non-owned cred for member","suites":["PATCH /credentials/:id"],"updatePoint":{"line":353,"column":50},"line":353,"code":"\ttest('should not update non-owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst patchPayload = randomCredentialPayload();\n\n\t\tconst response = await authMemberAgent\n\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t.send(patchPayload);\n\n\t\texpect(response.statusCode).toBe(404);\n\n\t\tconst shellCredential = await Db.collections.Credentials.findOneByOrFail({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(shellCredential.name).not.toBe(patchPayload.name); // not updated\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["PATCH /credentials/:id"],"updatePoint":{"line":370,"column":38},"line":370,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tawait Promise.all(\n\t\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\t\tconst response = await authOwnerAgent\n\t\t\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t\t\t.send(invalidPayload);\n\n\t\t\t\tif (response.statusCode === 500) {\n\t\t\t\t\tconsole.log(response.statusCode, response.body);\n\t\t\t\t}\n\t\t\t\texpect(response.statusCode).toBe(400);\n\t\t\t}),\n\t\t);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if cred not found","suites":["PATCH /credentials/:id"],"updatePoint":{"line":387,"column":36},"line":387,"code":"\ttest('should fail if cred not found', async () => {\n\t\tconst response = await authOwnerAgent.patch('/credentials/123').send(randomCredentialPayload());\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with missing encryption key","suites":["PATCH /credentials/:id"],"updatePoint":{"line":393,"column":46},"line":393,"code":"\ttest('should fail with missing encryption key', async () => {\n\t\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\t\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\t\tconst response = await authOwnerAgent.post('/credentials').send(randomCredentialPayload());\n\n\t\texpect(response.statusCode).toBe(500);\n\n\t\tmock.mockRestore();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return default name for new credential or its increment","suites":["GET /credentials/new"],"updatePoint":{"line":406,"column":69},"line":406,"code":"\ttest('should return default name for new credential or its increment', async () => {\n\t\tconst name = config.getEnv('credentials.defaultName');\n\t\tlet tempName = name;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst response = await authOwnerAgent.get(`/credentials/new?name=${name}`);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\tif (i === 0) {\n\t\t\t\texpect(response.body.data.name).toBe(name);\n\t\t\t} else {\n\t\t\t\ttempName = name + ' ' + (i + 1);\n\t\t\t\texpect(response.body.data.name).toBe(tempName);\n\t\t\t}\n\t\t\tawait saveCredential({ ...randomCredentialPayload(), name: tempName }, { user: owner });\n\t\t}\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return name from query for new credential or its increment","suites":["GET /credentials/new"],"updatePoint":{"line":424,"column":72},"line":424,"code":"\ttest('should return name from query for new credential or its increment', async () => {\n\t\tconst name = 'special credential name';\n\t\tlet tempName = name;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst response = await authOwnerAgent.get(`/credentials/new?name=${name}`);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\tif (i === 0) {\n\t\t\t\texpect(response.body.data.name).toBe(name);\n\t\t\t} else {\n\t\t\t\ttempName = name + ' ' + (i + 1);\n\t\t\t\texpect(response.body.data.name).toBe(tempName);\n\t\t\t}\n\t\t\tawait saveCredential({ ...randomCredentialPayload(), name: tempName }, { user: owner });\n\t\t}\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve owned cred for owner","suites":["GET /credentials/:id"],"updatePoint":{"line":444,"column":43},"line":444,"code":"\ttest('should retrieve owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst firstResponse = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(firstResponse.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(firstResponse.body.data);\n\t\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\t\tconst secondResponse = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\tvalidateMainCredentialData(secondResponse.body.data);\n\t\texpect(secondResponse.body.data.data).toBeDefined();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve owned cred for member","suites":["GET /credentials/:id"],"updatePoint":{"line":462,"column":44},"line":462,"code":"\ttest('should retrieve owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst firstResponse = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(firstResponse.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(firstResponse.body.data);\n\t\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\t\tconst secondResponse = await authMemberAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(secondResponse.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(secondResponse.body.data);\n\t\texpect(secondResponse.body.data.data).toBeDefined();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve non-owned cred for owner","suites":["GET /credentials/:id"],"updatePoint":{"line":482,"column":47},"line":482,"code":"\ttest('should retrieve non-owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst response1 = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response1.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(response1.body.data);\n\t\texpect(response1.body.data.data).toBeUndefined();\n\n\t\tconst response2 = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(response2.statusCode).toBe(200);\n\n\t\tvalidateMainCredentialData(response2.body.data);\n\t\texpect(response2.body.data.data).toBeDefined();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not retrieve non-owned cred for member","suites":["GET /credentials/:id"],"updatePoint":{"line":502,"column":52},"line":502,"code":"\ttest('should not retrieve non-owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst response = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(404);\n\t\texpect(response.body.data).toBeUndefined(); // owner's cred not returned\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with missing encryption key","suites":["GET /credentials/:id"],"updatePoint":{"line":511,"column":46},"line":511,"code":"\ttest('should fail with missing encryption key', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\t\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t\t.query({ includeData: true });\n\n\t\texpect(response.statusCode).toBe(500);\n\n\t\tmock.mockRestore();\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 404 if cred not found","suites":["GET /credentials/:id"],"updatePoint":{"line":526,"column":42},"line":526,"code":"\ttest('should return 404 if cred not found', async () => {\n\t\tconst response = await authOwnerAgent.get('/credentials/789');\n\t\texpect(response.statusCode).toBe(404);\n\n\t\tconst responseAbc = await authOwnerAgent.get('/credentials/abc');\n\t\texpect(responseAbc.statusCode).toBe(404);\n\t});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return Source Control preferences","suites":["GET /sourceControl/preferences"],"updatePoint":{"line":38,"column":47},"line":38,"code":"\ttest('should return Source Control preferences', async () => {\n\t\tawait authOwnerAgent\n\t\t\t.get(`/${SOURCE_CONTROL_API_ROOT}/preferences`)\n\t\t\t.expect(200)\n\t\t\t.expect((res) => {\n\t\t\t\treturn 'repositoryUrl' in res.body && 'branchName' in res.body;\n\t\t\t});\n\t});","file":"integration/environments/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return repo sync status","suites":["GET /sourceControl/preferences"],"updatePoint":{"line":47,"column":37},"line":47,"code":"\ttest('should return repo sync status', async () => {\n\t\tContainer.get(SourceControlService).getStatus = async () => {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tid: 'haQetoXq9GxHSkft',\n\t\t\t\t\tname: 'My workflow 6 edit',\n\t\t\t\t\ttype: 'workflow',\n\t\t\t\t\tstatus: 'modified',\n\t\t\t\t\tlocation: 'local',\n\t\t\t\t\tconflict: true,\n\t\t\t\t\tfile: '/Users/michael/.n8n/git/workflows/haQetoXq9GxHSkft.json',\n\t\t\t\t\tupdatedAt: '2023-07-14T11:24:41.000Z',\n\t\t\t\t},\n\t\t\t] as SourceControlledFile[];\n\t\t};\n\t\tawait authOwnerAgent\n\t\t\t.get(`/${SOURCE_CONTROL_API_ROOT}/get-status`)\n\t\t\t.query({ direction: 'push', preferLocalVersion: 'true', verbose: 'false' })\n\t\t\t.expect(200)\n\t\t\t.expect((res) => {\n\t\t\t\tconst data: SourceControlledFile[] = res.body.data;\n\t\t\t\texpect(data.length).toBe(1);\n\t\t\t\texpect(data[0].id).toBe('haQetoXq9GxHSkft');\n\t\t\t});\n\t});","file":"integration/environments/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should have a running logwriter process","suites":[],"updatePoint":{"line":102,"column":45},"line":102,"code":"test('should have a running logwriter process', () => {\n\tconst thread = eventBus.logWriter.worker;\n\texpect(thread).toBeDefined();\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should have logwriter log messages","suites":[],"updatePoint":{"line":107,"column":40},"line":107,"code":"test('should have logwriter log messages', async () => {\n\tconst testMessage = new EventMessageGeneric({\n\t\teventName: 'n8n.test.message' as EventNamesTypes,\n\t\tid: uuid(),\n\t});\n\tawait eventBus.send(testMessage);\n\tawait new Promise((resolve) => {\n\t\teventBus.logWriter.worker?.once('message', async (msg: { command: string; data: any }) => {\n\t\t\texpect(msg.command).toBe('appendMessageToLog');\n\t\t\texpect(msg.data).toBe(true);\n\t\t\tawait confirmIdInAll(testMessage.id);\n\t\t\tresolve(true);\n\t\t});\n\t});\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing authentication","suites":["GET /eventbus/destination"],"updatePoint":{"line":124,"column":48},"line":124,"code":"\ttest('should fail due to missing authentication', async () => {\n\t\tconst response = await testServer.authlessAgent.get('/eventbus/destination');\n\t\texpect(response.statusCode).toBe(401);\n\t});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"all returned destinations should exist in eventbus","suites":["GET /eventbus/destination"],"updatePoint":{"line":129,"column":57},"line":129,"code":"\ttest('all returned destinations should exist in eventbus', async () => {\n\t\tconst response = await authOwnerAgent.get('/eventbus/destination');\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst data = response.body.data;\n\t\texpect(data).toBeTruthy();\n\t\texpect(Array.isArray(data)).toBeTruthy();\n\n\t\tfor (let index = 0; index < data.length; index++) {\n\t\t\tconst destination = data[index];\n\t\t\tconst foundDestinations = await eventBus.findDestination(destination.id);\n\t\t\texpect(Array.isArray(foundDestinations)).toBeTruthy();\n\t\t\texpect(foundDestinations.length).toBe(1);\n\t\t\texpect(foundDestinations[0].label).toBe(destination.label);\n\t\t}\n\t});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"create syslog destination","suites":["POST /eventbus/destination"],"updatePoint":{"line":148,"column":32},"line":148,"code":"\ttest('create syslog destination', async () => {\n\t\tconst response = await authOwnerAgent.post('/eventbus/destination').send(testSyslogDestination);\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"create sentry destination","suites":["POST /eventbus/destination"],"updatePoint":{"line":153,"column":32},"line":153,"code":"\ttest('create sentry destination', async () => {\n\t\tconst response = await authOwnerAgent.post('/eventbus/destination').send(testSentryDestination);\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"create webhook destination","suites":["POST /eventbus/destination"],"updatePoint":{"line":158,"column":33},"line":158,"code":"\ttest('create webhook destination', async () => {\n\t\tconst response = await authOwnerAgent\n\t\t\t.post('/eventbus/destination')\n\t\t\t.send(testWebhookDestination);\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send message to syslog","suites":["POST /eventbus/destination"],"line":168,"code":"test.skip('should send message to syslog', async () => {","file":"integration/eventbus.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"should confirm send message if there are no subscribers","suites":["POST /eventbus/destination"],"line":209,"code":"test.skip('should confirm send message if there are no subscribers', async () => {","file":"integration/eventbus.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"should anonymize audit message to syslog ","suites":["POST /eventbus/destination"],"updatePoint":{"line":240,"column":47},"line":240,"code":"test('should anonymize audit message to syslog ', async () => {\n\tconst testAuditMessage = new EventMessageAudit({\n\t\teventName: 'n8n.audit.user.updated',\n\t\tpayload: {\n\t\t\t_secret: 'secret',\n\t\t\tpublic: 'public',\n\t\t},\n\t\tid: uuid(),\n\t});\n\n\tconst syslogDestination = eventBus.destinations[\n\t\ttestSyslogDestination.id!\n\t] as MessageEventBusDestinationSyslog;\n\n\tsyslogDestination.enable();\n\n\tconst mockedSyslogClientLog = jest.spyOn(syslogDestination.client, 'log');\n\tmockedSyslogClientLog.mockImplementation((m, _options, _cb) => {\n\t\tconst o = JSON.parse(m);\n\t\texpect(o).toHaveProperty('payload');\n\t\texpect(o.payload).toHaveProperty('_secret');\n\t\tsyslogDestination.anonymizeAuditMessages\n\t\t\t? expect(o.payload._secret).toBe('*')\n\t\t\t: expect(o.payload._secret).toBe('secret');\n\t\texpect(o.payload).toHaveProperty('public');\n\t\texpect(o.payload.public).toBe('public');\n\t\treturn syslogDestination.client;\n\t});\n\n\tsyslogDestination.anonymizeAuditMessages = true;\n\tawait eventBus.send(testAuditMessage);\n\tawait new Promise((resolve) => {\n\t\teventBus.logWriter.worker?.on(\n\t\t\t'message',\n\t\t\tasync function handler005(msg: { command: string; data: any }) {\n\t\t\t\tif (msg.command === 'appendMessageToLog') {\n\t\t\t\t\tconst sent = await eventBus.getEventsAll();\n\t\t\t\t\tawait confirmIdInAll(testAuditMessage.id);\n\t\t\t\t\texpect(mockedSyslogClientLog).toHaveBeenCalled();\n\t\t\t\t\teventBus.logWriter.worker?.removeListener('message', handler005);\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n\n\tsyslogDestination.anonymizeAuditMessages = false;\n\tawait eventBus.send(testAuditMessage);\n\tawait new Promise((resolve) => {\n\t\teventBus.logWriter.worker?.on(\n\t\t\t'message',\n\t\t\tasync function handler006(msg: { command: string; data: any }) {\n\t\t\t\tif (msg.command === 'appendMessageToLog') {\n\t\t\t\t\tconst sent = await eventBus.getEventsAll();\n\t\t\t\t\tawait confirmIdInAll(testAuditMessage.id);\n\t\t\t\t\texpect(mockedSyslogClientLog).toHaveBeenCalled();\n\t\t\t\t\tsyslogDestination.disable();\n\t\t\t\t\teventBus.logWriter.worker?.removeListener('message', handler006);\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send message to webhook ","suites":["POST /eventbus/destination"],"updatePoint":{"line":305,"column":37},"line":305,"code":"test('should send message to webhook ', async () => {\n\tconst testMessage = new EventMessageGeneric({\n\t\teventName: 'n8n.test.message' as EventNamesTypes,\n\t\tid: uuid(),\n\t});\n\n\tconst webhookDestination = eventBus.destinations[\n\t\ttestWebhookDestination.id!\n\t] as MessageEventBusDestinationWebhook;\n\n\twebhookDestination.enable();\n\n\tmockedAxios.post.mockResolvedValue({ status: 200, data: { msg: 'OK' } });\n\tmockedAxios.request.mockResolvedValue({ status: 200, data: { msg: 'OK' } });\n\n\tawait eventBus.send(testMessage);\n\tawait new Promise((resolve) => {\n\t\teventBus.logWriter.worker?.on(\n\t\t\t'message',\n\t\t\tasync function handler003(msg: { command: string; data: any }) {\n\t\t\t\tif (msg.command === 'appendMessageToLog') {\n\t\t\t\t\tawait confirmIdInAll(testMessage.id);\n\t\t\t\t} else if (msg.command === 'confirmMessageSent') {\n\t\t\t\t\tawait confirmIdSent(testMessage.id);\n\t\t\t\t\texpect(mockedAxios.request).toHaveBeenCalled();\n\t\t\t\t\twebhookDestination.disable();\n\t\t\t\t\teventBus.logWriter.worker?.removeListener('message', handler003);\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send message to sentry ","suites":["POST /eventbus/destination"],"updatePoint":{"line":339,"column":36},"line":339,"code":"test('should send message to sentry ', async () => {\n\tconst testMessage = new EventMessageGeneric({\n\t\teventName: 'n8n.test.message' as EventNamesTypes,\n\t\tid: uuid(),\n\t});\n\n\tconst sentryDestination = eventBus.destinations[\n\t\ttestSentryDestination.id!\n\t] as MessageEventBusDestinationSentry;\n\n\tsentryDestination.enable();\n\n\tconst mockedSentryCaptureMessage = jest.spyOn(sentryDestination.sentryClient!, 'captureMessage');\n\tmockedSentryCaptureMessage.mockImplementation((_m, _level, _hint, _scope) => {\n\t\teventBus.confirmSent(testMessage, {\n\t\t\tid: sentryDestination.id,\n\t\t\tname: sentryDestination.label,\n\t\t});\n\t\treturn testMessage.id;\n\t});\n\n\tawait eventBus.send(testMessage);\n\tawait new Promise((resolve) => {\n\t\teventBus.logWriter.worker?.on(\n\t\t\t'message',\n\t\t\tasync function handler004(msg: { command: string; data: any }) {\n\t\t\t\tif (msg.command === 'appendMessageToLog') {\n\t\t\t\t\tawait confirmIdInAll(testMessage.id);\n\t\t\t\t} else if (msg.command === 'confirmMessageSent') {\n\t\t\t\t\tawait confirmIdSent(testMessage.id);\n\t\t\t\t\texpect(mockedSentryCaptureMessage).toHaveBeenCalled();\n\t\t\t\t\tsentryDestination.disable();\n\t\t\t\t\teventBus.logWriter.worker?.removeListener('message', handler004);\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /eventbus/destination delete all destinations by id","suites":["POST /eventbus/destination"],"updatePoint":{"line":379,"column":64},"line":379,"code":"test('DELETE /eventbus/destination delete all destinations by id', async () => {\n\tconst existingDestinationIds = [...Object.keys(eventBus.destinations)];\n\n\tawait Promise.all(\n\t\texistingDestinationIds.map(async (id) => {\n\t\t\tconst response = await authOwnerAgent.del('/eventbus/destination').query({ id });\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t}),\n\t);\n\n\texpect(Object.keys(eventBus.destinations).length).toBe(0);\n});","file":"integration/eventbus.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Member role should not be able to access ldap routes","suites":[],"updatePoint":{"line":94,"column":58},"line":94,"code":"test('Member role should not be able to access ldap routes', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authAgent = testServer.authAgentFor(member);\n\tawait authAgent.get('/ldap/config').expect(403);\n\tawait authAgent.put('/ldap/config').expect(403);\n\tawait authAgent.post('/ldap/test-connection').expect(403);\n\tawait authAgent.post('/ldap/sync').expect(403);\n\tawait authAgent.get('/ldap/sync').expect(403);\n});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"route should validate payload","suites":["PUT /ldap/config"],"updatePoint":{"line":105,"column":36},"line":105,"code":"\ttest('route should validate payload', async () => {\n\t\tconst invalidValuePayload = {\n\t\t\t...LDAP_DEFAULT_CONFIGURATION,\n\t\t\tloginEnabled: '', // enabled property only allows boolean\n\t\t\tloginLabel: '',\n\t\t};\n\n\t\tconst invalidExtraPropertyPayload = {\n\t\t\t...LDAP_DEFAULT_CONFIGURATION,\n\t\t\texample: true, // property not defined in the validation schema\n\t\t};\n\n\t\tconst missingPropertyPayload = {\n\t\t\tloginEnabled: true,\n\t\t\tloginLabel: '',\n\t\t\t// missing all other properties defined in the schema\n\t\t};\n\n\t\tconst invalidPayloads = [\n\t\t\tinvalidValuePayload,\n\t\t\tinvalidExtraPropertyPayload,\n\t\t\tmissingPropertyPayload,\n\t\t];\n\n\t\tfor (const invalidPayload of invalidPayloads) {\n\t\t\tconst response = await authOwnerAgent.put('/ldap/config').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t\texpect(response.body).toHaveProperty('message');\n\t\t}\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"route should update model","suites":["PUT /ldap/config"],"updatePoint":{"line":136,"column":32},"line":136,"code":"\ttest('route should update model', async () => {\n\t\tconst validPayload = {\n\t\t\t...LDAP_DEFAULT_CONFIGURATION,\n\t\t\tloginEnabled: true,\n\t\t\tloginLabel: '',\n\t\t};\n\n\t\tconst response = await authOwnerAgent.put('/ldap/config').send(validPayload);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.loginEnabled).toBe(true);\n\t\texpect(response.body.data.loginLabel).toBe('');\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should apply \"Convert all LDAP users to email users\" strategy when LDAP login disabled","suites":["PUT /ldap/config"],"updatePoint":{"line":150,"column":93},"line":150,"code":"\ttest('should apply \"Convert all LDAP users to email users\" strategy when LDAP login disabled', async () => {\n\t\tconst ldapConfig = await createLdapConfig();\n\t\tLdapManager.updateConfig(ldapConfig);\n\n\t\tconst member = await testDb.createLdapUser({ globalRole: globalMemberRole }, uniqueId());\n\n\t\tconst configuration = ldapConfig;\n\n\t\t// disable the login, so the strategy is applied\n\t\tawait authOwnerAgent.put('/ldap/config').send({ ...configuration, loginEnabled: false });\n\n\t\tconst emailUser = await Db.collections.User.findOneByOrFail({ id: member.id });\n\t\tconst localLdapIdentities = await testDb.getLdapIdentities();\n\n\t\texpect(getCurrentAuthenticationMethod()).toBe('email');\n\t\texpect(emailUser.email).toBe(member.email);\n\t\texpect(emailUser.lastName).toBe(member.lastName);\n\t\texpect(emailUser.firstName).toBe(member.firstName);\n\t\texpect(localLdapIdentities.length).toEqual(0);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /ldap/config route should retrieve current configuration","suites":["PUT /ldap/config"],"updatePoint":{"line":172,"column":66},"line":172,"code":"test('GET /ldap/config route should retrieve current configuration', async () => {\n\tconst validPayload = {\n\t\t...LDAP_DEFAULT_CONFIGURATION,\n\t\tloginEnabled: true,\n\t\tloginLabel: '',\n\t};\n\n\tlet response = await authOwnerAgent.put('/ldap/config').send(validPayload);\n\texpect(response.statusCode).toBe(200);\n\texpect(getCurrentAuthenticationMethod()).toBe('ldap');\n\n\tresponse = await authOwnerAgent.get('/ldap/config');\n\n\texpect(response.body.data).toMatchObject(validPayload);\n});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"route should success","suites":["POST /ldap/test-connection"],"updatePoint":{"line":189,"column":27},"line":189,"code":"\ttest('route should success', async () => {\n\t\tjest.spyOn(LdapService.prototype, 'testConnection').mockResolvedValue();\n\n\t\tawait authOwnerAgent.post('/ldap/test-connection').expect(200);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"route should fail","suites":["POST /ldap/test-connection"],"updatePoint":{"line":195,"column":24},"line":195,"code":"\ttest('route should fail', async () => {\n\t\tconst errorMessage = 'Invalid connection';\n\n\t\tjest.spyOn(LdapService.prototype, 'testConnection').mockRejectedValue(new Error(errorMessage));\n\n\t\tconst response = await authOwnerAgent.post('/ldap/test-connection');\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body).toHaveProperty('message');\n\t\texpect(response.body.message).toStrictEqual(errorMessage);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect new user but not persist change in model","suites":["POST /ldap/sync","dry mode"],"updatePoint":{"line":241,"column":62},"line":241,"code":"\t\ttest('should detect new user but not persist change in model', async () => {\n\t\t\tconst synchronization = await runTest([\n\t\t\t\t{\n\t\t\t\t\tdn: '',\n\t\t\t\t\tmail: randomEmail(),\n\t\t\t\t\tsn: randomName(),\n\t\t\t\t\tgivenName: randomName(),\n\t\t\t\t\tuid: uniqueId(),\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(synchronization.created).toBe(1);\n\n\t\t\t// Make sure only the instance owner is on the DB\n\t\t\tconst localDbUsers = await Db.collections.User.find();\n\t\t\texpect(localDbUsers.length).toBe(1);\n\t\t\texpect(localDbUsers[0].id).toBe(owner.id);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect updated user but not persist change in model","suites":["POST /ldap/sync","dry mode"],"updatePoint":{"line":260,"column":66},"line":260,"code":"\t\ttest('should detect updated user but not persist change in model', async () => {\n\t\t\tconst ldapUserEmail = randomEmail();\n\t\t\tconst ldapUserId = uniqueId();\n\n\t\t\tconst member = await testDb.createLdapUser(\n\t\t\t\t{ globalRole: globalMemberRole, email: ldapUserEmail },\n\t\t\t\tldapUserId,\n\t\t\t);\n\n\t\t\tconst synchronization = await runTest([\n\t\t\t\t{\n\t\t\t\t\tdn: '',\n\t\t\t\t\tmail: ldapUserEmail,\n\t\t\t\t\tsn: randomName(),\n\t\t\t\t\tgivenName: 'updated',\n\t\t\t\t\tuid: ldapUserId,\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(synchronization.updated).toBe(1);\n\n\t\t\t// Make sure the changes in the \"LDAP server\" were not persisted in the database\n\t\t\tconst localLdapIdentities = await testDb.getLdapIdentities();\n\t\t\tconst localLdapUsers = localLdapIdentities.map(({ user }) => user);\n\t\t\texpect(localLdapUsers.length).toBe(1);\n\t\t\texpect(localLdapUsers[0].id).toBe(member.id);\n\t\t\texpect(localLdapUsers[0].lastName).toBe(member.lastName);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect disabled user but not persist change in model","suites":["POST /ldap/sync","dry mode"],"updatePoint":{"line":289,"column":67},"line":289,"code":"\t\ttest('should detect disabled user but not persist change in model', async () => {\n\t\t\tconst ldapUserEmail = randomEmail();\n\t\t\tconst ldapUserId = uniqueId();\n\n\t\t\tconst member = await testDb.createLdapUser(\n\t\t\t\t{ globalRole: globalMemberRole, email: ldapUserEmail },\n\t\t\t\tldapUserId,\n\t\t\t);\n\n\t\t\tconst synchronization = await runTest([]);\n\n\t\t\texpect(synchronization.disabled).toBe(1);\n\n\t\t\t// Make sure the changes in the \"LDAP server\" were not persisted in the database\n\t\t\tconst localLdapIdentities = await testDb.getLdapIdentities();\n\t\t\tconst localLdapUsers = localLdapIdentities.map(({ user }) => user);\n\t\t\texpect(localLdapUsers.length).toBe(1);\n\t\t\texpect(localLdapUsers[0].id).toBe(member.id);\n\t\t\texpect(localLdapUsers[0].disabled).toBe(false);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect new user and persist change in model","suites":["POST /ldap/sync","live mode"],"updatePoint":{"line":334,"column":58},"line":334,"code":"\t\ttest('should detect new user and persist change in model', async () => {\n\t\t\tconst ldapUser = {\n\t\t\t\tmail: randomEmail(),\n\t\t\t\tdn: '',\n\t\t\t\tsn: randomName(),\n\t\t\t\tgivenName: randomName(),\n\t\t\t\tuid: uniqueId(),\n\t\t\t};\n\n\t\t\tconst synchronization = await runTest([ldapUser]);\n\t\t\texpect(synchronization.created).toBe(1);\n\n\t\t\t// Make sure the changes in the \"LDAP server\" were persisted in the database\n\t\t\tconst allUsers = await testDb.getAllUsers();\n\t\t\texpect(allUsers.length).toBe(2);\n\n\t\t\tconst ownerUser = allUsers.find((u) => u.email === owner.email)!;\n\t\t\texpect(ownerUser.email).toBe(owner.email);\n\n\t\t\tconst memberUser = allUsers.find((u) => u.email !== owner.email)!;\n\t\t\texpect(memberUser.email).toBe(ldapUser.mail);\n\t\t\texpect(memberUser.lastName).toBe(ldapUser.sn);\n\t\t\texpect(memberUser.firstName).toBe(ldapUser.givenName);\n\n\t\t\tconst authIdentities = await testDb.getLdapIdentities();\n\t\t\texpect(authIdentities.length).toBe(1);\n\t\t\texpect(authIdentities[0].providerId).toBe(ldapUser.uid);\n\t\t\texpect(authIdentities[0].providerType).toBe('ldap');\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect updated user and persist change in model","suites":["POST /ldap/sync","live mode"],"updatePoint":{"line":364,"column":62},"line":364,"code":"\t\ttest('should detect updated user and persist change in model', async () => {\n\t\t\tconst ldapUser = {\n\t\t\t\tmail: randomEmail(),\n\t\t\t\tdn: '',\n\t\t\t\tsn: 'updated',\n\t\t\t\tgivenName: randomName(),\n\t\t\t\tuid: uniqueId(),\n\t\t\t};\n\n\t\t\tawait testDb.createLdapUser(\n\t\t\t\t{\n\t\t\t\t\tglobalRole: globalMemberRole,\n\t\t\t\t\temail: ldapUser.mail,\n\t\t\t\t\tfirstName: ldapUser.givenName,\n\t\t\t\t\tlastName: randomName(),\n\t\t\t\t},\n\t\t\t\tldapUser.uid,\n\t\t\t);\n\n\t\t\tconst synchronization = await runTest([ldapUser]);\n\t\t\texpect(synchronization.updated).toBe(1);\n\n\t\t\t// Make sure the changes in the \"LDAP server\" were persisted in the database\n\t\t\tconst localLdapIdentities = await testDb.getLdapIdentities();\n\t\t\tconst localLdapUsers = localLdapIdentities.map(({ user }) => user);\n\n\t\t\texpect(localLdapUsers.length).toBe(1);\n\t\t\texpect(localLdapUsers[0].email).toBe(ldapUser.mail);\n\t\t\texpect(localLdapUsers[0].lastName).toBe(ldapUser.sn);\n\t\t\texpect(localLdapUsers[0].firstName).toBe(ldapUser.givenName);\n\t\t\texpect(localLdapIdentities[0].providerId).toBe(ldapUser.uid);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect disabled user and persist change in model","suites":["POST /ldap/sync","live mode"],"updatePoint":{"line":397,"column":63},"line":397,"code":"\t\ttest('should detect disabled user and persist change in model', async () => {\n\t\t\tconst ldapUser = {\n\t\t\t\tmail: randomEmail(),\n\t\t\t\tdn: '',\n\t\t\t\tsn: 'updated',\n\t\t\t\tgivenName: randomName(),\n\t\t\t\tuid: uniqueId(),\n\t\t\t};\n\n\t\t\tawait testDb.createLdapUser(\n\t\t\t\t{\n\t\t\t\t\tglobalRole: globalMemberRole,\n\t\t\t\t\temail: ldapUser.mail,\n\t\t\t\t\tfirstName: ldapUser.givenName,\n\t\t\t\t\tlastName: ldapUser.sn,\n\t\t\t\t},\n\t\t\t\tldapUser.uid,\n\t\t\t);\n\n\t\t\tconst synchronization = await runTest([]);\n\t\t\texpect(synchronization.disabled).toBe(1);\n\n\t\t\t// Make sure the changes in the \"LDAP server\" were persisted in the database\n\t\t\tconst allUsers = await testDb.getAllUsers();\n\t\t\texpect(allUsers.length).toBe(2);\n\n\t\t\tconst ownerUser = allUsers.find((u) => u.email === owner.email)!;\n\t\t\texpect(ownerUser.email).toBe(owner.email);\n\n\t\t\tconst memberUser = allUsers.find((u) => u.email !== owner.email)!;\n\t\t\texpect(memberUser.email).toBe(ldapUser.mail);\n\t\t\texpect(memberUser.lastName).toBe(ldapUser.sn);\n\t\t\texpect(memberUser.firstName).toBe(ldapUser.givenName);\n\t\t\texpect(memberUser.disabled).toBe(true);\n\n\t\t\tconst authIdentities = await testDb.getLdapIdentities();\n\t\t\texpect(authIdentities.length).toBe(0);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should remove user instance access once the user is disabled during synchronization","suites":["POST /ldap/sync","live mode"],"updatePoint":{"line":436,"column":91},"line":436,"code":"\t\ttest('should remove user instance access once the user is disabled during synchronization', async () => {\n\t\t\tconst member = await testDb.createLdapUser({ globalRole: globalMemberRole }, uniqueId());\n\n\t\t\tjest.spyOn(LdapService.prototype, 'searchWithAdminBinding').mockResolvedValue([]);\n\n\t\t\tawait authOwnerAgent.post('/ldap/sync').send({ type: 'live' });\n\n\t\t\tconst response = await testServer.authAgentFor(member).get('/login');\n\t\t\texpect(response.body.code).toBe(401);\n\t\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /ldap/sync should return paginated synchronizations","suites":["POST /ldap/sync","live mode"],"updatePoint":{"line":449,"column":61},"line":449,"code":"test('GET /ldap/sync should return paginated synchronizations', async () => {\n\tfor (let i = 0; i < 2; i++) {\n\t\tawait saveLdapSynchronization({\n\t\t\tcreated: 0,\n\t\t\tscanned: 0,\n\t\t\tupdated: 0,\n\t\t\tdisabled: 0,\n\t\t\tstartedAt: new Date(),\n\t\t\tendedAt: new Date(),\n\t\t\tstatus: 'success',\n\t\t\terror: '',\n\t\t\trunMode: 'dry',\n\t\t});\n\t}\n\n\tlet response = await authOwnerAgent.get('/ldap/sync?perPage=1&page=0');\n\texpect(response.body.data.length).toBe(1);\n\n\tresponse = await authOwnerAgent.get('/ldap/sync?perPage=1&page=1');\n\texpect(response.body.data.length).toBe(1);\n});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow new LDAP user to login and synchronize data","suites":["POST /login"],"updatePoint":{"line":500,"column":63},"line":500,"code":"\ttest('should allow new LDAP user to login and synchronize data', async () => {\n\t\tconst ldapUser = {\n\t\t\tmail: randomEmail(),\n\t\t\tdn: '',\n\t\t\tsn: '',\n\t\t\tgivenName: randomName(),\n\t\t\tuid: uniqueId(),\n\t\t};\n\t\tawait runTest(ldapUser);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow existing LDAP user to login and synchronize data","suites":["POST /login"],"updatePoint":{"line":511,"column":68},"line":511,"code":"\ttest('should allow existing LDAP user to login and synchronize data', async () => {\n\t\tconst ldapUser = {\n\t\t\tmail: randomEmail(),\n\t\t\tdn: '',\n\t\t\tsn: 'updated',\n\t\t\tgivenName: 'updated',\n\t\t\tuid: uniqueId(),\n\t\t};\n\n\t\tawait testDb.createLdapUser(\n\t\t\t{\n\t\t\t\tglobalRole: globalMemberRole,\n\t\t\t\temail: ldapUser.mail,\n\t\t\t\tfirstName: 'firstname',\n\t\t\t\tlastName: 'lastname',\n\t\t\t},\n\t\t\tldapUser.uid,\n\t\t);\n\n\t\tawait runTest(ldapUser);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should transform email user into LDAP user when match found","suites":["POST /login"],"updatePoint":{"line":533,"column":66},"line":533,"code":"\ttest('should transform email user into LDAP user when match found', async () => {\n\t\tconst ldapUser = {\n\t\t\tmail: randomEmail(),\n\t\t\tdn: '',\n\t\t\tsn: randomName(),\n\t\t\tgivenName: randomName(),\n\t\t\tuid: uniqueId(),\n\t\t};\n\n\t\tawait testDb.createUser({\n\t\t\tglobalRole: globalMemberRole,\n\t\t\temail: ldapUser.mail,\n\t\t\tfirstName: ldapUser.givenName,\n\t\t\tlastName: 'lastname',\n\t\t});\n\n\t\tawait runTest(ldapUser);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"don't transfer workflows","suites":["Instance owner should able to delete LDAP users"],"updatePoint":{"line":554,"column":31},"line":554,"code":"\ttest(\"don't transfer workflows\", async () => {\n\t\tconst ldapConfig = await createLdapConfig();\n\t\tLdapManager.updateConfig(ldapConfig);\n\n\t\tconst member = await testDb.createLdapUser({ globalRole: globalMemberRole }, uniqueId());\n\n\t\tawait authOwnerAgent.post(`/users/${member.id}`);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"transfer workflows and credentials","suites":["Instance owner should able to delete LDAP users"],"updatePoint":{"line":563,"column":41},"line":563,"code":"\ttest('transfer workflows and credentials', async () => {\n\t\tconst ldapConfig = await createLdapConfig();\n\t\tLdapManager.updateConfig(ldapConfig);\n\n\t\tconst member = await testDb.createLdapUser({ globalRole: globalMemberRole }, uniqueId());\n\n\t\t// delete the LDAP member and transfer its workflows/credentials to instance owner\n\t\tawait authOwnerAgent.post(`/users/${member.id}?transferId=${owner.id}`);\n\t});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Sign-type should be returned when listing users","suites":["Instance owner should able to delete LDAP users"],"updatePoint":{"line":574,"column":53},"line":574,"code":"test('Sign-type should be returned when listing users', async () => {\n\tconst ldapConfig = await createLdapConfig();\n\tLdapManager.updateConfig(ldapConfig);\n\n\tawait testDb.createLdapUser(\n\t\t{\n\t\t\tglobalRole: globalMemberRole,\n\t\t},\n\t\tuniqueId(),\n\t);\n\n\tconst allUsers = await testDb.getAllUsers();\n\texpect(allUsers.length).toBe(2);\n\n\tconst ownerUser = allUsers.find((u) => u.email === owner.email)!;\n\texpect(sanitizeUser(ownerUser).signInType).toStrictEqual('email');\n\n\tconst memberUser = allUsers.find((u) => u.email !== owner.email)!;\n\texpect(sanitizeUser(memberUser).signInType).toStrictEqual('ldap');\n});","file":"integration/ldap/ldap.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return license information to the instance owner","suites":["GET /license"],"updatePoint":{"line":38,"column":62},"line":38,"code":"\ttest('should return license information to the instance owner', async () => {\n\t\t// No license defined so we just expect the result to be the defaults\n\t\tawait authOwnerAgent.get('/license').expect(200, DEFAULT_LICENSE_RESPONSE);\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return license information to a regular user","suites":["GET /license"],"updatePoint":{"line":43,"column":58},"line":43,"code":"\ttest('should return license information to a regular user', async () => {\n\t\t// No license defined so we just expect the result to be the defaults\n\t\tawait authMemberAgent.get('/license').expect(200, DEFAULT_LICENSE_RESPONSE);\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work for instance owner","suites":["POST /license/activate"],"updatePoint":{"line":50,"column":37},"line":50,"code":"\ttest('should work for instance owner', async () => {\n\t\tawait authOwnerAgent\n\t\t\t.post('/license/activate')\n\t\t\t.send({ activationKey: 'abcde' })\n\t\t\t.expect(200, DEFAULT_POST_RESPONSE);\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"does not work for regular users","suites":["POST /license/activate"],"updatePoint":{"line":57,"column":38},"line":57,"code":"\ttest('does not work for regular users', async () => {\n\t\tawait authMemberAgent\n\t\t\t.post('/license/activate')\n\t\t\t.send({ activationKey: 'abcde' })\n\t\t\t.expect(403, { code: 403, message: NON_OWNER_ACTIVATE_RENEW_MESSAGE });\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"errors out properly","suites":["POST /license/activate"],"updatePoint":{"line":64,"column":26},"line":64,"code":"\ttest('errors out properly', async () => {\n\t\tLicense.prototype.activate = jest.fn().mockImplementation(() => {\n\t\t\tthrow new Error(ACTIVATION_FAILED_MESSAGE);\n\t\t});\n\n\t\tawait authOwnerAgent\n\t\t\t.post('/license/activate')\n\t\t\t.send({ activationKey: 'abcde' })\n\t\t\t.expect(400, { code: 400, message: ACTIVATION_FAILED_MESSAGE });\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work for instance owner","suites":["POST /license/renew"],"updatePoint":{"line":77,"column":37},"line":77,"code":"\ttest('should work for instance owner', async () => {\n\t\t// No license defined so we just expect the result to be the defaults\n\t\tawait authOwnerAgent.post('/license/renew').expect(200, DEFAULT_POST_RESPONSE);\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"does not work for regular users","suites":["POST /license/renew"],"updatePoint":{"line":82,"column":38},"line":82,"code":"\ttest('does not work for regular users', async () => {\n\t\tawait authMemberAgent\n\t\t\t.post('/license/renew')\n\t\t\t.expect(403, { code: 403, message: NON_OWNER_ACTIVATE_RENEW_MESSAGE });\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"errors out properly","suites":["POST /license/renew"],"updatePoint":{"line":88,"column":26},"line":88,"code":"\ttest('errors out properly', async () => {\n\t\tLicense.prototype.renew = jest.fn().mockImplementation(() => {\n\t\t\tthrow new Error(RENEW_ERROR_MESSAGE);\n\t\t});\n\n\t\tawait authOwnerAgent\n\t\t\t.post('/license/renew')\n\t\t\t.expect(400, { code: 400, message: RENEW_ERROR_MESSAGE });\n\t});","file":"integration/license.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":42,"column":49},"line":42,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneByOrFail({ id });\n\n\t\t\texpect(storedOwnerShell.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwnerShell.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwnerShell.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Owner shell"],"updatePoint":{"line":79,"column":48},"line":79,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneByOrFail({});\n\t\t\texpect(storedOwnerShell.email).toBeNull();\n\t\t\texpect(storedOwnerShell.firstName).toBeNull();\n\t\t\texpect(storedOwnerShell.lastName).toBeNull();\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail for shell","suites":["Owner shell"],"updatePoint":{"line":91,"column":47},"line":91,"code":"\ttest('PATCH /me/password should fail for shell', async () => {\n\t\tconst validPasswordPayload = {\n\t\t\tcurrentPassword: randomValidPassword(),\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst validPayloads = [validPasswordPayload, ...INVALID_PASSWORD_PAYLOADS];\n\n\t\tfor (const payload of validPayloads) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me/password').send(payload);\n\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneByOrFail({});\n\n\t\t\tif (payload.newPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t}\n\n\t\t\tif (payload.currentPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t}\n\t\t}\n\n\t\tconst storedOwnerShell = await Db.collections.User.findOneByOrFail({});\n\t\texpect(storedOwnerShell.password).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":118,"column":55},"line":118,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authOwnerShellAgent.post('/me/survey').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: IsNull() },\n\t\t\t});\n\n\t\t\texpect(storedShellOwner.personalizationAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/api-key should create an api key","suites":["Owner shell"],"updatePoint":{"line":135,"column":48},"line":135,"code":"\ttest('POST /me/api-key should create an api key', async () => {\n\t\tconst response = await authOwnerShellAgent.post('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toBeDefined();\n\t\texpect(response.body.data.apiKey).not.toBeNull();\n\n\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\twhere: { email: IsNull() },\n\t\t});\n\n\t\texpect(storedShellOwner.apiKey).toEqual(response.body.data.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me/api-key should fetch the api key","suites":["Owner shell"],"updatePoint":{"line":149,"column":47},"line":149,"code":"\ttest('GET /me/api-key should fetch the api key', async () => {\n\t\tconst response = await authOwnerShellAgent.get('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toEqual(ownerShell.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /me/api-key should fetch the api key","suites":["Owner shell"],"updatePoint":{"line":156,"column":50},"line":156,"code":"\ttest('DELETE /me/api-key should fetch the api key', async () => {\n\t\tconst response = await authOwnerShellAgent.delete('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\twhere: { email: IsNull() },\n\t\t});\n\n\t\texpect(storedShellOwner.apiKey).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":185,"column":49},"line":185,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('member');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedMember = await Db.collections.User.findOneByOrFail({ id });\n\n\t\t\texpect(storedMember.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedMember.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedMember.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":222,"column":48},"line":222,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneByOrFail({});\n\t\t\texpect(storedMember.email).toBe(member.email);\n\t\t\texpect(storedMember.firstName).toBe(member.firstName);\n\t\t\texpect(storedMember.lastName).toBe(member.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":234,"column":58},"line":234,"code":"\ttest('PATCH /me/password should succeed with valid inputs', async () => {\n\t\tconst validPayload = {\n\t\t\tcurrentPassword: memberPassword,\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await authMemberAgent.patch('/me/password').send(validPayload);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\tconst storedMember = await Db.collections.User.findOneByOrFail({});\n\t\texpect(storedMember.password).not.toBe(member.password);\n\t\texpect(storedMember.password).not.toBe(validPayload.newPassword);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":249,"column":57},"line":249,"code":"\ttest('PATCH /me/password should fail with invalid inputs', async () => {\n\t\tfor (const payload of INVALID_PASSWORD_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me/password').send(payload);\n\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneByOrFail({});\n\n\t\t\tif (payload.newPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t}\n\t\t\tif (payload.currentPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t}\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":265,"column":55},"line":265,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authMemberAgent.post('/me/survey').send(validPayload);\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst { personalizationAnswers: storedAnswers } = await Db.collections.User.findOneByOrFail(\n\t\t\t\t{},\n\t\t\t);\n\n\t\t\texpect(storedAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/api-key should create an api key","suites":["Member"],"updatePoint":{"line":281,"column":48},"line":281,"code":"\ttest('POST /me/api-key should create an api key', async () => {\n\t\tconst response = await testServer.authAgentFor(member).post('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toBeDefined();\n\t\texpect(response.body.data.apiKey).not.toBeNull();\n\n\t\tconst storedMember = await Db.collections.User.findOneByOrFail({ id: member.id });\n\n\t\texpect(storedMember.apiKey).toEqual(response.body.data.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me/api-key should fetch the api key","suites":["Member"],"updatePoint":{"line":293,"column":47},"line":293,"code":"\ttest('GET /me/api-key should fetch the api key', async () => {\n\t\tconst response = await testServer.authAgentFor(member).get('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toEqual(member.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /me/api-key should fetch the api key","suites":["Member"],"updatePoint":{"line":300,"column":50},"line":300,"code":"\ttest('DELETE /me/api-key should fetch the api key', async () => {\n\t\tconst response = await testServer.authAgentFor(member).delete('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst storedMember = await Db.collections.User.findOneByOrFail({ id: member.id });\n\n\t\texpect(storedMember.apiKey).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner"],"updatePoint":{"line":316,"column":49},"line":316,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = testServer.authAgentFor(owner);\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedOwner = await Db.collections.User.findOneByOrFail({ id });\n\n\t\t\texpect(storedOwner.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwner.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwner.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return n8n version","suites":["Metrics"],"updatePoint":{"line":27,"column":30},"line":27,"code":"\tit('should return n8n version', async () => {\n\t\tconst n8nVersion = semverParse(N8N_VERSION || '0.0.0');\n\t\texpect(n8nVersion).toBeTruthy();\n\t\tconst lines = await getMetricsResponseAsLines();\n\t\texpect(lines).toContain(\n\t\t\t`n8n_test_version_info{version=\"v${n8nVersion!.version}\",major=\"${\n\t\t\t\tn8nVersion!.major\n\t\t\t}\",minor=\"${n8nVersion!.minor}\",patch=\"${n8nVersion!.patch}\"} 1`,\n\t\t);\n\t});","file":"integration/metrics.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return cache metrics when enabled","suites":["Metrics"],"updatePoint":{"line":38,"column":45},"line":38,"code":"\tit('should return cache metrics when enabled', async () => {\n\t\tconfig.set('endpoints.metrics.includeCacheMetrics', true);\n\t\tawait Container.get(MetricsService).configureMetrics(testServer.app);\n\t\tconst lines = await getMetricsResponseAsLines();\n\t\texpect(lines).toContain('n8n_test_cache_hits_total 0');\n\t\texpect(lines).toContain('n8n_test_cache_misses_total 0');\n\t\texpect(lines).toContain('n8n_test_cache_updates_total 0');\n\t});","file":"integration/metrics.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return default metrics","suites":["Metrics"],"updatePoint":{"line":63,"column":34},"line":63,"code":"\tit('should return default metrics', async () => {\n\t\tconfig.set('endpoints.metrics.includeDefaultMetrics', true);\n\t\tawait Container.get(MetricsService).configureMetrics(testServer.app);\n\t\tconst lines = await getMetricsResponseAsLines();\n\t\texpect(lines).toContain('nodejs_heap_space_size_total_bytes{space=\"read_only\"} 0');\n\t\tconfig.set('endpoints.metrics.includeDefaultMetrics', false);\n\t});","file":"integration/metrics.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not return default metrics only when disabled","suites":["Metrics"],"updatePoint":{"line":71,"column":57},"line":71,"code":"\tit('should not return default metrics only when disabled', async () => {\n\t\tconfig.set('endpoints.metrics.includeDefaultMetrics', false);\n\t\tawait Container.get(MetricsService).configureMetrics(testServer.app);\n\t\tconst lines = await getMetricsResponseAsLines();\n\t\texpect(lines).not.toContain('nodejs_heap_space_size_total_bytes{space=\"read_only\"} 0');\n\t\tconfig.set('endpoints.metrics.includeDefaultMetrics', true);\n\t});","file":"integration/metrics.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respond 200 if no nodes are installed","suites":["GET /nodes"],"updatePoint":{"line":66,"column":51},"line":66,"code":"\ttest('should respond 200 if no nodes are installed', async () => {\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { data },\n\t\t} = await authOwnerShellAgent.get('/nodes');\n\n\t\texpect(statusCode).toBe(200);\n\t\texpect(data).toHaveLength(0);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return list of one installed package and node","suites":["GET /nodes"],"updatePoint":{"line":76,"column":59},"line":76,"code":"\ttest('should return list of one installed package and node', async () => {\n\t\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { data },\n\t\t} = await authOwnerShellAgent.get('/nodes');\n\n\t\texpect(statusCode).toBe(200);\n\t\texpect(data).toHaveLength(1);\n\t\texpect(data[0].installedNodes).toHaveLength(1);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return list of multiple installed packages and nodes","suites":["GET /nodes"],"updatePoint":{"line":90,"column":66},"line":90,"code":"\ttest('should return list of multiple installed packages and nodes', async () => {\n\t\tconst first = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(first.packageName));\n\n\t\tconst second = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(second.packageName));\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(second.packageName));\n\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { data },\n\t\t} = await authOwnerShellAgent.get('/nodes');\n\n\t\texpect(statusCode).toBe(200);\n\t\texpect(data).toHaveLength(2);\n\n\t\tconst allNodes = data.reduce(\n\t\t\t(acc: InstalledNodes[], cur: InstalledPackages) => acc.concat(cur.installedNodes),\n\t\t\t[],\n\t\t);\n\n\t\texpect(allNodes).toHaveLength(3);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not check for updates if no packages installed","suites":["GET /nodes"],"updatePoint":{"line":114,"column":60},"line":114,"code":"\ttest('should not check for updates if no packages installed', async () => {\n\t\tawait authOwnerShellAgent.get('/nodes');\n\n\t\texpect(mocked(executeCommand)).toHaveBeenCalledTimes(0);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should check for updates if packages installed","suites":["GET /nodes"],"updatePoint":{"line":120,"column":53},"line":120,"code":"\ttest('should check for updates if packages installed', async () => {\n\t\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\t\tawait authOwnerShellAgent.get('/nodes');\n\n\t\texpect(mocked(executeCommand)).toHaveBeenCalledWith('npm outdated --json', {\n\t\t\tdoNotHandleError: true,\n\t\t});\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should report package updates if available","suites":["GET /nodes"],"updatePoint":{"line":131,"column":49},"line":131,"code":"\ttest('should report package updates if available', async () => {\n\t\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\t\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\t\tmocked(executeCommand).mockImplementationOnce(() => {\n\t\t\tthrow {\n\t\t\t\tcode: 1,\n\t\t\t\tstdout: JSON.stringify({\n\t\t\t\t\t[packageName]: {\n\t\t\t\t\t\tcurrent: COMMUNITY_PACKAGE_VERSION.CURRENT,\n\t\t\t\t\t\twanted: COMMUNITY_PACKAGE_VERSION.CURRENT,\n\t\t\t\t\t\tlatest: COMMUNITY_PACKAGE_VERSION.UPDATED,\n\t\t\t\t\t\tlocation: path.join('node_modules', packageName),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t};\n\t\t});\n\n\t\tmocked(isNpmError).mockReturnValueOnce(true);\n\n\t\tconst {\n\t\t\tbody: { data },\n\t\t} = await authOwnerShellAgent.get('/nodes');\n\n\t\texpect(data[0].installedVersion).toBe(COMMUNITY_PACKAGE_VERSION.CURRENT);\n\t\texpect(data[0].updateAvailable).toBe(COMMUNITY_PACKAGE_VERSION.UPDATED);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject if package name is missing","suites":["POST /nodes"],"updatePoint":{"line":161,"column":47},"line":161,"code":"\ttest('should reject if package name is missing', async () => {\n\t\tconst { statusCode } = await authOwnerShellAgent.post('/nodes');\n\n\t\texpect(statusCode).toBe(400);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject if package is duplicate","suites":["POST /nodes"],"updatePoint":{"line":167,"column":44},"line":167,"code":"\ttest('should reject if package is duplicate', async () => {\n\t\tmocked(findInstalledPackage).mockResolvedValueOnce(new InstalledPackages());\n\t\tmocked(isPackageInstalled).mockResolvedValueOnce(true);\n\t\tmocked(hasPackageLoaded).mockReturnValueOnce(true);\n\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { message },\n\t\t} = await authOwnerShellAgent.post('/nodes').send({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(400);\n\t\texpect(message).toContain('already installed');\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow installing packages that could not be loaded","suites":["POST /nodes"],"updatePoint":{"line":183,"column":64},"line":183,"code":"\ttest('should allow installing packages that could not be loaded', async () => {\n\t\tmocked(findInstalledPackage).mockResolvedValueOnce(new InstalledPackages());\n\t\tmocked(hasPackageLoaded).mockReturnValueOnce(false);\n\t\tmocked(checkNpmPackageStatus).mockResolvedValueOnce({ status: 'OK' });\n\n\t\tmockLoadNodesAndCredentials.installNpmModule.mockImplementationOnce(mockedEmptyPackage);\n\n\t\tconst { statusCode } = await authOwnerShellAgent.post('/nodes').send({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(200);\n\t\texpect(mocked(removePackageFromMissingList)).toHaveBeenCalled();\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not install a banned package","suites":["POST /nodes"],"updatePoint":{"line":198,"column":42},"line":198,"code":"\ttest('should not install a banned package', async () => {\n\t\tmocked(checkNpmPackageStatus).mockResolvedValueOnce({ status: 'Banned' });\n\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { message },\n\t\t} = await authOwnerShellAgent.post('/nodes').send({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(400);\n\t\texpect(message).toContain('banned');\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete if package name is empty","suites":["DELETE /nodes"],"updatePoint":{"line":214,"column":49},"line":214,"code":"\ttest('should not delete if package name is empty', async () => {\n\t\tconst response = await authOwnerShellAgent.delete('/nodes');\n\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject if package is not installed","suites":["DELETE /nodes"],"updatePoint":{"line":220,"column":48},"line":220,"code":"\ttest('should reject if package is not installed', async () => {\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { message },\n\t\t} = await authOwnerShellAgent.delete('/nodes').query({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(400);\n\t\texpect(message).toContain('not installed');\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should uninstall package","suites":["DELETE /nodes"],"updatePoint":{"line":232,"column":31},"line":232,"code":"\ttest('should uninstall package', async () => {\n\t\tconst removeSpy = mockLoadNodesAndCredentials.removeNpmModule.mockImplementationOnce(jest.fn());\n\n\t\tmocked(findInstalledPackage).mockImplementationOnce(mockedEmptyPackage);\n\n\t\tconst { statusCode } = await authOwnerShellAgent.delete('/nodes').query({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(200);\n\t\texpect(removeSpy).toHaveBeenCalledTimes(1);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject if package name is empty","suites":["PATCH /nodes"],"updatePoint":{"line":247,"column":45},"line":247,"code":"\ttest('should reject if package name is empty', async () => {\n\t\tconst response = await authOwnerShellAgent.patch('/nodes');\n\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"reject if package is not installed","suites":["PATCH /nodes"],"updatePoint":{"line":253,"column":41},"line":253,"code":"\ttest('reject if package is not installed', async () => {\n\t\tconst {\n\t\t\tstatusCode,\n\t\t\tbody: { message },\n\t\t} = await authOwnerShellAgent.patch('/nodes').send({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(statusCode).toBe(400);\n\t\texpect(message).toContain('not installed');\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update a package","suites":["PATCH /nodes"],"updatePoint":{"line":265,"column":30},"line":265,"code":"\ttest('should update a package', async () => {\n\t\tconst updateSpy =\n\t\t\tmockLoadNodesAndCredentials.updateNpmModule.mockImplementationOnce(mockedEmptyPackage);\n\n\t\tmocked(findInstalledPackage).mockImplementationOnce(mockedEmptyPackage);\n\n\t\tawait authOwnerShellAgent.patch('/nodes').send({\n\t\t\tname: utils.installedPackagePayload().packageName,\n\t\t});\n\n\t\texpect(updateSpy).toHaveBeenCalledTimes(1);\n\t});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create owner and enable isInstanceOwnerSetUp","suites":["POST /owner/setup"],"updatePoint":{"line":38,"column":58},"line":38,"code":"\ttest('should create owner and enable isInstanceOwnerSetUp', async () => {\n\t\tconst newOwnerData = {\n\t\t\temail: randomEmail(),\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await authOwnerShellAgent.post('/owner/setup').send(newOwnerData);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tisPending,\n\t\t\tapiKey,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(newOwnerData.email);\n\t\texpect(firstName).toBe(newOwnerData.firstName);\n\t\texpect(lastName).toBe(newOwnerData.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\n\t\tconst storedOwner = await Db.collections.User.findOneByOrFail({ id });\n\t\texpect(storedOwner.password).not.toBe(newOwnerData.password);\n\t\texpect(storedOwner.email).toBe(newOwnerData.email);\n\t\texpect(storedOwner.firstName).toBe(newOwnerData.firstName);\n\t\texpect(storedOwner.lastName).toBe(newOwnerData.lastName);\n\n\t\tconst isInstanceOwnerSetUpConfig = config.getEnv('userManagement.isInstanceOwnerSetUp');\n\t\texpect(isInstanceOwnerSetUpConfig).toBe(true);\n\n\t\tconst isInstanceOwnerSetUpSetting = await utils.isInstanceOwnerSetUp();\n\t\texpect(isInstanceOwnerSetUpSetting).toBe(true);\n\t});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create owner with lowercased email","suites":["POST /owner/setup"],"updatePoint":{"line":86,"column":48},"line":86,"code":"\ttest('should create owner with lowercased email', async () => {\n\t\tconst newOwnerData = {\n\t\t\temail: randomEmail().toUpperCase(),\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await authOwnerShellAgent.post('/owner/setup').send(newOwnerData);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, email } = response.body.data;\n\n\t\texpect(id).toBe(ownerShell.id);\n\t\texpect(email).toBe(newOwnerData.email.toLowerCase());\n\n\t\tconst storedOwner = await Db.collections.User.findOneByOrFail({ id });\n\t\texpect(storedOwner.email).toBe(newOwnerData.email.toLowerCase());\n\t});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /owner/setup"],"updatePoint":{"line":154,"column":38},"line":154,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tfor (const invalidPayload of INVALID_POST_OWNER_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.post('/owner/setup').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}\n\t});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send password reset email","suites":["POST /forgot-password"],"updatePoint":{"line":45,"column":39},"line":45,"code":"\ttest('should send password reset email', async () => {\n\t\tconst member = await testDb.createUser({\n\t\t\temail: 'test@test.com',\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t\tawait Promise.all(\n\t\t\t[{ email: owner.email }, { email: member.email.toUpperCase() }].map(async (payload) => {\n\t\t\t\tconst response = await testServer.authlessAgent.post('/forgot-password').send(payload);\n\n\t\t\t\texpect(response.statusCode).toBe(200);\n\t\t\t\texpect(response.body).toEqual({});\n\t\t\t}),\n\t\t);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if emailing is not set up","suites":["POST /forgot-password"],"updatePoint":{"line":63,"column":44},"line":63,"code":"\ttest('should fail if emailing is not set up', async () => {\n\t\tconfig.set('userManagement.emails.mode', '');\n\n\t\tawait testServer.authlessAgent\n\t\t\t.post('/forgot-password')\n\t\t\t.send({ email: owner.email })\n\t\t\t.expect(500);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if SAML is authentication method","suites":["POST /forgot-password"],"updatePoint":{"line":72,"column":51},"line":72,"code":"\ttest('should fail if SAML is authentication method', async () => {\n\t\tawait setCurrentAuthenticationMethod('saml');\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\t\tconst member = await testDb.createUser({\n\t\t\temail: 'test@test.com',\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tawait testServer.authlessAgent\n\t\t\t.post('/forgot-password')\n\t\t\t.send({ email: member.email })\n\t\t\t.expect(403);\n\n\t\tawait setCurrentAuthenticationMethod('email');\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should succeed if SAML is authentication method and requestor is owner","suites":["POST /forgot-password"],"updatePoint":{"line":88,"column":77},"line":88,"code":"\ttest('should succeed if SAML is authentication method and requestor is owner', async () => {\n\t\tawait setCurrentAuthenticationMethod('saml');\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.post('/forgot-password')\n\t\t\t.send({ email: owner.email });\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual({});\n\n\t\tawait setCurrentAuthenticationMethod('email');\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /forgot-password"],"updatePoint":{"line":102,"column":38},"line":102,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t\tconst invalidPayloads = [\n\t\t\trandomEmail(),\n\t\t\t[randomEmail()],\n\t\t\t{},\n\t\t\t[{ name: randomName() }],\n\t\t\t[{ email: randomName() }],\n\t\t];\n\n\t\tfor (const invalidPayload of invalidPayloads) {\n\t\t\tconst response = await testServer.authlessAgent.post('/forgot-password').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if user is not found","suites":["POST /forgot-password"],"updatePoint":{"line":119,"column":39},"line":119,"code":"\ttest('should fail if user is not found', async () => {\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.post('/forgot-password')\n\t\t\t.send({ email: randomEmail() });\n\n\t\texpect(response.statusCode).toBe(200); // expect 200 to remain vague\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should succeed with valid inputs","suites":["GET /resolve-password-token"],"updatePoint":{"line":135,"column":39},"line":135,"code":"\ttest('should succeed with valid inputs', async () => {\n\t\tconst resetPasswordToken = jwtService.signData({ sub: owner.id });\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.get('/resolve-password-token')\n\t\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["GET /resolve-password-token"],"updatePoint":{"line":145,"column":38},"line":145,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst first = await testServer.authlessAgent\n\t\t\t.get('/resolve-password-token')\n\t\t\t.query({ token: uuid() });\n\n\t\tconst second = await testServer.authlessAgent\n\t\t\t.get('/resolve-password-token')\n\t\t\t.query({ userId: owner.id });\n\n\t\tfor (const response of [first, second]) {\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if user is not found","suites":["GET /resolve-password-token"],"updatePoint":{"line":159,"column":39},"line":159,"code":"\ttest('should fail if user is not found', async () => {\n\t\tconst token = jwtService.signData({ sub: uuid() });\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.get('/resolve-password-token')\n\t\t\t.query({ userId: owner.id, token });\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if token is expired","suites":["GET /resolve-password-token"],"updatePoint":{"line":169,"column":38},"line":169,"code":"\ttest('should fail if token is expired', async () => {\n\t\tconst resetPasswordToken = jwtService.signData({ sub: owner.id }, { expiresIn: '-1h' });\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.get('/resolve-password-token')\n\t\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should succeed with valid inputs","suites":["POST /change-password"],"updatePoint":{"line":183,"column":39},"line":183,"code":"\ttest('should succeed with valid inputs', async () => {\n\t\tconst resetPasswordToken = jwtService.signData({ sub: owner.id });\n\t\tconst response = await testServer.authlessAgent.post('/change-password').send({\n\t\t\ttoken: resetPasswordToken,\n\t\t\tuserId: owner.id,\n\t\t\tpassword: passwordToStore,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeDefined();\n\n\t\tconst { password: storedPassword } = await Db.collections.User.findOneByOrFail({\n\t\t\tid: owner.id,\n\t\t});\n\n\t\tconst comparisonResult = await compare(passwordToStore, storedPassword);\n\t\texpect(comparisonResult).toBe(true);\n\t\texpect(storedPassword).not.toBe(passwordToStore);\n\n\t\texpect(externalHooks.run).toHaveBeenCalledWith('user.password.update', [\n\t\t\towner.email,\n\t\t\tstoredPassword,\n\t\t]);\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /change-password"],"updatePoint":{"line":210,"column":38},"line":210,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst resetPasswordToken = jwtService.signData({ sub: owner.id });\n\n\t\tconst invalidPayloads = [\n\t\t\t{ token: uuid() },\n\t\t\t{ id: owner.id },\n\t\t\t{ password: randomValidPassword() },\n\t\t\t{ token: uuid(), id: owner.id },\n\t\t\t{ token: uuid(), password: randomValidPassword() },\n\t\t\t{ id: owner.id, password: randomValidPassword() },\n\t\t\t{\n\t\t\t\tid: owner.id,\n\t\t\t\tpassword: randomInvalidPassword(),\n\t\t\t\ttoken: resetPasswordToken,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: owner.id,\n\t\t\t\tpassword: randomValidPassword(),\n\t\t\t\ttoken: uuid(),\n\t\t\t},\n\t\t];\n\n\t\tfor (const invalidPayload of invalidPayloads) {\n\t\t\tconst response = await testServer.authlessAgent\n\t\t\t\t.post('/change-password')\n\t\t\t\t.query(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst { password: storedPassword } = await Db.collections.User.findOneByOrFail({});\n\t\t\texpect(owner.password).toBe(storedPassword);\n\t\t}\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail when token has expired","suites":["POST /change-password"],"updatePoint":{"line":243,"column":41},"line":243,"code":"\ttest('should fail when token has expired', async () => {\n\t\tconst resetPasswordToken = jwtService.signData({ sub: owner.id }, { expiresIn: '-1h' });\n\n\t\tconst response = await testServer.authlessAgent.post('/change-password').send({\n\t\t\ttoken: resetPasswordToken,\n\t\t\tuserId: owner.id,\n\t\t\tpassword: passwordToStore,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(404);\n\n\t\texpect(externalHooks.run).not.toHaveBeenCalled();\n\t});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create credentials","suites":["POST /credentials"],"updatePoint":{"line":50,"column":32},"line":50,"code":"\ttest('should create credentials', async () => {\n\t\tconst payload = {\n\t\t\tname: 'test credential',\n\t\t\ttype: 'githubApi',\n\t\t\tdata: {\n\t\t\t\taccessToken: 'abcdefghijklmnopqrstuvwxyz',\n\t\t\t\tuser: 'test',\n\t\t\t\tserver: 'testServer',\n\t\t\t},\n\t\t};\n\n\t\tconst response = await authOwnerAgent.post('/credentials').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\tconst { id, name, type } = response.body;\n\n\t\texpect(name).toBe(payload.name);\n\t\texpect(type).toBe(payload.type);\n\n\t\tconst credential = await Db.collections.Credentials.findOneByOrFail({ id });\n\n\t\texpect(credential.name).toBe(payload.name);\n\t\texpect(credential.type).toBe(payload.type);\n\t\texpect(credential.data).not.toBe(payload.data);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['user', 'credentials', 'role'],\n\t\t\twhere: { credentialsId: credential.id, userId: owner.id },\n\t\t});\n\n\t\texpect(sharedCredential.role).toEqual(credentialOwnerRole);\n\t\texpect(sharedCredential.credentials.name).toBe(payload.name);\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /credentials"],"updatePoint":{"line":84,"column":38},"line":84,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tfor (const invalidPayload of INVALID_PAYLOADS) {\n\t\t\tconst response = await authOwnerAgent.post('/credentials').send(invalidPayload);\n\t\t\texpect(response.statusCode === 400 || response.statusCode === 415).toBe(true);\n\t\t}\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with missing encryption key","suites":["POST /credentials"],"updatePoint":{"line":91,"column":46},"line":91,"code":"\ttest('should fail with missing encryption key', async () => {\n\t\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\t\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\t\tconst response = await authOwnerAgent.post('/credentials').send(credentialPayload());\n\n\t\texpect(response.statusCode).toBe(500);\n\n\t\tmock.mockRestore();\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete owned cred for owner","suites":["DELETE /credentials/:id"],"updatePoint":{"line":104,"column":41},"line":104,"code":"\ttest('should delete owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(dbCredential(), { user: owner });\n\n\t\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { name, type } = response.body;\n\n\t\texpect(name).toBe(savedCredential.name);\n\t\texpect(type).toBe(savedCredential.type);\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete non-owned cred for owner","suites":["DELETE /credentials/:id"],"updatePoint":{"line":127,"column":45},"line":127,"code":"\ttest('should delete non-owned cred for owner', async () => {\n\t\tconst savedCredential = await saveCredential(dbCredential(), { user: member });\n\n\t\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete owned cred for member","suites":["DELETE /credentials/:id"],"updatePoint":{"line":145,"column":42},"line":145,"code":"\ttest('should delete owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(dbCredential(), { user: member });\n\n\t\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { name, type } = response.body;\n\n\t\texpect(name).toBe(savedCredential.name);\n\t\texpect(type).toBe(savedCredential.type);\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete owned cred for member but leave others untouched","suites":["DELETE /credentials/:id"],"updatePoint":{"line":168,"column":69},"line":168,"code":"\ttest('should delete owned cred for member but leave others untouched', async () => {\n\t\tconst anotherMember = await testDb.createUser({\n\t\t\tglobalRole: globalMemberRole,\n\t\t\tapiKey: randomApiKey(),\n\t\t});\n\n\t\tconst savedCredential = await saveCredential(dbCredential(), { user: member });\n\t\tconst notToBeChangedCredential = await saveCredential(dbCredential(), { user: member });\n\t\tconst notToBeChangedCredential2 = await saveCredential(dbCredential(), {\n\t\t\tuser: anotherMember,\n\t\t});\n\n\t\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { name, type } = response.body;\n\n\t\texpect(name).toBe(savedCredential.name);\n\t\texpect(type).toBe(savedCredential.type);\n\n\t\tconst deletedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(deletedCredential).toBeNull(); // deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne({\n\t\t\twhere: {\n\t\t\t\tcredentialsId: savedCredential.id,\n\t\t\t},\n\t\t});\n\n\t\texpect(deletedSharedCredential).toBeNull(); // deleted\n\n\t\tawait Promise.all(\n\t\t\t[notToBeChangedCredential, notToBeChangedCredential2].map(async (credential) => {\n\t\t\t\tconst untouchedCredential = await Db.collections.Credentials.findOneBy({\n\t\t\t\t\tid: credential.id,\n\t\t\t\t});\n\n\t\t\t\texpect(untouchedCredential).toEqual(credential); // not deleted\n\n\t\t\t\tconst untouchedSharedCredential = await Db.collections.SharedCredentials.findOne({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\tcredentialsId: credential.id,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\texpect(untouchedSharedCredential).toBeDefined(); // not deleted\n\t\t\t}),\n\t\t);\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete non-owned cred for member","suites":["DELETE /credentials/:id"],"updatePoint":{"line":222,"column":50},"line":222,"code":"\ttest('should not delete non-owned cred for member', async () => {\n\t\tconst savedCredential = await saveCredential(dbCredential(), { user: owner });\n\n\t\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\t\texpect(response.statusCode).toBe(404);\n\n\t\tconst shellCredential = await Db.collections.Credentials.findOneBy({\n\t\t\tid: savedCredential.id,\n\t\t});\n\n\t\texpect(shellCredential).toBeDefined(); // not deleted\n\n\t\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOneBy({});\n\n\t\texpect(deletedSharedCredential).toBeDefined(); // not deleted\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if cred not found","suites":["DELETE /credentials/:id"],"updatePoint":{"line":240,"column":36},"line":240,"code":"\ttest('should fail if cred not found', async () => {\n\t\tconst response = await authOwnerAgent.delete('/credentials/123');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to not found type","suites":["GET /credentials/schema/:credentialType"],"updatePoint":{"line":248,"column":40},"line":248,"code":"\ttest('should fail due to not found type', async () => {\n\t\tconst response = await authOwnerAgent.get('/credentials/schema/testing');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve credential type","suites":["GET /credentials/schema/:credentialType"],"updatePoint":{"line":254,"column":38},"line":254,"code":"\ttest('should retrieve credential type', async () => {\n\t\tconst response = await authOwnerAgent.get('/credentials/schema/githubApi');\n\n\t\tconst { additionalProperties, type, properties, required } = response.body;\n\n\t\texpect(additionalProperties).toBe(false);\n\t\texpect(type).toBe('object');\n\t\texpect(properties.server).toBeDefined();\n\t\texpect(properties.server.type).toBe('string');\n\t\texpect(properties.user.type).toBeDefined();\n\t\texpect(properties.user.type).toBe('string');\n\t\texpect(properties.accessToken.type).toBeDefined();\n\t\texpect(properties.accessToken.type).toBe('string');\n\t\texpect(required).toEqual(expect.arrayContaining(['server', 'user', 'accessToken']));\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["GET /executions/:id"],"updatePoint":{"line":60,"column":41},"line":60,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('get', '/executions/1', null));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["GET /executions/:id"],"updatePoint":{"line":62,"column":41},"line":62,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('get', '/executions/1', 'abcXYZ'));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"owner should be able to get an execution owned by him","suites":["GET /executions/:id"],"updatePoint":{"line":64,"column":60},"line":64,"code":"\ttest('owner should be able to get an execution owned by him', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.get(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = response.body;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(finished).toBe(true);\n\t\texpect(mode).toEqual(execution.mode);\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(execution.workflowId);\n\t\texpect(waitTill).toBeNull();\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"owner should be able to read executions of other users","suites":["GET /executions/:id"],"updatePoint":{"line":96,"column":61},"line":96,"code":"\ttest('owner should be able to read executions of other users', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, user1);\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.get(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"member should be able to fetch his own executions","suites":["GET /executions/:id"],"updatePoint":{"line":105,"column":56},"line":105,"code":"\ttest('member should be able to fetch his own executions', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, user1);\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tconst response = await authUser1Agent.get(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"member should not get an execution of another user without the workflow being shared","suites":["GET /executions/:id"],"updatePoint":{"line":114,"column":91},"line":114,"code":"\ttest('member should not get an execution of another user without the workflow being shared', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tconst response = await authUser1Agent.get(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"member should be able to fetch executions of workflows shared with him","suites":["GET /executions/:id"],"updatePoint":{"line":124,"column":77},"line":124,"code":"\ttest('member should be able to fetch executions of workflows shared with him', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, user1);\n\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [user2]);\n\n\t\tconst response = await authUser2Agent.get(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["DELETE /executions/:id"],"updatePoint":{"line":138,"column":41},"line":138,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('delete', '/executions/1', null));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["DELETE /executions/:id"],"updatePoint":{"line":140,"column":41},"line":140,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('delete', '/executions/1', 'abcXYZ'));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete an execution","suites":["DELETE /executions/:id"],"updatePoint":{"line":142,"column":33},"line":142,"code":"\ttest('should delete an execution', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\t\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.delete(`/executions/${execution.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = response.body;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(finished).toBe(true);\n\t\texpect(mode).toEqual(execution.mode);\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(execution.workflowId);\n\t\texpect(waitTill).toBeNull();\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["GET /executions"],"updatePoint":{"line":175,"column":41},"line":175,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('get', '/executions', null));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["GET /executions"],"updatePoint":{"line":177,"column":41},"line":177,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('get', '/executions', 'abcXYZ'));","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve all successful executions","suites":["GET /executions"],"updatePoint":{"line":179,"column":48},"line":179,"code":"\ttest('should retrieve all successful executions', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\t\tconst successfulExecution = await testDb.createSuccessfulExecution(workflow);\n\n\t\tawait testDb.createErrorExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.get('/executions').query({\n\t\t\tstatus: 'success',\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1);\n\t\texpect(response.body.nextCursor).toBe(null);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = response.body.data[0];\n\n\t\texpect(id).toBeDefined();\n\t\texpect(finished).toBe(true);\n\t\texpect(mode).toEqual(successfulExecution.mode);\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(successfulExecution.workflowId);\n\t\texpect(waitTill).toBeNull();\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should paginate two executions","suites":["GET /executions"],"line":219,"code":"\ttest.skip('should paginate two executions', async () => {","file":"integration/publicApi/executions.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"should retrieve all error executions","suites":["GET /executions"],"updatePoint":{"line":275,"column":43},"line":275,"code":"\ttest('should retrieve all error executions', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\t\tawait testDb.createSuccessfulExecution(workflow);\n\n\t\tconst errorExecution = await testDb.createErrorExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.get('/executions').query({\n\t\t\tstatus: 'error',\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1);\n\t\texpect(response.body.nextCursor).toBe(null);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = response.body.data[0];\n\n\t\texpect(id).toBeDefined();\n\t\texpect(finished).toBe(false);\n\t\texpect(mode).toEqual(errorExecution.mode);\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(errorExecution.workflowId);\n\t\texpect(waitTill).toBeNull();\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all waiting executions","suites":["GET /executions"],"updatePoint":{"line":313,"column":43},"line":313,"code":"\ttest('should return all waiting executions', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\t\tawait testDb.createSuccessfulExecution(workflow);\n\n\t\tawait testDb.createErrorExecution(workflow);\n\n\t\tconst waitingExecution = await testDb.createWaitingExecution(workflow);\n\n\t\tconst response = await authOwnerAgent.get('/executions').query({\n\t\t\tstatus: 'waiting',\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1);\n\t\texpect(response.body.nextCursor).toBe(null);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = response.body.data[0];\n\n\t\texpect(id).toBeDefined();\n\t\texpect(finished).toBe(false);\n\t\texpect(mode).toEqual(waitingExecution.mode);\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(waitingExecution.workflowId);\n\t\texpect(new Date(waitTill).getTime()).toBeGreaterThan(Date.now() - 1000);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve all executions of specific workflow","suites":["GET /executions"],"updatePoint":{"line":353,"column":58},"line":353,"code":"\ttest('should retrieve all executions of specific workflow', async () => {\n\t\tconst [workflow, workflow2] = await testDb.createManyWorkflows(2, {}, owner);\n\n\t\tconst savedExecutions = await testDb.createManyExecutions(\n\t\t\t2,\n\t\t\tworkflow,\n\t\t\ttestDb.createSuccessfulExecution,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, workflow2, testDb.createSuccessfulExecution);\n\n\t\tconst response = await authOwnerAgent.get('/executions').query({\n\t\t\tworkflowId: workflow.id,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\t\texpect(response.body.nextCursor).toBe(null);\n\n\t\tfor (const execution of response.body.data) {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\tfinished,\n\t\t\t\tmode,\n\t\t\t\tretryOf,\n\t\t\t\tretrySuccessId,\n\t\t\t\tstartedAt,\n\t\t\t\tstoppedAt,\n\t\t\t\tworkflowId,\n\t\t\t\twaitTill,\n\t\t\t} = execution;\n\n\t\t\texpect(savedExecutions.some((exec) => exec.id === id)).toBe(true);\n\t\t\texpect(finished).toBe(true);\n\t\t\texpect(mode).toBeDefined();\n\t\t\texpect(retrySuccessId).toBeNull();\n\t\t\texpect(retryOf).toBeNull();\n\t\t\texpect(startedAt).not.toBeNull();\n\t\t\texpect(stoppedAt).not.toBeNull();\n\t\t\texpect(workflowId).toBe(workflow.id);\n\t\t\texpect(waitTill).toBeNull();\n\t\t}\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"owner should retrieve all executions regardless of ownership","suites":["GET /executions"],"updatePoint":{"line":396,"column":67},"line":396,"code":"\ttest('owner should retrieve all executions regardless of ownership', async () => {\n\t\tconst [firstWorkflowForUser1, secondWorkflowForUser1] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser1,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser1, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser1, testDb.createSuccessfulExecution);\n\n\t\tconst [firstWorkflowForUser2, secondWorkflowForUser2] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser2,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser2, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser2, testDb.createSuccessfulExecution);\n\n\t\tconst response = await authOwnerAgent.get('/executions');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(8);\n\t\texpect(response.body.nextCursor).toBe(null);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"member should not see executions of workflows not shared with him","suites":["GET /executions"],"updatePoint":{"line":420,"column":72},"line":420,"code":"\ttest('member should not see executions of workflows not shared with him', async () => {\n\t\tconst [firstWorkflowForUser1, secondWorkflowForUser1] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser1,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser1, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser1, testDb.createSuccessfulExecution);\n\n\t\tconst [firstWorkflowForUser2, secondWorkflowForUser2] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser2,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser2, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser2, testDb.createSuccessfulExecution);\n\n\t\tconst response = await authUser1Agent.get('/executions');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(4);\n\t\texpect(response.body.nextCursor).toBe(null);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"member should also see executions of workflows shared with him","suites":["GET /executions"],"updatePoint":{"line":444,"column":69},"line":444,"code":"\ttest('member should also see executions of workflows shared with him', async () => {\n\t\tconst [firstWorkflowForUser1, secondWorkflowForUser1] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser1,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser1, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser1, testDb.createSuccessfulExecution);\n\n\t\tconst [firstWorkflowForUser2, secondWorkflowForUser2] = await testDb.createManyWorkflows(\n\t\t\t2,\n\t\t\t{},\n\t\t\tuser2,\n\t\t);\n\t\tawait testDb.createManyExecutions(2, firstWorkflowForUser2, testDb.createSuccessfulExecution);\n\t\tawait testDb.createManyExecutions(2, secondWorkflowForUser2, testDb.createSuccessfulExecution);\n\n\t\tawait testDb.shareWorkflowWithUsers(firstWorkflowForUser2, [user1]);\n\n\t\tconst response = await authUser1Agent.get('/executions');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(6);\n\t\texpect(response.body.nextCursor).toBe(null);\n\t});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["With license unlimited quota:users","GET /users"],"updatePoint":{"line":31,"column":42},"line":31,"code":"\t\ttest('should fail due to missing API Key', async () => {\n\t\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get('/users').expect(401);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["With license unlimited quota:users","GET /users"],"updatePoint":{"line":37,"column":42},"line":37,"code":"\t\ttest('should fail due to invalid API Key', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\t\t\towner.apiKey = 'invalid-key';\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get('/users').expect(401);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to member trying to access owner only endpoint","suites":["With license unlimited quota:users","GET /users"],"updatePoint":{"line":47,"column":70},"line":47,"code":"\t\ttest('should fail due to member trying to access owner only endpoint', async () => {\n\t\t\tconst member = await testDb.createUser({ apiKey: randomApiKey() });\n\t\t\tconst authMemberAgent = testServer.publicApiAgentFor(member);\n\t\t\tawait authMemberAgent.get('/users').expect(403);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all users","suites":["With license unlimited quota:users","GET /users"],"updatePoint":{"line":53,"column":31},"line":53,"code":"\t\ttest('should return all users', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\n\t\t\tawait testDb.createUser();\n\n\t\t\tconst response = await authOwnerAgent.get('/users').expect(200);\n\t\t\texpect(response.body.data.length).toBe(2);\n\t\t\texpect(response.body.nextCursor).toBeNull();\n\n\t\t\tfor (const user of response.body.data) {\n\t\t\t\tconst {\n\t\t\t\t\tid,\n\t\t\t\t\temail,\n\t\t\t\t\tfirstName,\n\t\t\t\t\tlastName,\n\t\t\t\t\tpersonalizationAnswers,\n\t\t\t\t\tglobalRole,\n\t\t\t\t\tpassword,\n\t\t\t\t\tisPending,\n\t\t\t\t\tcreatedAt,\n\t\t\t\t\tupdatedAt,\n\t\t\t\t} = user;\n\n\t\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\t\texpect(email).toBeDefined();\n\t\t\t\texpect(firstName).toBeDefined();\n\t\t\t\texpect(lastName).toBeDefined();\n\t\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\t\texpect(password).toBeUndefined();\n\t\t\t\texpect(isPending).toBe(false);\n\t\t\t\texpect(globalRole).toBeUndefined();\n\t\t\t\texpect(createdAt).toBeDefined();\n\t\t\t\texpect(updatedAt).toBeDefined();\n\t\t\t}\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["With license unlimited quota:users","GET /users/:id"],"updatePoint":{"line":96,"column":42},"line":96,"code":"\t\ttest('should fail due to missing API Key', async () => {\n\t\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get(`/users/${owner.id}`).expect(401);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["With license unlimited quota:users","GET /users/:id"],"updatePoint":{"line":102,"column":42},"line":102,"code":"\t\ttest('should fail due to invalid API Key', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\t\t\towner.apiKey = 'invalid-key';\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get(`/users/${owner.id}`).expect(401);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to member trying to access owner only endpoint","suites":["With license unlimited quota:users","GET /users/:id"],"updatePoint":{"line":112,"column":70},"line":112,"code":"\t\ttest('should fail due to member trying to access owner only endpoint', async () => {\n\t\t\tconst member = await testDb.createUser({ apiKey: randomApiKey() });\n\t\t\tconst authMemberAgent = testServer.publicApiAgentFor(member);\n\t\t\tawait authMemberAgent.get(`/users/${member.id}`).expect(403);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return 404 for non-existing id ","suites":["With license unlimited quota:users","GET /users/:id"],"updatePoint":{"line":117,"column":46},"line":117,"code":"\t\ttest('should return 404 for non-existing id ', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get(`/users/${uuid()}`).expect(404);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a pending user","suites":["With license unlimited quota:users","GET /users/:id"],"updatePoint":{"line":126,"column":36},"line":126,"code":"\t\ttest('should return a pending user', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\n\t\t\tconst { id: memberId } = await testDb.createUserShell(globalMemberRole);\n\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tconst response = await authOwnerAgent.get(`/users/${memberId}`).expect(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tcreatedAt,\n\t\t\t\tupdatedAt,\n\t\t\t} = response.body;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBeDefined();\n\t\t\texpect(firstName).toBeDefined();\n\t\t\texpect(lastName).toBeDefined();\n\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(globalRole).toBeUndefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(isPending).toBeDefined();\n\t\t\texpect(isPending).toBeTruthy();\n\t\t\texpect(updatedAt).toBeDefined();\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"with non-existing email should return 404","suites":["With license unlimited quota:users","GET /users/:email"],"updatePoint":{"line":165,"column":49},"line":165,"code":"\t\ttest('with non-existing email should return 404', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tawait authOwnerAgent.get('/users/jhondoe@gmail.com').expect(404);\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a user","suites":["With license unlimited quota:users","GET /users/:email"],"updatePoint":{"line":174,"column":28},"line":174,"code":"\t\ttest('should return a user', async () => {\n\t\t\tconst owner = await testDb.createUser({\n\t\t\t\tglobalRole: globalOwnerRole,\n\t\t\t\tapiKey: randomApiKey(),\n\t\t\t});\n\n\t\t\tconst authOwnerAgent = testServer.publicApiAgentFor(owner);\n\t\t\tconst response = await authOwnerAgent.get(`/users/${owner.email}`).expect(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tcreatedAt,\n\t\t\t\tupdatedAt,\n\t\t\t} = response.body;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBeDefined();\n\t\t\texpect(firstName).toBeDefined();\n\t\t\texpect(lastName).toBeDefined();\n\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole).toBeUndefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(updatedAt).toBeDefined();\n\t\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /users should fail due to invalid license","suites":["With license without quota:users"],"updatePoint":{"line":223,"column":52},"line":223,"code":"\ttest('GET /users should fail due to invalid license', async () => {\n\t\tawait authOwnerAgent.get('/users').expect(403);\n\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /users/:id should fail due to invalid license","suites":["With license without quota:users"],"updatePoint":{"line":227,"column":56},"line":227,"code":"\ttest('GET /users/:id should fail due to invalid license', async () => {\n\t\tawait authOwnerAgent.get(`/users/${uuid()}`).expect(403);\n\t});","file":"integration/publicApi/users.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["GET /workflows"],"updatePoint":{"line":62,"column":41},"line":62,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('get', '/workflows', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["GET /workflows"],"updatePoint":{"line":64,"column":41},"line":64,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('get', '/workflows', 'abcXYZ'));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all owned workflows","suites":["GET /workflows"],"updatePoint":{"line":66,"column":40},"line":66,"code":"\ttest('should return all owned workflows', async () => {\n\t\tawait Promise.all([\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t]);\n\n\t\tconst response = await authMemberAgent.get('/workflows');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(3);\n\t\texpect(response.body.nextCursor).toBeNull();\n\n\t\tfor (const workflow of response.body.data) {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\tconnections,\n\t\t\t\tactive,\n\t\t\t\tstaticData,\n\t\t\t\tnodes,\n\t\t\t\tsettings,\n\t\t\t\tname,\n\t\t\t\tcreatedAt,\n\t\t\t\tupdatedAt,\n\t\t\t\ttags,\n\t\t\t} = workflow;\n\n\t\t\texpect(id).toBeDefined();\n\t\t\texpect(name).toBeDefined();\n\t\t\texpect(connections).toBeDefined();\n\t\t\texpect(active).toBe(false);\n\t\t\texpect(staticData).toBeDefined();\n\t\t\texpect(nodes).toBeDefined();\n\t\t\texpect(tags).toBeDefined();\n\t\t\texpect(settings).toBeDefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(updatedAt).toBeDefined();\n\t\t}\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all owned workflows with pagination","suites":["GET /workflows"],"updatePoint":{"line":106,"column":56},"line":106,"code":"\ttest('should return all owned workflows with pagination', async () => {\n\t\tawait Promise.all([\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t]);\n\n\t\tconst response = await authMemberAgent.get('/workflows?limit=1');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1);\n\t\texpect(response.body.nextCursor).not.toBeNull();\n\n\t\tconst response2 = await authMemberAgent.get(\n\t\t\t`/workflows?limit=1&cursor=${response.body.nextCursor}`,\n\t\t);\n\n\t\texpect(response2.statusCode).toBe(200);\n\t\texpect(response2.body.data.length).toBe(1);\n\t\texpect(response2.body.nextCursor).not.toBeNull();\n\t\texpect(response2.body.nextCursor).not.toBe(response.body.nextCursor);\n\n\t\tconst responses = [...response.body.data, ...response2.body.data];\n\n\t\tfor (const workflow of responses) {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\tconnections,\n\t\t\t\tactive,\n\t\t\t\tstaticData,\n\t\t\t\tnodes,\n\t\t\t\tsettings,\n\t\t\t\tname,\n\t\t\t\tcreatedAt,\n\t\t\t\tupdatedAt,\n\t\t\t\ttags,\n\t\t\t} = workflow;\n\n\t\t\texpect(id).toBeDefined();\n\t\t\texpect(name).toBeDefined();\n\t\t\texpect(connections).toBeDefined();\n\t\t\texpect(active).toBe(false);\n\t\t\texpect(staticData).toBeDefined();\n\t\t\texpect(nodes).toBeDefined();\n\t\t\texpect(tags).toBeDefined();\n\t\t\texpect(settings).toBeDefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(updatedAt).toBeDefined();\n\t\t}\n\n\t\t// check that we really received a different result\n\t\texpect(response.body.data[0].id).not.toEqual(response2.body.data[0].id);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all owned workflows filtered by tag","suites":["GET /workflows"],"updatePoint":{"line":160,"column":56},"line":160,"code":"\ttest('should return all owned workflows filtered by tag', async () => {\n\t\tconst tag = await testDb.createTag({});\n\n\t\tconst [workflow] = await Promise.all([\n\t\t\ttestDb.createWorkflow({ tags: [tag] }, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t]);\n\n\t\tconst response = await authMemberAgent.get(`/workflows?tags=${tag.name}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(1);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tconnections,\n\t\t\tactive,\n\t\t\tstaticData,\n\t\t\tnodes,\n\t\t\tsettings,\n\t\t\tname,\n\t\t\tcreatedAt,\n\t\t\tupdatedAt,\n\t\t\ttags: wfTags,\n\t\t} = response.body.data[0];\n\n\t\texpect(id).toBe(workflow.id);\n\t\texpect(name).toBeDefined();\n\t\texpect(connections).toBeDefined();\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toBeDefined();\n\t\texpect(nodes).toBeDefined();\n\t\texpect(settings).toBeDefined();\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\n\t\texpect(wfTags.length).toBe(1);\n\t\texpect(wfTags[0].id).toBe(tag.id);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all owned workflows filtered by tags","suites":["GET /workflows"],"updatePoint":{"line":200,"column":57},"line":200,"code":"\ttest('should return all owned workflows filtered by tags', async () => {\n\t\tconst tags = await Promise.all([await testDb.createTag({}), await testDb.createTag({})]);\n\t\tconst tagNames = tags.map((tag) => tag.name).join(',');\n\n\t\tconst [workflow1, workflow2] = await Promise.all([\n\t\t\ttestDb.createWorkflow({ tags }, member),\n\t\t\ttestDb.createWorkflow({ tags }, member),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({ tags: [tags[0]] }, member),\n\t\t\ttestDb.createWorkflow({ tags: [tags[1]] }, member),\n\t\t]);\n\n\t\tconst response = await authMemberAgent.get(`/workflows?tags=${tagNames}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\n\t\tfor (const workflow of response.body.data) {\n\t\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\t\tworkflow;\n\n\t\t\texpect(id).toBeDefined();\n\t\t\texpect([workflow1.id, workflow2.id].includes(id)).toBe(true);\n\n\t\t\texpect(name).toBeDefined();\n\t\t\texpect(connections).toBeDefined();\n\t\t\texpect(active).toBe(false);\n\t\t\texpect(staticData).toBeDefined();\n\t\t\texpect(nodes).toBeDefined();\n\t\t\texpect(settings).toBeDefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(updatedAt).toBeDefined();\n\n\t\t\texpect(workflow.tags.length).toBe(2);\n\t\t\tworkflow.tags.forEach((tag: TagEntity) => {\n\t\t\t\texpect(tags.some((savedTag) => savedTag.id === tag.id)).toBe(true);\n\t\t\t});\n\t\t}\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all workflows for owner","suites":["GET /workflows"],"updatePoint":{"line":240,"column":44},"line":240,"code":"\ttest('should return all workflows for owner', async () => {\n\t\tawait Promise.all([\n\t\t\ttestDb.createWorkflow({}, owner),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, owner),\n\t\t\ttestDb.createWorkflow({}, member),\n\t\t\ttestDb.createWorkflow({}, owner),\n\t\t]);\n\n\t\tconst response = await authOwnerAgent.get('/workflows');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(5);\n\t\texpect(response.body.nextCursor).toBeNull();\n\n\t\tfor (const workflow of response.body.data) {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\tconnections,\n\t\t\t\tactive,\n\t\t\t\tstaticData,\n\t\t\t\tnodes,\n\t\t\t\tsettings,\n\t\t\t\tname,\n\t\t\t\tcreatedAt,\n\t\t\t\tupdatedAt,\n\t\t\t\ttags,\n\t\t\t} = workflow;\n\n\t\t\texpect(id).toBeDefined();\n\t\t\texpect(name).toBeDefined();\n\t\t\texpect(connections).toBeDefined();\n\t\t\texpect(active).toBe(false);\n\t\t\texpect(staticData).toBeDefined();\n\t\t\texpect(nodes).toBeDefined();\n\t\t\texpect(tags).toBeDefined();\n\t\t\texpect(settings).toBeDefined();\n\t\t\texpect(createdAt).toBeDefined();\n\t\t\texpect(updatedAt).toBeDefined();\n\t\t}\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["GET /workflows/:id"],"updatePoint":{"line":284,"column":41},"line":284,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('get', '/workflows/2', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["GET /workflows/:id"],"updatePoint":{"line":286,"column":41},"line":286,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('get', '/workflows/2', 'abcXYZ'));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to non-existing workflow","suites":["GET /workflows/:id"],"updatePoint":{"line":288,"column":47},"line":288,"code":"\ttest('should fail due to non-existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.get('/workflows/2');\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve workflow","suites":["GET /workflows/:id"],"updatePoint":{"line":293,"column":31},"line":293,"code":"\ttest('should retrieve workflow', async () => {\n\t\t// create and assign workflow to owner\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\n\t\tconst response = await authMemberAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\tconnections,\n\t\t\tactive,\n\t\t\tstaticData,\n\t\t\tnodes,\n\t\t\tsettings,\n\t\t\tname,\n\t\t\tcreatedAt,\n\t\t\tupdatedAt,\n\t\t\ttags,\n\t\t} = response.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(tags).toEqual([]);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve non-owned workflow for owner","suites":["GET /workflows/:id"],"updatePoint":{"line":326,"column":51},"line":326,"code":"\ttest('should retrieve non-owned workflow for owner', async () => {\n\t\t// create and assign workflow to owner\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["DELETE /workflows/:id"],"updatePoint":{"line":350,"column":41},"line":350,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('delete', '/workflows/2', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["DELETE /workflows/:id"],"updatePoint":{"line":352,"column":41},"line":352,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('delete', '/workflows/2', 'abcXYZ'));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to non-existing workflow","suites":["DELETE /workflows/:id"],"updatePoint":{"line":354,"column":47},"line":354,"code":"\ttest('should fail due to non-existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.delete('/workflows/2');\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete the workflow","suites":["DELETE /workflows/:id"],"updatePoint":{"line":359,"column":33},"line":359,"code":"\ttest('should delete the workflow', async () => {\n\t\t// create and assign workflow to owner\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\n\t\tconst response = await authMemberAgent.delete(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t\t// make sure the workflow actually deleted from the db\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOneBy({\n\t\t\tworkflowId: workflow.id,\n\t\t});\n\n\t\texpect(sharedWorkflow).toBeNull();\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete non-owned workflow when owner","suites":["DELETE /workflows/:id"],"updatePoint":{"line":388,"column":50},"line":388,"code":"\ttest('should delete non-owned workflow when owner', async () => {\n\t\t// create and assign workflow to owner\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\n\t\tconst response = await authMemberAgent.delete(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t\t// make sure the workflow actually deleted from the db\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOneBy({\n\t\t\tworkflowId: workflow.id,\n\t\t});\n\n\t\texpect(sharedWorkflow).toBeNull();\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":419,"column":41},"line":419,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('post', '/workflows/2/activate', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":422,"column":37},"line":421,"code":"\ttest(\n\t\t'should fail due to invalid API Key',\n\t\ttestWithAPIKey('post', '/workflows/2/activate', 'abcXYZ'),\n\t);","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to non-existing workflow","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":426,"column":47},"line":426,"code":"\ttest('should fail due to non-existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.post('/workflows/2/activate');\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to trying to activate a workflow without a trigger","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":431,"column":73},"line":431,"code":"\ttest('should fail due to trying to activate a workflow without a trigger', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, owner);\n\t\tconst response = await authOwnerAgent.post(`/workflows/${workflow.id}/activate`);\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set workflow as active","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":437,"column":36},"line":437,"code":"\ttest('should set workflow as active', async () => {\n\t\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\t\tconst response = await authMemberAgent.post(`/workflows/${workflow.id}/activate`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(true);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t\t// check whether the workflow is on the database\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t\trelations: ['workflow'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.active).toBe(true);\n\n\t\t// check whether the workflow is on the active workflow runner\n\t\texpect(await workflowRunner.isActive(workflow.id)).toBe(true);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set non-owned workflow as active when owner","suites":["POST /workflows/:id/activate"],"updatePoint":{"line":472,"column":57},"line":472,"code":"\ttest('should set non-owned workflow as active when owner', async () => {\n\t\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\t\tconst response = await authMemberAgent.post(`/workflows/${workflow.id}/activate`);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(true);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t\t// check whether the workflow is on the database\n\t\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: owner.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t});\n\n\t\texpect(sharedOwnerWorkflow).toBeNull();\n\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t\trelations: ['workflow'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.active).toBe(true);\n\n\t\t// check whether the workflow is on the active workflow runner\n\t\texpect(await workflowRunner.isActive(workflow.id)).toBe(true);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["POST /workflows/:id/deactivate"],"updatePoint":{"line":519,"column":37},"line":518,"code":"\ttest(\n\t\t'should fail due to missing API Key',\n\t\ttestWithAPIKey('post', '/workflows/2/deactivate', null),\n\t);","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["POST /workflows/:id/deactivate"],"updatePoint":{"line":524,"column":37},"line":523,"code":"\ttest(\n\t\t'should fail due to invalid API Key',\n\t\ttestWithAPIKey('post', '/workflows/2/deactivate', 'abcXYZ'),\n\t);","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to non-existing workflow","suites":["POST /workflows/:id/deactivate"],"updatePoint":{"line":528,"column":47},"line":528,"code":"\ttest('should fail due to non-existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.post('/workflows/2/deactivate');\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deactivate workflow","suites":["POST /workflows/:id/deactivate"],"updatePoint":{"line":533,"column":33},"line":533,"code":"\ttest('should deactivate workflow', async () => {\n\t\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\t\tawait authMemberAgent.post(`/workflows/${workflow.id}/activate`);\n\n\t\tconst workflowDeactivationResponse = await authMemberAgent.post(\n\t\t\t`/workflows/${workflow.id}/deactivate`,\n\t\t);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tworkflowDeactivationResponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\n\t\t// get the workflow after it was deactivated\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t\trelations: ['workflow'],\n\t\t});\n\n\t\t// check whether the workflow is deactivated in the database\n\t\texpect(sharedWorkflow?.workflow.active).toBe(false);\n\n\t\texpect(await workflowRunner.isActive(workflow.id)).toBe(false);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deactivate non-owned workflow when owner","suites":["POST /workflows/:id/deactivate"],"updatePoint":{"line":570,"column":54},"line":570,"code":"\ttest('should deactivate non-owned workflow when owner', async () => {\n\t\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\t\tawait authMemberAgent.post(`/workflows/${workflow.id}/activate`);\n\n\t\tconst workflowDeactivationResponse = await authMemberAgent.post(\n\t\t\t`/workflows/${workflow.id}/deactivate`,\n\t\t);\n\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tworkflowDeactivationResponse.body;\n\n\t\texpect(id).toEqual(workflow.id);\n\t\texpect(name).toEqual(workflow.name);\n\t\texpect(connections).toEqual(workflow.connections);\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toEqual(workflow.staticData);\n\t\texpect(nodes).toEqual(workflow.nodes);\n\t\texpect(settings).toEqual(workflow.settings);\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\n\t\t// check whether the workflow is deactivated in the database\n\t\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: owner.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t});\n\n\t\texpect(sharedOwnerWorkflow).toBeNull();\n\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: workflow.id,\n\t\t\t},\n\t\t\trelations: ['workflow'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.active).toBe(false);\n\n\t\texpect(await workflowRunner.isActive(workflow.id)).toBe(false);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["POST /workflows"],"updatePoint":{"line":617,"column":41},"line":617,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('post', '/workflows', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["POST /workflows"],"updatePoint":{"line":619,"column":41},"line":619,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('post', '/workflows', 'abcXYZ'));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid body","suites":["POST /workflows"],"updatePoint":{"line":621,"column":38},"line":621,"code":"\ttest('should fail due to invalid body', async () => {\n\t\tconst response = await authOwnerAgent.post('/workflows').send({});\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create workflow","suites":["POST /workflows"],"updatePoint":{"line":626,"column":29},"line":626,"code":"\ttest('should create workflow', async () => {\n\t\tconst payload = {\n\t\t\tname: 'testing',\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tstaticData: null,\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: true,\n\t\t\t\tsaveManualExecutions: true,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t};\n\n\t\tconst response = await authMemberAgent.post('/workflows').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(name).toBe(payload.name);\n\t\texpect(connections).toEqual(payload.connections);\n\t\texpect(settings).toEqual(payload.settings);\n\t\texpect(staticData).toEqual(payload.staticData);\n\t\texpect(nodes).toEqual(payload.nodes);\n\t\texpect(active).toBe(false);\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toEqual(createdAt);\n\n\t\t// check if created workflow in DB\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: response.body.id,\n\t\t\t},\n\t\t\trelations: ['workflow', 'role'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.name).toBe(name);\n\t\texpect(sharedWorkflow?.workflow.createdAt.toISOString()).toBe(createdAt);\n\t\texpect(sharedWorkflow?.role).toEqual(workflowOwnerRole);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not add a starting node if the payload has no starting nodes","suites":["POST /workflows"],"updatePoint":{"line":682,"column":74},"line":682,"code":"\ttest('should not add a starting node if the payload has no starting nodes', async () => {\n\t\tconst response = await authMemberAgent.post('/workflows').send({\n\t\t\tname: 'testing',\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Hacker News',\n\t\t\t\t\ttype: 'n8n-nodes-base.hackerNews',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: true,\n\t\t\t\tsaveManualExecutions: true,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t});\n\n\t\tconst found = response.body.nodes.find((node: INode) => STARTING_NODES.includes(node.type));\n\n\t\texpect(found).toBeUndefined();\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to missing API Key","suites":["PUT /workflows/:id"],"updatePoint":{"line":713,"column":41},"line":713,"code":"\ttest('should fail due to missing API Key', testWithAPIKey('put', '/workflows/1', null));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid API Key","suites":["PUT /workflows/:id"],"updatePoint":{"line":715,"column":41},"line":715,"code":"\ttest('should fail due to invalid API Key', testWithAPIKey('put', '/workflows/1', 'abcXYZ'));","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to non-existing workflow","suites":["PUT /workflows/:id"],"updatePoint":{"line":717,"column":47},"line":717,"code":"\ttest('should fail due to non-existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.put('/workflows/1').send({\n\t\t\tname: 'testing',\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tstaticData: null,\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: true,\n\t\t\t\tsaveManualExecutions: true,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t});\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail due to invalid body","suites":["PUT /workflows/:id"],"updatePoint":{"line":745,"column":38},"line":745,"code":"\ttest('should fail due to invalid body', async () => {\n\t\tconst response = await authOwnerAgent.put('/workflows/1').send({\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tstaticData: null,\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: true,\n\t\t\t\tsaveManualExecutions: true,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t});\n\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update workflow","suites":["PUT /workflows/:id"],"updatePoint":{"line":772,"column":29},"line":772,"code":"\ttest('should update workflow', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\t\tconst payload = {\n\t\t\tname: 'name updated',\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Cron',\n\t\t\t\t\ttype: 'n8n-nodes-base.cron',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [400, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tstaticData: '{\"id\":1}',\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: false,\n\t\t\t\tsaveManualExecutions: false,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t};\n\n\t\tconst response = await authMemberAgent.put(`/workflows/${workflow.id}`).send(payload);\n\n\t\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\texpect(id).toBe(workflow.id);\n\t\texpect(name).toBe(payload.name);\n\t\texpect(connections).toEqual(payload.connections);\n\t\texpect(settings).toEqual(payload.settings);\n\t\texpect(staticData).toMatchObject(JSON.parse(payload.staticData));\n\t\texpect(nodes).toEqual(payload.nodes);\n\t\texpect(active).toBe(false);\n\t\texpect(createdAt).toBe(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).not.toBe(workflow.updatedAt.toISOString());\n\n\t\t// check updated workflow in DB\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: response.body.id,\n\t\t\t},\n\t\t\trelations: ['workflow'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.name).toBe(payload.name);\n\t\texpect(sharedWorkflow?.workflow.updatedAt.getTime()).toBeGreaterThan(\n\t\t\tworkflow.updatedAt.getTime(),\n\t\t);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update non-owned workflow if owner","suites":["PUT /workflows/:id"],"updatePoint":{"line":838,"column":48},"line":838,"code":"\ttest('should update non-owned workflow if owner', async () => {\n\t\tconst workflow = await testDb.createWorkflow({}, member);\n\n\t\tconst payload = {\n\t\t\tname: 'name owner updated',\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [240, 300],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-2',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tname: 'Cron',\n\t\t\t\t\ttype: 'n8n-nodes-base.cron',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [400, 300],\n\t\t\t\t},\n\t\t\t],\n\t\t\tconnections: {},\n\t\t\tstaticData: '{\"id\":1}',\n\t\t\tsettings: {\n\t\t\t\tsaveExecutionProgress: false,\n\t\t\t\tsaveManualExecutions: false,\n\t\t\t\tsaveDataErrorExecution: 'all',\n\t\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\t\texecutionTimeout: 3600,\n\t\t\t\ttimezone: 'America/New_York',\n\t\t\t},\n\t\t};\n\n\t\tconst response = await authMemberAgent.put(`/workflows/${workflow.id}`).send(payload);\n\n\t\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\t\tresponse.body;\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\texpect(id).toBe(workflow.id);\n\t\texpect(name).toBe(payload.name);\n\t\texpect(connections).toEqual(payload.connections);\n\t\texpect(settings).toEqual(payload.settings);\n\t\texpect(staticData).toMatchObject(JSON.parse(payload.staticData));\n\t\texpect(nodes).toEqual(payload.nodes);\n\t\texpect(active).toBe(false);\n\t\texpect(createdAt).toBe(workflow.createdAt.toISOString());\n\t\texpect(updatedAt).not.toBe(workflow.updatedAt.toISOString());\n\n\t\t// check updated workflow in DB\n\t\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: owner.id,\n\t\t\t\tworkflowId: response.body.id,\n\t\t\t},\n\t\t});\n\n\t\texpect(sharedOwnerWorkflow).toBeNull();\n\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\twhere: {\n\t\t\t\tuserId: member.id,\n\t\t\t\tworkflowId: response.body.id,\n\t\t\t},\n\t\t\trelations: ['workflow', 'role'],\n\t\t});\n\n\t\texpect(sharedWorkflow?.workflow.name).toBe(payload.name);\n\t\texpect(sharedWorkflow?.workflow.updatedAt.getTime()).toBeGreaterThan(\n\t\t\tworkflow.updatedAt.getTime(),\n\t\t);\n\t\texpect(sharedWorkflow?.role).toEqual(workflowOwnerRole);\n\t});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should succeed with valid inputs","suites":["Instance owner","PATCH /me"],"updatePoint":{"line":40,"column":40},"line":40,"code":"\t\ttest('should succeed with valid inputs', async () => {\n\t\t\tawait enableSaml(false);\n\t\t\tawait authOwnerAgent\n\t\t\t\t.patch('/me')\n\t\t\t\t.send({\n\t\t\t\t\temail: randomEmail(),\n\t\t\t\t\tfirstName: randomName(),\n\t\t\t\t\tlastName: randomName(),\n\t\t\t\t\tpassword: randomValidPassword(),\n\t\t\t\t})\n\t\t\t\t.expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw BadRequestError if email is changed when SAML is enabled","suites":["Instance owner","PATCH /me"],"updatePoint":{"line":53,"column":77},"line":53,"code":"\t\ttest('should throw BadRequestError if email is changed when SAML is enabled', async () => {\n\t\t\tawait enableSaml(true);\n\t\t\tawait authOwnerAgent\n\t\t\t\t.patch('/me')\n\t\t\t\t.send({\n\t\t\t\t\temail: randomEmail(),\n\t\t\t\t\tfirstName: randomName(),\n\t\t\t\t\tlastName: randomName(),\n\t\t\t\t})\n\t\t\t\t.expect(400, { code: 400, message: 'SAML user may not change their email' });\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw BadRequestError if password is changed when SAML is enabled","suites":["Instance owner","PATCH /password"],"updatePoint":{"line":67,"column":80},"line":67,"code":"\t\ttest('should throw BadRequestError if password is changed when SAML is enabled', async () => {\n\t\t\tawait enableSaml(true);\n\t\t\tawait authOwnerAgent\n\t\t\t\t.patch('/me/password')\n\t\t\t\t.send({\n\t\t\t\t\tpassword: randomValidPassword(),\n\t\t\t\t})\n\t\t\t\t.expect(400, {\n\t\t\t\t\tcode: 400,\n\t\t\t\t\tmessage: 'With SAML enabled, users need to use their SAML provider to change passwords',\n\t\t\t\t});\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should post saml config","suites":["Instance owner","POST /sso/saml/config"],"updatePoint":{"line":82,"column":31},"line":82,"code":"\t\ttest('should post saml config', async () => {\n\t\t\tawait authOwnerAgent\n\t\t\t\t.post('/sso/saml/config')\n\t\t\t\t.send({\n\t\t\t\t\t...sampleConfig,\n\t\t\t\t\tloginEnabled: true,\n\t\t\t\t})\n\t\t\t\t.expect(200);\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('saml');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should toggle saml as default authentication method","suites":["Instance owner","POST /sso/saml/config/toggle"],"updatePoint":{"line":95,"column":59},"line":95,"code":"\t\ttest('should toggle saml as default authentication method', async () => {\n\t\t\tawait enableSaml(true);\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('saml');\n\n\t\t\tawait authOwnerAgent\n\t\t\t\t.post('/sso/saml/config/toggle')\n\t\t\t\t.send({\n\t\t\t\t\tloginEnabled: false,\n\t\t\t\t})\n\t\t\t\t.expect(200);\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('email');\n\n\t\t\tawait authOwnerAgent\n\t\t\t\t.post('/sso/saml/config/toggle')\n\t\t\t\t.send({\n\t\t\t\t\tloginEnabled: true,\n\t\t\t\t})\n\t\t\t\t.expect(200);\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('saml');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail enable saml if default authentication is not email","suites":["Instance owner","POST /sso/saml/config/toggle"],"updatePoint":{"line":118,"column":70},"line":118,"code":"\t\ttest('should fail enable saml if default authentication is not email', async () => {\n\t\t\tawait enableSaml(true);\n\n\t\t\tawait authOwnerAgent\n\t\t\t\t.post('/sso/saml/config/toggle')\n\t\t\t\t.send({\n\t\t\t\t\tloginEnabled: false,\n\t\t\t\t})\n\t\t\t\t.expect(200);\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('email');\n\n\t\t\tawait setCurrentAuthenticationMethod('ldap');\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('ldap');\n\n\t\t\tawait authOwnerAgent\n\t\t\t\t.post('/sso/saml/config/toggle')\n\t\t\t\t.send({\n\t\t\t\t\tloginEnabled: true,\n\t\t\t\t})\n\t\t\t\t.expect(500);\n\n\t\t\texpect(getCurrentAuthenticationMethod()).toBe('ldap');\n\t\t\tawait setCurrentAuthenticationMethod('saml');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":150,"column":53},"line":150,"code":"\t\ttest(`should be able to access ${SamlUrls.metadata}`, async () => {\n\t\t\tawait authOwnerAgent.get(`/sso/saml${SamlUrls.metadata}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":154,"column":55},"line":154,"code":"\t\ttest(`should be able to access GET ${SamlUrls.config}`, async () => {\n\t\t\tawait authOwnerAgent.get(`/sso/saml${SamlUrls.config}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access POST ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":158,"column":56},"line":158,"code":"\t\ttest(`should be able to access POST ${SamlUrls.config}`, async () => {\n\t\t\tawait authOwnerAgent.post(`/sso/saml${SamlUrls.config}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access POST ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":162,"column":69},"line":162,"code":"\t\ttest(`should be able to access POST ${SamlUrls.configToggleEnabled}`, async () => {\n\t\t\tawait authOwnerAgent.post(`/sso/saml${SamlUrls.configToggleEnabled}`).expect(400);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":166,"column":52},"line":166,"code":"\t\ttest(`should be able to access GET ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await authOwnerAgent.get(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access POST ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":173,"column":53},"line":173,"code":"\t\ttest(`should be able to access POST ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await authOwnerAgent.post(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":180,"column":56},"line":180,"code":"\t\ttest(`should be able to access GET ${SamlUrls.initSSO}`, async () => {\n\t\t\tawait authOwnerAgent.get(`/sso/saml${SamlUrls.initSSO}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Owner"],"updatePoint":{"line":184,"column":59},"line":184,"code":"\t\ttest(`should be able to access GET ${SamlUrls.configTest}`, async () => {\n\t\t\tawait authOwnerAgent.get(`/sso/saml${SamlUrls.configTest}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":189,"column":53},"line":189,"code":"\t\ttest(`should be able to access ${SamlUrls.metadata}`, async () => {\n\t\t\tawait authMemberAgent.get(`/sso/saml${SamlUrls.metadata}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":193,"column":55},"line":193,"code":"\t\ttest(`should be able to access GET ${SamlUrls.config}`, async () => {\n\t\t\tawait authMemberAgent.get(`/sso/saml${SamlUrls.config}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access POST ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":197,"column":60},"line":197,"code":"\t\ttest(`should NOT be able to access POST ${SamlUrls.config}`, async () => {\n\t\t\tawait authMemberAgent.post(`/sso/saml${SamlUrls.config}`).expect(403);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access POST ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":201,"column":73},"line":201,"code":"\t\ttest(`should NOT be able to access POST ${SamlUrls.configToggleEnabled}`, async () => {\n\t\t\tawait authMemberAgent.post(`/sso/saml${SamlUrls.configToggleEnabled}`).expect(403);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":205,"column":52},"line":205,"code":"\t\ttest(`should be able to access GET ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await authMemberAgent.get(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access POST ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":212,"column":53},"line":212,"code":"\t\ttest(`should be able to access POST ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await authMemberAgent.post(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":219,"column":56},"line":219,"code":"\t\ttest(`should be able to access GET ${SamlUrls.initSSO}`, async () => {\n\t\t\tawait authMemberAgent.get(`/sso/saml${SamlUrls.initSSO}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access GET ","suites":["Check endpoint permissions","Authenticated Member"],"updatePoint":{"line":223,"column":63},"line":223,"code":"\t\ttest(`should NOT be able to access GET ${SamlUrls.configTest}`, async () => {\n\t\t\tawait authMemberAgent.get(`/sso/saml${SamlUrls.configTest}`).expect(403);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":228,"column":53},"line":228,"code":"\t\ttest(`should be able to access ${SamlUrls.metadata}`, async () => {\n\t\t\tawait testServer.authlessAgent.get(`/sso/saml${SamlUrls.metadata}`).expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access GET ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":232,"column":59},"line":232,"code":"\t\ttest(`should NOT be able to access GET ${SamlUrls.config}`, async () => {\n\t\t\tawait testServer.authlessAgent.get(`/sso/saml${SamlUrls.config}`).expect(401);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access POST ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":236,"column":60},"line":236,"code":"\t\ttest(`should NOT be able to access POST ${SamlUrls.config}`, async () => {\n\t\t\tawait testServer.authlessAgent.post(`/sso/saml${SamlUrls.config}`).expect(401);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access POST ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":240,"column":73},"line":240,"code":"\t\ttest(`should NOT be able to access POST ${SamlUrls.configToggleEnabled}`, async () => {\n\t\t\tawait testServer.authlessAgent.post(`/sso/saml${SamlUrls.configToggleEnabled}`).expect(401);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":244,"column":52},"line":244,"code":"\t\ttest(`should be able to access GET ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await testServer.authlessAgent.get(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access POST ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":251,"column":53},"line":251,"code":"\t\ttest(`should be able to access POST ${SamlUrls.acs}`, async () => {\n\t\t\t// Note that 401 here is coming from the missing SAML object,\n\t\t\t// not from not being able to access the endpoint, so this is expected!\n\t\t\tconst response = await testServer.authlessAgent.post(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\t\texpect(response.text).toContain('SAML Authentication failed');\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to access GET ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":258,"column":56},"line":258,"code":"\t\ttest(`should be able to access GET ${SamlUrls.initSSO}`, async () => {\n\t\t\tconst response = await testServer.authlessAgent\n\t\t\t\t.get(`/sso/saml${SamlUrls.initSSO}`)\n\t\t\t\t.expect(200);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT be able to access GET ","suites":["Check endpoint permissions","Non-Authenticated User"],"updatePoint":{"line":264,"column":63},"line":264,"code":"\t\ttest(`should NOT be able to access GET ${SamlUrls.configTest}`, async () => {\n\t\t\tawait testServer.authlessAgent.get(`/sso/saml${SamlUrls.configTest}`).expect(401);\n\t\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should trigger onUserLoginSuccess hook","suites":["SAML login flow"],"updatePoint":{"line":275,"column":45},"line":275,"code":"\ttest('should trigger onUserLoginSuccess hook', async () => {\n\t\tconst mockedHandleSamlLogin = jest.spyOn(Container.get(SamlService), 'handleSamlLogin');\n\n\t\tmockedHandleSamlLogin.mockImplementation(\n\t\t\tasync (): Promise<{\n\t\t\t\tauthenticatedUser: User;\n\t\t\t\tattributes: SamlUserAttributes;\n\t\t\t\tonboardingRequired: false;\n\t\t\t}> => {\n\t\t\t\treturn {\n\t\t\t\t\tauthenticatedUser: someUser,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\temail: someUser.email,\n\t\t\t\t\t\tfirstName: someUser.firstName,\n\t\t\t\t\t\tlastName: someUser.lastName,\n\t\t\t\t\t\tuserPrincipalName: someUser.email,\n\t\t\t\t\t},\n\t\t\t\t\tonboardingRequired: false,\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\n\t\tconst mockedHookOnUserLoginSuccess = jest.spyOn(\n\t\t\tContainer.get(InternalHooks),\n\t\t\t'onUserLoginSuccess',\n\t\t);\n\t\tmockedHookOnUserLoginSuccess.mockImplementation(\n\t\t\tasync (userLoginData: { user: User; authenticationMethod: AuthenticationMethod }) => {\n\t\t\t\texpect(userLoginData.authenticationMethod).toEqual('saml');\n\t\t\t\treturn;\n\t\t\t},\n\t\t);\n\t\tconst response = await authOwnerAgent.post(`/sso/saml${SamlUrls.acs}`).expect(302);\n\t\texpect(mockedHookOnUserLoginSuccess).toBeCalled();\n\t\tmockedHookOnUserLoginSuccess.mockRestore();\n\t\tmockedHandleSamlLogin.mockRestore();\n\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should trigger onUserLoginFailed hook","suites":["SAML login flow"],"updatePoint":{"line":313,"column":44},"line":313,"code":"\ttest('should trigger onUserLoginFailed hook', async () => {\n\t\tconst mockedHandleSamlLogin = jest.spyOn(Container.get(SamlService), 'handleSamlLogin');\n\n\t\tmockedHandleSamlLogin.mockImplementation(\n\t\t\tasync (): Promise<{\n\t\t\t\tauthenticatedUser: User | undefined;\n\t\t\t\tattributes: SamlUserAttributes;\n\t\t\t\tonboardingRequired: false;\n\t\t\t}> => {\n\t\t\t\treturn {\n\t\t\t\t\tauthenticatedUser: undefined,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\temail: someUser.email,\n\t\t\t\t\t\tfirstName: someUser.firstName,\n\t\t\t\t\t\tlastName: someUser.lastName,\n\t\t\t\t\t\tuserPrincipalName: someUser.email,\n\t\t\t\t\t},\n\t\t\t\t\tonboardingRequired: false,\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\n\t\tconst mockedHookOnUserLoginFailed = jest.spyOn(\n\t\t\tContainer.get(InternalHooks),\n\t\t\t'onUserLoginFailed',\n\t\t);\n\t\tmockedHookOnUserLoginFailed.mockImplementation(\n\t\t\tasync (userLoginData: {\n\t\t\t\tuser: string;\n\t\t\t\tauthenticationMethod: AuthenticationMethod;\n\t\t\t\treason?: string;\n\t\t\t}) => {\n\t\t\t\texpect(userLoginData.authenticationMethod).toEqual('saml');\n\t\t\t\treturn;\n\t\t\t},\n\t\t);\n\t\tconst response = await authOwnerAgent.post(`/sso/saml${SamlUrls.acs}`).expect(401);\n\t\texpect(mockedHookOnUserLoginFailed).toBeCalled();\n\t\tmockedHookOnUserLoginFailed.mockRestore();\n\t\tmockedHandleSamlLogin.mockRestore();\n\t});","file":"integration/saml/saml.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create tag","suites":["POST /tags"],"updatePoint":{"line":21,"column":24},"line":21,"code":"\ttest('should create tag', async () => {\n\t\tconst resp = await authOwnerAgent.post('/tags').send({ name: 'test' });\n\t\texpect(resp.statusCode).toBe(200);\n\n\t\tconst dbTag = await Container.get(TagRepository).findBy({ name: 'test' });\n\t\texpect(dbTag.length === 1);\n\t});","file":"integration/tags.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not create duplicate tag","suites":["POST /tags"],"updatePoint":{"line":29,"column":38},"line":29,"code":"\ttest('should not create duplicate tag', async () => {\n\t\tconst newTag = Container.get(TagRepository).create({ name: 'test' });\n\t\tawait Container.get(TagRepository).save(newTag);\n\n\t\tconst resp = await authOwnerAgent.post('/tags').send({ name: 'test' });\n\t\texpect(resp.status).toBe(500);\n\n\t\tconst dbTag = await Container.get(TagRepository).findBy({ name: 'test' });\n\t\texpect(dbTag.length).toBe(1);\n\t});","file":"integration/tags.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all users (for owner)","suites":["GET /users"],"updatePoint":{"line":64,"column":42},"line":64,"code":"\ttest('should return all users (for owner)', async () => {\n\t\tawait testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst response = await authOwnerAgent.get('/users');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\n\t\tresponse.body.data.map((user: User) => {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = user;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBeDefined();\n\t\t\texpect(firstName).toBeDefined();\n\t\t\texpect(lastName).toBeDefined();\n\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole).toBeDefined();\n\t\t\texpect(apiKey).not.toBeDefined();\n\t\t});\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all users (for member)","suites":["GET /users"],"updatePoint":{"line":97,"column":43},"line":97,"code":"\ttest('should return all users (for member)', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst response = await testServer.authAgentFor(member).get('/users');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete the user","suites":["DELETE /users/:id"],"updatePoint":{"line":107,"column":29},"line":107,"code":"\ttest('should delete the user', async () => {\n\t\tconst userToDelete = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst newWorkflow = new WorkflowEntity();\n\n\t\tObject.assign(newWorkflow, {\n\t\t\tname: randomName(),\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [],\n\t\t});\n\n\t\tconst savedWorkflow = await Db.collections.Workflow.save(newWorkflow);\n\n\t\tawait Db.collections.SharedWorkflow.save({\n\t\t\trole: workflowOwnerRole,\n\t\t\tuser: userToDelete,\n\t\t\tworkflow: savedWorkflow,\n\t\t});\n\n\t\tconst newCredential = new CredentialsEntity();\n\n\t\tObject.assign(newCredential, {\n\t\t\tname: randomName(),\n\t\t\tdata: '',\n\t\t\ttype: '',\n\t\t\tnodesAccess: [],\n\t\t});\n\n\t\tconst savedCredential = await Db.collections.Credentials.save(newCredential);\n\n\t\tawait Db.collections.SharedCredentials.save({\n\t\t\trole: credentialOwnerRole,\n\t\t\tuser: userToDelete,\n\t\t\tcredentials: savedCredential,\n\t\t});\n\n\t\tconst response = await authOwnerAgent.delete(`/users/${userToDelete.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\tconst user = await Db.collections.User.findOneBy({ id: userToDelete.id });\n\t\texpect(user).toBeNull(); // deleted\n\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\t\trelations: ['user'],\n\t\t\twhere: { userId: userToDelete.id, roleId: workflowOwnerRole.id },\n\t\t});\n\t\texpect(sharedWorkflow).toBeNull(); // deleted\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOne({\n\t\t\trelations: ['user'],\n\t\t\twhere: { userId: userToDelete.id, roleId: credentialOwnerRole.id },\n\t\t});\n\t\texpect(sharedCredential).toBeNull(); // deleted\n\n\t\tconst workflow = await Db.collections.Workflow.findOneBy({ id: savedWorkflow.id });\n\t\texpect(workflow).toBeNull(); // deleted\n\n\t\t// TODO: Include active workflow and check whether webhook has been removed\n\n\t\tconst credential = await Db.collections.Credentials.findOneBy({ id: savedCredential.id });\n\t\texpect(credential).toBeNull(); // deleted\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail to delete self","suites":["DELETE /users/:id"],"updatePoint":{"line":173,"column":33},"line":173,"code":"\ttest('should fail to delete self', async () => {\n\t\tconst response = await authOwnerAgent.delete(`/users/${owner.id}`);\n\n\t\texpect(response.statusCode).toBe(400);\n\n\t\tconst user = await Db.collections.User.findOneBy({ id: owner.id });\n\t\texpect(user).toBeDefined();\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if user to delete is transferee","suites":["DELETE /users/:id"],"updatePoint":{"line":182,"column":50},"line":182,"code":"\ttest('should fail if user to delete is transferee', async () => {\n\t\tconst { id: idToDelete } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst response = await authOwnerAgent.delete(`/users/${idToDelete}`).query({\n\t\t\ttransferId: idToDelete,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(400);\n\n\t\tconst user = await Db.collections.User.findOneBy({ id: idToDelete });\n\t\texpect(user).toBeDefined();\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"with transferId should perform transfer","suites":["DELETE /users/:id"],"updatePoint":{"line":195,"column":46},"line":195,"code":"\ttest('with transferId should perform transfer', async () => {\n\t\tconst userToDelete = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedWorkflow = await testDb.createWorkflow(undefined, userToDelete);\n\n\t\tconst savedCredential = await testDb.saveCredential(randomCredentialPayload(), {\n\t\t\tuser: userToDelete,\n\t\t\trole: credentialOwnerRole,\n\t\t});\n\n\t\tconst response = await authOwnerAgent.delete(`/users/${userToDelete.id}`).query({\n\t\t\ttransferId: owner.id,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOneOrFail({\n\t\t\trelations: ['workflow'],\n\t\t\twhere: { userId: owner.id },\n\t\t});\n\n\t\texpect(sharedWorkflow.workflow).toBeDefined();\n\t\texpect(sharedWorkflow.workflow.id).toBe(savedWorkflow.id);\n\n\t\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\t\trelations: ['credentials'],\n\t\t\twhere: { userId: owner.id },\n\t\t});\n\n\t\texpect(sharedCredential.credentials).toBeDefined();\n\t\texpect(sharedCredential.credentials.id).toBe(savedCredential.id);\n\n\t\tconst deletedUser = await Db.collections.User.findOneBy({ id: userToDelete.id });\n\n\t\texpect(deletedUser).toBeNull();\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fill out a user shell","suites":["POST /users/:id"],"updatePoint":{"line":234,"column":35},"line":234,"code":"\ttest('should fill out a user shell', async () => {\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\t\tconst memberData = {\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await testServer.authlessAgent\n\t\t\t.post(`/users/${memberShell.id}`)\n\t\t\t.send(memberData);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tpassword,\n\t\t\tglobalRole,\n\t\t\tisPending,\n\t\t\tapiKey,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBeDefined();\n\t\texpect(firstName).toBe(memberData.firstName);\n\t\texpect(lastName).toBe(memberData.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole).toBeDefined();\n\t\texpect(apiKey).not.toBeDefined();\n\n\t\tconst authToken = utils.getAuthToken(response);\n\t\texpect(authToken).toBeDefined();\n\n\t\tconst member = await Db.collections.User.findOneByOrFail({ id: memberShell.id });\n\t\texpect(member.firstName).toBe(memberData.firstName);\n\t\texpect(member.lastName).toBe(memberData.lastName);\n\t\texpect(member.password).not.toBe(memberData.password);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /users/:id"],"updatePoint":{"line":279,"column":38},"line":279,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst memberShellEmail = randomEmail();\n\n\t\tconst memberShell = await Db.collections.User.save({\n\t\t\temail: memberShellEmail,\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconst invalidPayloads = [\n\t\t\t{\n\t\t\t\tfirstName: randomName(),\n\t\t\t\tlastName: randomName(),\n\t\t\t\tpassword: randomValidPassword(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tinviterId: owner.id,\n\t\t\t\tfirstName: randomName(),\n\t\t\t\tpassword: randomValidPassword(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tinviterId: owner.id,\n\t\t\t\tfirstName: randomName(),\n\t\t\t\tpassword: randomValidPassword(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tinviterId: owner.id,\n\t\t\t\tfirstName: randomName(),\n\t\t\t\tlastName: randomName(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tinviterId: owner.id,\n\t\t\t\tfirstName: randomName(),\n\t\t\t\tlastName: randomName(),\n\t\t\t\tpassword: randomInvalidPassword(),\n\t\t\t},\n\t\t];\n\n\t\tfor (const invalidPayload of invalidPayloads) {\n\t\t\tconst response = await testServer.authlessAgent\n\t\t\t\t.post(`/users/${memberShell.id}`)\n\t\t\t\t.send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedUser = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: memberShellEmail },\n\t\t\t});\n\n\t\t\texpect(storedUser.firstName).toBeNull();\n\t\t\texpect(storedUser.lastName).toBeNull();\n\t\t\texpect(storedUser.password).toBeNull();\n\t\t}\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with already accepted invite","suites":["POST /users/:id"],"updatePoint":{"line":332,"column":47},"line":332,"code":"\ttest('should fail with already accepted invite', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst newMemberData = {\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await testServer.authlessAgent.post(`/users/${member.id}`).send(newMemberData);\n\n\t\texpect(response.statusCode).toBe(400);\n\n\t\tconst storedMember = await Db.collections.User.findOneOrFail({\n\t\t\twhere: { email: member.email },\n\t\t});\n\t\texpect(storedMember.firstName).not.toBe(newMemberData.firstName);\n\t\texpect(storedMember.lastName).not.toBe(newMemberData.lastName);\n\n\t\tconst comparisonResult = await compareHash(member.password, storedMember.password);\n\t\texpect(comparisonResult).toBe(false);\n\t\texpect(storedMember.password).not.toBe(newMemberData.password);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should succeed if emailing is not set up","suites":["POST /users"],"updatePoint":{"line":363,"column":47},"line":363,"code":"\ttest('should succeed if emailing is not set up', async () => {\n\t\tconst response = await authOwnerAgent.post('/users').send([{ email: randomEmail() }]);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data[0].user.inviteAcceptUrl).toBeDefined();\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should email invites and create user shells but ignore existing","suites":["POST /users"],"updatePoint":{"line":370,"column":70},"line":370,"code":"\ttest('should email invites and create user shells but ignore existing', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\t\tconst testEmails = [\n\t\t\trandomEmail(),\n\t\t\trandomEmail().toUpperCase(),\n\t\t\tmemberShell.email,\n\t\t\tmember.email,\n\t\t];\n\n\t\tconst payload = testEmails.map((e) => ({ email: e }));\n\n\t\tconst response = await authOwnerAgent.post('/users').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tfor (const {\n\t\t\tuser: { id, email: receivedEmail },\n\t\t\terror,\n\t\t} of response.body.data) {\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(id).not.toBe(member.id);\n\n\t\t\tconst lowerCasedEmail = receivedEmail.toLowerCase();\n\t\t\texpect(receivedEmail).toBe(lowerCasedEmail);\n\t\t\texpect(payload.some(({ email }) => email.toLowerCase() === lowerCasedEmail)).toBe(true);\n\n\t\t\tif (error) {\n\t\t\t\texpect(error).toBe('Email could not be sent');\n\t\t\t}\n\n\t\t\tconst storedUser = await Db.collections.User.findOneByOrFail({ id });\n\t\t\tconst { firstName, lastName, personalizationAnswers, password } = storedUser;\n\n\t\t\texpect(firstName).toBeNull();\n\t\t\texpect(lastName).toBeNull();\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeNull();\n\t\t}\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid inputs","suites":["POST /users"],"updatePoint":{"line":412,"column":38},"line":412,"code":"\ttest('should fail with invalid inputs', async () => {\n\t\tconst invalidPayloads = [\n\t\t\trandomEmail(),\n\t\t\t[randomEmail()],\n\t\t\t{},\n\t\t\t[{ name: randomName() }],\n\t\t\t[{ email: randomName() }],\n\t\t];\n\n\t\tawait Promise.all(\n\t\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\t\tconst response = await authOwnerAgent.post('/users').send(invalidPayload);\n\t\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\t\tconst users = await Db.collections.User.find();\n\t\t\t\texpect(users.length).toBe(1); // DB unaffected\n\t\t\t}),\n\t\t);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore an empty payload","suites":["POST /users"],"updatePoint":{"line":432,"column":37},"line":432,"code":"\ttest('should ignore an empty payload', async () => {\n\t\tconst response = await authOwnerAgent.post('/users').send([]);\n\n\t\tconst { data } = response.body;\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(Array.isArray(data)).toBe(true);\n\t\texpect(data.length).toBe(0);\n\n\t\tconst users = await Db.collections.User.find();\n\t\texpect(users.length).toBe(1);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send reinvite, but fail if user already accepted invite","suites":["POST /users/:id/reinvite"],"updatePoint":{"line":455,"column":69},"line":455,"code":"\ttest('should send reinvite, but fail if user already accepted invite', async () => {\n\t\tconst email = randomEmail();\n\t\tconst payload = [{ email }];\n\t\tconst response = await authOwnerAgent.post('/users').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst { data } = response.body;\n\t\tconst invitedUserId = data[0].user.id;\n\t\tconst reinviteResponse = await authOwnerAgent.post(`/users/${invitedUserId}/reinvite`);\n\n\t\texpect(reinviteResponse.statusCode).toBe(200);\n\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst reinviteMemberResponse = await authOwnerAgent.post(`/users/${member.id}/reinvite`);\n\n\t\texpect(reinviteMemberResponse.statusCode).toBe(400);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"not be called when SMTP not set up","suites":["UserManagementMailer expect NodeMailer.verifyConnection"],"updatePoint":{"line":491,"column":41},"line":491,"code":"\ttest('not be called when SMTP not set up', async () => {\n\t\tconst userManagementMailer = new UserManagementMailer();\n\t\t// NodeMailer.verifyConnection gets called only explicitly\n\t\tawait expect(async () => userManagementMailer.verifyConnection()).rejects.toThrow();\n\n\t\texpect(NodeMailer.prototype.verifyConnection).toHaveBeenCalledTimes(0);\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"to be called when SMTP set up","suites":["UserManagementMailer expect NodeMailer.verifyConnection"],"updatePoint":{"line":499,"column":36},"line":499,"code":"\ttest('to be called when SMTP set up', async () => {\n\t\t// host needs to be set, otherwise smtp is skipped\n\t\tconfig.set('userManagement.emails.smtp.host', 'host');\n\t\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t\tconst userManagementMailer = new UserManagementMailer();\n\t\t// NodeMailer.verifyConnection gets called only explicitly\n\t\texpect(async () => userManagementMailer.verifyConnection()).not.toThrow();\n\t});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all variables for an owner","suites":["GET /variables"],"updatePoint":{"line":45,"column":47},"line":45,"code":"\ttest('should return all variables for an owner', async () => {\n\t\tconst response = await authOwnerAgent.get('/variables');\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all variables for a member","suites":["GET /variables"],"updatePoint":{"line":51,"column":47},"line":51,"code":"\ttest('should return all variables for a member', async () => {\n\t\tconst response = await authMemberAgent.get('/variables');\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.length).toBe(2);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a single variable for an owner","suites":["GET /variables/:id"],"updatePoint":{"line":70,"column":51},"line":70,"code":"\ttest('should return a single variable for an owner', async () => {\n\t\tconst response1 = await authOwnerAgent.get(`/variables/${var1.id}`);\n\t\texpect(response1.statusCode).toBe(200);\n\t\texpect(response1.body.data.key).toBe('test1');\n\n\t\tconst response2 = await authOwnerAgent.get(`/variables/${var2.id}`);\n\t\texpect(response2.statusCode).toBe(200);\n\t\texpect(response2.body.data.key).toBe('test2');\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a single variable for a member","suites":["GET /variables/:id"],"updatePoint":{"line":80,"column":51},"line":80,"code":"\ttest('should return a single variable for a member', async () => {\n\t\tconst response1 = await authMemberAgent.get(`/variables/${var1.id}`);\n\t\texpect(response1.statusCode).toBe(200);\n\t\texpect(response1.body.data.key).toBe('test1');\n\n\t\tconst response2 = await authMemberAgent.get(`/variables/${var2.id}`);\n\t\texpect(response2.statusCode).toBe(200);\n\t\texpect(response2.body.data.key).toBe('test2');\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create a new variable and return it for an owner","suites":["POST /variables"],"updatePoint":{"line":101,"column":62},"line":101,"code":"\ttest('should create a new variable and return it for an owner', async () => {\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.key).toBe(toCreate.key);\n\t\texpect(response.body.data.value).toBe(toCreate.value);\n\n\t\tconst [byId, byKey] = await Promise.all([\n\t\t\ttestDb.getVariableById(response.body.data.id),\n\t\t\ttestDb.getVariableByKey(toCreate.key),\n\t\t]);\n\n\t\texpect(byId).not.toBeNull();\n\t\texpect(byId!.key).toBe(toCreate.key);\n\t\texpect(byId!.value).toBe(toCreate.value);\n\n\t\texpect(byKey).not.toBeNull();\n\t\texpect(byKey!.id).toBe(response.body.data.id);\n\t\texpect(byKey!.value).toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not create a new variable and return it for a member","suites":["POST /variables"],"updatePoint":{"line":121,"column":66},"line":121,"code":"\ttest('should not create a new variable and return it for a member', async () => {\n\t\tconst response = await authMemberAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(401);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\n\t\tconst byKey = await testDb.getVariableByKey(toCreate.key);\n\t\texpect(byKey).toBeNull();\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /variables should not create a new variable and return it if the instance doesn't have a license","suites":["POST /variables"],"updatePoint":{"line":131,"column":108},"line":131,"code":"\ttest(\"POST /variables should not create a new variable and return it if the instance doesn't have a license\", async () => {\n\t\tlicenseLike.isVariablesEnabled.mockReturnValue(false);\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\n\t\tconst byKey = await testDb.getVariableByKey(toCreate.key);\n\t\texpect(byKey).toBeNull();\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail to create a new variable and if one with the same key exists","suites":["POST /variables"],"updatePoint":{"line":142,"column":79},"line":142,"code":"\ttest('should fail to create a new variable and if one with the same key exists', async () => {\n\t\tawait testDb.createVariable(toCreate.key, toCreate.value);\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(500);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not fail if variable limit not reached","suites":["POST /variables"],"updatePoint":{"line":150,"column":52},"line":150,"code":"\ttest('should not fail if variable limit not reached', async () => {\n\t\tlicenseLike.getVariablesLimit.mockReturnValue(5);\n\t\tlet i = 1;\n\t\tlet toCreate = generatePayload(i);\n\t\twhile (i < 3) {\n\t\t\tawait testDb.createVariable(toCreate.key, toCreate.value);\n\t\t\ti++;\n\t\t\ttoCreate = generatePayload(i);\n\t\t}\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data?.key).toBe(toCreate.key);\n\t\texpect(response.body.data?.value).toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if variable limit reached","suites":["POST /variables"],"updatePoint":{"line":165,"column":44},"line":165,"code":"\ttest('should fail if variable limit reached', async () => {\n\t\tlicenseLike.getVariablesLimit.mockReturnValue(5);\n\t\tlet i = 1;\n\t\tlet toCreate = generatePayload(i);\n\t\twhile (i < 6) {\n\t\t\tawait testDb.createVariable(toCreate.key, toCreate.value);\n\t\t\ti++;\n\t\t\ttoCreate = generatePayload(i);\n\t\t}\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if key too long","suites":["POST /variables"],"updatePoint":{"line":180,"column":34},"line":180,"code":"\ttest('should fail if key too long', async () => {\n\t\tconst toCreate = {\n\t\t\t// 51 'a's\n\t\t\tkey: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n\t\t\tvalue: 'value',\n\t\t};\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if value too long","suites":["POST /variables"],"updatePoint":{"line":192,"column":36},"line":192,"code":"\ttest('should fail if value too long', async () => {\n\t\tconst toCreate = {\n\t\t\tkey: 'key',\n\t\t\t// 256 'a's\n\t\t\tvalue:\n\t\t\t\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n\t\t};\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if key contain's prohibited characters","suites":["POST /variables"],"updatePoint":{"line":205,"column":57},"line":205,"code":"\ttest(\"should fail if key contain's prohibited characters\", async () => {\n\t\tconst toCreate = {\n\t\t\t// 51 'a's\n\t\t\tkey: 'te$t',\n\t\t\tvalue: 'value',\n\t\t};\n\t\tconst response = await authOwnerAgent.post('/variables').send(toCreate);\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.data?.key).not.toBe(toCreate.key);\n\t\texpect(response.body.data?.value).not.toBe(toCreate.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should modify existing variable if use is an owner","suites":["PATCH /variables/:id"],"updatePoint":{"line":227,"column":57},"line":227,"code":"\ttest('should modify existing variable if use is an owner', async () => {\n\t\tconst variable = await testDb.createVariable('test1', 'value1');\n\t\tconst response = await authOwnerAgent.patch(`/variables/${variable.id}`).send(toModify);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.key).toBe(toModify.key);\n\t\texpect(response.body.data.value).toBe(toModify.value);\n\n\t\tconst [byId, byKey] = await Promise.all([\n\t\t\ttestDb.getVariableById(response.body.data.id),\n\t\t\ttestDb.getVariableByKey(toModify.key),\n\t\t]);\n\n\t\texpect(byId).not.toBeNull();\n\t\texpect(byId!.key).toBe(toModify.key);\n\t\texpect(byId!.value).toBe(toModify.value);\n\n\t\texpect(byKey).not.toBeNull();\n\t\texpect(byKey!.id).toBe(response.body.data.id);\n\t\texpect(byKey!.value).toBe(toModify.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should modify existing variable if use is an owner","suites":["PATCH /variables/:id"],"updatePoint":{"line":248,"column":57},"line":248,"code":"\ttest('should modify existing variable if use is an owner', async () => {\n\t\tconst variable = await testDb.createVariable('test1', 'value1');\n\t\tconst response = await authOwnerAgent.patch(`/variables/${variable.id}`).send(toModify);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.key).toBe(toModify.key);\n\t\texpect(response.body.data.value).toBe(toModify.value);\n\n\t\tconst [byId, byKey] = await Promise.all([\n\t\t\ttestDb.getVariableById(response.body.data.id),\n\t\t\ttestDb.getVariableByKey(toModify.key),\n\t\t]);\n\n\t\texpect(byId).not.toBeNull();\n\t\texpect(byId!.key).toBe(toModify.key);\n\t\texpect(byId!.value).toBe(toModify.value);\n\n\t\texpect(byKey).not.toBeNull();\n\t\texpect(byKey!.id).toBe(response.body.data.id);\n\t\texpect(byKey!.value).toBe(toModify.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not modify existing variable if use is a member","suites":["PATCH /variables/:id"],"updatePoint":{"line":269,"column":61},"line":269,"code":"\ttest('should not modify existing variable if use is a member', async () => {\n\t\tconst variable = await testDb.createVariable('test1', 'value1');\n\t\tconst response = await authMemberAgent.patch(`/variables/${variable.id}`).send(toModify);\n\t\texpect(response.statusCode).toBe(401);\n\t\texpect(response.body.data?.key).not.toBe(toModify.key);\n\t\texpect(response.body.data?.value).not.toBe(toModify.value);\n\n\t\tconst byId = await testDb.getVariableById(variable.id);\n\t\texpect(byId).not.toBeNull();\n\t\texpect(byId!.key).not.toBe(toModify.key);\n\t\texpect(byId!.value).not.toBe(toModify.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not modify existing variable if one with the same key exists","suites":["PATCH /variables/:id"],"updatePoint":{"line":282,"column":74},"line":282,"code":"\ttest('should not modify existing variable if one with the same key exists', async () => {\n\t\tconst [var1, var2] = await Promise.all([\n\t\t\ttestDb.createVariable('test1', 'value1'),\n\t\t\ttestDb.createVariable(toModify.key, toModify.value),\n\t\t]);\n\t\tconst response = await authOwnerAgent.patch(`/variables/${var1.id}`).send(toModify);\n\t\texpect(response.statusCode).toBe(500);\n\t\texpect(response.body.data?.key).not.toBe(toModify.key);\n\t\texpect(response.body.data?.value).not.toBe(toModify.value);\n\n\t\tconst byId = await testDb.getVariableById(var1.id);\n\t\texpect(byId).not.toBeNull();\n\t\texpect(byId!.key).toBe(var1.key);\n\t\texpect(byId!.value).toBe(var1.value);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete a single variable for an owner","suites":["DELETE /variables/:id"],"updatePoint":{"line":303,"column":51},"line":303,"code":"\ttest('should delete a single variable for an owner', async () => {\n\t\tconst [var1, var2, var3] = await Promise.all([\n\t\t\ttestDb.createVariable('test1', 'value1'),\n\t\t\ttestDb.createVariable('test2', 'value2'),\n\t\t\ttestDb.createVariable('test3', 'value3'),\n\t\t]);\n\n\t\tconst delResponse = await authOwnerAgent.delete(`/variables/${var1.id}`);\n\t\texpect(delResponse.statusCode).toBe(200);\n\n\t\tconst byId = await testDb.getVariableById(var1.id);\n\t\texpect(byId).toBeNull();\n\n\t\tconst getResponse = await authOwnerAgent.get('/variables');\n\t\texpect(getResponse.body.data.length).toBe(2);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete a single variable for a member","suites":["DELETE /variables/:id"],"updatePoint":{"line":320,"column":55},"line":320,"code":"\ttest('should not delete a single variable for a member', async () => {\n\t\tconst [var1, var2, var3] = await Promise.all([\n\t\t\ttestDb.createVariable('test1', 'value1'),\n\t\t\ttestDb.createVariable('test2', 'value2'),\n\t\t\ttestDb.createVariable('test3', 'value3'),\n\t\t]);\n\n\t\tconst delResponse = await authMemberAgent.delete(`/variables/${var1.id}`);\n\t\texpect(delResponse.statusCode).toBe(401);\n\n\t\tconst byId = await testDb.getVariableById(var1.id);\n\t\texpect(byId).not.toBeNull();\n\n\t\tconst getResponse = await authMemberAgent.get('/variables');\n\t\texpect(getResponse.body.data.length).toBe(3);\n\t});","file":"integration/variables.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle JSON","suites":["Webhook API","Content-Type support"],"updatePoint":{"line":62,"column":26},"line":62,"code":"\t\ttest('should handle JSON', async () => {\n\t\t\tconst response = await agent.post('/webhook/abcd').send({ test: true });\n\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\texpect(response.body).toEqual({ type: 'application/json', body: { test: true } });\n\t\t});","file":"integration/webhooks.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle XML","suites":["Webhook API","Content-Type support"],"updatePoint":{"line":68,"column":25},"line":68,"code":"\t\ttest('should handle XML', async () => {\n\t\t\tconst response = await agent\n\t\t\t\t.post('/webhook/abcd')\n\t\t\t\t.set('content-type', 'application/xml')\n\t\t\t\t.send(\n\t\t\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\"?><Outer attr=\"test\"><Inner>value</Inner></Outer>',\n\t\t\t\t);\n\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\texpect(response.body).toEqual({\n\t\t\t\ttype: 'application/xml',\n\t\t\t\tbody: {\n\t\t\t\t\touter: {\n\t\t\t\t\t\t$: {\n\t\t\t\t\t\t\tattr: 'test',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinner: 'value',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});","file":"integration/webhooks.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle form-urlencoded","suites":["Webhook API","Content-Type support"],"updatePoint":{"line":89,"column":37},"line":89,"code":"\t\ttest('should handle form-urlencoded', async () => {\n\t\t\tconst response = await agent\n\t\t\t\t.post('/webhook/abcd')\n\t\t\t\t.set('content-type', 'application/x-www-form-urlencoded')\n\t\t\t\t.send('x=5&y=str&z=false');\n\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\texpect(response.body).toEqual({\n\t\t\t\ttype: 'application/x-www-form-urlencoded',\n\t\t\t\tbody: { x: '5', y: 'str', z: 'false' },\n\t\t\t});\n\t\t});","file":"integration/webhooks.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle plain text","suites":["Webhook API","Content-Type support"],"updatePoint":{"line":101,"column":32},"line":101,"code":"\t\ttest('should handle plain text', async () => {\n\t\t\tconst response = await agent\n\t\t\t\t.post('/webhook/abcd')\n\t\t\t\t.set('content-type', 'text/plain')\n\t\t\t\t.send('{\"key\": \"value\"}');\n\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\texpect(response.body).toEqual({\n\t\t\t\ttype: 'text/plain',\n\t\t\t\tbody: '{\"key\": \"value\"}',\n\t\t\t});\n\t\t});","file":"integration/webhooks.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle multipart/form-data","suites":["Webhook API","Content-Type support"],"updatePoint":{"line":113,"column":41},"line":113,"code":"\t\ttest('should handle multipart/form-data', async () => {\n\t\t\tconst response = await agent\n\t\t\t\t.post('/webhook/abcd')\n\t\t\t\t.field('field', 'value')\n\t\t\t\t.attach('file', Buffer.from('random-text'))\n\t\t\t\t.set('content-type', 'multipart/form-data');\n\n\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\texpect(response.body.type).toEqual('multipart/form-data');\n\t\t\tconst {\n\t\t\t\tdata,\n\t\t\t\tfiles: {\n\t\t\t\t\tfile: [file],\n\t\t\t\t},\n\t\t\t} = response.body.body;\n\t\t\texpect(data).toEqual({ field: ['value'] });\n\t\t\texpect(file.mimetype).toEqual('application/octet-stream');\n\t\t\texpect(readFileSync(file.filepath, 'utf-8')).toEqual('random-text');\n\t\t});","file":"integration/webhooks.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"when sharing is disabled","suites":["router should switch based on flag"],"updatePoint":{"line":60,"column":31},"line":60,"code":"\ttest('when sharing is disabled', async () => {\n\t\tsharingSpy.mockReturnValueOnce(false);\n\n\t\tawait authOwnerAgent\n\t\t\t.put(`/workflows/${savedWorkflowId}/share`)\n\t\t\t.send({ shareWithIds: [member.id] })\n\t\t\t.expect(404);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"when sharing is enabled","suites":["router should switch based on flag"],"updatePoint":{"line":69,"column":30},"line":69,"code":"\ttest('when sharing is enabled', async () => {\n\t\tawait authOwnerAgent\n\t\t\t.put(`/workflows/${savedWorkflowId}/share`)\n\t\t\t.send({ shareWithIds: [member.id] })\n\t\t\t.expect(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should save sharing with new users","suites":["PUT /workflows/:id"],"updatePoint":{"line":78,"column":66},"line":78,"code":"\ttest('PUT /workflows/:id/share should save sharing with new users', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should succeed when sharing with invalid user-id","suites":["PUT /workflows/:id"],"updatePoint":{"line":91,"column":80},"line":91,"code":"\ttest('PUT /workflows/:id/share should succeed when sharing with invalid user-id', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [uuid()] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should allow sharing with multiple users","suites":["PUT /workflows/:id"],"updatePoint":{"line":104,"column":72},"line":104,"code":"\ttest('PUT /workflows/:id/share should allow sharing with multiple users', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id, anotherMember.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(3);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should override sharing","suites":["PUT /workflows/:id"],"updatePoint":{"line":117,"column":55},"line":117,"code":"\ttest('PUT /workflows/:id/share should override sharing', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id, anotherMember.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(3);\n\n\t\tconst secondResponse = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id] });\n\t\texpect(secondResponse.statusCode).toBe(200);\n\n\t\tconst secondSharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(secondSharedWorkflows).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return workflows without nodes, sharing and credential usage details","suites":["GET /workflows"],"updatePoint":{"line":140,"column":82},"line":140,"code":"\ttest('should return workflows without nodes, sharing and credential usage details', async () => {\n\t\tconst tag = await testDb.createTag({ name: 'test' });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflow = await createWorkflow(\n\t\t\t{\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: uuid(),\n\t\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\t\tparameters: {},\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\t\tcredentials: {\n\t\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttags: [tag],\n\t\t\t},\n\t\t\towner,\n\t\t);\n\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member]);\n\n\t\tconst response = await authOwnerAgent.get('/workflows');\n\n\t\tconst [fetchedWorkflow] = response.body.data;\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(fetchedWorkflow.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t});\n\n\t\texpect(fetchedWorkflow.sharedWith).not.toBeDefined();\n\t\texpect(fetchedWorkflow.usedCredentials).not.toBeDefined();\n\t\texpect(fetchedWorkflow.nodes).not.toBeDefined();\n\t\texpect(fetchedWorkflow.tags).toEqual(\n\t\t\texpect.arrayContaining([\n\t\t\t\texpect.objectContaining({\n\t\t\t\t\tid: expect.any(String),\n\t\t\t\t\tname: expect.any(String),\n\t\t\t\t}),\n\t\t\t]),\n\t\t);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return an auto-incremented name, even when sharing is ","suites":["GET /workflows/new"],"updatePoint":{"line":197,"column":3},"line":195,"code":"\t\ttest(`should return an auto-incremented name, even when sharing is ${\n\t\t\tsharingEnabled ? 'enabled' : 'disabled'\n\t\t}`, async () => {\n\t\t\tsharingSpy.mockReturnValueOnce(sharingEnabled);\n\n\t\t\tawait createWorkflow({ name: 'My workflow' }, owner);\n\t\t\tawait createWorkflow({ name: 'My workflow 7' }, owner);\n\n\t\t\tconst response = await authOwnerAgent.get('/workflows/new');\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body.data.name).toEqual('My workflow 8');\n\t\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should fail with invalid id due to route rule","suites":["GET /workflows/:id"],"updatePoint":{"line":211,"column":56},"line":211,"code":"\ttest('GET should fail with invalid id due to route rule', async () => {\n\t\tconst response = await authOwnerAgent.get('/workflows/potatoes');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return 404 for non existing workflow","suites":["GET /workflows/:id"],"updatePoint":{"line":217,"column":54},"line":217,"code":"\ttest('GET should return 404 for non existing workflow', async () => {\n\t\tconst response = await authOwnerAgent.get('/workflows/9001');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return a workflow with owner","suites":["GET /workflows/:id"],"updatePoint":{"line":223,"column":46},"line":223,"code":"\ttest('GET should return a workflow with owner', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return shared workflow with user data","suites":["GET /workflows/:id"],"updatePoint":{"line":239,"column":55},"line":239,"code":"\ttest('GET should return shared workflow with user data', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member]);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(1);\n\t\texpect(response.body.data.sharedWith[0]).toMatchObject({\n\t\t\tid: member.id,\n\t\t\temail: member.email,\n\t\t\tfirstName: member.firstName,\n\t\t\tlastName: member.lastName,\n\t\t});\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return all sharees","suites":["GET /workflows/:id"],"updatePoint":{"line":262,"column":36},"line":262,"code":"\ttest('GET should return all sharees', async () => {\n\t\tconst workflow = await createWorkflow({}, owner);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member, anotherMember]);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials owned by user","suites":["GET /workflows/:id"],"updatePoint":{"line":279,"column":64},"line":279,"code":"\ttest('GET should return workflow with credentials owned by user', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, owner);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials saying owner does not have access when not shared","suites":["GET /workflows/:id"],"updatePoint":{"line":302,"column":100},"line":302,"code":"\ttest('GET should return workflow with credentials saying owner does not have access when not shared', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, owner);\n\n\t\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: false, // although owner can see, they do not have access\n\t\t\t},\n\t\t]);\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials for all users with or without access","suites":["GET /workflows/:id"],"updatePoint":{"line":325,"column":87},"line":325,"code":"\ttest('GET should return workflow with credentials for all users with or without access', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, member);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [anotherMember]);\n\n\t\tconst responseMember1 = await authMemberAgent.get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember1.statusCode).toBe(200);\n\t\texpect(responseMember1.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true, // one user has access\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember1.body.data.sharedWith).toHaveLength(1);\n\n\t\tconst responseMember2 = await authAnotherMemberAgent.get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember2.statusCode).toBe(200);\n\t\texpect(responseMember2.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: false, // the other one doesn't\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember2.body.data.sharedWith).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials for all users with access","suites":["GET /workflows/:id"],"updatePoint":{"line":358,"column":76},"line":358,"code":"\ttest('GET should return workflow with credentials for all users with access', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\t// Both users have access to the credential (none is owner)\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [anotherMember]);\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, member);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [anotherMember]);\n\n\t\tconst responseMember1 = await authMemberAgent.get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember1.statusCode).toBe(200);\n\t\texpect(responseMember1.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember1.body.data.sharedWith).toHaveLength(1);\n\n\t\tconst responseMember2 = await authAnotherMemberAgent.get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember2.statusCode).toBe(200);\n\t\texpect(responseMember2.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id,\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember2.body.data.sharedWith).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should create a workflow that uses no credential","suites":["POST /workflows"],"updatePoint":{"line":395,"column":53},"line":395,"code":"\tit('Should create a workflow that uses no credential', async () => {\n\t\tconst workflow = makeWorkflow({ withPinData: false });\n\n\t\tconst response = await authOwnerAgent.post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should save a new workflow with credentials","suites":["POST /workflows"],"updatePoint":{"line":403,"column":48},"line":403,"code":"\tit('Should save a new workflow with credentials', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authOwnerAgent.post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not allow saving a workflow using credential you have no access","suites":["POST /workflows"],"updatePoint":{"line":415,"column":75},"line":415,"code":"\tit('Should not allow saving a workflow using credential you have no access', async () => {\n\t\t// Credential belongs to owner, member cannot use it.\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authMemberAgent.post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.message).toBe(\n\t\t\t'The workflow you are trying to save contains credentials that are not shared with you',\n\t\t);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow owner to save a workflow using credential owned by others","suites":["POST /workflows"],"updatePoint":{"line":431,"column":75},"line":431,"code":"\tit('Should allow owner to save a workflow using credential owned by others', async () => {\n\t\t// Credential belongs to owner, member cannot use it.\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authOwnerAgent.post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow saving a workflow using a credential owned by others and shared with you","suites":["POST /workflows"],"updatePoint":{"line":444,"column":90},"line":444,"code":"\tit('Should allow saving a workflow using a credential owned by others and shared with you', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [anotherMember]);\n\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id, name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authAnotherMemberAgent.post('/workflows').send(workflow);\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should succeed when saving unchanged workflow nodes","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":459,"column":56},"line":459,"code":"\tit('Should succeed when saving unchanged workflow nodes', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(workflow);\n\t\tconst { id, versionId } = createResponse.body.data;\n\n\t\tconst response = await authOwnerAgent.patch(`/workflows/${id}`).send({\n\t\t\tname: 'new name',\n\t\t\tversionId,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow owner to add node containing credential not shared with the owner","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":494,"column":83},"line":494,"code":"\tit('Should allow owner to add node containing credential not shared with the owner', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(workflow);\n\t\tconst { id, versionId } = createResponse.body.data;\n\n\t\tconst response = await authOwnerAgent.patch(`/workflows/${id}`).send({\n\t\t\tversionId,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should prevent member from adding node containing credential inaccessible to member","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":544,"column":88},"line":544,"code":"\tit('Should prevent member from adding node containing credential inaccessible to member', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(workflow);\n\t\tconst { id, versionId } = createResponse.body.data;\n\n\t\tconst response = await authMemberAgent.patch(`/workflows/${id}`).send({\n\t\t\tversionId,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-12345',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should succeed but prevent modifying node attributes other than position, name and disabled","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":603,"column":96},"line":603,"code":"\tit('Should succeed but prevent modifying node attributes other than position, name and disabled', async () => {\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst originalNodes: INode[] = [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tname: 'Start',\n\t\t\t\tparameters: {\n\t\t\t\t\tfirstParam: 123,\n\t\t\t\t},\n\t\t\t\tposition: [-20, 260],\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tcredentials: {\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t];\n\n\t\tconst changedNodes: INode[] = [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tname: 'End',\n\t\t\t\tparameters: {\n\t\t\t\t\tfirstParam: 456,\n\t\t\t\t},\n\t\t\t\tposition: [-20, 555],\n\t\t\t\ttype: 'n8n-nodes-base.no-op',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tcredentials: {\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tid: '200',\n\t\t\t\t\t\tname: 'fake credential',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdisabled: true,\n\t\t\t},\n\t\t];\n\n\t\tconst expectedNodes: INode[] = [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tname: 'End',\n\t\t\t\tparameters: {\n\t\t\t\t\tfirstParam: 123,\n\t\t\t\t},\n\t\t\t\tposition: [-20, 555],\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tcredentials: {\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tid: savedCredential.id,\n\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdisabled: true,\n\t\t\t},\n\t\t];\n\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: originalNodes,\n\t\t};\n\n\t\tconst createResponse = await authMemberAgent.post('/workflows').send(workflow);\n\t\tconst { id, versionId } = createResponse.body.data;\n\n\t\tawait authMemberAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [anotherMember.id] });\n\n\t\tconst response = await authAnotherMemberAgent.patch(`/workflows/${id}`).send({\n\t\t\tversionId,\n\t\t\tnodes: changedNodes,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.nodes).toMatchObject(expectedNodes);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block owner updating workflow nodes on interim update by member","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":688,"column":75},"line":688,"code":"\tit('should block owner updating workflow nodes on interim update by member', async () => {\n\t\t// owner creates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerVersionId } = createResponse.body.data;\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses and updates workflow name\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\n\t\tawait authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ name: 'Update by member', versionId: memberVersionId });\n\n\t\t// owner blocked from updating workflow nodes\n\n\t\tconst updateAttemptResponse = await authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ nodes: [], versionId: ownerVersionId });\n\n\t\texpect(updateAttemptResponse.status).toBe(400);\n\t\texpect(updateAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block member updating workflow nodes on interim update by owner","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":714,"column":75},"line":714,"code":"\tit('should block member updating workflow nodes on interim update by owner', async () => {\n\t\t// owner creates, updates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerFirstVersionId } = createResponse.body.data;\n\n\t\tconst updateResponse = await authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ name: 'Update by owner', versionId: ownerFirstVersionId });\n\n\t\tconst { versionId: ownerSecondVersionId } = updateResponse.body.data;\n\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses workflow\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\n\t\t// owner re-updates workflow\n\n\t\tawait authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ name: 'Owner update again', versionId: ownerSecondVersionId });\n\n\t\t// member blocked from updating workflow\n\n\t\tconst updateAttemptResponse = await authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ nodes: [], versionId: memberVersionId });\n\n\t\texpect(updateAttemptResponse.status).toBe(400);\n\t\texpect(updateAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block owner activation on interim activation by member","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":749,"column":66},"line":749,"code":"\tit('should block owner activation on interim activation by member', async () => {\n\t\t// owner creates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerVersionId } = createResponse.body.data;\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses and activates workflow\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\t\tawait authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ active: true, versionId: memberVersionId, name: 'Update by member' });\n\t\t// owner blocked from activating workflow\n\n\t\tconst activationAttemptResponse = await authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ active: true, versionId: ownerVersionId, name: 'Update by owner' });\n\n\t\texpect(activationAttemptResponse.status).toBe(400);\n\t\texpect(activationAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block member activation on interim activation by owner","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":773,"column":66},"line":773,"code":"\tit('should block member activation on interim activation by owner', async () => {\n\t\t// owner creates, updates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerFirstVersionId } = createResponse.body.data;\n\n\t\tconst updateResponse = await authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ name: 'Update by owner', versionId: ownerFirstVersionId });\n\t\tconst { versionId: ownerSecondVersionId } = updateResponse.body.data;\n\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses workflow\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\n\t\t// owner activates workflow\n\n\t\tawait authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ active: true, versionId: ownerSecondVersionId, name: 'Owner update again' });\n\n\t\t// member blocked from activating workflow\n\n\t\tconst updateAttemptResponse = await authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ active: true, versionId: memberVersionId, name: 'Update by member' });\n\n\t\texpect(updateAttemptResponse.status).toBe(400);\n\t\texpect(updateAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block member updating workflow settings on interim update by owner","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":807,"column":78},"line":807,"code":"\tit('should block member updating workflow settings on interim update by owner', async () => {\n\t\t// owner creates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerVersionId } = createResponse.body.data;\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses workflow\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\n\t\t// owner updates workflow name\n\n\t\tawait authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ name: 'Another name', versionId: ownerVersionId });\n\n\t\t// member blocked from updating workflow settings\n\n\t\tconst updateAttemptResponse = await authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ settings: { saveManualExecutions: true }, versionId: memberVersionId });\n\n\t\texpect(updateAttemptResponse.status).toBe(400);\n\t\texpect(updateAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should block member updating workflow name on interim update by owner","suites":["PATCH /workflows/:id - validate interim updates"],"updatePoint":{"line":835,"column":74},"line":835,"code":"\tit('should block member updating workflow name on interim update by owner', async () => {\n\t\t// owner creates and shares workflow\n\n\t\tconst createResponse = await authOwnerAgent.post('/workflows').send(makeWorkflow());\n\t\tconst { id, versionId: ownerVersionId } = createResponse.body.data;\n\t\tawait authOwnerAgent.put(`/workflows/${id}/share`).send({ shareWithIds: [member.id] });\n\n\t\t// member accesses workflow\n\n\t\tconst memberGetResponse = await authMemberAgent.get(`/workflows/${id}`);\n\t\tconst { versionId: memberVersionId } = memberGetResponse.body.data;\n\n\t\t// owner updates workflow settings\n\n\t\tawait authOwnerAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ settings: { saveManualExecutions: true }, versionId: ownerVersionId });\n\n\t\t// member blocked from updating workflow name\n\n\t\tconst updateAttemptResponse = await authMemberAgent\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({ settings: { saveManualExecutions: true }, versionId: memberVersionId });\n\n\t\texpect(updateAttemptResponse.status).toBe(400);\n\t\texpect(updateAttemptResponse.body.code).toBe(100);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show all workflows to owners","suites":["getSharedWorkflowIds"],"updatePoint":{"line":865,"column":40},"line":865,"code":"\tit('should show all workflows to owners', async () => {\n\t\towner.globalRole = await getGlobalOwnerRole();\n\t\tconst workflow1 = await createWorkflow({}, member);\n\t\tconst workflow2 = await createWorkflow({}, anotherMember);\n\t\tconst sharedWorkflowIds = await getSharedWorkflowIds(owner);\n\t\texpect(sharedWorkflowIds).toHaveLength(2);\n\t\texpect(sharedWorkflowIds).toContain(workflow1.id);\n\t\texpect(sharedWorkflowIds).toContain(workflow2.id);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show shared workflows to users","suites":["getSharedWorkflowIds"],"updatePoint":{"line":875,"column":42},"line":875,"code":"\tit('should show shared workflows to users', async () => {\n\t\tmember.globalRole = await getGlobalMemberRole();\n\t\tconst workflow1 = await createWorkflow({}, anotherMember);\n\t\tconst workflow2 = await createWorkflow({}, anotherMember);\n\t\tconst workflow3 = await createWorkflow({}, anotherMember);\n\t\tawait testDb.shareWorkflowWithUsers(workflow1, [member]);\n\t\tawait testDb.shareWorkflowWithUsers(workflow3, [member]);\n\t\tconst sharedWorkflowIds = await getSharedWorkflowIds(member);\n\t\texpect(sharedWorkflowIds).toHaveLength(2);\n\t\texpect(sharedWorkflowIds).toContain(workflow1.id);\n\t\texpect(sharedWorkflowIds).toContain(workflow3.id);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should store pin data for node in workflow","suites":["POST /workflows"],"updatePoint":{"line":32,"column":49},"line":32,"code":"\ttest('should store pin data for node in workflow', async () => {\n\t\tconst pinData = await testWithPinData(true);\n\t\texpect(pinData).toMatchObject(MOCK_PINDATA);\n\t});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set pin data to null if no pin data","suites":["POST /workflows"],"updatePoint":{"line":37,"column":49},"line":37,"code":"\ttest('should set pin data to null if no pin data', async () => {\n\t\tconst pinData = await testWithPinData(false);\n\t\texpect(pinData).toBeNull();\n\t});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return pin data","suites":["GET /workflows/:id"],"updatePoint":{"line":44,"column":29},"line":44,"code":"\ttest('should return pin data', async () => {\n\t\tconst workflow = makeWorkflow({ withPinData: true });\n\t\tconst workflowCreationResponse = await authOwnerAgent.post('/workflows').send(workflow);\n\n\t\tconst { id } = workflowCreationResponse.body.data as { id: string };\n\t\tconst workflowRetrievalResponse = await authOwnerAgent.get(`/workflows/${id}`);\n\n\t\texpect(workflowRetrievalResponse.statusCode).toBe(200);\n\t\tconst { pinData } = workflowRetrievalResponse.body.data as { pinData: IPinData };\n\t\texpect(pinData).toMatchObject(MOCK_PINDATA);\n\t});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should initialize activeExecutions with empty list","suites":["ActiveExecutions"],"updatePoint":{"line":34,"column":57},"line":34,"code":"\ttest('Should initialize activeExecutions with empty list', () => {\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should add execution to active execution list","suites":["ActiveExecutions"],"updatePoint":{"line":38,"column":52},"line":38,"code":"\ttest('Should add execution to active execution list', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\n\t\texpect(executionId).toBe(FAKE_EXECUTION_ID);\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(1);\n\t\texpect(createNewExecution).toHaveBeenCalledTimes(1);\n\t\texpect(updateExistingExecution).toHaveBeenCalledTimes(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should update execution if add is called with execution ID","suites":["ActiveExecutions"],"updatePoint":{"line":48,"column":65},"line":48,"code":"\ttest('Should update execution if add is called with execution ID', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(\n\t\t\tnewExecution,\n\t\t\tundefined,\n\t\t\tFAKE_SECOND_EXECUTION_ID,\n\t\t);\n\n\t\texpect(executionId).toBe(FAKE_SECOND_EXECUTION_ID);\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(1);\n\t\texpect(createNewExecution).toHaveBeenCalledTimes(0);\n\t\texpect(updateExistingExecution).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail attaching execution to invalid executionId","suites":["ActiveExecutions"],"updatePoint":{"line":62,"column":61},"line":62,"code":"\ttest('Should fail attaching execution to invalid executionId', async () => {\n\t\tconst deferredPromise = mockCancelablePromise();\n\n\t\texpect(() => {\n\t\t\tactiveExecutions.attachWorkflowExecution(FAKE_EXECUTION_ID, deferredPromise);\n\t\t}).toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should successfully attach execution to valid executionId","suites":["ActiveExecutions"],"updatePoint":{"line":70,"column":64},"line":70,"code":"\ttest('Should successfully attach execution to valid executionId', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tawait activeExecutions.add(newExecution, undefined, FAKE_EXECUTION_ID);\n\t\tconst deferredPromise = mockCancelablePromise();\n\n\t\texpect(() =>\n\t\t\tactiveExecutions.attachWorkflowExecution(FAKE_EXECUTION_ID, deferredPromise),\n\t\t).not.toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should attach and resolve response promise to existing execution","suites":["ActiveExecutions"],"updatePoint":{"line":80,"column":71},"line":80,"code":"\ttest('Should attach and resolve response promise to existing execution', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tawait activeExecutions.add(newExecution, undefined, FAKE_EXECUTION_ID);\n\t\tconst deferredPromise = await mockDeferredPromise();\n\t\tactiveExecutions.attachResponsePromise(FAKE_EXECUTION_ID, deferredPromise);\n\t\tconst fakeResponse = { data: { resultData: { runData: {} } } };\n\t\tactiveExecutions.resolveResponsePromise(FAKE_EXECUTION_ID, fakeResponse);\n\n\t\tawait expect(deferredPromise.promise()).resolves.toEqual(fakeResponse);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should remove an existing execution","suites":["ActiveExecutions"],"updatePoint":{"line":91,"column":42},"line":91,"code":"\ttest('Should remove an existing execution', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tactiveExecutions.remove(executionId);\n\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should resolve post execute promise on removal","suites":["ActiveExecutions"],"updatePoint":{"line":99,"column":53},"line":99,"code":"\ttest('Should resolve post execute promise on removal', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tconst postExecutePromise = activeExecutions.getPostExecutePromise(executionId);\n\t\t// Force the above to be executed since we cannot await it\n\t\tawait new Promise((res) => {\n\t\t\tsetTimeout(res, 100);\n\t\t});\n\t\tconst fakeOutput = mockFullRunData();\n\t\tactiveExecutions.remove(executionId, fakeOutput);\n\n\t\tawait expect(postExecutePromise).resolves.toEqual(fakeOutput);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error when trying to create a promise with invalid execution","suites":["ActiveExecutions"],"updatePoint":{"line":113,"column":80},"line":113,"code":"\ttest('Should throw error when trying to create a promise with invalid execution', async () => {\n\t\tawait expect(activeExecutions.getPostExecutePromise(FAKE_EXECUTION_ID)).rejects.toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call function to cancel execution when asked to stop","suites":["ActiveExecutions"],"updatePoint":{"line":117,"column":66},"line":117,"code":"\ttest('Should call function to cancel execution when asked to stop', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tconst cancelExecution = jest.fn();\n\t\tconst cancellablePromise = mockCancelablePromise();\n\t\tcancellablePromise.cancel = cancelExecution;\n\t\tactiveExecutions.attachWorkflowExecution(executionId, cancellablePromise);\n\t\tvoid activeExecutions.stopExecution(executionId);\n\n\t\texpect(cancelExecution).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should initialize activeWorkflowRunner with empty list of active workflows and call External Hooks","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":181,"column":105},"line":181,"code":"\ttest('Should initialize activeWorkflowRunner with empty list of active workflows and call External Hooks', async () => {\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.getActiveWorkflows()).toHaveLength(0);\n\t\texpect(mocked(Db.collections.Workflow.find)).toHaveBeenCalled();\n\t\texpect(webhookService.deleteInstanceWebhooks).toHaveBeenCalled();\n\t\texpect(externalHooks.run).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should initialize activeWorkflowRunner with one active workflow","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":189,"column":70},"line":189,"code":"\ttest('Should initialize activeWorkflowRunner with one active workflow', async () => {\n\t\tdatabaseActiveWorkflowsCount = 1;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.getActiveWorkflows()).toHaveLength(\n\t\t\tdatabaseActiveWorkflowsCount,\n\t\t);\n\t\texpect(mocked(Db.collections.Workflow.find)).toHaveBeenCalled();\n\t\texpect(webhookService.deleteInstanceWebhooks).toHaveBeenCalled();\n\t\texpect(externalHooks.run).toHaveBeenCalled();\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should make sure function checkIfWorkflowCanBeActivated was called for every workflow","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":200,"column":92},"line":200,"code":"\ttest('Should make sure function checkIfWorkflowCanBeActivated was called for every workflow', async () => {\n\t\tdatabaseActiveWorkflowsCount = 2;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(workflowCheckIfCanBeActivated).toHaveBeenCalledTimes(databaseActiveWorkflowsCount);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Call to removeAll should remove every workflow","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":206,"column":53},"line":206,"code":"\ttest('Call to removeAll should remove every workflow', async () => {\n\t\tdatabaseActiveWorkflowsCount = 2;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.getActiveWorkflows()).toHaveLength(\n\t\t\tdatabaseActiveWorkflowsCount,\n\t\t);\n\t\tawait activeWorkflowRunner.removeAll();\n\t\texpect(removeFunction).toHaveBeenCalledTimes(databaseActiveWorkflowsCount);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Call to remove should also call removeWorkflowWebhooks","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":216,"column":61},"line":216,"code":"\ttest('Call to remove should also call removeWorkflowWebhooks', async () => {\n\t\tdatabaseActiveWorkflowsCount = 1;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.getActiveWorkflows()).toHaveLength(\n\t\t\tdatabaseActiveWorkflowsCount,\n\t\t);\n\t\tawait activeWorkflowRunner.remove('1');\n\t\texpect(removeWebhooksFunction).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Call to isActive should return true for valid workflow","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":226,"column":61},"line":226,"code":"\ttest('Call to isActive should return true for valid workflow', async () => {\n\t\tdatabaseActiveWorkflowsCount = 1;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.isActive('1')).toBe(true);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Call to isActive should return false for invalid workflow","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":232,"column":64},"line":232,"code":"\ttest('Call to isActive should return false for invalid workflow', async () => {\n\t\tdatabaseActiveWorkflowsCount = 1;\n\t\tawait activeWorkflowRunner.init();\n\t\texpect(await activeWorkflowRunner.isActive('2')).toBe(false);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Calling add should call checkIfWorkflowCanBeActivated","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":238,"column":60},"line":238,"code":"\ttest('Calling add should call checkIfWorkflowCanBeActivated', async () => {\n\t\t// Initialize with default (0) workflows\n\t\tawait activeWorkflowRunner.init();\n\t\tgenerateWorkflows(1);\n\t\tawait activeWorkflowRunner.add('1', 'activate');\n\t\texpect(workflowCheckIfCanBeActivated).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"runWorkflow should call run method in WorkflowRunner","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":246,"column":59},"line":246,"code":"\ttest('runWorkflow should call run method in WorkflowRunner', async () => {\n\t\tawait activeWorkflowRunner.init();\n\t\tconst workflow = generateWorkflows(1);\n\t\tconst additionalData = await WorkflowExecuteAdditionalData.getBase('fake-user-id');\n\n\t\tworkflowRunnerRun.mockResolvedValueOnce('invalid-execution-id');\n\n\t\tawait activeWorkflowRunner.runWorkflow(\n\t\t\tworkflow[0],\n\t\t\tworkflow[0].nodes[0],\n\t\t\t[[]],\n\t\t\tadditionalData,\n\t\t\t'trigger',\n\t\t);\n\n\t\texpect(workflowRunnerRun).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"executeErrorWorkflow should call function with same name in WorkflowExecuteAdditionalData","suites":["ActiveWorkflowRunner"],"updatePoint":{"line":264,"column":96},"line":264,"code":"\ttest('executeErrorWorkflow should call function with same name in WorkflowExecuteAdditionalData', async () => {\n\t\tconst workflowData = generateWorkflows(1)[0];\n\t\tconst error = new NodeOperationError(workflowData.nodes[0], 'Fake error message');\n\t\tawait activeWorkflowRunner.init();\n\t\tactiveWorkflowRunner.executeErrorWorkflow(error, workflowData, 'trigger');\n\t\texpect(workflowExecuteAdditionalDataExecuteErrorWorkflowSpy).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should execute error workflow on failure to activate due to 401","suites":["ActiveWorkflowRunner","init()"],"updatePoint":{"line":273,"column":69},"line":273,"code":"\t\tit('should execute error workflow on failure to activate due to 401', async () => {\n\t\t\tdatabaseActiveWorkflowsCount = 1;\n\n\t\t\tjest.spyOn(ActiveWorkflowRunner.prototype, 'add').mockImplementation(() => {\n\t\t\t\tthrow new NodeApiError(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: 'a75dcd1b-9fed-4643-90bd-75933d67936c',\n\t\t\t\t\t\tname: 'Github Trigger',\n\t\t\t\t\t\ttype: 'n8n-nodes-base.githubTrigger',\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\t} as INode,\n\t\t\t\t\t{\n\t\t\t\t\t\thttpCode: '401',\n\t\t\t\t\t\tmessage: 'Authorization failed - please check your credentials',\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tconst executeSpy = jest.spyOn(ActiveWorkflowRunner.prototype, 'executeErrorWorkflow');\n\n\t\t\tawait activeWorkflowRunner.init();\n\n\t\t\tconst [error, workflow] = executeSpy.mock.calls[0];\n\n\t\t\texpect(error.message).toContain('Authorization');\n\t\t\texpect(workflow.id).toBe('1');\n\t\t});","file":"unit/ActiveWorkflowRunner.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail with empty package name","suites":["parsePackageName"],"updatePoint":{"line":34,"column":42},"line":34,"code":"\ttest('Should fail with empty package name', () => {\n\t\texpect(() => parseNpmPackageName('')).toThrowError();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail with invalid package prefix name","suites":["parsePackageName"],"updatePoint":{"line":38,"column":51},"line":38,"code":"\ttest('Should fail with invalid package prefix name', () => {\n\t\texpect(() => parseNpmPackageName('INVALID_PREFIX@123')).toThrowError();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name","suites":["parsePackageName"],"updatePoint":{"line":42,"column":38},"line":42,"code":"\ttest('Should parse valid package name', () => {\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst parsed = parseNpmPackageName(validPackageName);\n\n\t\texpect(parsed.rawString).toBe(validPackageName);\n\t\texpect(parsed.packageName).toBe(validPackageName);\n\t\texpect(parsed.scope).toBeUndefined();\n\t\texpect(parsed.version).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name and version","suites":["parsePackageName"],"updatePoint":{"line":52,"column":50},"line":52,"code":"\ttest('Should parse valid package name and version', () => {\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst validPackageVersion = '0.1.1';\n\t\tconst fullPackageName = `${validPackageName}@${validPackageVersion}`;\n\t\tconst parsed = parseNpmPackageName(fullPackageName);\n\n\t\texpect(parsed.rawString).toBe(fullPackageName);\n\t\texpect(parsed.packageName).toBe(validPackageName);\n\t\texpect(parsed.scope).toBeUndefined();\n\t\texpect(parsed.version).toBe(validPackageVersion);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name, scope and version","suites":["parsePackageName"],"updatePoint":{"line":64,"column":57},"line":64,"code":"\ttest('Should parse valid package name, scope and version', () => {\n\t\tconst validPackageScope = '@n8n';\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst validPackageVersion = '0.1.1';\n\t\tconst fullPackageName = `${validPackageScope}/${validPackageName}@${validPackageVersion}`;\n\t\tconst parsed = parseNpmPackageName(fullPackageName);\n\n\t\texpect(parsed.rawString).toBe(fullPackageName);\n\t\texpect(parsed.packageName).toBe(`${validPackageScope}/${validPackageName}`);\n\t\texpect(parsed.scope).toBe(validPackageScope);\n\t\texpect(parsed.version).toBe(validPackageVersion);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call command with valid options","suites":["executeCommand"],"updatePoint":{"line":88,"column":45},"line":88,"code":"\ttest('Should call command with valid options', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\texpect(args[1].cwd).toBeDefined();\n\t\t\texpect(args[1].env).toBeDefined();\n\t\t\t// PATH or NODE_PATH may be undefined depending on environment so we don't check for these keys.\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toBeCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should make sure folder exists","suites":["executeCommand"],"updatePoint":{"line":104,"column":37},"line":104,"code":"\ttest('Should make sure folder exists', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toBeCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should try to create folder if it does not exist","suites":["executeCommand"],"updatePoint":{"line":117,"column":55},"line":117,"code":"\ttest('Should try to create folder if it does not exist', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\t// @ts-ignore\n\t\tfsAccess.mockImplementation(() => {\n\t\t\tthrow new Error('Folder does not exist.');\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toHaveBeenCalled();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw especial error when package is not found","suites":["executeCommand"],"updatePoint":{"line":135,"column":60},"line":135,"code":"\ttest('Should throw especial error when package is not found', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(\n\t\t\t\tnew Error(\n\t\t\t\t\t'Something went wrong - ' +\n\t\t\t\t\t\tNPM_COMMAND_TOKENS.NPM_PACKAGE_NOT_FOUND_ERROR +\n\t\t\t\t\t\t'. Aborting.',\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\n\t\tawait expect(async () => executeCommand('ls')).rejects.toThrow(\n\t\t\tRESPONSE_ERROR_MESSAGES.PACKAGE_NOT_FOUND,\n\t\t);\n\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toHaveBeenCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return same list if availableUpdates is undefined","suites":["crossInformationPackage"],"updatePoint":{"line":159,"column":63},"line":159,"code":"\ttest('Should return same list if availableUpdates is undefined', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages);\n\t\texpect(crossedData).toEqual(fakePackages);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should correctly match update versions for packages","suites":["crossInformationPackage"],"updatePoint":{"line":165,"column":58},"line":165,"code":"\ttest('Should correctly match update versions for packages', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\n\t\tconst updates: CommunityPackages.AvailableUpdates = {\n\t\t\t[fakePackages[0].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.2.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t\t[fakePackages[1].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.3.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t};\n\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages, updates);\n\n\t\t// @ts-ignore\n\t\texpect(crossedData[0].updateAvailable).toBe('0.2.0');\n\t\t// @ts-ignore\n\t\texpect(crossedData[1].updateAvailable).toBe('0.3.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should correctly match update versions for single package","suites":["crossInformationPackage"],"updatePoint":{"line":191,"column":64},"line":191,"code":"\ttest('Should correctly match update versions for single package', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\n\t\tconst updates: CommunityPackages.AvailableUpdates = {\n\t\t\t[fakePackages[1].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.3.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t};\n\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages, updates);\n\n\t\t// @ts-ignore\n\t\texpect(crossedData[0].updateAvailable).toBeUndefined();\n\t\t// @ts-ignore\n\t\texpect(crossedData[1].updateAvailable).toBe('0.3.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not match failed packages that do not exist","suites":["matchMissingPackages"],"updatePoint":{"line":213,"column":57},"line":213,"code":"\ttest('Should not match failed packages that do not exist', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${NODE_PACKAGE_PREFIX}another-very-long-name-that-never-is-seen`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages).toEqual(fakePackages);\n\t\texpect(matchedPackages[0].failedLoading).toBeUndefined();\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should match failed packages that should be present","suites":["matchMissingPackages"],"updatePoint":{"line":223,"column":58},"line":223,"code":"\ttest('Should match failed packages that should be present', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${fakePackages[0].packageName}@${fakePackages[0].installedVersion}`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages[0].failedLoading).toBe(true);\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should match failed packages even if version is wrong","suites":["matchMissingPackages"],"updatePoint":{"line":232,"column":60},"line":232,"code":"\ttest('Should match failed packages even if version is wrong', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${fakePackages[0].packageName}@123.456.789`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages[0].failedLoading).toBe(true);\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call axios.post","suites":["checkNpmPackageStatus"],"updatePoint":{"line":243,"column":29},"line":243,"code":"\ttest('Should call axios.post', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\tawait checkNpmPackageStatus(packageName);\n\t\texpect(axios.post).toHaveBeenCalled();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not fail if request fails","suites":["checkNpmPackageStatus"],"updatePoint":{"line":249,"column":39},"line":249,"code":"\ttest('Should not fail if request fails', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\taxios.post = jest.fn(() => {\n\t\t\tthrow new Error('Something went wrong');\n\t\t});\n\t\tconst result = await checkNpmPackageStatus(packageName);\n\t\texpect(result.status).toBe(NPM_PACKAGE_STATUS_GOOD);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should warn if package is banned","suites":["checkNpmPackageStatus"],"updatePoint":{"line":258,"column":39},"line":258,"code":"\ttest('Should warn if package is banned', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\t// @ts-ignore\n\t\taxios.post = jest.fn(() => {\n\t\t\treturn { data: { status: 'Banned', reason: 'Not good' } };\n\t\t});\n\t\tconst result = await checkNpmPackageStatus(packageName);\n\t\texpect(result.status).toBe('Banned');\n\t\texpect(result.reason).toBe('Not good');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return true when failed package list does not exist","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":271,"column":65},"line":271,"code":"\ttest('Should return true when failed package list does not exist', () => {\n\t\tconfig.set('nodes.packagesMissing', undefined);\n\t\tconst result = hasPackageLoaded('package');\n\t\texpect(result).toBe(true);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return true when package is not in the list of missing packages","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":277,"column":77},"line":277,"code":"\ttest('Should return true when package is not in the list of missing packages', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packgeB@0.1.0');\n\t\tconst result = hasPackageLoaded('packageC');\n\t\texpect(result).toBe(true);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return false when package is in the list of missing packages","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":283,"column":74},"line":283,"code":"\ttest('Should return false when package is in the list of missing packages', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packgeB@0.1.0');\n\t\tconst result = hasPackageLoaded('packageA');\n\t\texpect(result).toBe(false);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should do nothing if key does not exist","suites":["removePackageFromMissingList"],"updatePoint":{"line":291,"column":46},"line":291,"code":"\ttest('Should do nothing if key does not exist', () => {\n\t\tconfig.set('nodes.packagesMissing', undefined);\n\n\t\tremovePackageFromMissingList('packageA');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should remove only correct package from list","suites":["removePackageFromMissingList"],"updatePoint":{"line":300,"column":51},"line":300,"code":"\ttest('Should remove only correct package from list', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packageB@0.2.0 packageBB@0.2.0');\n\n\t\tremovePackageFromMissingList('packageB');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBe('packageA@0.1.0 packageBB@0.2.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not remove if package is not in the list","suites":["removePackageFromMissingList"],"updatePoint":{"line":309,"column":54},"line":309,"code":"\ttest('Should not remove if package is not in the list', () => {\n\t\tconst failedToLoadList = 'packageA@0.1.0 packageB@0.2.0 packageBB@0.2.0';\n\t\tconfig.set('nodes.packagesMissing', failedToLoadList);\n\n\t\tremovePackageFromMissingList('packageC');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBe(failedToLoadList);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw BadRequestError if email is missing in the payload","suites":["MeController","updateCurrentUser"],"updatePoint":{"line":27,"column":69},"line":27,"code":"\t\tit('should throw BadRequestError if email is missing in the payload', async () => {\n\t\t\tconst req = mock<MeRequest.UserUpdate>({});\n\t\t\tawait expect(controller.updateCurrentUser(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Email is mandatory'),\n\t\t\t);\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw BadRequestError if email is invalid","suites":["MeController","updateCurrentUser"],"updatePoint":{"line":34,"column":54},"line":34,"code":"\t\tit('should throw BadRequestError if email is invalid', async () => {\n\t\t\tconst req = mock<MeRequest.UserUpdate>({ body: { email: 'invalid-email' } });\n\t\t\tawait expect(controller.updateCurrentUser(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Invalid email address'),\n\t\t\t);\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update the user in the DB, and issue a new cookie","suites":["MeController","updateCurrentUser"],"updatePoint":{"line":41,"column":62},"line":41,"code":"\t\tit('should update the user in the DB, and issue a new cookie', async () => {\n\t\t\tconst user = mock<User>({\n\t\t\t\tid: '123',\n\t\t\t\tpassword: 'password',\n\t\t\t\tauthIdentities: [],\n\t\t\t\tglobalRoleId: '1',\n\t\t\t});\n\t\t\tconst reqBody = { email: 'valid@email.com', firstName: 'John', lastName: 'Potato' };\n\t\t\tconst req = mock<MeRequest.UserUpdate>({ user, body: reqBody });\n\t\t\tconst res = mock<Response>();\n\t\t\tuserRepository.findOneOrFail.mockResolvedValue(user);\n\t\t\tjest.spyOn(jwt, 'sign').mockImplementation(() => 'signed-token');\n\n\t\t\tawait controller.updateCurrentUser(req, res);\n\n\t\t\texpect(userRepository.update).toHaveBeenCalled();\n\n\t\t\tconst cookieOptions = captor<CookieOptions>();\n\t\t\texpect(res.cookie).toHaveBeenCalledWith(AUTH_COOKIE_NAME, 'signed-token', cookieOptions);\n\t\t\texpect(cookieOptions.value.httpOnly).toBe(true);\n\t\t\texpect(cookieOptions.value.sameSite).toBe('lax');\n\n\t\t\texpect(externalHooks.run).toHaveBeenCalledWith('user.profile.update', [\n\t\t\t\tuser.email,\n\t\t\t\tanyObject(),\n\t\t\t]);\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not allow updating any other fields on a user besides email and name","suites":["MeController","updateCurrentUser"],"updatePoint":{"line":69,"column":81},"line":69,"code":"\t\tit('should not allow updating any other fields on a user besides email and name', async () => {\n\t\t\tconst user = mock<User>({\n\t\t\t\tid: '123',\n\t\t\t\tpassword: 'password',\n\t\t\t\tauthIdentities: [],\n\t\t\t\tglobalRoleId: '1',\n\t\t\t});\n\t\t\tconst reqBody = { email: 'valid@email.com', firstName: 'John', lastName: 'Potato' };\n\t\t\tconst req = mock<MeRequest.UserUpdate>({ user, body: reqBody });\n\t\t\tconst res = mock<Response>();\n\t\t\tuserRepository.findOneOrFail.mockResolvedValue(user);\n\t\t\tjest.spyOn(jwt, 'sign').mockImplementation(() => 'signed-token');\n\n\t\t\t// Add invalid data to the request payload\n\t\t\tObject.assign(reqBody, { id: '0', globalRoleId: '42' });\n\n\t\t\tawait controller.updateCurrentUser(req, res);\n\n\t\t\texpect(userRepository.update).toHaveBeenCalled();\n\n\t\t\tconst updatedUser = userRepository.update.mock.calls[0][1];\n\t\t\texpect(updatedUser.email).toBe(reqBody.email);\n\t\t\texpect(updatedUser.firstName).toBe(reqBody.firstName);\n\t\t\texpect(updatedUser.lastName).toBe(reqBody.lastName);\n\t\t\texpect(updatedUser.id).not.toBe('0');\n\t\t\texpect(updatedUser.globalRoleId).not.toBe('42');\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw if the user does not have a password set","suites":["MeController","updatePassword"],"updatePoint":{"line":101,"column":59},"line":101,"code":"\t\tit('should throw if the user does not have a password set', async () => {\n\t\t\tconst req = mock<MeRequest.Password>({\n\t\t\t\tuser: mock({ password: undefined }),\n\t\t\t\tbody: { currentPassword: '', newPassword: '' },\n\t\t\t});\n\t\t\tawait expect(controller.updatePassword(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Requesting user not set up.'),\n\t\t\t);\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw if currentPassword does not match the user's password","suites":["MeController","updatePassword"],"updatePoint":{"line":111,"column":72},"line":111,"code":"\t\tit(\"should throw if currentPassword does not match the user's password\", async () => {\n\t\t\tconst req = mock<MeRequest.Password>({\n\t\t\t\tuser: mock({ password: passwordHash }),\n\t\t\t\tbody: { currentPassword: 'not_old_password', newPassword: '' },\n\t\t\t});\n\t\t\tawait expect(controller.updatePassword(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Provided current password is incorrect.'),\n\t\t\t);\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should update the password in the DB, and issue a new cookie","suites":["MeController","updatePassword","should throw if newPassword is not valid"],"updatePoint":{"line":135,"column":66},"line":135,"code":"\t\tit('should update the password in the DB, and issue a new cookie', async () => {\n\t\t\tconst req = mock<MeRequest.Password>({\n\t\t\t\tuser: mock({ password: passwordHash }),\n\t\t\t\tbody: { currentPassword: 'old_password', newPassword: 'NewPassword123' },\n\t\t\t});\n\t\t\tconst res = mock<Response>();\n\t\t\tuserRepository.save.calledWith(req.user).mockResolvedValue(req.user);\n\t\t\tjest.spyOn(jwt, 'sign').mockImplementation(() => 'new-signed-token');\n\n\t\t\tawait controller.updatePassword(req, res);\n\n\t\t\texpect(req.user.password).not.toBe(passwordHash);\n\n\t\t\tconst cookieOptions = captor<CookieOptions>();\n\t\t\texpect(res.cookie).toHaveBeenCalledWith(AUTH_COOKIE_NAME, 'new-signed-token', cookieOptions);\n\t\t\texpect(cookieOptions.value.httpOnly).toBe(true);\n\t\t\texpect(cookieOptions.value.sameSite).toBe('lax');\n\n\t\t\texpect(externalHooks.run).toHaveBeenCalledWith('user.password.update', [\n\t\t\t\treq.user.email,\n\t\t\t\treq.user.password,\n\t\t\t]);\n\n\t\t\texpect(internalHooks.onUserUpdate).toHaveBeenCalledWith({\n\t\t\t\tuser: req.user,\n\t\t\t\tfields_changed: ['password'],\n\t\t\t});\n\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create and save an API key","suites":["MeController","API Key methods","createAPIKey"],"updatePoint":{"line":172,"column":40},"line":172,"code":"\t\t\tit('should create and save an API key', async () => {\n\t\t\t\tconst { apiKey } = await controller.createAPIKey(req);\n\t\t\t\texpect(userRepository.update).toHaveBeenCalledWith(req.user.id, { apiKey });\n\t\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return the users api key","suites":["MeController","API Key methods","getAPIKey"],"updatePoint":{"line":179,"column":38},"line":179,"code":"\t\t\tit('should return the users api key', async () => {\n\t\t\t\tconst { apiKey } = await controller.getAPIKey(req);\n\t\t\t\texpect(apiKey).toEqual(req.user.apiKey);\n\t\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete the API key","suites":["MeController","API Key methods","deleteAPIKey"],"updatePoint":{"line":186,"column":32},"line":186,"code":"\t\t\tit('should delete the API key', async () => {\n\t\t\t\tawait controller.deleteAPIKey(req);\n\t\t\t\texpect(userRepository.update).toHaveBeenCalledWith(req.user.id, { apiKey: null });\n\t\t\t});","file":"unit/controllers/me.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw a BadRequestError if the instance owner is already setup","suites":["OwnerController","setupOwner"],"updatePoint":{"line":32,"column":75},"line":32,"code":"\t\tit('should throw a BadRequestError if the instance owner is already setup', async () => {\n\t\t\tconfig.getEnv.calledWith('userManagement.isInstanceOwnerSetUp').mockReturnValue(true);\n\t\t\tawait expect(controller.setupOwner(mock(), mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Instance owner already setup'),\n\t\t\t);\n\t\t});","file":"unit/controllers/owner.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw a BadRequestError if the email is invalid","suites":["OwnerController","setupOwner"],"updatePoint":{"line":39,"column":60},"line":39,"code":"\t\tit('should throw a BadRequestError if the email is invalid', async () => {\n\t\t\tconfig.getEnv.calledWith('userManagement.isInstanceOwnerSetUp').mockReturnValue(false);\n\t\t\tconst req = mock<OwnerRequest.Post>({ body: { email: 'invalid email' } });\n\t\t\tawait expect(controller.setupOwner(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('Invalid email address'),\n\t\t\t);\n\t\t});","file":"unit/controllers/owner.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw a BadRequestError if firstName & lastName are missing ","suites":["OwnerController","setupOwner","should throw if the password is invalid"],"updatePoint":{"line":59,"column":73},"line":59,"code":"\t\tit('should throw a BadRequestError if firstName & lastName are missing ', async () => {\n\t\t\tconfig.getEnv.calledWith('userManagement.isInstanceOwnerSetUp').mockReturnValue(false);\n\t\t\tconst req = mock<OwnerRequest.Post>({\n\t\t\t\tbody: { email: 'valid@email.com', password: 'NewPassword123', firstName: '', lastName: '' },\n\t\t\t});\n\t\t\tawait expect(controller.setupOwner(req, mock())).rejects.toThrowError(\n\t\t\t\tnew BadRequestError('First and last names are mandatory'),\n\t\t\t);\n\t\t});","file":"unit/controllers/owner.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should setup the instance owner successfully","suites":["OwnerController","setupOwner","should throw if the password is invalid"],"updatePoint":{"line":69,"column":50},"line":69,"code":"\t\tit('should setup the instance owner successfully', async () => {\n\t\t\tconst user = mock<User>({\n\t\t\t\tid: 'userId',\n\t\t\t\tglobalRole: { scope: 'global', name: 'owner' },\n\t\t\t\tauthIdentities: [],\n\t\t\t});\n\t\t\tconst req = mock<OwnerRequest.Post>({\n\t\t\t\tbody: {\n\t\t\t\t\temail: 'valid@email.com',\n\t\t\t\t\tpassword: 'NewPassword123',\n\t\t\t\t\tfirstName: 'Jane',\n\t\t\t\t\tlastName: 'Doe',\n\t\t\t\t},\n\t\t\t\tuser,\n\t\t\t});\n\t\t\tconst res = mock<Response>();\n\t\t\tconfig.getEnv.calledWith('userManagement.isInstanceOwnerSetUp').mockReturnValue(false);\n\t\t\tuserRepository.save.calledWith(anyObject()).mockResolvedValue(user);\n\t\t\tjest.spyOn(jwt, 'sign').mockImplementation(() => 'signed-token');\n\n\t\t\tawait controller.setupOwner(req, res);\n\n\t\t\texpect(userRepository.save).toHaveBeenCalledWith(user);\n\n\t\t\tconst cookieOptions = captor<CookieOptions>();\n\t\t\texpect(res.cookie).toHaveBeenCalledWith(AUTH_COOKIE_NAME, 'signed-token', cookieOptions);\n\t\t\texpect(cookieOptions.value.httpOnly).toBe(true);\n\t\t\texpect(cookieOptions.value.sameSite).toBe('lax');\n\t\t});","file":"unit/controllers/owner.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw 400 on invalid credential types","suites":["TranslationController","getCredentialTranslation"],"updatePoint":{"line":17,"column":50},"line":17,"code":"\t\tit('should throw 400 on invalid credential types', async () => {\n\t\t\tconst credentialType = 'not-a-valid-credential-type';\n\t\t\tconst req = mock<TranslationRequest.Credential>({ query: { credentialType } });\n\t\t\tcredentialTypes.recognizes.calledWith(credentialType).mockReturnValue(false);\n\n\t\t\tawait expect(controller.getCredentialTranslation(req)).rejects.toThrowError(\n\t\t\t\tnew BadRequestError(`Invalid Credential type: \"${credentialType}\"`),\n\t\t\t);\n\t\t});","file":"unit/controllers/translation.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return translation json on valid credential types","suites":["TranslationController","getCredentialTranslation"],"updatePoint":{"line":27,"column":62},"line":27,"code":"\t\tit('should return translation json on valid credential types', async () => {\n\t\t\tconst credentialType = 'credential-type';\n\t\t\tconst req = mock<TranslationRequest.Credential>({ query: { credentialType } });\n\t\t\tconfig.getEnv.calledWith('defaultLocale').mockReturnValue('de');\n\t\t\tcredentialTypes.recognizes.calledWith(credentialType).mockReturnValue(true);\n\t\t\tconst response = { translation: 'string' };\n\t\t\tjest.mock(`${CREDENTIAL_TRANSLATIONS_DIR}/de/credential-type.json`, () => response, {\n\t\t\t\tvirtual: true,\n\t\t\t});\n\n\t\t\texpect(await controller.getCredentialTranslation(req)).toEqual(response);\n\t\t});","file":"unit/controllers/translation.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error when calling invalid credential name","suites":["CredentialTypes"],"updatePoint":{"line":37,"column":62},"line":37,"code":"\ttest('Should throw error when calling invalid credential name', () => {\n\t\texpect(() => credentialTypes.getByName('fakeThirdCredential')).toThrowError();\n\t});","file":"unit/CredentialTypes.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return correct credential type for valid name","suites":["CredentialTypes"],"updatePoint":{"line":41,"column":59},"line":41,"code":"\ttest('Should return correct credential type for valid name', () => {\n\t\tconst mockedCredentialTypes = mockNodesAndCredentials.loaded.credentials;\n\t\texpect(credentialTypes.getByName('fakeFirstCredential')).toStrictEqual(\n\t\t\tmockedCredentialTypes.fakeFirstCredential.type,\n\t\t);\n\t});","file":"unit/CredentialTypes.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse form-urlencoded content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":4,"column":58},"line":4,"code":"\ttest('Should parse form-urlencoded content type correctly', () => {\n\t\tconst curl =\n\t\t\t'curl -X POST https://reqbin.com/echo/post/form -H \"Content-Type: application/x-www-form-urlencoded\" -d \"param1=value1&param2=value2\"';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/form');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('param1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('param2');\n\t\texpect(parameters.bodyParameters?.parameters[1].value).toBe('value2');\n\t\texpect(parameters.contentType).toBe('form-urlencoded');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse JSON content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":19,"column":47},"line":19,"code":"\ttest('Should parse JSON content type correctly', () => {\n\t\tconst curl =\n\t\t\t'curl -X POST https://reqbin.com/echo/post/json -H \\'Content-Type: application/json\\' -d \\'{\"login\":\"my_login\",\"password\":\"my_password\"}\\'';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('login');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('my_login');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('password');\n\t\texpect(parameters.bodyParameters?.parameters[1].value).toBe('my_password');\n\t\texpect(parameters.contentType).toBe('json');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse multipart-form-data content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":34,"column":62},"line":34,"code":"\ttest('Should parse multipart-form-data content type correctly', () => {\n\t\tconst curl =\n\t\t\t'curl -X POST https://reqbin.com/echo/post/json -v -F key1=value1 -F upload=@localfilename';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].parameterType).toBe('formData');\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('key1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].parameterType).toBe('formBinaryData');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('upload');\n\t\texpect(parameters.contentType).toBe('multipart-form-data');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse binary request correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":50,"column":44},"line":50,"code":"\ttest('Should parse binary request correctly', () => {\n\t\tconst curl =\n\t\t\t\"curl --location --request POST 'https://www.website.com' --header 'Content-Type: image/png' --data-binary '@/Users/image.png\";\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://www.website.com');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.contentType).toBe('binaryData');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse unknown content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":62,"column":50},"line":62,"code":"\ttest('Should parse unknown content type correctly', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo/post/xml\n\t\t-H \"Content-Type: application/xml\"\n\t\t-H \"Accept: application/xml\"\n\t\t-d \"<Request><Login>my_login</Login><Password>my_password</Password></Request>\"`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/xml');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.contentType).toBe('raw');\n\t\texpect(parameters.rawContentType).toBe('application/xml');\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('Accept');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe('application/xml');\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse header properties and keep the original case","suites":["CurlConverterHelper"],"updatePoint":{"line":79,"column":64},"line":79,"code":"\ttest('Should parse header properties and keep the original case', () => {\n\t\tconst curl =\n\t\t\t'curl -X POST https://reqbin.com/echo/post/json -v -F key1=value1 -F upload=@localfilename -H \"ACCEPT: text/javascript\" -H \"content-type: multipart/form-data\"';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].parameterType).toBe('formData');\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('key1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].parameterType).toBe('formBinaryData');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('upload');\n\t\texpect(parameters.contentType).toBe('multipart-form-data');\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('ACCEPT');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe('text/javascript');\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse querystring properties","suites":["CurlConverterHelper"],"updatePoint":{"line":97,"column":42},"line":97,"code":"\ttest('Should parse querystring properties', () => {\n\t\tconst curl = \"curl -G -d 'q=kitties' -d 'count=20' https://google.com/search\";\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://google.com/search');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(true);\n\t\texpect(parameters.queryParameters?.parameters[0].name).toBe('q');\n\t\texpect(parameters.queryParameters?.parameters[0].value).toBe('kitties');\n\t\texpect(parameters.queryParameters?.parameters[1].name).toBe('count');\n\t\texpect(parameters.queryParameters?.parameters[1].value).toBe('20');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse basic authentication property and keep the original case","suites":["CurlConverterHelper"],"updatePoint":{"line":111,"column":76},"line":111,"code":"\ttest('Should parse basic authentication property and keep the original case', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\"';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location flag with --location","suites":["CurlConverterHelper"],"updatePoint":{"line":125,"column":49},"line":125,"code":"\ttest('Should parse location flag with --location', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" --location';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location flag with --L","suites":["CurlConverterHelper"],"updatePoint":{"line":140,"column":42},"line":140,"code":"\ttest('Should parse location flag with --L', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" -L';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location and max redirects flags with --location and --max-redirs 10","suites":["CurlConverterHelper"],"updatePoint":{"line":155,"column":88},"line":155,"code":"\ttest('Should parse location and max redirects flags with --location and --max-redirs 10', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" --location --max-redirs 10';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t\texpect(parameters.options.redirect.redirect.maxRedirects).toBe('10');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse proxy flag -x","suites":["CurlConverterHelper"],"updatePoint":{"line":171,"column":33},"line":171,"code":"\ttest('Should parse proxy flag -x', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" -x https://google.com';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.proxy).toBe('https://google.com');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse proxy flag --proxy","suites":["CurlConverterHelper"],"updatePoint":{"line":186,"column":38},"line":186,"code":"\ttest('Should parse proxy flag --proxy', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" -x https://google.com';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.proxy).toBe('https://google.com');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include headers on output flag --include","suites":["CurlConverterHelper"],"updatePoint":{"line":201,"column":60},"line":201,"code":"\ttest('Should parse include headers on output flag --include', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" --include -x https://google.com';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.response.response.fullResponse).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include headers on output flag -i","suites":["CurlConverterHelper"],"updatePoint":{"line":216,"column":53},"line":216,"code":"\ttest('Should parse include headers on output flag -i', () => {\n\t\tconst curl = 'curl https://reqbin.com/echo -u \"login:password\" -x https://google.com -i';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.response.response.fullResponse).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include request flag -X","suites":["CurlConverterHelper"],"updatePoint":{"line":231,"column":43},"line":231,"code":"\ttest('Should parse include request flag -X', () => {\n\t\tconst curl = 'curl -X POST https://reqbin.com/echo -u \"login:password\" -x https://google.com';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include request flag --request","suites":["CurlConverterHelper"],"updatePoint":{"line":239,"column":50},"line":239,"code":"\ttest('Should parse include request flag --request', () => {\n\t\tconst curl =\n\t\t\t'curl --request POST https://reqbin.com/echo -u \"login:password\" -x https://google.com';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include timeout flag --connect-timeout","suites":["CurlConverterHelper"],"updatePoint":{"line":248,"column":58},"line":248,"code":"\ttest('Should parse include timeout flag --connect-timeout', () => {\n\t\tconst curl =\n\t\t\t'curl --request POST https://reqbin.com/echo -u \"login:password\" --connect-timeout 20';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.timeout).toBe(20000);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse download file flag -O","suites":["CurlConverterHelper"],"updatePoint":{"line":258,"column":41},"line":258,"code":"\ttest('Should parse download file flag -O', () => {\n\t\tconst curl = 'curl --request POST https://reqbin.com/echo -u \"login:password\" -O';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.response.response.responseFormat).toBe('file');\n\t\texpect(parameters.options.response.response.outputPropertyName).toBe('data');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse download file flag -o","suites":["CurlConverterHelper"],"updatePoint":{"line":268,"column":41},"line":268,"code":"\ttest('Should parse download file flag -o', () => {\n\t\tconst curl = 'curl --request POST https://reqbin.com/echo -u \"login:password\" -o';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.response.response.responseFormat).toBe('file');\n\t\texpect(parameters.options.response.response.outputPropertyName).toBe('data');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse ignore SSL flag -k","suites":["CurlConverterHelper"],"updatePoint":{"line":278,"column":38},"line":278,"code":"\ttest('Should parse ignore SSL flag -k', () => {\n\t\tconst curl = 'curl --request POST https://reqbin.com/echo -u \"login:password\" -k';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.allowUnauthorizedCerts).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse ignore SSL flag --insecure","suites":["CurlConverterHelper"],"updatePoint":{"line":287,"column":46},"line":287,"code":"\ttest('Should parse ignore SSL flag --insecure', () => {\n\t\tconst curl = 'curl --request POST https://reqbin.com/echo -u \"login:password\" --insecure';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.allowUnauthorizedCerts).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"initializes license manager","suites":["License"],"updatePoint":{"line":29,"column":34},"line":29,"code":"\ttest('initializes license manager', async () => {\n\t\texpect(LicenseManager).toHaveBeenCalledWith({\n\t\t\tautoRenewEnabled: true,\n\t\t\tautoRenewOffset: MOCK_RENEW_OFFSET,\n\t\t\tdeviceFingerprint: expect.any(Function),\n\t\t\tproductIdentifier: `n8n-${N8N_VERSION}`,\n\t\t\tlogger: expect.anything(),\n\t\t\tloadCertStr: expect.any(Function),\n\t\t\tsaveCertStr: expect.any(Function),\n\t\t\tserver: MOCK_SERVER_URL,\n\t\t\ttenantId: 1,\n\t\t});\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"attempts to activate license with provided key","suites":["License"],"updatePoint":{"line":43,"column":53},"line":43,"code":"\ttest('attempts to activate license with provided key', async () => {\n\t\tawait license.activate(MOCK_ACTIVATION_KEY);\n\n\t\texpect(LicenseManager.prototype.activate).toHaveBeenCalledWith(MOCK_ACTIVATION_KEY);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"renews license","suites":["License"],"updatePoint":{"line":49,"column":21},"line":49,"code":"\ttest('renews license', async () => {\n\t\tawait license.renew();\n\n\t\texpect(LicenseManager.prototype.renew).toHaveBeenCalled();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check if feature is enabled","suites":["License"],"updatePoint":{"line":55,"column":34},"line":55,"code":"\ttest('check if feature is enabled', async () => {\n\t\tawait license.isFeatureEnabled(MOCK_FEATURE_FLAG);\n\n\t\texpect(LicenseManager.prototype.hasFeatureEnabled).toHaveBeenCalledWith(MOCK_FEATURE_FLAG);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check if sharing feature is enabled","suites":["License"],"updatePoint":{"line":61,"column":42},"line":61,"code":"\ttest('check if sharing feature is enabled', async () => {\n\t\tawait license.isFeatureEnabled(MOCK_FEATURE_FLAG);\n\n\t\texpect(LicenseManager.prototype.hasFeatureEnabled).toHaveBeenCalledWith(MOCK_FEATURE_FLAG);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check fetching entitlements","suites":["License"],"updatePoint":{"line":67,"column":34},"line":67,"code":"\ttest('check fetching entitlements', async () => {\n\t\tawait license.getCurrentEntitlements();\n\n\t\texpect(LicenseManager.prototype.getCurrentEntitlements).toHaveBeenCalled();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check fetching feature values","suites":["License"],"updatePoint":{"line":73,"column":36},"line":73,"code":"\ttest('check fetching feature values', async () => {\n\t\tlicense.getFeatureValue(MOCK_FEATURE_FLAG);\n\n\t\texpect(LicenseManager.prototype.getFeatureValue).toHaveBeenCalledWith(MOCK_FEATURE_FLAG);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check management jwt","suites":["License"],"updatePoint":{"line":79,"column":27},"line":79,"code":"\ttest('check management jwt', async () => {\n\t\tawait license.getManagementJwt();\n\n\t\texpect(LicenseManager.prototype.getManagementJwt).toHaveBeenCalled();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"getMainPlan() returns the right entitlement","suites":["License"],"updatePoint":{"line":85,"column":50},"line":85,"code":"\ttest('getMainPlan() returns the right entitlement', async () => {\n\t\t// mock entitlements response\n\t\tLicense.prototype.getCurrentEntitlements = jest.fn().mockReturnValue([\n\t\t\t{\n\t\t\t\tid: '84a9c852-1349-478d-9ad1-b3f55510e477',\n\t\t\t\tproductId: '670650f2-72d8-4397-898c-c249906e2cc2',\n\t\t\t\tproductMetadata: {},\n\t\t\t\tfeatures: {},\n\t\t\t\tfeatureOverrides: {},\n\t\t\t\tvalidFrom: new Date(),\n\t\t\t\tvalidTo: new Date(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: MOCK_MAIN_PLAN_ID,\n\t\t\t\tproductId: '670650f2-72d8-4397-898c-c249906e2cc2',\n\t\t\t\tproductMetadata: {\n\t\t\t\t\tterms: {\n\t\t\t\t\t\tisMainPlan: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tfeatures: {},\n\t\t\t\tfeatureOverrides: {},\n\t\t\t\tvalidFrom: new Date(),\n\t\t\t\tvalidTo: new Date(),\n\t\t\t},\n\t\t]);\n\t\tjest.fn(license.getMainPlan).mockReset();\n\n\t\tconst mainPlan = license.getMainPlan();\n\t\texpect(mainPlan?.id).toBe(MOCK_MAIN_PLAN_ID);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"getMainPlan() returns undefined if there is no main plan","suites":["License"],"updatePoint":{"line":117,"column":63},"line":117,"code":"\ttest('getMainPlan() returns undefined if there is no main plan', async () => {\n\t\t// mock entitlements response\n\t\tLicense.prototype.getCurrentEntitlements = jest.fn().mockReturnValue([\n\t\t\t{\n\t\t\t\tid: '84a9c852-1349-478d-9ad1-b3f55510e477',\n\t\t\t\tproductId: '670650f2-72d8-4397-898c-c249906e2cc2',\n\t\t\t\tproductMetadata: {}, // has no `productMetadata.terms.isMainPlan`!\n\t\t\t\tfeatures: {},\n\t\t\t\tfeatureOverrides: {},\n\t\t\t\tvalidFrom: new Date(),\n\t\t\t\tvalidTo: new Date(),\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'c1aae471-c24e-4874-ad88-b97107de486c',\n\t\t\t\tproductId: '670650f2-72d8-4397-898c-c249906e2cc2',\n\t\t\t\tproductMetadata: {}, // has no `productMetadata.terms.isMainPlan`!\n\t\t\t\tfeatures: {},\n\t\t\t\tfeatureOverrides: {},\n\t\t\t\tvalidFrom: new Date(),\n\t\t\t\tvalidTo: new Date(),\n\t\t\t},\n\t\t]);\n\t\tjest.fn(license.getMainPlan).mockReset();\n\n\t\tconst mainPlan = license.getMainPlan();\n\t\texpect(mainPlan).toBeUndefined();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse valid filter","suites":["List query middleware","Query filter"],"updatePoint":{"line":23,"column":33},"line":23,"code":"\t\ttest('should parse valid filter', () => {\n\t\t\tmockReq.query = { filter: '{ \"name\": \"My Workflow\" }' };\n\t\t\tfilterListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ filter: { name: 'My Workflow' } });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore invalid filter","suites":["List query middleware","Query filter"],"updatePoint":{"line":31,"column":36},"line":31,"code":"\t\ttest('should ignore invalid filter', () => {\n\t\t\tmockReq.query = { filter: '{ \"name\": \"My Workflow\", \"foo\": \"bar\" }' };\n\t\t\tfilterListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ filter: { name: 'My Workflow' } });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw on invalid JSON","suites":["List query middleware","Query filter"],"updatePoint":{"line":39,"column":36},"line":39,"code":"\t\ttest('should throw on invalid JSON', () => {\n\t\t\tmockReq.query = { filter: '{ \"name\" : \"My Workflow\"' };\n\t\t\tconst call = () => filterListQueryMiddleware(...args);\n\n\t\t\texpect(call).toThrowError('Failed to parse filter JSON');\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse valid select","suites":["List query middleware","Query select"],"updatePoint":{"line":48,"column":33},"line":48,"code":"\t\ttest('should parse valid select', () => {\n\t\t\tmockReq.query = { select: '[\"name\", \"id\"]' };\n\t\t\tselectListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ select: { name: true, id: true } });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"ignore invalid select","suites":["List query middleware","Query select"],"updatePoint":{"line":56,"column":29},"line":56,"code":"\t\ttest('ignore invalid select', () => {\n\t\t\tmockReq.query = { select: '[\"name\", \"foo\"]' };\n\t\t\tselectListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ select: { name: true } });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"throw on invalid JSON","suites":["List query middleware","Query select"],"updatePoint":{"line":64,"column":29},"line":64,"code":"\t\ttest('throw on invalid JSON', () => {\n\t\t\tmockReq.query = { select: '[\"name\"' };\n\t\t\tconst call = () => selectListQueryMiddleware(...args);\n\n\t\t\texpect(call).toThrowError('Failed to parse select JSON');\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"throw on non-string-array JSON for select","suites":["List query middleware","Query select"],"updatePoint":{"line":71,"column":49},"line":71,"code":"\t\ttest('throw on non-string-array JSON for select', () => {\n\t\t\tmockReq.query = { select: '\"name\"' };\n\t\t\tconst call = () => selectListQueryMiddleware(...args);\n\n\t\t\texpect(call).toThrowError('Parsed select is not a string array');\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse valid pagination","suites":["List query middleware","Query pagination"],"updatePoint":{"line":80,"column":37},"line":80,"code":"\t\ttest('should parse valid pagination', () => {\n\t\t\tmockReq.query = { skip: '1', take: '2' };\n\t\t\tpaginationListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ skip: 1, take: 2 });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore skip without take","suites":["List query middleware","Query pagination"],"updatePoint":{"line":88,"column":39},"line":88,"code":"\t\ttest('should ignore skip without take', () => {\n\t\t\tmockReq.query = { skip: '1' };\n\t\t\tpaginationListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toBeUndefined();\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should default skip to 0","suites":["List query middleware","Query pagination"],"updatePoint":{"line":96,"column":32},"line":96,"code":"\t\ttest('should default skip to 0', () => {\n\t\t\tmockReq.query = { take: '2' };\n\t\t\tpaginationListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ skip: 0, take: 2 });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should cap take at 50","suites":["List query middleware","Query pagination"],"updatePoint":{"line":104,"column":29},"line":104,"code":"\t\ttest('should cap take at 50', () => {\n\t\t\tmockReq.query = { take: '51' };\n\t\t\tpaginationListQueryMiddleware(...args);\n\n\t\t\texpect(mockReq.listQueryOptions).toEqual({ skip: 0, take: 50 });\n\t\t\texpect(nextFn).toBeCalledTimes(1);\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw on non-numeric-integer take","suites":["List query middleware","Query pagination"],"updatePoint":{"line":112,"column":48},"line":112,"code":"\t\ttest('should throw on non-numeric-integer take', () => {\n\t\t\tmockReq.query = { take: '3.2' };\n\t\t\tconst call = () => paginationListQueryMiddleware(...args);\n\n\t\t\texpect(call).toThrowError('Parameter take or skip is not an integer string');\n\t\t});","file":"unit/middleware/listQuery.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if workflow has no creds","suites":["PermissionChecker.check()"],"updatePoint":{"line":63,"column":44},"line":63,"code":"\ttest('should allow if workflow has no creds', async () => {\n\t\tconst userId = uuid();\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(async () => PermissionChecker.check(workflow, userId)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if requesting user is instance owner","suites":["PermissionChecker.check()"],"updatePoint":{"line":87,"column":56},"line":87,"code":"\ttest('should allow if requesting user is instance owner', async () => {\n\t\tconst owner = await testDb.createOwner();\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: randomPositiveDigit().toString(),\n\t\t\t\t\t\t\tname: 'Action Network Account',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(async () => PermissionChecker.check(workflow, owner.id)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if workflow creds are valid subset","suites":["PermissionChecker.check()"],"updatePoint":{"line":117,"column":54},"line":117,"code":"\ttest('should allow if workflow creds are valid subset', async () => {\n\t\tconst [owner, member] = await Promise.all([testDb.createOwner(), testDb.createUser()]);\n\n\t\tconst ownerCred = await saveCredential(randomCred(), { user: owner });\n\t\tconst memberCred = await saveCredential(randomCred(), { user: member });\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: ownerCred.id,\n\t\t\t\t\t\t\tname: ownerCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network 2',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: memberCred.id,\n\t\t\t\t\t\t\tname: memberCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(async () => PermissionChecker.check(workflow, owner.id)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deny if workflow creds are not valid subset","suites":["PermissionChecker.check()"],"updatePoint":{"line":164,"column":57},"line":164,"code":"\ttest('should deny if workflow creds are not valid subset', async () => {\n\t\tconst member = await testDb.createUser();\n\n\t\tconst memberCred = await saveCredential(randomCred(), { user: member });\n\n\t\tconst workflowDetails = {\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: memberCred.id,\n\t\t\t\t\t\t\tname: memberCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network 2',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: 'non-existing-credential-id',\n\t\t\t\t\t\t\tname: 'Non-existing credential name',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst workflowEntity = await Db.collections.Workflow.save(workflowDetails);\n\n\t\tawait Db.collections.SharedWorkflow.save({\n\t\t\tworkflow: workflowEntity,\n\t\t\tuser: member,\n\t\t\trole: workflowOwnerRole,\n\t\t});\n\n\t\tconst workflow = new Workflow(workflowDetails);\n\n\t\tawait expect(PermissionChecker.check(workflow, member.id)).rejects.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"sets default policy from environment when subworkflow has none","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":237,"column":69},"line":237,"code":"\ttest('sets default policy from environment when subworkflow has none', async () => {\n\t\tconfig.set('workflows.callerPolicyDefaultOption', 'none');\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => {\n\t\t\t\treturn fakeUser;\n\t\t\t});\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(true);\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId),\n\t\t).rejects.toThrow(`Target workflow ID ${subworkflow.id} may not be called`);\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"if sharing is disabled, ensures that workflows are owner by same user","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":258,"column":76},"line":258,"code":"\ttest('if sharing is disabled, ensures that workflows are owner by same user', async () => {\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => fakeUser);\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(false);\n\t\tjest.spyOn(UserService, 'get').mockImplementation(async () => fakeUser);\n\t\tjest.spyOn(WorkflowsService, 'getSharing').mockImplementation(async () => {\n\t\t\treturn sharedWorkflowNotOwner;\n\t\t});\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId),\n\t\t).rejects.toThrow(`Target workflow ID ${subworkflow.id} may not be called`);\n\n\t\t// Check description\n\t\ttry {\n\t\t\tawait PermissionChecker.checkSubworkflowExecutePolicy(subworkflow, '', 'abcde');\n\t\t} catch (error) {\n\t\t\tif (error instanceof SubworkflowOperationError) {\n\t\t\t\texpect(error.description).toBe(\n\t\t\t\t\t`${fakeUser.firstName} (${fakeUser.email}) can make this change. You may need to tell them the ID of this workflow, which is ${subworkflow.id}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"list of ids must include the parent workflow id","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":291,"column":54},"line":291,"code":"\ttest('list of ids must include the parent workflow id', async () => {\n\t\tconst invalidParentWorkflowId = uuid();\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => fakeUser);\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(true);\n\t\tjest.spyOn(UserService, 'get').mockImplementation(async () => fakeUser);\n\t\tjest.spyOn(WorkflowsService, 'getSharing').mockImplementation(async () => {\n\t\t\treturn sharedWorkflowNotOwner;\n\t\t});\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t\tsettings: {\n\t\t\t\tcallerPolicy: 'workflowsFromAList',\n\t\t\t\tcallerIds: '123,456,bcdef  ',\n\t\t\t},\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId, invalidParentWorkflowId),\n\t\t).rejects.toThrow(`Target workflow ID ${subworkflow.id} may not be called`);\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"sameOwner passes when both workflows are owned by the same user","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":318,"column":70},"line":318,"code":"\ttest('sameOwner passes when both workflows are owned by the same user', async () => {\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => fakeUser);\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(false);\n\t\tjest.spyOn(UserService, 'get').mockImplementation(async () => fakeUser);\n\t\tjest.spyOn(WorkflowsService, 'getSharing').mockImplementation(async () => {\n\t\t\treturn sharedWorkflowOwner;\n\t\t});\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId, userId),\n\t\t).resolves.not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"workflowsFromAList works when the list contains the parent id","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":340,"column":68},"line":340,"code":"\ttest('workflowsFromAList works when the list contains the parent id', async () => {\n\t\tconst workflowId = uuid();\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => fakeUser);\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(true);\n\t\tjest.spyOn(UserService, 'get').mockImplementation(async () => fakeUser);\n\t\tjest.spyOn(WorkflowsService, 'getSharing').mockImplementation(async () => {\n\t\t\treturn sharedWorkflowNotOwner;\n\t\t});\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t\tsettings: {\n\t\t\t\tcallerPolicy: 'workflowsFromAList',\n\t\t\t\tcallerIds: `123,456,bcdef,  ${workflowId}`,\n\t\t\t},\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId, workflowId),\n\t\t).resolves.not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not throw when workflow policy is set to any","suites":["PermissionChecker.checkSubworkflowExecutePolicy"],"updatePoint":{"line":367,"column":58},"line":367,"code":"\ttest('should not throw when workflow policy is set to any', async () => {\n\t\tjest\n\t\t\t.spyOn(ownershipService, 'getWorkflowOwnerCached')\n\t\t\t.mockImplementation(async (workflowId) => fakeUser);\n\t\tjest.spyOn(UserManagementHelper, 'isSharingEnabled').mockReturnValue(true);\n\t\tjest.spyOn(UserService, 'get').mockImplementation(async () => fakeUser);\n\t\tjest.spyOn(WorkflowsService, 'getSharing').mockImplementation(async () => {\n\t\t\treturn sharedWorkflowNotOwner;\n\t\t});\n\n\t\tconst subworkflow = new Workflow({\n\t\t\tnodes: [],\n\t\t\tconnections: {},\n\t\t\tactive: false,\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tid: '2',\n\t\t\tsettings: {\n\t\t\t\tcallerPolicy: 'any',\n\t\t\t},\n\t\t});\n\t\tawait expect(\n\t\t\tPermissionChecker.checkSubworkflowExecutePolicy(subworkflow, userId),\n\t\t).resolves.not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"inits PostHog correctly","suites":["PostHog"],"updatePoint":{"line":23,"column":28},"line":23,"code":"\tit('inits PostHog correctly', async () => {\n\t\tconst ph = new PostHogClient();\n\t\tawait ph.init(instanceId);\n\n\t\texpect(PostHog.prototype.constructor).toHaveBeenCalledWith(apiKey, { host: apiHost });\n\t});","file":"unit/PostHog.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"does not initialize or track if diagnostics are not enabled","suites":["PostHog"],"updatePoint":{"line":30,"column":64},"line":30,"code":"\tit('does not initialize or track if diagnostics are not enabled', async () => {\n\t\tconfig.set('diagnostics.enabled', false);\n\n\t\tconst ph = new PostHogClient();\n\t\tawait ph.init(instanceId);\n\n\t\tph.track({\n\t\t\tuserId: 'test',\n\t\t\tevent: 'test',\n\t\t\tproperties: {},\n\t\t});\n\n\t\texpect(PostHog.prototype.constructor).not.toHaveBeenCalled();\n\t\texpect(PostHog.prototype.capture).not.toHaveBeenCalled();\n\t});","file":"unit/PostHog.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"captures PostHog events","suites":["PostHog"],"updatePoint":{"line":46,"column":28},"line":46,"code":"\tit('captures PostHog events', async () => {\n\t\tconst event = 'test event';\n\t\tconst properties = {\n\t\t\tuser_id: 'test',\n\t\t\ttest: true,\n\t\t};\n\n\t\tconst ph = new PostHogClient();\n\t\tawait ph.init(instanceId);\n\n\t\tph.track({\n\t\t\tuserId,\n\t\t\tevent,\n\t\t\tproperties,\n\t\t});\n\n\t\texpect(PostHog.prototype.capture).toHaveBeenCalledWith({\n\t\t\tdistinctId: userId,\n\t\t\tevent,\n\t\t\tuserId,\n\t\t\tproperties,\n\t\t\tsendFeatureFlags: true,\n\t\t});\n\t});","file":"unit/PostHog.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"gets feature flags","suites":["PostHog"],"updatePoint":{"line":71,"column":23},"line":71,"code":"\tit('gets feature flags', async () => {\n\t\tconst createdAt = new Date();\n\t\tconst ph = new PostHogClient();\n\t\tawait ph.init(instanceId);\n\n\t\tawait ph.getFeatureFlags({\n\t\t\tid: userId,\n\t\t\tcreatedAt,\n\t\t});\n\n\t\texpect(PostHog.prototype.getAllFlags).toHaveBeenCalledWith(`${instanceId}#${userId}`, {\n\t\t\tpersonProperties: {\n\t\t\t\tcreated_at_timestamp: createdAt.getTime().toString(),\n\t\t\t},\n\t\t});\n\t});","file":"unit/PostHog.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return the role when present","suites":["RoleRepository","findRole"],"updatePoint":{"line":18,"column":43},"line":18,"code":"\t\ttest('should return the role when present', async () => {\n\t\t\tentityManager.findOne.mockResolvedValueOnce(createRole('global', 'owner'));\n\t\t\tconst role = await roleRepository.findRole('global', 'owner');\n\t\t\texpect(role?.name).toEqual('owner');\n\t\t\texpect(role?.scope).toEqual('global');\n\t\t});","file":"unit/repositories/role.repository.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return null otherwise","suites":["RoleRepository","findRole"],"updatePoint":{"line":25,"column":36},"line":25,"code":"\t\ttest('should return null otherwise', async () => {\n\t\t\tentityManager.findOne.mockResolvedValueOnce(null);\n\t\t\tconst role = await roleRepository.findRole('global', 'owner');\n\t\t\texpect(role).toEqual(null);\n\t\t});","file":"unit/repositories/role.repository.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"get","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":13,"column":11},"line":13,"code":"\t\ttest('get', async () => {\n\t\t\tawait cacheService.get('');\n\t\t\texpect(store.get).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.get('key');\n\t\t\texpect(store.get).toHaveBeenCalledWith('key');\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"getMany","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":21,"column":15},"line":21,"code":"\t\ttest('getMany', async () => {\n\t\t\tawait cacheService.getMany([]);\n\t\t\texpect(store.mget).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.getMany(['key1', 'key2']);\n\t\t\texpect(store.mget).toHaveBeenCalledWith('key1', 'key2');\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"set","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":29,"column":11},"line":29,"code":"\t\ttest('set', async () => {\n\t\t\tawait cacheService.set('', '');\n\t\t\texpect(store.set).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.set('key', 'value');\n\t\t\texpect(store.set).toHaveBeenCalledWith('key', 'value', undefined);\n\n\t\t\tawait cacheService.set('key', 'value', 123);\n\t\t\texpect(store.set).toHaveBeenCalledWith('key', 'value', 123);\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"setMany","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":40,"column":15},"line":40,"code":"\t\ttest('setMany', async () => {\n\t\t\tawait cacheService.setMany([]);\n\t\t\texpect(store.mset).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.setMany([['key', 'value']]);\n\t\t\texpect(store.mset).toHaveBeenCalledWith([['key', 'value']], undefined);\n\n\t\t\tawait cacheService.setMany([['key', 'value']], 123);\n\t\t\texpect(store.mset).toHaveBeenCalledWith([['key', 'value']], 123);\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"delete","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":51,"column":14},"line":51,"code":"\t\ttest('delete', async () => {\n\t\t\tawait cacheService.delete('');\n\t\t\texpect(store.del).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.delete('key');\n\t\t\texpect(store.del).toHaveBeenCalledWith('key');\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deleteMany","suites":["CacheService (Mock)","should prevent use of empty keys"],"updatePoint":{"line":59,"column":18},"line":59,"code":"\t\ttest('deleteMany', async () => {\n\t\t\tawait cacheService.deleteMany([]);\n\t\t\texpect(store.mdel).not.toHaveBeenCalled();\n\n\t\t\tawait cacheService.deleteMany(['key1', 'key2']);\n\t\t\texpect(store.mdel).toHaveBeenCalledWith('key1', 'key2');\n\t\t});","file":"unit/services/cache-mock.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create a memory cache by default","suites":["cacheService"],"updatePoint":{"line":62,"column":46},"line":62,"code":"\ttest('should create a memory cache by default', async () => {\n\t\tawait cacheService.init();\n\t\tawait expect(cacheService.getCache()).resolves.toBeDefined();\n\t\tconst candidate = (await cacheService.getCache()) as MemoryCache;\n\t\t// type guard to check that a MemoryCache is returned and not a RedisCache (which does not have a size property)\n\t\texpect(candidate.store.size).toBeDefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should cache and retrieve a value","suites":["cacheService"],"updatePoint":{"line":70,"column":40},"line":70,"code":"\ttest('should cache and retrieve a value', async () => {\n\t\tawait cacheService.init();\n\t\tawait expect(cacheService.getCache()).resolves.toBeDefined();\n\t\tawait cacheService.set('testString', 'test');\n\t\tawait cacheService.set('testNumber1', 123);\n\n\t\tawait expect(cacheService.get('testString')).resolves.toBe('test');\n\t\texpect(typeof (await cacheService.get('testString'))).toBe('string');\n\t\tawait expect(cacheService.get('testNumber1')).resolves.toBe(123);\n\t\texpect(typeof (await cacheService.get('testNumber1'))).toBe('number');\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should honour ttl values","suites":["cacheService"],"updatePoint":{"line":82,"column":31},"line":82,"code":"\ttest('should honour ttl values', async () => {\n\t\t// set default TTL to 10ms\n\t\tconfig.set('cache.memory.ttl', 10);\n\n\t\tawait cacheService.set('testString', 'test');\n\t\tawait cacheService.set('testNumber1', 123, 1000);\n\n\t\tconst store = (await cacheService.getCache())?.store;\n\n\t\texpect(store).toBeDefined();\n\n\t\tawait expect(store!.ttl('testString')).resolves.toBeLessThanOrEqual(100);\n\t\tawait expect(store!.ttl('testNumber1')).resolves.toBeLessThanOrEqual(1000);\n\n\t\t// commented out because it fails on CI sporadically\n\t\t// await expect(cacheService.get('testString')).resolves.toBe('test');\n\t\t// await expect(cacheService.get('testNumber1')).resolves.toBe(123);\n\n\t\t// await new Promise((resolve) => setTimeout(resolve, 20));\n\n\t\t// await expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t\t// await expect(cacheService.get('testNumber1')).resolves.toBe(123);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set and remove values","suites":["cacheService"],"updatePoint":{"line":106,"column":35},"line":106,"code":"\ttest('should set and remove values', async () => {\n\t\tawait cacheService.set('testString', 'test');\n\t\tawait expect(cacheService.get('testString')).resolves.toBe('test');\n\t\tawait cacheService.delete('testString');\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should calculate maxSize","suites":["cacheService"],"updatePoint":{"line":113,"column":31},"line":113,"code":"\ttest('should calculate maxSize', async () => {\n\t\tconfig.set('cache.memory.maxSize', 16);\n\t\tawait cacheService.destroy();\n\n\t\t// 16 bytes because stringify wraps the string in quotes, so 2 bytes for the quotes\n\t\tawait cacheService.set('testString', 'withoutUnicode');\n\t\tawait expect(cacheService.get('testString')).resolves.toBe('withoutUnicode');\n\n\t\tawait cacheService.destroy();\n\n\t\t// should not fit!\n\t\tawait cacheService.set('testString', 'withUnicode');\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set and get complex objects","suites":["cacheService"],"updatePoint":{"line":128,"column":41},"line":128,"code":"\ttest('should set and get complex objects', async () => {\n\t\tawait cacheService.set('testObject', testObject);\n\t\tawait expect(cacheService.get('testObject')).resolves.toMatchObject(testObject);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set and get multiple values","suites":["cacheService"],"updatePoint":{"line":133,"column":41},"line":133,"code":"\ttest('should set and get multiple values', async () => {\n\t\tawait cacheService.destroy();\n\t\texpect(cacheService.isRedisCache()).toBe(false);\n\n\t\tawait cacheService.setMany([\n\t\t\t['testString', 'test'],\n\t\t\t['testString2', 'test2'],\n\t\t]);\n\t\tawait cacheService.setMany([\n\t\t\t['testNumber1', 123],\n\t\t\t['testNumber2', 456],\n\t\t]);\n\t\tawait expect(cacheService.getMany(['testString', 'testString2'])).resolves.toStrictEqual([\n\t\t\t'test',\n\t\t\t'test2',\n\t\t]);\n\t\tawait expect(cacheService.getMany(['testNumber1', 'testNumber2'])).resolves.toStrictEqual([\n\t\t\t123, 456,\n\t\t]);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create a redis in queue mode","suites":["cacheService"],"updatePoint":{"line":154,"column":42},"line":154,"code":"\ttest('should create a redis in queue mode', async () => {\n\t\tconfig.set('cache.backend', 'auto');\n\t\tconfig.set('executions.mode', 'queue');\n\t\tawait cacheService.destroy();\n\t\tawait cacheService.init();\n\n\t\tconst cache = await cacheService.getCache();\n\t\tawait expect(cacheService.getCache()).resolves.toBeDefined();\n\t\tconst candidate = (await cacheService.getCache()) as RedisCache;\n\t\texpect(candidate.store.client).toBeDefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create a redis cache if asked","suites":["cacheService"],"updatePoint":{"line":166,"column":43},"line":166,"code":"\ttest('should create a redis cache if asked', async () => {\n\t\tconfig.set('cache.backend', 'redis');\n\t\tconfig.set('executions.mode', 'queue');\n\t\tawait cacheService.destroy();\n\t\tawait cacheService.init();\n\n\t\tconst cache = await cacheService.getCache();\n\t\tawait expect(cacheService.getCache()).resolves.toBeDefined();\n\t\tconst candidate = (await cacheService.getCache()) as RedisCache;\n\t\texpect(candidate.store.client).toBeDefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get/set/delete redis cache","suites":["cacheService"],"updatePoint":{"line":178,"column":40},"line":178,"code":"\ttest('should get/set/delete redis cache', async () => {\n\t\tconfig.set('cache.backend', 'redis');\n\t\tconfig.set('executions.mode', 'queue');\n\t\tawait cacheService.destroy();\n\t\tawait cacheService.init();\n\n\t\tawait cacheService.set('testObject', testObject);\n\t\tawait expect(cacheService.get('testObject')).resolves.toMatchObject(testObject);\n\t\tawait cacheService.delete('testObject');\n\t\tawait expect(cacheService.get('testObject')).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return fallback value if key is not set","suites":["cacheService"],"updatePoint":{"line":194,"column":53},"line":194,"code":"\ttest('should return fallback value if key is not set', async () => {\n\t\tawait cacheService.reset();\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t\tawait expect(\n\t\t\tcacheService.get('testString', {\n\t\t\t\tfallbackValue: 'fallback',\n\t\t\t}),\n\t\t).resolves.toBe('fallback');\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should call refreshFunction if key is not set","suites":["cacheService"],"updatePoint":{"line":204,"column":52},"line":204,"code":"\ttest('should call refreshFunction if key is not set', async () => {\n\t\tawait cacheService.reset();\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t\tawait expect(\n\t\t\tcacheService.get('testString', {\n\t\t\t\trefreshFunction: async () => 'refreshed',\n\t\t\t\tfallbackValue: 'this should not be returned',\n\t\t\t}),\n\t\t).resolves.toBe('refreshed');\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should transparently handle disabled cache","suites":["cacheService"],"updatePoint":{"line":215,"column":49},"line":215,"code":"\ttest('should transparently handle disabled cache', async () => {\n\t\tawait cacheService.disable();\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t\tawait cacheService.set('testString', 'whatever');\n\t\tawait expect(cacheService.get('testString')).resolves.toBeUndefined();\n\t\tawait expect(\n\t\t\tcacheService.get('testString', {\n\t\t\t\tfallbackValue: 'fallback',\n\t\t\t}),\n\t\t).resolves.toBe('fallback');\n\t\tawait expect(\n\t\t\tcacheService.get('testString', {\n\t\t\t\trefreshFunction: async () => 'refreshed',\n\t\t\t\tfallbackValue: 'this should not be returned',\n\t\t\t}),\n\t\t).resolves.toBe('refreshed');\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set and get partial results","suites":["cacheService"],"updatePoint":{"line":233,"column":41},"line":233,"code":"\ttest('should set and get partial results', async () => {\n\t\tawait cacheService.setMany([\n\t\t\t['testNumber1', 123],\n\t\t\t['testNumber2', 456],\n\t\t]);\n\t\tawait expect(cacheService.getMany(['testNumber1', 'testNumber2'])).resolves.toStrictEqual([\n\t\t\t123, 456,\n\t\t]);\n\t\tawait expect(cacheService.getMany(['testNumber3', 'testNumber2'])).resolves.toStrictEqual([\n\t\t\tundefined,\n\t\t\t456,\n\t\t]);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should getMany and fix partial results and set single key","suites":["cacheService"],"updatePoint":{"line":247,"column":64},"line":247,"code":"\ttest('should getMany and fix partial results and set single key', async () => {\n\t\tawait cacheService.setMany([\n\t\t\t['testNumber1', 123],\n\t\t\t['testNumber2', 456],\n\t\t]);\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2', 'testNumber3']),\n\t\t).resolves.toStrictEqual([123, 456, undefined]);\n\t\tawait expect(cacheService.get('testNumber3')).resolves.toBeUndefined();\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2', 'testNumber3'], {\n\t\t\t\tasync refreshFunctionEach(key) {\n\t\t\t\t\treturn key === 'testNumber3' ? 789 : undefined;\n\t\t\t\t},\n\t\t\t}),\n\t\t).resolves.toStrictEqual([123, 456, 789]);\n\t\tawait expect(cacheService.get('testNumber3')).resolves.toBe(789);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should getMany and set all keys","suites":["cacheService"],"updatePoint":{"line":266,"column":38},"line":266,"code":"\ttest('should getMany and set all keys', async () => {\n\t\tawait cacheService.setMany([\n\t\t\t['testNumber1', 123],\n\t\t\t['testNumber2', 456],\n\t\t]);\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2', 'testNumber3']),\n\t\t).resolves.toStrictEqual([123, 456, undefined]);\n\t\tawait expect(cacheService.get('testNumber3')).resolves.toBeUndefined();\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2', 'testNumber3'], {\n\t\t\t\tasync refreshFunctionMany(keys) {\n\t\t\t\t\treturn [111, 222, 333];\n\t\t\t\t},\n\t\t\t}),\n\t\t).resolves.toStrictEqual([111, 222, 333]);\n\t\tawait expect(cacheService.get('testNumber1')).resolves.toBe(111);\n\t\tawait expect(cacheService.get('testNumber2')).resolves.toBe(222);\n\t\tawait expect(cacheService.get('testNumber3')).resolves.toBe(333);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set and get multiple values with fallbackValue","suites":["cacheService"],"updatePoint":{"line":287,"column":60},"line":287,"code":"\ttest('should set and get multiple values with fallbackValue', async () => {\n\t\tawait cacheService.disable();\n\t\tawait cacheService.setMany([\n\t\t\t['testNumber1', 123],\n\t\t\t['testNumber2', 456],\n\t\t]);\n\t\tawait expect(cacheService.getMany(['testNumber1', 'testNumber2'])).resolves.toStrictEqual([\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t]);\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2'], {\n\t\t\t\tfallbackValues: [123, 456],\n\t\t\t}),\n\t\t).resolves.toStrictEqual([123, 456]);\n\t\tawait expect(\n\t\t\tcacheService.getMany(['testNumber1', 'testNumber2'], {\n\t\t\t\trefreshFunctionMany: async () => [123, 456],\n\t\t\t\tfallbackValues: [0, 1],\n\t\t\t}),\n\t\t).resolves.toStrictEqual([123, 456]);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deal with unicode keys","suites":["cacheService"],"updatePoint":{"line":310,"column":36},"line":310,"code":"\ttest('should deal with unicode keys', async () => {\n\t\tconst key = '? > \":< ! withUnicode';\n\t\tawait cacheService.set(key, 'test');\n\t\tawait expect(cacheService.get(key)).resolves.toBe('test');\n\t\tawait cacheService.delete(key);\n\t\tawait expect(cacheService.get(key)).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deal with unicode keys in redis","suites":["cacheService"],"updatePoint":{"line":318,"column":45},"line":318,"code":"\ttest('should deal with unicode keys in redis', async () => {\n\t\tconfig.set('cache.backend', 'redis');\n\t\tconfig.set('executions.mode', 'queue');\n\t\tawait cacheService.destroy();\n\t\tawait cacheService.init();\n\t\tconst key = '? > \":< ! withUnicode';\n\n\t\texpect(((await cacheService.getCache()) as RedisCache).store.client).toBeDefined();\n\n\t\tawait cacheService.set(key, 'test');\n\t\tawait expect(cacheService.get(key)).resolves.toBe('test');\n\t\tawait cacheService.delete(key);\n\t\tawait expect(cacheService.get(key)).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not cache null or undefined values","suites":["cacheService"],"updatePoint":{"line":333,"column":48},"line":333,"code":"\ttest('should not cache null or undefined values', async () => {\n\t\tawait cacheService.set('nullValue', null);\n\t\tawait cacheService.set('undefValue', undefined);\n\t\tawait cacheService.set('normalValue', 'test');\n\n\t\tawait expect(cacheService.get('normalValue')).resolves.toBe('test');\n\t\tawait expect(cacheService.get('undefValue')).resolves.toBeUndefined();\n\t\tawait expect(cacheService.get('nullValue')).resolves.toBeUndefined();\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle setting empty keys","suites":["cacheService"],"updatePoint":{"line":343,"column":39},"line":343,"code":"\ttest('should handle setting empty keys', async () => {\n\t\tawait cacheService.set('', null);\n\t\tawait expect(cacheService.get('')).resolves.toBeUndefined();\n\t\tawait cacheService.setMany([\n\t\t\t['', 'something'],\n\t\t\t['', 'something'],\n\t\t]);\n\t\tawait expect(cacheService.getMany([''])).resolves.toStrictEqual([undefined]);\n\t\tawait cacheService.setMany([]);\n\t\tawait expect(cacheService.getMany([])).resolves.toStrictEqual([]);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle setting empty keys (redis)","suites":["cacheService"],"updatePoint":{"line":355,"column":47},"line":355,"code":"\ttest('should handle setting empty keys (redis)', async () => {\n\t\tconfig.set('cache.backend', 'redis');\n\t\tconfig.set('executions.mode', 'queue');\n\t\tawait cacheService.destroy();\n\t\tawait cacheService.init();\n\n\t\tawait cacheService.set('', null);\n\t\tawait expect(cacheService.get('')).resolves.toBeUndefined();\n\t\tawait cacheService.setMany([\n\t\t\t['', 'something'],\n\t\t\t['', 'something'],\n\t\t]);\n\t\tawait expect(cacheService.getMany([''])).resolves.toStrictEqual([undefined]);\n\t\tawait cacheService.setMany([]);\n\t\tawait expect(cacheService.getMany([])).resolves.toStrictEqual([]);\n\t});","file":"unit/services/cache.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create metrics for production successes","suites":["EventsService","workflowExecutionCompleted"],"updatePoint":{"line":70,"column":54},"line":70,"code":"\t\ttest('should create metrics for production successes', async () => {\n\t\t\t// Call the function with a production success result, ensure metrics hook gets called\n\t\t\tconst workflow = {\n\t\t\t\tid: '1',\n\t\t\t\tname: '',\n\t\t\t\tactive: false,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tnodes: [],\n\t\t\t\tconnections: {},\n\t\t\t};\n\t\t\tconst runData: IRun = {\n\t\t\t\tfinished: true,\n\t\t\t\tstatus: 'success',\n\t\t\t\tdata: { resultData: { runData: {} } },\n\t\t\t\tmode: 'internal' as WorkflowExecuteMode,\n\t\t\t\tstartedAt: new Date(),\n\t\t\t};\n\t\t\tmockDBCall();\n\n\t\t\tawait eventsService.workflowExecutionCompleted(workflow, runData);\n\t\t\texpect(updateUserSettingsMock).toHaveBeenCalledTimes(1);\n\t\t\texpect(onFirstProductionWorkflowSuccess).toBeCalledTimes(1);\n\t\t\texpect(onFirstProductionWorkflowSuccess).toHaveBeenNthCalledWith(1, {\n\t\t\t\tuser_id: fakeUser.id,\n\t\t\t\tworkflow_id: workflow.id,\n\t\t\t});\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should only create metrics for production successes","suites":["EventsService","workflowExecutionCompleted"],"updatePoint":{"line":99,"column":59},"line":99,"code":"\t\ttest('should only create metrics for production successes', async () => {\n\t\t\t// Call the function with a non production success result, ensure metrics hook is never called\n\t\t\tconst workflow = {\n\t\t\t\tid: '1',\n\t\t\t\tname: '',\n\t\t\t\tactive: false,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tnodes: [],\n\t\t\t\tconnections: {},\n\t\t\t};\n\t\t\tconst runData: IRun = {\n\t\t\t\tfinished: false,\n\t\t\t\tstatus: 'failed',\n\t\t\t\tdata: { resultData: { runData: {} } },\n\t\t\t\tmode: 'internal' as WorkflowExecuteMode,\n\t\t\t\tstartedAt: new Date(),\n\t\t\t};\n\t\t\tawait eventsService.workflowExecutionCompleted(workflow, runData);\n\t\t\texpect(onFirstProductionWorkflowSuccess).toBeCalledTimes(0);\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not send metrics for updated entries","suites":["EventsService","workflowExecutionCompleted"],"updatePoint":{"line":121,"column":51},"line":121,"code":"\t\ttest('should not send metrics for updated entries', async () => {\n\t\t\t// Call the function with a fail insert, ensure update is called *and* metrics aren't sent\n\t\t\tconst workflow = {\n\t\t\t\tid: '1',\n\t\t\t\tname: '',\n\t\t\t\tactive: false,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tnodes: [],\n\t\t\t\tconnections: {},\n\t\t\t};\n\t\t\tconst runData: IRun = {\n\t\t\t\tfinished: true,\n\t\t\t\tstatus: 'success',\n\t\t\t\tdata: { resultData: { runData: {} } },\n\t\t\t\tmode: 'internal' as WorkflowExecuteMode,\n\t\t\t\tstartedAt: new Date(),\n\t\t\t};\n\t\t\tmockDBCall(2);\n\t\t\tawait eventsService.workflowExecutionCompleted(workflow, runData);\n\t\t\texpect(onFirstProductionWorkflowSuccess).toBeCalledTimes(0);\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create metrics when the db is updated","suites":["EventsService","nodeFetchedData"],"updatePoint":{"line":146,"column":52},"line":146,"code":"\t\ttest('should create metrics when the db is updated', async () => {\n\t\t\t// Call the function with a production success result, ensure metrics hook gets called\n\t\t\tconst workflowId = '1';\n\t\t\tconst node = {\n\t\t\t\tid: 'abcde',\n\t\t\t\tname: 'test node',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\ttype: '',\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\tparameters: {},\n\t\t\t};\n\t\t\tawait eventsService.nodeFetchedData(workflowId, node);\n\t\t\texpect(onFirstWorkflowDataLoad).toBeCalledTimes(1);\n\t\t\texpect(onFirstWorkflowDataLoad).toHaveBeenNthCalledWith(1, {\n\t\t\t\tuser_id: fakeUser.id,\n\t\t\t\tworkflow_id: workflowId,\n\t\t\t\tnode_type: node.type,\n\t\t\t\tnode_id: node.id,\n\t\t\t});\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create metrics with credentials when the db is updated","suites":["EventsService","nodeFetchedData"],"updatePoint":{"line":167,"column":69},"line":167,"code":"\t\ttest('should create metrics with credentials when the db is updated', async () => {\n\t\t\t// Call the function with a production success result, ensure metrics hook gets called\n\t\t\tconst workflowId = '1';\n\t\t\tconst node = {\n\t\t\t\tid: 'abcde',\n\t\t\t\tname: 'test node',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\ttype: '',\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\tparameters: {},\n\t\t\t\tcredentials: {\n\t\t\t\t\ttestCredentials: {\n\t\t\t\t\t\tid: '1',\n\t\t\t\t\t\tname: 'Test Credentials',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait eventsService.nodeFetchedData(workflowId, node);\n\t\t\texpect(onFirstWorkflowDataLoad).toBeCalledTimes(1);\n\t\t\texpect(onFirstWorkflowDataLoad).toHaveBeenNthCalledWith(1, {\n\t\t\t\tuser_id: fakeUser.id,\n\t\t\t\tworkflow_id: workflowId,\n\t\t\t\tnode_type: node.type,\n\t\t\t\tnode_id: node.id,\n\t\t\t\tcredential_type: 'testCredentials',\n\t\t\t\tcredential_id: node.credentials.testCredentials.id,\n\t\t\t});\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not send metrics for entries that already have the flag set","suites":["EventsService","nodeFetchedData"],"updatePoint":{"line":196,"column":74},"line":196,"code":"\t\ttest('should not send metrics for entries that already have the flag set', async () => {\n\t\t\t// Fetch data for workflow 2 which is set up to not be altered in the mocks\n\t\t\tentityManager.insert.mockRejectedValueOnce(new QueryFailedError('', undefined, ''));\n\t\t\tconst workflowId = '1';\n\t\t\tconst node = {\n\t\t\t\tid: 'abcde',\n\t\t\t\tname: 'test node',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\ttype: '',\n\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\tparameters: {},\n\t\t\t};\n\t\t\tawait eventsService.nodeFetchedData(workflowId, node);\n\t\t\texpect(onFirstWorkflowDataLoad).toBeCalledTimes(0);\n\t\t});","file":"unit/services/events.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should sign input with user management secret","suites":["JwtService"],"updatePoint":{"line":15,"column":52},"line":15,"code":"\ttest('Should sign input with user management secret', async () => {\n\t\tconst userId = 1;\n\n\t\tconst token = jwtService.signData({ sub: userId });\n\t\texpect(typeof token).toBe('string');\n\n\t\tconst secret = config.get('userManagement.jwtSecret');\n\n\t\tconst decodedToken = jwt.verify(token, secret);\n\n\t\texpect(decodedToken).toHaveProperty('sub');\n\t\texpect(decodedToken).toHaveProperty('iat');\n\t\texpect(decodedToken?.sub).toBe(userId);\n\t});","file":"unit/services/jwt.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should verify token with user management secret","suites":["JwtService"],"updatePoint":{"line":30,"column":54},"line":30,"code":"\ttest('Should verify token with user management secret', async () => {\n\t\tconst userId = 1;\n\n\t\tconst secret = config.get('userManagement.jwtSecret');\n\n\t\tconst token = jwt.sign({ sub: userId }, secret);\n\n\t\tconst decodedToken = jwt.verify(token, secret);\n\n\t\texpect(decodedToken).toHaveProperty('sub');\n\t\texpect(decodedToken?.sub).toBe(userId);\n\t});","file":"unit/services/jwt.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should retrieve a workflow owner","suites":["OwnershipService","getWorkflowOwner()"],"updatePoint":{"line":36,"column":40},"line":36,"code":"\t\ttest('should retrieve a workflow owner', async () => {\n\t\t\troleService.findWorkflowOwnerRole.mockResolvedValueOnce(wfOwnerRole());\n\n\t\t\tconst mockOwner = new User();\n\t\t\tconst mockNonOwner = new User();\n\n\t\t\tconst sharedWorkflow = Object.assign(new SharedWorkflow(), {\n\t\t\t\trole: new Role(),\n\t\t\t\tuser: mockOwner,\n\t\t\t});\n\n\t\t\tsharedWorkflowRepository.findOneOrFail.mockResolvedValueOnce(sharedWorkflow);\n\n\t\t\tconst returnedOwner = await ownershipService.getWorkflowOwnerCached('some-workflow-id');\n\n\t\t\texpect(returnedOwner).toBe(mockOwner);\n\t\t\texpect(returnedOwner).not.toBe(mockNonOwner);\n\t\t});","file":"unit/services/ownership.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw if no workflow owner role found","suites":["OwnershipService","getWorkflowOwner()"],"updatePoint":{"line":55,"column":52},"line":55,"code":"\t\ttest('should throw if no workflow owner role found', async () => {\n\t\t\troleService.findWorkflowOwnerRole.mockRejectedValueOnce(new Error());\n\n\t\t\tawait expect(ownershipService.getWorkflowOwnerCached('some-workflow-id')).rejects.toThrow();\n\t\t});","file":"unit/services/ownership.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw if no workflow owner found","suites":["OwnershipService","getWorkflowOwner()"],"updatePoint":{"line":61,"column":47},"line":61,"code":"\t\ttest('should throw if no workflow owner found', async () => {\n\t\t\troleService.findWorkflowOwnerRole.mockResolvedValueOnce(wfOwnerRole());\n\n\t\t\tsharedWorkflowRepository.findOneOrFail.mockRejectedValue(new Error());\n\n\t\t\tawait expect(ownershipService.getWorkflowOwnerCached('some-workflow-id')).rejects.toThrow();\n\t\t});","file":"unit/services/ownership.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create pubsub publisher and subscriber with handler","suites":["cacheService"],"updatePoint":{"line":57,"column":65},"line":57,"code":"\ttest('should create pubsub publisher and subscriber with handler', async () => {\n\t\tconst pub = await redisService.getPubSubPublisher();\n\t\tconst sub = await redisService.getPubSubSubscriber();\n\t\texpect(pub).toBeDefined();\n\t\texpect(sub).toBeDefined();\n\n\t\tconst mockHandler = jest.fn();\n\t\tmockHandler.mockImplementation((channel: string, message: string) => {});\n\t\tsub.addMessageHandler(PUBSUB_CHANNEL, mockHandler);\n\t\tawait sub.subscribe(PUBSUB_CHANNEL);\n\t\tawait pub.publish(PUBSUB_CHANNEL, 'test');\n\t\tawait new Promise((resolve) =>\n\t\t\tsetTimeout(async () => {\n\t\t\t\tresolve(0);\n\t\t\t}, 50),\n\t\t);\n\t\texpect(mockHandler).toHaveBeenCalled();\n\t\tawait sub.destroy();\n\t\tawait pub.destroy();\n\t});","file":"unit/services/redis.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create list sender and receiver","suites":["cacheService"],"updatePoint":{"line":78,"column":45},"line":78,"code":"\ttest('should create list sender and receiver', async () => {\n\t\tconst sender = await redisService.getListSender();\n\t\tconst receiver = await redisService.getListReceiver();\n\t\texpect(sender).toBeDefined();\n\t\texpect(receiver).toBeDefined();\n\t\tawait sender.prepend(LIST_CHANNEL, 'middle');\n\t\tawait sender.prepend(LIST_CHANNEL, 'first');\n\t\tawait sender.append(LIST_CHANNEL, 'end');\n\t\tlet popResult = await receiver.popFromHead(LIST_CHANNEL);\n\t\texpect(popResult).toBe('first');\n\t\tpopResult = await receiver.popFromTail(LIST_CHANNEL);\n\t\texpect(popResult).toBe('end');\n\t\tawait sender.prepend(LIST_CHANNEL, 'somevalue');\n\t\tpopResult = await receiver.popFromTail(LIST_CHANNEL);\n\t\texpect(popResult).toBe('middle');\n\t\tawait sender.destroy();\n\t\tawait receiver.destroy();\n\t});","file":"unit/services/redis.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create stream producer and consumer","suites":["cacheService"],"line":99,"code":"\ttest.skip('should create stream producer and consumer', async () => {","file":"unit/services/redis.service.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"should return the   role if found","suites":["RoleService","findRole() []"],"updatePoint":{"line":48,"column":57},"line":48,"code":"\t\t\ttest(`should return the ${scope} ${name} role if found`, async () => {\n\t\t\t\tconfig.set('cache.enabled', cacheEnabled);\n\n\t\t\t\tconst role = roleRepository.create({ name, scope });\n\t\t\t\troleRepository.findRole.mockResolvedValueOnce(role);\n\t\t\t\tconst returnedRole = await roleRepository.findRole(scope, name);\n\n\t\t\t\texpect(returnedRole).toBe(role);\n\t\t\t});","file":"unit/services/role.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return the role if a shared workflow is found","suites":["RoleService","findRoleByUserAndWorkflow() []"],"updatePoint":{"line":60,"column":61},"line":60,"code":"\t\t\ttest('should return the role if a shared workflow is found', async () => {\n\t\t\t\tconfig.set('cache.enabled', cacheEnabled);\n\n\t\t\t\tconst sharedWorkflow = Object.assign(new SharedWorkflow(), { role: new Role() });\n\t\t\t\tsharedWorkflowRepository.findOne.mockResolvedValueOnce(sharedWorkflow);\n\t\t\t\tconst returnedRole = await roleService.findRoleByUserAndWorkflow(userId, workflowId);\n\n\t\t\t\texpect(returnedRole).toBe(sharedWorkflow.role);\n\t\t\t});","file":"unit/services/role.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return undefined if no shared workflow is found","suites":["RoleService","findRoleByUserAndWorkflow() []"],"updatePoint":{"line":70,"column":63},"line":70,"code":"\t\t\ttest('should return undefined if no shared workflow is found', async () => {\n\t\t\t\tconfig.set('cache.enabled', cacheEnabled);\n\n\t\t\t\tsharedWorkflowRepository.findOne.mockResolvedValueOnce(null);\n\t\t\t\tconst returnedRole = await roleService.findRoleByUserAndWorkflow(userId, workflowId);\n\n\t\t\t\texpect(returnedRole).toBeUndefined();\n\t\t\t});","file":"unit/services/role.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return the webhook if found","suites":["WebhookService","findWebhook() - static case "],"updatePoint":{"line":31,"column":43},"line":31,"code":"\t\t\ttest('should return the webhook if found', async () => {\n\t\t\t\tconst method = 'GET';\n\t\t\t\tconst path = 'user/profile';\n\t\t\t\tconst mockWebhook = createWebhook(method, path);\n\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(mockWebhook);\n\n\t\t\t\tconst returnedWebhook = await webhookService.findWebhook(method, path);\n\n\t\t\t\texpect(returnedWebhook).toBe(mockWebhook);\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return null if not found","suites":["WebhookService","findWebhook() - static case "],"updatePoint":{"line":43,"column":40},"line":43,"code":"\t\t\ttest('should return null if not found', async () => {\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(null); // static\n\t\t\t\twebhookRepository.findBy.mockResolvedValue([]);\n\n\t\t\t\tconst returnValue = await webhookService.findWebhook('GET', 'user/profile');\n\n\t\t\t\texpect(returnValue).toBeNull();\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return the webhook if found","suites":["WebhookService","findWebhook() - dynamic case "],"updatePoint":{"line":54,"column":43},"line":54,"code":"\t\t\ttest('should return the webhook if found', async () => {\n\t\t\t\tconst method = 'GET';\n\t\t\t\tconst webhookId = uuid();\n\t\t\t\tconst path = 'user/:id/posts';\n\t\t\t\tconst mockWebhook = createWebhook(method, path, webhookId, 3);\n\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(null); // static\n\t\t\t\twebhookRepository.findBy.mockResolvedValue([mockWebhook]); // dynamic\n\n\t\t\t\tconst returnedWebhook = await webhookService.findWebhook(\n\t\t\t\t\tmethod,\n\t\t\t\t\t[webhookId, 'user/123/posts'].join('/'),\n\t\t\t\t);\n\n\t\t\t\texpect(returnedWebhook).toBe(mockWebhook);\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle subset dynamic path case","suites":["WebhookService","findWebhook() - dynamic case "],"updatePoint":{"line":71,"column":47},"line":71,"code":"\t\t\ttest('should handle subset dynamic path case', async () => {\n\t\t\t\tconst method1 = 'GET';\n\t\t\t\tconst webhookId1 = uuid();\n\t\t\t\tconst path1 = 'user/:id/posts';\n\t\t\t\tconst mockWebhook1 = createWebhook(method1, path1, webhookId1, 3);\n\n\t\t\t\tconst method2 = 'GET';\n\t\t\t\tconst webhookId2 = uuid();\n\t\t\t\tconst path2 = 'user/:id/posts/:postId/comments';\n\t\t\t\tconst mockWebhook2 = createWebhook(method2, path2, webhookId2, 3);\n\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(null); // static\n\t\t\t\twebhookRepository.findBy.mockResolvedValue([mockWebhook1, mockWebhook2]); // dynamic\n\n\t\t\t\tconst fullPath1 = [webhookId1, 'user/123/posts'].join('/');\n\t\t\t\tconst returnedWebhook1 = await webhookService.findWebhook(method1, fullPath1);\n\n\t\t\t\tconst fullPath2 = [webhookId1, 'user/123/posts/456/comments'].join('/');\n\t\t\t\tconst returnedWebhook2 = await webhookService.findWebhook(method2, fullPath2);\n\n\t\t\t\texpect(returnedWebhook1).toBe(mockWebhook1);\n\t\t\t\texpect(returnedWebhook2).toBe(mockWebhook2);\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle single-segment dynamic path case","suites":["WebhookService","findWebhook() - dynamic case "],"updatePoint":{"line":95,"column":55},"line":95,"code":"\t\t\ttest('should handle single-segment dynamic path case', async () => {\n\t\t\t\tconst method1 = 'GET';\n\t\t\t\tconst webhookId1 = uuid();\n\t\t\t\tconst path1 = ':var';\n\t\t\t\tconst mockWebhook1 = createWebhook(method1, path1, webhookId1, 3);\n\n\t\t\t\tconst method2 = 'GET';\n\t\t\t\tconst webhookId2 = uuid();\n\t\t\t\tconst path2 = 'user/:id/posts/:postId/comments';\n\t\t\t\tconst mockWebhook2 = createWebhook(method2, path2, webhookId2, 3);\n\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(null); // static\n\t\t\t\twebhookRepository.findBy.mockResolvedValue([mockWebhook1, mockWebhook2]); // dynamic\n\n\t\t\t\tconst fullPath = [webhookId1, 'user/123/posts/456'].join('/');\n\t\t\t\tconst returnedWebhook = await webhookService.findWebhook(method1, fullPath);\n\n\t\t\t\texpect(returnedWebhook).toBe(mockWebhook1);\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return null if not found","suites":["WebhookService","findWebhook() - dynamic case "],"updatePoint":{"line":115,"column":40},"line":115,"code":"\t\t\ttest('should return null if not found', async () => {\n\t\t\t\tconst fullPath = [uuid(), 'user/:id/posts'].join('/');\n\n\t\t\t\twebhookRepository.findOneBy.mockResolvedValue(null); // static\n\t\t\t\twebhookRepository.findBy.mockResolvedValue([]); // dynamic\n\n\t\t\t\tconst returnValue = await webhookService.findWebhook('GET', fullPath);\n\n\t\t\t\texpect(returnValue).toBeNull();\n\t\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return all methods for webhook","suites":["WebhookService","getWebhookMethods()"],"updatePoint":{"line":129,"column":45},"line":129,"code":"\t\ttest('should return all methods for webhook', async () => {\n\t\t\tconst path = 'user/profile';\n\n\t\t\twebhookRepository.find.mockResolvedValue([\n\t\t\t\tcreateWebhook('GET', path),\n\t\t\t\tcreateWebhook('POST', path),\n\t\t\t\tcreateWebhook('PUT', path),\n\t\t\t\tcreateWebhook('PATCH', path),\n\t\t\t]);\n\n\t\t\tconst returnedMethods = await webhookService.getWebhookMethods(path);\n\n\t\t\texpect(returnedMethods).toEqual(['GET', 'POST', 'PUT', 'PATCH']);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return empty array if no webhooks found","suites":["WebhookService","getWebhookMethods()"],"updatePoint":{"line":144,"column":54},"line":144,"code":"\t\ttest('should return empty array if no webhooks found', async () => {\n\t\t\twebhookRepository.find.mockResolvedValue([]);\n\n\t\t\tconst returnedMethods = await webhookService.getWebhookMethods('user/profile');\n\n\t\t\texpect(returnedMethods).toEqual([]);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete all webhooks of the instance","suites":["WebhookService","deleteInstanceWebhooks()"],"updatePoint":{"line":154,"column":50},"line":154,"code":"\t\ttest('should delete all webhooks of the instance', async () => {\n\t\t\tconst mockInstanceWebhooks = [\n\t\t\t\tcreateWebhook('PUT', 'users'),\n\t\t\t\tcreateWebhook('GET', 'user/:id'),\n\t\t\t\tcreateWebhook('POST', ':var'),\n\t\t\t];\n\n\t\t\twebhookRepository.find.mockResolvedValue(mockInstanceWebhooks);\n\n\t\t\tawait webhookService.deleteInstanceWebhooks();\n\n\t\t\texpect(webhookRepository.remove).toHaveBeenCalledWith(mockInstanceWebhooks);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete any webhooks if none found","suites":["WebhookService","deleteInstanceWebhooks()"],"updatePoint":{"line":168,"column":52},"line":168,"code":"\t\ttest('should not delete any webhooks if none found', async () => {\n\t\t\twebhookRepository.find.mockResolvedValue([]);\n\n\t\t\tawait webhookService.deleteInstanceWebhooks();\n\n\t\t\texpect(webhookRepository.remove).toHaveBeenCalledWith([]);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should delete all webhooks of the workflow","suites":["WebhookService","deleteWorkflowWebhooks()"],"updatePoint":{"line":178,"column":50},"line":178,"code":"\t\ttest('should delete all webhooks of the workflow', async () => {\n\t\t\tconst mockWorkflowWebhooks = [\n\t\t\t\tcreateWebhook('PUT', 'users'),\n\t\t\t\tcreateWebhook('GET', 'user/:id'),\n\t\t\t\tcreateWebhook('POST', ':var'),\n\t\t\t];\n\n\t\t\twebhookRepository.findBy.mockResolvedValue(mockWorkflowWebhooks);\n\n\t\t\tconst workflowId = uuid();\n\n\t\t\tawait webhookService.deleteWorkflowWebhooks(workflowId);\n\n\t\t\texpect(webhookRepository.remove).toHaveBeenCalledWith(mockWorkflowWebhooks);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not delete any webhooks if none found","suites":["WebhookService","deleteWorkflowWebhooks()"],"updatePoint":{"line":194,"column":52},"line":194,"code":"\t\ttest('should not delete any webhooks if none found', async () => {\n\t\t\twebhookRepository.findBy.mockResolvedValue([]);\n\n\t\t\tconst workflowId = uuid();\n\n\t\t\tawait webhookService.deleteWorkflowWebhooks(workflowId);\n\n\t\t\texpect(webhookRepository.remove).toHaveBeenCalledWith([]);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create the webhook","suites":["WebhookService","createWebhook()"],"updatePoint":{"line":206,"column":33},"line":206,"code":"\t\ttest('should create the webhook', async () => {\n\t\t\tconst mockWebhook = createWebhook('GET', 'user/:id');\n\n\t\t\tawait webhookService.storeWebhook(mockWebhook);\n\n\t\t\texpect(webhookRepository.insert).toHaveBeenCalledWith(mockWebhook);\n\t\t});","file":"unit/services/webhook.service.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should generate an SSH key pair","suites":["Source Control"],"updatePoint":{"line":169,"column":36},"line":169,"code":"\tit('should generate an SSH key pair', async () => {\n\t\tconst keyPair = await generateSshKeyPair();\n\t\texpect(keyPair.privateKey).toBeTruthy();\n\t\texpect(keyPair.privateKey).toContain('BEGIN OPENSSH PRIVATE KEY');\n\t\texpect(keyPair.publicKey).toBeTruthy();\n\t\texpect(keyPair.publicKey).toContain('ssh-ed25519');\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should check for git and ssh folders and create them if required","suites":["Source Control"],"updatePoint":{"line":177,"column":69},"line":177,"code":"\tit('should check for git and ssh folders and create them if required', async () => {\n\t\tconst userFolder = UserSettings.getUserN8nFolderPath();\n\t\tconst sshFolder = path.join(userFolder, SOURCE_CONTROL_SSH_FOLDER);\n\t\tconst gitFolder = path.join(userFolder, SOURCE_CONTROL_GIT_FOLDER);\n\t\tconst sshKeyName = path.join(sshFolder, SOURCE_CONTROL_SSH_KEY_NAME);\n\t\tlet hasThrown = false;\n\t\ttry {\n\t\t\taccessSync(sshFolder, fsConstants.F_OK);\n\t\t} catch (error) {\n\t\t\thasThrown = true;\n\t\t}\n\t\texpect(hasThrown).toBeTruthy();\n\t\thasThrown = false;\n\t\ttry {\n\t\t\taccessSync(gitFolder, fsConstants.F_OK);\n\t\t} catch (error) {\n\t\t\thasThrown = true;\n\t\t}\n\t\texpect(hasThrown).toBeTruthy();\n\t\t// create missing folders\n\t\texpect(sourceControlFoldersExistCheck([gitFolder, sshFolder], true)).toBe(false);\n\t\t// find folders this time\n\t\texpect(sourceControlFoldersExistCheck([gitFolder, sshFolder], true)).toBe(true);\n\t\texpect(accessSync(sshFolder, fsConstants.F_OK)).toBeUndefined();\n\t\texpect(accessSync(gitFolder, fsConstants.F_OK)).toBeUndefined();\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should check if source control is licensed","suites":["Source Control"],"updatePoint":{"line":204,"column":47},"line":204,"code":"\tit('should check if source control is licensed', async () => {\n\t\texpect(Container.get(License).isSourceControlLicensed()).toBe(true);\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get repo type from url","suites":["Source Control"],"updatePoint":{"line":208,"column":34},"line":208,"code":"\tit('should get repo type from url', async () => {\n\t\texpect(getRepoType('git@github.com:n8ntest/n8n_testrepo.git')).toBe('github');\n\t\texpect(getRepoType('git@gitlab.com:n8ntest/n8n_testrepo.git')).toBe('gitlab');\n\t\texpect(getRepoType('git@mygitea.io:n8ntest/n8n_testrepo.git')).toBe('other');\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get tracking information from pre-push results","suites":["Source Control"],"updatePoint":{"line":214,"column":58},"line":214,"code":"\tit('should get tracking information from pre-push results', () => {\n\t\tconst trackingResult = getTrackingInformationFromPrePushResult(pushResult);\n\t\texpect(trackingResult).toEqual({\n\t\t\tworkflows_eligible: 3,\n\t\t\tworkflows_eligible_with_conflicts: 1,\n\t\t\tcreds_eligible: 1,\n\t\t\tcreds_eligible_with_conflicts: 0,\n\t\t\tvariables_eligible: 1,\n\t\t});\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get tracking information from post-push results","suites":["Source Control"],"updatePoint":{"line":225,"column":59},"line":225,"code":"\tit('should get tracking information from post-push results', () => {\n\t\tconst trackingResult = getTrackingInformationFromPostPushResult(pushResult);\n\t\texpect(trackingResult).toEqual({\n\t\t\tworkflows_pushed: 2,\n\t\t\tworkflows_eligible: 3,\n\t\t\tcreds_pushed: 1,\n\t\t\tvariables_pushed: 1,\n\t\t});\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get tracking information from pull results","suites":["Source Control"],"updatePoint":{"line":235,"column":54},"line":235,"code":"\tit('should get tracking information from pull results', () => {\n\t\tconst trackingResult = getTrackingInformationFromPullResult(pullResult);\n\t\texpect(trackingResult).toEqual({\n\t\t\tcred_conflicts: 1,\n\t\t\tworkflow_conflicts: 1,\n\t\t\tworkflow_updates: 3,\n\t\t});\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should class validate correct preferences","suites":["Source Control"],"updatePoint":{"line":244,"column":46},"line":244,"code":"\tit('should class validate correct preferences', async () => {\n\t\tconst validPreferences = {\n\t\t\tbranchName: 'main',\n\t\t\trepositoryUrl: 'git@example.com:n8ntest/n8n_testrepo.git',\n\t\t\tbranchReadOnly: false,\n\t\t\tbranchColor: '#5296D6',\n\t\t};\n\t\tconst validationResult = await Container.get(\n\t\t\tSourceControlPreferencesService,\n\t\t).validateSourceControlPreferences(validPreferences);\n\t\texpect(validationResult).toBeTruthy();\n\t});","file":"unit/SourceControl.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should call track method","suites":["Telemetry","trackN8nStop"],"updatePoint":{"line":65,"column":32},"line":65,"code":"\t\ttest('should call track method', async () => {\n\t\t\tawait telemetry.trackN8nStop();\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should count executions correctly","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":76,"column":41},"line":76,"code":"\t\ttest('should count executions correctly', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: true,\n\t\t\t\tsuccess: true,\n\t\t\t\terror_node_type: 'custom-nodes-base.node-type',\n\t\t\t};\n\n\t\t\tpayload.is_manual = true;\n\t\t\tpayload.success = true;\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = true;\n\t\t\tconst execTime2 = fakeJestSystemTime('2022-01-01 13:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = true;\n\t\t\tpayload.success = false;\n\t\t\tconst execTime3 = fakeJestSystemTime('2022-01-01 14:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = false;\n\t\t\tconst execTime4 = fakeJestSystemTime('2022-01-01 15:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\tconst execBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime3);\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime4);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fire \"Workflow execution errored\" event for failed executions","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":126,"column":76},"line":126,"code":"\t\ttest('should fire \"Workflow execution errored\" event for failed executions', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: true,\n\t\t\t\tsuccess: false,\n\t\t\t\terror_node_type: 'custom-nodes-base.node-type',\n\t\t\t};\n\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tlet execBuffer = telemetry.getCountsBuffer();\n\n\t\t\t// should not fire event for custom nodes\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime1);\n\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.node-type';\n\t\t\tfakeJestSystemTime('2022-01-01 13:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\t// should fire event for custom nodes\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(2);\n\t\t\texpect(spyTrack).toHaveBeenCalledWith('Workflow execution errored', payload);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(4);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should track production executions count correctly","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":161,"column":58},"line":161,"code":"\t\ttest('should track production executions count correctly', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: false,\n\t\t\t\tsuccess: true,\n\t\t\t\terror_node_type: 'node_type',\n\t\t\t};\n\n\t\t\t// successful execution\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\tlet execBuffer = telemetry.getCountsBuffer();\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(1);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// successful execution n8n node\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '2';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(1);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(1);\n\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// additional successful execution\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '2';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '1';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// failed execution\n\t\t\tconst execTime2 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tpayload.error_node_type = 'custom-package.custom-node';\n\t\t\tpayload.success = false;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(1);\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// failed execution n8n node\n\t\t\tpayload.success = false;\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.is_manual = true;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(1);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(1);\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(1);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a message with path and method","suites":["utils test webhookNotFoundErrorMessage "],"updatePoint":{"line":4,"column":49},"line":4,"code":"\tit('should return a message with path and method', () => {\n\t\tconst message = webhookNotFoundErrorMessage('webhook12345', 'GET');\n\n\t\texpect(message).toEqual('The requested webhook \"GET webhook12345\" is not registered.');\n\t});","file":"unit/utils.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a message with path","suites":["utils test webhookNotFoundErrorMessage "],"updatePoint":{"line":9,"column":38},"line":9,"code":"\tit('should return a message with path', () => {\n\t\tconst message = webhookNotFoundErrorMessage('webhook12345');\n\n\t\texpect(message).toEqual('The requested webhook \"webhook12345\" is not registered.');\n\t});","file":"unit/utils.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a message with method with tip","suites":["utils test webhookNotFoundErrorMessage "],"updatePoint":{"line":14,"column":49},"line":14,"code":"\tit('should return a message with method with tip', () => {\n\t\tconst message = webhookNotFoundErrorMessage('webhook12345', 'POST', ['GET', 'PUT']);\n\n\t\texpect(message).toEqual(\n\t\t\t'This webhook is not registered for POST requests. Did you mean to make a GET or PUT request?',\n\t\t);\n\t});","file":"unit/utils.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a message with method with tip","suites":["utils test webhookNotFoundErrorMessage "],"updatePoint":{"line":21,"column":49},"line":21,"code":"\tit('should return a message with method with tip', () => {\n\t\tconst message = webhookNotFoundErrorMessage('webhook12345', 'POST', ['PUT']);\n\n\t\texpect(message).toEqual(\n\t\t\t'This webhook is not registered for POST requests. Did you mean to make a PUT request?',\n\t\t);\n\t});","file":"unit/utils.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return a message with method with tip","suites":["utils test webhookNotFoundErrorMessage "],"updatePoint":{"line":28,"column":49},"line":28,"code":"\tit('should return a message with method with tip', () => {\n\t\tconst message = webhookNotFoundErrorMessage('webhook12345', 'POST', ['GET', 'PUT', 'DELETE']);\n\n\t\texpect(message).toEqual(\n\t\t\t'This webhook is not registered for POST requests. Did you mean to make a GET, PUT or DELETE request?',\n\t\t);\n\t});","file":"unit/utils.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle preflight requests","suites":["WebhookServer","CORS","for "],"updatePoint":{"line":45,"column":40},"line":45,"code":"\t\t\t\tit('should handle preflight requests', async () => {\n\t\t\t\t\tconst pathPrefix = config.getEnv(`endpoints.${key}`);\n\t\t\t\t\tmanager.getWebhookMethods.mockResolvedValueOnce(['GET']);\n\n\t\t\t\t\tconst response = await agent.options(`/${pathPrefix}/abcd`).set('origin', corsOrigin);\n\t\t\t\t\texpect(response.statusCode).toEqual(204);\n\t\t\t\t\texpect(response.body).toEqual({});\n\t\t\t\t\texpect(response.headers['access-control-allow-origin']).toEqual(corsOrigin);\n\t\t\t\t\texpect(response.headers['access-control-allow-methods']).toEqual('OPTIONS, GET');\n\t\t\t\t});","file":"unit/webhooks.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle regular requests","suites":["WebhookServer","CORS","for "],"updatePoint":{"line":56,"column":38},"line":56,"code":"\t\t\t\tit('should handle regular requests', async () => {\n\t\t\t\t\tconst pathPrefix = config.getEnv(`endpoints.${key}`);\n\t\t\t\t\tmanager.getWebhookMethods.mockResolvedValueOnce(['GET']);\n\t\t\t\t\tmanager.executeWebhook.mockResolvedValueOnce(\n\t\t\t\t\t\tmockResponse({ test: true }, { key: 'value ' }),\n\t\t\t\t\t);\n\n\t\t\t\t\tconst response = await agent.get(`/${pathPrefix}/abcd`).set('origin', corsOrigin);\n\t\t\t\t\texpect(response.statusCode).toEqual(200);\n\t\t\t\t\texpect(response.body).toEqual({ test: true });\n\t\t\t\t\texpect(response.headers['access-control-allow-origin']).toEqual(corsOrigin);\n\t\t\t\t\texpect(response.headers.key).toEqual('value');\n\t\t\t\t});","file":"unit/webhooks.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an error if any node has no credential ID","suites":["WorkflowCredentials"],"updatePoint":{"line":51,"column":62},"line":51,"code":"\ttest('Should return an error if any node has no credential ID', async () => {\n\t\tconst credentials = noIdNode.credentials!.test;\n\t\tconst expectedError = new Error(\n\t\t\t`Credentials with name \"${credentials.name}\" for type \"test\" miss an ID.`,\n\t\t);\n\t\tawait expect(WorkflowCredentials([noIdNode])).rejects.toEqual(expectedError);\n\t\texpect(mocked(Db.collections.Credentials.findOneBy)).toHaveBeenCalledTimes(0);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an error if credentials cannot be found in the DB","suites":["WorkflowCredentials"],"updatePoint":{"line":60,"column":70},"line":60,"code":"\ttest('Should return an error if credentials cannot be found in the DB', async () => {\n\t\tconst credentials = notFoundNode.credentials!.test;\n\t\tconst expectedError = new Error(\n\t\t\t`Could not find credentials for type \"test\" with ID \"${credentials.id}\".`,\n\t\t);\n\t\tawait expect(WorkflowCredentials([notFoundNode])).rejects.toEqual(expectedError);\n\t\texpect(mocked(Db.collections.Credentials.findOneBy)).toHaveBeenCalledTimes(1);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should ignore duplicates","suites":["WorkflowCredentials"],"updatePoint":{"line":69,"column":31},"line":69,"code":"\ttest('Should ignore duplicates', async () => {\n\t\tconst response = await WorkflowCredentials([validNode, validNode, validNode]);\n\t\texpect(Object.keys(response)).toEqual(['test']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should ignore Nodes with no credentials set","suites":["WorkflowCredentials"],"updatePoint":{"line":74,"column":50},"line":74,"code":"\ttest('Should ignore Nodes with no credentials set', async () => {\n\t\tconst response = await WorkflowCredentials([validNode, noCredentialsNode]);\n\t\texpect(Object.keys(response)).toEqual(['test']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should work for Nodes with multiple credentials","suites":["WorkflowCredentials"],"updatePoint":{"line":79,"column":54},"line":79,"code":"\ttest('Should work for Nodes with multiple credentials', async () => {\n\t\tconst response = await WorkflowCredentials([multiCredNode]);\n\t\texpect(Object.keys(response)).toEqual(['mcTest', 'mcTest2']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Execution metadata is saved in a batch","suites":["WorkflowExecuteAdditionalData"],"updatePoint":{"line":16,"column":45},"line":16,"code":"\ttest('Execution metadata is saved in a batch', async () => {\n\t\tconst toSave = {\n\t\t\ttest1: 'value1',\n\t\t\ttest2: 'value2',\n\t\t};\n\t\tconst executionId = '1234';\n\n\t\tawait saveExecutionMetadata(executionId, toSave);\n\n\t\texpect(mocked(Db.collections.ExecutionMetadata.save)).toHaveBeenCalledTimes(1);\n\t\texpect(mocked(Db.collections.ExecutionMetadata.save).mock.calls[0]).toEqual([\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\texecution: { id: executionId },\n\t\t\t\t\tkey: 'test1',\n\t\t\t\t\tvalue: 'value1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\texecution: { id: executionId },\n\t\t\t\t\tkey: 'test2',\n\t\t\t\t\tvalue: 'value2',\n\t\t\t\t},\n\t\t\t],\n\t\t]);\n\t});","file":"unit/WorkflowExecuteAdditionalData.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a workflow without nodes","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":27,"column":64},"line":27,"code":"\t\ttest('Should return an empty list for a workflow without nodes', () => {\n\t\t\tconst workflow = getWorkflow();\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a workflow with nodes without credentials","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":33,"column":81},"line":33,"code":"\t\ttest('Should return an empty list for a workflow with nodes without credentials', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithoutCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an element for a node with a credential without access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":39,"column":76},"line":39,"code":"\t\ttest('Should return an element for a node with a credential without access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a node with a credential with access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":45,"column":76},"line":45,"code":"\t\ttest('Should return an empty list for a node with a credential with access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an element for a node with two credentials and mixed access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":53,"column":81},"line":53,"code":"\t\ttest('Should return an element for a node with two credentials and mixed access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one node for a workflow with two nodes and two credentials","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":61,"column":80},"line":61,"code":"\t\ttest('Should return one node for a workflow with two nodes and two credentials', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t\tTHIRD_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one element for a workflows with two nodes and one credential","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":70,"column":83},"line":70,"code":"\t\ttest('Should return one element for a workflows with two nodes and one credential', () => {\n\t\t\tconst workflow = getWorkflow({\n\t\t\t\taddNodeWithoutCreds: true,\n\t\t\t\taddNodeWithOneCred: true,\n\t\t\t\taddNodeWithTwoCreds: true,\n\t\t\t});\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one element for a workflows with two nodes and partial credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":82,"column":94},"line":82,"code":"\t\ttest('Should return one element for a workflows with two nodes and partial credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return two elements for a workflows with two nodes and partial credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":91,"column":95},"line":91,"code":"\t\ttest('Should return two elements for a workflows with two nodes and partial credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(2);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return two elements for a workflows with two nodes and no credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":99,"column":90},"line":99,"code":"\t\ttest('Should return two elements for a workflows with two nodes and no credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(2);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error saving a workflow using credential without access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":107,"column":74},"line":107,"code":"\t\tit('Should throw error saving a workflow using credential without access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst previousWorkflowVersion = getWorkflow();\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, []);\n\t\t\t}).toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not throw error when saving a workflow using credential with access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":115,"column":80},"line":115,"code":"\t\tit('Should not throw error when saving a workflow using credential with access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst previousWorkflowVersion = getWorkflow();\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, [\n\t\t\t\t\tgenerateCredentialEntity(FIRST_CREDENTIAL_ID),\n\t\t\t\t]);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not throw error when saving a workflow removing node without credential access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":125,"column":91},"line":125,"code":"\t\tit('Should not throw error when saving a workflow removing node without credential access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow();\n\t\t\tconst previousWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, [\n\t\t\t\t\tgenerateCredentialEntity(FIRST_CREDENTIAL_ID),\n\t\t\t\t]);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should save fine when not making changes to workflow without access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":135,"column":73},"line":135,"code":"\t\tit('Should save fine when not making changes to workflow without access', () => {\n\t\t\tconst workflowWithOneCredential = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(workflowWithOneCredential, workflowWithOneCredential, []);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error saving a workflow adding node without credential access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":142,"column":80},"line":142,"code":"\t\tit('Should throw error saving a workflow adding node without credential access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({\n\t\t\t\taddNodeWithOneCred: true,\n\t\t\t\taddNodeWithTwoCreds: true,\n\t\t\t});\n\t\t\tconst previousWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, []);\n\t\t\t}).toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return undefined","suites":["WorkflowHelpers","getExecutionStartNode"],"updatePoint":{"line":154,"column":29},"line":154,"code":"\t\tit('Should return undefined', () => {\n\t\t\tconst data = {\n\t\t\t\tpinData: {},\n\t\t\t\tstartNodes: [],\n\t\t\t} as unknown as IWorkflowExecutionDataProcess;\n\t\t\tconst workflow = {\n\t\t\t\tgetNode(nodeName: string) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: nodeName,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t} as unknown as Workflow;\n\t\t\tconst executionStartNode = getExecutionStartNode(data, workflow);\n\t\t\texpect(executionStartNode).toBeUndefined();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return startNode","suites":["WorkflowHelpers","getExecutionStartNode"],"updatePoint":{"line":169,"column":29},"line":169,"code":"\t\tit('Should return startNode', () => {\n\t\t\tconst data = {\n\t\t\t\tpinData: {\n\t\t\t\t\tnode1: {},\n\t\t\t\t\tnode2: {},\n\t\t\t\t},\n\t\t\t\tstartNodes: ['node2'],\n\t\t\t} as unknown as IWorkflowExecutionDataProcess;\n\t\t\tconst workflow = {\n\t\t\t\tgetNode(nodeName: string) {\n\t\t\t\t\tif (nodeName === 'node2') {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tname: 'node2',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t} as unknown as Workflow;\n\t\t\tconst executionStartNode = getExecutionStartNode(data, workflow);\n\t\t\texpect(executionStartNode).toEqual({\n\t\t\t\tname: 'node2',\n\t\t\t});\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":5,"column":72},"line":5,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', []);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\t// const nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data with initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":18,"column":69},"line":18,"code":"\t\ttest('should be able to set and read key data with initial data set', () => {\n\t\t\tconst key = 'key2';\n\t\t\tconst password = 'password';\n\n\t\t\t// Saved under \"key1\"\n\t\t\tconst initialData = 4321;\n\t\t\tconst initialDataEncoded = 'U2FsdGVkX1+0baznXt+Ag/ub8A2kHLyoLxn/rR9h4XQ=';\n\n\t\t\tconst credentials = new Credentials(\n\t\t\t\t{ id: null, name: 'testName' },\n\t\t\t\t'testType',\n\t\t\t\t[],\n\t\t\t\tinitialDataEncoded,\n\t\t\t);\n\n\t\t\tconst newData = 1234;\n\n\t\t\t// Set and read new data\n\t\t\tcredentials.setDataKey(key, newData, password);\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\n\t\t\t// Read the data which got provided encrypted on init\n\t\t\texpect(credentials.getDataKey('key1', password)).toEqual(initialData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","with nodeType set"],"updatePoint":{"line":45,"column":72},"line":45,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst nodeAccess = [\n\t\t\t\t{\n\t\t\t\t\tnodeType: 'base.noOp',\n\t\t\t\t\tuser: 'userName',\n\t\t\t\t\tdate: new Date(),\n\t\t\t\t},\n\t\t\t];\n\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', nodeAccess);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\tconst nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\t// Should be able to read with nodeType which has access\n\t\t\texpect(credentials.getDataKey(key, password, nodeType)).toEqual(newData);\n\n\t\t\t// Should not be able to read with nodeType which does NOT have access\n\t\t\t// expect(credentials.getDataKey(key, password, 'base.otherNode')).toThrowError(Error);\n\t\t\ttry {\n\t\t\t\tcredentials.getDataKey(key, password, 'base.otherNode');\n\t\t\t\texpect(true).toBe(false);\n\t\t\t} catch (e) {\n\t\t\t\texpect(e.message).toBe(\n\t\t\t\t\t'The node of type \"base.otherNode\" does not have access to credentials \"testName\" of type \"testType\".',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get the data which will be saved in database\n\t\t\tconst dbData = credentials.getDataToSave();\n\t\t\texpect(dbData.name).toEqual('testName');\n\t\t\texpect(dbData.type).toEqual('testType');\n\t\t\texpect(dbData.nodesAccess).toEqual(nodeAccess);\n\t\t\t// Compare only the first 6 characters as the rest seems to change with each execution\n\t\t\texpect(dbData.data!.slice(0, 6)).toEqual(\n\t\t\t\t'U2FsdGVkX1+wpQWkj+YTzaPSNTFATjnlmFKIsUTZdhk='.slice(0, 6),\n\t\t\t);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'default' mode","suites":["NodeExecuteFunctions","test binary data helper methods"],"updatePoint":{"line":31,"column":90},"line":31,"code":"\t\ttest(\"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'default' mode\", async () => {\n\t\t\t// Setup a 'default' binary data manager instance\n\t\t\tawait BinaryDataManager.init({\n\t\t\t\tmode: 'default',\n\t\t\t\tavailableModes: 'default',\n\t\t\t\tlocalStoragePath: temporaryDir,\n\t\t\t\tbinaryDataTTL: 1,\n\t\t\t\tpersistedBinaryDataTTL: 1,\n\t\t\t});\n\n\t\t\t// Set our binary data buffer\n\t\t\tconst inputData: Buffer = Buffer.from('This is some binary data', 'utf8');\n\t\t\tconst setBinaryDataBufferResponse: IBinaryData = await setBinaryDataBuffer(\n\t\t\t\t{\n\t\t\t\t\tmimeType: 'txt',\n\t\t\t\t\tdata: 'This should be overwritten by the actual payload in the response',\n\t\t\t\t},\n\t\t\t\tinputData,\n\t\t\t\t'executionId',\n\t\t\t);\n\n\t\t\t// Expect our return object to contain the base64 encoding of the input data, as it should be stored in memory.\n\t\t\texpect(setBinaryDataBufferResponse.data).toEqual(inputData.toString('base64'));\n\n\t\t\t// Now, re-fetch our data.\n\t\t\t// An ITaskDataConnections object is used to share data between nodes. The top level property, 'main', represents the successful output object from a previous node.\n\t\t\tconst taskDataConnectionsInput: ITaskDataConnections = {\n\t\t\t\tmain: [],\n\t\t\t};\n\n\t\t\t// We add an input set, with one item at index 0, to this input. It contains an empty json payload and our binary data.\n\t\t\ttaskDataConnectionsInput.main.push([\n\t\t\t\t{\n\t\t\t\t\tjson: {},\n\t\t\t\t\tbinary: {\n\t\t\t\t\t\tdata: setBinaryDataBufferResponse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\t// Now, lets fetch our data! The item will be item index 0.\n\t\t\tconst getBinaryDataBufferResponse: Buffer = await getBinaryDataBuffer(\n\t\t\t\ttaskDataConnectionsInput,\n\t\t\t\t0,\n\t\t\t\t'data',\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\texpect(getBinaryDataBufferResponse).toEqual(inputData);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'filesystem' mode","suites":["NodeExecuteFunctions","test binary data helper methods"],"updatePoint":{"line":82,"column":93},"line":82,"code":"\t\ttest(\"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'filesystem' mode\", async () => {\n\t\t\t// Setup a 'filesystem' binary data manager instance\n\t\t\tawait BinaryDataManager.init({\n\t\t\t\tmode: 'filesystem',\n\t\t\t\tavailableModes: 'filesystem',\n\t\t\t\tlocalStoragePath: temporaryDir,\n\t\t\t\tbinaryDataTTL: 1,\n\t\t\t\tpersistedBinaryDataTTL: 1,\n\t\t\t});\n\n\t\t\t// Set our binary data buffer\n\t\t\tconst inputData: Buffer = Buffer.from('This is some binary data', 'utf8');\n\t\t\tconst setBinaryDataBufferResponse: IBinaryData = await setBinaryDataBuffer(\n\t\t\t\t{\n\t\t\t\t\tmimeType: 'txt',\n\t\t\t\t\tdata: 'This should be overwritten with the name of the configured data manager',\n\t\t\t\t},\n\t\t\t\tinputData,\n\t\t\t\t'executionId',\n\t\t\t);\n\n\t\t\t// Expect our return object to contain the name of the configured data manager.\n\t\t\texpect(setBinaryDataBufferResponse.data).toEqual('filesystem');\n\n\t\t\t// Ensure that the input data was successfully persisted to disk.\n\t\t\texpect(\n\t\t\t\treadFileSync(\n\t\t\t\t\t`${temporaryDir}/${setBinaryDataBufferResponse.id?.replace('filesystem:', '')}`,\n\t\t\t\t),\n\t\t\t).toEqual(inputData);\n\n\t\t\t// Now, re-fetch our data.\n\t\t\t// An ITaskDataConnections object is used to share data between nodes. The top level property, 'main', represents the successful output object from a previous node.\n\t\t\tconst taskDataConnectionsInput: ITaskDataConnections = {\n\t\t\t\tmain: [],\n\t\t\t};\n\n\t\t\t// We add an input set, with one item at index 0, to this input. It contains an empty json payload and our binary data.\n\t\t\ttaskDataConnectionsInput.main.push([\n\t\t\t\t{\n\t\t\t\t\tjson: {},\n\t\t\t\t\tbinary: {\n\t\t\t\t\t\tdata: setBinaryDataBufferResponse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\t// Now, lets fetch our data! The item will be item index 0.\n\t\t\tconst getBinaryDataBufferResponse: Buffer = await getBinaryDataBuffer(\n\t\t\t\ttaskDataConnectionsInput,\n\t\t\t\t0,\n\t\t\t\t'data',\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\texpect(getBinaryDataBufferResponse).toEqual(inputData);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw if the response status is 200","suites":["NodeExecuteFunctions","proxyRequestToAxios"],"updatePoint":{"line":153,"column":54},"line":153,"code":"\t\ttest('should not throw if the response status is 200', async () => {\n\t\t\tnock(baseUrl).get('/test').reply(200);\n\t\t\tawait proxyRequestToAxios(workflow, additionalData, node, `${baseUrl}/test`);\n\t\t\texpect(hooks.executeHookFunctions).toHaveBeenCalledWith('nodeFetchedData', [\n\t\t\t\tworkflow.id,\n\t\t\t\tnode,\n\t\t\t]);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw if the response status is 403","suites":["NodeExecuteFunctions","proxyRequestToAxios"],"updatePoint":{"line":162,"column":50},"line":162,"code":"\t\ttest('should throw if the response status is 403', async () => {\n\t\t\tconst headers = { 'content-type': 'text/plain' };\n\t\t\tnock(baseUrl).get('/test').reply(403, 'Forbidden', headers);\n\t\t\ttry {\n\t\t\t\tawait proxyRequestToAxios(workflow, additionalData, node, `${baseUrl}/test`);\n\t\t\t} catch (error) {\n\t\t\t\texpect(error.statusCode).toEqual(403);\n\t\t\t\texpect(error.request).toBeUndefined();\n\t\t\t\texpect(error.response).toMatchObject({ headers, status: 403 });\n\t\t\t\texpect(error.options).toMatchObject({\n\t\t\t\t\theaders: { Accept: '*/*' },\n\t\t\t\t\tmethod: 'get',\n\t\t\t\t\turl: 'http://example.de/test',\n\t\t\t\t});\n\t\t\t\texpect(error.config).toBeUndefined();\n\t\t\t\texpect(error.message).toEqual('403 - \"Forbidden\"');\n\t\t\t}\n\t\t\texpect(hooks.executeHookFunctions).not.toHaveBeenCalled();\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw if the response status is 404, but `simple` option is set to `false`","suites":["NodeExecuteFunctions","proxyRequestToAxios"],"updatePoint":{"line":182,"column":93},"line":182,"code":"\t\ttest('should not throw if the response status is 404, but `simple` option is set to `false`', async () => {\n\t\t\tnock(baseUrl).get('/test').reply(404, 'Not Found');\n\t\t\tconst response = await proxyRequestToAxios(workflow, additionalData, node, {\n\t\t\t\turl: `${baseUrl}/test`,\n\t\t\t\tsimple: false,\n\t\t\t});\n\n\t\t\texpect(response).toEqual('Not Found');\n\t\t\texpect(hooks.executeHookFunctions).toHaveBeenCalledWith('nodeFetchedData', [\n\t\t\t\tworkflow.id,\n\t\t\t\tnode,\n\t\t\t]);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return full response when `resolveWithFullResponse` is set to true","suites":["NodeExecuteFunctions","proxyRequestToAxios"],"updatePoint":{"line":196,"column":81},"line":196,"code":"\t\ttest('should return full response when `resolveWithFullResponse` is set to true', async () => {\n\t\t\tnock(baseUrl).get('/test').reply(404, 'Not Found');\n\t\t\tconst response = await proxyRequestToAxios(workflow, additionalData, node, {\n\t\t\t\turl: `${baseUrl}/test`,\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\tsimple: false,\n\t\t\t});\n\n\t\t\texpect(response).toMatchObject({\n\t\t\t\tbody: 'Not Found',\n\t\t\t\theaders: {},\n\t\t\t\tstatusCode: 404,\n\t\t\t\tstatusMessage: null,\n\t\t\t});\n\t\t\texpect(hooks.executeHookFunctions).toHaveBeenCalledWith('nodeFetchedData', [\n\t\t\t\tworkflow.id,\n\t\t\t\tnode,\n\t\t\t]);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata will set a value","suites":["Execution Metadata functions"],"updatePoint":{"line":25,"column":52},"line":25,"code":"\ttest('setWorkflowExecutionMetadata will set a value', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tsetWorkflowExecutionMetadata(executionData, 'test1', 'value1');\n\n\t\texpect(metadata).toEqual({\n\t\t\ttest1: 'value1',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setAllWorkflowExecutionMetadata will set multiple values","suites":["Execution Metadata functions"],"updatePoint":{"line":40,"column":63},"line":40,"code":"\ttest('setAllWorkflowExecutionMetadata will set multiple values', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tsetAllWorkflowExecutionMetadata(executionData, {\n\t\t\ttest1: 'value1',\n\t\t\ttest2: 'value2',\n\t\t});\n\n\t\texpect(metadata).toEqual({\n\t\t\ttest1: 'value1',\n\t\t\ttest2: 'value2',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata should only convert numbers to strings","suites":["Execution Metadata functions"],"updatePoint":{"line":59,"column":74},"line":59,"code":"\ttest('setWorkflowExecutionMetadata should only convert numbers to strings', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(() => setWorkflowExecutionMetadata(executionData, 'test1', 1234)).not.toThrow(\n\t\t\tExecutionMetadataValidationError,\n\t\t);\n\n\t\texpect(metadata).toEqual({\n\t\t\ttest1: '1234',\n\t\t});\n\n\t\texpect(() => setWorkflowExecutionMetadata(executionData, 'test2', {})).toThrow(\n\t\t\tExecutionMetadataValidationError,\n\t\t);\n\n\t\texpect(metadata).not.toEqual({\n\t\t\ttest1: '1234',\n\t\t\ttest2: {},\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setAllWorkflowExecutionMetadata should not convert values to strings and should set other values correctly","suites":["Execution Metadata functions"],"updatePoint":{"line":85,"column":113},"line":85,"code":"\ttest('setAllWorkflowExecutionMetadata should not convert values to strings and should set other values correctly', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(() =>\n\t\t\tsetAllWorkflowExecutionMetadata(executionData, {\n\t\t\t\ttest1: {} as unknown as string,\n\t\t\t\ttest2: [] as unknown as string,\n\t\t\t\ttest3: 'value3',\n\t\t\t\ttest4: 'value4',\n\t\t\t}),\n\t\t).toThrow(ExecutionMetadataValidationError);\n\n\t\texpect(metadata).toEqual({\n\t\t\ttest3: 'value3',\n\t\t\ttest4: 'value4',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata should validate key characters","suites":["Execution Metadata functions"],"updatePoint":{"line":108,"column":66},"line":108,"code":"\ttest('setWorkflowExecutionMetadata should validate key characters', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(() => setWorkflowExecutionMetadata(executionData, 'te$t1$', 1234)).toThrow(\n\t\t\tExecutionMetadataValidationError,\n\t\t);\n\n\t\texpect(metadata).not.toEqual({\n\t\t\ttest1: '1234',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata should limit the number of metadata entries","suites":["Execution Metadata functions"],"updatePoint":{"line":125,"column":79},"line":125,"code":"\ttest('setWorkflowExecutionMetadata should limit the number of metadata entries', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tconst expected: Record<string, string> = {};\n\t\tfor (let i = 0; i < KV_LIMIT; i++) {\n\t\t\texpected[`test${i + 1}`] = `value${i + 1}`;\n\t\t}\n\n\t\tfor (let i = 0; i < KV_LIMIT + 10; i++) {\n\t\t\tsetWorkflowExecutionMetadata(executionData, `test${i + 1}`, `value${i + 1}`);\n\t\t}\n\n\t\texpect(metadata).toEqual(expected);\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"getWorkflowExecutionMetadata should return a single value for an existing key","suites":["Execution Metadata functions"],"updatePoint":{"line":145,"column":84},"line":145,"code":"\ttest('getWorkflowExecutionMetadata should return a single value for an existing key', () => {\n\t\tconst metadata: Record<string, string> = { test1: 'value1' };\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(getWorkflowExecutionMetadata(executionData, 'test1')).toBe('value1');\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"getWorkflowExecutionMetadata should return undefined for an unset key","suites":["Execution Metadata functions"],"updatePoint":{"line":156,"column":76},"line":156,"code":"\ttest('getWorkflowExecutionMetadata should return undefined for an unset key', () => {\n\t\tconst metadata: Record<string, string> = { test1: 'value1' };\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(getWorkflowExecutionMetadata(executionData, 'test2')).toBeUndefined();\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"getAllWorkflowExecutionMetadata should return all metadata","suites":["Execution Metadata functions"],"updatePoint":{"line":167,"column":65},"line":167,"code":"\ttest('getAllWorkflowExecutionMetadata should return all metadata', () => {\n\t\tconst metadata: Record<string, string> = { test1: 'value1', test2: 'value2' };\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\texpect(getAllWorkflowExecutionMetadata(executionData)).toEqual(metadata);\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"getAllWorkflowExecutionMetadata should not an object that modifies internal state","suites":["Execution Metadata functions"],"updatePoint":{"line":178,"column":88},"line":178,"code":"\ttest('getAllWorkflowExecutionMetadata should not an object that modifies internal state', () => {\n\t\tconst metadata: Record<string, string> = { test1: 'value1', test2: 'value2' };\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tgetAllWorkflowExecutionMetadata(executionData).test1 = 'changed';\n\n\t\texpect(metadata.test1).not.toBe('changed');\n\t\texpect(metadata.test1).toBe('value1');\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata should truncate long keys","suites":["Execution Metadata functions"],"updatePoint":{"line":192,"column":61},"line":192,"code":"\ttest('setWorkflowExecutionMetadata should truncate long keys', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tsetWorkflowExecutionMetadata(\n\t\t\texecutionData,\n\t\t\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab',\n\t\t\t'value1',\n\t\t);\n\n\t\texpect(metadata).toEqual({\n\t\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: 'value1',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"setWorkflowExecutionMetadata should truncate long values","suites":["Execution Metadata functions"],"updatePoint":{"line":211,"column":63},"line":211,"code":"\ttest('setWorkflowExecutionMetadata should truncate long values', () => {\n\t\tconst metadata = {};\n\t\tconst executionData = {\n\t\t\tresultData: {\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t} as IRunExecutionData;\n\n\t\tsetWorkflowExecutionMetadata(\n\t\t\texecutionData,\n\t\t\t'test1',\n\t\t\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab',\n\t\t);\n\n\t\texpect(metadata).toEqual({\n\t\t\ttest1:\n\t\t\t\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n\t\t});\n\t});","file":"WorkflowExecutionMetadata.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"runs query to update db","suites":["pgUpdate"],"updatePoint":{"line":7,"column":28},"line":7,"code":"\tit('runs query to update db', async () => {\n\t\tconst updateItem = { id: 1234, name: 'test' };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'update \"myschema\".\"mytable\" as t set \"id\"=v.\"id\",\"name\"=v.\"name\" from (values(1234,\\'test\\')) as v(\"id\",\"name\") WHERE v.\"id\" = t.\"id\" RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db if updateKey is not in columns","suites":["pgUpdate"],"updatePoint":{"line":35,"column":59},"line":35,"code":"\tit('runs query to update db if updateKey is not in columns', async () => {\n\t\tconst updateItem = { id: 1234, name: 'test' };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tconst results = await PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'update \"myschema\".\"mytable\" as t set \"id\"=v.\"id\",\"name\"=v.\"name\" from (values(1234,\\'test\\')) as v(\"id\",\"name\") WHERE v.\"id\" = t.\"id\" RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast as updateKey","suites":["pgUpdate"],"updatePoint":{"line":63,"column":51},"line":63,"code":"\tit('runs query to update db with cast as updateKey', async () => {\n\t\tconst updateItem = { id: '1234', name: 'test' };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id:uuid',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'update \"myschema\".\"mytable\" as t set \"id\"=v.\"id\",\"name\"=v.\"name\" from (values(\\'1234\\'::uuid,\\'test\\')) as v(\"id\",\"name\") WHERE v.\"id\" = t.\"id\" RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast in target columns","suites":["pgUpdate"],"updatePoint":{"line":91,"column":56},"line":91,"code":"\tit('runs query to update db with cast in target columns', async () => {\n\t\tconst updateItem = { id: '1234', name: 'test' };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id:uuid,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'update \"myschema\".\"mytable\" as t set \"id\"=v.\"id\",\"name\"=v.\"name\" from (values(\\'1234\\'::uuid,\\'test\\')) as v(\"id\",\"name\") WHERE v.\"id\" = t.\"id\" RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert","suites":["pgInsert"],"updatePoint":{"line":121,"column":25},"line":121,"code":"\tit('runs query to insert', async () => {\n\t\tconst insertItem = { id: 1234, name: 'test', age: 34 };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id,name,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'insert into \"myschema\".\"mytable\"(\"id\",\"name\",\"age\") values(1234,\\'test\\',34) RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert with type casting","suites":["pgInsert"],"updatePoint":{"line":148,"column":43},"line":148,"code":"\tit('runs query to insert with type casting', async () => {\n\t\tconst insertItem = { id: 1234, name: 'test', age: 34 };\n\t\tconst nodeParams: NodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id:int,name:text,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key: string) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t'insert into \"myschema\".\"mytable\"(\"id\",\"name\",\"age\") values(1234::int,\\'test\\'::text,34) RETURNING *',\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"it should adjust multiple metadata values","suites":["adjustMetadata"],"updatePoint":{"line":4,"column":46},"line":4,"code":"\tit('it should adjust multiple metadata values', async () => {\n\t\tconst additionalFieldsValues = {\n\t\t\tmetadata: {\n\t\t\t\tmetadataProperties: [\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: 'keyA',\n\t\t\t\t\t\tvalue: 'valueA',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: 'keyB',\n\t\t\t\t\t\tvalue: 'valueB',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t};\n\n\t\tconst adjustedMetadata = helpers.adjustMetadata(additionalFieldsValues);\n\n\t\tconst expectedAdjustedMetadata = {\n\t\t\tmetadata: {\n\t\t\t\tkeyA: 'valueA',\n\t\t\t\tkeyB: 'valueB',\n\t\t\t},\n\t\t};\n\t\texpect(adjustedMetadata).toStrictEqual(expectedAdjustedMetadata);\n\t});","file":"nodes/Stripe/helpers.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should do strict comparison","suites":["Test fuzzyCompare"],"updatePoint":{"line":5,"column":32},"line":5,"code":"\tit('should do strict comparison', () => {\n\t\tconst compareFunction = fuzzyCompare(false);\n\n\t\texpect(compareFunction(1, '1')).toEqual(false);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should do fuzzy comparison","suites":["Test fuzzyCompare"],"updatePoint":{"line":11,"column":31},"line":11,"code":"\tit('should do fuzzy comparison', () => {\n\t\tconst compareFunction = fuzzyCompare(true);\n\n\t\texpect(compareFunction(1, '1')).toEqual(true);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should treat null, 0 and \"0\" as equal","suites":["Test fuzzyCompare"],"updatePoint":{"line":17,"column":42},"line":17,"code":"\tit('should treat null, 0 and \"0\" as equal', () => {\n\t\tconst compareFunction = fuzzyCompare(true, 2);\n\n\t\texpect(compareFunction(null, null)).toEqual(true);\n\t\texpect(compareFunction(null, 0)).toEqual(true);\n\t\texpect(compareFunction(null, '0')).toEqual(true);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should not treat null, 0 and \"0\" as equal","suites":["Test fuzzyCompare"],"updatePoint":{"line":25,"column":46},"line":25,"code":"\tit('should not treat null, 0 and \"0\" as equal', () => {\n\t\tconst compareFunction = fuzzyCompare(true);\n\n\t\texpect(compareFunction(null, 0)).toEqual(false);\n\t\texpect(compareFunction(null, '0')).toEqual(false);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should wrap object in json","suites":["Test wrapData"],"updatePoint":{"line":34,"column":31},"line":34,"code":"\tit('should wrap object in json', () => {\n\t\tconst data = {\n\t\t\tid: 1,\n\t\t\tname: 'Name',\n\t\t};\n\t\tconst wrappedData = wrapData(data);\n\t\texpect(wrappedData).toBeDefined();\n\t\texpect(wrappedData).toEqual([{ json: data }]);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should wrap each object in array in json","suites":["Test wrapData"],"updatePoint":{"line":43,"column":45},"line":43,"code":"\tit('should wrap each object in array in json', () => {\n\t\tconst data = [\n\t\t\t{\n\t\t\t\tid: 1,\n\t\t\t\tname: 'Name',\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 2,\n\t\t\t\tname: 'Name 2',\n\t\t\t},\n\t\t];\n\t\tconst wrappedData = wrapData(data);\n\t\texpect(wrappedData).toBeDefined();\n\t\texpect(wrappedData).toEqual([{ json: data[0] }, { json: data[1] }]);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"json key from source should be inside json","suites":["Test wrapData"],"updatePoint":{"line":58,"column":47},"line":58,"code":"\tit('json key from source should be inside json', () => {\n\t\tconst data = {\n\t\t\tjson: {\n\t\t\t\tid: 1,\n\t\t\t\tname: 'Name',\n\t\t\t},\n\t\t};\n\t\tconst wrappedData = wrapData(data);\n\t\texpect(wrappedData).toBeDefined();\n\t\texpect(wrappedData).toEqual([{ json: data }]);\n\t\texpect(Object.keys(wrappedData[0].json)).toContain('json');\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should convert keys to lowercase","suites":["Test keysToLowercase"],"updatePoint":{"line":73,"column":37},"line":73,"code":"\tit('should convert keys to lowercase', () => {\n\t\tconst headers = {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'X-Test-Header': 'Test',\n\t\t\tAccept: 'application/json',\n\t\t};\n\n\t\tconst newHeaders = keysToLowercase(headers);\n\n\t\texpect(newHeaders).toEqual({\n\t\t\t'content-type': 'application/json',\n\t\t\t'x-test-header': 'Test',\n\t\t\taccept: 'application/json',\n\t\t});\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should return original value if it is not an object","suites":["Test keysToLowercase"],"updatePoint":{"line":88,"column":56},"line":88,"code":"\tit('should return original value if it is not an object', () => {\n\t\tconst test1 = keysToLowercase(['hello']);\n\t\tconst test2 = keysToLowercase('test');\n\t\tconst test3 = keysToLowercase(1);\n\t\tconst test4 = keysToLowercase(true);\n\t\tconst test5 = keysToLowercase(null);\n\t\tconst test6 = keysToLowercase(undefined);\n\n\t\texpect(test1).toEqual(['hello']);\n\t\texpect(test2).toEqual('test');\n\t\texpect(test3).toEqual(1);\n\t\texpect(test4).toEqual(true);\n\t\texpect(test5).toEqual(null);\n\t\texpect(test6).toEqual(undefined);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should return empty array when there are no resolvables","suites":["Test getResolvables"],"updatePoint":{"line":106,"column":60},"line":106,"code":"\tit('should return empty array when there are no resolvables', () => {\n\t\texpect(getResolvables('Plain String, no resolvables here.')).toEqual([]);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should properly handle resovables in SQL query","suites":["Test getResolvables"],"updatePoint":{"line":109,"column":51},"line":109,"code":"\tit('should properly handle resovables in SQL query', () => {\n\t\texpect(getResolvables('SELECT * FROM {{ $json.db }}.{{ $json.table }};')).toEqual([\n\t\t\t'{{ $json.db }}',\n\t\t\t'{{ $json.table }}',\n\t\t]);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should properly handle resovables in HTML string","suites":["Test getResolvables"],"updatePoint":{"line":115,"column":53},"line":115,"code":"\tit('should properly handle resovables in HTML string', () => {\n\t\texpect(\n\t\t\tgetResolvables(\n\t\t\t\t`\n\t\t\t\t<!DOCTYPE html>\n\t\t\t\t<html>\n\t\t\t\t\t<head><title>{{ $json.pageTitle }}</title></head>\n\t\t\t\t\t<body><h1>{{ $json.heading }}</h1></body>\n\t\t\t\t<html>\n\t\t\t\t<style>\n\t\t\t\t\tbody { height: {{ $json.pageHeight }}; }\n\t\t\t\t</style>\n\t\t\t\t<script>\n\t\t\t\t\tconsole.log('{{ $json.welcomeMessage }}');\n\t\t\t\t</script>\n\t\t\t\t`,\n\t\t\t),\n\t\t).toEqual([\n\t\t\t'{{ $json.pageTitle }}',\n\t\t\t'{{ $json.heading }}',\n\t\t\t'{{ $json.pageHeight }}',\n\t\t\t'{{ $json.welcomeMessage }}',\n\t\t]);\n\t});","file":"utils/utilities.test.ts","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should work with arrays","suites":["AugmentObject","augmentArray"],"updatePoint":{"line":7,"column":31},"line":7,"code":"\t\ttest('should work with arrays', () => {\n\t\t\tconst originalObject = [1, 2, 3, 4, null];\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentArray(originalObject);\n\n\t\t\texpect(augmentedObject.push(5)).toEqual(6);\n\t\t\texpect(augmentedObject).toEqual([1, 2, 3, 4, null, 5]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.pop()).toEqual(5);\n\t\t\texpect(augmentedObject).toEqual([1, 2, 3, 4, null]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.shift()).toEqual(1);\n\t\t\texpect(augmentedObject).toEqual([2, 3, 4, null]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.unshift(1)).toEqual(5);\n\t\t\texpect(augmentedObject).toEqual([1, 2, 3, 4, null]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.splice(1, 1)).toEqual([2]);\n\t\t\texpect(augmentedObject).toEqual([1, 3, 4, null]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.slice(1)).toEqual([3, 4, null]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.reverse()).toEqual([null, 4, 3, 1]);\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with arrays on any level","suites":["AugmentObject","augmentArray"],"updatePoint":{"line":40,"column":44},"line":40,"code":"\t\ttest('should work with arrays on any level', () => {\n\t\t\tconst originalObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\t\t\t\tc3: '03' as string | null,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taa3: '01',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\t\t\t\tc3: '13',\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taa3: '11',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taa: [\n\t\t\t\t\t{\n\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\tb3: '2',\n\t\t\t\t\t\t},\n\t\t\t\t\t\taa3: '1',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\t// On first level\n\t\t\taugmentedObject.aa[0].a3.b3 = '22';\n\t\t\texpect(augmentedObject.aa[0].a3.b3).toEqual('22');\n\t\t\texpect(originalObject.aa[0].a3.b3).toEqual('2');\n\n\t\t\t// Make sure that also array operations as push and length work as expected\n\t\t\t// On lower levels\n\t\t\taugmentedObject.a.b.c[0].a3.b3.c3 = '033';\n\t\t\texpect(augmentedObject.a.b.c[0].a3.b3.c3).toEqual('033');\n\t\t\texpect(originalObject.a.b.c[0].a3.b3.c3).toEqual('03');\n\n\t\t\taugmentedObject.a.b.c[1].a3.b3.c3 = '133';\n\t\t\texpect(augmentedObject.a.b.c[1].a3.b3.c3).toEqual('133');\n\t\t\texpect(originalObject.a.b.c[1].a3.b3.c3).toEqual('13');\n\n\t\t\taugmentedObject.a.b.c.push({\n\t\t\t\ta3: {\n\t\t\t\t\tb3: {\n\t\t\t\t\t\tc3: '23',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taa3: '21',\n\t\t\t});\n\t\t\taugmentedObject.a.b.c[2].a3.b3.c3 = '233';\n\t\t\texpect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual('233');\n\n\t\t\taugmentedObject.a.b.c[2].a3.b3.c3 = '2333';\n\t\t\texpect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual('2333');\n\n\t\t\taugmentedObject.a.b.c[2].a3.b3.c3 = null;\n\t\t\texpect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual(null);\n\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject.a.b.c.length).toEqual(3);\n\n\t\t\texpect(augmentedObject.aa).toEqual([\n\t\t\t\t{\n\t\t\t\t\ta3: {\n\t\t\t\t\t\tb3: '22',\n\t\t\t\t\t},\n\t\t\t\t\taa3: '1',\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(augmentedObject.a.b.c).toEqual([\n\t\t\t\t{\n\t\t\t\t\ta3: {\n\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\tc3: '033',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taa3: '01',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ta3: {\n\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\tc3: '133',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taa3: '11',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ta3: {\n\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\tc3: null,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\taa3: '21',\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\t\t\t\tc3: '033',\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taa3: '01',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\t\t\t\tc3: '133',\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taa3: '11',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\t\t\tb3: {\n\t\t\t\t\t\t\t\t\t\tc3: null,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taa3: '21',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taa: [\n\t\t\t\t\t{\n\t\t\t\t\t\ta3: {\n\t\t\t\t\t\t\tb3: '22',\n\t\t\t\t\t\t},\n\t\t\t\t\t\taa3: '1',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with simple values on first level","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":195,"column":53},"line":195,"code":"\t\ttest('should work with simple values on first level', () => {\n\t\t\tconst date = new Date(1680089084200);\n\t\t\tconst regexp = new RegExp('^test$', 'ig');\n\t\t\tconst originalObject: IDataObject = {\n\t\t\t\t1: 11,\n\t\t\t\t2: '22',\n\t\t\t\ta: 111,\n\t\t\t\tb: '222',\n\t\t\t\td: date,\n\t\t\t\tr: regexp,\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\taugmentedObject[1] = 911;\n\t\t\texpect(originalObject[1]).toEqual(11);\n\t\t\texpect(augmentedObject[1]).toEqual(911);\n\n\t\t\taugmentedObject[2] = '922';\n\t\t\texpect(originalObject[2]).toEqual('22');\n\t\t\texpect(augmentedObject[2]).toEqual('922');\n\n\t\t\taugmentedObject.a = 9111;\n\t\t\texpect(originalObject.a).toEqual(111);\n\t\t\texpect(augmentedObject.a).toEqual(9111);\n\n\t\t\taugmentedObject.b = '9222';\n\t\t\texpect(originalObject.b).toEqual('222');\n\t\t\texpect(augmentedObject.b).toEqual('9222');\n\n\t\t\taugmentedObject.c = 3;\n\n\t\t\texpect({ ...originalObject, d: date.toJSON(), r: {} }).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\t1: 911,\n\t\t\t\t2: '922',\n\t\t\t\ta: 9111,\n\t\t\t\tb: '9222',\n\t\t\t\tc: 3,\n\t\t\t\td: date.toJSON(),\n\t\t\t\tr: regexp.toString(),\n\t\t\t});\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with simple values on sub-level","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":241,"column":51},"line":241,"code":"\t\ttest('should work with simple values on sub-level', () => {\n\t\t\tconst originalObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\taugmentedObject.a.bb = '92';\n\t\t\texpect(originalObject.a.bb).toEqual('2');\n\t\t\texpect(augmentedObject.a.bb).toEqual('92');\n\n\t\t\taugmentedObject.a.b.cc = '93';\n\t\t\texpect(originalObject.a.b.cc).toEqual('3');\n\t\t\texpect(augmentedObject.a.b.cc).toEqual('93');\n\n\t\t\t// @ts-ignore\n\t\t\taugmentedObject.a.b.ccc = {\n\t\t\t\td: '4',\n\t\t\t};\n\n\t\t\t// @ts-ignore\n\t\t\texpect(augmentedObject.a.b.ccc).toEqual({ d: '4' });\n\n\t\t\t// @ts-ignore\n\t\t\taugmentedObject.a.b.ccc.d = '94';\n\t\t\t// @ts-ignore\n\t\t\texpect(augmentedObject.a.b.ccc.d).toEqual('94');\n\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tcc: '93',\n\t\t\t\t\t\tccc: {\n\t\t\t\t\t\t\td: '94',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tbb: '92',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with complex values on first level","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":292,"column":54},"line":292,"code":"\t\ttest('should work with complex values on first level', () => {\n\t\t\tconst originalObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t\tc2: null,\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\taugmentedObject.a = { new: 'NEW' };\n\t\t\texpect(originalObject.a).toEqual({\n\t\t\t\tb: {\n\t\t\t\t\tc2: null,\n\t\t\t\t\tcc: '3',\n\t\t\t\t},\n\t\t\t\tbb: '2',\n\t\t\t});\n\t\t\texpect(augmentedObject.a).toEqual({ new: 'NEW' });\n\n\t\t\taugmentedObject.aa = '11';\n\t\t\texpect(originalObject.aa).toEqual('1');\n\t\t\texpect(augmentedObject.aa).toEqual('11');\n\n\t\t\taugmentedObject.aaa = {\n\t\t\t\tbbb: {\n\t\t\t\t\tccc: '333',\n\t\t\t\t},\n\t\t\t};\n\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tnew: 'NEW',\n\t\t\t\t},\n\t\t\t\taa: '11',\n\t\t\t\taaa: {\n\t\t\t\t\tbbb: {\n\t\t\t\t\t\tccc: '333',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with delete and reset","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":341,"column":41},"line":341,"code":"\t\ttest('should work with delete and reset', () => {\n\t\t\tconst originalObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\td: '4' as string | undefined,\n\t\t\t\t\t\t} as { d?: string; dd?: string } | undefined,\n\t\t\t\t\t\tcc: '3' as string | undefined,\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2' as string | undefined,\n\t\t\t\t},\n\t\t\t\taa: '1' as string | undefined,\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\t// Remove multiple values\n\t\t\tdelete augmentedObject.a.b.c!.d;\n\t\t\texpect(augmentedObject.a.b.c!.d).toEqual(undefined);\n\t\t\texpect(originalObject.a.b.c!.d).toEqual('4');\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {},\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\tdelete augmentedObject.a.b.c;\n\t\t\texpect(augmentedObject.a.b.c).toEqual(undefined);\n\t\t\texpect(originalObject.a.b.c).toEqual({ d: '4' });\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\t// Set deleted values again\n\t\t\taugmentedObject.a.b.c = { dd: '444' };\n\t\t\texpect(augmentedObject.a.b.c).toEqual({ dd: '444' });\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\taugmentedObject.a.b.c.d = '44';\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\td: '44',\n\t\t\t\t\t\t\tdd: '444',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should work with setting to undefined and reset","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":413,"column":55},"line":413,"code":"\t\ttest('should work with setting to undefined and reset', () => {\n\t\t\tconst originalObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\td: '4' as string | undefined,\n\t\t\t\t\t\t} as { d?: string; dd?: string } | undefined,\n\t\t\t\t\t\tcc: '3' as string | undefined,\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2' as string | undefined,\n\t\t\t\t},\n\t\t\t\taa: '1' as string | undefined,\n\t\t\t};\n\t\t\tconst copyOriginal = deepCopy(originalObject);\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\t// Remove multiple values\n\t\t\taugmentedObject.a.b.c!.d = undefined;\n\t\t\texpect(augmentedObject.a.b.c!.d).toEqual(undefined);\n\t\t\texpect(originalObject.a.b.c!.d).toEqual('4');\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {},\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\taugmentedObject.a.b.c = undefined;\n\t\t\texpect(augmentedObject.a.b.c).toEqual(undefined);\n\t\t\texpect(originalObject.a.b.c).toEqual({ d: '4' });\n\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\t// Set deleted values again\n\t\t\taugmentedObject.a.b.c = { dd: '444' };\n\t\t\texpect(augmentedObject.a.b.c).toEqual({ dd: '444' });\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\n\t\t\taugmentedObject.a.b.c.d = '44';\n\t\t\texpect(augmentedObject).toEqual({\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\td: '44',\n\t\t\t\t\t\t\tdd: '444',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcc: '3',\n\t\t\t\t\t},\n\t\t\t\t\tbb: '2',\n\t\t\t\t},\n\t\t\t\taa: '1',\n\t\t\t});\n\t\t\texpect(originalObject).toEqual(copyOriginal);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should be faster than doing a deepCopy","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":484,"column":46},"line":484,"code":"\t\ttest('should be faster than doing a deepCopy', () => {\n\t\t\tconst iterations = 100;\n\t\t\tconst originalObject: IDataObject = {\n\t\t\t\ta: {\n\t\t\t\t\tb: {\n\t\t\t\t\t\tc: {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: {\n\t\t\t\t\t\t\t\t\tf: 12345,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tfor (let i = 0; i < 10; i++) {\n\t\t\t\toriginalObject[i.toString()] = deepCopy(originalObject);\n\t\t\t}\n\n\t\t\tlet startTime = new Date().getTime();\n\t\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\t\tconst augmentedObject = augmentObject(originalObject);\n\t\t\t\tfor (let i = 0; i < 5000; i++) {\n\t\t\t\t\taugmentedObject.a!.b.c.d.e.f++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst timeAugmented = new Date().getTime() - startTime;\n\n\t\t\tstartTime = new Date().getTime();\n\t\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\t\tconst copiedObject = deepCopy(originalObject);\n\t\t\t\tfor (let i = 0; i < 5000; i++) {\n\t\t\t\t\tcopiedObject.a!.b.c.d.e.f++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst timeCopied = new Date().getTime() - startTime;\n\n\t\t\texpect(timeAugmented).toBeLessThan(timeCopied);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should ignore non-enumerable keys","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":524,"column":41},"line":524,"code":"\t\ttest('should ignore non-enumerable keys', () => {\n\t\t\tconst originalObject = { a: 1, b: 2 };\n\t\t\tObject.defineProperty(originalObject, '__hiddenProp', { enumerable: false });\n\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\t\t\texpect(Object.keys(augmentedObject)).toEqual(['a', 'b']);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return property descriptors","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":532,"column":42},"line":532,"code":"\t\ttest('should return property descriptors', () => {\n\t\t\tconst originalObject = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {},\n\t\t\t\t\tz: {},\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\n\t\t\texpect(Object.getOwnPropertyDescriptor(augmentedObject.x, 'y')).toEqual({\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: {},\n\t\t\t\twritable: true,\n\t\t\t});\n\n\t\t\tdelete augmentedObject.x.y;\n\t\t\texpect(augmentedObject.x.hasOwnProperty('y')).toEqual(false);\n\n\t\t\taugmentedObject.x.y = 42;\n\t\t\texpect(augmentedObject.x.hasOwnProperty('y')).toEqual(true);\n\t\t\texpect(Object.getOwnPropertyDescriptor(augmentedObject.x, 'y')).toEqual({\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: 42,\n\t\t\t\twritable: true,\n\t\t\t});\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return valid values on `has` calls","suites":["AugmentObject","augmentObject"],"updatePoint":{"line":561,"column":49},"line":561,"code":"\t\ttest('should return valid values on `has` calls', () => {\n\t\t\tconst originalObject = {\n\t\t\t\tx: {\n\t\t\t\t\ty: {},\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst augmentedObject = augmentObject(originalObject);\n\t\t\texpect('y' in augmentedObject.x).toBe(true);\n\t\t\texpect('z' in augmentedObject.x).toBe(false);\n\n\t\t\taugmentedObject.x.z = 5;\n\t\t\texpect('z' in augmentedObject.x).toBe(true);\n\t\t\texpect('y' in augmentedObject.x).toBe(true);\n\t\t});","file":"AugmentObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyMinute` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":5,"column":63},"line":5,"code":"\t\ttest('should generate a valid cron for `everyMinute` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyMinute',\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] \\* \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyHour` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":12,"column":61},"line":12,"code":"\t\ttest('should generate a valid cron for `everyHour` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyHour',\n\t\t\t\tminute: 11,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 11 \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyX[minutes]` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":20,"column":67},"line":20,"code":"\t\ttest('should generate a valid cron for `everyX[minutes]` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyX',\n\t\t\t\tunit: 'minutes',\n\t\t\t\tvalue: 42,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] \\*\\/42 \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyX[hours]` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":29,"column":65},"line":29,"code":"\t\ttest('should generate a valid cron for `everyX[hours]` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyX',\n\t\t\t\tunit: 'hours',\n\t\t\t\tvalue: 3,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 0 \\*\\/3 \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyDay` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":38,"column":60},"line":38,"code":"\t\ttest('should generate a valid cron for `everyDay` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyDay',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyWeek` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":47,"column":61},"line":47,"code":"\t\ttest('should generate a valid cron for `everyWeek` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyWeek',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t\tweekday: 4,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 \\* \\* 4$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyMonth` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":57,"column":62},"line":57,"code":"\t\ttest('should generate a valid cron for `everyMonth` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyMonth',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t\tdayOfMonth: 12,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 12 \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should trim custom cron expressions","suites":["Cron","toCronExpression"],"updatePoint":{"line":67,"column":43},"line":67,"code":"\t\ttest('should trim custom cron expressions', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'custom',\n\t\t\t\tcronExpression: ' 0 9-17 * * * ',\n\t\t\t});\n\t\t\texpect(expression).toEqual('0 9-17 * * *');\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not be able to use global built-ins from denylist","suites":["Expression","getParameterValue()"],"updatePoint":{"line":38,"column":62},"line":38,"code":"\t\tit('should not be able to use global built-ins from denylist', () => {\n\t\t\texpect(evaluate('={{document}}')).toEqual({});\n\t\t\texpect(evaluate('={{window}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Window}}')).toEqual({});\n\t\t\texpect(evaluate('={{globalThis}}')).toEqual({});\n\t\t\texpect(evaluate('={{self}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{alert}}')).toEqual({});\n\t\t\texpect(evaluate('={{prompt}}')).toEqual({});\n\t\t\texpect(evaluate('={{confirm}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{eval}}')).toEqual({});\n\t\t\texpect(evaluate('={{uneval}}')).toEqual({});\n\t\t\texpect(evaluate('={{setTimeout}}')).toEqual({});\n\t\t\texpect(evaluate('={{setInterval}}')).toEqual({});\n\t\t\texpect(evaluate('={{Function}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{fetch}}')).toEqual({});\n\t\t\texpect(evaluate('={{XMLHttpRequest}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Promise}}')).toEqual({});\n\t\t\texpect(evaluate('={{Generator}}')).toEqual({});\n\t\t\texpect(evaluate('={{GeneratorFunction}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncFunction}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncGenerator}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncGeneratorFunction}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{WebAssembly}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Reflect}}')).toEqual({});\n\t\t\texpect(evaluate('={{Proxy}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{constructor}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{escape}}')).toEqual({});\n\t\t\texpect(evaluate('={{unescape}}')).toEqual({});\n\t\t});","file":"Expression.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should be able to use global built-ins from allowlist","suites":["Expression","getParameterValue()"],"updatePoint":{"line":77,"column":59},"line":77,"code":"\t\tit('should be able to use global built-ins from allowlist', () => {\n\t\t\texpect(evaluate('={{new Date()}}')).toBeInstanceOf(Date);\n\t\t\texpect(evaluate('={{DateTime.now().toLocaleString()}}')).toEqual(\n\t\t\t\tDateTime.now().toLocaleString(),\n\t\t\t);\n\t\t\texpect(evaluate('={{Interval.after(new Date(), 100)}}')).toEqual(\n\t\t\t\tInterval.after(new Date(), 100),\n\t\t\t);\n\t\t\texpect(evaluate('={{Duration.fromMillis(100)}}')).toEqual(Duration.fromMillis(100));\n\n\t\t\texpect(evaluate('={{new Object()}}')).toEqual(new Object());\n\n\t\t\texpect(evaluate('={{new Array()}}')).toEqual([]);\n\t\t\texpect(evaluate('={{new Int8Array()}}')).toEqual(new Int8Array());\n\t\t\texpect(evaluate('={{new Uint8Array()}}')).toEqual(new Uint8Array());\n\t\t\texpect(evaluate('={{new Uint8ClampedArray()}}')).toEqual(new Uint8ClampedArray());\n\t\t\texpect(evaluate('={{new Int16Array()}}')).toEqual(new Int16Array());\n\t\t\texpect(evaluate('={{new Uint16Array()}}')).toEqual(new Uint16Array());\n\t\t\texpect(evaluate('={{new Int32Array()}}')).toEqual(new Int32Array());\n\t\t\texpect(evaluate('={{new Uint32Array()}}')).toEqual(new Uint32Array());\n\t\t\texpect(evaluate('={{new Float32Array()}}')).toEqual(new Float32Array());\n\t\t\texpect(evaluate('={{new Float64Array()}}')).toEqual(new Float64Array());\n\t\t\texpect(evaluate('={{new BigInt64Array()}}')).toEqual(new BigInt64Array());\n\t\t\texpect(evaluate('={{new BigUint64Array()}}')).toEqual(new BigUint64Array());\n\n\t\t\texpect(evaluate('={{new Map()}}')).toEqual(new Map());\n\t\t\texpect(evaluate('={{new WeakMap()}}')).toEqual(new WeakMap());\n\t\t\texpect(evaluate('={{new Set()}}')).toEqual(new Set());\n\t\t\texpect(evaluate('={{new WeakSet()}}')).toEqual(new WeakSet());\n\n\t\t\texpect(evaluate('={{new Error()}}')).toEqual(new Error());\n\t\t\texpect(evaluate('={{new TypeError()}}')).toEqual(new TypeError());\n\t\t\texpect(evaluate('={{new SyntaxError()}}')).toEqual(new SyntaxError());\n\t\t\texpect(evaluate('={{new EvalError()}}')).toEqual(new EvalError());\n\t\t\texpect(evaluate('={{new RangeError()}}')).toEqual(new RangeError());\n\t\t\texpect(evaluate('={{new ReferenceError()}}')).toEqual(new ReferenceError());\n\t\t\texpect(evaluate('={{new URIError()}}')).toEqual(new URIError());\n\n\t\t\texpect(evaluate('={{Intl}}')).toEqual(Intl);\n\n\t\t\texpect(evaluate('={{new String()}}')).toEqual(new String());\n\t\t\texpect(evaluate(\"={{new RegExp('')}}\")).toEqual(new RegExp(''));\n\n\t\t\texpect(evaluate('={{Math}}')).toEqual(Math);\n\t\t\texpect(evaluate('={{new Number()}}')).toEqual(new Number());\n\t\t\texpect(evaluate(\"={{BigInt('1')}}\")).toEqual(BigInt('1'));\n\t\t\texpect(evaluate('={{Infinity}}')).toEqual(Infinity);\n\t\t\texpect(evaluate('={{NaN}}')).toEqual(NaN);\n\t\t\texpect(evaluate('={{isFinite(1)}}')).toEqual(isFinite(1));\n\t\t\texpect(evaluate('={{isNaN(1)}}')).toEqual(isNaN(1));\n\t\t\texpect(evaluate(\"={{parseFloat('1')}}\")).toEqual(parseFloat('1'));\n\t\t\texpect(evaluate(\"={{parseInt('1', 10)}}\")).toEqual(parseInt('1', 10));\n\n\t\t\texpect(evaluate('={{JSON.stringify({})}}')).toEqual(JSON.stringify({}));\n\t\t\texpect(evaluate('={{new ArrayBuffer(10)}}')).toEqual(new ArrayBuffer(10));\n\t\t\texpect(evaluate('={{new SharedArrayBuffer(10)}}')).toEqual(new SharedArrayBuffer(10));\n\t\t\texpect(evaluate('={{Atomics}}')).toEqual(Atomics);\n\t\t\texpect(evaluate('={{new DataView(new ArrayBuffer(1))}}')).toEqual(\n\t\t\t\tnew DataView(new ArrayBuffer(1)),\n\t\t\t);\n\n\t\t\texpect(evaluate(\"={{encodeURI('https://google.com')}}\")).toEqual(\n\t\t\t\tencodeURI('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{encodeURIComponent('https://google.com')}}\")).toEqual(\n\t\t\t\tencodeURIComponent('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{decodeURI('https://google.com')}}\")).toEqual(\n\t\t\t\tdecodeURI('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{decodeURIComponent('https://google.com')}}\")).toEqual(\n\t\t\t\tdecodeURIComponent('https://google.com'),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{Boolean(1)}}')).toEqual(Boolean(1));\n\t\t\texpect(evaluate('={{Symbol(1).toString()}}')).toEqual(Symbol(1).toString());\n\t\t});","file":"Expression.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not able to do arbitrary code execution","suites":["Expression","getParameterValue()"],"updatePoint":{"line":155,"column":52},"line":155,"code":"\t\tit('should not able to do arbitrary code execution', () => {\n\t\t\tconst testFn = jest.fn();\n\t\t\tObject.assign(global, { testFn });\n\t\t\texpect(() => evaluate(\"={{ Date['constructor']('testFn()')()}}\")).toThrowError(\n\t\t\t\tnew ExpressionError('Arbitrary code execution detected'),\n\t\t\t);\n\t\t\texpect(testFn).not.toHaveBeenCalled();\n\t\t});","file":"Expression.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".randomItem() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":9,"column":55},"line":9,"code":"\t\ttest('.randomItem() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [1,2,3].randomItem() }}')).not.toBeUndefined();\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isNotEmpty() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":13,"column":55},"line":13,"code":"\t\ttest('.isNotEmpty() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [1,2,3, \"imhere\"].isNotEmpty() }}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".pluck() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":17,"column":50},"line":17,"code":"\t\ttest('.pluck() should work correctly on an array', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(`={{ [\n\t\t\t\t{ value: 1, string: '1' },\n\t\t\t\t{ value: 2, string: '2' },\n\t\t\t\t{ value: 3, string: '3' },\n\t\t\t\t{ value: 4, string: '4' },\n\t\t\t\t{ value: 5, string: '5' },\n\t\t\t\t{ value: 6, string: '6' },\n\t\t\t\t{ value: { something: 'else' } }\n\t\t\t].pluck(\"value\") }}`),\n\t\t\t).toEqual(expect.arrayContaining([1, 2, 3, 4, 5, 6, { something: 'else' }]));\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".pluck() should work correctly for multiple values","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":31,"column":58},"line":31,"code":"\t\ttest('.pluck() should work correctly for multiple values', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(`={{ [\n\t\t\t\t\t{\n\t\t\t\t\t\tfirstName: 'John',\n\t\t\t\t\t\tlastName: 'Doe',\n\t\t\t\t\t\tphone: {\n\t\t\t\t\t\t\thome: '111-222',\n\t\t\t\t\t\t\toffice: '333-444'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfirstName: 'Jane',\n\t\t\t\t\t\tlastName: 'Doe',\n\t\t\t\t\t\tphone: {\n\t\t\t\t\t\t\toffice: '555-666'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t].pluck(\"firstName\", \"lastName\") }}`),\n\t\t\t).toEqual(\n\t\t\t\texpect.arrayContaining([\n\t\t\t\t\t['John', 'Doe'],\n\t\t\t\t\t['Jane', 'Doe'],\n\t\t\t\t]),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".pluck() should work return everything with no args","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":58,"column":59},"line":58,"code":"\t\ttest('.pluck() should work return everything with no args', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(`={{ [\n\t\t\t\t{ value: 1, string: '1' },\n\t\t\t\t{ value: 2, string: '2' },\n\t\t\t\t{ value: 3, string: '3' },\n\t\t\t\t{ value: 4, string: '4' },\n\t\t\t\t{ value: 5, string: '5' },\n\t\t\t\t{ value: 6, string: '6' },\n\t\t\t\t{ value: { something: 'else' } }\n\t\t\t].pluck() }}`),\n\t\t\t).toEqual(\n\t\t\t\texpect.arrayContaining([\n\t\t\t\t\t{ value: 1, string: '1' },\n\t\t\t\t\t{ value: 2, string: '2' },\n\t\t\t\t\t{ value: 3, string: '3' },\n\t\t\t\t\t{ value: 4, string: '4' },\n\t\t\t\t\t{ value: 5, string: '5' },\n\t\t\t\t\t{ value: 6, string: '6' },\n\t\t\t\t\t{ value: { something: 'else' } },\n\t\t\t\t]),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".unique() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":82,"column":51},"line":82,"code":"\t\ttest('.unique() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [\"repeat\",\"repeat\",\"a\",\"b\",\"c\"].unique() }}')).toEqual(\n\t\t\t\texpect.arrayContaining(['repeat', 'repeat', 'a', 'b', 'c']),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".unique() should work on an arrays containing nulls, objects and arrays","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":88,"column":79},"line":88,"code":"\t\ttest('.unique() should work on an arrays containing nulls, objects and arrays', () => {\n\t\t\texpect(\n\t\t\t\tevaluate('={{ [1, 2, 3, \"as\", {}, {}, 1, 2, [1,2], \"[sad]\", \"[sad]\", null].unique() }}'),\n\t\t\t).toEqual([1, 2, 3, 'as', {}, [1, 2], '[sad]', null]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":94,"column":52},"line":94,"code":"\t\ttest('.isEmpty() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [].isEmpty() }}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":98,"column":52},"line":98,"code":"\t\ttest('.isEmpty() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [1].isEmpty() }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".last() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":102,"column":49},"line":102,"code":"\t\ttest('.last() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [\"repeat\",\"repeat\",\"a\",\"b\",\"c\"].last() }}')).toEqual('c');\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".first() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":106,"column":50},"line":106,"code":"\t\ttest('.first() should work correctly on an array', () => {\n\t\t\texpect(evaluate('={{ [\"repeat\",\"repeat\",\"a\",\"b\",\"c\"].first() }}')).toEqual('repeat');\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".merge() should work correctly on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":110,"column":50},"line":110,"code":"\t\ttest('.merge() should work correctly on an array', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1, test2: 2 }, { test1: 1, test3: 3 }].merge([{ test1: 2, test3: 3 }, { test4: 4 }]) }}',\n\t\t\t\t),\n\t\t\t).toEqual({ test1: 1, test2: 2, test3: 3, test4: 4 });\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".merge() should work correctly without arguments","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":118,"column":56},"line":118,"code":"\t\ttest('.merge() should work correctly without arguments', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ a: 1, some: null }, { a: 2, c: \"something\" }, 2, \"asds\", { b: 23 }, null, [1, 2]].merge() }}',\n\t\t\t\t),\n\t\t\t).toEqual({ a: 1, some: null, c: 'something', b: 23 });\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".smartJoin() should work correctly on an array of objects","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":126,"column":65},"line":126,"code":"\t\ttest('.smartJoin() should work correctly on an array of objects', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ name: \"test1\", value: \"value1\" }, { name: \"test2\", value: null }].smartJoin(\"name\", \"value\") }}',\n\t\t\t\t),\n\t\t\t).toEqual({\n\t\t\t\ttest1: 'value1',\n\t\t\t\ttest2: null,\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".renameKeys() should work correctly on an array of objects","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":137,"column":66},"line":137,"code":"\t\ttest('.renameKeys() should work correctly on an array of objects', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1, test2: 2 }, { test1: 1, test3: 3 }].renameKeys(\"test1\", \"rename1\", \"test3\", \"rename3\") }}',\n\t\t\t\t),\n\t\t\t).toEqual([\n\t\t\t\t{ rename1: 1, test2: 2 },\n\t\t\t\t{ rename1: 1, rename3: 3 },\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".sum() should work on an array of numbers","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":148,"column":49},"line":148,"code":"\t\ttest('.sum() should work on an array of numbers', () => {\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4, 5, 6].sum() }}')).toEqual(21);\n\t\t\texpect(() => evaluate('={{ [\"1\", 2, 3, 4, 5, \"bad\"].sum() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".average() should work on an array of numbers","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":153,"column":53},"line":153,"code":"\t\ttest('.average() should work on an array of numbers', () => {\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4, 5, 6].average() }}')).toEqual(3.5);\n\t\t\texpect(() => evaluate('={{ [\"1\", 2, 3, 4, 5, \"bad\"].average() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".min() should work on an array of numbers","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":158,"column":49},"line":158,"code":"\t\ttest('.min() should work on an array of numbers', () => {\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4, 5, 6].min() }}')).toEqual(1);\n\t\t\texpect(() => evaluate('={{ [\"1\", 2, 3, 4, 5, \"bad\"].min() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".max() should work on an array of numbers","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":163,"column":49},"line":163,"code":"\t\ttest('.max() should work on an array of numbers', () => {\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4, 5, 6].max() }}')).toEqual(6);\n\t\t\texpect(() => evaluate('={{ [\"1\", 2, 3, 4, 5, \"bad\"].max() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".union() should work on an array of objects","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":168,"column":51},"line":168,"code":"\t\ttest('.union() should work on an array of objects', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1 }, { test2: 2 }].union([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',\n\t\t\t\t),\n\t\t\t).toEqual([{ test1: 1 }, { test2: 2 }, { test1: 1, test3: 3 }, { test4: 4 }]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".union() should work on an arrays containing nulls, objects and arrays","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":176,"column":78},"line":176,"code":"\t\ttest('.union() should work on an arrays containing nulls, objects and arrays', () => {\n\t\t\texpect(evaluate('={{ [1, 2, \"dd\", {}, null].union([1, {}, null, 3]) }}')).toEqual([\n\t\t\t\t1,\n\t\t\t\t2,\n\t\t\t\t'dd',\n\t\t\t\t{},\n\t\t\t\tnull,\n\t\t\t\t3,\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".intersection() should work on an array of objects","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":187,"column":58},"line":187,"code":"\t\ttest('.intersection() should work on an array of objects', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1 }, { test2: 2 }].intersection([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',\n\t\t\t\t),\n\t\t\t).toEqual([{ test2: 2 }]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".intersection() should work on an arrays containing nulls, objects and arrays","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":195,"column":85},"line":195,"code":"\t\ttest('.intersection() should work on an arrays containing nulls, objects and arrays', () => {\n\t\t\texpect(evaluate('={{ [1, 2, \"dd\", {}, null].intersection([1, {}, null]) }}')).toEqual([\n\t\t\t\t1,\n\t\t\t\t{},\n\t\t\t\tnull,\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".difference() should work on an array of objects","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":203,"column":56},"line":203,"code":"\t\ttest('.difference() should work on an array of objects', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1 }, { test2: 2 }].difference([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',\n\t\t\t\t),\n\t\t\t).toEqual([{ test1: 1 }]);\n\n\t\t\texpect(\n\t\t\t\tevaluate('={{ [{ test1: 1 }, { test2: 2 }].difference([{ test1: 1 }, { test2: 2 }]) }}'),\n\t\t\t).toEqual([]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".difference() should work on an arrays containing nulls, objects and arrays","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":215,"column":83},"line":215,"code":"\t\ttest('.difference() should work on an arrays containing nulls, objects and arrays', () => {\n\t\t\texpect(\n\t\t\t\tevaluate('={{ [1, 2, \"dd\", {}, null, [\"a\", 1]].difference([1, {}, null, [\"a\", 1]]) }}'),\n\t\t\t).toEqual([2, 'dd']);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".compact() should work on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":221,"column":42},"line":221,"code":"\t\ttest('.compact() should work on an array', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ [{ test1: 1, test2: undefined, test3: null }, null, undefined, 1, 2, 0, { test: \"asdf\" }].compact() }}',\n\t\t\t\t),\n\t\t\t).toEqual([{ test1: 1 }, 1, 2, 0, { test: 'asdf' }]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".chunk() should work on an array","suites":["Data Transformation Functions","Array Data Transformation Functions"],"updatePoint":{"line":229,"column":40},"line":229,"code":"\t\ttest('.chunk() should work on an array', () => {\n\t\t\texpect(evaluate('={{ numberList(1, 20).chunk(5) }}')).toEqual([\n\t\t\t\t[1, 2, 3, 4, 5],\n\t\t\t\t[6, 7, 8, 9, 10],\n\t\t\t\t[11, 12, 13, 14, 15],\n\t\t\t\t[16, 17, 18, 19, 20],\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ArrayExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isWeekend() should work correctly on a date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":10,"column":52},"line":10,"code":"\t\ttest('.isWeekend() should work correctly on a date', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 20).isWeekend() }}')).toBe(false);\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 21).isWeekend() }}')).toBe(true);\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 22).isWeekend() }}')).toBe(true);\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 23).isWeekend() }}')).toBe(false);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".beginningOf(\"week\") should work correctly on a date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":17,"column":60},"line":17,"code":"\t\ttest('.beginningOf(\"week\") should work correctly on a date', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 20).beginningOf(\"week\") }}')).toEqual(\n\t\t\t\tDateTime.local(2023, 1, 16, { zone: TEST_TIMEZONE }),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ new Date(2023, 0, 20).beginningOf(\"week\") }}')).toEqual(\n\t\t\t\tDateTime.local(2023, 1, 16, { zone: TEST_TIMEZONE }).toJSDate(),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".beginningOf(\"week\") should work correctly on a string","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":27,"column":62},"line":27,"code":"\t\ttest('.beginningOf(\"week\") should work correctly on a string', () => {\n\t\t\tconst evaluatedDate = evaluate('={{ \"2023-01-30\".toDate().beginningOf(\"week\") }}');\n\t\t\tconst expectedDate = DateTime.local(2023, 1, 23, { zone: TEST_TIMEZONE }).toJSDate();\n\n\t\t\tif (evaluatedDate && evaluatedDate instanceof Date) {\n\t\t\t\texpect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());\n\t\t\t}\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".beginningOf(\"month\") should work correctly on a string","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":36,"column":63},"line":36,"code":"\t\ttest('.beginningOf(\"month\") should work correctly on a string', () => {\n\t\t\tconst evaluatedDate = evaluate('={{ \"2023-06-16\".toDate().beginningOf(\"month\") }}');\n\t\t\tconst expectedDate = DateTime.local(2023, 6, 1, { zone: TEST_TIMEZONE }).toJSDate();\n\n\t\t\tif (evaluatedDate && evaluatedDate instanceof Date) {\n\t\t\t\texpect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());\n\t\t\t}\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".beginningOf(\"year\") should work correctly on a string","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":45,"column":62},"line":45,"code":"\t\ttest('.beginningOf(\"year\") should work correctly on a string', () => {\n\t\t\tconst evaluatedDate = evaluate('={{ \"2023-01-30\".toDate().beginningOf(\"year\") }}');\n\t\t\tconst expectedDate = DateTime.local(2023, 1, 1, { zone: TEST_TIMEZONE }).toJSDate();\n\n\t\t\tif (evaluatedDate && evaluatedDate instanceof Date) {\n\t\t\t\texpect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());\n\t\t\t}\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".endOfMonth() should work correctly on a date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":54,"column":53},"line":54,"code":"\t\ttest('.endOfMonth() should work correctly on a date', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 16).endOfMonth() }}')).toEqual(\n\t\t\t\tDateTime.local(2023, 1, 31, 23, 59, 59, 999, { zone: TEST_TIMEZONE }),\n\t\t\t);\n\t\t\texpect(evaluate('={{ new Date(2023, 0, 16).endOfMonth() }}')).toEqual(\n\t\t\t\tDateTime.local(2023, 1, 31, 23, 59, 59, 999, { zone: TEST_TIMEZONE }).toJSDate(),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".extract(\"day\") should work correctly on a date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":63,"column":55},"line":63,"code":"\t\ttest('.extract(\"day\") should work correctly on a date', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 20).extract(\"day\") }}')).toEqual(20);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".extract() should extract week for no args","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":67,"column":50},"line":67,"code":"\t\ttest('.extract() should extract week for no args', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 20).extract() }}')).toEqual(3);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".format(\"yyyy LLL dd\") should work correctly on a date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":71,"column":62},"line":71,"code":"\t\ttest('.format(\"yyyy LLL dd\") should work correctly on a date', () => {\n\t\t\texpect(evaluate('={{ DateTime.local(2023, 1, 16).format(\"yyyy LLL dd\") }}')).toEqual(\n\t\t\t\t'2023 Jan 16',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toDate() should work on a string","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":77,"column":41},"line":77,"code":"\t\ttest('.toDate() should work on a string', () => {\n\t\t\tconst date = new Date(2022, 0, 3);\n\t\t\texpect(evaluate(`={{ \"${getLocalISOString(date)}\".toDate() }}`)).toEqual(date);\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should work on string and Date","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":82,"column":51},"line":82,"code":"\t\ttest('.inBetween() should work on string and Date', () => {\n\t\t\texpect(evaluate(\"={{ $now.isBetween('2023-06-23'.toDate(), '2023-06-23') }}\")).toBeDefined();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should work on string and DateTime","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":86,"column":55},"line":86,"code":"\t\ttest('.inBetween() should work on string and DateTime', () => {\n\t\t\texpect(evaluate(\"={{ $now.isBetween($now, '2023-06-23') }}\")).toBeDefined();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should not work for invalid strings","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":90,"column":56},"line":90,"code":"\t\ttest('.inBetween() should not work for invalid strings', () => {\n\t\t\texpect(evaluate(\"={{ $now.isBetween($now, 'invalid') }}\")).toBeUndefined();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should not work for numbers","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":94,"column":48},"line":94,"code":"\t\ttest('.inBetween() should not work for numbers', () => {\n\t\t\texpect(evaluate('={{ $now.isBetween($now, 1) }}')).toBeUndefined();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should not work for a single argument","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":98,"column":58},"line":98,"code":"\t\ttest('.inBetween() should not work for a single argument', () => {\n\t\t\texpect(() => evaluate('={{ $now.isBetween($now) }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".inBetween() should not work for a more than two arguments","suites":["Data Transformation Functions","Date Data Transformation Functions"],"updatePoint":{"line":102,"column":66},"line":102,"code":"\t\ttest('.inBetween() should not work for a more than two arguments', () => {\n\t\t\texpect(() =>\n\t\t\t\tevaluate(\"={{ $now.isBetween($now, '2023-06-23', '2023-09-21'.toDate()) }}\"),\n\t\t\t).toThrow();\n\t\t});","file":"ExpressionExtensions/DateExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Basic transform with .isEmpty","suites":["Expression Extension Transforms","extend() transform"],"updatePoint":{"line":13,"column":37},"line":13,"code":"\t\ttest('Basic transform with .isEmpty', () => {\n\t\t\texpect(extendTransform('\"\".isEmpty()')!.code).toEqual('extend(\"\", \"isEmpty\", [])');\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Chained transform with .toSnakeCase.toSentenceCase","suites":["Expression Extension Transforms","extend() transform"],"updatePoint":{"line":17,"column":58},"line":17,"code":"\t\ttest('Chained transform with .toSnakeCase.toSentenceCase', () => {\n\t\t\texpect(extendTransform('\"\".toSnakeCase().toSentenceCase(2)')!.code).toEqual(\n\t\t\t\t'extend(extend(\"\", \"toSnakeCase\", []), \"toSentenceCase\", [2])',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Chained transform with native functions .toSnakeCase.trim.toSentenceCase","suites":["Expression Extension Transforms","extend() transform"],"updatePoint":{"line":23,"column":80},"line":23,"code":"\t\ttest('Chained transform with native functions .toSnakeCase.trim.toSentenceCase', () => {\n\t\t\texpect(extendTransform('\"aaa \".toSnakeCase().trim().toSentenceCase(2)')!.code).toEqual(\n\t\t\t\t'extend(extend(\"aaa \", \"toSnakeCase\", []).trim(), \"toSentenceCase\", [2])',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Lone expression","suites":["tmpl Expression Parser","Compatible splitting"],"updatePoint":{"line":33,"column":23},"line":33,"code":"\t\ttest('Lone expression', () => {\n\t\t\texpect(splitExpression('{{ \"\" }}')).toEqual([\n\t\t\t\t{ type: 'text', text: '' },\n\t\t\t\t{ type: 'code', text: ' \"\" ', hasClosingBrackets: true },\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Multiple expression","suites":["tmpl Expression Parser","Compatible splitting"],"updatePoint":{"line":40,"column":27},"line":40,"code":"\t\ttest('Multiple expression', () => {\n\t\t\texpect(splitExpression('{{ \"test\".toSnakeCase() }} you have ${{ (100).format() }}.')).toEqual(\n\t\t\t\t[\n\t\t\t\t\t{ type: 'text', text: '' },\n\t\t\t\t\t{ type: 'code', text: ' \"test\".toSnakeCase() ', hasClosingBrackets: true },\n\t\t\t\t\t{ type: 'text', text: ' you have $' },\n\t\t\t\t\t{ type: 'code', text: ' (100).format() ', hasClosingBrackets: true },\n\t\t\t\t\t{ type: 'text', text: '.' },\n\t\t\t\t],\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Unclosed expression","suites":["tmpl Expression Parser","Compatible splitting"],"updatePoint":{"line":52,"column":27},"line":52,"code":"\t\ttest('Unclosed expression', () => {\n\t\t\texpect(splitExpression('{{ \"test\".toSnakeCase() }} you have ${{ (100).format()')).toEqual([\n\t\t\t\t{ type: 'text', text: '' },\n\t\t\t\t{ type: 'code', text: ' \"test\".toSnakeCase() ', hasClosingBrackets: true },\n\t\t\t\t{ type: 'text', text: ' you have $' },\n\t\t\t\t{ type: 'code', text: ' (100).format()', hasClosingBrackets: false },\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Escaped opening bracket","suites":["tmpl Expression Parser","Compatible splitting"],"updatePoint":{"line":61,"column":31},"line":61,"code":"\t\ttest('Escaped opening bracket', () => {\n\t\t\texpect(splitExpression('test \\\\{{ no code }}')).toEqual([\n\t\t\t\t{ type: 'text', text: 'test \\\\{{ no code }}' },\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Escaped closinging bracket","suites":["tmpl Expression Parser","Compatible splitting"],"updatePoint":{"line":67,"column":34},"line":67,"code":"\t\ttest('Escaped closinging bracket', () => {\n\t\t\texpect(splitExpression('test {{ code.test(\"\\\\}}\") }}')).toEqual([\n\t\t\t\t{ type: 'text', text: 'test ' },\n\t\t\t\t{ type: 'code', text: ' code.test(\"}}\") ', hasClosingBrackets: true },\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Lone expression","suites":["tmpl Expression Parser","Compatible joining"],"updatePoint":{"line":76,"column":23},"line":76,"code":"\t\ttest('Lone expression', () => {\n\t\t\texpect(joinExpression(splitExpression('{{ \"\" }}'))).toEqual('{{ \"\" }}');\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Multiple expression","suites":["tmpl Expression Parser","Compatible joining"],"updatePoint":{"line":80,"column":27},"line":80,"code":"\t\ttest('Multiple expression', () => {\n\t\t\texpect(\n\t\t\t\tjoinExpression(\n\t\t\t\t\tsplitExpression('{{ \"test\".toSnakeCase() }} you have ${{ (100).format() }}.'),\n\t\t\t\t),\n\t\t\t).toEqual('{{ \"test\".toSnakeCase() }} you have ${{ (100).format() }}.');\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Unclosed expression","suites":["tmpl Expression Parser","Compatible joining"],"updatePoint":{"line":88,"column":27},"line":88,"code":"\t\ttest('Unclosed expression', () => {\n\t\t\texpect(\n\t\t\t\tjoinExpression(splitExpression('{{ \"test\".toSnakeCase() }} you have ${{ (100).format()')),\n\t\t\t).toEqual('{{ \"test\".toSnakeCase() }} you have ${{ (100).format()');\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Escaped opening bracket","suites":["tmpl Expression Parser","Compatible joining"],"updatePoint":{"line":94,"column":31},"line":94,"code":"\t\ttest('Escaped opening bracket', () => {\n\t\t\texpect(joinExpression(splitExpression('test \\\\{{ no code }}'))).toEqual(\n\t\t\t\t'test \\\\{{ no code }}',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Escaped closing bracket","suites":["tmpl Expression Parser","Compatible joining"],"updatePoint":{"line":100,"column":31},"line":100,"code":"\t\ttest('Escaped closing bracket', () => {\n\t\t\texpect(joinExpression(splitExpression('test {{ code.test(\"\\\\}}\") }}'))).toEqual(\n\t\t\t\t'test {{ code.test(\"\\\\}}\") }}',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Nested member access with name of function inside a function doesn't result in function call","suites":["tmpl Expression Parser","Edge cases"],"updatePoint":{"line":108,"column":100},"line":108,"code":"\t\ttest(\"Nested member access with name of function inside a function doesn't result in function call\", () => {\n\t\t\texpect(evaluate('={{ Math.floor([1, 2, 3, 4].length + 10) }}')).toEqual(14);\n\n\t\t\texpect(extendTransform('Math.floor([1, 2, 3, 4].length + 10)')?.code).toBe(\n\t\t\t\t'extend(Math, \"floor\", [[1, 2, 3, 4].length + 10])',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Optional chaining transforms","suites":["tmpl Expression Parser","Test newer ES syntax"],"updatePoint":{"line":118,"column":36},"line":118,"code":"\t\ttest('Optional chaining transforms', () => {\n\t\t\texpect(extendTransform('$json.something?.test.funcCall()')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test.funcCall();',\n\t\t\t);\n\n\t\t\texpect(extendTransform('$json.something?.test.funcCall()?.somethingElse')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.test.funcCall()) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.somethingElse;',\n\t\t\t);\n\n\t\t\texpect(extendTransform('$json.something?.test.funcCall().somethingElse')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test.funcCall().somethingElse;',\n\t\t\t);\n\n\t\t\texpect(\n\t\t\t\textendTransform('$json.something?.test.funcCall()?.somethingElse.otherCall()')?.code,\n\t\t\t).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.test.funcCall()) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.somethingElse.otherCall();',\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4]?.sum() }}')).toBe(10);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Optional chaining transforms on calls","suites":["tmpl Expression Parser","Test newer ES syntax"],"updatePoint":{"line":140,"column":45},"line":140,"code":"\t\ttest('Optional chaining transforms on calls', () => {\n\t\t\texpect(extendTransform('Math.min?.(1)')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = extendOptional(Math, \"min\")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1(1);',\n\t\t\t);\n\t\t\texpect(extendTransform('Math?.min?.(1)')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = Math) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = extendOptional(window.chainValue1, \"min\")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1(1);',\n\t\t\t);\n\n\t\t\texpect(extendTransform('$json.test.test2?.sum()')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.test.test2) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : extend(window.chainValue1, \"sum\", []);',\n\t\t\t);\n\t\t\texpect(extendTransform('$json.test.test2?.sum?.()')?.code).toBe(\n\t\t\t\t'window.chainCancelToken1 = ((window.chainValue1 = $json.test.test2) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = extendOptional(window.chainValue1, \"sum\")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1();',\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ [1, 2, 3, 4].sum?.() }}')).toBe(10);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Multiple optional chains in an expression","suites":["tmpl Expression Parser","Test newer ES syntax"],"updatePoint":{"line":158,"column":49},"line":158,"code":"\t\ttest('Multiple optional chains in an expression', () => {\n\t\t\texpect(extendTransform('$json.test?.test2($json.test?.test2)')?.code)\n\t\t\t\t.toBe(`window.chainCancelToken2 = ((window.chainValue2 = $json.test) ?? undefined) === undefined, window.chainCancelToken2 === true ? undefined : window.chainValue2.test2(\n  (window.chainCancelToken1 = ((window.chainValue1 = $json.test) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test2)\n);`);\n\n\t\t\texpect(extendTransform('$json.test?.test2($json.test.sum?.())')?.code)\n\t\t\t\t.toBe(`window.chainCancelToken2 = ((window.chainValue2 = $json.test) ?? undefined) === undefined, window.chainCancelToken2 === true ? undefined : window.chainValue2.test2(\n  (window.chainCancelToken1 = ((window.chainValue1 = extendOptional($json.test, \"sum\")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1())\n);`);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"min","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":174,"column":11},"line":174,"code":"\t\ttest('min', () => {\n\t\t\texpect(evaluate('={{ min(1, 2, 3, 4, 5, 6) }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ min(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"max","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":179,"column":11},"line":179,"code":"\t\ttest('max', () => {\n\t\t\texpect(evaluate('={{ max(1, 2, 3, 4, 5, 6) }}')).toEqual(6);\n\t\t\texpect(evaluate('={{ max(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"average","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":184,"column":15},"line":184,"code":"\t\ttest('average', () => {\n\t\t\texpect(evaluate('={{ average(1, 2, 3, 4, 5, 6) }}')).toEqual(3.5);\n\t\t\texpect(evaluate('={{ average(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"numberList","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":189,"column":18},"line":189,"code":"\t\ttest('numberList', () => {\n\t\t\texpect(evaluate('={{ numberList(1, 10) }}')).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\t\t\texpect(evaluate('={{ numberList(1, -10) }}')).toEqual([\n\t\t\t\t1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10,\n\t\t\t]);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"zip","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":196,"column":11},"line":196,"code":"\t\ttest('zip', () => {\n\t\t\texpect(evaluate('={{ zip([\"test1\", \"test2\", \"test3\"], [1, 2, 3]) }}')).toEqual({\n\t\t\t\ttest1: 1,\n\t\t\t\ttest2: 2,\n\t\t\t\ttest3: 3,\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"$if","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":204,"column":11},"line":204,"code":"\t\ttest('$if', () => {\n\t\t\texpect(evaluate('={{ $if(\"a\"===\"a\", 1, 2) }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ $if(\"a\"===\"b\", 1, 2) }}')).toEqual(2);\n\t\t\texpect(evaluate('={{ $if(\"a\"===\"a\", 1) }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ $if(\"a\"===\"b\", 1) }}')).toEqual(false);\n\n\t\t\t// This will likely break when sandboxing is implemented but it works for now.\n\t\t\t// If you're implementing sandboxing maybe provide a way to add functions to\n\t\t\t// sandbox we can check instead?\n\t\t\tconst mockCallback = jest.fn(() => false);\n\t\t\tevaluate('={{ $if(\"a\"===\"a\", true, $data.cb()) }}', [{ cb: mockCallback }]);\n\t\t\texpect(mockCallback.mock.calls.length).toEqual(0);\n\n\t\t\tevaluate('={{ $if(\"a\"===\"b\", true, $data.cb()) }}', [{ cb: mockCallback }]);\n\t\t\texpect(mockCallback.mock.calls.length).toEqual(1);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"$not","suites":["tmpl Expression Parser","Non dot extensions"],"updatePoint":{"line":221,"column":12},"line":221,"code":"\t\ttest('$not', () => {\n\t\t\texpect(evaluate('={{ $not(1) }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ $not(0) }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ $not(true) }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ $not(false) }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ $not(undefined) }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ $not(null) }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ $not(\"\") }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ $not(\"a\") }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/ExpressionExtension.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on undefined","suites":["Data Transformation Functions","Genric Data Transformation Functions"],"updatePoint":{"line":5,"column":53},"line":5,"code":"\t\ttest('.isEmpty() should work correctly on undefined', () => {\n\t\t\texpect(evaluate('={{(undefined).isEmpty()}}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/GenericExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".format() should work correctly on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":10,"column":51},"line":10,"code":"\t\ttest('.format() should work correctly on a number', () => {\n\t\t\texpect(evaluate('={{ Number(100).format() }}')).toEqual(\n\t\t\t\tnumberExtensions.functions.format(100, []),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".ceil() should work on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":16,"column":39},"line":16,"code":"\t\ttest('.ceil() should work on a number', () => {\n\t\t\texpect(evaluate('={{ (1.2).ceil() }}')).toEqual(2);\n\t\t\texpect(evaluate('={{ (1.9).ceil() }}')).toEqual(2);\n\t\t\texpect(evaluate('={{ (1.0).ceil() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ (NaN).ceil() }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".floor() should work on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":23,"column":40},"line":23,"code":"\t\ttest('.floor() should work on a number', () => {\n\t\t\texpect(evaluate('={{ (1.2).floor() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ (1.9).floor() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ (1.0).floor() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ (NaN).floor() }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".round() should work on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":30,"column":40},"line":30,"code":"\t\ttest('.round() should work on a number', () => {\n\t\t\texpect(evaluate('={{ (1.3333333).round(3) }}')).toEqual(1.333);\n\t\t\texpect(evaluate('={{ (1.3333333).round(0) }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ (1.5001).round(0) }}')).toEqual(2);\n\t\t\texpect(evaluate('={{ (NaN).round(3) }}')).toBeNaN();\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isOdd() should work on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":37,"column":40},"line":37,"code":"\t\ttest('.isOdd() should work on a number', () => {\n\t\t\texpect(evaluate('={{ (9).isOdd() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ (8).isOdd() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ (0).isOdd() }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isOdd() should not work on a float or NaN","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":43,"column":50},"line":43,"code":"\t\ttest('.isOdd() should not work on a float or NaN', () => {\n\t\t\texpect(() => evaluate('={{ (NaN).isOdd() }}')).toThrow();\n\t\t\texpect(() => evaluate('={{ (9.2).isOdd() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEven() should work on a number","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":48,"column":41},"line":48,"code":"\t\ttest('.isEven() should work on a number', () => {\n\t\t\texpect(evaluate('={{ (9).isEven() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ (8).isEven() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ (0).isEven() }}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEven() should not work on a float or NaN","suites":["Data Transformation Functions","Number Data Transformation Functions"],"updatePoint":{"line":54,"column":51},"line":54,"code":"\t\ttest('.isEven() should not work on a float or NaN', () => {\n\t\t\texpect(() => evaluate('={{ (NaN).isEven() }}')).toThrow();\n\t\t\texpect(() => evaluate('={{ (9.2).isEven() }}')).toThrow();\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Basic multiple expressions","suites":["Data Transformation Functions","Multiple expressions"],"updatePoint":{"line":61,"column":34},"line":61,"code":"\t\ttest('Basic multiple expressions', () => {\n\t\t\t// eslint-disable-next-line n8n-local-rules/no-interpolation-in-regular-string\n\t\t\texpect(evaluate('={{ \"test abc\".toSnakeCase() }} you have ${{ (100).format() }}.')).toEqual(\n\t\t\t\t'test_abc you have $100.',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/NumberExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":5,"column":53},"line":5,"code":"\t\ttest('.isEmpty() should work correctly on an object', () => {\n\t\t\texpect(evaluate('={{({}).isEmpty()}}')).toEqual(true);\n\t\t\texpect(evaluate('={{({ test1: 1 }).isEmpty()}}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".hasField should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":10,"column":42},"line":10,"code":"\t\ttest('.hasField should work on an object', () => {\n\t\t\texpect(evaluate('={{ ({ test1: 1 }).hasField(\"test1\") }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ ({ test1: 1 }).hasField(\"test2\") }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".removeField should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":15,"column":45},"line":15,"code":"\t\ttest('.removeField should work on an object', () => {\n\t\t\texpect(evaluate('={{ ({ test1: 1, test2: 2, test3: 3 }).removeField(\"test2\") }}')).toEqual({\n\t\t\t\ttest1: 1,\n\t\t\t\ttest3: 3,\n\t\t\t});\n\t\t\texpect(\n\t\t\t\tevaluate('={{ ({ test1: 1, test2: 2, test3: 3 }).removeField(\"testDoesntExist\") }}'),\n\t\t\t).toEqual({\n\t\t\t\ttest1: 1,\n\t\t\t\ttest2: 2,\n\t\t\t\ttest3: 3,\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".removeFieldsContaining should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":29,"column":56},"line":29,"code":"\t\ttest('.removeFieldsContaining should work on an object', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ ({ test1: \"i exist\", test2: \"i should be removed\", test3: \"i should also be removed\" }).removeFieldsContaining(\"removed\") }}',\n\t\t\t\t),\n\t\t\t).toEqual({\n\t\t\t\ttest1: 'i exist',\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".removeFieldsContaining should not work for empty string","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":39,"column":64},"line":39,"code":"\t\ttest('.removeFieldsContaining should not work for empty string', () => {\n\t\t\texpect(() =>\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ ({ test1: \"i exist\", test2: \"i should be removed\", test3: \"i should also be removed\" }).removeFieldsContaining(\"\") }}',\n\t\t\t\t),\n\t\t\t).toThrow();\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".keepFieldsContaining should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":47,"column":54},"line":47,"code":"\t\ttest('.keepFieldsContaining should work on an object', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ ({ test1: \"i exist\", test2: \"i should be removed\", test3: \"i should also be removed\" }).keepFieldsContaining(\"exist\") }}',\n\t\t\t\t),\n\t\t\t).toEqual({\n\t\t\t\ttest1: 'i exist',\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".keepFieldsContaining should work on a nested object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":57,"column":60},"line":57,"code":"\t\ttest('.keepFieldsContaining should work on a nested object', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ ({ test1: \"i exist\", test2: \"i should be removed\", test3: { test4: \"me too\" } }).keepFieldsContaining(\"exist\") }}',\n\t\t\t\t),\n\t\t\t).toEqual({\n\t\t\t\ttest1: 'i exist',\n\t\t\t});\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".keepFieldsContaining should not work for empty string","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":67,"column":62},"line":67,"code":"\t\ttest('.keepFieldsContaining should not work for empty string', () => {\n\t\t\texpect(() =>\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ ({ test1: \"i exist\", test2: \"i should be removed\", test3: \"i should also be removed\" }).keepFieldsContaining(\"\") }}',\n\t\t\t\t),\n\t\t\t).toThrow();\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".compact should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":75,"column":41},"line":75,"code":"\t\ttest('.compact should work on an object', () => {\n\t\t\texpect(\n\t\t\t\tevaluate('={{ ({ test1: 1, test2: \"2\", test3: undefined, test4: null }).compact() }}'),\n\t\t\t).toEqual({ test1: 1, test2: '2' });\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".urlEncode should work on an object","suites":["Data Transformation Functions","Object Data Transformation Functions"],"updatePoint":{"line":81,"column":43},"line":81,"code":"\t\ttest('.urlEncode should work on an object', () => {\n\t\t\texpect(evaluate('={{ ({ test1: 1, test2: \"2\" }).urlEncode() }}')).toEqual('test1=1&test2=2');\n\t\t});","file":"ExpressionExtensions/ObjectExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on a string that is not empty","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":10,"column":70},"line":10,"code":"\t\ttest('.isEmpty() should work correctly on a string that is not empty', () => {\n\t\t\texpect(evaluate('={{\"NotBlank\".isEmpty()}}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmpty() should work correctly on a string that is empty","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":14,"column":66},"line":14,"code":"\t\ttest('.isEmpty() should work correctly on a string that is empty', () => {\n\t\t\texpect(evaluate('={{\"\".isEmpty()}}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".hash() should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":18,"column":49},"line":18,"code":"\t\ttest('.hash() should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"12345\".hash(\"sha256\") }}')).toEqual(\n\t\t\t\tstringExtensions.functions.hash('12345', ['sha256']),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ \"12345\".hash(\"sha256\") }}')).not.toEqual(\n\t\t\t\tstringExtensions.functions.hash('12345', ['MD5']),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ \"12345\".hash(\"MD5\") }}')).toEqual(\n\t\t\t\tstringExtensions.functions.hash('12345', ['MD5']),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{ \"12345\".hash(\"sha256\") }}')).toEqual(\n\t\t\t\t'5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".hash() alias should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":36,"column":55},"line":36,"code":"\t\ttest('.hash() alias should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"12345\".hash(\"sha256\") }}')).toEqual(\n\t\t\t\t'5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".urlDecode should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":42,"column":52},"line":42,"code":"\t\ttest('.urlDecode should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"string%20with%20spaces\".urlDecode(false) }}')).toEqual(\n\t\t\t\t'string with spaces',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".urlEncode should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":48,"column":52},"line":48,"code":"\t\ttest('.urlEncode should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"string with spaces\".urlEncode(false) }}')).toEqual(\n\t\t\t\t'string%20with%20spaces',\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".removeTags should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":54,"column":53},"line":54,"code":"\t\ttest('.removeTags should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"<html><head>test</head></html>\".removeTags() }}')).toEqual('test');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".removeMarkdown should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":58,"column":57},"line":58,"code":"\t\ttest('.removeMarkdown should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"<html><head>test</head></html>\".removeMarkdown() }}')).toEqual('test');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toLowerCase should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":62,"column":54},"line":62,"code":"\t\ttest('.toLowerCase should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"TEST\".toLowerCase() }}')).toEqual('test');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toDate should work correctly on a date string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":66,"column":54},"line":66,"code":"\t\ttest('.toDate should work correctly on a date string', () => {\n\t\t\texpect(evaluate('={{ \"2022-09-01T19:42:28.164Z\".toDate() }}')).toEqual(\n\t\t\t\tnew Date('2022-09-01T19:42:28.164Z'),\n\t\t\t);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toFloat should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":72,"column":50},"line":72,"code":"\t\ttest('.toFloat should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"1.1\".toFloat() }}')).toEqual(1.1);\n\t\t\texpect(evaluate('={{ \"1.1\".toDecimalNumber() }}')).toEqual(1.1);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toInt should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":77,"column":48},"line":77,"code":"\t\ttest('.toInt should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"1.1\".toInt() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ \"1.1\".toWholeNumber() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ \"1.5\".toInt() }}')).toEqual(1);\n\t\t\texpect(evaluate('={{ \"1.5\".toWholeNumber() }}')).toEqual(1);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".quote should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":84,"column":48},"line":84,"code":"\t\ttest('.quote should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"test\".quote() }}')).toEqual('\"test\"');\n\t\t\texpect(evaluate('={{ \"\\\\\"test\\\\\"\".quote() }}')).toEqual('\"\\\\\"test\\\\\"\"');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isNumeric should work correctly on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":89,"column":52},"line":89,"code":"\t\ttest('.isNumeric should work correctly on a string', () => {\n\t\t\texpect(evaluate('={{ \"\".isNumeric() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"asdf\".isNumeric() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"1234\".isNumeric() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"4e4\".isNumeric() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"4.4\".isNumeric() }}')).toEqual(true);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isUrl should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":97,"column":38},"line":97,"code":"\t\ttest('.isUrl should work on a string', () => {\n\t\t\texpect(evaluate('={{ \"https://example.com/\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"http://example.com/\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"ftp://example.com/\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"example.com\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"www.example.com\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"https://www.example.com/\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com/path\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com/path?query=1\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com/path#fragment\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com:8080\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com?query=1\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"https://example.com#fragment\".isUrl() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"example.com/path\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"http:///\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"https://\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example\".isUrl() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"\".isUrl() }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isDomain should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":117,"column":41},"line":117,"code":"\t\ttest('.isDomain should work on a string', () => {\n\t\t\texpect(evaluate('={{ \"example.com\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"asdf\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"https://example.com/\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"www.example.com\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"subdomain.example.com\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"example.co.uk\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"example\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example.\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \".com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example..com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example_com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example/com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"example com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"www.example..com\".isDomain() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"123.com\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"xn--80aswg.xn--p1ai\".isDomain() }}')).toEqual(true); // Punycode domain\n\t\t\texpect(evaluate('={{ \"example.com:8080\".isDomain() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"\".isDomain() }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toSnakeCase should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":138,"column":44},"line":138,"code":"\t\ttest('.toSnakeCase should work on a string', () => {\n\t\t\texpect(evaluate('={{ \"I am a test!\".toSnakeCase() }}')).toEqual('i_am_a_test');\n\t\t\texpect(evaluate('={{ \"i_am_a_test\".toSnakeCase() }}')).toEqual('i_am_a_test');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".toSentenceCase should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":143,"column":47},"line":143,"code":"\t\ttest('.toSentenceCase should work on a string', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ \"i am a test! i have multiple types of Punctuation. or do i?\".toSentenceCase() }}',\n\t\t\t\t),\n\t\t\t).toEqual('I am a test! I have multiple types of punctuation. Or do i?');\n\t\t\texpect(evaluate('={{ \"i am a test!\".toSentenceCase() }}')).toEqual('I am a test!');\n\t\t\texpect(evaluate('={{ \"i am a test\".toSentenceCase() }}')).toEqual('I am a test');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".extractUrl should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":153,"column":43},"line":153,"code":"\t\ttest('.extractUrl should work on a string', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ \"I am a test with a url: https://example.net/ and I am a test with an email: test@example.org\".extractUrl() }}',\n\t\t\t\t),\n\t\t\t).toEqual('https://example.net/');\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ \"Check this out: https://subdomain.example.com:3000/path?q=1#hash\".extractUrl() }}',\n\t\t\t\t),\n\t\t\t).toEqual('https://subdomain.example.com:3000/path?q=1#hash');\n\t\t\texpect(evaluate('={{ \"Invalid URL: http:///example.com\".extractUrl() }}')).toEqual(undefined);\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ \"Mixed content: https://www.example.com and http://www.example.org\".extractUrl() }}',\n\t\t\t\t),\n\t\t\t).toEqual('https://www.example.com');\n\t\t\texpect(\n\t\t\t\tevaluate('={{ \"Text without URL: This is just a simple text\".extractUrl() }}'),\n\t\t\t).toEqual(undefined);\n\t\t\texpect(\n\t\t\t\tevaluate('={{ \"URL with Unicode: http://www.xn--80aswg.xn--j1amh\".extractUrl() }}'),\n\t\t\t).toEqual('http://www.xn--80aswg.xn--j1amh');\n\t\t\texpect(\n\t\t\t\tevaluate('={{ \"Localhost URL: http://localhost:8080/test?x=1\".extractUrl() }}'),\n\t\t\t).toEqual('http://localhost:8080/test?x=1');\n\t\t\texpect(\n\t\t\t\tevaluate('={{ \"IP URL: http://192.168.1.1:8000/path?q=value#frag\".extractUrl() }}'),\n\t\t\t).toEqual('http://192.168.1.1:8000/path?q=value#frag');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".extractDomain should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":184,"column":46},"line":184,"code":"\t\ttest('.extractDomain should work on a string', () => {\n\t\t\texpect(evaluate('={{ \"test@example.org\".extractDomain() }}')).toEqual('example.org');\n\t\t\texpect(evaluate('={{ \"https://example.org/\".extractDomain() }}')).toEqual('example.org');\n\t\t\texpect(evaluate('={{ \"https://www.google.com\".extractDomain() }}')).toEqual('www.google.com');\n\t\t\texpect(evaluate('={{ \"http://example.org\".extractDomain() }}')).toEqual('example.org');\n\t\t\texpect(evaluate('={{ \"ftp://ftp.example.com\".extractDomain() }}')).toEqual('ftp.example.com');\n\t\t\texpect(evaluate('={{ \"google.com\".extractDomain() }}')).toEqual('google.com');\n\t\t\texpect(evaluate('={{ \"www.example.net\".extractDomain() }}')).toEqual('www.example.net');\n\t\t\texpect(evaluate('={{ \"//example.com\".extractDomain() }}')).toEqual('example.com');\n\t\t\texpect(evaluate('={{ \"mailto:john.doe@example.com\".extractDomain() }}')).toEqual(\n\t\t\t\t'example.com',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"tel:+1-555-123-4567\".extractDomain() }}')).toEqual(undefined);\n\t\t\texpect(evaluate('={{ \"jane.doe@example.org\".extractDomain() }}')).toEqual('example.org');\n\t\t\texpect(evaluate('={{ \"name+tag@example.com\".extractDomain() }}')).toEqual('example.com');\n\t\t\texpect(evaluate('={{ \"first.last@example.co.uk\".extractDomain() }}')).toEqual(\n\t\t\t\t'example.co.uk',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"user@subdomain.example.com\".extractDomain() }}')).toEqual(\n\t\t\t\t'subdomain.example.com',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"www.example.net?test=1213\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.net',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"www.example.net?test\".extractDomain() }}')).toEqual('www.example.net');\n\t\t\texpect(evaluate('={{ \"www.example.net#tesdt123\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.net',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://www.example.net?test=1213\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.net',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://www.example.net?test\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.net',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://www.example.net#tesdt123\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.net',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://192.168.1.1\".extractDomain() }}')).toEqual('192.168.1.1');\n\t\t\texpect(evaluate('={{ \"http://www.xn--80aswg.xn--j1amh\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.xn--80aswg.xn--j1amh',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://localhost\".extractDomain() }}')).toEqual('localhost');\n\t\t\texpect(evaluate('={{ \"https://localhost?test=123\".extractDomain() }}')).toEqual('localhost');\n\t\t\texpect(evaluate('={{ \"https://www.example_with_underscore.com\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example_with_underscore.com',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://www.example.com:8080\".extractDomain() }}')).toEqual(\n\t\t\t\t'www.example.com',\n\t\t\t);\n\t\t\texpect(evaluate('={{ \"https://example.space\".extractDomain() }}')).toEqual('example.space');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".extractEmail should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":236,"column":45},"line":236,"code":"\t\ttest('.extractEmail should work on a string', () => {\n\t\t\texpect(\n\t\t\t\tevaluate(\n\t\t\t\t\t'={{ \"I am a test with a url: https://example.net/ and I am a test with an email: test@example.org\".extractEmail() }}',\n\t\t\t\t),\n\t\t\t).toEqual('test@example.org');\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":".isEmail should work on a string","suites":["Data Transformation Functions","String Data Transformation Functions"],"updatePoint":{"line":244,"column":40},"line":244,"code":"\t\ttest('.isEmail should work on a string', () => {\n\t\t\texpect(evaluate('={{ \"test@example.com\".isEmail() }}')).toEqual(true);\n\t\t\texpect(evaluate('={{ \"aaaaaaaa\".isEmail() }}')).toEqual(false);\n\t\t\texpect(evaluate('={{ \"test @ n8n\".isEmail() }}')).toEqual(false);\n\t\t});","file":"ExpressionExtensions/StringExtensions.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return unknown error message","suites":["NodeErrors tests"],"updatePoint":{"line":16,"column":40},"line":16,"code":"\tit('should return unknown error message', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {});\n\n\t\texpect(nodeApiError.message).toEqual(\n\t\t\t'UNKNOWN ERROR - check the detailed error for more information',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return the error message","suites":["NodeErrors tests"],"updatePoint":{"line":24,"column":36},"line":24,"code":"\tit('should return the error message', () => {\n\t\tconst nodeApiError = new NodeApiError(node, { message: 'test error message' });\n\n\t\texpect(nodeApiError.message).toEqual('test error message');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return the error message defined in reason","suites":["NodeErrors tests"],"updatePoint":{"line":30,"column":54},"line":30,"code":"\tit('should return the error message defined in reason', () => {\n\t\tconst nodeApiError = new NodeApiError(node, { reason: { message: 'test error message' } });\n\n\t\texpect(nodeApiError.message).toEqual('test error message');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return the error message defined in options","suites":["NodeErrors tests"],"updatePoint":{"line":36,"column":55},"line":36,"code":"\tit('should return the error message defined in options', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {}, { message: 'test error message' });\n\n\t\texpect(nodeApiError.message).toEqual('test error message');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return description error message","suites":["NodeErrors tests"],"updatePoint":{"line":42,"column":44},"line":42,"code":"\tit('should return description error message', () => {\n\t\tconst nodeApiError = new NodeApiError(node, { description: 'test error description' });\n\n\t\texpect(nodeApiError.message).toEqual('test error description');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return description as error message defined in reason","suites":["NodeErrors tests"],"updatePoint":{"line":48,"column":65},"line":48,"code":"\tit('should return description as error message defined in reason', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {\n\t\t\treason: { description: 'test error description' },\n\t\t});\n\n\t\texpect(nodeApiError.message).toEqual('test error description');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return description as error message defined in options","suites":["NodeErrors tests"],"updatePoint":{"line":56,"column":66},"line":56,"code":"\tit('should return description as error message defined in options', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {}, { description: 'test error description' });\n\n\t\texpect(nodeApiError.message).toEqual('test error description');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for ECONNREFUSED","suites":["NodeErrors tests"],"updatePoint":{"line":62,"column":51},"line":62,"code":"\tit('should return default message for ECONNREFUSED', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {\n\t\t\tmessage: 'ECONNREFUSED',\n\t\t});\n\n\t\texpect(nodeApiError.message).toEqual(\n\t\t\t'The service refused the connection - perhaps it is offline',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for 502","suites":["NodeErrors tests"],"updatePoint":{"line":72,"column":42},"line":72,"code":"\tit('should return default message for 502', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {\n\t\t\tmessage: '502 Bad Gateway',\n\t\t});\n\n\t\texpect(nodeApiError.message).toEqual('Bad gateway - the service failed to handle your request');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for ENOTFOUND, NodeOperationError","suites":["NodeErrors tests"],"updatePoint":{"line":80,"column":68},"line":80,"code":"\tit('should return default message for ENOTFOUND, NodeOperationError', () => {\n\t\tconst nodeOperationError = new NodeOperationError(node, 'ENOTFOUND test error message');\n\n\t\texpect(nodeOperationError.message).toEqual(\n\t\t\t'The connection cannot be established, this usually occurs due to an incorrect host(domain) value',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for ENOTFOUND, NodeApiError","suites":["NodeErrors tests"],"updatePoint":{"line":88,"column":62},"line":88,"code":"\tit('should return default message for ENOTFOUND, NodeApiError', () => {\n\t\tconst nodeApiError = new NodeApiError(node, { message: 'ENOTFOUND test error message' });\n\n\t\texpect(nodeApiError.message).toEqual(\n\t\t\t'The connection cannot be established, this usually occurs due to an incorrect host(domain) value',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for EEXIST based on code, NodeApiError","suites":["NodeErrors tests"],"updatePoint":{"line":96,"column":73},"line":96,"code":"\tit('should return default message for EEXIST based on code, NodeApiError', () => {\n\t\tconst nodeApiError = new NodeApiError(node, {\n\t\t\tmessage: 'test error message',\n\t\t\tcode: 'EEXIST',\n\t\t});\n\n\t\texpect(nodeApiError.message).toEqual('The file or directory already exists');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should update description GETADDRINFO, NodeOperationError","suites":["NodeErrors tests"],"updatePoint":{"line":105,"column":62},"line":105,"code":"\tit('should update description GETADDRINFO, NodeOperationError', () => {\n\t\tconst nodeOperationError = new NodeOperationError(node, 'GETADDRINFO test error message', {\n\t\t\tdescription: 'test error description',\n\t\t});\n\n\t\texpect(nodeOperationError.message).toEqual('The server closed the connection unexpectedly');\n\n\t\texpect(nodeOperationError.description).toEqual(\n\t\t\t'GETADDRINFO test error message - test error description',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should remove description if it is equal to message, NodeOperationError","suites":["NodeErrors tests"],"updatePoint":{"line":117,"column":76},"line":117,"code":"\tit('should remove description if it is equal to message, NodeOperationError', () => {\n\t\tconst nodeOperationError = new NodeOperationError(node, 'some text', {\n\t\t\tdescription: 'some text',\n\t\t});\n\n\t\texpect(nodeOperationError.message).toEqual('some text');\n\n\t\texpect(nodeOperationError.description).toEqual(undefined);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should remove description if it is equal to message, message provided in options take precedence over original, NodeApiError","suites":["NodeErrors tests"],"updatePoint":{"line":127,"column":129},"line":127,"code":"\tit('should remove description if it is equal to message, message provided in options take precedence over original, NodeApiError', () => {\n\t\tconst nodeApiError = new NodeApiError(\n\t\t\tnode,\n\t\t\t{\n\t\t\t\tmessage: 'original message',\n\t\t\t},\n\t\t\t{ message: 'new text', description: 'new text' },\n\t\t);\n\n\t\texpect(nodeApiError.message).toEqual('new text');\n\n\t\texpect(nodeApiError.description).toEqual(undefined);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return mapped message for MYMAPPEDMESSAGE, NodeOperationError","suites":["NodeErrors tests"],"updatePoint":{"line":141,"column":73},"line":141,"code":"\tit('should return mapped message for MYMAPPEDMESSAGE, NodeOperationError', () => {\n\t\tconst nodeOperationError = new NodeOperationError(node, 'MYMAPPEDMESSAGE test error message', {\n\t\t\tmessageMapping: {\n\t\t\t\tMYMAPPEDMESSAGE: 'test error message',\n\t\t\t},\n\t\t});\n\n\t\texpect(nodeOperationError.message).toEqual('test error message');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return mapped message for MYMAPPEDMESSAGE, NodeApiError","suites":["NodeErrors tests"],"updatePoint":{"line":151,"column":67},"line":151,"code":"\tit('should return mapped message for MYMAPPEDMESSAGE, NodeApiError', () => {\n\t\tconst nodeApiError = new NodeApiError(\n\t\t\tnode,\n\t\t\t{ message: 'MYMAPPEDMESSAGE test error message' },\n\t\t\t{\n\t\t\t\tmessageMapping: {\n\t\t\t\t\tMYMAPPEDMESSAGE: 'test error message',\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\texpect(nodeApiError.message).toEqual('test error message');\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should return default message for EACCES, custom mapping not found, NodeOperationError","suites":["NodeErrors tests"],"updatePoint":{"line":165,"column":91},"line":165,"code":"\tit('should return default message for EACCES, custom mapping not found, NodeOperationError', () => {\n\t\tconst nodeOperationError = new NodeOperationError(node, 'EACCES test error message', {\n\t\t\tmessageMapping: {\n\t\t\t\tMYMAPPEDMESSAGE: 'test error message',\n\t\t\t},\n\t\t});\n\n\t\texpect(nodeOperationError.message).toEqual(\n\t\t\t'Forbidden by access permissions, make sure you have the right permissions',\n\t\t);\n\t});","file":"NodeErrors.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got added (init empty)","suites":["ObservableObject"],"updatePoint":{"line":5,"column":72},"line":5,"code":"\ttest('should recognize that item on parent level got added (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\n\t\t// Make sure that \"__dataChanged\" does not returned as a key\n\t\texpect(Object.keys(testObject)).toEqual(['a']);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":15,"column":142},"line":15,"code":"\ttest('should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":23,"column":142},"line":23,"code":"\ttest('should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = { b: 2 };\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({ b: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":31,"column":141},"line":31,"code":"\ttest('should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [];\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":39,"column":139},"line":39,"code":"\ttest('should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [1, 2];\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":47,"column":76},"line":47,"code":"\ttest('should recognize that item on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual(1);\n\t\ttestObject.a = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":56,"column":77},"line":56,"code":"\ttest('should recognize that array on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: [1, 2] });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t\t(testObject.a as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":65,"column":81},"line":65,"code":"\ttest('should recognize that item on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\t(testObject.a! as IDataObject).b = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":74,"column":146},"line":74,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":85,"column":147},"line":85,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: false,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":96,"column":82},"line":96,"code":"\ttest('should recognize that array on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: [1, 2] } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2]);\n\t\t((testObject.a! as IDataObject).b as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":105,"column":82},"line":105,"code":"\ttest('should recognize that item on second child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(1);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":115,"column":80},"line":115,"code":"\ttest('should recognize that item on parent level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":125,"column":136},"line":125,"code":"\ttest('should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":137,"column":86},"line":137,"code":"\ttest('should recognize that item on second child level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\tdelete (testObject.a! as IDataObject).b;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(undefined);\n\t\texpect(testObject).toEqual({ a: {} });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed with null (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":147,"column":92},"line":147,"code":"\ttest('should recognize that item on second child level changed with null (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: null } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: null });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(null);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":5,"column":20},"line":5,"code":"\ttest('in valid URLs', () => {\n\t\tfor (const url of validUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":12,"column":24},"line":12,"code":"\ttest('in malformed URLs', () => {\n\t\tfor (const url of malformedUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":22,"column":21},"line":22,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":29,"column":25},"line":29,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":38,"column":21},"line":38,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of uuidUrls(validUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":45,"column":25},"line":45,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of uuidUrls(malformedUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":54,"column":21},"line":54,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":61,"column":25},"line":61,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast ISO dates","suites":["Type Validation"],"updatePoint":{"line":48,"column":39},"line":48,"code":"\tit('should validate and cast ISO dates', () => {\n\t\tVALID_ISO_DATES.forEach((date) => {\n\t\t\tconst validationResult = validateFieldType('date', date, 'dateTime');\n\t\t\texpect(validationResult.valid).toBe(true);\n\t\t\texpect((validationResult.newValue as DateTime).isValid).toBe(true);\n\t\t});\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast RFC 2822 dates","suites":["Type Validation"],"updatePoint":{"line":56,"column":44},"line":56,"code":"\tit('should validate and cast RFC 2822 dates', () => {\n\t\tVALID_RFC_DATES.forEach((date) => {\n\t\t\tconst validationResult = validateFieldType('date', date, 'dateTime');\n\t\t\texpect(validationResult.valid).toBe(true);\n\t\t\texpect((validationResult.newValue as DateTime).isValid).toBe(true);\n\t\t});\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast HTTP dates","suites":["Type Validation"],"updatePoint":{"line":64,"column":40},"line":64,"code":"\tit('should validate and cast HTTP dates', () => {\n\t\tVALID_HTTP_DATES.forEach((date) => {\n\t\t\tconst validationResult = validateFieldType('date', date, 'dateTime');\n\t\t\texpect(validationResult.valid).toBe(true);\n\t\t\texpect((validationResult.newValue as DateTime).isValid).toBe(true);\n\t\t});\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast SQL dates","suites":["Type Validation"],"updatePoint":{"line":72,"column":39},"line":72,"code":"\tit('should validate and cast SQL dates', () => {\n\t\tVALID_SQL_DATES.forEach((date) => {\n\t\t\tconst validationResult = validateFieldType('date', date, 'dateTime');\n\t\t\texpect(validationResult.valid).toBe(true);\n\t\t\texpect((validationResult.newValue as DateTime).isValid).toBe(true);\n\t\t});\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not validate invalid dates","suites":["Type Validation"],"updatePoint":{"line":80,"column":38},"line":80,"code":"\tit('should not validate invalid dates', () => {\n\t\tINVALID_DATES.forEach((date) => {\n\t\t\tconst validationResult = validateFieldType('date', date, 'dateTime');\n\t\t\texpect(validationResult.valid).toBe(false);\n\t\t});\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate boolean values properly","suites":["Type Validation"],"updatePoint":{"line":87,"column":44},"line":87,"code":"\tit('should validate boolean values properly', () => {\n\t\texpect(validateFieldType('boolean', 'true', 'boolean').newValue).toBe(true);\n\t\texpect(validateFieldType('boolean', 'TRUE', 'boolean').newValue).toBe(true);\n\t\texpect(validateFieldType('boolean', 1, 'boolean').newValue).toBe(true);\n\t\texpect(validateFieldType('boolean', '1', 'boolean').newValue).toBe(true);\n\t\texpect(validateFieldType('boolean', '01', 'boolean').newValue).toBe(true);\n\t\texpect(validateFieldType('boolean', 'false', 'boolean').newValue).toBe(false);\n\t\texpect(validateFieldType('boolean', 'FALSE', 'boolean').newValue).toBe(false);\n\t\texpect(validateFieldType('boolean', '0', 'boolean').newValue).toBe(false);\n\t\texpect(validateFieldType('boolean', '000', 'boolean').newValue).toBe(false);\n\t\texpect(validateFieldType('boolean', '0000', 'boolean').newValue).toBe(false);\n\t\texpect(validateFieldType('boolean', 0, 'boolean').newValue).toBe(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not validate invalid boolean values","suites":["Type Validation"],"updatePoint":{"line":101,"column":47},"line":101,"code":"\tit('should not validate invalid boolean values', () => {\n\t\texpect(validateFieldType('boolean', 'tru', 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', 'fals', 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', 1111, 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', 2, 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', -1, 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', 'yes', 'boolean').valid).toBe(false);\n\t\texpect(validateFieldType('boolean', 'no', 'boolean').valid).toBe(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast numbers","suites":["Type Validation"],"updatePoint":{"line":111,"column":37},"line":111,"code":"\tit('should validate and cast numbers', () => {\n\t\texpect(validateFieldType('number', '1', 'number').newValue).toBe(1);\n\t\texpect(validateFieldType('number', '-1', 'number').newValue).toBe(-1);\n\t\texpect(validateFieldType('number', '1.1', 'number').newValue).toBe(1.1);\n\t\texpect(validateFieldType('number', '-1.1', 'number').newValue).toBe(-1.1);\n\t\texpect(validateFieldType('number', 1, 'number').newValue).toBe(1);\n\t\texpect(validateFieldType('number', 'A', 'number').valid).toBe(false);\n\t\texpect(validateFieldType('number', '1,1', 'number').valid).toBe(false);\n\t\texpect(validateFieldType('number', true, 'number').valid).toBe(true);\n\t\texpect(validateFieldType('number', '1972-06-30T23:59:40Z', 'number').valid).toBe(false);\n\t\texpect(validateFieldType('number', [1, 2], 'number').valid).toBe(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast JSON properly","suites":["Type Validation"],"updatePoint":{"line":124,"column":43},"line":124,"code":"\tit('should validate and cast JSON properly', () => {\n\t\texpect(validateFieldType('json', '{\"a\": 1}', 'object').newValue).toEqual({ a: 1 });\n\t\texpect(\n\t\t\tvalidateFieldType('json', '{\"a\": 1, \"b\": { \"c\": 10, \"d\": \"test\"}}', 'object').valid,\n\t\t).toEqual(true);\n\t\texpect(validateFieldType('json', { name: 'John' }, 'object').valid).toEqual(true);\n\t\texpect(\n\t\t\tvalidateFieldType(\n\t\t\t\t'json',\n\t\t\t\t{ name: 'John', address: { street: 'Via Roma', city: 'Milano' } },\n\t\t\t\t'object',\n\t\t\t).valid,\n\t\t).toEqual(true);\n\t\t// Invalid value:\n\t\texpect(validateFieldType('json', ['one', 'two'], 'object').valid).toEqual(false);\n\t\t// eslint-disable-next-line prettier/prettier\n\t\texpect(validateFieldType('json', [\"one\", \"two\"], 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '1', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '[1]', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '1.1', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', 1.1, 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '\"a\"', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '{a: 1}', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', '[\"apples\", \"oranges\"]', 'object').valid).toEqual(false);\n\t\texpect(validateFieldType('json', [{ name: 'john' }, { name: 'bob' }], 'object').valid).toEqual(\n\t\t\tfalse,\n\t\t);\n\t\texpect(\n\t\t\tvalidateFieldType('json', '[ { name: \"john\" }, { name: \"bob\" } ]', 'object').valid,\n\t\t).toEqual(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast arrays properly","suites":["Type Validation"],"updatePoint":{"line":156,"column":45},"line":156,"code":"\tit('should validate and cast arrays properly', () => {\n\t\texpect(validateFieldType('array', '[\"apples\", \"oranges\"]', 'array').newValue).toEqual([\n\t\t\t'apples',\n\t\t\t'oranges',\n\t\t]);\n\t\texpect(validateFieldType('array', '[1]', 'array').newValue).toEqual([1]);\n\t\texpect(validateFieldType('array', '[1, 2]', 'array').newValue).toEqual([1, 2]);\n\t\t// Invalid values:\n\t\texpect(validateFieldType('array', '\"apples\", \"oranges\"', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1.1', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1, 2', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1. 2. 3', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '[1, 2, 3', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1, 2, 3]', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '{1, 2, {3, 4}, 5}', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', '1, 2, {3, 4}, 5', 'array').valid).toEqual(false);\n\t\texpect(validateFieldType('array', { name: 'John' }, 'array').valid).toEqual(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate options properly","suites":["Type Validation"],"updatePoint":{"line":176,"column":37},"line":176,"code":"\tit('should validate options properly', () => {\n\t\texpect(\n\t\t\tvalidateFieldType('options', 'oranges', 'options', [\n\t\t\t\t{ name: 'apples', value: 'apples' },\n\t\t\t\t{ name: 'oranges', value: 'oranges' },\n\t\t\t]).valid,\n\t\t).toEqual(true);\n\t\texpect(\n\t\t\tvalidateFieldType('options', 'something else', 'options', [\n\t\t\t\t{ name: 'apples', value: 'apples' },\n\t\t\t\t{ name: 'oranges', value: 'oranges' },\n\t\t\t]).valid,\n\t\t).toEqual(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should validate and cast time properly","suites":["Type Validation"],"updatePoint":{"line":191,"column":43},"line":191,"code":"\tit('should validate and cast time properly', () => {\n\t\texpect(validateFieldType('time', '23:23', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '23:23:23', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '23:23:23+1000', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '23:23:23-1000', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '22:00:00+01:00', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '22:00:00-01:00', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '22:00:00+01', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '22:00:00-01', 'time').valid).toEqual(true);\n\t\texpect(validateFieldType('time', '23:23:23:23', 'time').valid).toEqual(false);\n\t\texpect(validateFieldType('time', '23', 'time').valid).toEqual(false);\n\t\texpect(validateFieldType('time', 'foo', 'time').valid).toEqual(false);\n\t\texpect(validateFieldType('time', '23:23:', 'time').valid).toEqual(false);\n\t\texpect(validateFieldType('time', '23::23::23', 'time').valid).toEqual(false);\n\t});","file":"TypeValidation.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle null and undefined","suites":["isObjectEmpty"],"updatePoint":{"line":4,"column":37},"line":4,"code":"\tit('should handle null and undefined', () => {\n\t\texpect(isObjectEmpty(null)).toEqual(true);\n\t\texpect(isObjectEmpty(undefined)).toEqual(true);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle arrays","suites":["isObjectEmpty"],"updatePoint":{"line":9,"column":25},"line":9,"code":"\tit('should handle arrays', () => {\n\t\texpect(isObjectEmpty([])).toEqual(true);\n\t\texpect(isObjectEmpty([1, 2, 3])).toEqual(false);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle Set and Map","suites":["isObjectEmpty"],"updatePoint":{"line":14,"column":30},"line":14,"code":"\tit('should handle Set and Map', () => {\n\t\texpect(isObjectEmpty(new Set())).toEqual(true);\n\t\texpect(isObjectEmpty(new Set([1, 2, 3]))).toEqual(false);\n\n\t\texpect(isObjectEmpty(new Map())).toEqual(true);\n\t\texpect(\n\t\t\tisObjectEmpty(\n\t\t\t\tnew Map([\n\t\t\t\t\t['a', 1],\n\t\t\t\t\t['b', 2],\n\t\t\t\t]),\n\t\t\t),\n\t\t).toEqual(false);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle Buffer, ArrayBuffer, and Uint8Array","suites":["isObjectEmpty"],"updatePoint":{"line":29,"column":54},"line":29,"code":"\tit('should handle Buffer, ArrayBuffer, and Uint8Array', () => {\n\t\texpect(isObjectEmpty(Buffer.from(''))).toEqual(true);\n\t\texpect(isObjectEmpty(Buffer.from('abcd'))).toEqual(false);\n\n\t\texpect(isObjectEmpty(Uint8Array.from([]))).toEqual(true);\n\t\texpect(isObjectEmpty(Uint8Array.from([1, 2, 3]))).toEqual(false);\n\n\t\texpect(isObjectEmpty(new ArrayBuffer(0))).toEqual(true);\n\t\texpect(isObjectEmpty(new ArrayBuffer(1))).toEqual(false);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle plain objects","suites":["isObjectEmpty"],"updatePoint":{"line":40,"column":32},"line":40,"code":"\tit('should handle plain objects', () => {\n\t\texpect(isObjectEmpty({})).toEqual(true);\n\t\texpect(isObjectEmpty({ a: 1, b: 2 })).toEqual(false);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should handle instantiated classes","suites":["isObjectEmpty"],"updatePoint":{"line":45,"column":39},"line":45,"code":"\tit('should handle instantiated classes', () => {\n\t\texpect(isObjectEmpty(new (class Test {})())).toEqual(true);\n\t\texpect(\n\t\t\tisObjectEmpty(\n\t\t\t\tnew (class Test {\n\t\t\t\t\tprop = 123;\n\t\t\t\t})(),\n\t\t\t),\n\t\t).toEqual(false);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not call Object.keys unless a plain object","suites":["isObjectEmpty"],"updatePoint":{"line":56,"column":54},"line":56,"code":"\tit('should not call Object.keys unless a plain object', () => {\n\t\tconst keySpy = jest.spyOn(Object, 'keys');\n\t\tconst { calls } = keySpy.mock;\n\n\t\tconst assertCalls = (count: number) => {\n\t\t\tif (calls.length !== count) throw new Error(`Object.keys was called ${calls.length} times`);\n\t\t};\n\n\t\tassertCalls(0);\n\t\tisObjectEmpty(null);\n\t\tassertCalls(0);\n\t\tisObjectEmpty([1, 2, 3]);\n\t\tassertCalls(0);\n\t\tisObjectEmpty(Buffer.from('123'));\n\t\tassertCalls(0);\n\t\tisObjectEmpty({});\n\t\tassertCalls(1);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"parses JSON","suites":["jsonParse"],"updatePoint":{"line":77,"column":16},"line":77,"code":"\tit('parses JSON', () => {\n\t\texpect(jsonParse('[1, 2, 3]')).toEqual([1, 2, 3]);\n\t\texpect(jsonParse('{ \"a\": 1 }')).toEqual({ a: 1 });\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"optionally throws `errorMessage","suites":["jsonParse"],"updatePoint":{"line":82,"column":36},"line":82,"code":"\tit('optionally throws `errorMessage', () => {\n\t\texpect(() => {\n\t\t\tjsonParse('', { errorMessage: 'Invalid JSON' });\n\t\t}).toThrow('Invalid JSON');\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"optionally returns a `fallbackValue`","suites":["jsonParse"],"updatePoint":{"line":88,"column":41},"line":88,"code":"\tit('optionally returns a `fallbackValue`', () => {\n\t\texpect(jsonParse('', { fallbackValue: { foo: 'bar' } })).toEqual({ foo: 'bar' });\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should throw errors on circular references by default","suites":["jsonStringify"],"updatePoint":{"line":97,"column":58},"line":97,"code":"\tit('should throw errors on circular references by default', () => {\n\t\texpect(() => jsonStringify(source)).toThrow('Converting circular structure to JSON');\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should break circular references when requested","suites":["jsonStringify"],"updatePoint":{"line":101,"column":52},"line":101,"code":"\tit('should break circular references when requested', () => {\n\t\texpect(jsonStringify(source, { replaceCircularRefs: true })).toEqual(\n\t\t\t'{\"a\":1,\"b\":2,\"d\":\"2023-03-29T11:24:44.200Z\",\"r\":{},\"c\":\"[Circular Reference]\"}',\n\t\t);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not detect duplicates as circular references","suites":["jsonStringify"],"updatePoint":{"line":107,"column":56},"line":107,"code":"\tit('should not detect duplicates as circular references', () => {\n\t\tconst y = { z: 5 };\n\t\tconst x = [y, y, { y }];\n\t\texpect(jsonStringify(x, { replaceCircularRefs: true })).toEqual(\n\t\t\t'[{\"z\":5},{\"z\":5},{\"y\":{\"z\":5}}]',\n\t\t);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should deep copy an object","suites":["deepCopy"],"updatePoint":{"line":117,"column":31},"line":117,"code":"\tit('should deep copy an object', () => {\n\t\tconst serializable = {\n\t\t\tx: 1,\n\t\t\ty: 2,\n\t\t\ttoJSON: () => 'x:1,y:2',\n\t\t};\n\t\tconst object = {\n\t\t\tdeep: {\n\t\t\t\tprops: {\n\t\t\t\t\tlist: [{ a: 1 }, { b: 2 }, { c: 3 }],\n\t\t\t\t},\n\t\t\t\tarr: [1, 2, 3],\n\t\t\t},\n\t\t\tserializable,\n\t\t\tarr: [\n\t\t\t\t{\n\t\t\t\t\tprop: {\n\t\t\t\t\t\tlist: ['a', 'b', 'c'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tfunc: () => {},\n\t\t\tdate: new Date(1667389172201),\n\t\t\tundef: undefined,\n\t\t\tnil: null,\n\t\t\tbool: true,\n\t\t\tnum: 1,\n\t\t};\n\t\tconst copy = deepCopy(object);\n\t\texpect(copy).not.toBe(object);\n\t\texpect(copy.arr).toEqual(object.arr);\n\t\texpect(copy.arr).not.toBe(object.arr);\n\t\texpect(copy.date).toBe('2022-11-02T11:39:32.201Z');\n\t\texpect(copy.serializable).toBe(serializable.toJSON());\n\t\texpect(copy.deep.props).toEqual(object.deep.props);\n\t\texpect(copy.deep.props).not.toBe(object.deep.props);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should avoid max call stack in case of circular deps","suites":["deepCopy"],"updatePoint":{"line":155,"column":57},"line":155,"code":"\tit('should avoid max call stack in case of circular deps', () => {\n\t\tconst object: Record<string, any> = {\n\t\t\tdeep: {\n\t\t\t\tprops: {\n\t\t\t\t\tlist: [{ a: 1 }, { b: 2 }, { c: 3 }],\n\t\t\t\t},\n\t\t\t\tarr: [1, 2, 3],\n\t\t\t},\n\t\t\tarr: [\n\t\t\t\t{\n\t\t\t\t\tprop: {\n\t\t\t\t\t\tlist: ['a', 'b', 'c'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tfunc: () => {},\n\t\t\tdate: new Date(1667389172201),\n\t\t\tundef: undefined,\n\t\t\tnil: null,\n\t\t\tbool: true,\n\t\t\tnum: 1,\n\t\t};\n\n\t\tobject.circular = object;\n\t\tobject.deep.props.circular = object;\n\t\tobject.deep.arr.push(object);\n\n\t\tconst copy = deepCopy(object);\n\t\texpect(copy).not.toBe(object);\n\t\texpect(copy.arr).toEqual(object.arr);\n\t\texpect(copy.arr).not.toBe(object.arr);\n\t\texpect(copy.date).toBe('2022-11-02T11:39:32.201Z');\n\t\texpect(copy.deep.props.circular).toBe(copy);\n\t\texpect(copy.deep.props.circular).not.toBe(object);\n\t\texpect(copy.deep.arr.slice(-1)[0]).toBe(copy);\n\t\texpect(copy.deep.arr.slice(-1)[0]).not.toBe(object);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should also resolve all child parameters when the parent get requested","suites":["Workflow","getParameterValue"],"updatePoint":{"line":1397,"column":78},"line":1397,"code":"\t\ttest('should also resolve all child parameters when the parent get requested', () => {\n\t\t\tconst nodeTypes = Helpers.NodeTypes();\n\n\t\t\tconst nodes: INode[] = [\n\t\t\t\t{\n\t\t\t\t\tname: 'Node1',\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tstring: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\t\t\t\tvalue: '={{$parameter.values.string[0].value}}A',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'test.setMulti',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tposition: [100, 100],\n\t\t\t\t},\n\t\t\t];\n\t\t\tconst connections: IConnections = {};\n\n\t\t\tconst workflow = new Workflow({ nodes, connections, active: false, nodeTypes });\n\t\t\tconst activeNodeName = 'Node1';\n\n\t\t\tconst runExecutionData: IRunExecutionData = {\n\t\t\t\tresultData: {\n\t\t\t\t\trunData: {\n\t\t\t\t\t\tNode1: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstartTime: 1,\n\t\t\t\t\t\t\t\texecutionTime: 1,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmain: [\n\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tjson: {},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tsource: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst itemIndex = 0;\n\t\t\tconst runIndex = 0;\n\t\t\tconst connectionInputData: INodeExecutionData[] =\n\t\t\t\trunExecutionData.resultData.runData.Node1[0]!.data!.main[0]!;\n\t\t\tconst parameterName = 'values';\n\n\t\t\tconst parameterValue = nodes.find((node) => node.name === activeNodeName)!.parameters[\n\t\t\t\tparameterName\n\t\t\t];\n\t\t\tconst result = workflow.expression.getParameterValue(\n\t\t\t\tparameterValue,\n\t\t\t\trunExecutionData,\n\t\t\t\trunIndex,\n\t\t\t\titemIndex,\n\t\t\t\tactiveNodeName,\n\t\t\t\tconnectionInputData,\n\t\t\t\t'manual',\n\t\t\t\ttimezone,\n\t\t\t\t{},\n\t\t\t);\n\n\t\t\texpect(result).toEqual({\n\t\t\t\tstring: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\tvalue: 'value1A',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent nodes of nodes","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1752,"column":43},"line":1752,"code":"\t\ttest('Should return parent nodes of nodes', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent up to depth","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1775,"column":40},"line":1775,"code":"\t\ttest('Should return parent up to depth', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 0)).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return all parents with depth of -1","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1786,"column":50},"line":1786,"code":"\t\ttest('Should return all parents with depth of -1', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', -1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parents of nodes with all connected output indicies","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1801,"column":73},"line":1801,"code":"\t\ttest('Should return parents of nodes with all connected output indicies', () => {\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Switch')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [1, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set2')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [1, 2, 0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should handle loops within workflows","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1837,"column":44},"line":1837,"code":"\t\ttest('Should handle loops within workflows', () => {\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 3,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Switch')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":265,"column":32},"line":265,"code":"\t\ttest('test $(\"NodeName\").all()', () => {\n\t\t\texpect(proxy.$('Rename').all()[1].json.data).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":268,"column":39},"line":268,"code":"\t\ttest('test $(\"NodeName\").all() length', () => {\n\t\t\texpect(proxy.$('Rename').all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":271,"column":31},"line":271,"code":"\t\ttest('test $(\"NodeName\").item', () => {\n\t\t\texpect(proxy.$('Rename').item).toEqual({ json: { data: 105 }, pairedItem: { item: 0 } });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeNameEarlier\").item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":274,"column":38},"line":274,"code":"\t\ttest('test $(\"NodeNameEarlier\").item', () => {\n\t\t\texpect(proxy.$('Function').item).toEqual({\n\t\t\t\tjson: { initialName: 105 },\n\t\t\t\tpairedItem: { item: 0 },\n\t\t\t});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").itemMatching(2)","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":280,"column":42},"line":280,"code":"\t\ttest('test $(\"NodeName\").itemMatching(2)', () => {\n\t\t\texpect(proxy.$('Rename').itemMatching(2).json.data).toEqual(121);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":283,"column":34},"line":283,"code":"\t\ttest('test $(\"NodeName\").first()', () => {\n\t\t\texpect(proxy.$('Rename').first().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":286,"column":33},"line":286,"code":"\t\ttest('test $(\"NodeName\").last()', () => {\n\t\t\texpect(proxy.$('Rename').last().json.data).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").params","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":290,"column":33},"line":290,"code":"\t\ttest('test $(\"NodeName\").params', () => {\n\t\t\texpect(proxy.$('Rename').params).toEqual({ value1: 'data', value2: 'initialName' });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"$(\"NodeName\")","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":294,"column":21},"line":294,"code":"\t\ttest('$(\"NodeName\")', () => {\n\t\t\texpect(() => proxy.$('doNotExist')).toThrowError(ExpressionError);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"$(\"NodeName\")","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":298,"column":21},"line":298,"code":"\t\ttest('$(\"NodeName\")', () => {\n\t\t\texpect(() => proxy.$('Set')).toThrowError(ExpressionError);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":302,"column":25},"line":302,"code":"\t\ttest('test $input.all()', () => {\n\t\t\texpect(proxy.$input.all()[1].json.data).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":305,"column":32},"line":305,"code":"\t\ttest('test $input.all() length', () => {\n\t\t\texpect(proxy.$input.all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":308,"column":27},"line":308,"code":"\t\ttest('test $input.first()', () => {\n\t\t\texpect(proxy.$input.first().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":311,"column":26},"line":311,"code":"\t\ttest('test $input.last()', () => {\n\t\t\texpect(proxy.$input.last().json.data).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":314,"column":24},"line":314,"code":"\t\ttest('test $input.item', () => {\n\t\t\texpect(proxy.$input.item.json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $thisItem","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":317,"column":22},"line":317,"code":"\t\ttest('test $thisItem', () => {\n\t\t\texpect(proxy.$thisItem.json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $binary","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":321,"column":20},"line":321,"code":"\t\ttest('test $binary', () => {\n\t\t\texpect(proxy.$binary).toEqual({});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $json","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":325,"column":18},"line":325,"code":"\t\ttest('test $json', () => {\n\t\t\texpect(proxy.$json).toEqual({ data: 105 });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $itemIndex","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":329,"column":23},"line":329,"code":"\t\ttest('test $itemIndex', () => {\n\t\t\texpect(proxy.$itemIndex).toEqual(0);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $prevNode","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":333,"column":22},"line":333,"code":"\t\ttest('test $prevNode', () => {\n\t\t\texpect(proxy.$prevNode).toEqual({ name: 'Rename', outputIndex: 0, runIndex: 0 });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $runIndex","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":337,"column":22},"line":337,"code":"\t\ttest('test $runIndex', () => {\n\t\t\texpect(proxy.$runIndex).toEqual(0);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $workflow","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":341,"column":22},"line":341,"code":"\t\ttest('test $workflow', () => {\n\t\t\texpect(proxy.$workflow).toEqual({\n\t\t\t\tactive: false,\n\t\t\t\tid: '123',\n\t\t\t\tname: 'test workflow',\n\t\t\t});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"}]}