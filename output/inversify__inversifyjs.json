{"repo":"inversify/InversifyJS","url":"https://github.com/inversify/InversifyJS","branch":"master","configs":[{"package":"inversify","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should pass to tagParameter for parameter decorators","suites":["createTaggedDecorator"],"updatePoint":{"line":18,"column":58},"line":18,"code":"  it(\"should pass to tagParameter for parameter decorators\", () => {\n    class Target { }\n    const metadata = { key: \"1\", value: \"2\" };\n    const decorator = createTaggedDecorator(metadata);\n    const spiedTagParameter = sandbox.spy(tagParameter);\n    decorator(Target, undefined, 1);\n    expect(spiedTagParameter.calledWithExactly(Target, undefined, 1, metadata));\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"should pass to tagProperty for property decorators","suites":["createTaggedDecorator"],"updatePoint":{"line":27,"column":56},"line":27,"code":"  it(\"should pass to tagProperty for property decorators\", () => {\n    class Target { }\n    const metadata = { key: \"2\", value: \"2\" };\n    const decorator = createTaggedDecorator(metadata);\n    const spiedTagProperty = sandbox.spy(tagProperty);\n    decorator(Target.prototype, \"PropertyName\");\n    expect(spiedTagProperty.calledWithExactly(Target, \"PropertyName\", metadata));\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"should enable constraining to multiple metadata with a single decorator","suites":["createTaggedDecorator"],"updatePoint":{"line":36,"column":77},"line":36,"code":"  it(\"should enable constraining to multiple metadata with a single decorator\", () => {\n    function multipleMetadataDecorator(key1Value: string, key2Value: string) {\n      return createTaggedDecorator([{ key: \"key1\", value: key1Value }, { key: \"key2\", value: key2Value }]);\n    }\n\n    interface Thing {\n      type: string\n    }\n\n    @injectable()\n    class Thing1 implements Thing {\n      type = \"Thing1\"\n    }\n\n    @injectable()\n    class Root {\n      public thingyType!: string;\n      @multipleMetadataDecorator(\"Key1Value\", \"Key2Value\")\n      @inject<Thing>(\"Thing\")\n      set thingy(thingy: Thing) {\n        this.thingyType = thingy.type\n      }\n    }\n\n    const container = new Container();\n    container.bind<Thing>(\"Thing\").to(Thing1).when(request => {\n      const metadatas = request.target.metadata;\n      const key1Metadata = metadatas[1];\n      const key2Metadata = metadatas[2];\n      return key1Metadata?.value === \"Key1Value\" && key2Metadata?.value === \"Key2Value\";\n    });\n    container.resolve(Root);\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"should throw if multiple metadata with same key","suites":["tagParameter"],"updatePoint":{"line":73,"column":53},"line":73,"code":"  it(\"should throw if multiple metadata with same key\", () => {\n    class Target { }\n    expect(\n      () => tagParameter(Target, undefined, 1, [{ key: \"Duplicate\", value: \"1\" }, { key: \"Duplicate\", value: \"2\" }])\n    ).to.throw(`${ERROR_MSGS.DUPLICATED_METADATA} Duplicate`);\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"should throw if multiple metadata with same key","suites":["tagProperty"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it(\"should throw if multiple metadata with same key\", () => {\n    class Target { }\n    expect(\n      () => tagProperty(Target.prototype, \"Property\", [{ key: \"Duplicate\", value: \"1\" }, { key: \"Duplicate\", value: \"2\" }])\n    ).to.throw(`${ERROR_MSGS.DUPLICATED_METADATA} Duplicate`);\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"should throw for static properties","suites":["tagProperty"],"updatePoint":{"line":89,"column":40},"line":89,"code":"  it(\"should throw for static properties\", () => {\n    class Target { }\n\n    // does not throw\n    tagProperty(Target.prototype, \"Property\", { key: \"key\", value: \"value\" })\n\n    expect(\n      () => tagProperty(Target, \"StaticProperty\", { key: \"key\", value: \"value\" })\n    ).to.throw(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n\n  });","file":"annotation/decorator_utils.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for named parameters","suites":["@inject"],"updatePoint":{"line":80,"column":51},"line":80,"code":"  it(\"Should generate metadata for named parameters\", () => {\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, DecoratedWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.INJECT_TAG);\n    expect(m1.value).to.be.eql(\"Katana\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(METADATA_KEY.INJECT_TAG);\n    expect(m2.value).to.be.eql(\"Shuriken\");\n    expect(paramsMetadata[\"1\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"2\"]).to.be.instanceof(Array);\n    const m3: interfaces.Metadata = paramsMetadata[\"2\"][0];\n    expect(m3.key).to.be.eql(METADATA_KEY.INJECT_TAG);\n    expect(m3.value).to.be.eql(lazySwordId);\n    expect(paramsMetadata[\"2\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"3\"]).to.eq(undefined);\n\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@inject"],"updatePoint":{"line":112,"column":46},"line":112,"code":"  it(\"Should throw when applied multiple times\", () => {\n\n    const useDecoratorMoreThanOnce = function () {\n      __decorate([__param(0, inject(\"Katana\")), __param(0, inject(\"Shurien\"))], InvalidDecoratorUsageWarrior);\n    };\n\n    const msg = `${ERROR_MSGS.DUPLICATED_METADATA} ${METADATA_KEY.INJECT_TAG}`;\n    expect(useDecoratorMoreThanOnce).to.throw(msg);\n\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when not applied to a constructor","suites":["@inject"],"updatePoint":{"line":123,"column":52},"line":123,"code":"  it(\"Should throw when not applied to a constructor\", () => {\n\n    const useDecoratorOnMethodThatIsNotAConstructor = function () {\n      __decorate([__param(0, inject(\"Katana\"))],\n        InvalidDecoratorUsageWarrior.prototype,\n        \"test\", Object.getOwnPropertyDescriptor(InvalidDecoratorUsageWarrior.prototype, \"test\"));\n    };\n\n    const msg = `${ERROR_MSGS.INVALID_DECORATOR_OPERATION}`;\n    expect(useDecoratorOnMethodThatIsNotAConstructor).to.throw(msg);\n\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied with undefined","suites":["@inject"],"updatePoint":{"line":136,"column":46},"line":136,"code":"  it(\"Should throw when applied with undefined\", () => {\n\n    // this can happen when there is circular dependency between symbols\n    const useDecoratorWithUndefined = function () {\n      __decorate([__param(0, inject(undefined as any))], InvalidDecoratorUsageWarrior);\n    };\n\n    const msg = `${ERROR_MSGS.UNDEFINED_INJECT_ANNOTATION(\"InvalidDecoratorUsageWarrior\")}`;\n    expect(useDecoratorWithUndefined).to.throw(msg);\n\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@inject"],"updatePoint":{"line":148,"column":48},"line":148,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Shurien { }\n\n    const VanillaJSWarrior = (function () {\n      function Warrior(primary: Katana, secondary: Shurien) {\n        // ...\n      }\n      return Warrior;\n    })();\n\n    decorate(inject(\"Katana\"), VanillaJSWarrior, 0);\n    decorate(inject(\"Shurien\"), VanillaJSWarrior, 1);\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, VanillaJSWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.INJECT_TAG);\n    expect(m1.value).to.be.eql(\"Katana\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(METADATA_KEY.INJECT_TAG);\n    expect(m2.value).to.be.eql(\"Shurien\");\n    expect(paramsMetadata[\"1\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"should throw when applied inject decorator with undefined service identifier to a property","suites":["@inject"],"updatePoint":{"line":185,"column":96},"line":185,"code":"  it(\"should throw when applied inject decorator with undefined service identifier to a property\", () => {\n    expect(() => {\n      //@ts-ignore\n      class WithUndefinedInject {\n        @inject(undefined as any)\n        property!: string\n      }\n    }).to.throw(`${ERROR_MSGS.UNDEFINED_INJECT_ANNOTATION(\"WithUndefinedInject\")}`)\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"should throw when applied multiInject decorator with undefined service identifier to a constructor parameter","suites":["@inject"],"updatePoint":{"line":195,"column":114},"line":195,"code":"  it(\"should throw when applied multiInject decorator with undefined service identifier to a constructor parameter\", () => {\n    expect(() => {\n      //@ts-ignore\n      class WithUndefinedInject {\n        constructor(@multiInject(undefined as any) readonly dependency: string[]) { }\n      }\n    }).to.throw(`${ERROR_MSGS.UNDEFINED_INJECT_ANNOTATION(\"WithUndefinedInject\")}`)\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should unwrap LazyServiceIdentifer","suites":["@inject"],"updatePoint":{"line":204,"column":40},"line":204,"code":"  it('Should unwrap LazyServiceIdentifer', () => {\n    const unwrapped = lazySwordId.unwrap();\n    expect(unwrapped).to.be.equal('Sword');\n  });","file":"annotation/inject.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata if declared injections","suites":["@injectable"],"updatePoint":{"line":8,"column":53},"line":8,"code":"  it(\"Should generate metadata if declared injections\", () => {\n\n    class Katana { }\n\n    interface Weapon { }\n\n    @injectable()\n    class Warrior {\n\n      private _primaryWeapon: Katana;\n      private _secondaryWeapon: Weapon;\n\n      public constructor(primaryWeapon: Katana, secondaryWeapon: Weapon) {\n        this._primaryWeapon = primaryWeapon;\n        this._secondaryWeapon = secondaryWeapon;\n      }\n\n      public debug() {\n        return {\n          primaryWeapon: this._primaryWeapon,\n          secondaryWeapon: this._secondaryWeapon\n        };\n      }\n\n    }\n\n    const metadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, Warrior);\n    expect(metadata).to.be.instanceof(Array);\n\n    expect(metadata[0]).to.be.eql(Katana);\n    expect(metadata[1]).to.be.eql(Object);\n    expect(metadata[2]).to.eq(undefined);\n  });","file":"annotation/injectable.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@injectable"],"updatePoint":{"line":42,"column":46},"line":42,"code":"  it(\"Should throw when applied multiple times\", () => {\n\n    @injectable()\n    class Test { }\n\n    const useDecoratorMoreThanOnce = function () {\n      decorate(injectable(), Test);\n      decorate(injectable(), Test);\n    };\n\n    expect(useDecoratorMoreThanOnce).to.throw(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n  });","file":"annotation/injectable.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@injectable"],"updatePoint":{"line":55,"column":48},"line":55,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Katana { }\n    interface Shuriken { }\n\n    const VanillaJSWarrior = function (primary: Katana, secondary: Shuriken) {\n      // ...\n    };\n\n    decorate(injectable(), VanillaJSWarrior);\n\n    const metadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, VanillaJSWarrior);\n    expect(metadata).to.be.instanceof(Array);\n    expect(metadata.length).to.eql(0);\n\n  });","file":"annotation/injectable.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for named parameters","suites":["@multiInject"],"updatePoint":{"line":62,"column":51},"line":62,"code":"  it(\"Should generate metadata for named parameters\", () => {\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, DecoratedWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.MULTI_INJECT_TAG);\n    expect(m1.value).to.be.eql(\"Weapon\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"1\"]).to.eq(undefined);\n\n  });","file":"annotation/multi_inject.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@multiInject"],"updatePoint":{"line":79,"column":46},"line":79,"code":"  it(\"Should throw when applied multiple times\", () => {\n\n    const useDecoratorMoreThanOnce = function () {\n      __decorate([__param(0, multiInject(\"Weapon\")), __param(0, multiInject(\"Weapon\"))], InvalidDecoratorUsageWarrior);\n    };\n\n    const msg = `${ERROR_MSGS.DUPLICATED_METADATA} ${METADATA_KEY.MULTI_INJECT_TAG}`;\n    expect(useDecoratorMoreThanOnce).to.throw(msg);\n\n  });","file":"annotation/multi_inject.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when not applied to a constructor","suites":["@multiInject"],"updatePoint":{"line":90,"column":52},"line":90,"code":"  it(\"Should throw when not applied to a constructor\", () => {\n\n    const useDecoratorOnMethodThatIsNotAConstructor = function () {\n      __decorate([__param(0, multiInject(\"Weapon\"))],\n        InvalidDecoratorUsageWarrior.prototype,\n        \"test\", Object.getOwnPropertyDescriptor(InvalidDecoratorUsageWarrior.prototype, \"test\"));\n    };\n\n    const msg = `${ERROR_MSGS.INVALID_DECORATOR_OPERATION}`;\n    expect(useDecoratorOnMethodThatIsNotAConstructor).to.throw(msg);\n\n  });","file":"annotation/multi_inject.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@multiInject"],"updatePoint":{"line":103,"column":48},"line":103,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Katana { }\n    interface Shurien { }\n\n    const VanillaJSWarrior = (function () {\n      function Warrior(primary: Katana, secondary: Shurien) {\n        // ...\n      }\n      return Warrior;\n    })();\n\n    decorate(multiInject(\"Weapon\"), VanillaJSWarrior, 0);\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, VanillaJSWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.MULTI_INJECT_TAG);\n    expect(m1.value).to.be.eql(\"Weapon\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"1\"]).to.eq(undefined);\n\n  });","file":"annotation/multi_inject.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for named parameters","suites":["@named"],"updatePoint":{"line":65,"column":51},"line":65,"code":"  it(\"Should generate metadata for named parameters\", () => {\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, NamedWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(m1.value).to.be.eql(\"more_powerful\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(m2.value).to.be.eql(\"less_powerful\");\n    expect(paramsMetadata[\"1\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n\n  });","file":"annotation/named.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for named properties","suites":["@named"],"updatePoint":{"line":90,"column":51},"line":90,"code":"  it(\"Should generate metadata for named properties\", () => {\n\n    class Warrior {\n      @named(\"throwable\")\n      public weapon!: Weapon;\n    }\n\n    const metadataKey = METADATA_KEY.TAGGED_PROP;\n    const metadata = Reflect.getMetadata(metadataKey, Warrior);\n\n    const m1 = metadata.weapon[0];\n    expect(m1.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(m1.value).to.be.eql(\"throwable\");\n    expect(metadata.weapon[1]).to.eq(undefined);\n\n  });","file":"annotation/named.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@named"],"updatePoint":{"line":107,"column":46},"line":107,"code":"  it(\"Should throw when applied multiple times\", () => {\n\n    const useDecoratorMoreThanOnce = function () {\n      __decorate([__param(0, named(\"a\")), __param(0, named(\"b\"))], InvalidDecoratorUsageWarrior);\n    };\n\n    const msg = `${ERROR_MSGS.DUPLICATED_METADATA} ${METADATA_KEY.NAMED_TAG}`;\n    expect(useDecoratorMoreThanOnce).to.throw(msg);\n\n  });","file":"annotation/named.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when not applied to a constructor","suites":["@named"],"updatePoint":{"line":118,"column":52},"line":118,"code":"  it(\"Should throw when not applied to a constructor\", () => {\n\n    const useDecoratorOnMethodThatIsNotAConstructor = function () {\n      __decorate([__param(0, named(\"a\"))],\n        InvalidDecoratorUsageWarrior.prototype,\n        \"test\", Object.getOwnPropertyDescriptor(InvalidDecoratorUsageWarrior.prototype, \"test\"));\n    };\n\n    const msg = `${ERROR_MSGS.INVALID_DECORATOR_OPERATION}`;\n    expect(useDecoratorOnMethodThatIsNotAConstructor).to.throw(msg);\n\n  });","file":"annotation/named.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@named"],"updatePoint":{"line":131,"column":48},"line":131,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Katana { }\n    interface Shurien { }\n\n    const VanillaJSWarrior = (function () {\n      function NamedVanillaJSWarrior(primary: Katana, secondary: Shurien) {\n        // ...\n      }\n      return NamedVanillaJSWarrior;\n    })();\n\n    decorate(named(\"more_powerful\"), VanillaJSWarrior, 0);\n    decorate(named(\"less_powerful\"), VanillaJSWarrior, 1);\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, VanillaJSWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(m1.value).to.be.eql(\"more_powerful\");\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(m2.value).to.be.eql(\"less_powerful\");\n    expect(paramsMetadata[\"1\"][1]).eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n\n  });","file":"annotation/named.test.ts","skipped":false,"dir":"test"},{"name":"Should allow to flag dependencies as optional","suites":["@optional"],"updatePoint":{"line":6,"column":51},"line":6,"code":"  it(\"Should allow to flag dependencies as optional\", () => {\n\n    @injectable()\n    class Katana {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n      public name: string;\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") @optional() shuriken: Shuriken\n      ) {\n        this.name = \"Ninja\";\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    let ninja = container.get<Ninja>(\"Ninja\");\n    expect(ninja.name).to.eql(\"Ninja\");\n    expect(ninja.katana.name).to.eql(\"Katana\");\n    expect(ninja.shuriken).to.eql(undefined);\n\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    ninja = container.get<Ninja>(\"Ninja\");\n    expect(ninja.name).to.eql(\"Ninja\");\n    expect(ninja.katana.name).to.eql(\"Katana\");\n    expect(ninja.shuriken.name).to.eql(\"Shuriken\");\n\n  });","file":"annotation/optional.test.ts","skipped":false,"dir":"test"},{"name":"Should allow to set a default value for dependencies flagged as optional","suites":["@optional"],"updatePoint":{"line":58,"column":78},"line":58,"code":"  it(\"Should allow to set a default value for dependencies flagged as optional\", () => {\n\n    @injectable()\n    class Katana {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n      public name: string;\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") @optional() shuriken: Shuriken = { name: \"DefaultShuriken\" }\n      ) {\n        this.name = \"Ninja\";\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    let ninja = container.get<Ninja>(\"Ninja\");\n    expect(ninja.name).to.eql(\"Ninja\");\n    expect(ninja.katana.name).to.eql(\"Katana\");\n    expect(ninja.shuriken.name).to.eql(\"DefaultShuriken\");\n\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    ninja = container.get<Ninja>(\"Ninja\");\n    expect(ninja.name).to.eql(\"Ninja\");\n    expect(ninja.katana.name).to.eql(\"Katana\");\n    expect(ninja.shuriken.name).to.eql(\"Shuriken\");\n\n  });","file":"annotation/optional.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for the decorated method","suites":["@postConstruct"],"updatePoint":{"line":10,"column":55},"line":10,"code":"  it(\"Should generate metadata for the decorated method\", () => {\n    class Katana {\n      private useMessage!: string;\n\n      public use() {\n        return \"Used Katana!\";\n      }\n\n      @postConstruct()\n      public testMethod() {\n        this.useMessage = \"Used Katana!\";\n      }\n      public debug() {\n        return this.useMessage;\n      }\n    }\n    const metadata: Metadata = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, Katana);\n    expect(metadata.value).to.be.equal(\"testMethod\");\n  });","file":"annotation/post_construct.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@postConstruct"],"updatePoint":{"line":30,"column":46},"line":30,"code":"  it(\"Should throw when applied multiple times\", () => {\n    function setup() {\n      class Katana {\n        @postConstruct()\n        public testMethod1() {/* ... */ }\n\n        @postConstruct()\n        public testMethod2() {/* ... */ }\n      }\n      Katana.toString();\n    }\n    expect(setup).to.throw(ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);\n  });","file":"annotation/post_construct.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@postConstruct"],"updatePoint":{"line":44,"column":48},"line":44,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    const VanillaJSWarrior = function () {\n      // ...\n    };\n    VanillaJSWarrior.prototype.testMethod = function () {\n      // ...\n    };\n\n    decorate(postConstruct(), VanillaJSWarrior.prototype, \"testMethod\");\n\n    const metadata: Metadata = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, VanillaJSWarrior);\n    expect(metadata.value).to.be.equal(\"testMethod\");\n  });","file":"annotation/post_construct.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for tagged parameters","suites":["@Tagged"],"updatePoint":{"line":83,"column":52},"line":83,"code":"  it(\"Should generate metadata for tagged parameters\", () => {\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, TaggedWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(\"power\");\n    expect(m1.value).to.be.eql(1);\n\n    // argument at index 0 should only have one tag\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(\"power\");\n    expect(m2.value).to.be.eql(2);\n\n    // argument at index 1 should only have one tag\n    expect(paramsMetadata[\"1\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for tagged properties","suites":["@Tagged"],"updatePoint":{"line":111,"column":52},"line":111,"code":"  it(\"Should generate metadata for tagged properties\", () => {\n\n    class Warrior {\n      @tagged(\"throwable\", false)\n      public weapon!: Weapon;\n    }\n\n    const metadataKey = METADATA_KEY.TAGGED_PROP;\n    const metadata = Reflect.getMetadata(metadataKey, Warrior);\n    const m1 = metadata.weapon[0];\n    expect(m1.key).to.be.eql(\"throwable\");\n    expect(m1.value).to.be.eql(false);\n    expect(metadata.weapon[1]).to.eq(undefined);\n\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata for parameters tagged multiple times","suites":["@Tagged"],"updatePoint":{"line":127,"column":67},"line":127,"code":"  it(\"Should generate metadata for parameters tagged multiple times\", () => {\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, DoubleTaggedWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for argument at index 0\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n\n    // assert argument at index 0 first tag\n    const m11: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m11.key).to.be.eql(\"distance\");\n    expect(m11.value).to.be.eql(1);\n\n    // assert argument at index 0 second tag\n    const m12: interfaces.Metadata = paramsMetadata[\"0\"][1];\n    expect(m12.key).to.be.eql(\"power\");\n    expect(m12.value).to.be.eql(1);\n\n    // assert metadata for argument at index 1\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n\n    // assert argument at index 1 first tag\n    const m21: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m21.key).to.be.eql(\"distance\");\n    expect(m21.value).to.be.eql(5);\n\n    // assert argument at index 1 second tag\n    const m22: interfaces.Metadata = paramsMetadata[\"1\"][1];\n    expect(m22.key).to.be.eql(\"power\");\n    expect(m22.value).to.be.eql(2);\n\n    // no more metadata (argument at index > 1)\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when applied multiple times","suites":["@Tagged"],"updatePoint":{"line":163,"column":46},"line":163,"code":"  it(\"Should throw when applied multiple times\", () => {\n\n    const metadataKey = \"a\";\n\n    const useDecoratorMoreThanOnce = function () {\n      __decorate([__param(0, tagged(metadataKey, 1)), __param(0, tagged(metadataKey, 2))], InvalidDecoratorUsageWarrior);\n    };\n\n    const msg = `${ERRORS_MSGS.DUPLICATED_METADATA} ${metadataKey}`;\n    expect(useDecoratorMoreThanOnce).to.throw(msg);\n\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when not applied to a constructor","suites":["@Tagged"],"updatePoint":{"line":176,"column":52},"line":176,"code":"  it(\"Should throw when not applied to a constructor\", () => {\n\n    const useDecoratorOnMethodThatIsNotAConstructor = function () {\n      __decorate([__param(0, tagged(\"a\", 1))],\n        InvalidDecoratorUsageWarrior.prototype,\n        \"test\", Object.getOwnPropertyDescriptor(InvalidDecoratorUsageWarrior.prototype, \"test\"));\n    };\n\n    const msg = ERRORS_MSGS.INVALID_DECORATOR_OPERATION;\n    expect(useDecoratorOnMethodThatIsNotAConstructor).to.throw(msg);\n\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@Tagged"],"updatePoint":{"line":189,"column":48},"line":189,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Katana { }\n    interface Shuriken { }\n\n    const VanillaJSWarrior = (function () {\n      function TaggedVanillaJSWarrior(primary: Katana, secondary: Shuriken) {\n        // ...\n      }\n      return TaggedVanillaJSWarrior;\n    })();\n\n    decorate(tagged(\"power\", 1), VanillaJSWarrior, 0);\n    decorate(tagged(\"power\", 2), VanillaJSWarrior, 1);\n\n    const metadataKey = METADATA_KEY.TAGGED;\n    const paramsMetadata = Reflect.getMetadata(metadataKey, VanillaJSWarrior);\n    expect(paramsMetadata).to.be.an(\"object\");\n\n    // assert metadata for first argument\n    expect(paramsMetadata[\"0\"]).to.be.instanceof(Array);\n    const m1: interfaces.Metadata = paramsMetadata[\"0\"][0];\n    expect(m1.key).to.be.eql(\"power\");\n    expect(m1.value).to.be.eql(1);\n\n    // argument at index 0 should only have one tag\n    expect(paramsMetadata[\"0\"][1]).to.eq(undefined);\n\n    // assert metadata for second argument\n    expect(paramsMetadata[\"1\"]).to.be.instanceof(Array);\n    const m2: interfaces.Metadata = paramsMetadata[\"1\"][0];\n    expect(m2.key).to.be.eql(\"power\");\n    expect(m2.value).to.be.eql(2);\n\n    // argument at index 1 should only have one tag\n    expect(paramsMetadata[\"1\"][1]).to.eq(undefined);\n\n    // no more metadata should be available\n    expect(paramsMetadata[\"2\"]).to.eq(undefined);\n\n  });","file":"annotation/tagged.test.ts","skipped":false,"dir":"test"},{"name":"Should generate metadata if declared parameter names","suites":["@targetName"],"updatePoint":{"line":10,"column":58},"line":10,"code":"  it(\"Should generate metadata if declared parameter names\", () => {\n\n    @injectable()\n    class Warrior {\n\n      public katana: Stubs.Katana;\n      public shuriken: Stubs.Shuriken;\n\n      public constructor(\n        @targetName(\"katana\") katana: Stubs.Katana,\n        @targetName(\"shuriken\") shuriken: Stubs.Shuriken\n      ) {\n\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const metadata = Reflect.getMetadata(METADATA_KEY.TAGGED, Warrior);\n    expect(metadata[\"0\"]).to.be.instanceof(Array);\n    expect(metadata[\"1\"]).to.be.instanceof(Array);\n    expect(metadata[\"2\"]).to.eql(undefined);\n\n    expect(metadata[\"0\"][0].key).to.be.eql(METADATA_KEY.NAME_TAG);\n    expect(metadata[\"0\"][0].value).to.be.eql(\"katana\");\n    expect(metadata[\"1\"][0].key).to.be.eql(METADATA_KEY.NAME_TAG);\n    expect(metadata[\"1\"][0].value).to.be.eql(\"shuriken\");\n\n  });","file":"annotation/target_name.test.ts","skipped":false,"dir":"test"},{"name":"Should be usable in VanillaJS applications","suites":["@targetName"],"updatePoint":{"line":40,"column":48},"line":40,"code":"  it(\"Should be usable in VanillaJS applications\", () => {\n\n    interface Katana { }\n    interface Shuriken { }\n\n    const VanillaJSWarrior = function (primary: Katana, secondary: Shuriken) {\n      // ...\n    };\n\n    decorate(targetName(\"primary\"), VanillaJSWarrior, 0);\n    decorate(targetName(\"secondary\"), VanillaJSWarrior, 1);\n\n    const metadata = Reflect.getMetadata(METADATA_KEY.TAGGED, VanillaJSWarrior);\n    expect(metadata[\"0\"]).to.be.instanceof(Array);\n    expect(metadata[\"1\"]).to.be.instanceof(Array);\n    expect(metadata[\"2\"]).to.eql(undefined);\n\n    expect(metadata[\"0\"][0].key).to.be.eql(METADATA_KEY.NAME_TAG);\n    expect(metadata[\"0\"][0].value).to.be.eql(\"primary\");\n    expect(metadata[\"1\"][0].key).to.be.eql(METADATA_KEY.NAME_TAG);\n    expect(metadata[\"1\"][0].value).to.be.eql(\"secondary\");\n\n  });","file":"annotation/target_name.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["Binding"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    const fooIdentifier = \"FooInterface\";\n    const fooBinding = new Binding<Stubs.FooInterface>(fooIdentifier, BindingScopeEnum.Transient);\n    expect(fooBinding.serviceIdentifier).eql(fooIdentifier);\n    expect(fooBinding.implementationType).eql(null);\n    expect(fooBinding.cache).eql(null);\n    expect(fooBinding.scope).eql(BindingScopeEnum.Transient);\n    expect(fooBinding.id).to.be.a(\"number\");\n  });","file":"bindings/binding.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when args length of base and derived class not match","suites":["Bugs"],"updatePoint":{"line":22,"column":71},"line":22,"code":"  it(\"Should throw when args length of base and derived class not match\", () => {\r\n\r\n    @injectable()\r\n    class Warrior {\r\n      public rank: string;\r\n      public constructor(rank: string) { // length = 1\r\n        this.rank = rank;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class SamuraiMaster extends Warrior {\r\n      public constructor() { // length = 0\r\n        super(\"master\");\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<SamuraiMaster>(SamuraiMaster).to(SamuraiMaster);\r\n\r\n    const shouldThrow = function () {\r\n      container.get<SamuraiMaster>(SamuraiMaster);\r\n    };\r\n\r\n    const error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(\"SamuraiMaster\");\r\n    expect(shouldThrow).to.throw(error);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should not throw when args length of base and derived class match (property setter)","suites":["Bugs"],"updatePoint":{"line":51,"column":89},"line":51,"code":"  it(\"Should not throw when args length of base and derived class match (property setter)\", () => {\r\n\r\n    @injectable()\r\n    class Warrior {\r\n      public rank: string | null;\r\n      public constructor() { // length = 0\r\n        this.rank = null;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class SamuraiMaster extends Warrior {\r\n      public constructor() { // length = 0\r\n        super();\r\n        this.rank = \"master\";\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<SamuraiMaster>(SamuraiMaster).to(SamuraiMaster);\r\n    const master = container.get<SamuraiMaster>(SamuraiMaster);\r\n    expect(master.rank).eql(\"master\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should not throw when args length of base and derived class match","suites":["Bugs"],"updatePoint":{"line":76,"column":71},"line":76,"code":"  it(\"Should not throw when args length of base and derived class match\", () => {\r\n\r\n    // Injecting into the derived class\r\n\r\n    @injectable()\r\n    class Warrior {\r\n      protected rank: string;\r\n      public constructor(rank: string) { // length = 1\r\n        this.rank = rank;\r\n      }\r\n    }\r\n\r\n    const TYPES = { Rank: \"Rank\" };\r\n\r\n    @injectable()\r\n    class SamuraiMaster extends Warrior {\r\n      public constructor(\r\n        @inject(TYPES.Rank) @named(\"master\") public rank: string // length = 1\r\n      ) {\r\n        super(rank);\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<SamuraiMaster>(SamuraiMaster).to(SamuraiMaster);\r\n    container.bind<string>(TYPES.Rank)\r\n      .toConstantValue(\"master\")\r\n      .whenTargetNamed(\"master\");\r\n\r\n    const master = container.get<SamuraiMaster>(SamuraiMaster);\r\n    expect(master.rank).eql(\"master\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should not throw when args length of base and derived class match","suites":["Bugs"],"updatePoint":{"line":110,"column":71},"line":110,"code":"  it(\"Should not throw when args length of base and derived class match\", () => {\r\n\r\n    // Injecting into the derived class with multiple args\r\n\r\n    @injectable()\r\n    class Warrior {\r\n      protected rank: string;\r\n      public constructor(rank: string) { // length = 1\r\n        this.rank = rank;\r\n      }\r\n    }\r\n\r\n    interface Weapon {\r\n      name: string;\r\n    }\r\n\r\n    @injectable()\r\n    class Katana implements Weapon {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"Katana\";\r\n      }\r\n    }\r\n\r\n    const TYPES = {\r\n      Rank: \"Rank\",\r\n      Weapon: \"Weapon\"\r\n    };\r\n\r\n    @injectable()\r\n    class SamuraiMaster extends Warrior {\r\n      public weapon: Weapon;\r\n      public constructor(\r\n        @inject(TYPES.Rank) @named(\"master\") public rank: string,\r\n        @inject(TYPES.Weapon) weapon: Weapon\r\n      ) { // length = 2\r\n        super(rank);\r\n        this.weapon = weapon;\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Weapon>(TYPES.Weapon).to(Katana);\r\n    container.bind<SamuraiMaster>(SamuraiMaster).to(SamuraiMaster);\r\n    container.bind<string>(TYPES.Rank)\r\n      .toConstantValue(\"master\")\r\n      .whenTargetNamed(\"master\");\r\n\r\n    const master = container.get<SamuraiMaster>(SamuraiMaster);\r\n    expect(master.rank).eql(\"master\");\r\n    expect(master.weapon.name).eql(\"Katana\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to convert a Symbol value to a string","suites":["Bugs"],"updatePoint":{"line":164,"column":58},"line":164,"code":"  it(\"Should be able to convert a Symbol value to a string\", () => {\r\n\r\n    interface Weapon { }\r\n\r\n    const TYPES = {\r\n      Weapon: Symbol.for(\"Weapon\")\r\n    };\r\n\r\n    const container = new Container();\r\n    const throwF = () => { container.get<Weapon>(TYPES.Weapon); };\r\n    expect(throwF).to.throw(`${ERROR_MSGS.NOT_REGISTERED} ${getServiceIdentifierAsString(TYPES.Weapon)}`);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be not require @inject annotation in toConstructor bindings","suites":["Bugs"],"updatePoint":{"line":178,"column":72},"line":178,"code":"  it(\"Should be not require @inject annotation in toConstructor bindings\", () => {\r\n\r\n    interface ICategorySortingFn { }\r\n    interface IContentSortingFn { }\r\n    interface Collection { }\r\n\r\n    @injectable()\r\n    class Category {\r\n      public constructor(\r\n        public id: string,\r\n        public title: string,\r\n        public categoryFirstPermalink: string,\r\n        public categoryPermalink: string,\r\n        public pagination: number,\r\n        public categorySortingFn: ICategorySortingFn,\r\n        public contentSortingFn: IContentSortingFn,\r\n        public belongsToCollection: Collection\r\n      ) {\r\n        // do nothing\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<interfaces.Newable<Category>>(\"Newable<Category>\").toConstructor(Category);\r\n    const expected = container.get<interfaces.Newable<Category>>(\"Newable<Category>\");\r\n    expect(expected).eql(Category);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to combine tagged injection and constant value bindings","suites":["Bugs"],"updatePoint":{"line":207,"column":76},"line":207,"code":"  it(\"Should be able to combine tagged injection and constant value bindings\", () => {\r\n\r\n    const container = new Container();\r\n\r\n    interface Intl { }\r\n\r\n    container.bind<Intl>(\"Intl\").toConstantValue({ hello: \"bonjour\" }).whenTargetTagged(\"lang\", \"fr\");\r\n    container.bind<Intl>(\"Intl\").toConstantValue({ goodbye: \"au revoir\" }).whenTargetTagged(\"lang\", \"fr\");\r\n\r\n    const f = function () { container.getTagged<Intl>(\"Intl\", \"lang\", \"fr\"); };\r\n    expect(f).to.throw();\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to combine dynamic value with singleton scope","suites":["Bugs"],"updatePoint":{"line":221,"column":66},"line":221,"code":"  it(\"Should be able to combine dynamic value with singleton scope\", () => {\r\n\r\n    const container = new Container();\r\n\r\n    container.bind<number>(\"transient_random\").toDynamicValue((context: interfaces.Context) =>\r\n      Math.random()).inTransientScope();\r\n\r\n    container.bind<number>(\"singleton_random\").toDynamicValue((context: interfaces.Context) =>\r\n      Math.random()).inSingletonScope();\r\n\r\n    const a = container.get<number>(\"transient_random\");\r\n    const b = container.get<number>(\"transient_random\");\r\n\r\n    expect(a).not.to.eql(b);\r\n\r\n    const c = container.get<number>(\"singleton_random\");\r\n    const d = container.get<number>(\"singleton_random\");\r\n\r\n    expect(c).to.eql(d);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use an abstract class as the serviceIdentifier","suites":["Bugs"],"updatePoint":{"line":243,"column":70},"line":243,"code":"  it(\"Should be able to use an abstract class as the serviceIdentifier\", () => {\r\n\r\n    @injectable()\r\n    abstract class Animal {\r\n      protected name: string;\r\n      public constructor(@unmanaged() name: string) {\r\n        this.name = name;\r\n      }\r\n      public abstract makeSound(input: string): string;\r\n      public move(meters: number) {\r\n        return `${this.name} moved ${meters}m`;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Snake extends Animal {\r\n      public constructor() {\r\n        super(\"Snake\");\r\n      }\r\n      public makeSound(input: string): string {\r\n        return \"sssss\" + input;\r\n      }\r\n      public move() {\r\n        return \"Slithering... \" + super.move(5);\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Jungle {\r\n      public animal: Animal;\r\n      public constructor(@inject(Animal) animal: Animal) {\r\n        this.animal = animal;\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Animal>(Animal).to(Snake);\r\n    container.bind<Jungle>(Jungle).to(Jungle);\r\n\r\n    const jungle = container.get(Jungle);\r\n    expect(jungle.animal.makeSound(\"zzz\")).to.eql(\"ssssszzz\");\r\n    expect(jungle.animal.move(5)).to.eql(\"Slithering... Snake moved 5m\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify is a target is tagged","suites":["Bugs"],"updatePoint":{"line":288,"column":54},"line":288,"code":"  it(\"Should be able to identify is a target is tagged\", () => {\r\n\r\n    const TYPES = {\r\n      Dependency1: Symbol.for(\"Dependency1\"),\r\n      Dependency2: Symbol.for(\"Dependency2\"),\r\n      Dependency3: Symbol.for(\"Dependency3\"),\r\n      Dependency4: Symbol.for(\"Dependency4\"),\r\n      Dependency5: Symbol.for(\"Dependency5\"),\r\n      Test: Symbol.for(\"Test\")\r\n    };\r\n\r\n    const TAGS = {\r\n      somename: \"somename\",\r\n      sometag: \"sometag\"\r\n    };\r\n\r\n    @injectable()\r\n    class Dependency1 {\r\n      public name = \"Dependency1\";\r\n    }\r\n\r\n    @injectable()\r\n    class Dependency2 {\r\n      public name = \"Dependency1\";\r\n    }\r\n\r\n    @injectable()\r\n    class Dependency3 {\r\n      public name = \"Dependency1\";\r\n    }\r\n\r\n    @injectable()\r\n    class Dependency4 {\r\n      public name = \"Dependency1\";\r\n    }\r\n\r\n    @injectable()\r\n    class Dependency5 {\r\n      public name = \"Dependency1\";\r\n    }\r\n\r\n    @injectable()\r\n    class Base {\r\n      public baseProp: string;\r\n      public constructor(\r\n        @unmanaged() baseProp: string\r\n      ) {\r\n        this.baseProp = baseProp;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Test extends Base {\r\n\r\n      private _prop1: Dependency1;\r\n      private _prop2: Dependency2[];\r\n      private _prop3: Dependency3;\r\n      private _prop4: Dependency4;\r\n      private _prop5: Dependency5;\r\n\r\n      public constructor(\r\n        @inject(TYPES.Dependency1) prop1: Dependency1, // inject\r\n        @multiInject(TYPES.Dependency2) prop2: Dependency2[], // multi inject\r\n        @inject(TYPES.Dependency3) @named(TAGS.somename) prop3: Dependency3, // named\r\n        @inject(TYPES.Dependency4) @tagged(TAGS.sometag, true) prop4: Dependency4, // tagged\r\n        @inject(TYPES.Dependency5) @targetName(\"prop6\") prop5: Dependency5 // targetName\r\n      ) {\r\n        super(\"unmanaged!\");\r\n        this._prop1 = prop1;\r\n        this._prop2 = prop2;\r\n        this._prop3 = prop3;\r\n        this._prop4 = prop4;\r\n        this._prop5 = prop5;\r\n      }\r\n      public debug() {\r\n        return {\r\n          prop1: this._prop1,\r\n          prop2: this._prop2,\r\n          prop3: this._prop3,\r\n          prop4: this._prop4,\r\n          prop5: this._prop5\r\n        };\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Test>(TYPES.Test).to(Test);\r\n    container.bind<Dependency1>(TYPES.Dependency1).to(Dependency1);\r\n    container.bind<Dependency2>(TYPES.Dependency2).to(Dependency2);\r\n    container.bind<Dependency3>(TYPES.Dependency3).to(Dependency3);\r\n    container.bind<Dependency4>(TYPES.Dependency4).to(Dependency4);\r\n    container.bind<Dependency5>(TYPES.Dependency5).to(Dependency5);\r\n\r\n    function logger(next: interfaces.Next): interfaces.Next {\r\n      return (args: interfaces.NextArgs) => {\r\n\r\n        const nextContextInterceptor = args.contextInterceptor;\r\n\r\n        args.contextInterceptor = (context: interfaces.Context) => {\r\n\r\n          context.plan.rootRequest.childRequests.forEach((request, index) => {\r\n\r\n            if (request === null || request.target === null) {\r\n              throw new Error(\"Request should not be null!\");\r\n            }\r\n\r\n            switch (index) {\r\n              case 0:\r\n                expect(request.target.isNamed()).to.eql(false);\r\n                expect(request.target.isTagged()).to.eql(false);\r\n                break;\r\n              case 1:\r\n                expect(request.target.isNamed()).to.eql(false);\r\n                expect(request.target.isTagged()).to.eql(false);\r\n                break;\r\n              case 2:\r\n                expect(request.target.isNamed()).to.eql(true);\r\n                expect(request.target.isTagged()).to.eql(false);\r\n                break;\r\n              case 3:\r\n                expect(request.target.isNamed()).to.eql(false);\r\n                expect(request.target.isTagged()).to.eql(true);\r\n                break;\r\n              case 4:\r\n                expect(request.target.isNamed()).to.eql(false);\r\n                expect(request.target.isTagged()).to.eql(false);\r\n            }\r\n          });\r\n\r\n          if (nextContextInterceptor !== null) {\r\n            return nextContextInterceptor(context);\r\n          } else {\r\n            throw new Error(\"nextContextInterceptor should not be null!\");\r\n          }\r\n\r\n        };\r\n\r\n        const result = next(args);\r\n\r\n        return result;\r\n      };\r\n    }\r\n\r\n    container.applyMiddleware(logger);\r\n    container.get<Test>(TYPES.Test);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Helper getFunctionName should not throw when using an anonymous function","suites":["Bugs"],"updatePoint":{"line":436,"column":78},"line":436,"code":"  it(\"Helper getFunctionName should not throw when using an anonymous function\", () => {\r\n\r\n    const name = getFunctionName(function (options: unknown) {\r\n      return options;\r\n    });\r\n\r\n    expect(name).to.eql(\"Anonymous function: \" + (function (options: unknown) {\r\n      return options;\r\n    }).toString());\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get all the available bindings for a service identifier","suites":["Bugs"],"updatePoint":{"line":448,"column":79},"line":448,"code":"  it(\"Should be able to get all the available bindings for a service identifier\", () => {\r\n\r\n    const controllerId = \"SomeControllerID\";\r\n    const tagA = \"A\";\r\n    const tagB = \"B\";\r\n\r\n    interface Controller {\r\n      name: string;\r\n    }\r\n\r\n    const container = new Container();\r\n\r\n    @injectable()\r\n    class AppController implements Controller {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"AppController\";\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class AppController2 implements Controller {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"AppController2\";\r\n      }\r\n    }\r\n\r\n    container.bind(controllerId).to(AppController).whenTargetNamed(tagA);\r\n    container.bind(controllerId).to(AppController2).whenTargetNamed(tagB);\r\n\r\n    function wrongNamedBinding() { container.getAllNamed<Controller>(controllerId, \"Wrong\"); }\r\n    expect(wrongNamedBinding).to.throw();\r\n\r\n    const appControllerNamedRight = container.getAllNamed<Controller>(controllerId, tagA);\r\n    expect(appControllerNamedRight.length).to.eql(1, \"getAllNamed\");\r\n    expect(appControllerNamedRight[0]?.name).to.eql(\"AppController\");\r\n\r\n    function wrongTaggedBinding() { container.getAllTagged<Controller>(controllerId, \"Wrong\", \"Wrong\"); }\r\n    expect(wrongTaggedBinding).to.throw();\r\n\r\n    const appControllerTaggedRight = container.getAllTagged<Controller>(controllerId, METADATA_KEY.NAMED_TAG, tagB);\r\n    expect(appControllerTaggedRight.length).to.eql(1, \"getAllTagged\");\r\n    expect(appControllerTaggedRight[0]?.name).to.eql(\"AppController2\");\r\n\r\n    const getAppController = () => {\r\n      const matches = container.getAll<Controller>(controllerId);\r\n      expect(matches.length).to.eql(2);\r\n      expect(matches[0]?.name).to.eql(\"AppController\");\r\n      expect(matches[1]?.name).to.eql(\"AppController2\");\r\n    };\r\n\r\n    expect(getAppController).not.to.throw();\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should not be able to get a named dependency if no named bindings are registered","suites":["Bugs"],"updatePoint":{"line":504,"column":86},"line":504,"code":"  it(\"Should not be able to get a named dependency if no named bindings are registered\", () => {\r\n\r\n    const TYPES = {\r\n      Weapon: \"Weapon\"\r\n    };\r\n\r\n    interface Weapon {\r\n      name: string;\r\n    }\r\n\r\n    @injectable()\r\n    class Katana implements Weapon {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"Katana\";\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetNamed(\"sword\");\r\n\r\n    const throws = () => { container.getNamed<Weapon>(TYPES.Weapon, \"bow\"); };\r\n\r\n    const error = \"No matching bindings found for serviceIdentifier: Weapon\\n Weapon \" +\r\n      \"- named: bow \\n\\nRegistered bindings:\\n Katana - named: sword \";\r\n\r\n    expect(throws).to.throw(error);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should throw a friendly error when binding a non-class using toSelf","suites":["Bugs"],"updatePoint":{"line":534,"column":73},"line":534,"code":"  it(\"Should throw a friendly error when binding a non-class using toSelf\", () => {\r\n    const container = new Container();\r\n    const throws = () => { container.bind(\"testId\").toSelf(); };\r\n    expect(throws).to.throw(ERROR_MSGS.INVALID_TO_SELF_VALUE);\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should generate correct metadata when the spread operator is used","suites":["Bugs"],"updatePoint":{"line":540,"column":71},"line":540,"code":"  it(\"Should generate correct metadata when the spread operator is used\", () => {\r\n\r\n    const BAR = Symbol.for(\"BAR\");\r\n    const FOO = Symbol.for(\"FOO\");\r\n\r\n    interface Bar {\r\n      name: string;\r\n    }\r\n\r\n    @injectable()\r\n    class Foo {\r\n      public bar: Bar[];\r\n      public constructor(@multiInject(BAR) ...args: Bar[][]) {\r\n        this.bar = args[0] as Bar[];\r\n      }\r\n    }\r\n\r\n    // is the metadata correct?\r\n    const serviceIdentifiers = Reflect.getMetadata(METADATA_KEY.TAGGED, Foo);\r\n    expect(serviceIdentifiers[\"0\"][0].value.toString()).to.be.eql(\"Symbol(BAR)\");\r\n\r\n    // is the plan correct?\r\n    const dependencies = getDependencies(new MetadataReader(), Foo);\r\n    expect(dependencies.length).to.be.eql(1);\r\n    expect(dependencies[0]?.serviceIdentifier.toString()).to.be.eql(\"Symbol(BAR)\");\r\n\r\n    // integration test\r\n    const container = new Container();\r\n    container.bind<Bar>(BAR).toConstantValue({ name: \"bar1\" });\r\n    container.bind<Bar>(BAR).toConstantValue({ name: \"bar2\" });\r\n    container.bind<Foo>(FOO).to(Foo);\r\n    const foo = container.get<Foo>(FOO);\r\n    expect(foo.bar.length).to.eql(2);\r\n    expect(foo.bar[0]?.name).to.eql(\"bar1\");\r\n    expect(foo.bar[1]?.name).to.eql(\"bar2\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject into an abstract class","suites":["Bugs"],"updatePoint":{"line":578,"column":53},"line":578,"code":"  it(\"Should be able to inject into an abstract class\", () => {\r\n\r\n    interface Weapon { }\r\n\r\n    @injectable()\r\n    abstract class BaseSoldier {\r\n      public weapon: Weapon;\r\n      public constructor(\r\n        @inject(\"Weapon\") weapon: Weapon\r\n      ) {\r\n        this.weapon = weapon;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Soldier extends BaseSoldier { }\r\n\r\n    @injectable()\r\n    class Archer extends BaseSoldier { }\r\n\r\n    @injectable()\r\n    class Knight extends BaseSoldier { }\r\n\r\n    @injectable()\r\n    class Sword implements Weapon { }\r\n\r\n    @injectable()\r\n    class Bow implements Weapon { }\r\n\r\n    @injectable()\r\n    class DefaultWeapon implements Weapon { }\r\n\r\n    const container = new Container();\r\n\r\n    container.bind<Weapon>(\"Weapon\").to(DefaultWeapon).whenInjectedInto(Soldier);\r\n    container.bind<Weapon>(\"Weapon\").to(Sword).whenInjectedInto(Knight);\r\n    container.bind<Weapon>(\"Weapon\").to(Bow).whenInjectedInto(Archer);\r\n    container.bind<BaseSoldier>(\"BaseSoldier\").to(Soldier).whenTargetNamed(\"default\");\r\n    container.bind<BaseSoldier>(\"BaseSoldier\").to(Knight).whenTargetNamed(\"knight\");\r\n    container.bind<BaseSoldier>(\"BaseSoldier\").to(Archer).whenTargetNamed(\"archer\");\r\n\r\n    const soldier = container.getNamed<BaseSoldier>(\"BaseSoldier\", \"default\");\r\n    const knight = container.getNamed<BaseSoldier>(\"BaseSoldier\", \"knight\");\r\n    const archer = container.getNamed<BaseSoldier>(\"BaseSoldier\", \"archer\");\r\n\r\n    expect(soldier.weapon instanceof DefaultWeapon).to.eql(true);\r\n    expect(knight.weapon instanceof Sword).to.eql(true);\r\n    expect(archer.weapon instanceof Bow).to.eql(true);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able apply inject to property shortcut","suites":["Bugs"],"updatePoint":{"line":629,"column":54},"line":629,"code":"  it(\"Should be able apply inject to property shortcut\", () => {\r\n\r\n    interface Weapon {\r\n      use(): string;\r\n    }\r\n\r\n    @injectable()\r\n    class Katana implements Weapon {\r\n      public use() {\r\n        return \"Used Katana!\";\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Ninja {\r\n      public constructor(@inject(\"Weapon\") @named(\"sword\") private _weapon: Weapon) {\r\n        //\r\n      }\r\n      public fight() {\r\n        return this._weapon.use();\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"sword\");\r\n    container.bind<Ninja>(Ninja).toSelf();\r\n\r\n    const ninja = container.get<Ninja>(Ninja);\r\n    expect(ninja.fight()).eql(\"Used Katana!\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject into abstract base class without decorators","suites":["Bugs"],"updatePoint":{"line":661,"column":74},"line":661,"code":"  it(\"Should be able to inject into abstract base class without decorators\", () => {\r\n\r\n    const TYPES = {\r\n      Warrior: \"Warrior\",\r\n      Weapon: \"Weapon\"\r\n    };\r\n\r\n    const TAGS = {\r\n      Primary: \"Primary\",\r\n      Priority: \"Priority\",\r\n      Secondary: \"Secondary\"\r\n    };\r\n\r\n    interface Weapon {\r\n      name: string;\r\n    }\r\n\r\n    @injectable()\r\n    class Katana implements Weapon {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"Katana\";\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class Shuriken implements Weapon {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"Shuriken\";\r\n      }\r\n    }\r\n\r\n    interface Warrior {\r\n      name: string;\r\n      primaryWeapon: Weapon;\r\n    }\r\n\r\n    abstract class BaseWarrior implements Warrior {\r\n\r\n      public name: string;\r\n      public primaryWeapon!: Weapon;\r\n\r\n      public constructor(@unmanaged() name: string) {\r\n        this.name = name;\r\n      }\r\n\r\n    }\r\n\r\n    // @injectable()\r\n    decorate(injectable(), BaseWarrior);\r\n\r\n    // @inject(TYPES.Weapon)\r\n    inject(TYPES.Weapon)(BaseWarrior.prototype, \"primaryWeapon\");\r\n\r\n    // @tagged(TAGS.Priority, TAGS.Primary)\r\n    tagged(TAGS.Priority, TAGS.Primary)(BaseWarrior.prototype, \"primaryWeapon\");\r\n\r\n    @injectable()\r\n    class Samurai extends BaseWarrior {\r\n\r\n      @inject(TYPES.Weapon)\r\n      @tagged(TAGS.Priority, TAGS.Secondary)\r\n      public secondaryWeapon!: Weapon;\r\n\r\n      public constructor() {\r\n        super(\"Samurai\");\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\r\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetTagged(TAGS.Priority, TAGS.Primary);\r\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetTagged(TAGS.Priority, TAGS.Secondary);\r\n\r\n    const samurai = container.get<Samurai>(TYPES.Warrior);\r\n    expect(samurai.name).to.eql(\"Samurai\");\r\n    expect(samurai.secondaryWeapon).not.to.eql(undefined);\r\n    expect(samurai.secondaryWeapon.name).to.eql(\"Shuriken\");\r\n    expect(samurai.primaryWeapon).not.to.eql(undefined);\r\n    expect(samurai.primaryWeapon.name).to.eql(\"Katana\");\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to combine unmanaged and managed injections ","suites":["Bugs"],"updatePoint":{"line":744,"column":65},"line":744,"code":"  it(\"Should be able to combine unmanaged and managed injections \", () => {\r\n\r\n    interface Model<T> {\r\n      instance: T;\r\n    }\r\n\r\n    interface RepoBaseInterface<T> {\r\n      model: Model<T>;\r\n    }\r\n\r\n    class Type {\r\n      public name: string;\r\n      public constructor() {\r\n        this.name = \"Type\";\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class RepoBase<T> implements RepoBaseInterface<T> {\r\n\r\n      public model: Model<T>;\r\n\r\n      public constructor(\r\n        // using @unmanaged() here is right\r\n        // because entityType is NOT Injected by inversify\r\n        @unmanaged() entityType: new () => T\r\n      ) {\r\n        this.model = { instance: new entityType() };\r\n      }\r\n\r\n    }\r\n\r\n    @injectable()\r\n    class TypedRepo extends RepoBase<Type> {\r\n      public constructor() {\r\n        super(Type); // unmanaged injection (NOT Injected by inversify)\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class BLBase<T> {\r\n\r\n      public repository: RepoBaseInterface<T>;\r\n\r\n      public constructor(\r\n        // using @unmanaged() here would wrong\r\n        // because repository is injected by inversify\r\n        repository: RepoBaseInterface<T>\r\n      ) {\r\n        this.repository = repository;\r\n      }\r\n    }\r\n\r\n    @injectable()\r\n    class TypedBL extends BLBase<Type> {\r\n      public constructor(\r\n        repository: TypedRepo // Injected by inversify (no @inject required)\r\n      ) {\r\n        super(repository); // managed injection (Injected by inversify)\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<TypedRepo>(TypedRepo).toSelf();\r\n    container.bind<TypedBL>(\"TypedBL\").to(TypedBL);\r\n\r\n    const typedBL = container.get<TypedBL>(\"TypedBL\");\r\n    expect(typedBL.repository.model.instance.name).to.eq(new Type().name);\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"Should detect missing annotations in base classes","suites":["Bugs"],"updatePoint":{"line":815,"column":55},"line":815,"code":"  it(\"Should detect missing annotations in base classes\", () => {\r\n\r\n    @injectable()\r\n    class Katana implements Katana {\r\n      public hit() {\r\n        return \"cut!\";\r\n      }\r\n    }\r\n\r\n    abstract class Warrior {\r\n      private _katana: Katana;\r\n\r\n      public constructor(\r\n        @unmanaged() katana: Katana\r\n      ) {\r\n        this._katana = katana;\r\n      }\r\n\r\n      public fight() { return this._katana.hit(); }\r\n    }\r\n\r\n    @injectable()\r\n    class Ninja extends Warrior {\r\n      public constructor(\r\n        @inject(\"Katana\") katana: Katana\r\n      ) {\r\n        super(katana);\r\n      }\r\n    }\r\n\r\n    const container = new Container();\r\n    container.bind<Warrior>(\"Ninja\").to(Ninja);\r\n    container.bind<Katana>(\"Katana\").to(Katana);\r\n\r\n    const tryGet = () => {\r\n      container.get<Ninja>(\"Ninja\");\r\n    };\r\n\r\n    expect(tryGet).to.throw(\"Missing required @injectable annotation in: Warrior.\");\r\n\r\n  });\r","file":"bugs/bugs.test.ts","skipped":false,"dir":"test"},{"name":"should inject a katana as default weapon to ninja","suites":["Issue 1190"],"updatePoint":{"line":6,"column":55},"line":6,"code":"  it('should inject a katana as default weapon to ninja', () => {\n    const TYPES = {\n      Weapon: \"Weapon\"\n    };\n\n    const TAG = {\n      throwable: \"throwable\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n      public name: string;\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(TYPES.Weapon) @optional() katana: Weapon,\n        @inject(TYPES.Weapon) @named(TAG.throwable) shuriken: Weapon\n      ) {\n        this.name = \"Ninja\";\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetIsDefault();\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetNamed(TAG.throwable);\n\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.katana).to.deep.eq(new Katana());\n  });","file":"bugs/issue_1190.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is a constant value binding","suites":["Issue 1297"],"updatePoint":{"line":6,"column":78},"line":6,"code":"  it('should call onActivation once if the service is a constant value binding', () => {\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, message: string) => string\n    >((_ctx: interfaces.Context, message: string) => message);\n\n    container.bind<string>(\"message\")\n      .toConstantValue(\"Hello world\")\n      .onActivation(onActivationHandlerSpy);\n\n    container.get(\"message\");\n    container.get(\"message\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is a factory binding","suites":["Issue 1297"],"updatePoint":{"line":23,"column":71},"line":23,"code":"  it('should call onActivation once if the service is a factory binding', () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, instance: interfaces.Factory<Katana>) => interfaces.Factory<Katana>\n    >((_ctx: interfaces.Context, instance: interfaces.Factory<Katana>) => instance);\n\n    container.bind<Katana>(\"Katana\").to(Katana);\n\n    container.bind<interfaces.Factory<Katana>>(\"Factory<Katana>\").toFactory<Katana>((context) =>\n      () =>\n        context.container.get<Katana>(\"Katana\")).onActivation(onActivationHandlerSpy);\n\n    container.get(\"Factory<Katana>\");\n    container.get(\"Factory<Katana>\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is an auto factory binding","suites":["Issue 1297"],"updatePoint":{"line":50,"column":77},"line":50,"code":"  it('should call onActivation once if the service is an auto factory binding', () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, instance: interfaces.Factory<Katana>) => interfaces.Factory<Katana>\n    >((_ctx: interfaces.Context, instance: interfaces.Factory<Katana>) => instance);\n\n    container.bind<Katana>(\"Katana\").to(Katana);\n\n    container.bind<interfaces.Factory<Katana>>(\"Factory<Katana>\")\n      .toAutoFactory<Katana>(\"Katana\").onActivation(onActivationHandlerSpy);\n\n    container.get(\"Factory<Katana>\");\n    container.get(\"Factory<Katana>\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is a function binding","suites":["Issue 1297"],"updatePoint":{"line":76,"column":72},"line":76,"code":"  it('should call onActivation once if the service is a function binding', () => {\n\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, messageGenerator: () => string) => () => string\n    >((_ctx: interfaces.Context, messageGenerator: () => string) => messageGenerator);\n\n    container.bind<() => string>(\"message\")\n      .toFunction(() => \"Hello world\")\n      .onActivation(onActivationHandlerSpy);\n\n    container.get(\"message\");\n    container.get(\"message\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is a constructor binding","suites":["Issue 1297"],"updatePoint":{"line":94,"column":75},"line":94,"code":"  it('should call onActivation once if the service is a constructor binding', () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, injectableObj: unknown) => unknown\n    >((_ctx: interfaces.Context, injectableObj: unknown) => injectableObj);\n\n    container.bind(\"Katana\")\n      .toConstructor<Katana>(Katana)\n      .onActivation(onActivationHandlerSpy);\n\n    container.get(\"Katana\");\n    container.get(\"Katana\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"should call onActivation once if the service is a provider binding","suites":["Issue 1297"],"updatePoint":{"line":119,"column":72},"line":119,"code":"  it('should call onActivation once if the service is a provider binding', () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    const container = new Container();\n\n    const onActivationHandlerSpy = sinon.spy<\n      (ctx: interfaces.Context, injectableObj: unknown) => unknown\n    >((_ctx: interfaces.Context, injectableObj: unknown) => injectableObj);\n\n    container.bind(\"Provider<Katana>\")\n      .toProvider<Katana>((context: interfaces.Context) =>\n        () =>\n          Promise.resolve(new Katana())).onActivation(onActivationHandlerSpy);\n\n    container.get(\"Provider<Katana>\");\n    container.get(\"Provider<Katana>\");\n\n    expect(onActivationHandlerSpy.callCount).to.eq(1);\n  });","file":"bugs/issue_1297.test.ts","skipped":false,"dir":"test"},{"name":"Should throw correct circular dependency path","suites":["Issue 543"],"updatePoint":{"line":7,"column":51},"line":7,"code":"  it(\"Should throw correct circular dependency path\", () => {\n\n    const TYPE = {\n      Child: Symbol.for(\"Child\"),\n      Child2: Symbol.for(\"Child2\"),\n      Circular: Symbol.for(\"Circular\"),\n      Irrelevant: Symbol.for(\"Irrelevant1\"),\n      Root: Symbol.for(\"Root\")\n    };\n\n    interface IIrrelevant { }\n    interface ICircular { }\n    interface IChild { }\n    interface IChild2 { }\n\n    @injectable()\n    class Irrelevant implements IIrrelevant { }\n\n    @injectable()\n    class Child2 implements IChild2 {\n      public circ: ICircular;\n      public constructor(\n        @inject(TYPE.Circular) circ: ICircular\n      ) {\n        this.circ = circ;\n      }\n    }\n\n    @injectable()\n    class Child implements IChild {\n      public irrelevant: IIrrelevant;\n      public child2: IChild2;\n      public constructor(\n        @inject(TYPE.Irrelevant) irrelevant: IIrrelevant,\n        @inject(TYPE.Child2) child2: IChild2\n      ) {\n        this.irrelevant = irrelevant;\n        this.child2 = child2;\n      }\n    }\n\n    @injectable()\n    class Circular implements Circular {\n      public irrelevant: IIrrelevant;\n      public child: IChild;\n      public constructor(\n        @inject(TYPE.Irrelevant) irrelevant: IIrrelevant,\n        @inject(TYPE.Child) child: IChild\n      ) {\n        this.irrelevant = irrelevant;\n        this.child = child;\n      }\n    }\n\n    @injectable()\n    class Root {\n      public irrelevant: IIrrelevant;\n      public circ: ICircular;\n      public constructor(\n        @inject(TYPE.Irrelevant) irrelevant1: IIrrelevant,\n        @inject(TYPE.Circular) circ: ICircular\n      ) {\n        this.irrelevant = irrelevant1;\n        this.circ = circ;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Root>(TYPE.Root).to(Root);\n    container.bind<Irrelevant>(TYPE.Irrelevant).to(Irrelevant);\n    container.bind<Circular>(TYPE.Circular).to(Circular);\n    container.bind<Child>(TYPE.Child).to(Child);\n    container.bind<Child2>(TYPE.Child2).to(Child2);\n\n    function throws() {\n      return container.get(TYPE.Root);\n    }\n\n    expect(throws).to.throw(\n      `${ERROR_MSGS.CIRCULAR_DEPENDENCY} Symbol(Root) --> Symbol(Circular) --> Symbol(Child) --> Symbol(Child2) --> Symbol(Circular)`\n    );\n\n  });","file":"bugs/issue_543.test.ts","skipped":false,"dir":"test"},{"name":"Should throw if circular dependencies found with dynamics","suites":["Issue 549"],"updatePoint":{"line":6,"column":63},"line":6,"code":"  it(\"Should throw if circular dependencies found with dynamics\", () => {\n\n    const TYPE = {\n      ADynamicValue: Symbol.for(\"ADynamicValue\"),\n      BDynamicValue: Symbol.for(\"BDynamicValue\")\n    };\n\n    interface IA { }\n    interface IB { }\n\n    @injectable()\n    class A {\n      public b: IB;\n      public constructor(\n        @inject(TYPE.BDynamicValue) b: IB\n      ) {\n        this.b = b;\n      }\n    }\n\n    @injectable()\n    class B {\n      public a: IA;\n      public constructor(\n        @inject(TYPE.ADynamicValue) a: IA\n      ) {\n        this.a = a;\n      }\n    }\n\n    const container = new Container({ defaultScope: \"Singleton\" });\n    container.bind(A).toSelf();\n    container.bind(B).toSelf();\n\n    container.bind(TYPE.ADynamicValue).toDynamicValue((ctx) =>\n      ctx.container.get(A)\n    );\n\n    container.bind(TYPE.BDynamicValue).toDynamicValue((ctx) =>\n      ctx.container.get(B)\n    );\n\n    function willThrow() {\n      return container.get<A>(A);\n    }\n\n    try {\n      const result = willThrow();\n      throw new Error(\n        `This line should never be executed. Expected 'willThrow' to throw! ${JSON.stringify(result)}`\n      );\n    } catch (e) {\n\n      const expectedErrorA = ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(\"toDynamicValue\", TYPE.ADynamicValue.toString());\n      const expectedErrorB = ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(\"toDynamicValue\", TYPE.BDynamicValue.toString());\n      const matchesErrorA = e.message.indexOf(expectedErrorA) !== -1;\n      const matchesErrorB = e.message.indexOf(expectedErrorB) !== -1;\n\n      if (!matchesErrorA && !matchesErrorB) {\n        throw new Error(\n          \"Expected 'willThrow' to throw:\\n\" +\n          `- ${expectedErrorA}\\n` +\n          \"or\\n\" +\n          `- ${expectedErrorB}\\n` +\n          \"but got\\n\" +\n          `- ${e.message}`\n        );\n      }\n\n    }\n\n  });","file":"bugs/issue_549.test.ts","skipped":false,"dir":"test"},{"name":"Should expose metadata through context","suites":["Issue 633"],"updatePoint":{"line":6,"column":44},"line":6,"code":"  it(\"Should expose metadata through context\", () => {\n\n    @injectable()\n    class Logger {\n      public named: string;\n      public constructor(named: string) {\n        this.named = named;\n      }\n    }\n\n    const container = new Container();\n\n    const TYPE = {\n      Logger: Symbol.for(\"Logger\")\n    };\n\n    container.bind<Logger>(TYPE.Logger).toDynamicValue((context) => {\n      const namedMetadata = context.currentRequest.target.getNamedTag();\n      const named = namedMetadata ? namedMetadata.value : \"default\";\n      return new Logger(named as string);\n    });\n\n    const logger1 = container.getNamed<Logger>(TYPE.Logger, \"Name1\");\n    const logger2 = container.getNamed<Logger>(TYPE.Logger, \"Name2\");\n\n    expect(logger1.named).to.eq(\"Name1\");\n    expect(logger2.named).to.eq(\"Name2\");\n\n  });","file":"bugs/issue_633.test.ts","skipped":false,"dir":"test"},{"name":"Should expose BindingScopeEnum as part of the public API","suites":["Issue 706"],"updatePoint":{"line":6,"column":62},"line":6,"code":"  it(\"Should expose BindingScopeEnum as part of the public API\", () => {\n\n    @injectable()\n    class SomeClass {\n      public time: number;\n      public constructor() {\n        this.time = new Date().getTime();\n      }\n    }\n\n    const container = new Container({\n      defaultScope: BindingScopeEnum.Singleton,\n    });\n\n    const TYPE = {\n      SomeClass: Symbol.for(\"SomeClass\")\n    };\n\n    container.bind<SomeClass>(TYPE.SomeClass).to(SomeClass);\n\n    const instanceOne = container.get<SomeClass>(TYPE.SomeClass);\n    const instanceTwo = container.get<SomeClass>(TYPE.SomeClass);\n\n    expect(instanceOne.time).to.eq(instanceTwo.time);\n\n  });","file":"bugs/issue_706.test.ts","skipped":false,"dir":"test"},{"name":"should inject the right instances","suites":["Issue 928"],"updatePoint":{"line":7,"column":39},"line":7,"code":"  it('should inject the right instances', () => {\n\n    let injectedA: unknown;\n    let injectedB: unknown;\n    let injectedC: unknown;\n\n    // some dependencies\n    @injectable() class DepA { a = 1 }\n    @injectable() class DepB { b = 1 }\n    @injectable() class DepC { c = 1 }\n\n    @injectable() abstract class AbstractCls {\n      constructor(@inject(DepA) a: DepA, @inject(DepB) @optional() b: DepB = { b: 0 }) {\n        injectedA = a;\n        injectedB = b;\n      }\n    }\n\n    @injectable() class Cls extends AbstractCls {\n      constructor(@inject(DepC) c: DepC, @inject(DepB) @optional() b: DepB = { b: 0 }, @inject(DepA) a: DepA) {\n        super(a, b);\n\n        injectedC = c;\n      }\n    }\n\n    const container = new Container();\n    [DepA, DepB, DepC, Cls].forEach(i => container.bind(i).toSelf().inSingletonScope());\n\n    container.get(Cls);\n\n    expect(injectedA).to.deep.eq(new DepA());\n    expect(injectedB).to.deep.eq(new DepB());\n    expect(injectedC).to.deep.eq(new DepC());\n  });","file":"bugs/issue_928.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to customize POST_CONSTRUCT_ERROR","suites":["ERROR_MSGS"],"updatePoint":{"line":6,"column":54},"line":6,"code":"  it(\"Should be able to customize POST_CONSTRUCT_ERROR\", () => {\n    const error = ERROR_MSGS.POST_CONSTRUCT_ERROR(\"a\", \"b\");\n    expect(error).eql(\"@postConstruct error in class a: b\");\n  });","file":"constants/error_message.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to set the registry of a container module","suites":["ContainerModule"],"updatePoint":{"line":10,"column":62},"line":10,"code":"  it(\"Should be able to set the registry of a container module\", () => {\n    const registry = (bind: interfaces.Bind) => { /* do nothing */ };\n    const warriors = new ContainerModule(registry);\n    expect(warriors.id).to.be.a(\"number\");\n    expect(warriors.registry).eql(registry);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to remove some bindings from within a container module","suites":["ContainerModule"],"updatePoint":{"line":17,"column":75},"line":17,"code":"  it(\"Should be able to remove some bindings from within a container module\", () => {\n\n    const container = new Container();\n    container.bind<string>(\"A\").toConstantValue(\"1\");\n    expect(container.get<string>(\"A\")).to.eql(\"1\");\n\n    const warriors = new ContainerModule((bind: interfaces.Bind, unbind: interfaces.Unbind) => {\n      expect(container.get<string>(\"A\")).to.eql(\"1\");\n      unbind(\"A\");\n      expect(() => { container.get<string>(\"A\"); }).to.throw();\n      bind<string>(\"A\").toConstantValue(\"2\");\n      expect(container.get<string>(\"A\")).to.eql(\"2\");\n      bind<string>(\"B\").toConstantValue(\"3\");\n      expect(container.get<string>(\"B\")).to.eql(\"3\");\n    });\n\n    container.load(warriors);\n    expect(container.get<string>(\"A\")).to.eql(\"2\");\n    expect(container.get<string>(\"B\")).to.eql(\"3\");\n\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check for existence of bindings within a container module","suites":["ContainerModule"],"updatePoint":{"line":39,"column":81},"line":39,"code":"  it(\"Should be able to check for existence of bindings within a container module\", () => {\n\n    const container = new Container();\n    container.bind<string>(\"A\").toConstantValue(\"1\");\n    expect(container.get<string>(\"A\")).to.eql(\"1\");\n\n    const warriors = new ContainerModule((bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound) => {\n      expect(container.get<string>(\"A\")).to.eql(\"1\");\n      expect(isBound(\"A\")).to.eql(true);\n      unbind(\"A\");\n      expect(isBound(\"A\")).to.eql(false);\n    });\n\n    container.load(warriors);\n\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to override a binding using rebind within a container module","suites":["ContainerModule"],"updatePoint":{"line":56,"column":81},"line":56,"code":"  it(\"Should be able to override a binding using rebind within a container module\", () => {\n\n    const TYPES = {\n      someType: \"someType\"\n    };\n\n    const container = new Container();\n\n    const module1 = new ContainerModule(\n      (\n        bind: interfaces.Bind,\n        unbind: interfaces.Unbind,\n        isBound: interfaces.IsBound\n      ) => {\n        bind<number>(TYPES.someType).toConstantValue(1);\n        bind<number>(TYPES.someType).toConstantValue(2);\n      }\n    );\n\n    const module2 = new ContainerModule(\n      (\n        bind: interfaces.Bind,\n        unbind: interfaces.Unbind,\n        isBound: interfaces.IsBound,\n        rebind: interfaces.Rebind\n      ) => {\n        rebind<number>(TYPES.someType).toConstantValue(3);\n      }\n    );\n\n    container.load(module1);\n    const values1 = container.getAll(TYPES.someType);\n    expect(values1[0]).to.eq(1);\n    expect(values1[1]).to.eq(2);\n\n    container.load(module2);\n    const values2 = container.getAll(TYPES.someType);\n    expect(values2[0]).to.eq(3);\n    expect(values2[1]).to.eq(undefined);\n\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able use await async functions in container modules","suites":["ContainerModule"],"updatePoint":{"line":98,"column":67},"line":98,"code":"  it(\"Should be able use await async functions in container modules\", async () => {\n\n    const container = new Container();\n    const someAsyncFactory = () => new Promise<number>((res) => setTimeout(() => res(1), 100));\n    const A = Symbol.for(\"A\");\n    const B = Symbol.for(\"B\");\n\n    const moduleOne = new AsyncContainerModule(async (bind) => {\n      const val = await someAsyncFactory();\n      bind(A).toConstantValue(val);\n    });\n\n    const moduleTwo = new AsyncContainerModule(async (bind) => {\n      bind(B).toConstantValue(2);\n    });\n\n    await container.loadAsync(moduleOne, moduleTwo);\n\n    const AIsBound = container.isBound(A);\n    expect(AIsBound).to.eq(true);\n    const a = container.get(A);\n    expect(a).to.eq(1);\n\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to add an activation hook through a container module","suites":["ContainerModule"],"updatePoint":{"line":123,"column":73},"line":123,"code":"  it(\"Should be able to add an activation hook through a container module\", () => {\n\n    const container = new Container();\n    container.bind<string>(\"A\").toDynamicValue(() => \"1\");\n    expect(container.get<string>(\"A\")).to.eql(\"1\");\n\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation) => {\n      bind<string>(\"B\").toConstantValue(\"2\").onActivation(() => \"C\");\n      onActivation(\"A\", () => \"B\");\n    });\n\n    container.load(module);\n\n    expect(container.get<string>(\"A\")).to.eql(\"B\");\n    expect(container.get(\"B\")).to.eql(\"C\")\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to add a deactivation hook through a container module","suites":["ContainerModule"],"updatePoint":{"line":140,"column":74},"line":140,"code":"  it(\"Should be able to add a deactivation hook through a container module\", () => {\n    const container = new Container();\n    container.bind<string>(\"A\").toConstantValue(\"1\");\n\n    let deact = false;\n    const warriors = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      onDeactivation(\"A\", () => {\n        deact = true;\n      });\n    });\n\n    container.load(warriors);\n    container.get(\"A\");\n    container.unbind(\"A\");\n\n    expect(deact).eql(true);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to add an async deactivation hook through a container module (async)","suites":["ContainerModule"],"updatePoint":{"line":158,"column":89},"line":158,"code":"  it(\"Should be able to add an async deactivation hook through a container module (async)\", async () => {\n    const container = new Container();\n    container.bind<string>(\"A\").toConstantValue(\"1\");\n\n    let deact = false;\n\n    const warriors = new ContainerModule((bind, unbind, isBound, rebind, unBindAsync, onActivation, onDeactivation) => {\n      onDeactivation(\"A\", async () => {\n        deact = true;\n      });\n    });\n\n    container.load(warriors);\n    container.get(\"A\");\n    await container.unbindAsync(\"A\");\n\n    expect(deact).eql(true);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to add multiple async deactivation hook through a container module (async)","suites":["ContainerModule"],"updatePoint":{"line":177,"column":95},"line":177,"code":"  it(\"Should be able to add multiple async deactivation hook through a container module (async)\", async () => {\n\n    const onActivationHandlerSpy = sinon.spy<() => Promise<void>>(async () => undefined);\n\n    const serviceIdentifier = \"destroyable\";\n    const container = new Container();\n\n    const containerModule = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      onDeactivation(serviceIdentifier, onActivationHandlerSpy);\n      onDeactivation(serviceIdentifier, onActivationHandlerSpy);\n    });\n\n    container.bind(serviceIdentifier).toConstantValue(serviceIdentifier);\n\n    container.get(serviceIdentifier);\n\n    container.load(containerModule);\n\n    await container.unbindAllAsync();\n\n    expect(onActivationHandlerSpy.callCount).to.eq(2);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should remove module bindings when unload","suites":["ContainerModule"],"updatePoint":{"line":200,"column":47},"line":200,"code":"  it(\"Should remove module bindings when unload\", () => {\n    const sid = \"sid\";\n    const container = new Container();\n    container.bind<string>(sid).toConstantValue(\"Not module\");\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      bind<string>(sid).toConstantValue(\"Module\")\n    });\n    container.load(module);\n    let values = container.getAll(sid);\n    expect(values).to.deep.equal([\"Not module\", \"Module\"]);\n\n    container.unload(module);\n    values = container.getAll(sid);\n    expect(values).to.deep.equal([\"Not module\"]);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should deactivate singletons from module bindings when unload","suites":["ContainerModule"],"updatePoint":{"line":216,"column":67},"line":216,"code":"  it(\"Should deactivate singletons from module bindings when unload\", () => {\n    const sid = \"sid\";\n    const container = new Container();\n    let moduleBindingDeactivated: string | undefined\n    let containerDeactivated: string | undefined\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      bind<string>(sid).toConstantValue(\"Module\").onDeactivation(injectable => { moduleBindingDeactivated = injectable });\n      onDeactivation<string>(sid, injectable => { containerDeactivated = injectable })\n    });\n    container.load(module);\n    container.get(sid);\n\n    container.unload(module);\n    expect(moduleBindingDeactivated).to.equal(\"Module\");\n    expect(containerDeactivated).to.equal(\"Module\");\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should remove container handlers from module when unload","suites":["ContainerModule"],"updatePoint":{"line":233,"column":62},"line":233,"code":"  it(\"Should remove container handlers from module when unload\", () => {\n    const sid = \"sid\";\n    const container = new Container();\n    let activatedNotModule: string | undefined\n    let deactivatedNotModule: string | undefined\n    container.onActivation<string>(sid, (_, injected) => {\n      activatedNotModule = injected;\n      return injected;\n    });\n    container.onDeactivation<string>(sid, injected => { deactivatedNotModule = injected })\n    container.bind<string>(sid).toConstantValue(\"Value\");\n    let activationCount = 0;\n    let deactivationCount = 0;\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      onDeactivation<string>(sid, _ => { deactivationCount++ });\n      onActivation<string>(sid, (_, injected) => {\n        activationCount++;\n        return injected;\n      });\n    });\n    container.load(module);\n    container.unload(module);\n\n    container.get(sid);\n    container.unbind(sid);\n\n    expect(activationCount).to.equal(0);\n    expect(deactivationCount).to.equal(0);\n\n    expect(activatedNotModule).to.equal(\"Value\");\n    expect(deactivatedNotModule).to.equal(\"Value\")\n  })","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should remove module bindings when unloadAsync","suites":["ContainerModule"],"updatePoint":{"line":266,"column":52},"line":266,"code":"  it(\"Should remove module bindings when unloadAsync\", async () => {\n    const sid = \"sid\";\n    const container = new Container();\n    container.onDeactivation(sid, injected => Promise.resolve());\n    container.bind<string>(sid).toConstantValue(\"Not module\");\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      bind<string>(sid).toConstantValue(\"Module\")\n    });\n    container.load(module);\n    let values = container.getAll(sid);\n    expect(values).to.deep.equal([\"Not module\", \"Module\"]);\n\n    await container.unloadAsync(module);\n    values = container.getAll(sid);\n    expect(values).to.deep.equal([\"Not module\"]);\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should deactivate singletons from module bindings when unloadAsync","suites":["ContainerModule"],"updatePoint":{"line":283,"column":72},"line":283,"code":"  it(\"Should deactivate singletons from module bindings when unloadAsync\", async () => {\n    const sid = \"sid\";\n    const container = new Container();\n    let moduleBindingDeactivated: string | undefined\n    let containerDeactivated: string | undefined\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      bind<string>(sid).toConstantValue(\"Module\").onDeactivation(injectable => { moduleBindingDeactivated = injectable });\n      onDeactivation<string>(sid, injectable => {\n        containerDeactivated = injectable;\n        return Promise.resolve();\n      })\n    });\n    container.load(module);\n    container.get(sid);\n\n    await container.unloadAsync(module);\n    expect(moduleBindingDeactivated).to.equal(\"Module\");\n    expect(containerDeactivated).to.equal(\"Module\");\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should remove container handlers from module when unloadAsync","suites":["ContainerModule"],"updatePoint":{"line":303,"column":67},"line":303,"code":"  it(\"Should remove container handlers from module when unloadAsync\", async () => {\n    const sid = \"sid\";\n    const container = new Container();\n    let activatedNotModule: string | undefined\n    let deactivatedNotModule: string | undefined\n    container.onActivation<string>(sid, (_, injected) => {\n      activatedNotModule = injected;\n      return injected;\n    });\n    container.onDeactivation<string>(sid, injected => {\n      deactivatedNotModule = injected;\n    })\n    container.bind<string>(sid).toConstantValue(\"Value\");\n    let activationCount = 0;\n    let deactivationCount = 0;\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      onDeactivation<string>(sid, _ => {\n        deactivationCount++\n        return Promise.resolve();\n      });\n      onActivation<string>(sid, (_, injected) => {\n        activationCount++;\n        return injected;\n      });\n    });\n    container.load(module);\n    await container.unloadAsync(module);\n\n    container.get(sid);\n    container.unbind(sid);\n\n    expect(activationCount).to.equal(0);\n    expect(deactivationCount).to.equal(0);\n\n    expect(activatedNotModule).to.equal(\"Value\");\n    expect(deactivatedNotModule).to.equal(\"Value\");\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"should be able to unbindAsync from a module","suites":["ContainerModule"],"updatePoint":{"line":341,"column":49},"line":341,"code":"  it(\"should be able to unbindAsync from a module\", async () => {\n    let _unbindAsync: interfaces.UnbindAsync | undefined\n    const container = new Container();\n    const module = new ContainerModule((bind, unbind, isBound, rebind, unbindAsync, onActivation, onDeactivation) => {\n      _unbindAsync = unbindAsync\n    });\n    const sid = \"sid\";\n    container.bind<string>(sid).toConstantValue(\"Value\")\n    container.bind<string>(sid).toConstantValue(\"Value2\")\n    const deactivated: string[] = []\n    container.onDeactivation<string>(sid, injected => {\n      deactivated.push(injected);\n      return Promise.resolve();\n    })\n\n    container.getAll(sid);\n    container.load(module);\n    await _unbindAsync!(sid);\n    expect(deactivated).to.deep.equal([\"Value\", \"Value2\"]);\n    //bindings removed\n    expect(() => container.getAll(sid)).to.throw(`${NOT_REGISTERED} sid`)\n  });","file":"container/container_module.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use modules as configuration","suites":["Container"],"updatePoint":{"line":29,"column":52},"line":29,"code":"  it(\"Should be able to use modules as configuration\", () => {\n\n    interface Ninja { }\n    interface Katana { }\n    interface Shuriken { }\n\n    @injectable()\n    class Katana implements Katana { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const warriors = new ContainerModule((bind: interfaces.Bind) => {\n      bind<Ninja>(\"Ninja\").to(Ninja);\n    });\n\n    const weapons = new ContainerModule((bind: interfaces.Bind) => {\n      bind<Katana>(\"Katana\").to(Katana);\n      bind<Shuriken>(\"Shuriken\").to(Shuriken);\n    });\n\n    const container = new Container();\n    container.load(warriors, weapons);\n\n    let map: Dictionary = getBindingDictionary(container).getMap();\n    expect(map.has(\"Ninja\")).equal(true);\n    expect(map.has(\"Katana\")).equal(true);\n    expect(map.has(\"Shuriken\")).equal(true);\n    expect(map.size).equal(3);\n\n    const tryGetNinja = () => { container.get(\"Ninja\"); };\n    const tryGetKatana = () => { container.get(\"Katana\"); };\n    const tryGetShuruken = () => { container.get(\"Shuriken\"); };\n\n    container.unload(warriors);\n    map = getBindingDictionary(container).getMap();\n    expect(map.size).equal(2);\n    expect(tryGetNinja).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetKatana).not.to.throw();\n    expect(tryGetShuruken).not.to.throw();\n\n    container.unload(weapons);\n    map = getBindingDictionary(container).getMap();\n    expect(map.size).equal(0);\n    expect(tryGetNinja).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetKatana).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetShuruken).to.throw(ERROR_MSGS.NOT_REGISTERED);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to store bindings","suites":["Container"],"updatePoint":{"line":82,"column":38},"line":82,"code":"  it(\"Should be able to store bindings\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaId = \"Ninja\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    const map: Dictionary = getBindingDictionary(container).getMap();\n    expect(map.size).equal(1);\n    expect(map.has(ninjaId)).equal(true);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should have an unique identifier","suites":["Container"],"updatePoint":{"line":99,"column":38},"line":99,"code":"  it(\"Should have an unique identifier\", () => {\n\n    const container1 = new Container();\n    const container2 = new Container();\n    expect(container1.id).to.be.a(\"number\");\n    expect(container2.id).to.be.a(\"number\");\n    expect(container1.id).not.equal(container2.id);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should unbind a binding when requested","suites":["Container"],"updatePoint":{"line":109,"column":44},"line":109,"code":"  it(\"Should unbind a binding when requested\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaId = \"Ninja\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    const map: Dictionary = getBindingDictionary(container).getMap();\n    expect(map.has(ninjaId)).equal(true);\n\n    container.unbind(ninjaId);\n    expect(map.has(ninjaId)).equal(false);\n    expect(map.size).equal(0);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when cannot unbind","suites":["Container"],"updatePoint":{"line":129,"column":37},"line":129,"code":"  it(\"Should throw when cannot unbind\", () => {\n    const serviceIdentifier = \"Ninja\";\n    const container = new Container();\n    const throwFunction = () => { container.unbind(serviceIdentifier); };\n    expect(throwFunction).to.throw(`${ERROR_MSGS.CANNOT_UNBIND} ${getServiceIdentifierAsString(serviceIdentifier)}`);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when cannot unbind (async)","suites":["Container"],"updatePoint":{"line":136,"column":45},"line":136,"code":"  it(\"Should throw when cannot unbind (async)\", async () => {\n    const serviceIdentifier = \"Ninja\";\n    const container = new Container();\n\n    try {\n      await container.unbindAsync(serviceIdentifier);\n      assert.fail();\n    } catch (err: unknown) {\n      expect((err as Error).message).to.eql(`${ERROR_MSGS.CANNOT_UNBIND} ${getServiceIdentifierAsString(serviceIdentifier)}`);\n    }\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should unbind a binding when requested","suites":["Container"],"updatePoint":{"line":148,"column":44},"line":148,"code":"  it(\"Should unbind a binding when requested\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    interface Samurai { }\n\n    @injectable()\n    class Samurai implements Samurai { }\n\n    const ninjaId = \"Ninja\";\n    const samuraiId = \"Samurai\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Samurai>(samuraiId).to(Samurai);\n\n    let map: Dictionary = getBindingDictionary(container).getMap();\n\n    expect(map.size).equal(2);\n    expect(map.has(ninjaId)).equal(true);\n    expect(map.has(samuraiId)).equal(true);\n\n    container.unbind(ninjaId);\n    map = getBindingDictionary(container).getMap();\n    expect(map.size).equal(1);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able unbound all dependencies","suites":["Container"],"updatePoint":{"line":178,"column":45},"line":178,"code":"  it(\"Should be able unbound all dependencies\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    interface Samurai { }\n\n    @injectable()\n    class Samurai implements Samurai { }\n\n    const ninjaId = \"Ninja\";\n    const samuraiId = \"Samurai\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Samurai>(samuraiId).to(Samurai);\n\n    let map: Dictionary = getBindingDictionary(container).getMap();\n\n    expect(map.size).equal(2);\n    expect(map.has(ninjaId)).equal(true);\n    expect(map.has(samuraiId)).equal(true);\n\n    container.unbindAll();\n    map = getBindingDictionary(container).getMap();\n    expect(map.size).equal(0);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should NOT be able to get unregistered services","suites":["Container"],"updatePoint":{"line":209,"column":53},"line":209,"code":"  it(\"Should NOT be able to get unregistered services\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaId = \"Ninja\";\n\n    const container = new Container();\n    const throwFunction = () => { container.get<Ninja>(ninjaId); };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.NOT_REGISTERED} ${ninjaId}`);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should NOT be able to get ambiguous match","suites":["Container"],"updatePoint":{"line":223,"column":47},"line":223,"code":"  it(\"Should NOT be able to get ambiguous match\", () => {\n\n    interface Warrior { }\n\n    @injectable()\n    class Ninja implements Warrior { }\n\n    @injectable()\n    class Samurai implements Warrior { }\n\n    const warriorId = \"Warrior\";\n\n    const container = new Container();\n    container.bind<Warrior>(warriorId).to(Ninja);\n    container.bind<Warrior>(warriorId).to(Samurai);\n\n    const dictionary: Dictionary = getBindingDictionary(container).getMap();\n\n    expect(dictionary.size).equal(1);\n    dictionary.forEach((value, key) => {\n      expect(key).equal(warriorId);\n      expect(value.length).equal(2);\n    });\n\n    const throwFunction = () => { container.get<Warrior>(warriorId); };\n    expect(throwFunction).to.throw(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${warriorId}`);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should NOT be able to getAll of an unregistered services","suites":["Container"],"updatePoint":{"line":252,"column":62},"line":252,"code":"  it(\"Should NOT be able to getAll of an unregistered services\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaId = \"Ninja\";\n\n    const container = new Container();\n    const throwFunction = () => { container.getAll<Ninja>(ninjaId); };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.NOT_REGISTERED} ${ninjaId}`);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a string literal identifier as a string","suites":["Container"],"updatePoint":{"line":267,"column":67},"line":267,"code":"  it(\"Should be able to get a string literal identifier as a string\", () => {\n    const Katana = \"Katana\";\n    const KatanaStr = getServiceIdentifierAsString(Katana);\n    expect(KatanaStr).to.equal(\"Katana\");\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a symbol identifier as a string","suites":["Container"],"updatePoint":{"line":273,"column":59},"line":273,"code":"  it(\"Should be able to get a symbol identifier as a string\", () => {\n    const KatanaSymbol = Symbol.for(\"Katana\");\n    const KatanaStr = getServiceIdentifierAsString(KatanaSymbol);\n    expect(KatanaStr).to.equal(\"Symbol(Katana)\");\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a class identifier as a string","suites":["Container"],"updatePoint":{"line":279,"column":58},"line":279,"code":"  it(\"Should be able to get a class identifier as a string\", () => {\n    class Katana { }\n    const KatanaStr = getServiceIdentifierAsString(Katana);\n    expect(KatanaStr).to.equal(\"Katana\");\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to snapshot and restore container","suites":["Container"],"updatePoint":{"line":285,"column":54},"line":285,"code":"  it(\"Should be able to snapshot and restore container\", () => {\n\n    interface Warrior {\n    }\n\n    @injectable()\n    class Ninja implements Warrior { }\n\n    @injectable()\n    class Samurai implements Warrior { }\n\n    const container = new Container();\n    container.bind<Warrior>(Ninja).to(Ninja);\n    container.bind<Warrior>(Samurai).to(Samurai);\n\n    expect(container.get(Samurai)).to.be.instanceOf(Samurai);\n    expect(container.get(Ninja)).to.be.instanceOf(Ninja);\n\n    container.snapshot(); // snapshot container = v1\n\n    container.unbind(Ninja);\n    expect(container.get(Samurai)).to.be.instanceOf(Samurai);\n    expect(() => container.get(Ninja)).to.throw();\n\n    container.snapshot(); // snapshot container = v2\n    expect(() => container.get(Ninja)).to.throw();\n\n    container.bind<Warrior>(Ninja).to(Ninja);\n    expect(container.get(Samurai)).to.be.instanceOf(Samurai);\n    expect(container.get(Ninja)).to.be.instanceOf(Ninja);\n\n    container.restore(); // restore container to v2\n    expect(container.get(Samurai)).to.be.instanceOf(Samurai);\n    expect(() => container.get(Ninja)).to.throw();\n\n    container.restore(); // restore container to v1\n    expect(container.get(Samurai)).to.be.instanceOf(Samurai);\n    expect(container.get(Ninja)).to.be.instanceOf(Ninja);\n\n    expect(() => container.restore()).to.throw(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should maintain the activation state of a singleton when doing a snapshot of a container","suites":["Container"],"updatePoint":{"line":327,"column":94},"line":327,"code":"  it(\"Should maintain the activation state of a singleton when doing a snapshot of a container\", () => {\n\n    let timesCalled = 0;\n\n    @injectable()\n    class Ninja {\n      @postConstruct()\n      public postConstruct() {\n        timesCalled++;\n      }\n    }\n\n    const container = new Container();\n\n    container.bind<Ninja>(Ninja).to(Ninja).inSingletonScope();\n\n    container.get<Ninja>(Ninja);\n    container.snapshot();\n    container.restore();\n    container.get<Ninja>(Ninja);\n\n    expect(timesCalled).to.be.equal(1);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should save and restore the container activations and deactivations when snapshot and restore","suites":["Container"],"updatePoint":{"line":351,"column":99},"line":351,"code":"  it(\"Should save and restore the container activations and deactivations when snapshot and restore\", () => {\n    const sid = \"sid\";\n    const container = new Container();\n    container.bind<string>(sid).toConstantValue(\"Value\");\n\n    let activated = false;\n    let deactivated = false\n\n    container.snapshot();\n\n    container.onActivation<string>(sid, (c, i) => {\n      activated = true;\n      return i;\n    });\n    container.onDeactivation(sid, i => {\n      deactivated = true;\n    });\n\n    container.restore();\n\n    container.get(sid);\n    container.unbind(sid);\n\n    expect(activated).to.equal(false);\n    expect(deactivated).to.equal(false);\n  })","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should save and restore the module activation store when snapshot and restore","suites":["Container"],"updatePoint":{"line":378,"column":83},"line":378,"code":"  it(\"Should save and restore the module activation store when snapshot and restore\", () => {\n    const container = new Container();\n    const clonedActivationStore = new ModuleActivationStore();\n    const originalActivationStore = {\n      clone() {\n        return clonedActivationStore;\n      }\n    }\n    const anyContainer = container as any;\n    anyContainer._moduleActivationStore = originalActivationStore;\n    container.snapshot();\n    const snapshot: interfaces.ContainerSnapshot = anyContainer._snapshots[0];\n    expect(snapshot.moduleActivationStore === clonedActivationStore).to.equal(true);\n    container.restore();\n    expect(anyContainer._moduleActivationStore === clonedActivationStore).to.equal(true);\n  })","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check is there are bindings available for a given identifier","suites":["Container"],"updatePoint":{"line":395,"column":84},"line":395,"code":"  it(\"Should be able to check is there are bindings available for a given identifier\", () => {\n\n    interface Warrior { }\n    const warriorId = \"Warrior\";\n    const warriorSymbol = Symbol.for(\"Warrior\");\n\n    @injectable()\n    class Ninja implements Warrior { }\n\n    const container = new Container();\n    container.bind<Warrior>(Ninja).to(Ninja);\n    container.bind<Warrior>(warriorId).to(Ninja);\n    container.bind<Warrior>(warriorSymbol).to(Ninja);\n\n    expect(container.isBound(Ninja)).equal(true);\n    expect(container.isBound(warriorId)).equal(true);\n    expect(container.isBound(warriorSymbol)).equal(true);\n\n    interface Katana { }\n    const katanaId = \"Katana\";\n    const katanaSymbol = Symbol.for(\"Katana\");\n\n    @injectable()\n    class Katana implements Katana { }\n\n    expect(container.isBound(Katana)).equal(false);\n    expect(container.isBound(katanaId)).equal(false);\n    expect(container.isBound(katanaSymbol)).equal(false);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check is there are bindings available for a given identifier only in current container","suites":["Container"],"updatePoint":{"line":426,"column":110},"line":426,"code":"  it(\"Should be able to check is there are bindings available for a given identifier only in current container\", () => {\n\n    interface Warrior { }\n\n    @injectable()\n    class Ninja implements Warrior { }\n\n    const containerParent = new Container();\n    const containerChild = new Container();\n\n    containerChild.parent = containerParent;\n\n    containerParent.bind<Warrior>(Ninja).to(Ninja);\n\n    expect(containerParent.isBound(Ninja)).to.eql(true);\n    expect(containerParent.isCurrentBound(Ninja)).to.eql(true);\n    expect(containerChild.isBound(Ninja)).to.eql(true);\n    expect(containerChild.isCurrentBound(Ninja)).to.eql(false);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get services from parent container","suites":["Container"],"updatePoint":{"line":446,"column":58},"line":446,"code":"  it(\"Should be able to get services from parent container\", () => {\n    const weaponIdentifier = \"Weapon\";\n\n    @injectable()\n    class Katana { }\n\n    const container = new Container();\n    container.bind(weaponIdentifier).to(Katana);\n\n    const childContainer = new Container();\n    childContainer.parent = container;\n\n    const secondChildContainer = new Container();\n    secondChildContainer.parent = childContainer;\n\n    expect(secondChildContainer.get(weaponIdentifier)).to.be.instanceOf(Katana);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check if services are bound from parent container","suites":["Container"],"updatePoint":{"line":464,"column":73},"line":464,"code":"  it(\"Should be able to check if services are bound from parent container\", () => {\n    const weaponIdentifier = \"Weapon\";\n\n    @injectable()\n    class Katana { }\n\n    const container = new Container();\n    container.bind(weaponIdentifier).to(Katana);\n\n    const childContainer = new Container();\n    childContainer.parent = container;\n\n    const secondChildContainer = new Container();\n    secondChildContainer.parent = childContainer;\n\n    expect(secondChildContainer.isBound(weaponIdentifier)).to.be.equal(true);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should prioritize requested container to resolve a service identifier","suites":["Container"],"updatePoint":{"line":482,"column":75},"line":482,"code":"  it(\"Should prioritize requested container to resolve a service identifier\", () => {\n    const weaponIdentifier = \"Weapon\";\n\n    @injectable()\n    class Katana { }\n\n    @injectable()\n    class DivineRapier { }\n\n    const container = new Container();\n    container.bind(weaponIdentifier).to(Katana);\n\n    const childContainer = new Container();\n    childContainer.parent = container;\n\n    const secondChildContainer = new Container();\n    secondChildContainer.parent = childContainer;\n    secondChildContainer.bind(weaponIdentifier).to(DivineRapier);\n\n    expect(secondChildContainer.get(weaponIdentifier)).to.be.instanceOf(DivineRapier);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve named multi-injection","suites":["Container"],"updatePoint":{"line":504,"column":53},"line":504,"code":"  it(\"Should be able to resolve named multi-injection\", () => {\n\n    interface Intl {\n      hello?: string;\n      goodbye?: string;\n    }\n\n    const container = new Container();\n    container.bind<Intl>(\"Intl\").toConstantValue({ hello: \"bonjour\" }).whenTargetNamed(\"fr\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ goodbye: \"au revoir\" }).whenTargetNamed(\"fr\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ hello: \"hola\" }).whenTargetNamed(\"es\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ goodbye: \"adios\" }).whenTargetNamed(\"es\");\n\n    const fr = container.getAllNamed<Intl>(\"Intl\", \"fr\");\n    expect(fr.length).to.equal(2);\n    expect(fr[0]?.hello).to.equal(\"bonjour\");\n    expect(fr[1]?.goodbye).to.equal(\"au revoir\");\n\n    const es = container.getAllNamed<Intl>(\"Intl\", \"es\");\n    expect(es.length).to.equal(2);\n    expect(es[0]?.hello).to.equal(\"hola\");\n    expect(es[1]?.goodbye).to.equal(\"adios\");\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve tagged multi-injection","suites":["Container"],"updatePoint":{"line":529,"column":54},"line":529,"code":"  it(\"Should be able to resolve tagged multi-injection\", () => {\n\n    interface Intl {\n      hello?: string;\n      goodbye?: string;\n    }\n\n    const container = new Container();\n    container.bind<Intl>(\"Intl\").toConstantValue({ hello: \"bonjour\" }).whenTargetTagged(\"lang\", \"fr\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ goodbye: \"au revoir\" }).whenTargetTagged(\"lang\", \"fr\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ hello: \"hola\" }).whenTargetTagged(\"lang\", \"es\");\n    container.bind<Intl>(\"Intl\").toConstantValue({ goodbye: \"adios\" }).whenTargetTagged(\"lang\", \"es\");\n\n    const fr = container.getAllTagged<Intl>(\"Intl\", \"lang\", \"fr\");\n    expect(fr.length).to.equal(2);\n    expect(fr[0]?.hello).to.equal(\"bonjour\");\n    expect(fr[1]?.goodbye).to.equal(\"au revoir\");\n\n    const es = container.getAllTagged<Intl>(\"Intl\", \"lang\", \"es\");\n    expect(es.length).to.equal(2);\n    expect(es[0]?.hello).to.equal(\"hola\");\n    expect(es[1]?.goodbye).to.equal(\"adios\");\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able configure the default scope at a global level","suites":["Container"],"updatePoint":{"line":554,"column":66},"line":554,"code":"  it(\"Should be able configure the default scope at a global level\", () => {\n\n    interface Warrior {\n      health: number;\n      takeHit(damage: number): void;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public health: number;\n      public constructor() {\n        this.health = 100;\n      }\n      public takeHit(damage: number) {\n        this.health = this.health - damage;\n      }\n    }\n\n    const TYPES = {\n      Warrior: \"Warrior\"\n    };\n\n    const container1 = new Container();\n    container1.bind<Warrior>(TYPES.Warrior).to(Ninja);\n\n    const transientNinja1 = container1.get<Warrior>(TYPES.Warrior);\n    expect(transientNinja1.health).to.equal(100);\n    transientNinja1.takeHit(10);\n    expect(transientNinja1.health).to.equal(90);\n\n    const transientNinja2 = container1.get<Warrior>(TYPES.Warrior);\n    expect(transientNinja2.health).to.equal(100);\n    transientNinja2.takeHit(10);\n    expect(transientNinja2.health).to.equal(90);\n\n    const container2 = new Container({ defaultScope: BindingScopeEnum.Singleton });\n    container2.bind<Warrior>(TYPES.Warrior).to(Ninja);\n\n    const singletonNinja1 = container2.get<Warrior>(TYPES.Warrior);\n    expect(singletonNinja1.health).to.equal(100);\n    singletonNinja1.takeHit(10);\n    expect(singletonNinja1.health).to.equal(90);\n\n    const singletonNinja2 = container2.get<Warrior>(TYPES.Warrior);\n    expect(singletonNinja2.health).to.equal(90);\n    singletonNinja2.takeHit(10);\n    expect(singletonNinja2.health).to.equal(80);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should default binding scope to Transient if no default scope on options","suites":["Container"],"updatePoint":{"line":604,"column":78},"line":604,"code":"  it(\"Should default binding scope to Transient if no default scope on options\", () => {\n    const container = new Container();\n    container.options.defaultScope = undefined;\n    const expectedScope: interfaces.BindingScope = \"Transient\";\n    expect((container.bind(\"SID\") as any)._binding.scope).to.equal(expectedScope);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to configure automatic binding for @injectable() decorated classes","suites":["Container"],"updatePoint":{"line":610,"column":87},"line":610,"code":"  it(\"Should be able to configure automatic binding for @injectable() decorated classes\", () => {\n\n    @injectable()\n    class Katana { }\n\n    @injectable()\n    class Shuriken { }\n\n    @injectable()\n    class Ninja {\n      public constructor(public weapon: Katana) { }\n    }\n\n    class Samurai { }\n\n    const container1 = new Container({ autoBindInjectable: true });\n    const katana1 = container1.get(Katana);\n    const ninja1 = container1.get(Ninja);\n    expect(katana1).to.be.an.instanceof(Katana);\n    expect(katana1).to.not.equal(container1.get(Katana));\n    expect(ninja1).to.be.an.instanceof(Ninja);\n    expect(ninja1).to.not.equal(container1.get(Ninja));\n    expect(ninja1.weapon).to.be.an.instanceof(Katana);\n    expect(ninja1.weapon).to.not.equal(container1.get(Ninja).weapon);\n    expect(ninja1.weapon).to.not.equal(katana1);\n\n    const container2 = new Container({ defaultScope: BindingScopeEnum.Singleton, autoBindInjectable: true });\n    const katana2 = container2.get(Katana);\n    const ninja2 = container2.get(Ninja);\n    expect(katana2).to.be.an.instanceof(Katana);\n    expect(katana2).to.equal(container2.get(Katana));\n    expect(ninja2).to.be.an.instanceof(Ninja);\n    expect(ninja2).to.equal(container2.get(Ninja));\n    expect(ninja2.weapon).to.be.an.instanceof(Katana);\n    expect(ninja2.weapon).to.equal(container2.get(Ninja).weapon);\n    expect(ninja2.weapon).to.equal(katana2);\n\n    const container3 = new Container({ autoBindInjectable: true });\n    container3.bind(Katana).toSelf().inSingletonScope();\n    const katana3 = container3.get(Katana);\n    const ninja3 = container3.get(Ninja);\n    expect(katana3).to.be.an.instanceof(Katana);\n    expect(katana3).to.equal(container3.get(Katana));\n    expect(ninja3).to.be.an.instanceof(Ninja);\n    expect(ninja3).to.not.equal(container3.get(Ninja));\n    expect(ninja3.weapon).to.be.an.instanceof(Katana);\n    expect(ninja3.weapon).to.equal(container3.get(Ninja).weapon);\n    expect(ninja3.weapon).to.equal(katana3);\n\n    const container4 = new Container({ autoBindInjectable: true });\n    container4.bind(Katana).to(Shuriken);\n    const katana4 = container4.get(Katana);\n    const ninja4 = container4.get(Ninja);\n    expect(katana4).to.be.an.instanceof(Shuriken);\n    expect(katana4).to.not.equal(container4.get(Katana));\n    expect(ninja4).to.be.an.instanceof(Ninja);\n    expect(ninja4).to.not.equal(container4.get(Ninja));\n    expect(ninja4.weapon).to.be.an.instanceof(Shuriken);\n    expect(ninja4.weapon).to.not.equal(container4.get(Ninja).weapon);\n    expect(ninja4.weapon).to.not.equal(katana4);\n\n    const container5 = new Container({ autoBindInjectable: true });\n    expect(() => container5.get(Samurai)).to.throw(ERROR_MSGS.NOT_REGISTERED);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be throw an exception if incorrect options is provided","suites":["Container"],"updatePoint":{"line":676,"column":67},"line":676,"code":"  it(\"Should be throw an exception if incorrect options is provided\", () => {\n\n    const invalidOptions1: any = () => 0;\n    const wrong1 = () => new Container(invalidOptions1);\n    expect(wrong1).to.throw(`${ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT}`);\n\n    const invalidOptions2: any = { autoBindInjectable: \"wrongValue\" };\n    const wrong2 = () => new Container(invalidOptions2);\n    expect(wrong2).to.throw(`${ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE}`);\n\n    const invalidOptions3: any = { defaultScope: \"wrongValue\" };\n    const wrong3 = () => new Container(invalidOptions3);\n    expect(wrong3).to.throw(`${ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE}`);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to merge two containers","suites":["Container"],"updatePoint":{"line":692,"column":44},"line":692,"code":"  it(\"Should be able to merge two containers\", () => {\n\n    @injectable()\n    class Ninja {\n      public name = \"Ninja\";\n    }\n\n    @injectable()\n    class Shuriken {\n      public name = \"Shuriken\";\n    }\n\n    const CHINA_EXPANSION_TYPES = {\n      Ninja: \"Ninja\",\n      Shuriken: \"Shuriken\"\n    };\n\n    const chinaExpansionContainer = new Container();\n    chinaExpansionContainer.bind<Ninja>(CHINA_EXPANSION_TYPES.Ninja).to(Ninja);\n    chinaExpansionContainer.bind<Shuriken>(CHINA_EXPANSION_TYPES.Shuriken).to(Shuriken);\n\n    @injectable()\n    class Samurai {\n      public name = \"Samurai\";\n    }\n\n    @injectable()\n    class Katana {\n      public name = \"Katana\";\n    }\n\n    const JAPAN_EXPANSION_TYPES = {\n      Katana: \"Katana\",\n      Samurai: \"Samurai\"\n    };\n\n    const japanExpansionContainer = new Container();\n    japanExpansionContainer.bind<Samurai>(JAPAN_EXPANSION_TYPES.Samurai).to(Samurai);\n    japanExpansionContainer.bind<Katana>(JAPAN_EXPANSION_TYPES.Katana).to(Katana);\n\n    const gameContainer = Container.merge(chinaExpansionContainer, japanExpansionContainer);\n    expect(gameContainer.get<Ninja>(CHINA_EXPANSION_TYPES.Ninja).name).to.equal(\"Ninja\");\n    expect(gameContainer.get<Shuriken>(CHINA_EXPANSION_TYPES.Shuriken).name).to.equal(\"Shuriken\");\n    expect(gameContainer.get<Samurai>(JAPAN_EXPANSION_TYPES.Samurai).name).to.equal(\"Samurai\");\n    expect(gameContainer.get<Katana>(JAPAN_EXPANSION_TYPES.Katana).name).to.equal(\"Katana\");\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to merge multiple containers","suites":["Container"],"updatePoint":{"line":740,"column":49},"line":740,"code":"  it(\"Should be able to merge multiple containers\", () => {\n    @injectable()\n    class Ninja {\n      public name = \"Ninja\";\n    }\n\n    @injectable()\n    class Shuriken {\n      public name = \"Shuriken\";\n    }\n\n    const CHINA_EXPANSION_TYPES = {\n      Ninja: \"Ninja\",\n      Shuriken: \"Shuriken\"\n    };\n\n    const chinaExpansionContainer = new Container();\n    chinaExpansionContainer.bind<Ninja>(CHINA_EXPANSION_TYPES.Ninja).to(Ninja);\n    chinaExpansionContainer.bind<Shuriken>(CHINA_EXPANSION_TYPES.Shuriken).to(Shuriken);\n\n    @injectable()\n    class Samurai {\n      public name = \"Samurai\";\n    }\n\n    @injectable()\n    class Katana {\n      public name = \"Katana\";\n    }\n\n    const JAPAN_EXPANSION_TYPES = {\n      Katana: \"Katana\",\n      Samurai: \"Samurai\"\n    };\n\n    const japanExpansionContainer = new Container();\n    japanExpansionContainer.bind<Samurai>(JAPAN_EXPANSION_TYPES.Samurai).to(Samurai);\n    japanExpansionContainer.bind<Katana>(JAPAN_EXPANSION_TYPES.Katana).to(Katana);\n\n    @injectable()\n    class Sheriff {\n      public name = \"Sheriff\";\n    }\n\n    @injectable()\n    class Revolver {\n      public name = \"Revolver\";\n    }\n\n    const USA_EXPANSION_TYPES = {\n      Revolver: \"Revolver\",\n      Sheriff: \"Sheriff\"\n    };\n\n    const usaExpansionContainer = new Container();\n    usaExpansionContainer.bind<Sheriff>(USA_EXPANSION_TYPES.Sheriff).to(Sheriff);\n    usaExpansionContainer.bind<Revolver>(USA_EXPANSION_TYPES.Revolver).to(Revolver);\n\n    const gameContainer = Container.merge(chinaExpansionContainer, japanExpansionContainer, usaExpansionContainer);\n    expect(gameContainer.get<Ninja>(CHINA_EXPANSION_TYPES.Ninja).name).to.equal(\"Ninja\");\n    expect(gameContainer.get<Shuriken>(CHINA_EXPANSION_TYPES.Shuriken).name).to.equal(\"Shuriken\");\n    expect(gameContainer.get<Samurai>(JAPAN_EXPANSION_TYPES.Samurai).name).to.equal(\"Samurai\");\n    expect(gameContainer.get<Katana>(JAPAN_EXPANSION_TYPES.Katana).name).to.equal(\"Katana\");\n    expect(gameContainer.get<Sheriff>(USA_EXPANSION_TYPES.Sheriff).name).to.equal(\"Sheriff\");\n    expect(gameContainer.get<Revolver>(USA_EXPANSION_TYPES.Revolver).name).to.equal(\"Revolver\");\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able create a child containers","suites":["Container"],"updatePoint":{"line":807,"column":46},"line":807,"code":"  it(\"Should be able create a child containers\", () => {\n    const parent = new Container();\n    const child = parent.createChild();\n    if (child.parent === null) {\n      throw new Error(\"Parent should not be null\");\n    }\n    expect(child.parent.id).to.equal(parent.id);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should inherit parent container options","suites":["Container"],"updatePoint":{"line":816,"column":45},"line":816,"code":"  it(\"Should inherit parent container options\", () => {\n    @injectable()\n    class Warrior { }\n\n    const parent = new Container({\n      defaultScope: BindingScopeEnum.Singleton\n    });\n\n    const child = parent.createChild();\n    child.bind(Warrior).toSelf();\n\n    const singletonWarrior1 = child.get(Warrior);\n    const singletonWarrior2 = child.get(Warrior);\n    expect(singletonWarrior1).to.equal(singletonWarrior2);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to override options to child containers","suites":["Container"],"updatePoint":{"line":832,"column":60},"line":832,"code":"  it(\"Should be able to override options to child containers\", () => {\n    @injectable()\n    class Warrior { }\n\n    const parent = new Container({\n      defaultScope: BindingScopeEnum.Request\n    });\n\n    const child = parent.createChild({\n      defaultScope: BindingScopeEnum.Singleton\n    });\n    child.bind(Warrior).toSelf();\n\n    const singletonWarrior1 = child.get(Warrior);\n    const singletonWarrior2 = child.get(Warrior);\n    expect(singletonWarrior1).to.equal(singletonWarrior2);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able check if a named binding is bound","suites":["Container"],"updatePoint":{"line":850,"column":54},"line":850,"code":"  it(\"Should be able check if a named binding is bound\", () => {\n\n    const zero = \"Zero\";\n    const invalidDivisor = \"InvalidDivisor\";\n    const validDivisor = \"ValidDivisor\";\n    const container = new Container();\n\n    expect(container.isBound(zero)).to.equal(false);\n    container.bind<number>(zero).toConstantValue(0);\n    expect(container.isBound(zero)).to.equal(true);\n\n    container.unbindAll();\n    expect(container.isBound(zero)).to.equal(false);\n    container.bind<number>(zero).toConstantValue(0).whenTargetNamed(invalidDivisor);\n    expect(container.isBoundNamed(zero, invalidDivisor)).to.equal(true);\n    expect(container.isBoundNamed(zero, validDivisor)).to.equal(false);\n\n    container.bind<number>(zero).toConstantValue(1).whenTargetNamed(validDivisor);\n    expect(container.isBoundNamed(zero, invalidDivisor)).to.equal(true);\n    expect(container.isBoundNamed(zero, validDivisor)).to.equal(true);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check if a named binding is bound from parent container","suites":["Container"],"updatePoint":{"line":873,"column":79},"line":873,"code":"  it(\"Should be able to check if a named binding is bound from parent container\", () => {\n\n    const zero = \"Zero\";\n    const invalidDivisor = \"InvalidDivisor\";\n    const validDivisor = \"ValidDivisor\";\n    const container = new Container();\n    const childContainer = container.createChild();\n    const secondChildContainer = childContainer.createChild();\n\n    container.bind<number>(zero).toConstantValue(0).whenTargetNamed(invalidDivisor);\n    expect(secondChildContainer.isBoundNamed(zero, invalidDivisor)).to.equal(true);\n    expect(secondChildContainer.isBoundNamed(zero, validDivisor)).to.equal(false);\n\n    container.bind<number>(zero).toConstantValue(1).whenTargetNamed(validDivisor);\n    expect(secondChildContainer.isBoundNamed(zero, invalidDivisor)).to.equal(true);\n    expect(secondChildContainer.isBoundNamed(zero, validDivisor)).to.equal(true);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a tagged binding","suites":["Container"],"updatePoint":{"line":892,"column":44},"line":892,"code":"  it(\"Should be able to get a tagged binding\", () => {\n\n    const zero = \"Zero\";\n    const isValidDivisor = \"IsValidDivisor\";\n    const container = new Container();\n\n    container.bind<number>(zero).toConstantValue(0).whenTargetTagged(isValidDivisor, false);\n    expect(container.getTagged(zero, isValidDivisor, false)).to.equal(0);\n\n    container.bind<number>(zero).toConstantValue(1).whenTargetTagged(isValidDivisor, true);\n    expect(container.getTagged(zero, isValidDivisor, false)).to.equal(0);\n    expect(container.getTagged(zero, isValidDivisor, true)).to.equal(1);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a tagged binding from parent container","suites":["Container"],"updatePoint":{"line":907,"column":66},"line":907,"code":"  it(\"Should be able to get a tagged binding from parent container\", () => {\n\n    const zero = \"Zero\";\n    const isValidDivisor = \"IsValidDivisor\";\n    const container = new Container();\n    const childContainer = container.createChild();\n    const secondChildContainer = childContainer.createChild();\n\n    container.bind<number>(zero).toConstantValue(0).whenTargetTagged(isValidDivisor, false);\n    container.bind<number>(zero).toConstantValue(1).whenTargetTagged(isValidDivisor, true);\n    expect(secondChildContainer.getTagged(zero, isValidDivisor, false)).to.equal(0);\n    expect(secondChildContainer.getTagged(zero, isValidDivisor, true)).to.equal(1);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able check if a tagged binding is bound","suites":["Container"],"updatePoint":{"line":922,"column":55},"line":922,"code":"  it(\"Should be able check if a tagged binding is bound\", () => {\n\n    const zero = \"Zero\";\n    const isValidDivisor = \"IsValidDivisor\";\n    const container = new Container();\n\n    expect(container.isBound(zero)).to.equal(false);\n    container.bind<number>(zero).toConstantValue(0);\n    expect(container.isBound(zero)).to.equal(true);\n\n    container.unbindAll();\n    expect(container.isBound(zero)).to.equal(false);\n    container.bind<number>(zero).toConstantValue(0).whenTargetTagged(isValidDivisor, false);\n    expect(container.isBoundTagged(zero, isValidDivisor, false)).to.equal(true);\n    expect(container.isBoundTagged(zero, isValidDivisor, true)).to.equal(false);\n\n    container.bind<number>(zero).toConstantValue(1).whenTargetTagged(isValidDivisor, true);\n    expect(container.isBoundTagged(zero, isValidDivisor, false)).to.equal(true);\n    expect(container.isBoundTagged(zero, isValidDivisor, true)).to.equal(true);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to check if a tagged binding is bound from parent container","suites":["Container"],"updatePoint":{"line":944,"column":80},"line":944,"code":"  it(\"Should be able to check if a tagged binding is bound from parent container\", () => {\n\n    const zero = \"Zero\";\n    const isValidDivisor = \"IsValidDivisor\";\n    const container = new Container();\n    const childContainer = container.createChild();\n    const secondChildContainer = childContainer.createChild();\n\n    container.bind<number>(zero).toConstantValue(0).whenTargetTagged(isValidDivisor, false);\n    expect(secondChildContainer.isBoundTagged(zero, isValidDivisor, false)).to.equal(true);\n    expect(secondChildContainer.isBoundTagged(zero, isValidDivisor, true)).to.equal(false);\n\n    container.bind<number>(zero).toConstantValue(1).whenTargetTagged(isValidDivisor, true);\n    expect(secondChildContainer.isBoundTagged(zero, isValidDivisor, false)).to.equal(true);\n    expect(secondChildContainer.isBoundTagged(zero, isValidDivisor, true)).to.equal(true);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to override a binding using rebind","suites":["Container"],"updatePoint":{"line":962,"column":55},"line":962,"code":"  it(\"Should be able to override a binding using rebind\", () => {\n\n    const TYPES = {\n      someType: \"someType\"\n    };\n\n    const container = new Container();\n    container.bind<number>(TYPES.someType).toConstantValue(1);\n    container.bind<number>(TYPES.someType).toConstantValue(2);\n\n    const values1 = container.getAll(TYPES.someType);\n    expect(values1[0]).to.eq(1);\n    expect(values1[1]).to.eq(2);\n\n    container.rebind<number>(TYPES.someType).toConstantValue(3);\n    const values2 = container.getAll(TYPES.someType);\n    expect(values2[0]).to.eq(3);\n    expect(values2[1]).to.eq(undefined);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to override a binding using rebindAsync","suites":["Container"],"updatePoint":{"line":983,"column":60},"line":983,"code":"  it(\"Should be able to override a binding using rebindAsync\", async () => {\n\n    const TYPES = {\n      someType: \"someType\"\n    };\n\n    const container = new Container();\n    container.bind<number>(TYPES.someType).toConstantValue(1);\n    container.bind<number>(TYPES.someType).toConstantValue(2);\n    container.onDeactivation(TYPES.someType, () => Promise.resolve())\n\n    const values1 = container.getAll(TYPES.someType);\n    expect(values1[0]).to.eq(1);\n    expect(values1[1]).to.eq(2);\n\n    (await container.rebindAsync<number>(TYPES.someType)).toConstantValue(3);\n    const values2 = container.getAll(TYPES.someType);\n    expect(values2[0]).to.eq(3);\n    expect(values2[1]).to.eq(undefined);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve named multi-injection (async)","suites":["Container"],"updatePoint":{"line":1005,"column":61},"line":1005,"code":"  it(\"Should be able to resolve named multi-injection (async)\", async () => {\n\n    interface Intl {\n      hello?: string;\n      goodbye?: string;\n    }\n\n    const container = new Container();\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"bonjour\" })).whenTargetNamed(\"fr\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ goodbye: \"au revoir\" })).whenTargetNamed(\"fr\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"hola\" })).whenTargetNamed(\"es\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ goodbye: \"adios\" })).whenTargetNamed(\"es\");\n\n    const fr = await container.getAllNamedAsync<Intl>(\"Intl\", \"fr\");\n    expect(fr.length).to.equal(2);\n    expect(fr[0]?.hello).to.equal(\"bonjour\");\n    expect(fr[1]?.goodbye).to.equal(\"au revoir\");\n\n    const es = await container.getAllNamedAsync<Intl>(\"Intl\", \"es\");\n    expect(es.length).to.equal(2);\n    expect(es[0]?.hello).to.equal(\"hola\");\n    expect(es[1]?.goodbye).to.equal(\"adios\");\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve named (async)","suites":["Container"],"updatePoint":{"line":1030,"column":45},"line":1030,"code":"  it(\"Should be able to resolve named (async)\", async () => {\n    interface Intl {\n      hello?: string;\n      goodbye?: string;\n    }\n\n    const container = new Container();\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"bonjour\" })).whenTargetNamed(\"fr\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"hola\" })).whenTargetNamed(\"es\");\n\n    const fr = await container.getNamedAsync<Intl>(\"Intl\", \"fr\");\n    expect(fr.hello).to.equal(\"bonjour\");\n\n    const es = await container.getNamedAsync<Intl>(\"Intl\", \"es\");\n    expect(es.hello).to.equal(\"hola\");\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve tagged multi-injection (async)","suites":["Container"],"updatePoint":{"line":1047,"column":62},"line":1047,"code":"  it(\"Should be able to resolve tagged multi-injection (async)\", async () => {\n\n    interface Intl {\n      hello?: string;\n      goodbye?: string;\n    }\n\n    const container = new Container();\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"bonjour\" })).whenTargetTagged(\"lang\", \"fr\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ goodbye: \"au revoir\" })).whenTargetTagged(\"lang\", \"fr\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ hello: \"hola\" })).whenTargetTagged(\"lang\", \"es\");\n    container.bind<Intl>(\"Intl\").toDynamicValue(() => Promise.resolve({ goodbye: \"adios\" })).whenTargetTagged(\"lang\", \"es\");\n\n    const fr = await container.getAllTaggedAsync<Intl>(\"Intl\", \"lang\", \"fr\");\n    expect(fr.length).to.equal(2);\n    expect(fr[0]?.hello).to.equal(\"bonjour\");\n    expect(fr[1]?.goodbye).to.equal(\"au revoir\");\n\n    const es = await container.getAllTaggedAsync<Intl>(\"Intl\", \"lang\", \"es\");\n    expect(es.length).to.equal(2);\n    expect(es[0]?.hello).to.equal(\"hola\");\n    expect(es[1]?.goodbye).to.equal(\"adios\");\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to get a tagged binding (async)","suites":["Container"],"updatePoint":{"line":1072,"column":52},"line":1072,"code":"  it(\"Should be able to get a tagged binding (async)\", async () => {\n\n    const zero = \"Zero\";\n    const isValidDivisor = \"IsValidDivisor\";\n    const container = new Container();\n\n    container.bind<number>(zero).toDynamicValue(() => Promise.resolve(0)).whenTargetTagged(isValidDivisor, false);\n    expect(await container.getTaggedAsync(zero, isValidDivisor, false)).to.equal(0);\n\n    container.bind<number>(zero).toDynamicValue(() => Promise.resolve(1)).whenTargetTagged(isValidDivisor, true);\n    expect(await container.getTaggedAsync(zero, isValidDivisor, false)).to.equal(0);\n    expect(await container.getTaggedAsync(zero, isValidDivisor, true)).to.equal(1);\n\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"should be able to get all the services binded (async)","suites":["Container"],"updatePoint":{"line":1087,"column":59},"line":1087,"code":"  it(\"should be able to get all the services binded (async)\", async () => {\n    const serviceIdentifier = \"service-identifier\";\n\n    const container = new Container();\n\n    const firstValueBinded = \"value-one\";\n    const secondValueBinded = \"value-two\";\n    const thirdValueBinded = \"value-three\";\n\n    container.bind(serviceIdentifier).toConstantValue(firstValueBinded);\n    container.bind(serviceIdentifier).toConstantValue(secondValueBinded);\n    container.bind(serviceIdentifier).toDynamicValue(_ => Promise.resolve(thirdValueBinded));\n    const services = await container.getAllAsync<string>(serviceIdentifier);\n\n    expect(services).to.deep.eq([firstValueBinded, secondValueBinded, thirdValueBinded]);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"should throw an error if skipBaseClassChecks is not a boolean","suites":["Container"],"updatePoint":{"line":1104,"column":67},"line":1104,"code":"  it('should throw an error if skipBaseClassChecks is not a boolean', () => {\n    expect(() =>\n      new Container({\n        skipBaseClassChecks: 'Jolene, Jolene, Jolene, Jolene' as unknown as boolean\n      })\n    ).to.throw(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject when symbol property key ","suites":["Container"],"updatePoint":{"line":1112,"column":56},"line":1112,"code":"  it(\"Should be able to inject when symbol property key \", () => {\n    const weaponProperty = Symbol();\n    interface Weapon { }\n    @injectable()\n    class Shuriken implements Weapon { }\n    @injectable()\n    class Ninja {\n      @inject(\"Weapon\")\n      [weaponProperty]: Weapon\n    }\n    const container = new Container();\n    container.bind(\"Weapon\").to(Shuriken);\n    const myNinja = container.resolve(Ninja);\n    const weapon = myNinja[weaponProperty];\n    expect(weapon).to.be.instanceOf(Shuriken);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should be possible to constrain to a symbol description","suites":["Container"],"updatePoint":{"line":1129,"column":61},"line":1129,"code":"  it(\"Should be possible to constrain to a symbol description\", () => {\n    const throwableWeapon = Symbol(\"throwable\");\n    interface Weapon { }\n    @injectable()\n    class Shuriken implements Weapon { }\n    @injectable()\n    class Ninja {\n      @inject(\"Weapon\")\n      [throwableWeapon]: Weapon\n    }\n    const container = new Container();\n    container.bind(\"Weapon\").to(Shuriken).when(request => {\n      return request.target.name.equals(\"throwable\");\n    })\n    const myNinja = container.resolve(Ninja);\n    const weapon = myNinja[throwableWeapon];\n    expect(weapon).to.be.instanceOf(Shuriken);\n  });","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"container resolve should come from the same container","suites":["Container"],"updatePoint":{"line":1148,"column":59},"line":1148,"code":"  it(\"container resolve should come from the same container\", () => {\n    @injectable()\n    class CompositionRoot { }\n    class DerivedContainer extends Container {\n      public planningForCompositionRoot(): void {\n        //\n      }\n    }\n    const middleware: interfaces.Middleware = (next) =>\n      (nextArgs) => {\n        const contextInterceptor = nextArgs.contextInterceptor;\n        nextArgs.contextInterceptor = context => {\n          if (context.plan.rootRequest.serviceIdentifier === CompositionRoot) {\n            (context.container as DerivedContainer).planningForCompositionRoot();\n          }\n          return contextInterceptor(context);\n        }\n        return next(nextArgs)\n      }\n\n    const myContainer = new DerivedContainer();\n    myContainer.applyMiddleware(middleware);\n    myContainer.resolve(CompositionRoot);\n    // tslint:disable-next-line: no-unused-expression\n    expect(() => myContainer.resolve(CompositionRoot)).not.to.throw;\n  })","file":"container/container.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when invoking get, remove or hasKey with a null key","suites":["Lookup"],"updatePoint":{"line":23,"column":70},"line":23,"code":"  it(\"Should throw when invoking get, remove or hasKey with a null key\", () => {\n    const lookup = new Lookup<unknown>();\n    expect(() => { lookup.get(invalid); }).to.throw(ERROR_MSGS.NULL_ARGUMENT);\n    expect(() => { lookup.remove(invalid); }).to.throw(ERROR_MSGS.NULL_ARGUMENT);\n    expect(() => { lookup.hasKey(invalid); }).to.throw(ERROR_MSGS.NULL_ARGUMENT);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when attempting to add a null key","suites":["Lookup"],"updatePoint":{"line":30,"column":52},"line":30,"code":"  it(\"Should throw when attempting to add a null key\", () => {\n    const lookup = new Lookup<unknown>();\n    expect(() => { lookup.add(invalid, new ClonableValue<number>(1)); }).to.throw(ERROR_MSGS.NULL_ARGUMENT);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when attempting to add a null value","suites":["Lookup"],"updatePoint":{"line":35,"column":54},"line":35,"code":"  it(\"Should throw when attempting to add a null value\", () => {\n    const lookup = new Lookup<unknown>();\n    expect(() => { lookup.add(\"TEST_KEY\", null); }).to.throw(ERROR_MSGS.NULL_ARGUMENT);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to link multiple values to a string key","suites":["Lookup"],"updatePoint":{"line":40,"column":60},"line":40,"code":"  it(\"Should be able to link multiple values to a string key\", () => {\n    const lookup = new Lookup<unknown>();\n    const key = \"TEST_KEY\";\n    lookup.add(key, new ClonableValue<number>(1));\n    lookup.add(key, new ClonableValue<number>(2));\n    const result = lookup.get(key);\n    expect(result.length).to.eql(2);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to link multiple values a symbol key","suites":["Lookup"],"updatePoint":{"line":49,"column":57},"line":49,"code":"  it(\"Should be able to link multiple values a symbol key\", () => {\n    const lookup = new Lookup<unknown>();\n    const key = Symbol.for(\"TEST_KEY\");\n    lookup.add(key, new ClonableValue<number>(1));\n    lookup.add(key, new ClonableValue<number>(2));\n    const result = lookup.get(key);\n    expect(result.length).to.eql(2);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should throws when key not found","suites":["Lookup"],"updatePoint":{"line":58,"column":38},"line":58,"code":"  it(\"Should throws when key not found\", () => {\n    const lookup = new Lookup<unknown>();\n    expect(() => { lookup.get(\"THIS_KEY_IS_NOT_AVAILABLE\"); }).to.throw(ERROR_MSGS.KEY_NOT_FOUND);\n    expect(() => { lookup.remove(\"THIS_KEY_IS_NOT_AVAILABLE\"); }).to.throw(ERROR_MSGS.KEY_NOT_FOUND);\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should be clonable","suites":["Lookup"],"updatePoint":{"line":64,"column":24},"line":64,"code":"  it(\"Should be clonable\", () => {\n\n    const lookup = new Lookup<interfaces.Clonable<unknown>>();\n    const key1 = Symbol.for(\"TEST_KEY\");\n\n    class Warrior {\n      public kind: string;\n      public constructor(kind: string) {\n        this.kind = kind;\n      }\n      public clone() {\n        return new Warrior(this.kind);\n      }\n    }\n\n    lookup.add(key1, new Warrior(\"ninja\"));\n    lookup.add(key1, new Warrior(\"samurai\"));\n\n    const copy = lookup.clone();\n    expect(copy.hasKey(key1)).to.eql(true);\n\n    lookup.remove(key1);\n    expect(copy.hasKey(key1)).to.eql(true);\n\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should use use the original non clonable entry if it is not clonable","suites":["Lookup"],"updatePoint":{"line":90,"column":74},"line":90,"code":"  it(\"Should use use the original non clonable entry if it is not clonable\", () => {\n    const lookup = new Lookup<unknown>();\n    const key1 = Symbol.for(\"TEST_KEY\");\n\n    class Warrior {\n      public kind: string;\n      public constructor(kind: string) {\n        this.kind = kind;\n      }\n    }\n    const warrior = new Warrior(\"ninja\")\n    lookup.add(key1, warrior);\n\n    const copy = lookup.clone();\n    expect(copy.get(key1)[0] === warrior).to.eql(true);\n\n  })","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to remove a binding by a condition","suites":["Lookup"],"updatePoint":{"line":108,"column":55},"line":108,"code":"  it(\"Should be able to remove a binding by a condition\", () => {\n\n    const moduleId1 = 1;\n    const moduleId2 = 2;\n    const warriorId = \"Warrior\";\n    const weaponId = \"Weapon\";\n\n    const getLookup = () => {\n\n      interface Warrior { }\n\n      class Ninja implements Warrior { }\n      const ninjaBinding = new Binding(warriorId, BindingScopeEnum.Transient);\n      ninjaBinding.implementationType = Ninja;\n      ninjaBinding.moduleId = moduleId1;\n\n      class Samurai implements Warrior { }\n      const samuraiBinding = new Binding(warriorId, BindingScopeEnum.Transient);\n      samuraiBinding.implementationType = Samurai;\n      samuraiBinding.moduleId = moduleId2;\n\n      interface Weapon { }\n\n      class Shuriken implements Weapon { }\n      const shurikenBinding = new Binding(weaponId, BindingScopeEnum.Transient);\n      shurikenBinding.implementationType = Shuriken;\n      shurikenBinding.moduleId = moduleId1;\n\n      class Katana implements Weapon { }\n      const katanaBinding = new Binding(weaponId, BindingScopeEnum.Transient);\n      katanaBinding.implementationType = Katana;\n      katanaBinding.moduleId = moduleId2;\n\n      const lookup = new Lookup<Binding<unknown>>();\n      lookup.add(warriorId, ninjaBinding);\n      lookup.add(warriorId, samuraiBinding);\n      lookup.add(weaponId, shurikenBinding);\n      lookup.add(weaponId, katanaBinding);\n\n      return lookup;\n\n    };\n\n    const removeByModule = (expected: unknown) => (item: interfaces.Binding<unknown>): boolean =>\n      item.moduleId === expected;\n\n    const lookup1 = getLookup();\n    expect(lookup1.hasKey(warriorId)).to.eql(true);\n    expect(lookup1.hasKey(weaponId)).to.eql(true);\n    expect(lookup1.get(warriorId).length).to.eql(2);\n    expect(lookup1.get(weaponId).length).to.eql(2);\n\n    const removeByModule1 = removeByModule(moduleId1);\n    lookup1.removeByCondition(removeByModule1);\n    expect(lookup1.hasKey(warriorId)).to.eql(true);\n    expect(lookup1.hasKey(weaponId)).to.eql(true);\n    expect(lookup1.get(warriorId).length).to.eql(1);\n    expect(lookup1.get(weaponId).length).to.eql(1);\n\n    const lookup2 = getLookup();\n    expect(lookup2.hasKey(warriorId)).to.eql(true);\n    expect(lookup2.hasKey(weaponId)).to.eql(true);\n    expect(lookup2.get(warriorId).length).to.eql(2);\n    expect(lookup2.get(weaponId).length).to.eql(2);\n\n    const removeByModule2 = removeByModule(moduleId2);\n    lookup2.removeByCondition(removeByModule1);\n    lookup2.removeByCondition(removeByModule2);\n    expect(lookup2.hasKey(warriorId)).to.eql(false);\n    expect(lookup2.hasKey(weaponId)).to.eql(false);\n\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"should be able to remove the intersection with another lookup","suites":["Lookup"],"updatePoint":{"line":181,"column":67},"line":181,"code":"  it('should be able to remove the intersection with another lookup', () => {\n    const lookup = new Lookup<unknown>();\n\n    const serviceIdentifier1 = 'service-identifier-1';\n    const serviceIdentifier2 = 'service-identifier-2';\n\n    const serviceIdentifier1Values = [11, 12, 13, 14];\n    const serviceIdentifier2Values = [21, 22, 23, 24];\n\n    for (const value of serviceIdentifier1Values) {\n      lookup.add(serviceIdentifier1, value);\n    }\n\n    for (const value of serviceIdentifier2Values) {\n      lookup.add(serviceIdentifier2, value);\n    }\n\n    const lookupToIntersect = new Lookup<unknown>();\n\n    const lookupToIntersectServiceIdentifier2Values = [23, 24, 25, 26];\n\n    const serviceIdentifier3 = 'service-identifier-3';\n\n    const lookupToIntersectServiceIdentifier3Values = [31, 32, 33, 34];\n\n    for (const value of lookupToIntersectServiceIdentifier2Values) {\n      lookupToIntersect.add(serviceIdentifier2, value);\n    }\n\n    for (const value of lookupToIntersectServiceIdentifier3Values) {\n      lookupToIntersect.add(serviceIdentifier3, value);\n    }\n\n    lookup.removeIntersection(lookupToIntersect);\n\n    expect(lookup.getMap()).to.deep.equal(new Map([\n      [serviceIdentifier1, [...serviceIdentifier1Values]],\n      [serviceIdentifier2, [21, 22]],\n    ]));\n  });","file":"container/lookup.test.ts","skipped":false,"dir":"test"},{"name":"should remove handlers added by the module","suites":["ModuleActivationStore"],"updatePoint":{"line":6,"column":48},"line":6,"code":"  it(\"should remove handlers added by the module\", () => {\n    const moduleActivationStore = new ModuleActivationStore();\n\n    const moduleId1: number = 1;\n    const moduleId2: number = 2;\n    const serviceIdentifier1: string = 'some-service-1';\n    const serviceIdentifier2: string = 'some-service-2';\n\n    const onActivation1: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onActivation2: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onActivation3: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onDeactivation1: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    const onDeactivation2: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    const onDeactivation3: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier1, onActivation1);\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier1, onActivation2);\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier2, onActivation3);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier1, onDeactivation1);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier1, onDeactivation2);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier2, onDeactivation3);\n\n    const onActivationMod2: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onDeactivationMod2: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    moduleActivationStore.addActivation(moduleId2, serviceIdentifier1, onActivationMod2);\n    moduleActivationStore.addDeactivation(moduleId2, serviceIdentifier1, onDeactivationMod2);\n\n    const handlers = moduleActivationStore.remove(moduleId1);\n    expect(handlers.onActivations.getMap()).to.deep.equal(new Map([\n      [serviceIdentifier1, [onActivation1, onActivation2]],\n      [serviceIdentifier2, [onActivation3]]\n    ]));\n    expect(handlers.onDeactivations.getMap()).to.deep.equal(new Map([\n      [serviceIdentifier1, [onDeactivation1, onDeactivation2]],\n      [serviceIdentifier2, [onDeactivation3]],\n    ]));\n\n    const noHandlers = moduleActivationStore.remove(moduleId1);\n    expect(noHandlers.onActivations.getMap()).to.deep.equal(new Map());\n    expect(noHandlers.onDeactivations.getMap()).to.deep.equal(new Map());\n\n    const module2Handlers = moduleActivationStore.remove(moduleId2);\n    expect(module2Handlers.onActivations.getMap()).to.deep.equal(new Map([[serviceIdentifier1, [onActivationMod2]]]));\n    expect(module2Handlers.onDeactivations.getMap()).to.deep.equal(new Map([[serviceIdentifier1, [onDeactivationMod2]]]));\n  });","file":"container/module_activation_store.test.ts","skipped":false,"dir":"test"},{"name":"should be able to clone","suites":["ModuleActivationStore"],"updatePoint":{"line":52,"column":29},"line":52,"code":"  it(\"should be able to clone\", () => {\n    const moduleActivationStore = new ModuleActivationStore();\n\n    const moduleId1: number = 1;\n    const moduleId2: number = 2;\n    const serviceIdentifier1: string = 'some-service-1';\n    const serviceIdentifier2: string = 'some-service-2';\n\n    const onActivation1: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onActivation2: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onActivation3: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onDeactivation1: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    const onDeactivation2: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    const onDeactivation3: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier1, onActivation1);\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier1, onActivation2);\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier2, onActivation3);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier1, onDeactivation1);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier1, onDeactivation2);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier2, onDeactivation3);\n\n    const onActivationMod2: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onDeactivationMod2: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n    moduleActivationStore.addActivation(moduleId2, serviceIdentifier1, onActivationMod2);\n    moduleActivationStore.addDeactivation(moduleId2, serviceIdentifier1, onDeactivationMod2);\n\n    const clone = moduleActivationStore.clone();\n\n    //change original\n    const onActivation4: interfaces.BindingActivation<unknown> = (c, a) => a;\n    const onDeactivation4: interfaces.BindingDeactivation<unknown> = (d) => Promise.resolve();\n\n    moduleActivationStore.addActivation(moduleId1, serviceIdentifier1, onActivation4);\n    moduleActivationStore.addDeactivation(moduleId1, serviceIdentifier1, onDeactivation4);\n    moduleActivationStore.remove(moduleId2);\n\n    const cloneModule1Handlers = clone.remove(moduleId1);\n\n    expect(cloneModule1Handlers.onActivations.getMap()).to.deep.equal(\n      new Map([\n        [serviceIdentifier1, [onActivation1, onActivation2]],\n        [serviceIdentifier2, [onActivation3]]\n      ]),\n    );\n\n    expect(cloneModule1Handlers.onDeactivations.getMap()).to.deep.equal(\n      new Map([\n        [serviceIdentifier1, [onDeactivation1, onDeactivation2]],\n        [serviceIdentifier2, [onDeactivation3]],\n      ]),\n    );\n\n    const cloneModule2Handlers = clone.remove(moduleId2);\n\n    expect(cloneModule2Handlers.onActivations.getMap()).to.deep.equal(\n      new Map([[serviceIdentifier1, [onActivationMod2]]]),\n    );\n\n    expect(cloneModule2Handlers.onDeactivations.getMap()).to.deep.equal(\n      new Map([[serviceIdentifier1, [onDeactivationMod2]]]),\n    );\n  });","file":"container/module_activation_store.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use custom constructor injection metadata","suites":["Custom Metadata Reader"],"updatePoint":{"line":83,"column":65},"line":83,"code":"  it(\"Should be able to use custom constructor injection metadata\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    class Katana implements Katana {\n      public static readonly constructorInjections = [];\n      public static readonly propertyInjections = [];\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    class Shuriken implements Shuriken {\n      public static readonly constructorInjections = [];\n      public static readonly propertyInjections = [];\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    class Ninja implements Ninja {\n\n      public static readonly constructorInjections = [\"Katana\", \"Shuriken\"];\n      public static readonly propertyInjections = [];\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        katana: Katana,\n        shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.applyCustomMetadataReader(new StaticPropsMetadataReader());\n\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"features/metadata_reader.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use custom prop injection metadata","suites":["Custom Metadata Reader"],"updatePoint":{"line":149,"column":58},"line":149,"code":"  it(\"Should be able to use custom prop injection metadata\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    class Katana implements Katana {\n      public static readonly constructorInjections = [];\n      public static readonly propertyInjections = [];\n      public static readonly __brk = 1; // TEMP\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    class Shuriken implements Shuriken {\n      public static readonly constructorInjections = [];\n      public static readonly propertyInjections = [];\n      public static readonly __brk = 1; // TEMP\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    class Ninja implements Ninja {\n\n      public static readonly constructorInjections = [];\n\n      public static readonly propertyInjections = [\n        { propName: \"_katana\", injection: \"Katana\" },\n        { propName: \"_shuriken\", injection: \"Shuriken\" }\n      ];\n\n      public static readonly __brk = 1; // TEMP\n\n      private _katana!: Katana;\n      private _shuriken!: Shuriken;\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.applyCustomMetadataReader(new StaticPropsMetadataReader());\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"features/metadata_reader.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use extend the default metadata reader","suites":["Custom Metadata Reader"],"updatePoint":{"line":213,"column":62},"line":213,"code":"  it(\"Should be able to use extend the default metadata reader\", () => {\n\n    const constructorMetadataLog: interfaces.ConstructorMetadata[] = [];\n    const propertyMetadataLog: interfaces.MetadataMap[] = [];\n\n    class CustomMetadataReader extends MetadataReader {\n      public getConstructorMetadata(constructorFunc: NewableFunction): interfaces.ConstructorMetadata {\n        const constructorMetadata = super.getConstructorMetadata(constructorFunc);\n        constructorMetadataLog.push(constructorMetadata);\n        return constructorMetadata;\n      }\n      public getPropertiesMetadata(constructorFunc: NewableFunction): interfaces.MetadataMap {\n        const propertyMetadata = super.getPropertiesMetadata(constructorFunc);\n        propertyMetadataLog.push(propertyMetadata);\n        return propertyMetadata;\n      }\n    }\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.applyCustomMetadataReader(new CustomMetadataReader());\n\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n    expect(Array.isArray(constructorMetadataLog)).eq(true);\n    expect(constructorMetadataLog.length).eq(3);\n\n    const constructorMetadataLogFirstElement = constructorMetadataLog[0] as interfaces.ConstructorMetadata;\n    const constructorMetadataLogSecondElement = constructorMetadataLog[1] as interfaces.ConstructorMetadata;\n    const constructorMetadataLogThirdElement = constructorMetadataLog[2] as interfaces.ConstructorMetadata;\n\n    const compilerGeneratedMetadata0 = constructorMetadataLogFirstElement.compilerGeneratedMetadata;\n\n    if (compilerGeneratedMetadata0) {\n      expect(compilerGeneratedMetadata0[0]).eq(Katana);\n      expect(compilerGeneratedMetadata0[1]).eq(Shuriken);\n    }\n\n    const userGeneratedMetadataFirstElement =\n      constructorMetadataLogFirstElement.userGeneratedMetadata[\"0\"] as interfaces.Metadata[];\n\n    const userGeneratedMetadataSecondElement =\n      constructorMetadataLogFirstElement.userGeneratedMetadata[\"1\"] as interfaces.Metadata[];\n\n    expect((userGeneratedMetadataFirstElement[0] as interfaces.Metadata).key).eq(\"inject\");\n    expect((userGeneratedMetadataFirstElement[0] as interfaces.Metadata).value).eq(\"Katana\");\n    expect((userGeneratedMetadataSecondElement[0] as interfaces.Metadata).key).eq(\"inject\");\n    expect((userGeneratedMetadataSecondElement[0] as interfaces.Metadata).value).eq(\"Shuriken\");\n\n    expect(JSON.stringify(constructorMetadataLogSecondElement.compilerGeneratedMetadata)).eq(JSON.stringify([]));\n    expect(JSON.stringify(constructorMetadataLogThirdElement.compilerGeneratedMetadata)).eq(JSON.stringify([]));\n    expect(JSON.stringify(constructorMetadataLogSecondElement.userGeneratedMetadata)).eq(JSON.stringify({}));\n    expect(JSON.stringify(constructorMetadataLogThirdElement.userGeneratedMetadata)).eq(JSON.stringify({}));\n\n    expect(propertyMetadataLog.length).eq(3);\n\n    const getLength = (metadata: interfaces.MetadataMap) => {\n      return (metadata as unknown as { length: number }).length\n    }\n\n    expect(getLength(propertyMetadataLog[0] as interfaces.MetadataMap)).eq(0);\n    expect(getLength(propertyMetadataLog[1] as interfaces.MetadataMap)).eq(0);\n    expect(getLength(propertyMetadataLog[2] as interfaces.MetadataMap)).eq(0);\n\n  });","file":"features/metadata_reader.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a default to avoid ambiguous binding exceptions","suites":["Named default"],"updatePoint":{"line":6,"column":78},"line":6,"code":"  it(\"Should be able to inject a default to avoid ambiguous binding exceptions\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    const TAG = {\n      chinese: \"chinese\",\n      japanese: \"japanese\",\n      throwable: \"throwable\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    interface Warrior {\n      name: string;\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n      public name: string;\n      public weapon: Weapon;\n      public constructor(\n        @inject(TYPES.Weapon) weapon: Weapon\n      ) {\n        this.name = \"Samurai\";\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public name: string;\n      public weapon: Weapon;\n      public constructor(\n        @inject(TYPES.Weapon) @named(TAG.throwable) weapon: Weapon\n      ) {\n        this.name = \"Ninja\";\n        this.weapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Ninja).whenTargetNamed(TAG.chinese);\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai).whenTargetNamed(TAG.japanese);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetNamed(TAG.throwable);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetIsDefault();\n\n    const ninja = container.getNamed<Warrior>(TYPES.Warrior, TAG.chinese);\n    const samurai = container.getNamed<Warrior>(TYPES.Warrior, TAG.japanese);\n\n    expect(ninja.name).to.eql(\"Ninja\");\n    expect(ninja.weapon.name).to.eql(\"Shuriken\");\n    expect(samurai.name).to.eql(\"Samurai\");\n    expect(samurai.weapon.name).to.eql(\"Katana\");\n\n  });","file":"features/named_default.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to select a default to avoid ambiguous binding exceptions","suites":["Named default"],"updatePoint":{"line":84,"column":78},"line":84,"code":"  it(\"Should be able to select a default to avoid ambiguous binding exceptions\", () => {\n\n    const TYPES = {\n      Weapon: \"Weapon\"\n    };\n\n    const TAG = {\n      throwable: \"throwable\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetNamed(TAG.throwable);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).inSingletonScope().whenTargetIsDefault();\n\n    const defaultWeapon = container.get<Weapon>(TYPES.Weapon);\n    const throwableWeapon = container.getNamed<Weapon>(TYPES.Weapon, TAG.throwable);\n\n    expect(defaultWeapon.name).eql(\"Katana\");\n    expect(throwableWeapon.name).eql(\"Shuriken\");\n\n  });","file":"features/named_default.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a property","suites":["Property Injection"],"updatePoint":{"line":11,"column":41},"line":11,"code":"  it(\"Should be able to inject a property\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n      public name: string;\n      @inject(TYPES.Weapon)\n      public weapon!: Weapon;\n      public constructor() {\n        this.name = \"Samurai\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana);\n\n    const warrior = container.get<Warrior>(TYPES.Warrior);\n    expect(warrior.name).to.eql(\"Samurai\");\n    expect(warrior.weapon).not.to.eql(undefined);\n    expect(warrior.weapon.name).to.eql(\"Katana\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a property combined with constructor injection","suites":["Property Injection"],"updatePoint":{"line":56,"column":77},"line":56,"code":"  it(\"Should be able to inject a property combined with constructor injection\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    const TAGS = {\n      Primary: \"Primary\",\n      Secondary: \"Secondary\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      primaryWeapon: Weapon;\n      secondaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public name: string;\n      public primaryWeapon: Weapon;\n\n      @inject(TYPES.Weapon)\n      @named(TAGS.Secondary)\n      public secondaryWeapon!: Weapon;\n\n      public constructor(\n        @inject(TYPES.Weapon) @named(TAGS.Primary) weapon: Weapon\n      ) {\n        this.name = \"Samurai\";\n        this.primaryWeapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetNamed(TAGS.Primary);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetNamed(TAGS.Secondary);\n\n    const warrior = container.get<Warrior>(TYPES.Warrior);\n    expect(warrior.name).to.eql(\"Samurai\");\n    expect(warrior.primaryWeapon).not.to.eql(undefined);\n    expect(warrior.primaryWeapon.name).to.eql(\"Katana\");\n    expect(warrior.secondaryWeapon).not.to.eql(undefined);\n    expect(warrior.secondaryWeapon.name).to.eql(\"Shuriken\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a named property","suites":["Property Injection"],"updatePoint":{"line":126,"column":47},"line":126,"code":"  it(\"Should be able to inject a named property\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    const TAGS = {\n      Primary: \"Primary\",\n      Secondary: \"Secondary\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      primaryWeapon: Weapon;\n      secondaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public name: string;\n\n      @inject(TYPES.Weapon)\n      @named(TAGS.Primary)\n      public primaryWeapon!: Weapon;\n\n      @inject(TYPES.Weapon)\n      @named(TAGS.Secondary)\n      public secondaryWeapon!: Weapon;\n\n      public constructor() {\n        this.name = \"Samurai\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetNamed(TAGS.Primary);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetNamed(TAGS.Secondary);\n\n    const warrior = container.get<Warrior>(TYPES.Warrior);\n    expect(warrior.name).to.eql(\"Samurai\");\n    expect(warrior.primaryWeapon).not.to.eql(undefined);\n    expect(warrior.primaryWeapon.name).to.eql(\"Katana\");\n    expect(warrior.secondaryWeapon).not.to.eql(undefined);\n    expect(warrior.secondaryWeapon.name).to.eql(\"Shuriken\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a tagged property","suites":["Property Injection"],"updatePoint":{"line":196,"column":48},"line":196,"code":"  it(\"Should be able to inject a tagged property\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    const TAGS = {\n      Primary: \"Primary\",\n      Priority: \"Priority\",\n      Secondary: \"Secondary\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      primaryWeapon: Weapon;\n      secondaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public name: string;\n\n      @inject(TYPES.Weapon)\n      @tagged(TAGS.Priority, TAGS.Primary)\n      public primaryWeapon!: Weapon;\n\n      @inject(TYPES.Weapon)\n      @tagged(TAGS.Priority, TAGS.Secondary)\n      public secondaryWeapon!: Weapon;\n\n      public constructor() {\n        this.name = \"Samurai\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetTagged(TAGS.Priority, TAGS.Primary);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetTagged(TAGS.Priority, TAGS.Secondary);\n\n    const warrior = container.get<Warrior>(TYPES.Warrior);\n    expect(warrior.name).to.eql(\"Samurai\");\n    expect(warrior.primaryWeapon).not.to.eql(undefined);\n    expect(warrior.primaryWeapon.name).to.eql(\"Katana\");\n    expect(warrior.secondaryWeapon).not.to.eql(undefined);\n    expect(warrior.secondaryWeapon.name).to.eql(\"Shuriken\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to multi-inject a property","suites":["Property Injection"],"updatePoint":{"line":267,"column":47},"line":267,"code":"  it(\"Should be able to multi-inject a property\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      weapons: Weapon[];\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public name: string;\n\n      @multiInject(TYPES.Weapon)\n      public weapons!: Weapon[];\n\n      public constructor() {\n        this.name = \"Samurai\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken);\n\n    const warrior = container.get<Warrior>(TYPES.Warrior);\n    expect(warrior.name).to.eql(\"Samurai\");\n    expect(warrior.weapons[0]).not.to.eql(undefined);\n    expect(warrior.weapons[0]?.name).to.eql(\"Katana\");\n    expect(warrior.weapons[1]).not.to.eql(undefined);\n    expect(warrior.weapons[1]?.name).to.eql(\"Shuriken\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a property in a base class","suites":["Property Injection"],"updatePoint":{"line":326,"column":57},"line":326,"code":"  it(\"Should be able to inject a property in a base class\", () => {\n\n    const TYPES = {\n      Warrior: \"Warrior\",\n      Weapon: \"Weapon\"\n    };\n\n    const TAGS = {\n      Primary: \"Primary\",\n      Priority: \"Priority\",\n      Secondary: \"Secondary\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"Shuriken\";\n      }\n    }\n\n    interface Warrior {\n      name: string;\n      primaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class BaseWarrior implements Warrior {\n\n      public name: string;\n\n      @inject(TYPES.Weapon)\n      @tagged(TAGS.Priority, TAGS.Primary)\n      public primaryWeapon!: Weapon;\n\n      public constructor(@unmanaged() name: string) {\n        this.name = name;\n      }\n    }\n\n    @injectable()\n    class Samurai extends BaseWarrior {\n\n      @inject(TYPES.Weapon)\n      @tagged(TAGS.Priority, TAGS.Secondary)\n      public secondaryWeapon!: Weapon;\n\n      public constructor() {\n        super(\"Samurai\");\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).to(Samurai);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenTargetTagged(TAGS.Priority, TAGS.Primary);\n    container.bind<Weapon>(TYPES.Weapon).to(Shuriken).whenTargetTagged(TAGS.Priority, TAGS.Secondary);\n\n    const samurai = container.get<Samurai>(TYPES.Warrior);\n    expect(samurai.name).to.eql(\"Samurai\");\n    expect(samurai.secondaryWeapon).not.to.eql(undefined);\n    expect(samurai.secondaryWeapon.name).to.eql(\"Shuriken\");\n    expect(samurai.primaryWeapon).not.to.eql(undefined);\n    expect(samurai.primaryWeapon.name).to.eql(\"Katana\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to flag a property injection as optional","suites":["Property Injection"],"updatePoint":{"line":404,"column":61},"line":404,"code":"  it(\"Should be able to flag a property injection as optional\", () => {\n\n    const TYPES = {\n      Route: \"Route\",\n      Router: \"Router\"\n    };\n\n    interface Route {\n      name: string;\n    }\n\n    @injectable()\n    class Router {\n\n      @inject(TYPES.Route) @optional()\n      private route!: Route;\n\n      public getRoute(): Route {\n        return this.route;\n      }\n\n    }\n\n    const container = new Container();\n\n    container.bind<Router>(TYPES.Router).to(Router);\n\n    const router1 = container.get<Router>(TYPES.Router);\n    expect(router1.getRoute()).to.eql(undefined);\n\n    container.bind<Route>(TYPES.Route).toConstantValue({ name: \"route1\" });\n\n    const router2 = container.get<Router>(TYPES.Router);\n    expect(router2.getRoute().name).to.eql(\"route1\");\n\n  });","file":"features/property_injection.test.ts","skipped":false,"dir":"test"},{"name":"Should support complex asynchronous initialization processes","suites":["Provider"],"updatePoint":{"line":6,"column":66},"line":6,"code":"  it(\"Should support complex asynchronous initialization processes\", (done) => {\n\n    @injectable()\n    class Ninja {\n      public level: number;\n      public rank: string;\n      public constructor() {\n        this.level = 0;\n        this.rank = \"Ninja\";\n      }\n      public train(): Promise<number> {\n        return new Promise<number>((resolve) => {\n          setTimeout(() => {\n            this.level += 10;\n            resolve(this.level);\n          }, 10);\n        });\n      }\n    }\n\n    @injectable()\n    class NinjaMaster {\n      public rank: string;\n      public constructor() {\n        this.rank = \"NinjaMaster\";\n      }\n    }\n\n    type NinjaMasterProvider = () => Promise<NinjaMaster>;\n\n    const container = new Container();\n\n    container.bind<Ninja>(\"Ninja\").to(Ninja).inSingletonScope();\n    container.bind<NinjaMasterProvider>(\"Provider<NinjaMaster>\").toProvider((context) =>\n      () =>\n        new Promise<NinjaMaster>((resolve, reject) => {\n          const ninja = context.container.get<Ninja>(\"Ninja\");\n          ninja.train().then((level) => {\n            if (level >= 20) {\n              resolve(new NinjaMaster());\n            } else {\n              reject(\"Not enough training\");\n            }\n          });\n        }));\n\n    const ninjaMasterProvider = container.get<NinjaMasterProvider>(\"Provider<NinjaMaster>\");\n\n    // helper\n    function valueOrDefault<T>(provider: () => Promise<T>, defaultValue: T) {\n      return new Promise<T>((resolve, reject) => {\n        provider().then((value) => {\n          resolve(value);\n        }).catch(() => {\n          resolve(defaultValue);\n        });\n      });\n    }\n\n    valueOrDefault(ninjaMasterProvider, { rank: \"DefaultNinjaMaster\" }).then((ninjaMaster) => {\n      expect(ninjaMaster.rank).to.eql(\"DefaultNinjaMaster\");\n    });\n\n    valueOrDefault(ninjaMasterProvider, { rank: \"DefaultNinjaMaster\" }).then((ninjaMaster) => {\n      expect(ninjaMaster.rank).to.eql(\"NinjaMaster\");\n      done();\n    });\n\n  });","file":"features/provider.test.ts","skipped":false,"dir":"test"},{"name":"Should support custom arguments","suites":["Provider"],"updatePoint":{"line":76,"column":37},"line":76,"code":"  it(\"Should support custom arguments\", (done) => {\n\n    const container = new Container();\n\n    interface Sword {\n      material: string;\n      damage: number;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public material!: string;\n      public damage!: number;\n    }\n\n    type SwordProvider = (material: string, damage: number) => Promise<Sword>;\n\n    container.bind<Sword>(\"Sword\").to(Katana);\n\n    container.bind<SwordProvider>(\"SwordProvider\").toProvider<Sword>((context) =>\n      (material: string, damage: number) =>\n        new Promise<Sword>((resolve) => {\n          setTimeout(() => {\n            const katana = context.container.get<Sword>(\"Sword\");\n            katana.material = material;\n            katana.damage = damage;\n            resolve(katana);\n          }, 10);\n        }));\n\n    const katanaProvider = container.get<SwordProvider>(\"SwordProvider\");\n\n    katanaProvider(\"gold\", 100).then((powerfulGoldKatana) => {\n\n      expect(powerfulGoldKatana.material).to.eql(\"gold\");\n      expect(powerfulGoldKatana.damage).to.eql(100);\n\n      katanaProvider(\"gold\", 10).then((notSoPowerfulGoldKatana) => {\n        expect(notSoPowerfulGoldKatana.material).to.eql(\"gold\");\n        expect(notSoPowerfulGoldKatana.damage).to.eql(10);\n        done();\n      });\n\n    });\n\n  });","file":"features/provider.test.ts","skipped":false,"dir":"test"},{"name":"Should support partial application of custom arguments","suites":["Provider"],"updatePoint":{"line":123,"column":60},"line":123,"code":"  it(\"Should support partial application of custom arguments\", (done) => {\n\n    const container = new Container();\n\n    interface Sword {\n      material: string;\n      damage: number;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public material!: string;\n      public damage!: number;\n    }\n\n    type SwordProvider = (material: string) => (damage: number) => Promise<Sword>;\n\n    container.bind<Sword>(\"Sword\").to(Katana);\n\n    container.bind<SwordProvider>(\"SwordProvider\").toProvider<Sword>((context) =>\n      (material: string) =>\n        (damage: number) =>\n          new Promise<Sword>((resolve) => {\n            setTimeout(() => {\n              const katana = context.container.get<Sword>(\"Sword\");\n              katana.material = material;\n              katana.damage = damage;\n              resolve(katana);\n            }, 10);\n          }));\n\n    const katanaProvider = container.get<SwordProvider>(\"SwordProvider\");\n    const goldKatanaProvider = katanaProvider(\"gold\");\n\n    goldKatanaProvider(100).then((powerfulGoldKatana) => {\n\n      expect(powerfulGoldKatana.material).to.eql(\"gold\");\n      expect(powerfulGoldKatana.damage).to.eql(100);\n\n      goldKatanaProvider(10).then((notSoPowerfulGoldKatana) => {\n        expect(notSoPowerfulGoldKatana.material).to.eql(\"gold\");\n        expect(notSoPowerfulGoldKatana.damage).to.eql(10);\n        done();\n      });\n\n    });\n\n  });","file":"features/provider.test.ts","skipped":false,"dir":"test"},{"name":"Should support the declaration of singletons","suites":["Provider"],"updatePoint":{"line":172,"column":50},"line":172,"code":"  it(\"Should support the declaration of singletons\", (done) => {\n\n    const container = new Container();\n\n    interface Warrior {\n      level: number;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public level: number;\n      public constructor() {\n        this.level = 0;\n      }\n    }\n\n    type WarriorProvider = (level: number) => Promise<Warrior>;\n\n    container.bind<Warrior>(\"Warrior\").to(Ninja).inSingletonScope(); // Value is singleton!\n\n    container.bind<WarriorProvider>(\"WarriorProvider\").toProvider<Warrior>((context) =>\n      (increaseLevel: number) =>\n        new Promise<Warrior>((resolve) => {\n          setTimeout(() => {\n            const warrior = context.container.get<Warrior>(\"Warrior\"); // Get singleton!\n            warrior.level += increaseLevel;\n            resolve(warrior);\n          }, 100);\n        }));\n\n    const warriorProvider = container.get<WarriorProvider>(\"WarriorProvider\");\n\n    warriorProvider(10).then((warrior) => {\n\n      expect(warrior.level).to.eql(10);\n\n      warriorProvider(10).then((warrior2) => {\n        expect(warrior.level).to.eql(20);\n        done();\n      });\n\n    });\n\n  });","file":"features/provider.test.ts","skipped":false,"dir":"test"},{"name":"Should support request scope in basic bindings","suites":["inRequestScope"],"updatePoint":{"line":7,"column":52},"line":7,"code":"  it(\"Should support request scope in basic bindings\", () => {\n\n    const TYPE = {\n      Warrior: Symbol(\"Warrior\"),\n      Weapon: Symbol(\"Weapon\")\n    };\n\n    interface Weapon {\n      use(): string;\n    }\n\n    interface Warrior {\n      primaryWeapon: Weapon;\n      secondaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      private _madeOn: number;\n      public constructor() {\n        this._madeOn = performance.now();\n      }\n      public use() {\n        return `Used Katana made on ${this._madeOn}!`;\n      }\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n      public primaryWeapon: Weapon;\n      public secondaryWeapon: Weapon;\n      public constructor(\n        @inject(TYPE.Weapon) primaryWeapon: Weapon,\n        @inject(TYPE.Weapon) secondaryWeapon: Weapon\n      ) {\n        this.primaryWeapon = primaryWeapon;\n        this.secondaryWeapon = secondaryWeapon;\n      }\n    }\n\n    // Without request scope\n    const container = new Container();\n    container.bind<Weapon>(TYPE.Weapon).to(Katana);\n    container.bind<Warrior>(TYPE.Warrior).to(Samurai);\n    const samurai = container.get<Warrior>(TYPE.Warrior);\n    const samurai2 = container.get<Warrior>(TYPE.Warrior);\n\n    // One requests should use two instances because scope is transient\n    expect(samurai.primaryWeapon.use()).not.to.eql(samurai.secondaryWeapon.use());\n\n    // One requests should use two instances because scope is transient\n    expect(samurai2.primaryWeapon.use()).not.to.eql(samurai2.secondaryWeapon.use());\n\n    // Two request should use two Katana instances\n    // for each instance of Samuari because scope is transient\n    expect(samurai.primaryWeapon.use()).not.to.eql(samurai2.primaryWeapon.use());\n    expect(samurai.secondaryWeapon.use()).not.to.eql(samurai2.secondaryWeapon.use());\n\n    // With request scope\n    const container1 = new Container();\n    container1.bind<Weapon>(TYPE.Weapon).to(Katana).inRequestScope(); // Important\n    container1.bind<Warrior>(TYPE.Warrior).to(Samurai);\n    const samurai3 = container1.get<Warrior>(TYPE.Warrior);\n    const samurai4 = container1.get<Warrior>(TYPE.Warrior);\n\n    // One requests should use one instance because scope is request scope\n    expect(samurai3.primaryWeapon.use()).to.eql(samurai3.secondaryWeapon.use());\n\n    // One requests should use one instance because scope is request scope\n    expect(samurai4.primaryWeapon.use()).to.eql(samurai4.secondaryWeapon.use());\n\n    // Two request should use one instances of Katana\n    // for each instance of Samurai because scope is request scope\n    expect(samurai3.primaryWeapon.use()).not.to.eql(samurai4.primaryWeapon.use());\n    expect(samurai3.secondaryWeapon.use()).not.to.eql(samurai4.secondaryWeapon.use());\n\n  });","file":"features/request_scope.test.ts","skipped":false,"dir":"test"},{"name":"Should support request scope when using contraints","suites":["inRequestScope"],"updatePoint":{"line":85,"column":56},"line":85,"code":"  it(\"Should support request scope when using contraints\", () => {\n\n    const TYPE = {\n      Warrior: Symbol(\"Warrior\"),\n      Weapon: Symbol(\"Weapon\")\n    };\n\n    interface Weapon {\n      use(): string;\n    }\n\n    interface Warrior {\n      primaryWeapon: Weapon;\n      secondaryWeapon: Weapon;\n      tertiaryWeapon: Weapon;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      private _madeOn: number;\n      public constructor() {\n        this._madeOn = performance.now();\n      }\n      public use() {\n        return `Used Katana made on ${this._madeOn}!`;\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      private _madeOn: number;\n      public constructor() {\n        this._madeOn = performance.now();\n      }\n      public use() {\n        return `Used Shuriken made on ${this._madeOn}!`;\n      }\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n      public primaryWeapon: Weapon;\n      public secondaryWeapon: Weapon;\n      public tertiaryWeapon: Weapon;\n      public constructor(\n        @inject(TYPE.Weapon) @named(\"sword\") primaryWeapon: Weapon,\n        @inject(TYPE.Weapon) @named(\"throwable\") secondaryWeapon: Weapon,\n        @inject(TYPE.Weapon) @named(\"throwable\") tertiaryWeapon: Weapon\n      ) {\n        this.primaryWeapon = primaryWeapon;\n        this.secondaryWeapon = secondaryWeapon;\n        this.tertiaryWeapon = tertiaryWeapon;\n      }\n    }\n\n    const container = new Container();\n\n    container.bind<Weapon>(TYPE.Weapon).to(Katana)\n      .inRequestScope()\n      .whenTargetNamed(\"sword\");\n\n    container.bind<Weapon>(TYPE.Weapon).to(Shuriken)\n      .inRequestScope()\n      .whenTargetNamed(\"throwable\");\n\n    container.bind<Warrior>(TYPE.Warrior).to(Samurai);\n\n    const samurai1 = container.get<Warrior>(TYPE.Warrior);\n    const samurai2 = container.get<Warrior>(TYPE.Warrior);\n\n    // Katana and Shuriken are two instances\n    expect(samurai1.primaryWeapon.use()).not.to.eql(samurai1.secondaryWeapon.use());\n\n    // Shuriken should be one shared instance because scope is request scope\n    expect(samurai1.secondaryWeapon.use()).to.eql(samurai1.tertiaryWeapon.use());\n\n    // Katana and Shuriken are two instances\n    expect(samurai2.primaryWeapon.use()).not.to.eql(samurai2.secondaryWeapon.use());\n\n    // Shuriken should be one shared instance because scope is request scope\n    expect(samurai2.secondaryWeapon.use()).to.eql(samurai2.tertiaryWeapon.use());\n\n    // Two request should use one instances of Katana\n    // for each instance of Samurai because scope is request scope\n    expect(samurai1.secondaryWeapon.use()).not.to.eql(samurai2.secondaryWeapon.use());\n    expect(samurai1.tertiaryWeapon.use()).not.to.eql(samurai2.tertiaryWeapon.use());\n\n  });","file":"features/request_scope.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve a class that has not binded","suites":["Container.prototype.resolve"],"updatePoint":{"line":6,"column":59},"line":6,"code":"  it(\"Should be able to resolve a class that has not binded\", () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Katana;\n      public constructor(katana: Katana) {\n        this.katana = katana;\n      }\n      public fight() { return this.katana.hit(); }\n    }\n\n    const container = new Container();\n    container.bind(Katana).toSelf();\n\n    const tryGet = () => container.get(Ninja);\n    expect(tryGet).to.throw(\"No matching bindings found for serviceIdentifier: Ninja\");\n\n    const ninja = container.resolve(Ninja);\n    expect(ninja.fight()).to.eql(\"cut!\");\n    expect(container.isBound(Ninja)).to.equal(false);\n\n  });","file":"features/resolve_unbinded.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve a class that has already been bound","suites":["Container.prototype.resolve"],"updatePoint":{"line":36,"column":67},"line":36,"code":"  it(\"Should be able to resolve a class that has already been bound\", () => {\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Katana;\n      public constructor(katana: Katana) {\n        this.katana = katana;\n      }\n      public fight() { return this.katana.hit(); }\n    }\n\n    const container = new Container();\n    container.bind(Katana).toSelf();\n    container.bind(Ninja).toSelf();\n\n    const ninja = container.resolve(Ninja);\n    expect(ninja.fight()).to.eql(\"cut!\");\n  })","file":"features/resolve_unbinded.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to bind to a service","suites":["Transitive bindings"],"updatePoint":{"line":6,"column":41},"line":6,"code":"  it(\"Should be able to bind to a service\", () => {\n\n    @injectable()\n    class MySqlDatabaseTransactionLog {\n      public time: number;\n      public name: string;\n      public constructor() {\n        this.time = new Date().getTime();\n        this.name = \"MySqlDatabaseTransactionLog\";\n      }\n    }\n\n    @injectable()\n    class DatabaseTransactionLog {\n      public time!: number;\n      public name!: string;\n    }\n\n    @injectable()\n    class TransactionLog {\n      public time!: number;\n      public name!: string;\n    }\n\n    const container = new Container();\n    container.bind(MySqlDatabaseTransactionLog).toSelf().inSingletonScope();\n    container.bind(DatabaseTransactionLog).toService(MySqlDatabaseTransactionLog);\n    container.bind(TransactionLog).toService(DatabaseTransactionLog);\n\n    const mySqlDatabaseTransactionLog = container.get(MySqlDatabaseTransactionLog);\n    const databaseTransactionLog = container.get(DatabaseTransactionLog);\n    const transactionLog = container.get(TransactionLog);\n\n    expect(mySqlDatabaseTransactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(databaseTransactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(transactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(mySqlDatabaseTransactionLog.time).to.eq(databaseTransactionLog.time);\n    expect(databaseTransactionLog.time).to.eq(transactionLog.time);\n\n  });","file":"features/transitive_bindings.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to bulk bind to a service","suites":["Transitive bindings"],"updatePoint":{"line":47,"column":46},"line":47,"code":"  it(\"Should be able to bulk bind to a service\", () => {\n\n    @injectable()\n    class MySqlDatabaseTransactionLog {\n      public time: number;\n      public name: string;\n      public constructor() {\n        this.time = new Date().getTime();\n        this.name = \"MySqlDatabaseTransactionLog\";\n      }\n    }\n\n    @injectable()\n    class DatabaseTransactionLog {\n      public time!: number;\n      public name!: string;\n    }\n\n    @injectable()\n    class TransactionLog {\n      public time!: number;\n      public name!: string;\n    }\n\n    const container = new Container();\n    const mbts = multiBindToService(container);\n    container.bind(MySqlDatabaseTransactionLog).toSelf().inSingletonScope();\n    mbts(MySqlDatabaseTransactionLog)(DatabaseTransactionLog, TransactionLog);\n\n    const mySqlDatabaseTransactionLog = container.get(MySqlDatabaseTransactionLog);\n    const databaseTransactionLog = container.get(DatabaseTransactionLog);\n    const transactionLog = container.get(TransactionLog);\n\n    expect(mySqlDatabaseTransactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(databaseTransactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(transactionLog.name).to.eq(\"MySqlDatabaseTransactionLog\");\n    expect(mySqlDatabaseTransactionLog.time).to.eq(databaseTransactionLog.time);\n    expect(databaseTransactionLog.time).to.eq(transactionLog.time);\n\n  });","file":"features/transitive_bindings.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve and inject dependencies","suites":["InversifyJS"],"updatePoint":{"line":12,"column":55},"line":12,"code":"  it(\"Should be able to resolve and inject dependencies\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to do setter injection and property injection","suites":["InversifyJS"],"updatePoint":{"line":72,"column":66},"line":72,"code":"  it(\"Should be able to do setter injection and property injection\", () => {\n    @injectable()\n    class Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n\n      private _shuriken!: Shuriken;\n      @inject(Shuriken)\n      public set Shuriken(shuriken: Shuriken) {\n        this._shuriken = shuriken;\n      }\n      @inject(Katana)\n      public katana!: Katana;\n      public sneak() { return this._shuriken.throw(); }\n      public fight() { return this.katana.hit(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind(Shuriken).toSelf();\n    container.bind(Katana).toSelf();\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n    expect(ninja.sneak()).to.eql(\"hit!\");\n    expect(ninja.fight()).to.eql(\"cut!\");\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve and inject dependencies in VanillaJS","suites":["InversifyJS"],"updatePoint":{"line":111,"column":68},"line":111,"code":"  it(\"Should be able to resolve and inject dependencies in VanillaJS\", () => {\n\n    const TYPES = {\n      Katana: \"Katana\",\n      Ninja: \"Ninja\",\n      Shuriken: \"Shuriken\",\n      Blowgun: \"Blowgun\"\n    };\n\n    class Blowgun {\n      public blow() {\n        return \"poison!\";\n      }\n    }\n\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    class Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    class Ninja {\n\n      public _katana: Katana;\n      public _shuriken: Shuriken;\n      public _blowgun!: Blowgun;\n\n      public constructor(katana: Katana, shuriken: Shuriken) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n      public poisonDart() { return this._blowgun.blow(); }\n\n      public set blowgun(blowgun: Blowgun) {\n        this._blowgun = blowgun;\n      }\n    }\n\n    decorate(injectable(), Katana);\n    decorate(injectable(), Shuriken);\n    decorate(injectable(), Ninja);\n    decorate(injectable(), Blowgun);\n    decorate(inject(TYPES.Katana), Ninja, 0);\n    decorate(inject(TYPES.Shuriken), Ninja, 1);\n    decorate(inject(TYPES.Blowgun), Ninja.prototype, \"blowgun\");\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n    container.bind<Katana>(TYPES.Katana).to(Katana);\n    container.bind<Shuriken>(TYPES.Shuriken).to(Shuriken);\n    container.bind<Blowgun>(TYPES.Blowgun).to(Blowgun);\n\n    const ninja = container.get<Ninja>(TYPES.Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n    expect(ninja.poisonDart()).eql(\"poison!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use classes as runtime identifiers","suites":["InversifyJS"],"updatePoint":{"line":179,"column":58},"line":179,"code":"  it(\"Should be able to use classes as runtime identifiers\", () => {\n\n    @injectable()\n    class Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(katana: Katana, shuriken: Shuriken) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(Ninja).to(Ninja);\n    container.bind<Katana>(Katana).to(Katana);\n    container.bind<Shuriken>(Shuriken).to(Shuriken);\n\n    const ninja = container.get<Ninja>(Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use Symbols as runtime identifiers","suites":["InversifyJS"],"updatePoint":{"line":223,"column":58},"line":223,"code":"  it(\"Should be able to use Symbols as runtime identifiers\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    const TYPES = {\n      Katana: Symbol.for(\"Katana\"),\n      Ninja: Symbol.for(\"Ninja\"),\n      Shuriken: Symbol.for(\"Shuriken\")\n    };\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(TYPES.Katana) katana: Katana,\n        @inject(TYPES.Shuriken) shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n    container.bind<Katana>(TYPES.Katana).to(Katana);\n    container.bind<Shuriken>(TYPES.Shuriken).to(Shuriken);\n\n    const ninja = container.get<Ninja>(TYPES.Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to wrap Symbols with LazyServiceIdentifer","suites":["InversifyJS"],"updatePoint":{"line":289,"column":62},"line":289,"code":"  it(\"Should be able to wrap Symbols with LazyServiceIdentifer\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    const TYPES = {\n      Katana: Symbol.for(\"Katana\"),\n      Ninja: Symbol.for(\"Ninja\"),\n      Shuriken: Symbol.for(\"Shuriken\")\n    };\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(new LazyServiceIdentifer(() => TYPES.Katana)) katana: Katana,\n        @inject(new LazyServiceIdentifer(() => TYPES.Shuriken)) shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n    container.bind<Katana>(TYPES.Katana).to(Katana);\n    container.bind<Shuriken>(TYPES.Shuriken).to(Shuriken);\n\n    const ninja = container.get<Ninja>(TYPES.Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support Container modules","suites":["InversifyJS"],"updatePoint":{"line":355,"column":38},"line":355,"code":"  it(\"Should support Container modules\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(@inject(\"Katana\") katana: Katana, @inject(\"Shuriken\") shuriken: Shuriken) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const warriors = new ContainerModule((bind: interfaces.Bind) => {\n      bind<Ninja>(\"Ninja\").to(Ninja);\n    });\n\n    const weapons = new ContainerModule((bind: interfaces.Bind) => {\n      bind<Katana>(\"Katana\").to(Katana);\n      bind<Shuriken>(\"Shuriken\").to(Shuriken);\n    });\n\n    const container = new Container();\n\n    // load\n    container.load(warriors, weapons);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n    const tryGetNinja = () => { container.get(\"Ninja\"); };\n    const tryGetKatana = () => { container.get(\"Katana\"); };\n    const tryGetShuruken = () => { container.get(\"Shuriken\"); };\n\n    // unload\n    container.unload(warriors);\n    expect(tryGetNinja).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetKatana).not.to.throw();\n    expect(tryGetShuruken).not.to.throw();\n\n    container.unload(weapons);\n    expect(tryGetNinja).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetKatana).to.throw(ERROR_MSGS.NOT_REGISTERED);\n    expect(tryGetShuruken).to.throw(ERROR_MSGS.NOT_REGISTERED);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support control over the scope of the dependencies","suites":["InversifyJS"],"updatePoint":{"line":436,"column":63},"line":436,"code":"  it(\"Should support control over the scope of the dependencies\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      private _usageCount: number;\n      public constructor() {\n        this._usageCount = 0;\n      }\n      public hit() {\n        this._usageCount = this._usageCount + 1;\n        return `This katana was used ${this._usageCount} times!`;\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      private _shurikenCount: number;\n      public constructor() {\n        this._shurikenCount = 10;\n      }\n      public throw() {\n        this._shurikenCount = this._shurikenCount - 1;\n        return `Only ${this._shurikenCount} items left!`;\n      }\n    }\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana).inSingletonScope();\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n\n    const ninja1 = container.get<Ninja>(\"Ninja\");\n    expect(ninja1.fight()).eql(\"This katana was used 1 times!\");\n    expect(ninja1.fight()).eql(\"This katana was used 2 times!\");\n    expect(ninja1.sneak()).eql(\"Only 9 items left!\");\n    expect(ninja1.sneak()).eql(\"Only 8 items left!\");\n\n    const ninja2 = container.get<Ninja>(\"Ninja\");\n    expect(ninja2.fight()).eql(\"This katana was used 3 times!\");\n    expect(ninja2.sneak()).eql(\"Only 9 items left!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of classes to itself","suites":["InversifyJS"],"updatePoint":{"line":511,"column":55},"line":511,"code":"  it(\"Should support the injection of classes to itself\", () => {\n\n    const heroName = \"superman\";\n\n    @injectable()\n    class Hero {\n      public name: string;\n      public constructor() {\n        this.name = heroName;\n      }\n    }\n\n    const container = new Container();\n    container.bind(Hero).toSelf();\n    const hero = container.get<Hero>(Hero);\n\n    expect(hero.name).eql(heroName);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of constant values","suites":["InversifyJS"],"updatePoint":{"line":531,"column":53},"line":531,"code":"  it(\"Should support the injection of constant values\", () => {\n\n    interface Warrior {\n      name: string;\n    }\n\n    const TYPES = {\n      Warrior: \"Warrior\"\n    };\n\n    const heroName = \"superman\";\n\n    @injectable()\n    class Hero implements Warrior {\n      public name: string;\n      public constructor() {\n        this.name = heroName;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(TYPES.Warrior).toConstantValue(new Hero());\n    const hero = container.get<Warrior>(TYPES.Warrior);\n\n    expect(hero.name).eql(heroName);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of dynamic values","suites":["InversifyJS"],"updatePoint":{"line":559,"column":52},"line":559,"code":"  it(\"Should support the injection of dynamic values\", () => {\n\n    interface UseDate {\n      doSomething(): Date;\n    }\n\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public constructor(@inject(\"Date\") currentDate: Date) {\n        this.currentDate = currentDate;\n      }\n      public doSomething() {\n        return this.currentDate;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue((context: interfaces.Context) => new Date());\n\n    const subject1 = container.get<UseDate>(\"UseDate\");\n    const subject2 = container.get<UseDate>(\"UseDate\");\n    expect(subject1.doSomething() === subject2.doSomething()).eql(false);\n\n    container.unbind(\"Date\");\n    container.bind<Date>(\"Date\").toConstantValue(new Date());\n\n    const subject3 = container.get<UseDate>(\"UseDate\");\n    const subject4 = container.get<UseDate>(\"UseDate\");\n    expect(subject3.doSomething() === subject4.doSomething()).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of Functions","suites":["InversifyJS"],"updatePoint":{"line":593,"column":47},"line":593,"code":"  it(\"Should support the injection of Functions\", () => {\n\n    const ninjaId = \"Ninja\";\n    const longDistanceWeaponId = \"LongDistanceWeapon\";\n    const shortDistanceWeaponFactoryId = \"ShortDistanceWeaponFactory\";\n\n    type ShortDistanceWeaponFactory = () => ShortDistanceWeapon;\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface ShortDistanceWeapon {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    @injectable()\n    class Katana implements ShortDistanceWeapon {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(handler: KatanaHandler, blade: KatanaBlade) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface LongDistanceWeapon { }\n\n    @injectable()\n    class Shuriken implements LongDistanceWeapon { }\n\n    interface Warrior {\n      shortDistanceWeaponFactory: ShortDistanceWeaponFactory;\n      longDistanceWeapon: LongDistanceWeapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public shortDistanceWeaponFactory: ShortDistanceWeaponFactory;\n      public longDistanceWeapon: LongDistanceWeapon;\n      public constructor(\n        @inject(shortDistanceWeaponFactoryId) @targetName(\"katana\") shortDistanceWeaponFactory: ShortDistanceWeaponFactory,\n        @inject(longDistanceWeaponId) @targetName(\"shuriken\") longDistanceWeapon: LongDistanceWeapon\n      ) {\n        this.shortDistanceWeaponFactory = shortDistanceWeaponFactory;\n        this.longDistanceWeapon = longDistanceWeapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<LongDistanceWeapon>(longDistanceWeaponId).to(Shuriken);\n\n    const katanaFactory = function () {\n      return new Katana(new KatanaHandler(), new KatanaBlade());\n    };\n\n    container.bind<ShortDistanceWeaponFactory>(shortDistanceWeaponFactoryId).toFunction(katanaFactory); // IMPORTANT!\n    const ninja = container.get<Ninja>(ninjaId);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(typeof ninja.shortDistanceWeaponFactory === \"function\").eql(true);\n    expect(ninja.shortDistanceWeaponFactory() instanceof Katana).eql(true);\n    expect(ninja.shortDistanceWeaponFactory().handler instanceof KatanaHandler).eql(true);\n    expect(ninja.shortDistanceWeaponFactory().blade instanceof KatanaBlade).eql(true);\n    expect(ninja.longDistanceWeapon instanceof Shuriken).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of class constructors","suites":["InversifyJS"],"updatePoint":{"line":669,"column":56},"line":669,"code":"  it(\"Should support the injection of class constructors\", () => {\n\n    interface Katana {\n      hit(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Ninja {\n\n      private _katana: Katana;\n\n      public constructor(\n        @inject(\"Newable<Katana>\") katana: interfaces.Newable<Katana>\n      ) {\n        this._katana = new katana();\n      }\n\n      public fight() { return this._katana.hit(); }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<interfaces.Newable<Katana>>(\"Newable<Katana>\").toConstructor<Katana>(Katana);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of user defined factories","suites":["InversifyJS"],"updatePoint":{"line":706,"column":60},"line":706,"code":"  it(\"Should support the injection of user defined factories\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class NinjaWithUserDefinedFactory implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Factory<Katana>\") katanaFactory: () => Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this._katana = katanaFactory();\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(NinjaWithUserDefinedFactory);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<interfaces.Factory<Katana>>(\"Factory<Katana>\").toFactory<Katana>((context) =>\n      () =>\n        context.container.get<Katana>(\"Katana\"));\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of user defined factories with args","suites":["InversifyJS"],"updatePoint":{"line":769,"column":70},"line":769,"code":"  it(\"Should support the injection of user defined factories with args\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Weapon {\n      use(): string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public use() {\n        return \"katana!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public use() {\n        return \"shuriken!\";\n      }\n    }\n\n    @injectable()\n    class NinjaWithUserDefinedFactory implements Ninja {\n\n      private _katana: Weapon;\n      private _shuriken: Weapon;\n\n      public constructor(\n        @inject(\"Factory<Weapon>\") weaponFactory: (throwable: boolean) => Weapon\n      ) {\n        this._katana = weaponFactory(false);\n        this._shuriken = weaponFactory(true);\n      }\n\n      public fight() { return this._katana.use(); }\n      public sneak() { return this._shuriken.use(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(NinjaWithUserDefinedFactory);\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(\"throwable\", true);\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetTagged(\"throwable\", false);\n\n    container.bind<interfaces.Factory<Weapon>>(\"Factory<Weapon>\").toFactory<Weapon, [boolean]>((context) =>\n      (throwable: boolean) =>\n        context.container.getTagged<Weapon>(\"Weapon\", \"throwable\", throwable));\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"katana!\");\n    expect(ninja.sneak()).eql(\"shuriken!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of user defined factories with partial application","suites":["InversifyJS"],"updatePoint":{"line":828,"column":85},"line":828,"code":"  it(\"Should support the injection of user defined factories with partial application\", () => {\n\n    interface InjectorPump { }\n\n    @injectable()\n    class InjectorPump implements InjectorPump { }\n\n    interface SparkPlugs { }\n\n    @injectable()\n    class SparkPlugs implements SparkPlugs { }\n\n    class Engine {\n      public displacement!: number | null;\n    }\n\n    @injectable()\n    class DieselEngine implements Engine {\n      public displacement: number | null;\n      private _injectorPump: InjectorPump;\n      public constructor(\n        @inject(\"InjectorPump\") injectorPump: InjectorPump\n      ) {\n        this._injectorPump = injectorPump;\n        this.displacement = null;\n      }\n      public debug() {\n        return this._injectorPump;\n      }\n    }\n\n    @injectable()\n    class PetrolEngine implements Engine {\n      public displacement: number | null;\n      private _sparkPlugs: SparkPlugs;\n      public constructor(\n        @inject(\"SparkPlugs\") sparkPlugs: SparkPlugs\n      ) {\n        this._sparkPlugs = sparkPlugs;\n        this.displacement = null;\n      }\n      public debug() {\n        return this._sparkPlugs;\n      }\n    }\n\n    interface CarFactory {\n      createEngine(displacement: number): Engine;\n    }\n\n    @injectable()\n    class DieselCarFactory implements CarFactory {\n      private _dieselFactory: (displacement: number) => Engine;\n      public constructor(\n        @inject(\"Factory<Engine>\") factory: (category: string) => (displacement: number) => Engine\n      ) {\n        this._dieselFactory = factory(\"diesel\");\n      }\n      public createEngine(displacement: number): Engine {\n        return this._dieselFactory(displacement);\n      }\n    }\n\n    const container = new Container();\n    container.bind<SparkPlugs>(\"SparkPlugs\").to(SparkPlugs);\n    container.bind<InjectorPump>(\"InjectorPump\").to(InjectorPump);\n    container.bind<Engine>(\"Engine\").to(PetrolEngine).whenTargetNamed(\"petrol\");\n    container.bind<Engine>(\"Engine\").to(DieselEngine).whenTargetNamed(\"diesel\");\n\n    container.bind<interfaces.Factory<Engine>>(\"Factory<Engine>\").toFactory<Engine, [string], [number]>((context: interfaces.Context) =>\n      (theNamed: string) => (displacement: number) => {\n        const theEngine = context.container.getNamed<Engine>(\"Engine\", theNamed);\n        theEngine.displacement = displacement;\n        return theEngine;\n      });\n\n    container.bind<CarFactory>(\"DieselCarFactory\").to(DieselCarFactory);\n\n    const dieselCarFactory = container.get<CarFactory>(\"DieselCarFactory\");\n    const engine = dieselCarFactory.createEngine(300);\n\n    expect(engine.displacement).eql(300);\n    expect(engine instanceof DieselEngine).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of auto factories","suites":["InversifyJS"],"updatePoint":{"line":914,"column":52},"line":914,"code":"  it(\"Should support the injection of auto factories\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    interface Shuriken {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class NinjaWithAutoFactory implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Factory<Katana>\") katanaAutoFactory: () => Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this._katana = katanaAutoFactory();\n        this._shuriken = shuriken;\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(NinjaWithAutoFactory);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<interfaces.Factory<Katana>>(\"Factory<Katana>\").toAutoFactory<Katana>(\"Katana\");\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of auto named factories","suites":["InversifyJS"],"updatePoint":{"line":975,"column":58},"line":975,"code":"  it(\"Should support the injection of auto named factories\", () => {\n\n    interface Ninja {\n      fight(): string;\n      sneak(): string;\n    }\n    interface Weapon { }\n\n    interface Katana extends Weapon {\n      hit(): string;\n    }\n\n    interface Shuriken extends Weapon {\n      throw(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Shuriken {\n      public throw() {\n        return \"hit!\";\n      }\n    }\n\n    @injectable()\n    class NinjaWithAutoNamedFactory implements Ninja {\n\n      private _katana: Katana;\n      private _shuriken: Shuriken;\n\n      public constructor(\n        @inject(\"Factory<Weapon>\") weaponFactory: <TWeapon extends Weapon = Weapon>(named: string) => TWeapon\n      ) {\n        this._katana = weaponFactory<Katana>(\"katana\");\n        this._shuriken = weaponFactory<Shuriken>(\"shuriken\");\n      }\n\n      public fight() { return this._katana.hit(); }\n      public sneak() { return this._shuriken.throw(); }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(NinjaWithAutoNamedFactory);\n    container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"katana\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetNamed(\"shuriken\");\n    container.bind<interfaces.Factory<Weapon>>(\"Factory<Weapon>\").toAutoNamedFactory<Weapon>(\"Weapon\");\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of providers","suites":["InversifyJS"],"updatePoint":{"line":1038,"column":47},"line":1038,"code":"  it(\"Should support the injection of providers\", (done) => {\n\n    type KatanaProvider = () => Promise<Katana>;\n\n    interface Ninja {\n      katana: Katana | null;\n      katanaProvider: KatanaProvider;\n    }\n\n    interface Katana {\n      hit(): string;\n    }\n\n    @injectable()\n    class Katana implements Katana {\n      public hit() {\n        return \"cut!\";\n      }\n    }\n\n    @injectable()\n    class NinjaWithProvider implements Ninja {\n\n      public katana: Katana | null;\n      public katanaProvider: KatanaProvider;\n\n      public constructor(\n        @inject(\"Provider<Katana>\") katanaProvider: KatanaProvider\n      ) {\n        this.katanaProvider = katanaProvider;\n        this.katana = null;\n      }\n\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(NinjaWithProvider);\n    container.bind<Katana>(\"Katana\").to(Katana);\n\n    container.bind<KatanaProvider>(\"Provider<Katana>\").toProvider<Katana>((context: interfaces.Context) =>\n      () =>\n        new Promise<Katana>((resolve) => {\n          const katana = context.container.get<Katana>(\"Katana\");\n          resolve(katana);\n        }));\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    ninja.katanaProvider()\n      .then((katana) => {\n        ninja.katana = katana;\n        expect(ninja.katana.hit()).eql(\"cut!\");\n        done();\n      })\n      .catch((e) => { /* do nothing */ });\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values","suites":["InversifyJS","Injection of multiple values with string as keys"],"updatePoint":{"line":1098,"column":55},"line":1098,"code":"    it(\"Should support the injection of multiple values\", () => {\n\n      const warriorId = \"Warrior\";\n      const weaponId = \"Weapon\";\n\n      interface Weapon {\n        name: string;\n      }\n\n      @injectable()\n      class Katana implements Weapon {\n        public name = \"Katana\";\n      }\n\n      @injectable()\n      class Shuriken implements Weapon {\n        public name = \"Shuriken\";\n      }\n\n      interface Warrior {\n        katana: Weapon;\n        shuriken: Weapon;\n      }\n\n      @injectable()\n      class Ninja implements Warrior {\n        public katana: Weapon;\n        public shuriken: Weapon;\n        public constructor(@multiInject(weaponId) weapons: Weapon[]) {\n          this.katana = weapons[0] as Weapon;\n          this.shuriken = weapons[1] as Weapon;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Warrior>(warriorId).to(Ninja);\n      container.bind<Weapon>(weaponId).to(Katana);\n      container.bind<Weapon>(weaponId).to(Shuriken);\n\n      const ninja = container.get<Warrior>(warriorId);\n      expect(ninja.katana.name).eql(\"Katana\");\n      expect(ninja.shuriken.name).eql(\"Shuriken\");\n\n      // if only one value is bound to Weapon\n      const container2 = new Container();\n      container2.bind<Warrior>(warriorId).to(Ninja);\n      container2.bind<Weapon>(weaponId).to(Katana);\n\n      const ninja2 = container2.get<Warrior>(warriorId);\n      expect(ninja2.katana.name).eql(\"Katana\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested inject","suites":["InversifyJS","Injection of multiple values with string as keys"],"updatePoint":{"line":1151,"column":74},"line":1151,"code":"    it(\"Should support the injection of multiple values with nested inject\", () => {\n\n      interface Ninja {\n        fight(): string;\n        sneak(): string;\n      }\n\n      interface Katana {\n        hit(): string;\n      }\n\n      interface Shuriken {\n        throw(): string;\n      }\n\n      @injectable()\n      class Katana implements Katana {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken implements Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja implements Ninja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          @inject(\"Katana\") katana: Katana,\n          @inject(\"Shuriken\") shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      interface School {\n        ninjaMaster: Ninja;\n        student: Ninja;\n      }\n\n      @injectable()\n      class NinjaSchool implements School {\n        public ninjaMaster: Ninja;\n        public student: Ninja;\n\n        public constructor(\n          @multiInject(\"Ninja\") ninja: Ninja[]\n        ) {\n          this.ninjaMaster = ninja[0] as Ninja;\n          this.student = ninja[1] as Ninja;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Katana>(\"Katana\").to(Katana);\n      container.bind<Shuriken>(\"Shuriken\").to(Shuriken);\n      container.bind<Ninja>(\"Ninja\").to(Ninja);\n      container.bind<Ninja>(\"Ninja\").to(Ninja);\n      container.bind<School>(\"School\").to(NinjaSchool);\n\n      const ninjaSchool = container.get<School>(\"School\");\n      expect(ninjaSchool.ninjaMaster.fight()).eql(\"cut!\");\n      expect(ninjaSchool.ninjaMaster.sneak()).eql(\"hit!\");\n\n      expect(ninjaSchool.student.fight()).eql(\"cut!\");\n      expect(ninjaSchool.student.sneak()).eql(\"hit!\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested multiInject","suites":["InversifyJS","Injection of multiple values with string as keys"],"updatePoint":{"line":1233,"column":79},"line":1233,"code":"    it(\"Should support the injection of multiple values with nested multiInject\", () => {\n\n      const warriorId = \"Warrior\";\n      const swordId = \"Sword\";\n      const shurikenId = \"Shuriken\";\n      const schoolId = \"School\";\n      const organisationId = \"Organisation\";\n\n      interface Warrior {\n        fight(): string;\n        sneak(): string;\n      }\n\n      interface Sword {\n        hit(): string;\n      }\n\n      interface Shuriken {\n        throw(): string;\n      }\n\n      @injectable()\n      class Katana implements Sword {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken implements Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja implements Warrior {\n\n        private _katana: Sword;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          @inject(swordId) katana: Sword,\n          @inject(shurikenId) shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      interface School {\n        ninjaMaster: Warrior;\n        student: Warrior;\n      }\n\n      @injectable()\n      class NinjaSchool implements School {\n\n        public ninjaMaster: Warrior;\n        public student: Warrior;\n\n        public constructor(\n          @multiInject(warriorId) ninjas: Ninja[]\n        ) {\n          this.ninjaMaster = ninjas[0] as Ninja;\n          this.student = ninjas[1] as Ninja;\n        }\n      }\n\n      interface Organisation {\n        schools: School[];\n      }\n\n      @injectable()\n      class NinjaOrganisation implements Organisation {\n        public schools: School[];\n\n        public constructor(\n          @multiInject(schoolId) schools: School[]\n        ) {\n          this.schools = schools;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Sword>(swordId).to(Katana);\n      container.bind<Shuriken>(shurikenId).to(Shuriken);\n      container.bind<Warrior>(warriorId).to(Ninja);\n      container.bind<Warrior>(warriorId).to(Ninja);\n      container.bind<School>(schoolId).to(NinjaSchool);\n      container.bind<School>(schoolId).to(NinjaSchool);\n      container.bind<Organisation>(organisationId).to(NinjaOrganisation);\n\n      const ninjaOrganisation = container.get<Organisation>(organisationId);\n\n      for (let i = 0; i < 2; i++) {\n        const ithNinjaOrganizationSchool = ninjaOrganisation.schools[i] as School;\n\n        expect(ithNinjaOrganizationSchool.ninjaMaster.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.ninjaMaster.sneak()).eql(\"hit!\");\n        expect(ithNinjaOrganizationSchool.student.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.student.sneak()).eql(\"hit!\");\n      }\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values when using classes as keys","suites":["InversifyJS","Injection of multiple values with class as keys"],"updatePoint":{"line":1345,"column":82},"line":1345,"code":"    it(\"Should support the injection of multiple values when using classes as keys\", () => {\n\n      @injectable()\n      class Weapon {\n        public name!: string;\n      }\n\n      @injectable()\n      class Katana extends Weapon {\n        public constructor() {\n          super();\n          this.name = \"Katana\";\n        }\n      }\n\n      @injectable()\n      class Shuriken extends Weapon {\n        public constructor() {\n          super();\n          this.name = \"Shuriken\";\n        }\n      }\n\n      @injectable()\n      class Ninja {\n        public katana: Weapon;\n        public shuriken: Weapon;\n        public constructor(@multiInject(Weapon) weapons: Weapon[]) {\n          this.katana = weapons[0] as Weapon;\n          this.shuriken = weapons[1] as Weapon;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Ninja>(Ninja).to(Ninja);\n      container.bind<Weapon>(Weapon).to(Katana);\n      container.bind<Weapon>(Weapon).to(Shuriken);\n\n      const ninja = container.get<Ninja>(Ninja);\n      expect(ninja.katana.name).eql(\"Katana\");\n      expect(ninja.shuriken.name).eql(\"Shuriken\");\n\n      // if only one value is bound to Weapon\n      const container2 = new Container();\n      container2.bind<Ninja>(Ninja).to(Ninja);\n      container2.bind<Weapon>(Weapon).to(Katana);\n\n      const ninja2 = container2.get<Ninja>(Ninja);\n      expect(ninja2.katana.name).eql(\"Katana\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested inject","suites":["InversifyJS","Injection of multiple values with class as keys"],"updatePoint":{"line":1397,"column":74},"line":1397,"code":"    it(\"Should support the injection of multiple values with nested inject\", () => {\n\n      @injectable()\n      class Katana {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          katana: Katana,\n          shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      @injectable()\n      class NinjaSchool {\n        public ninjaMaster: Ninja;\n        public student: Ninja;\n\n        public constructor(\n          @multiInject(Ninja) ninja: Ninja[]\n        ) {\n          this.ninjaMaster = ninja[0] as Ninja;\n          this.student = ninja[1] as Ninja;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Katana>(Katana).to(Katana);\n      container.bind<Shuriken>(Shuriken).to(Shuriken);\n      container.bind<Ninja>(Ninja).to(Ninja);\n      container.bind<Ninja>(Ninja).to(Ninja);\n      container.bind<NinjaSchool>(NinjaSchool).to(NinjaSchool);\n\n      const ninjaSchool = container.get<NinjaSchool>(NinjaSchool);\n      expect(ninjaSchool.ninjaMaster.fight()).eql(\"cut!\");\n      expect(ninjaSchool.ninjaMaster.sneak()).eql(\"hit!\");\n\n      expect(ninjaSchool.student.fight()).eql(\"cut!\");\n      expect(ninjaSchool.student.sneak()).eql(\"hit!\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested multiInject","suites":["InversifyJS","Injection of multiple values with class as keys"],"updatePoint":{"line":1461,"column":79},"line":1461,"code":"    it(\"Should support the injection of multiple values with nested multiInject\", () => {\n\n      @injectable()\n      class Katana {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          katana: Katana,\n          shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      @injectable()\n      class NinjaSchool {\n        public ninjaMaster: Ninja;\n        public student: Ninja;\n\n        public constructor(\n          @multiInject(Ninja) ninjas: Ninja[]\n        ) {\n          this.ninjaMaster = ninjas[0] as Ninja;\n          this.student = ninjas[1] as Ninja;\n        }\n      }\n\n      @injectable()\n      class NinjaOrganisation {\n        public schools: NinjaSchool[];\n\n        public constructor(\n          @multiInject(NinjaSchool) schools: NinjaSchool[]\n        ) {\n          this.schools = schools;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Katana>(Katana).to(Katana);\n      container.bind<Shuriken>(Shuriken).to(Shuriken);\n      container.bind<Ninja>(Ninja).to(Ninja);\n      container.bind<Ninja>(Ninja).to(Ninja);\n      container.bind<NinjaSchool>(NinjaSchool).to(NinjaSchool);\n      container.bind<NinjaSchool>(NinjaSchool).to(NinjaSchool);\n      container.bind<NinjaOrganisation>(NinjaOrganisation).to(NinjaOrganisation);\n\n      const ninjaOrganisation = container.get<NinjaOrganisation>(NinjaOrganisation);\n\n      for (let i = 0; i < 2; i++) {\n        const ithNinjaOrganizationSchool = ninjaOrganisation.schools[i] as NinjaSchool;\n\n        expect(ithNinjaOrganizationSchool.ninjaMaster.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.ninjaMaster.sneak()).eql(\"hit!\");\n        expect(ithNinjaOrganizationSchool.student.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.student.sneak()).eql(\"hit!\");\n      }\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values when using Symbols as keys","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1545,"column":82},"line":1545,"code":"    it(\"Should support the injection of multiple values when using Symbols as keys\", () => {\n\n      const TYPES = {\n        Warrior: Symbol.for(\"Warrior\"),\n        Weapon: Symbol.for(\"Weapon\")\n      };\n\n      interface Weapon {\n        name: string;\n      }\n\n      @injectable()\n      class Katana implements Weapon {\n        public name = \"Katana\";\n      }\n\n      @injectable()\n      class Shuriken implements Weapon {\n        public name = \"Shuriken\";\n      }\n\n      interface Warrior {\n        katana: Weapon;\n        shuriken: Weapon;\n      }\n\n      @injectable()\n      class Ninja implements Warrior {\n        public katana: Weapon;\n        public shuriken: Weapon;\n        public constructor(@multiInject(TYPES.Weapon) weapons: Weapon[]) {\n          this.katana = weapons[0] as Weapon;\n          this.shuriken = weapons[1] as Weapon;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Warrior>(TYPES.Warrior).to(Ninja);\n      container.bind<Weapon>(TYPES.Weapon).to(Katana);\n      container.bind<Weapon>(TYPES.Weapon).to(Shuriken);\n\n      const ninja = container.get<Warrior>(TYPES.Warrior);\n      expect(ninja.katana.name).eql(\"Katana\");\n      expect(ninja.shuriken.name).eql(\"Shuriken\");\n\n      // if only one value is bound to Weapon\n      const container2 = new Container();\n      container2.bind<Warrior>(TYPES.Warrior).to(Ninja);\n      container2.bind<Weapon>(TYPES.Weapon).to(Katana);\n\n      const ninja2 = container2.get<Warrior>(TYPES.Warrior);\n      expect(ninja2.katana.name).eql(\"Katana\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested inject","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1600,"column":74},"line":1600,"code":"    it(\"Should support the injection of multiple values with nested inject\", () => {\n\n      const TYPES = {\n        Katana: Symbol.for(\"Katana\"),\n        Ninja: Symbol.for(\"Ninja\"),\n        School: Symbol.for(\"School\"),\n        Shuriken: Symbol.for(\"Shuriken\"),\n      };\n\n      interface Ninja {\n        fight(): string;\n        sneak(): string;\n      }\n\n      interface Katana {\n        hit(): string;\n      }\n\n      interface Shuriken {\n        throw(): string;\n      }\n\n      @injectable()\n      class Katana implements Katana {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken implements Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja implements Ninja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          @inject(TYPES.Katana) katana: Katana,\n          @inject(TYPES.Shuriken) shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      interface School {\n        ninjaMaster: Ninja;\n        student: Ninja;\n      }\n\n      @injectable()\n      class NinjaSchool implements School {\n        public ninjaMaster: Ninja;\n        public student: Ninja;\n\n        public constructor(\n          @multiInject(TYPES.Ninja) ninja: Ninja[]\n        ) {\n          this.ninjaMaster = ninja[0] as Ninja;\n          this.student = ninja[1] as Ninja;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Katana>(TYPES.Katana).to(Katana);\n      container.bind<Shuriken>(TYPES.Shuriken).to(Shuriken);\n      container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n      container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n      container.bind<School>(TYPES.School).to(NinjaSchool);\n\n      const ninjaSchool = container.get<School>(TYPES.School);\n      expect(ninjaSchool.ninjaMaster.fight()).eql(\"cut!\");\n      expect(ninjaSchool.ninjaMaster.sneak()).eql(\"hit!\");\n\n      expect(ninjaSchool.student.fight()).eql(\"cut!\");\n      expect(ninjaSchool.student.sneak()).eql(\"hit!\");\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of multiple values with nested multiInject","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1689,"column":79},"line":1689,"code":"    it(\"Should support the injection of multiple values with nested multiInject\", () => {\n\n      const TYPES = {\n        Katana: Symbol.for(\"Katana\"),\n        Ninja: Symbol.for(\"Ninja\"),\n        Organisation: Symbol.for(\"Organisation\"),\n        School: Symbol.for(\"School\"),\n        Shuriken: Symbol.for(\"Shuriken\"),\n      };\n\n      interface Ninja {\n        fight(): string;\n        sneak(): string;\n      }\n\n      interface Katana {\n        hit(): string;\n      }\n\n      interface Shuriken {\n        throw(): string;\n      }\n\n      @injectable()\n      class Katana implements Katana {\n        public hit() {\n          return \"cut!\";\n        }\n      }\n\n      @injectable()\n      class Shuriken implements Shuriken {\n        public throw() {\n          return \"hit!\";\n        }\n      }\n\n      @injectable()\n      class Ninja implements Ninja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n          @inject(TYPES.Katana) katana: Katana,\n          @inject(TYPES.Shuriken) shuriken: Shuriken\n        ) {\n          this._katana = katana;\n          this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); }\n        public sneak() { return this._shuriken.throw(); }\n\n      }\n\n      interface School {\n        ninjaMaster: Ninja;\n        student: Ninja;\n      }\n\n      @injectable()\n      class NinjaSchool implements School {\n        public ninjaMaster: Ninja;\n        public student: Ninja;\n\n        public constructor(\n          @multiInject(TYPES.Ninja) ninjas: Ninja[]\n        ) {\n          this.ninjaMaster = ninjas[0] as Ninja;\n          this.student = ninjas[1] as Ninja;\n        }\n      }\n\n      interface Organisation {\n        schools: NinjaSchool[];\n      }\n\n      @injectable()\n      class NinjaOrganisation implements Organisation {\n        public schools: NinjaSchool[];\n\n        public constructor(\n          @multiInject(TYPES.School) schools: School[]\n        ) {\n          this.schools = schools;\n        }\n      }\n\n      const container = new Container();\n      container.bind<Katana>(TYPES.Katana).to(Katana);\n      container.bind<Shuriken>(TYPES.Shuriken).to(Shuriken);\n      container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n      container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n      container.bind<School>(TYPES.School).to(NinjaSchool);\n      container.bind<School>(TYPES.School).to(NinjaSchool);\n      container.bind<Organisation>(TYPES.Organisation).to(NinjaOrganisation);\n\n      const ninjaOrganisation = container.get<Organisation>(TYPES.Organisation);\n\n      for (let i = 0; i < 2; i++) {\n        const ithNinjaOrganizationSchool = ninjaOrganisation.schools[i] as School;\n\n        expect(ithNinjaOrganizationSchool.ninjaMaster.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.ninjaMaster.sneak()).eql(\"hit!\");\n        expect(ithNinjaOrganizationSchool.student.fight()).eql(\"cut!\");\n        expect(ithNinjaOrganizationSchool.student.sneak()).eql(\"hit!\");\n      }\n\n    });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support tagged bindings","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1801,"column":36},"line":1801,"code":"  it(\"Should support tagged bindings\", () => {\n\n    enum Tag { CanThrow }\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @tagged(\"canThrow\", false) katana: Weapon,\n        @inject(\"Weapon\") @tagged(Tag.CanThrow, true) shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetTagged(\"canThrow\", false);\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(Tag.CanThrow, true);\n\n    const ninja = container.get<Warrior>(\"Warrior\");\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support custom tag decorators","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1842,"column":42},"line":1842,"code":"  it(\"Should support custom tag decorators\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    const throwable = tagged(\"canThrow\", true);\n    const notThrowable = tagged(\"canThrow\", false);\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @notThrowable katana: Weapon,\n        @inject(\"Weapon\") @throwable shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetTagged(\"canThrow\", false);\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(\"canThrow\", true);\n\n    const ninja = container.get<Warrior>(\"Warrior\");\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support named bindings","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1884,"column":35},"line":1884,"code":"  it(\"Should support named bindings\", () => {\n\n    const name: symbol = Symbol.for(\"Weak\");\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @named(\"strong\") katana: Weapon,\n        @inject(\"Weapon\") @named(name) shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"strong\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetNamed(name);\n\n    const ninja = container.get<Warrior>(\"Warrior\");\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support contextual bindings and targetName annotation","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1925,"column":66},"line":1925,"code":"  it(\"Should support contextual bindings and targetName annotation\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"katana\") katana: Weapon,\n        @inject(\"Weapon\") @targetName(\"shuriken\") shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n\n    container.bind<Weapon>(\"Weapon\").to(Katana).when((request: interfaces.Request) =>\n      request !== null && request.target !== null && request.target.name.equals(\"katana\"));\n\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).when((request: interfaces.Request) =>\n      request !== null && request.target !== null && request.target.name.equals(\"shuriken\"));\n\n    const ninja = container.get<Warrior>(\"Warrior\");\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve a ambiguous binding by providing a named tag","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":1968,"column":76},"line":1968,"code":"  it(\"Should be able to resolve a ambiguous binding by providing a named tag\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"shuriken\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"japonese\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetNamed(\"chinese\");\n\n    const katana = container.getNamed<Weapon>(\"Weapon\", \"japonese\");\n    const shuriken = container.getNamed<Weapon>(\"Weapon\", \"chinese\");\n\n    expect(katana.name).eql(\"katana\");\n    expect(shuriken.name).eql(\"shuriken\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve a ambiguous binding by providing a custom tag","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2002,"column":77},"line":2002,"code":"  it(\"Should be able to resolve a ambiguous binding by providing a custom tag\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"katana\";\n      }\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"shuriken\";\n      }\n    }\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetTagged(\"faction\", \"samurai\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(\"faction\", \"ninja\");\n\n    const katana = container.getTagged<Weapon>(\"Weapon\", \"faction\", \"samurai\");\n    const shuriken = container.getTagged<Weapon>(\"Weapon\", \"faction\", \"ninja\");\n\n    expect(katana.name).eql(\"katana\");\n    expect(shuriken.name).eql(\"shuriken\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject into a super constructor","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2036,"column":55},"line":2036,"code":"  it(\"Should be able to inject into a super constructor\", () => {\n\n    const SYMBOLS = {\n      Samurai: Symbol.for(\"Samurai\"),\n      SamuraiMaster: Symbol.for(\"SamuraiMaster\"),\n      SamuraiMaster2: Symbol.for(\"SamuraiMaster2\"),\n      Weapon: Symbol.for(\"Weapon\")\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    interface Warrior {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"katana\";\n      }\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public weapon: Weapon;\n\n      public constructor(weapon: Weapon) {\n        this.weapon = weapon;\n      }\n    }\n\n    // Important: derived classes constructor must be manually implemented and annotated\n    // Therefore the following will fail\n    @injectable()\n    class SamuraiMaster extends Samurai implements Warrior {\n      public isMaster!: boolean;\n    }\n\n    // However, he following will work\n    @injectable()\n    class SamuraiMaster2 extends Samurai implements Warrior {\n      public isMaster: boolean;\n      public constructor(@inject(SYMBOLS.Weapon) weapon: Weapon) {\n        super(weapon);\n        this.isMaster = true;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Weapon>(SYMBOLS.Weapon).to(Katana);\n    container.bind<Warrior>(SYMBOLS.Samurai).to(Samurai);\n    container.bind<Warrior>(SYMBOLS.SamuraiMaster).to(SamuraiMaster);\n    container.bind<Warrior>(SYMBOLS.SamuraiMaster2).to(SamuraiMaster2);\n\n    const errorFunction = () => { container.get<Warrior>(SYMBOLS.SamuraiMaster); };\n    const error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(\"SamuraiMaster\");\n    expect(errorFunction).to.throw(error);\n\n    const samuraiMaster2 = container.get<SamuraiMaster2>(SYMBOLS.SamuraiMaster2);\n    expect(samuraiMaster2.weapon.name).eql(\"katana\");\n    expect(typeof samuraiMaster2.isMaster).eql(\"boolean\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should allow to flag arguments as unmanaged","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2104,"column":49},"line":2104,"code":"  it(\"Should allow to flag arguments as unmanaged\", () => {\n\n    const container = new Container();\n\n    // CASE 1: should throw\n\n    const Base1Id = \"Base1\";\n\n    @injectable()\n    class Base1 {\n      public prop: string;\n      public constructor(arg: string) {\n        this.prop = arg;\n      }\n    }\n\n    @injectable()\n    class Derived1 extends Base1 {\n      public constructor() {\n        super(\"unmanaged-injected-value\");\n      }\n    }\n\n    container.bind<Base1>(Base1Id).to(Derived1);\n    const tryGet = () => { container.get(Base1Id); };\n    const error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(\"Derived1\");\n    expect(tryGet).to.throw(error);\n\n    // CASE 2: Use @unmanaged to overcome issue\n\n    const Base2Id = \"Base2\";\n\n    @injectable()\n    class Base2 {\n      public prop1: string;\n      public constructor(@unmanaged() arg1: string) {\n        this.prop1 = arg1;\n      }\n    }\n\n    @injectable()\n    class Derived2 extends Base2 {\n      public constructor() {\n        super(\"unmanaged-injected-value\");\n      }\n    }\n\n    container.bind<Base2>(Base2Id).to(Derived2);\n    const derived1 = container.get<Base2>(Base2Id);\n    expect(derived1 instanceof Derived2).to.eql(true);\n    expect(derived1.prop1).to.eql(\"unmanaged-injected-value\");\n\n    // CASE 3: Use @unmanaged to overcome issue when multiple args\n\n    const Base3Id = \"Base3\";\n\n    @injectable()\n    class Base3 {\n      public prop1: string;\n      public prop2: string;\n      public constructor(@unmanaged() arg1: string, arg2: string) {\n        this.prop1 = arg1;\n        this.prop2 = arg2;\n      }\n    }\n\n    @injectable()\n    class Derived3 extends Base3 {\n      public constructor(@inject(\"SomeId\") arg1: string) {\n        super(\"unmanaged-injected-value\", arg1);\n      }\n    }\n\n    container.bind<Base3>(Base3Id).to(Derived3);\n    container.bind<string>(\"SomeId\").toConstantValue(\"managed-injected-value\");\n    const derived2 = container.get<Base3>(Base3Id);\n    expect(derived2 instanceof Base3).to.eql(true);\n    expect(derived2.prop1).to.eql(\"unmanaged-injected-value\");\n    expect(derived2.prop2).to.eql(\"managed-injected-value\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenInjectedInto contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2186,"column":70},"line":2186,"code":"  it(\"Should support a whenInjectedInto contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"katana\";\n      }\n    }\n\n    @injectable()\n    class Bokken implements Weapon {\n      public name: string;\n      public constructor() {\n        this.name = \"bokken\";\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Katana).whenInjectedInto(NinjaMaster);\n    container.bind<Weapon>(TYPES.Weapon).to(Bokken).whenInjectedInto(NinjaStudent);\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master instanceof NinjaMaster).eql(true);\n    expect(student instanceof NinjaStudent).eql(true);\n\n    expect(master.weapon.name).eql(\"katana\");\n    expect(student.weapon.name).eql(\"bokken\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenParentNamed contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2258,"column":69},"line":2258,"code":"  it(\"Should support a whenParentNamed contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @named(\"non-lethal\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @named(\"lethal\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenParentNamed(\"lethal\");\n    container.bind<Material>(TYPES.Material).to(Wood).whenParentNamed(\"non-lethal\");\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenParentTagged contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2341,"column":70},"line":2341,"code":"  it(\"Should support a whenParentTagged contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @tagged(\"lethal\", false) weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") @tagged(\"lethal\", true) weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenParentTagged(\"lethal\", true);\n    container.bind<Material>(TYPES.Material).to(Wood).whenParentTagged(\"lethal\", false);\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenAnyAncestorIs and whenNoAncestorIs contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2424,"column":92},"line":2424,"code":"  it(\"Should support a whenAnyAncestorIs and whenNoAncestorIs contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    // whenAnyAncestorIs\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenAnyAncestorIs(NinjaMaster);\n    container.bind<Material>(TYPES.Material).to(Wood).whenAnyAncestorIs(NinjaStudent);\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n    // whenNoAncestorIs\n    const container2 = new Container();\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container2.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container2.bind<Material>(TYPES.Material).to(Iron).whenNoAncestorIs(NinjaStudent);\n    container2.bind<Material>(TYPES.Material).to(Wood).whenNoAncestorIs(NinjaMaster);\n\n    const master2 = container2.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student2 = container2.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master2.weapon.material.name).eql(\"iron\");\n    expect(student2.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenAnyAncestorNamed and whenNoAncestorNamed contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2522,"column":98},"line":2522,"code":"  it(\"Should support a whenAnyAncestorNamed and whenNoAncestorNamed contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    // whenAnyAncestorNamed\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetNamed(\"non-lethal\");\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetNamed(\"lethal\");\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenAnyAncestorNamed(\"lethal\");\n    container.bind<Material>(TYPES.Material).to(Wood).whenAnyAncestorNamed(\"non-lethal\");\n\n    const master = container.getNamed<Ninja>(TYPES.Ninja, \"lethal\");\n    const student = container.getNamed<Ninja>(TYPES.Ninja, \"non-lethal\");\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n    // whenNoAncestorNamed\n    const container2 = new Container();\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetNamed(\"non-lethal\");\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetNamed(\"lethal\");\n    container2.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container2.bind<Material>(TYPES.Material).to(Iron).whenNoAncestorNamed(\"non-lethal\");\n    container2.bind<Material>(TYPES.Material).to(Wood).whenNoAncestorNamed(\"lethal\");\n\n    const master2 = container.getNamed<Ninja>(TYPES.Ninja, \"lethal\");\n    const student2 = container.getNamed<Ninja>(TYPES.Ninja, \"non-lethal\");\n\n    expect(master2.weapon.material.name).eql(\"iron\");\n    expect(student2.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenAnyAncestorTagged and whenNoAncestorTaggedcontextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2620,"column":99},"line":2620,"code":"  it(\"Should support a whenAnyAncestorTagged and whenNoAncestorTaggedcontextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    // whenAnyAncestorTagged\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"lethal\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"lethal\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenAnyAncestorTagged(\"lethal\", true);\n    container.bind<Material>(TYPES.Material).to(Wood).whenAnyAncestorTagged(\"lethal\", false);\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"lethal\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"lethal\", false);\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n    // whenNoAncestorTagged\n    const container2 = new Container();\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"lethal\", false);\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"lethal\", true);\n    container2.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container2.bind<Material>(TYPES.Material).to(Iron).whenNoAncestorTagged(\"lethal\", false);\n    container2.bind<Material>(TYPES.Material).to(Wood).whenNoAncestorTagged(\"lethal\", true);\n\n    const master2 = container.getTagged<Ninja>(TYPES.Ninja, \"lethal\", true);\n    const student2 = container.getTagged<Ninja>(TYPES.Ninja, \"lethal\", false);\n\n    expect(master2.weapon.material.name).eql(\"iron\");\n    expect(student2.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should support a whenAnyAncestorMatches and whenNoAncestorMatches contextual bindings constraint","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2718,"column":102},"line":2718,"code":"  it(\"Should support a whenAnyAncestorMatches and whenNoAncestorMatches contextual bindings constraint\", () => {\n\n    const TYPES = {\n      Material: \"Material\",\n      Ninja: \"Ninja\",\n      Weapon: \"Weapon\"\n    };\n\n    interface Material {\n      name: string;\n    }\n\n    @injectable()\n    class Wood implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"wood\";\n      }\n    }\n\n    @injectable()\n    class Iron implements Material {\n      public name: string;\n      public constructor() {\n        this.name = \"iron\";\n      }\n    }\n\n    interface Weapon {\n      material: Material;\n    }\n\n    @injectable()\n    class Sword implements Weapon {\n      public material: Material;\n      public constructor(@inject(\"Material\") material: Material) {\n        this.material = material;\n      }\n    }\n\n    interface Ninja {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class NinjaStudent implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    @injectable()\n    class NinjaMaster implements Ninja {\n\n      public weapon: Weapon;\n\n      public constructor(\n        @inject(\"Weapon\") weapon: Weapon\n      ) {\n        this.weapon = weapon;\n      }\n    }\n\n    // custom constraints\n    const anyAncestorIsNinjaMasterConstraint = typeConstraint(NinjaMaster);\n    const anyAncestorIsNinjaStudentConstraint = typeConstraint(NinjaStudent);\n\n    // whenAnyAncestorMatches\n    const container = new Container();\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container.bind<Material>(TYPES.Material).to(Iron).whenAnyAncestorMatches(anyAncestorIsNinjaMasterConstraint);\n    container.bind<Material>(TYPES.Material).to(Wood).whenAnyAncestorMatches(anyAncestorIsNinjaStudentConstraint);\n\n    const master = container.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student = container.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master.weapon.material.name).eql(\"iron\");\n    expect(student.weapon.material.name).eql(\"wood\");\n\n    // whenNoAncestorMatches\n    const container2 = new Container();\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaStudent).whenTargetTagged(\"master\", false);\n    container2.bind<Ninja>(TYPES.Ninja).to(NinjaMaster).whenTargetTagged(\"master\", true);\n    container2.bind<Weapon>(TYPES.Weapon).to(Sword);\n    container2.bind<Material>(TYPES.Material).to(Iron).whenNoAncestorMatches(anyAncestorIsNinjaStudentConstraint);\n    container2.bind<Material>(TYPES.Material).to(Wood).whenNoAncestorMatches(anyAncestorIsNinjaMasterConstraint);\n\n    const master2 = container2.getTagged<Ninja>(TYPES.Ninja, \"master\", true);\n    const student2 = container2.getTagged<Ninja>(TYPES.Ninja, \"master\", false);\n\n    expect(master2.weapon.material.name).eql(\"iron\");\n    expect(student2.weapon.material.name).eql(\"wood\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to inject a regular derived class","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2820,"column":54},"line":2820,"code":"  it(\"Should be able to inject a regular derived class\", () => {\n\n    const SYMBOLS = {\n      RANK: Symbol.for(\"RANK\"),\n      SamuraiMaster: Symbol.for(\"SamuraiMaster\")\n    };\n\n    interface Warrior {\n      rank: string;\n    }\n\n    @injectable()\n    class Samurai implements Warrior {\n\n      public rank: string;\n\n      public constructor(rank: string) {\n        this.rank = rank;\n      }\n    }\n\n    @injectable()\n    class SamuraiMaster extends Samurai implements Warrior {\n      public constructor(@inject(SYMBOLS.RANK) rank: string) {\n        super(rank);\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(SYMBOLS.SamuraiMaster).to(SamuraiMaster);\n    container.bind<string>(SYMBOLS.RANK).toConstantValue(\"Master\");\n\n    const samurai = container.get<SamuraiMaster>(SYMBOLS.SamuraiMaster);\n    expect(samurai.rank).eql(\"Master\");\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify missing @injectable in a base class","suites":["InversifyJS","Injection of multiple values with Symbol as keys"],"updatePoint":{"line":2857,"column":68},"line":2857,"code":"  it(\"Should be able to identify missing @injectable in a base class\", () => {\n\n    const SYMBOLS = {\n      SamuraiMaster: Symbol.for(\"SamuraiMaster\")\n    };\n\n    interface Warrior {\n      rank: string;\n    }\n\n    // IMPORTANT: Missing @injectable()\n    class Samurai implements Warrior {\n\n      public rank: string;\n\n      public constructor(rank: string) {\n        this.rank = rank;\n      }\n    }\n\n    @injectable()\n    class SamuraiMaster extends Samurai implements Warrior {\n      public constructor() {\n        super(\"master\");\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(SYMBOLS.SamuraiMaster).to(SamuraiMaster);\n\n    function throws() {\n      return container.get<Warrior>(SYMBOLS.SamuraiMaster);\n    }\n\n    expect(throws).to.throw(`${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} Samurai`);\n\n  });","file":"inversify.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use middleware as Container configuration","suites":["Middleware"],"updatePoint":{"line":20,"column":65},"line":20,"code":"  it(\"Should be able to use middleware as Container configuration\", () => {\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware1(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware1: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    container.applyMiddleware(middleware1);\n    const _container = container;\n    expect((_container as unknown as { _middleware: unknown })._middleware).not.to.eql(null);\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should support middleware","suites":["Middleware"],"updatePoint":{"line":39,"column":31},"line":39,"code":"  it(\"Should support middleware\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware1(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware1: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    function middleware2(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware2: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    // two middlewares applied at one single point in time\n    container.applyMiddleware(middleware1, middleware2);\n\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(log.length).eql(2);\n    expect(log[0]).eql(\"Middleware2: Ninja\");\n    expect(log[1]).eql(\"Middleware1: Ninja\");\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should allow applyMiddleware at multiple points in time","suites":["Middleware"],"updatePoint":{"line":78,"column":61},"line":78,"code":"  it(\"Should allow applyMiddleware at multiple points in time\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware1(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware1: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    function middleware2(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware2: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    container.applyMiddleware(middleware1); // one point in time\n    container.applyMiddleware(middleware2);  // another point in time\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(log.length).eql(2);\n    expect(log[0]).eql(\"Middleware2: Ninja\");\n    expect(log[1]).eql(\"Middleware1: Ninja\");\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should use middleware","suites":["Middleware"],"updatePoint":{"line":116,"column":27},"line":116,"code":"  it(\"Should use middleware\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware1(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware1: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    function middleware2(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        log.push(`Middleware2: ${args.serviceIdentifier.toString()}`);\n        return planAndResolve(args);\n      };\n    }\n\n    container.applyMiddleware(middleware1, middleware2);\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(log.length).eql(2);\n    expect(log[0]).eql(\"Middleware2: Ninja\");\n    expect(log[1]).eql(\"Middleware1: Ninja\");\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use middleware to catch errors during pre-planning phase","suites":["Middleware"],"updatePoint":{"line":153,"column":80},"line":153,"code":"  it(\"Should be able to use middleware to catch errors during pre-planning phase\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        try {\n          return planAndResolve(args);\n        } catch (e) {\n          log.push(e.message);\n          return [];\n        }\n      };\n    }\n\n    container.applyMiddleware(middleware);\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.get(\"SOME_NOT_REGISTERED_ID\");\n    expect(log.length).eql(1);\n    expect(log[0]).eql(`${ERROR_MSGS.NOT_REGISTERED} SOME_NOT_REGISTERED_ID`);\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use middleware to catch errors during planning phase","suites":["Middleware"],"updatePoint":{"line":183,"column":76},"line":183,"code":"  it(\"Should be able to use middleware to catch errors during planning phase\", () => {\n\n    interface Warrior { }\n\n    @injectable()\n    class Ninja implements Warrior { }\n\n    @injectable()\n    class Samurai implements Warrior { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        try {\n          return planAndResolve(args);\n        } catch (e) {\n          log.push(e.message);\n          return [];\n        }\n      };\n    }\n\n    container.applyMiddleware(middleware);\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n    container.bind<Warrior>(\"Warrior\").to(Samurai);\n\n    container.get(\"Warrior\");\n    expect(log.length).eql(1);\n    expect(log[0]).to.contain(`${ERROR_MSGS.AMBIGUOUS_MATCH} Warrior`);\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to use middleware to catch errors during resolution phase","suites":["Middleware"],"updatePoint":{"line":218,"column":78},"line":218,"code":"  it(\"Should be able to use middleware to catch errors during resolution phase\", () => {\n\n    interface Warrior { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        try {\n          return planAndResolve(args);\n        } catch (e) {\n          log.push(e.message);\n          return [];\n        }\n      };\n    }\n\n    container.applyMiddleware(middleware);\n    container.bind<Warrior>(\"Warrior\"); // Invalid binding missing BindingToSyntax\n\n    container.get(\"Warrior\");\n    expect(log.length).eql(1);\n    expect(log[0]).eql(`${ERROR_MSGS.INVALID_BINDING_TYPE} Warrior`);\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should help users to identify problems with middleware","suites":["Middleware"],"updatePoint":{"line":246,"column":60},"line":246,"code":"  it(\"Should help users to identify problems with middleware\", () => {\n\n    const container = new Container();\n\n    function middleware(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        try {\n          return planAndResolve(args);\n        } catch (e) {\n          // missing return!\n        }\n      };\n    }\n\n    container.applyMiddleware(middleware);\n    const throws = () => { container.get(\"SOME_NOT_REGISTERED_ID\"); };\n    expect(throws).to.throw(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should allow users to intercept a resolution context","suites":["Middleware"],"updatePoint":{"line":266,"column":58},"line":266,"code":"  it(\"Should allow users to intercept a resolution context\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n\n    const container = new Container();\n\n    const log: string[] = [];\n\n    function middleware1(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        const nextContextInterceptor = args.contextInterceptor;\n        args.contextInterceptor = (context: interfaces.Context) => {\n          log.push(`contextInterceptor1: ${args.serviceIdentifier.toString()}`);\n          return nextContextInterceptor !== null ? nextContextInterceptor(context) : context;\n        };\n        return planAndResolve(args);\n      };\n    }\n\n    function middleware2(planAndResolve: interfaces.Next): interfaces.Next {\n      return (args: interfaces.NextArgs) => {\n        const nextContextInterceptor = args.contextInterceptor;\n        args.contextInterceptor = (context: interfaces.Context) => {\n          log.push(`contextInterceptor2: ${args.serviceIdentifier.toString()}`);\n          return nextContextInterceptor !== null ? nextContextInterceptor(context) : context;\n        };\n        return planAndResolve(args);\n      };\n    }\n\n    container.applyMiddleware(middleware1, middleware2);\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n\n    const ninja = container.get<Ninja>(\"Ninja\");\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(log.length).eql(2);\n    expect(log[0]).eql(\"contextInterceptor1: Ninja\");\n    expect(log[1]).eql(\"contextInterceptor2: Ninja\");\n\n  });","file":"middleware/middleware.test.ts","skipped":false,"dir":"test"},{"name":"Should contain correct message and the serviceIdentifier in error message","suites":["Error message when resolving fails"],"updatePoint":{"line":17,"column":79},"line":17,"code":"  it(\"Should contain correct message and the serviceIdentifier in error message\", () => {\n    const container = new Container();\n\n    container.bind<Weapon>(\"Weapon\").to(Katana);\n\n    const tryWeapon = () => { container.get(\"Ninja\"); };\n\n    expect(tryWeapon).to.throw(`${ERROR_MSGS.NOT_REGISTERED} Ninja`);\n\n  });","file":"node/error_messages.test.ts","skipped":false,"dir":"test"},{"name":"Should contain the provided name in error message when target is named","suites":["Error message when resolving fails"],"updatePoint":{"line":28,"column":76},"line":28,"code":"  it(\"Should contain the provided name in error message when target is named\", () => {\n\n    const container = new Container();\n    const tryGetNamedWeapon = (name: string | number | symbol) => { container.getNamed(\"Weapon\", name); };\n\n    expect(() => tryGetNamedWeapon(\"superior\")).to.throw(/.*\\bWeapon\\b.*\\bsuperior\\b/g);\n    expect(() => tryGetNamedWeapon(Symbol.for(\"Superior\"))).to.throw(/.*\\bWeapon\\b.*Symbol\\(Superior\\)/g);\n    expect(() => tryGetNamedWeapon(0)).to.throw(/.*\\bWeapon\\b.*\\b0\\b/g);\n\n  });","file":"node/error_messages.test.ts","skipped":false,"dir":"test"},{"name":"Should contain the provided tag in error message when target is tagged","suites":["Error message when resolving fails"],"updatePoint":{"line":39,"column":76},"line":39,"code":"  it(\"Should contain the provided tag in error message when target is tagged\", () => {\n\n    const container = new Container();\n    const tryGetTaggedWeapon = (tag: string | number | symbol) => { container.getTagged(\"Weapon\", tag, true); };\n\n    expect(() => tryGetTaggedWeapon(\"canShoot\")).to.throw(/.*\\bWeapon\\b.*\\bcanShoot\\b.*\\btrue\\b/g);\n    expect(() => tryGetTaggedWeapon(Symbol.for(\"Can shoot\"))).to.throw(/.*\\bWeapon\\b.*Symbol\\(Can shoot\\).*\\btrue\\b/g);\n    expect(() => tryGetTaggedWeapon(0)).to.throw(/.*\\bWeapon\\b.*\\b0\\b.*\\btrue\\b/g);\n\n  });","file":"node/error_messages.test.ts","skipped":false,"dir":"test"},{"name":"Should list all possible bindings in error message if no matching binding found","suites":["Error message when resolving fails"],"updatePoint":{"line":50,"column":85},"line":50,"code":"  it(\"Should list all possible bindings in error message if no matching binding found\", () => {\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"strong\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(\"canThrow\", true);\n    container.bind<Weapon>(\"Weapon\").to(Bokken).whenTargetNamed(\"weak\");\n\n    try {\n      container.getNamed(\"Weapon\", \"superior\");\n    } catch (error) {\n      expect(error.message).to.match(/.*\\bKatana\\b.*\\bnamed\\b.*\\bstrong\\b/);\n      expect(error.message).to.match(/.*\\bBokken\\b.*\\bnamed\\b.*\\bweak\\b/);\n      expect(error.message).to.match(/.*\\bShuriken\\b.*\\btagged\\b.*\\bcanThrow\\b.*\\btrue\\b/);\n    }\n  });","file":"node/error_messages.test.ts","skipped":false,"dir":"test"},{"name":"Should list all possible bindings in error message if ambiguous matching binding found","suites":["Error message when resolving fails"],"updatePoint":{"line":66,"column":92},"line":66,"code":"  it(\"Should list all possible bindings in error message if ambiguous matching binding found\", () => {\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana).whenTargetNamed(\"strong\");\n    container.bind<Weapon>(\"Weapon\").to(Shuriken).whenTargetTagged(\"canThrow\", true);\n    container.bind<Weapon>(\"Weapon\").to(Bokken).whenTargetNamed(\"weak\");\n\n    try {\n      container.get(\"Weapon\");\n    } catch (error) {\n      expect(error.message).to.match(/.*\\bKatana\\b.*\\bnamed\\b.*\\bstrong\\b/);\n      expect(error.message).to.match(/.*\\bBokken\\b.*\\bnamed\\b.*\\bweak\\b/);\n      expect(error.message).to.match(/.*\\bShuriken\\b.*\\btagged\\b.*\\bcanThrow\\b.*\\btrue\\b/);\n    }\n\n  });","file":"node/error_messages.test.ts","skipped":false,"dir":"test"},{"name":"Should throw if circular dependencies found","suites":["Node"],"updatePoint":{"line":7,"column":49},"line":7,"code":"  it(\"Should throw if circular dependencies found\", () => {\n\n    interface IA { }\n    interface IB { }\n    interface IC { }\n    interface ID { }\n\n    @injectable()\n    class A implements IA {\n      public b: IB;\n      public c: IC;\n      public constructor(\n        @inject(\"B\") b: IB,\n        @inject(\"C\") c: IC,\n      ) {\n        this.b = b;\n        this.c = c;\n      }\n    }\n\n    @injectable()\n    class B implements IB { }\n\n    @injectable()\n    class C implements IC {\n      public d: ID;\n      public constructor(@inject(\"D\") d: ID) {\n        this.d = d;\n      }\n    }\n\n    @injectable()\n    class D implements ID {\n      public a: IA;\n      public constructor(@inject(\"A\") a: IA) {\n        this.a = a;\n      }\n    }\n\n    const container = new Container();\n    container.bind<A>(\"A\").to(A);\n    container.bind<B>(\"B\").to(B);\n    container.bind<C>(\"C\").to(C);\n    container.bind<D>(\"D\").to(D);\n\n    function willThrow() {\n      const a = container.get<A>(\"A\");\n      return a;\n    }\n\n    expect(willThrow).to.throw(\n      `${ERROR_MSGS.CIRCULAR_DEPENDENCY} A --> C --> D --> A`\n    );\n\n  });","file":"node/exceptions.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 1 binding in less than 1 ms","suites":["Performance"],"updatePoint":{"line":59,"column":60},"line":59,"code":"  it(\"Should be able to register 1 binding in less than 1 ms\", () => {\n    const result1 = registerN(1);\n    expect(result1.register).to.below(1);\n    expect(result1.register).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 5 bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":65,"column":61},"line":65,"code":"  it(\"Should be able to register 5 bindings in less than 1 ms\", () => {\n    const result5 = registerN(5);\n    expect(result5.register).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 1K bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":70,"column":62},"line":70,"code":"  it(\"Should be able to register 1K bindings in less than 1 ms\", () => {\n    const result1K = registerN(1000);\n    expect(result1K.register).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 5K bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":75,"column":62},"line":75,"code":"  it(\"Should be able to register 5K bindings in less than 1 ms\", () => {\n    const result5K = registerN(5000);\n    expect(result5K.register).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 1 bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":80,"column":61},"line":80,"code":"  it(\"Should be able to register 1 bindings in less than 1 ms\", () => {\n    const container1 = registerN(1000).container;\n    const result1 = resolveN(container1, 5);\n    expect(result1.avg).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 5 bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":86,"column":61},"line":86,"code":"  it(\"Should be able to register 5 bindings in less than 1 ms\", () => {\n    const container5 = registerN(1000).container;\n    const result5 = resolveN(container5, 5);\n    expect(result5.avg).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 1K bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":92,"column":62},"line":92,"code":"  it(\"Should be able to register 1K bindings in less than 1 ms\", () => {\n    const container1K = registerN(1000).container;\n    const result1K = resolveN(container1K, 5);\n    expect(result1K.avg).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 5K bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":98,"column":62},"line":98,"code":"  it(\"Should be able to register 5K bindings in less than 1 ms\", () => {\n    const container5K = registerN(5000).container;\n    const result5K = resolveN(container5K, 5);\n    expect(result5K.avg).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to register 10K bindings in less than 1 ms","suites":["Performance"],"updatePoint":{"line":104,"column":63},"line":104,"code":"  it(\"Should be able to register 10K bindings in less than 1 ms\", () => {\n    const container10K = registerN(10000).container;\n    const result10K = resolveN(container10K, 5);\n    expect(result10K.avg).to.below(1);\n  });","file":"node/performance.test.ts","skipped":false,"dir":"test"},{"name":"Should support the injection of proxied objects","suites":["InversifyJS"],"updatePoint":{"line":7,"column":53},"line":7,"code":"  it(\"Should support the injection of proxied objects\", () => {\n\n    const weaponId = \"Weapon\";\n    const warriorId = \"Warrior\";\n\n    interface Weapon {\n      use(): void;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public use() {\n        return \"Used Katana!\";\n      }\n    }\n\n    interface Warrior {\n      weapon: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public weapon: Weapon;\n      public constructor(@inject(weaponId) weapon: Weapon) {\n        this.weapon = weapon;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(warriorId).to(Ninja);\n    const log: string[] = [];\n\n    container.bind<Weapon>(weaponId).to(Katana).onActivation((context: interfaces.Context, weapon: Weapon) => {\n      const handler = {\n        apply(target: any, thisArgument: any, argumentsList: any[]) {\n          log.push(`Starting: ${new Date().getTime()}`);\n          const result = target.apply(thisArgument, argumentsList);\n          log.push(`Finished: ${new Date().getTime()}`);\n          return result;\n        }\n      };\n      weapon.use = new Proxy(weapon.use, handler);\n      return weapon;\n    });\n\n    const ninja = container.get<Warrior>(warriorId);\n    ninja.weapon.use();\n\n    expect(log.length).eql(2);\n    expect(log[0]?.indexOf(\"Starting: \")).not.to.eql(-1);\n    expect(log[1]?.indexOf(\"Finished: \")).not.to.eql(-1);\n\n  });","file":"node/proxies.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["Context"],"updatePoint":{"line":11,"column":45},"line":11,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    const container = new Container();\n    const context1 = new Context(container);\n    const invalid: any = null;\n    const context2: Context = new (Context)(invalid);\n\n    expect(context1.container).not.to.eql(null);\n    expect(context2.container).eql(null);\n    expect(context1.id).to.be.a(\"number\");\n    expect(context2.id).to.be.a(\"number\");\n    expect(context1.id).not.eql(context2.id);\n\n  });","file":"planning/context.test.ts","skipped":false,"dir":"test"},{"name":"Should be linkable to a Plan","suites":["Context"],"updatePoint":{"line":26,"column":34},"line":26,"code":"  it(\"Should be linkable to a Plan\", () => {\n\n    const container = new Container();\n    const context = new Context(container);\n    const target = new Target(TargetTypeEnum.Variable, \"\", \"Ninja\");\n\n    const ninjaRequest = new Request(\n      \"Ninja\",\n      context,\n      null,\n      [],\n      target\n    );\n\n    const plan = new Plan(context, ninjaRequest);\n    context.addPlan(plan);\n\n    expect(context.plan.rootRequest.serviceIdentifier).eql(\"Ninja\");\n  });","file":"planning/context.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["Metadata"],"updatePoint":{"line":6,"column":45},"line":6,"code":"  it(\"Should set its own properties correctly\", () => {\n    const m = new Metadata(\"power\", 5);\n    expect(m.key).to.equals(\"power\");\n    expect(m.value).to.equals(5);\n  });","file":"planning/metadata.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["Plan"],"updatePoint":{"line":11,"column":45},"line":11,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    const container = new Container();\n    const context = new Context(container);\n    const runtimeId = \"Something\";\n\n    const request: Request = new Request(\n      runtimeId,\n      context,\n      null,\n      [],\n      new Target(TargetTypeEnum.Variable, \"\", runtimeId)\n    );\n\n    const plan = new Plan(context, request);\n\n    expect(plan.parentContext).eql(context);\n    expect(plan.rootRequest.serviceIdentifier).eql(request.serviceIdentifier);\n    expect(plan.rootRequest.parentContext).eql(request.parentContext);\n    expect(plan.rootRequest.parentRequest).eql(request.parentRequest);\n    expect(plan.rootRequest.childRequests).eql(request.childRequests);\n    expect(plan.rootRequest.target).eql(request.target);\n  });","file":"planning/plan.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to create a basic plan","suites":["Planner"],"updatePoint":{"line":28,"column":43},"line":28,"code":"  it(\"Should be able to create a basic plan\", () => {\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface Katana { }\n\n    @injectable()\n    class Katana implements Katana {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(\n        @inject(\"KatanaHandler\") @targetName(\"handler\") handler: KatanaHandler,\n        @inject(\"KatanaBlade\") @targetName(\"blade\") blade: KatanaBlade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") @targetName(\"katana\") katana: Katana,\n        @inject(\"Shuriken\") @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaId = \"Katana\";\n    const katanaHandlerId = \"KatanaHandler\";\n    const katanaBladeId = \"KatanaBlade\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).to(Katana);\n    container.bind<KatanaBlade>(katanaBladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(katanaHandlerId).to(KatanaHandler);\n\n    // Actual\n    const actualPlan = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId).plan;\n    const actualNinjaRequest = actualPlan.rootRequest;\n    const actualKatanaRequest = actualNinjaRequest.childRequests[0];\n    const actualKatanaHandlerRequest = actualKatanaRequest?.childRequests[0];\n    const actualKatanaBladeRequest = actualKatanaRequest?.childRequests[1];\n    const actualShurikenRequest = actualNinjaRequest.childRequests[1];\n\n    expect(actualNinjaRequest.serviceIdentifier).eql(ninjaId);\n    expect(actualNinjaRequest.childRequests.length).eql(2);\n\n    // Katana\n    expect(actualKatanaRequest?.serviceIdentifier).eql(katanaId);\n    expect(actualKatanaRequest?.bindings.length).eql(1);\n    expect(actualKatanaRequest?.target.serviceIdentifier).eql(katanaId);\n    expect(actualKatanaRequest?.childRequests.length).eql(2);\n\n    // KatanaHandler\n    expect(actualKatanaHandlerRequest?.serviceIdentifier).eql(katanaHandlerId);\n    expect(actualKatanaHandlerRequest?.bindings.length).eql(1);\n    expect(actualKatanaHandlerRequest?.target.serviceIdentifier).eql(katanaHandlerId);\n\n    // KatanaBlade\n    expect(actualKatanaBladeRequest?.serviceIdentifier).eql(katanaBladeId);\n    expect(actualKatanaBladeRequest?.bindings.length).eql(1);\n    expect(actualKatanaBladeRequest?.target.serviceIdentifier).eql(katanaBladeId);\n\n    // Shuriken\n    expect(actualShurikenRequest?.serviceIdentifier).eql(shurikenId);\n    expect(actualShurikenRequest?.bindings.length).eql(1);\n    expect(actualShurikenRequest?.target.serviceIdentifier).eql(shurikenId);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when circular dependencies found","suites":["Planner"],"updatePoint":{"line":122,"column":51},"line":122,"code":"  it(\"Should throw when circular dependencies found\", () => {\n\n    interface IA { }\n    interface IB { }\n    interface IC { }\n    interface ID { }\n\n    @injectable()\n    class D implements ID {\n      public a: IA;\n      public constructor(\n        @inject(\"A\") a: IA\n      ) { // circular dependency\n        this.a = a;\n      }\n    }\n\n    @injectable()\n    class C implements IC {\n      public d: ID;\n      public constructor(\n        @inject(\"D\") d: ID\n      ) {\n        this.d = d;\n      }\n    }\n\n    @injectable()\n    class B implements IB { }\n\n    @injectable()\n    class A implements IA {\n      public b: IB;\n      public c: IC;\n      public constructor(\n        @inject(\"B\") b: IB,\n        @inject(\"C\") c: IC\n      ) {\n        this.b = b;\n        this.c = c;\n      }\n    }\n\n    const aId = \"A\";\n    const bId = \"B\";\n    const cId = \"C\";\n    const dId = \"D\";\n\n    const container = new Container();\n    container.bind<IA>(aId).to(A);\n    container.bind<IB>(bId).to(B);\n    container.bind<IC>(cId).to(C);\n    container.bind<ID>(dId).to(D);\n\n    const throwErrorFunction = () => {\n      container.get(aId);\n    };\n\n    expect(throwErrorFunction).to.throw(\n      `${ERROR_MSGS.CIRCULAR_DEPENDENCY} A --> C --> D --> A`\n    );\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should only plan sub-dependencies when binding type is BindingType.Instance","suites":["Planner"],"updatePoint":{"line":186,"column":81},"line":186,"code":"  it(\"Should only plan sub-dependencies when binding type is BindingType.Instance\", () => {\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface Katana { }\n\n    @injectable()\n    class Katana implements Katana {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(\n        @inject(\"KatanaHandler\") @targetName(\"handler\") handler: KatanaHandler,\n        @inject(\"KatanaBlade\") @targetName(\"blade\") blade: KatanaBlade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katanaFactory: interfaces.Factory<Katana>;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Factory<Katana>\") @targetName(\"katanaFactory\") katanaFactory: interfaces.Factory<Katana>,\n        @inject(\"Shuriken\") @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katanaFactory = katanaFactory;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaId = \"Katana\";\n    const katanaHandlerId = \"KatanaHandler\";\n    const katanaBladeId = \"KatanaBlade\";\n    const katanaFactoryId = \"Factory<Katana>\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaBladeId).to(Katana);\n    container.bind<KatanaBlade>(katanaBladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(katanaHandlerId).to(KatanaHandler);\n    container.bind<interfaces.Factory<Katana>>(katanaFactoryId).toFactory<Katana>((context: interfaces.Context) =>\n      () =>\n        context.container.get<Katana>(katanaId));\n\n    const actualPlan = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId).plan;\n\n    expect(actualPlan.rootRequest.serviceIdentifier).eql(ninjaId);\n    expect(actualPlan.rootRequest.childRequests[0]?.serviceIdentifier).eql(katanaFactoryId);\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests.length).eql(0); // IMPORTANT!\n    expect(actualPlan.rootRequest.childRequests[1]?.serviceIdentifier).eql(shurikenId);\n    expect(actualPlan.rootRequest.childRequests[1]?.childRequests.length).eql(0);\n    expect(actualPlan.rootRequest.childRequests[2]).eql(undefined);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should generate plans with multi-injections","suites":["Planner"],"updatePoint":{"line":261,"column":49},"line":261,"code":"  it(\"Should generate plans with multi-injections\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @multiInject(\"Weapon\") @targetName(\"weapons\") weapons: Weapon[]\n      ) {\n        this.katana = weapons[0] as Weapon;\n        this.shuriken = weapons[1] as Weapon;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).to(Shuriken);\n    container.bind<Weapon>(weaponId).to(Katana);\n\n    const actualPlan = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId).plan;\n\n    // root request has no target\n    expect(actualPlan.rootRequest.serviceIdentifier).eql(ninjaId);\n    expect(actualPlan.rootRequest.target.serviceIdentifier).eql(ninjaId);\n    expect(actualPlan.rootRequest.target.isArray()).eql(false);\n\n    // root request should only have one child request with target weapons/Weapon[]\n    expect(actualPlan.rootRequest.childRequests[0]?.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[1]).eql(undefined);\n    expect(actualPlan.rootRequest.childRequests[0]?.target.name.value()).eql(\"weapons\");\n    expect(actualPlan.rootRequest.childRequests[0]?.target.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[0]?.target.isArray()).eql(true);\n\n    // child request should have two child requests with targets weapons/Weapon[] but bindings Katana and Shuriken\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests.length).eql(2);\n\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.serviceIdentifier).eql(weaponId);\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.target.name.value()).eql(\"weapons\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.target.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.target.isArray()).eql(true);\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.bindings[0]?.serviceIdentifier).eql(\"Weapon\");\n    const shurikenImplementationType: any = actualPlan.rootRequest.childRequests[0]?.childRequests[0]?.bindings[0]?.implementationType;\n    expect(shurikenImplementationType.name).eql(\"Shuriken\");\n\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.serviceIdentifier).eql(weaponId);\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.target.name.value()).eql(\"weapons\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.target.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.target.isArray()).eql(true);\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.serviceIdentifier).eql(\"Weapon\");\n    expect(actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.bindings[0]?.serviceIdentifier).eql(\"Weapon\");\n    const katanaImplementationType: any = actualPlan.rootRequest.childRequests[0]?.childRequests[1]?.bindings[0]?.implementationType;\n    expect(katanaImplementationType.name).eql(\"Katana\");\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when no matching bindings are found","suites":["Planner"],"updatePoint":{"line":330,"column":54},"line":330,"code":"  it(\"Should throw when no matching bindings are found\", () => {\n\n    interface Katana { }\n    @injectable()\n    class Katana implements Katana { }\n\n    interface Shuriken { }\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") @targetName(\"katana\") katana: Katana,\n        @inject(\"Shuriken\") @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.NOT_REGISTERED} Katana`);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when an ambiguous match is found","suites":["Planner"],"updatePoint":{"line":370,"column":51},"line":370,"code":"  it(\"Should throw when an ambiguous match is found\", () => {\n\n    interface Katana { }\n\n    @injectable()\n    class Katana implements Katana { }\n\n    @injectable()\n    class SharpKatana implements Katana { }\n\n    interface Shuriken { }\n    class Shuriken implements Shuriken { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") katana: Katana,\n        @inject(\"Shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const katanaId = \"Katana\";\n    const shurikenId = \"Shuriken\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Katana>(katanaId).to(Katana);\n    container.bind<Katana>(katanaId).to(SharpKatana);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.AMBIGUOUS_MATCH} Katana`);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should apply constrains when an ambiguous match is found","suites":["Planner"],"updatePoint":{"line":416,"column":62},"line":416,"code":"  it(\"Should apply constrains when an ambiguous match is found\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Ninja { }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    @injectable()\n    class Ninja implements Ninja {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(weaponId) @targetName(\"katana\") @tagged(\"canThrow\", false) katana: Weapon,\n        @inject(weaponId) @targetName(\"shuriken\") @tagged(\"canThrow\", true) shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).to(Katana).whenTargetTagged(\"canThrow\", false);\n    container.bind<Weapon>(weaponId).to(Shuriken).whenTargetTagged(\"canThrow\", true);\n\n    const actualPlan = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId).plan;\n\n    // root request has no target\n    expect(actualPlan.rootRequest.serviceIdentifier).eql(ninjaId);\n    expect(actualPlan.rootRequest.target.serviceIdentifier).eql(ninjaId);\n    expect(actualPlan.rootRequest.target.isArray()).eql(false);\n\n    // root request should have 2 child requests\n    expect(actualPlan.rootRequest.childRequests[0]?.serviceIdentifier).eql(weaponId);\n    expect(actualPlan.rootRequest.childRequests[0]?.target.name.value()).eql(\"katana\");\n    expect(actualPlan.rootRequest.childRequests[0]?.target.serviceIdentifier).eql(weaponId);\n\n    expect(actualPlan.rootRequest.childRequests[1]?.serviceIdentifier).eql(weaponId);\n    expect(actualPlan.rootRequest.childRequests[1]?.target.name.value()).eql(\"shuriken\");\n    expect(actualPlan.rootRequest.childRequests[1]?.target.serviceIdentifier).eql(weaponId);\n\n    expect(actualPlan.rootRequest.childRequests[2]).eql(undefined);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when a class has a missing @injectable annotation","suites":["Planner"],"updatePoint":{"line":469,"column":68},"line":469,"code":"  it(\"Should throw when a class has a missing @injectable annotation\", () => {\n\n    interface Weapon { }\n\n    class Katana implements Weapon { }\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana);\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, \"Weapon\");\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} Katana.`);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when apply a metadata decorator without @inject or @multiInject","suites":["Planner"],"updatePoint":{"line":486,"column":82},"line":486,"code":"  it(\"Should throw when apply a metadata decorator without @inject or @multiInject\", () => {\n    @injectable()\n    class Ninja {\n      @named(\"name\")\n      // tslint:disable-next-line: no-empty\n      set weapon(weapon: Weapon) {\n\n      }\n    }\n    interface Weapon { }\n\n    class Katana implements Weapon { }\n\n    const container = new Container();\n    container.bind<Weapon>(\"Weapon\").to(Katana);\n    container.bind(Ninja).toSelf();\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, Ninja);\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} for property weapon in class Ninja.`);\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should ignore checking base classes for @injectable when skipBaseClassChecks is set on the container","suites":["Planner"],"updatePoint":{"line":510,"column":106},"line":510,"code":"  it(\"Should ignore checking base classes for @injectable when skipBaseClassChecks is set on the container\", () => {\n    class Test { }\n\n    @injectable()\n    class Test2 extends Test { }\n\n    const container = new Container({ skipBaseClassChecks: true });\n    container.bind(Test2).toSelf();\n    container.get(Test2);\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should ignore checking base classes for @injectable on resolve when skipBaseClassChecks is set","suites":["Planner"],"updatePoint":{"line":521,"column":100},"line":521,"code":"  it(\"Should ignore checking base classes for @injectable on resolve when skipBaseClassChecks is set\", () => {\n    class Test { }\n\n    @injectable()\n    class Test2 extends Test { }\n\n    const container = new Container({ skipBaseClassChecks: true });\n    container.resolve(Test2);\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when an class has a missing @inject annotation","suites":["Planner"],"updatePoint":{"line":531,"column":65},"line":531,"code":"  it(\"Should throw when an class has a missing @inject annotation\", () => {\n\n    interface Sword { }\n\n    @injectable()\n    class Katana implements Sword { }\n\n    interface Warrior { }\n\n    @injectable()\n    class Ninja implements Warrior {\n\n      public katana: Katana;\n\n      public constructor(\n        katana: Sword\n      ) {\n        this.katana = katana;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(\"Warrior\").to(Ninja);\n    container.bind<Sword>(\"Sword\").to(Katana);\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, \"Warrior\");\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.MISSING_INJECT_ANNOTATION} argument 0 in class Ninja.`);\n\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when a function has a missing @injectable annotation","suites":["Planner"],"updatePoint":{"line":564,"column":71},"line":564,"code":"  it(\"Should throw when a function has a missing @injectable annotation\", () => {\n\n    interface Katana { }\n\n    @injectable()\n    class Katana implements Katana { }\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja {\n\n      public katana: Katana;\n\n      public constructor(\n        katanaFactory: () => Katana\n      ) {\n        this.katana = katanaFactory();\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(\"Ninja\").to(Ninja);\n    container.bind<Katana>(\"Katana\").to(Katana);\n    container.bind<Katana>(\"Factory<Katana>\").to(Katana);\n\n    const throwFunction = () => {\n      plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, \"Ninja\");\n    };\n\n    expect(throwFunction).to.throw(`${ERROR_MSGS.MISSING_INJECT_ANNOTATION} argument 0 in class Ninja.`);\n  });","file":"planning/planner.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to set its own properties","suites":["QueryableString"],"updatePoint":{"line":6,"column":46},"line":6,"code":"  it(\"Should be able to set its own properties\", () => {\n    const queryableString = new QueryableString(\"some_text\");\n    expect(queryableString.value()).to.eql(\"some_text\");\n  });","file":"planning/queryable_string.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to return its value","suites":["QueryableString"],"updatePoint":{"line":11,"column":40},"line":11,"code":"  it(\"Should be able to return its value\", () => {\n    const queryableString = new QueryableString(\"some_text\");\n    expect(queryableString.value()).to.eql(\"some_text\");\n    expect(queryableString.value() === \"some_other_text\").to.eql(false);\n  });","file":"planning/queryable_string.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify if it's value starts with certain text","suites":["QueryableString"],"updatePoint":{"line":17,"column":71},"line":17,"code":"  it(\"Should be able to identify if it's value starts with certain text\", () => {\n    const queryableString = new QueryableString(\"some_text\");\n    expect(queryableString.startsWith(\"some\")).to.eql(true);\n    expect(queryableString.startsWith(\"s\")).to.eql(true);\n    expect(queryableString.startsWith(\"me\")).to.eql(false);\n    expect(queryableString.startsWith(\"_text\")).to.eql(false);\n  });","file":"planning/queryable_string.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify if it's value ends with certain text","suites":["QueryableString"],"updatePoint":{"line":25,"column":69},"line":25,"code":"  it(\"Should be able to identify if it's value ends with certain text\", () => {\n    const queryableString = new QueryableString(\"some_text\");\n    expect(queryableString.endsWith(\"_text\")).to.eql(true);\n    expect(queryableString.endsWith(\"ext\")).to.eql(true);\n    expect(queryableString.endsWith(\"_tex\")).to.eql(false);\n    expect(queryableString.endsWith(\"some\")).to.eql(false);\n  });","file":"planning/queryable_string.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify if it's value is equals to certain text","suites":["QueryableString"],"updatePoint":{"line":33,"column":72},"line":33,"code":"  it(\"Should be able to identify if it's value is equals to certain text\", () => {\n    const queryableString = new QueryableString(\"some_text\");\n    expect(queryableString.equals(\"some_text\")).to.eql(true);\n    expect(queryableString.contains(\"some_text \")).to.eql(false);\n    expect(queryableString.contains(\"som_text\")).to.eql(false);\n  });","file":"planning/queryable_string.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["Request"],"updatePoint":{"line":19,"column":45},"line":19,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    const container = new Container();\n    const context = new Context(container);\n\n    const request1: Request = new Request(\n      identifiers.Ninja,\n      context,\n      null,\n      [],\n      new Target(TargetTypeEnum.Variable, \"\", identifiers.Ninja)\n    );\n\n    const request2 = new Request(\n      identifiers.Ninja,\n      context,\n      null,\n      [],\n      new Target(TargetTypeEnum.Variable, \"\", identifiers.Ninja)\n    );\n\n    expect(request1.serviceIdentifier).eql(identifiers.Ninja);\n    expect(Array.isArray(request1.bindings)).eql(true);\n    expect(Array.isArray(request2.bindings)).eql(true);\n    expect(request1.id).to.be.a(\"number\");\n    expect(request2.id).to.be.a(\"number\");\n    expect(request1.id).not.eql(request2.id);\n\n  });","file":"planning/request.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to add a child request","suites":["Request"],"updatePoint":{"line":49,"column":43},"line":49,"code":"  it(\"Should be able to add a child request\", () => {\n\n    const container = new Container();\n    const context = new Context(container);\n\n    const ninjaRequest: Request = new Request(\n      identifiers.Ninja,\n      context,\n      null,\n      [],\n      new Target(TargetTypeEnum.Variable, \"Ninja\", identifiers.Ninja)\n    );\n\n    ninjaRequest.addChildRequest(\n      identifiers.Katana,\n      [],\n      new Target(TargetTypeEnum.ConstructorArgument, \"Katana\", identifiers.Katana)\n    );\n\n    const katanaRequest = ninjaRequest.childRequests[0];\n\n    expect(katanaRequest?.serviceIdentifier).eql(identifiers.Katana);\n    expect(katanaRequest?.target.name.value()).eql(\"Katana\");\n    expect(katanaRequest?.childRequests.length).eql(0);\n\n    const katanaParentRequest: interfaces.Request = katanaRequest?.parentRequest as Request;\n    expect(katanaParentRequest.serviceIdentifier).eql(identifiers.Ninja);\n    expect(katanaParentRequest.target.name.value()).eql(\"Ninja\");\n    expect(katanaParentRequest.target.serviceIdentifier).eql(identifiers.Ninja);\n\n  });","file":"planning/request.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to create instances of untagged targets","suites":["Target"],"updatePoint":{"line":9,"column":60},"line":9,"code":"  it(\"Should be able to create instances of untagged targets\", () => {\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    expect(target.serviceIdentifier).to.be.eql(\"Katana\");\n    expect(target.name.value()).to.be.eql(\"katana\");\n    expect(Array.isArray(target.metadata)).to.be.eql(true);\n    expect(target.metadata.length).to.be.eql(0);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to create instances of named targets","suites":["Target"],"updatePoint":{"line":17,"column":57},"line":17,"code":"  it(\"Should be able to create instances of named targets\", () => {\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", \"primary\");\n    expect(target.serviceIdentifier).to.be.eql(\"Katana\");\n    expect(target.name.value()).to.be.eql(\"katana\");\n    expect(Array.isArray(target.metadata)).to.be.eql(true);\n    expect(target.metadata.length).to.be.eql(1);\n    expect(target.metadata[0]?.key).to.be.eql(METADATA_KEY.NAMED_TAG);\n    expect(target.metadata[0]?.value).to.be.eql(\"primary\");\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to create instances of tagged targets","suites":["Target"],"updatePoint":{"line":27,"column":58},"line":27,"code":"  it(\"Should be able to create instances of tagged targets\", () => {\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    expect(target.serviceIdentifier).to.be.eql(\"Katana\");\n    expect(target.name.value()).to.be.eql(\"katana\");\n    expect(Array.isArray(target.metadata)).to.be.eql(true);\n    expect(target.metadata.length).to.be.eql(1);\n    expect(target.metadata[0]?.key).to.be.eql(\"power\");\n    expect(target.metadata[0]?.value).to.be.eql(5);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify named metadata","suites":["Target"],"updatePoint":{"line":37,"column":47},"line":37,"code":"  it(\"Should be able to identify named metadata\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", \"primary\");\n    expect(target1.isNamed()).to.be.eql(true);\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    expect(target2.isNamed()).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify multi-injections","suites":["Target"],"updatePoint":{"line":44,"column":49},"line":44,"code":"  it(\"Should be able to identify multi-injections\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    target1.metadata.push(new Metadata(METADATA_KEY.MULTI_INJECT_TAG, \"Katana\"));\n    expect(target1.isArray()).to.be.eql(true);\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    expect(target2.isArray()).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to match multi-inject for a specified service metadata","suites":["Target"],"updatePoint":{"line":52,"column":75},"line":52,"code":"  it(\"Should be able to match multi-inject for a specified service metadata\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    target1.metadata.push(new Metadata(METADATA_KEY.MULTI_INJECT_TAG, \"Katana\"));\n    target1.metadata.push(new Metadata(METADATA_KEY.INJECT_TAG, \"Shuriken\"));\n    expect(target1.matchesArray(\"Katana\")).to.be.eql(true);\n    expect(target1.matchesArray(\"Shuriken\")).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to match named metadata","suites":["Target"],"updatePoint":{"line":60,"column":44},"line":60,"code":"  it(\"Should be able to match named metadata\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", \"primary\");\n    expect(target1.matchesNamedTag(\"primary\")).to.be.eql(true);\n    expect(target1.matchesNamedTag(\"secondary\")).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to identify tagged metadata","suites":["Target"],"updatePoint":{"line":66,"column":48},"line":66,"code":"  it(\"Should be able to identify tagged metadata\", () => {\n\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    expect(target.isTagged()).to.be.eql(false);\n\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    expect(target1.isTagged()).to.be.eql(true);\n\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", \"primary\");\n    expect(target2.isTagged()).to.be.eql(false);\n\n    const target3 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\");\n    target3.metadata.push(new Metadata(\"power\", 5), new Metadata(\"speed\", 5));\n    expect(target3.isTagged()).to.be.eql(true);\n\n    const target4 = new Target(TargetTypeEnum.Variable, \"\", \"Katana\");\n    target4.metadata.push(new Metadata(METADATA_KEY.INJECT_TAG, \"Katana\"))\n    expect(target4.isTagged()).to.be.eql(false);\n\n    const target5 = new Target(TargetTypeEnum.Variable, \"\", \"Katana\");\n    target5.metadata.push(new Metadata(METADATA_KEY.MULTI_INJECT_TAG, \"Katana\"))\n    expect(target5.isTagged()).to.be.eql(false);\n\n    const target6 = new Target(TargetTypeEnum.Variable, \"katanaName\", \"Katana\");\n    target6.metadata.push(new Metadata(METADATA_KEY.NAME_TAG, \"katanaName\"))\n    expect(target6.isTagged()).to.be.eql(false);\n\n    const target7 = new Target(TargetTypeEnum.Variable, \"\", \"Katana\");\n    target7.metadata.push(new Metadata(METADATA_KEY.UNMANAGED_TAG, true))\n    expect(target7.isTagged()).to.be.eql(false);\n\n    const target8 = new Target(TargetTypeEnum.Variable, \"katanaName\", \"Katana\");\n    target8.metadata.push(new Metadata(METADATA_KEY.NAMED_TAG, \"katanaName\"))\n    expect(target8.isTagged()).to.be.eql(false);\n\n    const target9 = new Target(TargetTypeEnum.Variable, \"\", \"Katana\");\n    target9.metadata.push(new Metadata(METADATA_KEY.OPTIONAL_TAG, true))\n    expect(target9.isTagged()).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to match tagged metadata","suites":["Target"],"updatePoint":{"line":106,"column":45},"line":106,"code":"  it(\"Should be able to match tagged metadata\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    expect(target1.matchesTag(\"power\")(5)).to.be.eql(true);\n    expect(target1.matchesTag(\"power\")(2)).to.be.eql(false);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should contain an unique identifier","suites":["Target"],"updatePoint":{"line":112,"column":41},"line":112,"code":"  it(\"Should contain an unique identifier\", () => {\n    const target1 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Katana\", new Metadata(\"power\", 5));\n    expect(target1.id).to.be.a(\"number\");\n    expect(target2.id).to.be.a(\"number\");\n    expect(target1.id).not.eql(target2.id);\n  });","file":"planning/target.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.Instance bindings","suites":["Resolve"],"updatePoint":{"line":37,"column":61},"line":37,"code":"  it(\"Should be able to resolve BindingType.Instance bindings\", () => {\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaId = \"Katana\";\n    const katanaHandlerId = \"KatanaHandler\";\n    const katanaBladeId = \"KatanaBlade\";\n\n    interface Blade { }\n\n    @injectable()\n    class KatanaBlade implements Blade { }\n\n    interface Handler { }\n\n    @injectable()\n    class KatanaHandler implements Handler { }\n\n    interface Sword {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: Handler;\n      public blade: Blade;\n      public constructor(\n        @inject(katanaHandlerId) @targetName(\"handler\") handler: Handler,\n        @inject(katanaBladeId) @targetName(\"blade\") blade: Blade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(katanaId) @targetName(\"katana\") katana: Katana,\n        @inject(shurikenId) @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).to(Katana);\n    container.bind<KatanaBlade>(katanaBladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(katanaHandlerId).to(KatanaHandler);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.katana.handler instanceof KatanaHandler).eql(true);\n    expect(ninja.katana.blade instanceof KatanaBlade).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should store singleton type bindings in cache","suites":["Resolve"],"updatePoint":{"line":114,"column":51},"line":114,"code":"  it(\"Should store singleton type bindings in cache\", () => {\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaId = \"Katana\";\n    const katanaHandlerId = \"KatanaHandler\";\n    const katanaBladeId = \"KatanaBlade\";\n\n    interface Blade { }\n\n    @injectable()\n    class KatanaBlade implements Blade { }\n\n    interface Handler { }\n\n    @injectable()\n    class KatanaHandler implements Handler { }\n\n    interface Sword {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: Handler;\n      public blade: Blade;\n      public constructor(\n        @inject(katanaHandlerId) @targetName(\"handler\") handler: Handler,\n        @inject(katanaBladeId) @targetName(\"blade\") blade: Blade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(katanaId) @targetName(\"katana\") katana: Katana,\n        @inject(shurikenId) @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).to(Katana).inSingletonScope(); // SINGLETON!\n    container.bind<KatanaBlade>(katanaBladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(katanaHandlerId).to(KatanaHandler).inSingletonScope(); // SINGLETON!\n\n    const bindingDictionary = getBindingDictionary(container);\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const katanaBinding = bindingDictionary.get(katanaId)[0];\n    expect(katanaBinding?.cache === null).eql(true);\n    expect(katanaBinding?.activated).eql(false);\n\n    const ninja = resolveTyped<Ninja>(context);\n    expect(ninja instanceof Ninja).eql(true);\n\n    const ninja2 = resolveTyped<Ninja>(context);\n    expect(ninja2 instanceof Ninja).eql(true);\n\n    expect(katanaBinding?.cache instanceof Katana).eql(true);\n    expect(katanaBinding?.activated).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should throw when an invalid BindingType is detected","suites":["Resolve"],"updatePoint":{"line":198,"column":58},"line":198,"code":"  it(\"Should throw when an invalid BindingType is detected\", () => {\n\n    interface Katana { }\n\n    @injectable()\n    class Katana implements Katana { }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") @targetName(\"katana\") katana: Katana,\n        @inject(\"Shuriken\") @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    // container and bindings\n    const ninjaId = \"Ninja\";\n    const container = new Container();\n    container.bind<Ninja>(ninjaId); // IMPORTANT! (Invalid binding)\n\n    // context and plan\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const throwFunction = () => {\n      resolveTyped(context);\n    };\n\n    expect(context.plan.rootRequest.bindings[0]?.type).eql(BindingTypeEnum.Invalid);\n    expect(throwFunction).to.throw(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${ninjaId}`);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.ConstantValue bindings","suites":["Resolve"],"updatePoint":{"line":245,"column":66},"line":245,"code":"  it(\"Should be able to resolve BindingType.ConstantValue bindings\", () => {\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface Sword {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(handler: KatanaHandler, blade: KatanaBlade) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(\"Katana\") @targetName(\"katana\") katana: Katana,\n        @inject(\"Shuriken\") @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaId = \"Katana\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).toConstantValue(new Katana(new KatanaHandler(), new KatanaBlade())); // IMPORTANT!\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const katanaBinding = getBindingDictionary(container).get(katanaId)[0];\n    expect(katanaBinding?.activated).eql(false);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(katanaBinding?.activated).eql(true);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.katana.handler instanceof KatanaHandler).eql(true);\n    expect(ninja.katana.blade instanceof KatanaBlade).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.DynamicValue bindings","suites":["Resolve"],"updatePoint":{"line":321,"column":65},"line":321,"code":"  it(\"Should be able to resolve BindingType.DynamicValue bindings\", () => {\n\n    interface UseDate {\n      doSomething(): Date;\n    }\n\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public constructor(@inject(\"Date\") currentDate: Date) {\n        this.currentDate = currentDate;\n      }\n      public doSomething() {\n        return this.currentDate;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue((context: interfaces.Context) => new Date());\n\n    const subject1 = container.get<UseDate>(\"UseDate\");\n    const subject2 = container.get<UseDate>(\"UseDate\");\n    expect(subject1.doSomething() === subject2.doSomething()).eql(false);\n\n    container.unbind(\"Date\");\n    container.bind<Date>(\"Date\").toConstantValue(new Date());\n\n    const subject3 = container.get<UseDate>(\"UseDate\");\n    const subject4 = container.get<UseDate>(\"UseDate\");\n    expect(subject3.doSomething() === subject4.doSomething()).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.Constructor bindings","suites":["Resolve"],"updatePoint":{"line":355,"column":64},"line":355,"code":"  it(\"Should be able to resolve BindingType.Constructor bindings\", () => {\n\n    const ninjaId = \"Ninja\";\n    const newableKatanaId = \"Newable<Katana>\";\n    @injectable()\n    class Katana { }\n\n    @injectable()\n    class Ninja {\n      public katana: Katana;\n      public constructor(\n        @inject(newableKatanaId) katana: interfaces.Newable<Katana>\n      ) {\n        this.katana = new katana();  // IMPORTANT!\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<interfaces.Newable<Katana>>(newableKatanaId).toConstructor<Katana>(Katana);  // IMPORTANT!\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.Factory bindings","suites":["Resolve"],"updatePoint":{"line":384,"column":60},"line":384,"code":"  it(\"Should be able to resolve BindingType.Factory bindings\", () => {\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const swordFactoryId = \"Factory<Sword>\";\n    const katanaId = \"Katana\";\n    const handlerId = \"Handler\";\n    const bladeId = \"Blade\";\n\n    interface Blade { }\n\n    @injectable()\n    class KatanaBlade implements Blade { }\n\n    interface Handler { }\n\n    @injectable()\n    class KatanaHandler implements Handler { }\n\n    interface Sword {\n      handler: Handler;\n      blade: Blade;\n    }\n\n    type SwordFactory = () => Sword;\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: Handler;\n      public blade: Blade;\n      public constructor(\n        @inject(handlerId) @targetName(\"handler\") handler: Handler,\n        @inject(bladeId) @targetName(\"blade\") blade: Blade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(swordFactoryId) @targetName(\"makeKatana\") makeKatana: SwordFactory,\n        @inject(shurikenId) @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = makeKatana(); // IMPORTANT!\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).to(Katana);\n    container.bind<KatanaBlade>(bladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(handlerId).to(KatanaHandler);\n\n    container.bind<interfaces.Factory<Katana>>(swordFactoryId).toFactory<Katana>((theContext: interfaces.Context) =>\n      () =>\n        theContext.container.get<Katana>(katanaId));\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.katana.handler instanceof KatanaHandler).eql(true);\n    expect(ninja.katana.blade instanceof KatanaBlade).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve bindings with auto factory","suites":["Resolve"],"updatePoint":{"line":469,"column":58},"line":469,"code":"  it(\"Should be able to resolve bindings with auto factory\", () => {\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaFactoryId = \"Factory<Sword>\";\n    const katanaId = \"Katana\";\n    const katanaHandlerId = \"KatanaHandler\";\n    const katanaBladeId = \"KatanaBlade\";\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface Sword {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    type SwordFactory = () => Sword;\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(\n        @inject(katanaHandlerId) @targetName(\"handler\") handler: KatanaHandler,\n        @inject(katanaBladeId) @targetName(\"blade\") blade: KatanaBlade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(katanaFactoryId) @targetName(\"makeKatana\") makeKatana: SwordFactory,\n        @inject(shurikenId) @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = makeKatana(); // IMPORTANT!\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Katana>(katanaId).to(Katana);\n    container.bind<KatanaBlade>(katanaBladeId).to(KatanaBlade);\n    container.bind<KatanaHandler>(katanaHandlerId).to(KatanaHandler);\n    container.bind<interfaces.Factory<Katana>>(katanaFactoryId).toAutoFactory<Katana>(katanaId);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.katana.handler instanceof KatanaHandler).eql(true);\n    expect(ninja.katana.blade instanceof KatanaBlade).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.Provider bindings","suites":["Resolve"],"updatePoint":{"line":550,"column":61},"line":550,"code":"  it(\"Should be able to resolve BindingType.Provider bindings\", (done) => {\n\n    type SwordProvider = () => Promise<Sword>;\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const swordProviderId = \"Provider<Sword>\";\n    const swordId = \"Sword\";\n    const handlerId = \"Handler\";\n    const bladeId = \"Blade\";\n\n    interface Blade { }\n\n    @injectable()\n    class KatanaBlade implements Blade { }\n\n    interface Handler { }\n\n    @injectable()\n    class KatanaHandler implements Handler { }\n\n    interface Sword {\n      handler: Handler;\n      blade: Blade;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: Handler;\n      public blade: Blade;\n      public constructor(\n        @inject(handlerId) @targetName(\"handler\") handler: Handler,\n        @inject(bladeId) @targetName(\"handler\") blade: Blade\n      ) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katana: Katana | null;\n      katanaProvider: SwordProvider;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana | null;\n      public katanaProvider: SwordProvider;\n      public shuriken: Shuriken;\n      public constructor(\n        @inject(swordProviderId) @targetName(\"katanaProvider\") katanaProvider: SwordProvider,\n        @inject(shurikenId) @targetName(\"shuriken\") shuriken: Shuriken\n      ) {\n        this.katana = null;\n        this.katanaProvider = katanaProvider;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Warrior>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n    container.bind<Sword>(swordId).to(Katana);\n    container.bind<Blade>(bladeId).to(KatanaBlade);\n    container.bind<Handler>(handlerId).to(KatanaHandler);\n\n    container.bind<SwordProvider>(swordProviderId).toProvider<Sword>((theContext: interfaces.Context) =>\n      () =>\n        new Promise<Sword>((resolveFunc) => {\n          // Using setTimeout to simulate complex initialization\n          setTimeout(() => { resolveFunc(theContext.container.get<Sword>(swordId)); }, 100);\n        }));\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Warrior>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n    ninja.katanaProvider().then((katana) => {\n      ninja.katana = katana;\n      expect(ninja.katana instanceof Katana).eql(true);\n      expect(ninja.katana.handler instanceof KatanaHandler).eql(true);\n      expect(ninja.katana.blade instanceof KatanaBlade).eql(true);\n      done();\n    });\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with constraints on tagged targets","suites":["Resolve"],"updatePoint":{"line":645,"column":72},"line":645,"code":"  it(\"Should be able to resolve plans with constraints on tagged targets\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"katana\") @tagged(\"canThrow\", false) katana: Weapon,\n        @inject(\"Weapon\") @targetName(\"shuriken\") @tagged(\"canThrow\", true) shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).to(Katana).whenTargetTagged(\"canThrow\", false);\n    container.bind<Weapon>(weaponId).to(Shuriken).whenTargetTagged(\"canThrow\", true);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with constraints on named targets","suites":["Resolve"],"updatePoint":{"line":691,"column":71},"line":691,"code":"  it(\"Should be able to resolve plans with constraints on named targets\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"katana\") @named(\"strong\") katana: Weapon,\n        @inject(\"Weapon\") @targetName(\"shuriken\") @named(\"weak\") shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).to(Katana).whenTargetNamed(\"strong\");\n    container.bind<Weapon>(weaponId).to(Shuriken).whenTargetNamed(\"weak\");\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with custom contextual constraints","suites":["Resolve"],"updatePoint":{"line":737,"column":72},"line":737,"code":"  it(\"Should be able to resolve plans with custom contextual constraints\", () => {\n\n    interface Weapon { }\n\n    @injectable()\n    class Katana implements Weapon { }\n\n    @injectable()\n    class Shuriken implements Weapon { }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @inject(\"Weapon\") @targetName(\"katana\") katana: Weapon,\n        @inject(\"Weapon\") @targetName(\"shuriken\") shuriken: Weapon\n      ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    container.bind<Weapon>(weaponId).to(Katana).when((request: interfaces.Request) =>\n      request.target.name.equals(\"katana\"));\n\n    container.bind<Weapon>(weaponId).to(Shuriken).when((request: interfaces.Request) =>\n      request.target.name.equals(\"shuriken\"));\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with multi-injections","suites":["Resolve"],"updatePoint":{"line":786,"column":59},"line":786,"code":"  it(\"Should be able to resolve plans with multi-injections\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name = \"Katana\";\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name = \"Shuriken\";\n    }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @multiInject(\"Weapon\") @targetName(\"weapons\") weapons: Weapon[]\n      ) {\n        this.katana = weapons[0] as Weapon;\n        this.shuriken = weapons[1] as Weapon;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).to(Katana);\n    container.bind<Weapon>(weaponId).to(Shuriken);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n    // if only one value is bound to weaponId\n    const container2 = new Container();\n    container2.bind<Ninja>(ninjaId).to(Ninja);\n    container2.bind<Weapon>(weaponId).to(Katana);\n\n    const context2 = plan(new MetadataReader(), container2, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja2 = resolveTyped<Ninja>(context2);\n\n    expect(ninja2 instanceof Ninja).eql(true);\n    expect(ninja2.katana instanceof Katana).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with async multi-injections","suites":["Resolve"],"updatePoint":{"line":849,"column":65},"line":849,"code":"  it(\"Should be able to resolve plans with async multi-injections\", async () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    @injectable()\n    class Katana implements Weapon {\n      public name = \"Katana\";\n    }\n\n    @injectable()\n    class Shuriken implements Weapon {\n      public name = \"Shuriken\";\n    }\n\n    interface Warrior {\n      katana: Weapon;\n      shuriken: Weapon;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Weapon;\n      public shuriken: Weapon;\n      public constructor(\n        @multiInject(\"Weapon\") weapons: Weapon[]\n      ) {\n        this.katana = weapons[0] as Weapon;\n        this.shuriken = weapons[1] as Weapon;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const weaponId = \"Weapon\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Weapon>(weaponId).toDynamicValue(_ => Promise.resolve(new Katana()));\n    container.bind<Weapon>(weaponId).to(Shuriken);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = await resolveTyped<Promise<Ninja>>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(ninja.katana instanceof Katana).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n\n    // if only one value is bound to weaponId\n    const container2 = new Container();\n    container2.bind<Ninja>(ninjaId).to(Ninja);\n    container2.bind<Weapon>(weaponId).toDynamicValue(_ => new Katana());\n\n    const context2 = plan(new MetadataReader(), container2, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja2 = await resolveTyped<Promise<Ninja>>(context2);\n\n    expect(ninja2 instanceof Ninja).eql(true);\n    expect(ninja2.katana instanceof Katana).eql(true);\n    expect(ninja2.shuriken === undefined).eql(true)\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with async and non async injections","suites":["Resolve"],"updatePoint":{"line":913,"column":73},"line":913,"code":"  it(\"Should be able to resolve plans with async and non async injections\", async () => {\n    const syncPropertyId = \"syncProperty\"\n    const asyncPropertyId = \"asyncProperty\"\n    const syncCtorId = \"syncCtor\"\n    const asyncCtorId = \"asyncCtor\"\n    @injectable()\n    class CrazyInjectable {\n      public constructor(\n        @inject(syncCtorId) readonly syncCtor: string,\n        @inject(asyncCtorId) readonly asyncCtor: string) { }\n      @inject(syncPropertyId)\n      public syncProperty!: string\n      @inject(asyncPropertyId)\n      public asyncProperty!: string\n    }\n    const crazyInjectableId = 'crazy'\n    const container = new Container();\n    container.bind<CrazyInjectable>(crazyInjectableId).to(CrazyInjectable);\n    container.bind<string>(syncCtorId).toConstantValue(\"syncCtor\")\n    container.bind<string>(asyncCtorId).toDynamicValue(_ => Promise.resolve('asyncCtor'))\n    container.bind<string>(syncPropertyId).toConstantValue(\"syncProperty\")\n    container.bind<string>(asyncPropertyId).toDynamicValue(_ => Promise.resolve('asyncProperty'))\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, crazyInjectableId);\n    const crazyInjectable = await resolveTyped<Promise<CrazyInjectable>>(context);\n    expect(crazyInjectable.syncCtor).eql(\"syncCtor\")\n    expect(crazyInjectable.asyncCtor).eql(\"asyncCtor\")\n    expect(crazyInjectable.syncProperty).eql(\"syncProperty\")\n    expect(crazyInjectable.asyncProperty).eql(\"asyncProperty\")\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve plans with activation handlers","suites":["Resolve"],"updatePoint":{"line":944,"column":62},"line":944,"code":"  it(\"Should be able to resolve plans with activation handlers\", () => {\n\n    interface Sword {\n      use(): void;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public use() {\n        return \"Used Katana!\";\n      }\n    }\n\n    interface Warrior {\n      katana: Katana;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public constructor(\n        @inject(\"Katana\") katana: Katana\n      ) {\n        this.katana = katana;\n      }\n    }\n\n    const ninjaId = \"Ninja\";\n    const katanaId = \"Katana\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    // This is a global for unit testing but remember\n    // that it is not a good idea to use globals\n    const timeTracker: string[] = [];\n\n    container.bind<Katana>(katanaId).to(Katana).onActivation((theContext: interfaces.Context, katana: Katana) => {\n      const handler = {\n        apply(target: any, thisArgument: any, argumentsList: any[]) {\n          timeTracker.push(`Starting ${target.name} ${new Date().getTime()}`);\n          const result = target.apply(thisArgument, argumentsList);\n          timeTracker.push(`Finished ${target.name} ${new Date().getTime()}`);\n          return result;\n        }\n      };\n      /// create a proxy for method use() own by katana instance about to be injected\n      katana.use = new Proxy(katana.use, handler);\n      return katana;\n    });\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja.katana.use()).eql(\"Used Katana!\");\n    expect(Array.isArray(timeTracker)).eql(true);\n    expect(timeTracker.length).eql(2);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve BindingType.Function bindings","suites":["Resolve"],"updatePoint":{"line":1005,"column":61},"line":1005,"code":"  it(\"Should be able to resolve BindingType.Function bindings\", () => {\n\n    const ninjaId = \"Ninja\";\n    const shurikenId = \"Shuriken\";\n    const katanaFactoryId = \"KatanaFactory\";\n\n    type KatanaFactory = () => Katana;\n\n    interface KatanaBlade { }\n\n    @injectable()\n    class KatanaBlade implements KatanaBlade { }\n\n    interface KatanaHandler { }\n\n    @injectable()\n    class KatanaHandler implements KatanaHandler { }\n\n    interface Sword {\n      handler: KatanaHandler;\n      blade: KatanaBlade;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      public handler: KatanaHandler;\n      public blade: KatanaBlade;\n      public constructor(handler: KatanaHandler, blade: KatanaBlade) {\n        this.handler = handler;\n        this.blade = blade;\n      }\n    }\n\n    interface Shuriken { }\n\n    @injectable()\n    class Shuriken implements Shuriken { }\n\n    interface Warrior {\n      katanaFactory: KatanaFactory;\n      shuriken: Shuriken;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public constructor(\n        @inject(katanaFactoryId) @targetName(\"katana\") public katanaFactory: KatanaFactory,\n        @inject(shurikenId) @targetName(\"shuriken\") public shuriken: Shuriken\n      ) {\n      }\n    }\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Shuriken>(shurikenId).to(Shuriken);\n\n    const katanaFactoryInstance = function () {\n      return new Katana(new KatanaHandler(), new KatanaBlade());\n    };\n\n    container.bind<KatanaFactory>(katanaFactoryId).toFunction(katanaFactoryInstance);\n\n    const katanaFactoryBinding = getBindingDictionary(container).get(katanaFactoryId)[0];\n    expect(katanaFactoryBinding?.activated).eql(false);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja instanceof Ninja).eql(true);\n    expect(typeof ninja.katanaFactory === \"function\").eql(true);\n    expect(ninja.katanaFactory() instanceof Katana).eql(true);\n    expect(ninja.katanaFactory().handler instanceof KatanaHandler).eql(true);\n    expect(ninja.katanaFactory().blade instanceof KatanaBlade).eql(true);\n    expect(ninja.shuriken instanceof Shuriken).eql(true);\n    expect(katanaFactoryBinding?.activated).eql(true);\n\n    expect(katanaFactoryBinding?.activated).eql(true);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should run the @PostConstruct method","suites":["Resolve"],"updatePoint":{"line":1086,"column":42},"line":1086,"code":"  it(\"Should run the @PostConstruct method\", () => {\n\n    interface Sword {\n      use(): string;\n    }\n\n    @injectable()\n    class Katana implements Sword {\n      private useMessage!: string;\n\n      public use() {\n        return this.useMessage;\n      }\n\n      @postConstruct()\n      public postConstruct() {\n        this.useMessage = \"Used Katana!\";\n      }\n    }\n\n    interface Warrior {\n      katana: Katana;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public constructor(@inject(\"Katana\") katana: Katana) {\n        this.katana = katana;\n      }\n    }\n    const ninjaId = \"Ninja\";\n    const katanaId = \"Katana\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    container.bind<Katana>(katanaId).to(Katana);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja.katana.use()).eql(\"Used Katana!\");\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should throw an error if the @postConstruct method throws an error","suites":["Resolve"],"updatePoint":{"line":1133,"column":72},"line":1133,"code":"  it(\"Should throw an error if the @postConstruct method throws an error\", () => {\n\n    @injectable()\n    class Katana {\n\n      @postConstruct()\n      public postConstruct() {\n        throw new Error(\"Original Message\");\n      }\n    }\n\n    expect(() => resolveInstance({} as interfaces.Binding<unknown>, Katana, [], () => null))\n      .to.throw(\"@postConstruct error in class Katana: Original Message\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should run the @PostConstruct method of parent class","suites":["Resolve"],"updatePoint":{"line":1148,"column":58},"line":1148,"code":"  it(\"Should run the @PostConstruct method of parent class\", () => {\n\n    interface Weapon {\n      use(): string;\n    }\n\n    @injectable()\n    abstract class Sword implements Weapon {\n      protected useMessage!: string;\n\n      @postConstruct()\n      public postConstruct() {\n        this.useMessage = \"Used Weapon!\";\n      }\n\n      public abstract use(): string;\n    }\n\n    @injectable()\n    class Katana extends Sword {\n      public use() {\n        return this.useMessage;\n      }\n    }\n\n    interface Warrior {\n      katana: Katana;\n    }\n\n    @injectable()\n    class Ninja implements Warrior {\n      public katana: Katana;\n      public constructor(@inject(\"Katana\") katana: Katana) {\n        this.katana = katana;\n      }\n    }\n    const ninjaId = \"Ninja\";\n    const katanaId = \"Katana\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n\n    container.bind<Katana>(katanaId).to(Katana);\n\n    const context = plan(new MetadataReader(), container, false, TargetTypeEnum.Variable, ninjaId);\n\n    const ninja = resolveTyped<Ninja>(context);\n\n    expect(ninja.katana.use()).eql(\"Used Weapon!\");\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should run the @PostConstruct method once in the singleton scope","suites":["Resolve"],"updatePoint":{"line":1200,"column":70},"line":1200,"code":"  it(\"Should run the @PostConstruct method once in the singleton scope\", () => {\n    let timesCalled = 0;\n    @injectable()\n    class Katana {\n      @postConstruct()\n      public postConstruct() {\n        timesCalled++;\n      }\n    }\n\n    @injectable()\n    class Ninja {\n      public katana: Katana;\n      public constructor(@inject(\"Katana\") katana: Katana) {\n        this.katana = katana;\n      }\n    }\n\n    @injectable()\n    class Samurai {\n      public katana: Katana;\n      public constructor(@inject(\"Katana\") katana: Katana) {\n        this.katana = katana;\n      }\n    }\n    const ninjaId = \"Ninja\";\n    const samuraiId = \"Samurai\";\n    const katanaId = \"Katana\";\n\n    const container = new Container();\n    container.bind<Ninja>(ninjaId).to(Ninja);\n    container.bind<Samurai>(samuraiId).to(Samurai);\n    container.bind<Katana>(katanaId).to(Katana).inSingletonScope();\n    container.get(ninjaId);\n    container.get(samuraiId);\n    expect(timesCalled).to.be.equal(1);\n\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not cache bindings if a dependency in the async chain fails","suites":["Resolve"],"updatePoint":{"line":1239,"column":72},"line":1239,"code":"  it(\"Should not cache bindings if a dependency in the async chain fails\", async () => {\n    let level2Attempts = 0;\n\n    @injectable()\n    class Level2 {\n      public value: string;\n\n      public constructor(@inject(\"level1\") value: string) {\n        level2Attempts += 1;\n        this.value = value;\n      }\n    }\n\n    let level1Attempts = 0;\n\n    const container = new Container({ defaultScope: \"Singleton\", autoBindInjectable: true });\n    container.bind(\"level1\").toDynamicValue(async (context) => {\n      level1Attempts += 1;\n\n      if (level1Attempts === 1) {\n        throw new Error(\"first try failed.\");\n      }\n\n      return \"foobar\";\n    });\n    container.bind(\"a\").to(Level2);\n\n    try {\n      await container.getAsync(\"a\");\n\n      throw new Error(\"should have failed on first invocation.\");\n    } catch (ex) {\n      // ignore\n    }\n\n    const level2 = await container.getAsync<Level2>(\"a\");\n    expect(level2.value).equals(\"foobar\");\n\n    expect(level1Attempts).equals(2);\n    expect(level2Attempts).equals(1);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async when default scope is singleton","suites":["Resolve"],"updatePoint":{"line":1281,"column":58},"line":1281,"code":"  it(\"Should support async when default scope is singleton\", async () => {\n    const container = new Container({ defaultScope: \"Singleton\" });\n    container.bind(\"a\").toDynamicValue(async () => Math.random());\n\n    const object1 = await container.getAsync(\"a\");\n    const object2 = await container.getAsync(\"a\");\n\n    expect(object1).equals(object2);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should return different values if default singleton scope is overriden by bind","suites":["Resolve"],"updatePoint":{"line":1291,"column":84},"line":1291,"code":"  it(\"Should return different values if default singleton scope is overriden by bind\", async () => {\n    const container = new Container({ defaultScope: \"Singleton\" });\n    container.bind(\"a\").toDynamicValue(async () => Math.random()).inTransientScope();\n\n    const object1 = await container.getAsync(\"a\");\n    const object2 = await container.getAsync(\"a\");\n\n    expect(object1).not.equals(object2);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should only call parent async singleton once within child containers","suites":["Resolve"],"updatePoint":{"line":1301,"column":74},"line":1301,"code":"  it(\"Should only call parent async singleton once within child containers\", async () => {\n    const parent = new Container();\n    parent.bind<Date>(\"Parent\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n    const child = parent.createChild();\n    const [subject1, subject2] = await Promise.all([\n      child.getAsync<Date>(\"Parent\"),\n      child.getAsync<Date>(\"Parent\")\n    ]);\n\n    expect(subject1 === subject2).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"should not deactivate a non activated constant value","suites":["Resolve"],"updatePoint":{"line":1313,"column":58},"line":1313,"code":"  it(\"should not deactivate a non activated constant value\", () => {\n    const container = new Container();\n    container.bind<string>(\"ConstantValue\").toConstantValue(\"Constant\").onDeactivation(sinon.mock().never());\n    container.unbind(\"ConstantValue\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should return resolved instance to onDeactivation when binding is async","suites":["Resolve"],"updatePoint":{"line":1320,"column":77},"line":1320,"code":"  it(\"Should return resolved instance to onDeactivation when binding is async\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    let deactivatedDestroyable: Destroyable | null = null\n    container.bind<Destroyable>(\"Destroyable\").toDynamicValue(() => Promise.resolve(new Destroyable())).inSingletonScope()\n      .onDeactivation((instance) => new Promise((r) => {\n        deactivatedDestroyable = instance\n        r();\n      }));\n\n    await container.getAsync(\"Destroyable\");\n\n    await container.unbindAsync(\"Destroyable\");\n\n    expect(deactivatedDestroyable).instanceof(Destroyable);\n\n    // with BindingInWhenOnSyntax\n    const container2 = new Container({ defaultScope: \"Singleton\" });\n    let deactivatedDestroyable2: Destroyable | null = null\n    container2.bind<Destroyable>(\"Destroyable\").toDynamicValue(() => Promise.resolve(new Destroyable()))\n      .onDeactivation((instance) => new Promise((r) => {\n        deactivatedDestroyable2 = instance\n        r();\n      }));\n\n    await container2.getAsync(\"Destroyable\");\n\n    await container2.unbindAsync(\"Destroyable\");\n\n    expect(deactivatedDestroyable2).instanceof(Destroyable);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait on deactivation promise before returning unbindAsync()","suites":["Resolve"],"updatePoint":{"line":1355,"column":72},"line":1355,"code":"  it(\"Should wait on deactivation promise before returning unbindAsync()\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => new Promise((r) => {\n        r();\n\n        resolved = true;\n      }));\n\n    container.get(\"Destroyable\");\n\n    await container.unbindAsync(\"Destroyable\");\n\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait on predestroy promise before returning unbindAsync()","suites":["Resolve"],"updatePoint":{"line":1377,"column":70},"line":1377,"code":"  it(\"Should wait on predestroy promise before returning unbindAsync()\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return new Promise((r) => {\n          r({});\n\n          resolved = true;\n        });\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope();\n\n    container.get(\"Destroyable\");\n\n    await container.unbindAsync(\"Destroyable\");\n\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait on deactivation promise before returning unbindAllAsync()","suites":["Resolve"],"updatePoint":{"line":1402,"column":75},"line":1402,"code":"  it(\"Should wait on deactivation promise before returning unbindAllAsync()\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => new Promise((r) => {\n        r();\n\n        resolved = true;\n      }));\n\n    container.get(\"Destroyable\");\n\n    await container.unbindAllAsync();\n\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait on predestroy promise before returning unbindAllAsync()","suites":["Resolve"],"updatePoint":{"line":1424,"column":73},"line":1424,"code":"  it(\"Should wait on predestroy promise before returning unbindAllAsync()\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return new Promise((r) => {\n          r({});\n\n          resolved = true;\n        });\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope();\n\n    container.get(\"Destroyable\");\n\n    await container.unbindAllAsync();\n\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should call bind.cache.then on unbind w/ PromiseLike binding","suites":["Resolve"],"updatePoint":{"line":1449,"column":66},"line":1449,"code":"  it(\"Should call bind.cache.then on unbind w/ PromiseLike binding\", async () => {\n\n    const bindStub = sinon.stub().callsFake(() => {\n      return {\n        serviceIdentifier: \"PromiseLike\"\n      };\n    });\n\n    const stub = sinon.stub().callsFake((bindResolve) => {\n      bindResolve(bindStub());\n    });\n\n    @injectable()\n    class PromiseLike {\n      public then() {\n        return {\n          then: stub\n        };\n      }\n    }\n\n    const container = new Container();\n\n    container.bind(\"PromiseLike\").toConstantValue(new PromiseLike());\n\n    container.getAsync('PromiseLike');\n\n    container.unbindAll();\n\n    sinon.assert.calledOnce(stub);\n    sinon.assert.calledOnce(bindStub);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow transient construction with async preDestroy","suites":["Resolve"],"updatePoint":{"line":1482,"column":67},"line":1482,"code":"  it(\"Should not allow transient construction with async preDestroy\", async () => {\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return Promise.resolve();\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inTransientScope();\n\n    expect(() => container.get(\"Destroyable\")).to\n      .throw(\"@preDestroy error in class Destroyable: Class cannot be instantiated in transient scope.\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow transient construction with async deactivation","suites":["Resolve"],"updatePoint":{"line":1498,"column":69},"line":1498,"code":"  it(\"Should not allow transient construction with async deactivation\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inTransientScope()\n      .onDeactivation(() => Promise.resolve());\n\n    expect(() => container.get(\"Destroyable\")).to\n      .throw(\"onDeactivation() error in class Destroyable: Class cannot be instantiated in transient scope.\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow request construction with preDestroy","suites":["Resolve"],"updatePoint":{"line":1511,"column":59},"line":1511,"code":"  it(\"Should not allow request construction with preDestroy\", async () => {\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return;\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inRequestScope();\n\n    expect(() => container.get(\"Destroyable\")).to\n      .throw(\"@preDestroy error in class Destroyable: Class cannot be instantiated in request scope.\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow request construction with deactivation","suites":["Resolve"],"updatePoint":{"line":1527,"column":61},"line":1527,"code":"  it(\"Should not allow request construction with deactivation\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inRequestScope()\n      .onDeactivation(() => {\n        //\n      });\n\n    expect(() => container.get(\"Destroyable\")).to\n      .throw(\"onDeactivation() error in class Destroyable: Class cannot be instantiated in request scope.\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async deactivation to use the async unbindAll api","suites":["Resolve"],"updatePoint":{"line":1542,"column":84},"line":1542,"code":"  it(\"Should force a class with an async deactivation to use the async unbindAll api\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => Promise.resolve());\n\n    container.get(\"Destroyable\");\n\n    expect(() => container.unbindAll()).to\n      .throw(\"Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async pre destroy to use the async unbindAll api","suites":["Resolve"],"updatePoint":{"line":1557,"column":83},"line":1557,"code":"  it(\"Should force a class with an async pre destroy to use the async unbindAll api\", async () => {\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return Promise.resolve();\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope();\n\n    container.get(\"Destroyable\");\n\n    expect(() => container.unbindAll()).to\n      .throw(\"Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async deactivation to use the async unbind api","suites":["Resolve"],"updatePoint":{"line":1575,"column":81},"line":1575,"code":"  it(\"Should force a class with an async deactivation to use the async unbind api\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => Promise.resolve());\n\n    container.get(\"Destroyable\");\n\n    expect(() => container.unbind(\"Destroyable\")).to\n      .throw(\"Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should throw deactivation error when errors in deactivation ( sync )","suites":["Resolve"],"updatePoint":{"line":1590,"column":74},"line":1590,"code":"  it(\"Should throw deactivation error when errors in deactivation ( sync )\", () => {\n    @injectable()\n    class Destroyable {\n    }\n    const errorMessage = \"the error message\"\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => { throw new Error(errorMessage) });\n\n    container.get(\"Destroyable\");\n\n    const expectedErrorMessage = ERROR_MSGS.ON_DEACTIVATION_ERROR(\"Destroyable\", errorMessage)\n\n    expect(() => container.unbind(\"Destroyable\")).to\n      .throw(expectedErrorMessage);\n  })","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should throw deactivation error when errors in deactivation ( async )","suites":["Resolve"],"updatePoint":{"line":1607,"column":75},"line":1607,"code":"  it(\"Should throw deactivation error when errors in deactivation ( async )\", async () => {\n    @injectable()\n    class Destroyable {\n    }\n    const errorMessage = \"the error message\"\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope()\n      .onDeactivation(() => Promise.reject(new Error(errorMessage)));\n\n    container.get(\"Destroyable\");\n\n    const expectedErrorMessage = ERROR_MSGS.ON_DEACTIVATION_ERROR(\"Destroyable\", errorMessage)\n\n    let error: any\n    try {\n      await container.unbindAsync(\"Destroyable\")\n    } catch (e) {\n      error = e\n    }\n    expect(error.message).to.eql(expectedErrorMessage)\n  })","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should invoke destroy in order (all async): child container, parent container, binding, class","suites":["Resolve"],"updatePoint":{"line":1629,"column":99},"line":1629,"code":"  it(\"Should invoke destroy in order (all async): child container, parent container, binding, class\", async () => {\n    let roll = 1;\n    let binding = null;\n    let klass = null;\n    let parent = null;\n    let child = null;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return new Promise((presolve) => {\n          klass = roll;\n          roll += 1;\n          presolve({});\n        });\n      }\n    }\n\n    const container = new Container();\n    container.onDeactivation(\"Destroyable\", () => {\n      return new Promise((presolve) => {\n        parent = roll;\n        roll += 1;\n        presolve();\n      });\n    });\n\n    const childContainer = container.createChild();\n    childContainer.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope().onDeactivation(() => new Promise((presolve) => {\n      binding = roll;\n      roll += 1;\n      presolve();\n    }));\n    childContainer.onDeactivation(\"Destroyable\", () => {\n      return new Promise((presolve) => {\n        child = roll;\n        roll += 1;\n        presolve();\n      });\n    });\n\n    childContainer.get(\"Destroyable\");\n    await childContainer.unbindAsync(\"Destroyable\");\n\n    expect(roll).eql(5);\n    expect(child).eql(1);\n    expect(parent).eql(2);\n    expect(binding).eql(3);\n    expect(klass).eql(4);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should invoke destroy in order (sync + async): child container, parent container, binding, class","suites":["Resolve"],"updatePoint":{"line":1681,"column":102},"line":1681,"code":"  it(\"Should invoke destroy in order (sync + async): child container, parent container, binding, class\", async () => {\n    let roll = 1;\n    let binding = null;\n    let klass = null;\n    let parent = null;\n    let child = null;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return new Promise((presolve) => {\n          klass = roll;\n          roll += 1;\n          presolve({});\n        });\n      }\n    }\n\n    const container = new Container();\n    container.onDeactivation(\"Destroyable\", () => {\n      parent = roll;\n      roll += 1;\n    });\n\n    const childContainer = container.createChild();\n    childContainer.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope().onDeactivation(() => {\n      binding = roll;\n      roll += 1;\n    });\n    childContainer.onDeactivation(\"Destroyable\", () => {\n      return new Promise((presolve) => {\n        child = roll;\n        roll += 1;\n        presolve();\n      });\n    });\n\n    childContainer.get(\"Destroyable\");\n    await childContainer.unbindAsync(\"Destroyable\");\n\n    expect(roll).eql(5);\n    expect(child).eql(1);\n    expect(parent).eql(2);\n    expect(binding).eql(3);\n    expect(klass).eql(4);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should invoke destroy in order (all sync): child container, parent container, binding, class","suites":["Resolve"],"updatePoint":{"line":1729,"column":98},"line":1729,"code":"  it(\"Should invoke destroy in order (all sync): child container, parent container, binding, class\", () => {\n    let roll = 1;\n    let binding = null;\n    let klass = null;\n    let parent = null;\n    let child = null;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        klass = roll;\n        roll += 1;\n      }\n    }\n\n    const container = new Container();\n    container.onDeactivation(\"Destroyable\", () => {\n      parent = roll;\n      roll += 1;\n    });\n\n    const childContainer = container.createChild();\n    childContainer.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope().onDeactivation(() => {\n      binding = roll;\n      roll += 1;\n    });\n    childContainer.onDeactivation(\"Destroyable\", () => {\n      child = roll;\n      roll += 1;\n    });\n\n    childContainer.get(\"Destroyable\");\n    childContainer.unbind(\"Destroyable\");\n\n    expect(roll).eql(5);\n    expect(child).eql(1);\n    expect(parent).eql(2);\n    expect(binding).eql(3);\n    expect(klass).eql(4);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should invoke destroy in order (async): child container, parent container, binding, class","suites":["Resolve"],"updatePoint":{"line":1771,"column":95},"line":1771,"code":"  it(\"Should invoke destroy in order (async): child container, parent container, binding, class\", async () => {\n    let roll = 1;\n    let binding = null;\n    let klass = null;\n    let parent = null;\n    let child = null;\n\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public async myPreDestroyMethod() {\n        klass = roll;\n        roll += 1;\n      }\n    }\n\n    const container = new Container();\n    container.onDeactivation(\"Destroyable\", async () => {\n      parent = roll;\n      roll += 1;\n    });\n\n    const childContainer = container.createChild();\n    childContainer.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope().onDeactivation(() => {\n      binding = roll;\n      roll += 1;\n    });\n    childContainer.onDeactivation(\"Destroyable\", () => {\n      child = roll;\n      roll += 1;\n    });\n\n    childContainer.get(\"Destroyable\");\n    await childContainer.unbindAsync(\"Destroyable\");\n\n    expect(roll).eql(5);\n    expect(child).eql(1);\n    expect(parent).eql(2);\n    expect(binding).eql(3);\n    expect(klass).eql(4);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async pre destroy to use the async unbind api","suites":["Resolve"],"updatePoint":{"line":1813,"column":80},"line":1813,"code":"  it(\"Should force a class with an async pre destroy to use the async unbind api\", async () => {\n    @injectable()\n    class Destroyable {\n      @preDestroy()\n      public myPreDestroyMethod() {\n        return Promise.resolve();\n      }\n    }\n\n    const container = new Container();\n    container.bind<Destroyable>(\"Destroyable\").to(Destroyable).inSingletonScope();\n\n    container.get(\"Destroyable\");\n\n    expect(() => container.unbind(\"Destroyable\")).to\n      .throw(\"Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async onActivation to use the async api","suites":["Resolve"],"updatePoint":{"line":1831,"column":74},"line":1831,"code":"  it(\"Should force a class with an async onActivation to use the async api\", async () => {\n    @injectable()\n    class Constructable {\n    }\n\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").to(Constructable).inSingletonScope()\n      .onActivation(() => Promise.resolve());\n\n    expect(() => container.get(\"Constructable\")).to.throw(`You are attempting to construct 'Constructable' in a synchronous way\n but it has asynchronous dependencies.`);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should force a class with an async post construct to use the async api","suites":["Resolve"],"updatePoint":{"line":1844,"column":76},"line":1844,"code":"  it(\"Should force a class with an async post construct to use the async api\", async () => {\n    @injectable()\n    class Constructable {\n      @postConstruct()\n      public myPostConstructMethod() {\n        return Promise.resolve();\n      }\n    }\n\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").to(Constructable);\n\n    expect(() => container.get(\"Constructable\")).to.throw(`You are attempting to construct 'Constructable' in a synchronous way\n but it has asynchronous dependencies.`);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should retry promise if first time failed","suites":["Resolve"],"updatePoint":{"line":1860,"column":47},"line":1860,"code":"  it(\"Should retry promise if first time failed\", async () => {\n    @injectable()\n    class Constructable {\n    }\n\n    let attemped = false;\n\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").toDynamicValue(() => {\n      if (attemped) {\n        return Promise.resolve(new Constructable());\n      }\n\n      attemped = true;\n\n      return Promise.reject(\"break\");\n    }).inSingletonScope();\n\n    try {\n      await container.getAsync(\"Constructable\");\n\n      throw new Error(\"should have thrown exception.\");\n    } catch (ex) {\n      await container.getAsync(\"Constructable\");\n    }\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should return resolved instance to onActivation when binding is async","suites":["Resolve"],"updatePoint":{"line":1887,"column":75},"line":1887,"code":"  it(\"Should return resolved instance to onActivation when binding is async\", async () => {\n    @injectable()\n    class Constructable {\n    }\n    let activated: Constructable | null = null\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").toDynamicValue(() => Promise.resolve(new Constructable())).inSingletonScope()\n      .onActivation((context, c) => new Promise((r) => {\n        activated = c\n        r(c);\n      }));\n\n    await container.getAsync(\"Constructable\");\n    expect(activated).instanceof(Constructable);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow sync get if an async activation was added to container","suites":["Resolve"],"updatePoint":{"line":1903,"column":77},"line":1903,"code":"  it(\"Should not allow sync get if an async activation was added to container\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toConstantValue(\"bar\");\n\n    container.onActivation(\"foo\", () => Promise.resolve(\"baz\"));\n\n    expect(() => container.get(\"foo\")).to.throw(`You are attempting to construct 'foo' in a synchronous way\n but it has asynchronous dependencies.`);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of a previously binded sync object (without activation)","suites":["Resolve"],"updatePoint":{"line":1913,"column":94},"line":1913,"code":"  it(\"Should allow onActivation (sync) of a previously binded sync object (without activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toConstantValue(\"bar\");\n\n    container.onActivation(\"foo\", () => \"baz\");\n\n    const result = container.get(\"foo\");\n\n    expect(result).eql(\"baz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation to replace objects in async autoBindInjectable chain","suites":["Resolve"],"updatePoint":{"line":1924,"column":84},"line":1924,"code":"  it(\"Should allow onActivation to replace objects in async autoBindInjectable chain\", async () => {\n    class Level1 {\n\n    }\n\n    @injectable()\n    class Level2 {\n      public level1: Level1;\n\n      constructor(@inject(Level1) l1: Level1) {\n        this.level1 = l1;\n      }\n    }\n\n    @injectable()\n    class Level3 {\n      public level2: Level2;\n\n      constructor(@inject(Level2) l2: Level2) {\n        this.level2 = l2;\n      }\n    }\n\n    const constructedLevel2 = new Level2(new Level1());\n\n    const container = new Container({ autoBindInjectable: true, defaultScope: \"Singleton\" });\n    container.bind(Level1).toDynamicValue(() => Promise.resolve(new Level1()));\n    container.onActivation(Level2, () => {\n      return Promise.resolve(constructedLevel2);\n    });\n\n    const level2 = await container.getAsync(Level2);\n\n    expect(level2).equals(constructedLevel2);\n\n    const level3 = await container.getAsync(Level3);\n\n    expect(level3.level2).equals(constructedLevel2);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of a previously binded sync object (without activation)","suites":["Resolve"],"updatePoint":{"line":1964,"column":95},"line":1964,"code":"  it(\"Should allow onActivation (async) of a previously binded sync object (without activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toConstantValue(\"bar\");\n\n    container.onActivation(\"foo\", () => Promise.resolve(\"baz\"));\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"baz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of a previously binded async object (without activation)","suites":["Resolve"],"updatePoint":{"line":1975,"column":95},"line":1975,"code":"  it(\"Should allow onActivation (sync) of a previously binded async object (without activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toDynamicValue(() => Promise.resolve(\"bar\"));\n\n    container.onActivation(\"foo\", () => \"baz\");\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"baz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of a previously binded async object (without activation)","suites":["Resolve"],"updatePoint":{"line":1986,"column":96},"line":1986,"code":"  it(\"Should allow onActivation (async) of a previously binded async object (without activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toDynamicValue(() => Promise.resolve(\"bar\"));\n\n    container.onActivation(\"foo\", () => Promise.resolve(\"baz\"));\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"baz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of a previously binded sync object (with activation)","suites":["Resolve"],"updatePoint":{"line":1997,"column":91},"line":1997,"code":"  it(\"Should allow onActivation (sync) of a previously binded sync object (with activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toConstantValue(\"bar\").onActivation(() => \"bum\");\n\n    container.onActivation(\"foo\", (context, previous) => `${previous}baz`);\n\n    const result = container.get(\"foo\");\n\n    expect(result).eql(\"bumbaz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of a previously binded sync object (with activation)","suites":["Resolve"],"updatePoint":{"line":2008,"column":92},"line":2008,"code":"  it(\"Should allow onActivation (async) of a previously binded sync object (with activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toConstantValue(\"bar\").onActivation(() => \"bum\");\n\n    container.onActivation(\"foo\", (context, previous) => Promise.resolve(`${previous}baz`));\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"bumbaz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of a previously binded async object (with activation)","suites":["Resolve"],"updatePoint":{"line":2019,"column":92},"line":2019,"code":"  it(\"Should allow onActivation (sync) of a previously binded async object (with activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toDynamicValue(() => Promise.resolve(\"bar\")).onActivation(() => \"bum\");\n\n    container.onActivation(\"foo\", (context, previous) => `${previous}baz`);\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"bumbaz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of a previously binded async object (with activation)","suites":["Resolve"],"updatePoint":{"line":2030,"column":93},"line":2030,"code":"  it(\"Should allow onActivation (async) of a previously binded async object (with activation)\", async () => {\n    const container = new Container();\n    container.bind(\"foo\").toDynamicValue(() => Promise.resolve(\"bar\")).onActivation(() => \"bum\");\n\n    container.onActivation(\"foo\", (context, previous) => Promise.resolve(`${previous}baz`));\n\n    const result = await container.getAsync(\"foo\");\n\n    expect(result).eql(\"bumbaz\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of parent (async) through autobind tree","suites":["Resolve"],"updatePoint":{"line":2041,"column":78},"line":2041,"code":"  it(\"Should allow onActivation (sync) of parent (async) through autobind tree\", async () => {\n    class Parent {\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Parent();\n    // @ts-ignore\n    constructed.foo = \"bar\";\n\n    container.onActivation(Parent, () => constructed);\n\n    const result = await container.getAsync(Child);\n\n    expect(result.parent).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (sync) of child (async) through autobind tree","suites":["Resolve"],"updatePoint":{"line":2068,"column":77},"line":2068,"code":"  it(\"Should allow onActivation (sync) of child (async) through autobind tree\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Child(new Parent());\n\n    container.onActivation(Child, () => constructed);\n\n    const result = await container.getAsync(Child);\n\n    expect(result).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of parent (async) through autobind tree","suites":["Resolve"],"updatePoint":{"line":2094,"column":79},"line":2094,"code":"  it(\"Should allow onActivation (async) of parent (async) through autobind tree\", async () => {\n    class Parent {\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Parent();\n\n    container.onActivation(Parent, () => Promise.resolve(constructed));\n\n    const result = await container.getAsync(Child);\n\n    expect(result.parent).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation (async) of child (async) through autobind tree","suites":["Resolve"],"updatePoint":{"line":2119,"column":78},"line":2119,"code":"  it(\"Should allow onActivation (async) of child (async) through autobind tree\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Child(new Parent());\n\n    container.onActivation(Child, () => Promise.resolve(constructed));\n\n    const result = await container.getAsync(Child);\n\n    expect(result).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation of child on parent container","suites":["Resolve"],"updatePoint":{"line":2145,"column":60},"line":2145,"code":"  it(\"Should allow onActivation of child on parent container\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Child(new Parent());\n\n    container.onActivation(Child, () => Promise.resolve(constructed));\n\n    const child = container.createChild();\n\n    const result = await child.getAsync(Child);\n\n    expect(result).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation of parent on parent container","suites":["Resolve"],"updatePoint":{"line":2173,"column":61},"line":2173,"code":"  it(\"Should allow onActivation of parent on parent container\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Parent();\n\n    container.onActivation(Parent, () => Promise.resolve(constructed));\n\n    const child = container.createChild();\n\n    const result = await child.getAsync(Child);\n\n    expect(result.parent).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should allow onActivation of child from child container","suites":["Resolve"],"updatePoint":{"line":2201,"column":61},"line":2201,"code":"  it(\"Should allow onActivation of child from child container\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent()));\n\n    const constructed = new Child(new Parent());\n\n    const child = container.createChild();\n    child.onActivation(Child, () => Promise.resolve(constructed));\n\n    const result = await child.getAsync(Child);\n\n    expect(result).equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should priortize onActivation of parent container over child container","suites":["Resolve"],"updatePoint":{"line":2228,"column":76},"line":2228,"code":"  it(\"Should priortize onActivation of parent container over child container\", () => {\n    const container = new Container();\n    container.onActivation(\"foo\", (context, previous) => `${previous}baz`);\n    container.onActivation(\"foo\", (context, previous) => `${previous}1`);\n\n    const child = container.createChild();\n\n    child.bind<string>(\"foo\").toConstantValue(\"bar\").onActivation((c, previous) => `${previous}bah`);\n    child.onActivation(\"foo\", (context, previous) => `${previous}bum`);\n    child.onActivation(\"foo\", (context, previous) => `${previous}2`);\n\n    const result = child.get(\"foo\");\n\n    expect(result).equals(\"barbahbaz1bum2\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should priortize async onActivation of parent container over child container (async)","suites":["Resolve"],"updatePoint":{"line":2244,"column":90},"line":2244,"code":"  it(\"Should priortize async onActivation of parent container over child container (async)\", async () => {\n    const container = new Container();\n    container.onActivation(\"foo\", async (context, previous) => `${previous}baz`);\n    container.onActivation(\"foo\", async (context, previous) => `${previous}1`);\n\n    const child = container.createChild();\n\n    child.bind<string>(\"foo\").toConstantValue(\"bar\").onActivation((c, previous) => `${previous}bah`);\n    child.onActivation(\"foo\", async (context, previous) => `${previous}bum`);\n    child.onActivation(\"foo\", async (context, previous) => `${previous}2`);\n\n    const result = await child.getAsync(\"foo\");\n\n    expect(result).equals(\"barbahbaz1bum2\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should not allow onActivation of parent on child container","suites":["Resolve"],"updatePoint":{"line":2260,"column":64},"line":2260,"code":"  it(\"Should not allow onActivation of parent on child container\", async () => {\n    class Parent {\n\n    }\n\n    @injectable()\n    class Child {\n      public parent: Parent;\n\n      public constructor(@inject(Parent) parent: Parent) {\n        this.parent = parent;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Parent>(Parent).toDynamicValue(() => Promise.resolve(new Parent())).inSingletonScope();\n\n    const constructed = new Parent();\n\n    const child = container.createChild();\n    child.onActivation(Parent, () => Promise.resolve(constructed));\n\n    const result = await child.getAsync(Child);\n\n    expect(result.parent).not.equals(constructed);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait until onActivation promise resolves before returning object","suites":["Resolve"],"updatePoint":{"line":2287,"column":77},"line":2287,"code":"  it(\"Should wait until onActivation promise resolves before returning object\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Constructable {\n    }\n\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").to(Constructable).inSingletonScope()\n      .onActivation((context, c) => new Promise((r) => {\n        resolved = true;\n        r(c);\n      }));\n\n    const result = await container.getAsync(\"Constructable\");\n\n    expect(result).instanceof(Constructable);\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should wait until postConstruct promise resolves before returning object","suites":["Resolve"],"updatePoint":{"line":2307,"column":78},"line":2307,"code":"  it(\"Should wait until postConstruct promise resolves before returning object\", async () => {\n    let resolved = false;\n\n    @injectable()\n    class Constructable {\n      @postConstruct()\n      public myPostConstructMethod() {\n        return new Promise((r) => {\n          resolved = true;\n          r({});\n        });\n      }\n    }\n\n    const container = new Container();\n    container.bind<Constructable>(\"Constructable\").to(Constructable);\n\n    const result = await container.getAsync(\"Constructable\");\n\n    expect(result).instanceof(Constructable);\n    expect(resolved).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should only call async method once if marked as singleton (indirect)","suites":["Resolve"],"updatePoint":{"line":2330,"column":74},"line":2330,"code":"  it(\"Should only call async method once if marked as singleton (indirect)\", async () => {\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public constructor(@inject(\"Date\") currentDate: Date) {\n        expect(currentDate).instanceOf(Date);\n\n        this.currentDate = currentDate;\n      }\n      public doSomething() {\n        return this.currentDate;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    const subject1 = await container.getAsync<UseDate>(\"UseDate\");\n    const subject2 = await container.getAsync<UseDate>(\"UseDate\");\n    expect(subject1.doSomething() === subject2.doSomething()).eql(true);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async singletons when using autoBindInjectable","suites":["Resolve"],"updatePoint":{"line":2353,"column":67},"line":2353,"code":"  it(\"Should support async singletons when using autoBindInjectable\", async () => {\n    @injectable()\n    class AsyncValue {\n      public date: Date;\n      public constructor(@inject(\"Date\") date: Date) {\n        this.date = date;\n      }\n    }\n\n    @injectable()\n    class MixedDependency {\n      public asyncValue: AsyncValue;\n      public date!: Date;\n      public constructor(@inject(AsyncValue) asyncValue: AsyncValue) {\n        expect(asyncValue).instanceOf(AsyncValue);\n\n        this.asyncValue = asyncValue;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true, defaultScope: \"Singleton\" });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    const object1 = await container.getAsync<MixedDependency>(MixedDependency);\n    const object2 = await container.getAsync<MixedDependency>(MixedDependency);\n\n    expect(object1).equals(object2);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support shared async singletons when using autoBindInjectable","suites":["Resolve"],"updatePoint":{"line":2382,"column":74},"line":2382,"code":"  it(\"Should support shared async singletons when using autoBindInjectable\", async () => {\n    @injectable()\n    class AsyncValue {\n      public date: Date;\n      public constructor(@inject(\"Date\") date: Date) {\n        this.date = date;\n      }\n    }\n\n    @injectable()\n    class MixedDependency {\n      public asyncValue: AsyncValue;\n      public constructor(@inject(AsyncValue) asyncValue: AsyncValue) {\n        expect(asyncValue).instanceOf(AsyncValue);\n\n        this.asyncValue = asyncValue;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true, defaultScope: \"Singleton\" });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    const async = await container.getAsync<AsyncValue>(AsyncValue);\n\n    const object1 = await container.getAsync<MixedDependency>(MixedDependency);\n\n    expect(async).equals(object1.asyncValue);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async dependencies in multiple layers","suites":["Resolve"],"updatePoint":{"line":2411,"column":58},"line":2411,"code":"  it(\"Should support async dependencies in multiple layers\", async () => {\n    @injectable()\n    class AsyncValue {\n      public date: Date;\n      public constructor(@inject(\"Date\") date: Date) {\n        //expect(date).instanceOf(date);\n\n        this.date = date;\n      }\n    }\n\n    @injectable()\n    class MixedDependency {\n      public asyncValue: AsyncValue;\n      public date: Date;\n      public constructor(@inject(AsyncValue) asyncValue: AsyncValue, @inject(\"Date\") date: Date) {\n        expect(asyncValue).instanceOf(AsyncValue);\n        expect(date).instanceOf(Date);\n\n        this.date = date;\n        this.asyncValue = asyncValue;\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    const subject1 = await container.getAsync<MixedDependency>(MixedDependency);\n    expect(subject1.date).instanceOf(Date);\n    expect(subject1.asyncValue).instanceOf(AsyncValue);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async values already in cache","suites":["Resolve"],"updatePoint":{"line":2443,"column":50},"line":2443,"code":"  it(\"Should support async values already in cache\", async () => {\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    expect(await container.getAsync<Date>(\"Date\")).instanceOf(Date); // causes container to cache singleton as Lazy object\n    expect(await container.getAsync<Date>(\"Date\")).instanceOf(Date);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async values already in cache when there dependencies","suites":["Resolve"],"updatePoint":{"line":2451,"column":74},"line":2451,"code":"  it(\"Should support async values already in cache when there dependencies\", async () => {\n    @injectable()\n    class HasDependencies {\n      public constructor(@inject(\"Date\") date: Date) {\n        expect(date).instanceOf(Date);\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    expect(await container.getAsync<Date>(\"Date\")).instanceOf(Date); // causes container to cache singleton as Lazy object\n    await container.getAsync<HasDependencies>(HasDependencies);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should support async values already in cache when there are transient dependencies","suites":["Resolve"],"updatePoint":{"line":2466,"column":88},"line":2466,"code":"  it(\"Should support async values already in cache when there are transient dependencies\", async () => {\n    @injectable()\n    class Parent {\n      public constructor(@inject(\"Date\") date: Date) {\n        expect(date).instanceOf(Date);\n      }\n    }\n\n    @injectable()\n    class Child {\n      public constructor(\n        @inject(Parent) parent: Parent,\n        @inject(\"Date\") date: Date\n      ) {\n        expect(parent).instanceOf(Parent);\n        expect(date).instanceOf(Date);\n      }\n    }\n\n    const container = new Container({ autoBindInjectable: true });\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date())).inSingletonScope();\n\n    expect(await container.getAsync<Date>(\"Date\")).instanceOf(Date); // causes container to cache singleton as Lazy object\n    await container.getAsync<Child>(Child);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to mix async bindings with non-async values","suites":["Resolve"],"updatePoint":{"line":2492,"column":64},"line":2492,"code":"  it(\"Should be able to mix async bindings with non-async values\", async () => {\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public foobar: string;\n\n      public constructor(@inject(\"Date\") currentDate: Date, @inject(\"Static\") foobar: string) {\n        expect(currentDate).instanceOf(Date);\n\n        this.currentDate = currentDate;\n        this.foobar = foobar;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date()));\n    container.bind<String>(\"Static\").toConstantValue(\"foobar\");\n\n    const subject1 = await container.getAsync<UseDate>(\"UseDate\");\n    expect(subject1.foobar).eql(\"foobar\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should throw exception if using sync API with async dependencies","suites":["Resolve"],"updatePoint":{"line":2515,"column":70},"line":2515,"code":"  it(\"Should throw exception if using sync API with async dependencies\", async () => {\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public constructor(@inject(\"Date\") currentDate: Date) {\n        expect(currentDate).instanceOf(Date);\n\n        this.currentDate = currentDate;\n      }\n      public doSomething() {\n        return this.currentDate;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date()));\n\n    expect(() => container.get<UseDate>(\"UseDate\")).to.throw(`You are attempting to construct 'UseDate' in a synchronous way\n but it has asynchronous dependencies.`);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve indirect Promise bindings","suites":["Resolve"],"updatePoint":{"line":2537,"column":57},"line":2537,"code":"  it(\"Should be able to resolve indirect Promise bindings\", async () => {\n    @injectable()\n    class UseDate implements UseDate {\n      public currentDate: Date;\n      public constructor(@inject(\"Date\") currentDate: Date) {\n        expect(currentDate).instanceOf(Date);\n\n        this.currentDate = currentDate;\n      }\n      public doSomething() {\n        return this.currentDate;\n      }\n    }\n\n    const container = new Container();\n    container.bind<UseDate>(\"UseDate\").to(UseDate);\n    container.bind<Date>(\"Date\").toDynamicValue(() => Promise.resolve(new Date()));\n\n    const subject1 = await container.getAsync<UseDate>(\"UseDate\");\n    const subject2 = await container.getAsync<UseDate>(\"UseDate\");\n    expect(subject1.doSomething() === subject2.doSomething()).eql(false);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to resolve direct promise bindings","suites":["Resolve"],"updatePoint":{"line":2560,"column":55},"line":2560,"code":"  it(\"Should be able to resolve direct promise bindings\", async () => {\n    const container = new Container();\n    container.bind<string>(\"async\").toDynamicValue(() => Promise.resolve(\"foobar\"));\n\n    const value = await container.getAsync<string>(\"async\");\n    expect(value).eql(\"foobar\");\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should error if trying to resolve an promise in sync API","suites":["Resolve"],"updatePoint":{"line":2568,"column":62},"line":2568,"code":"  it(\"Should error if trying to resolve an promise in sync API\", () => {\n    const container = new Container();\n    container.bind<string>(\"async\").toDynamicValue(() => Promise.resolve(\"foobar\"));\n\n    expect(() => container.get<string>(\"async\")).to.throw(`You are attempting to construct 'async' in a synchronous way\n but it has asynchronous dependencies.`);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should cache a a resolved value on singleton when possible","suites":["Resolve"],"updatePoint":{"line":2576,"column":64},"line":2576,"code":"  it(\"Should cache a a resolved value on singleton when possible\", async () => {\n    const container = new Container();\n\n    const asyncServiceIdentifier = \"async\";\n\n    const asyncServiceDynamicResolvedValue = \"foobar\";\n    const asyncServiceDynamicValue = Promise.resolve(asyncServiceDynamicResolvedValue);\n    const asyncServiceDynamicValueCallback = sinon.spy(() => asyncServiceDynamicValue);\n\n    container\n      .bind<string>(asyncServiceIdentifier)\n      .toDynamicValue(asyncServiceDynamicValueCallback)\n      .inSingletonScope();\n\n    const serviceFromGetAsync = await container.getAsync(asyncServiceIdentifier);\n\n    await asyncServiceDynamicValue;\n\n    const serviceFromGet = container.get(asyncServiceIdentifier);\n\n    expect(asyncServiceDynamicValueCallback.callCount).to.eq(1);\n    expect(serviceFromGetAsync).eql(asyncServiceDynamicResolvedValue);\n    expect(serviceFromGet).eql(asyncServiceDynamicResolvedValue);\n  });","file":"resolution/resolver.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingInSyntax"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInSyntax = new BindingInSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingInSyntax: any = bindingInSyntax;\n\n    expect(_bindingInSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_in_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to configure the scope of a binding","suites":["BindingInSyntax"],"updatePoint":{"line":23,"column":56},"line":23,"code":"  it(\"Should be able to configure the scope of a binding\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInSyntax = new BindingInSyntax<Ninja>(binding);\n\n    // default scope is transient\n    expect(binding.scope).eql(BindingScopeEnum.Transient);\n\n    // singleton scope\n    bindingInSyntax.inSingletonScope();\n    expect(binding.scope).eql(BindingScopeEnum.Singleton);\n\n    // set transient scope explicitly\n    bindingInSyntax.inTransientScope();\n    expect(binding.scope).eql(BindingScopeEnum.Transient);\n\n  });","file":"syntax/binding_in_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingInWhenOnSyntax"],"updatePoint":{"line":21,"column":45},"line":21,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInWhenOnSyntax = new BindingInWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingInWhenOnSyntax: any = bindingInWhenOnSyntax;\n\n    expect(_bindingInWhenOnSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_in_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should provide access to BindingInSyntax methods","suites":["BindingInWhenOnSyntax"],"updatePoint":{"line":36,"column":54},"line":36,"code":"  it(\"Should provide access to BindingInSyntax methods\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInWhenOnSyntax = new BindingInWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingInWhenOnSyntax: any = bindingInWhenOnSyntax;\n\n    // stubs for BindingWhenSyntax methods\n    const inSingletonScopeStub = sinon.stub(_bindingInWhenOnSyntax._bindingInSyntax, \"inSingletonScope\").returns(null);\n    const inTransientScopeStub = sinon.stub(_bindingInWhenOnSyntax._bindingInSyntax, \"inTransientScope\").returns(null);\n\n    // invoke BindingWhenOnSyntax methods\n    bindingInWhenOnSyntax.inSingletonScope();\n    bindingInWhenOnSyntax.inTransientScope();\n\n    // assert invoked BindingWhenSyntax methods\n    expect(inSingletonScopeStub.callCount).eql(1);\n    expect(inTransientScopeStub.callCount).eql(1);\n\n  });","file":"syntax/binding_in_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should provide access to BindingWhenSyntax methods","suites":["BindingInWhenOnSyntax"],"updatePoint":{"line":61,"column":56},"line":61,"code":"  it(\"Should provide access to BindingWhenSyntax methods\", () => {\n\n    interface Army { }\n\n    @injectable()\n    class Army implements Army { }\n\n    interface ZombieArmy { }\n\n    @injectable()\n    class ZombieArmy implements ZombieArmy { }\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInWhenOnSyntax = new BindingInWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingInWhenOnSyntax: any = bindingInWhenOnSyntax;\n\n    // stubs for BindingWhenSyntax methods\n    const whenStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"when\").returns(null);\n    const whenTargetNamedStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"whenTargetNamed\").returns(null);\n    const whenTargetTaggedStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"whenTargetTagged\").returns(null);\n    const whenInjectedIntoStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"whenInjectedInto\").returns(null);\n    const whenParentNamedStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"whenParentNamed\").returns(null);\n    const whenParentTaggedStub = sinon.stub(_bindingInWhenOnSyntax._bindingWhenSyntax, \"whenParentTagged\").returns(null);\n\n    const whenAnyAncestorIsStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorIs\").returns(null);\n\n    const whenNoAncestorIsStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorIs\").returns(null);\n\n    const whenNoAncestorNamedStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorNamed\").returns(null);\n\n    const whenAnyAncestorNamedStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorNamed\").returns(null);\n\n    const whenNoAncestorTaggedStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorTagged\").returns(null);\n\n    const whenAnyAncestorTaggedStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorTagged\").returns(null);\n\n    const whenAnyAncestorMatchesStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorMatches\").returns(null);\n\n    const whenNoAncestorMatchesStub = sinon.stub(\n      _bindingInWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorMatches\").returns(null);\n\n    // invoke BindingWhenOnSyntax methods\n    bindingInWhenOnSyntax.when((request: interfaces.Request) => true);\n    bindingInWhenOnSyntax.whenTargetNamed(\"test\");\n    bindingInWhenOnSyntax.whenTargetTagged(\"test\", true);\n    bindingInWhenOnSyntax.whenInjectedInto(\"army\");\n    bindingInWhenOnSyntax.whenInjectedInto(Army);\n    bindingInWhenOnSyntax.whenParentNamed(\"test\");\n    bindingInWhenOnSyntax.whenParentTagged(\"test\", true);\n    bindingInWhenOnSyntax.whenAnyAncestorIs(Army);\n    bindingInWhenOnSyntax.whenNoAncestorIs(ZombieArmy);\n    bindingInWhenOnSyntax.whenAnyAncestorNamed(\"test\");\n    bindingInWhenOnSyntax.whenAnyAncestorTagged(\"test\", true);\n    bindingInWhenOnSyntax.whenNoAncestorNamed(\"test\");\n    bindingInWhenOnSyntax.whenNoAncestorTagged(\"test\", true);\n    bindingInWhenOnSyntax.whenAnyAncestorMatches((request: interfaces.Request) => true);\n    bindingInWhenOnSyntax.whenNoAncestorMatches((request: interfaces.Request) => true);\n\n    // assert invoked BindingWhenSyntax methods\n    expect(whenStub.callCount).eql(1);\n    expect(whenTargetNamedStub.callCount).eql(1);\n    expect(whenTargetTaggedStub.callCount).eql(1);\n    expect(whenInjectedIntoStub.callCount).eql(2);\n    expect(whenParentNamedStub.callCount).eql(1);\n    expect(whenAnyAncestorIsStub.callCount).eql(1);\n    expect(whenNoAncestorIsStub.callCount).eql(1);\n    expect(whenParentTaggedStub.callCount).eql(1);\n    expect(whenAnyAncestorNamedStub.callCount).eql(1);\n    expect(whenAnyAncestorTaggedStub.callCount).eql(1);\n    expect(whenNoAncestorNamedStub.callCount).eql(1);\n    expect(whenNoAncestorTaggedStub.callCount).eql(1);\n    expect(whenAnyAncestorMatchesStub.callCount).eql(1);\n    expect(whenNoAncestorMatchesStub.callCount).eql(1);\n\n  });","file":"syntax/binding_in_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should provide access to BindingOnSyntax methods","suites":["BindingInWhenOnSyntax"],"updatePoint":{"line":149,"column":54},"line":149,"code":"  it(\"Should provide access to BindingOnSyntax methods\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingInWhenOnSyntax = new BindingInWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingInWhenOnSyntax: any = bindingInWhenOnSyntax;\n\n    // stubs for BindingWhenSyntax methods\n    const onActivationStub = sinon.stub(_bindingInWhenOnSyntax._bindingOnSyntax, \"onActivation\").returns(null);\n\n    // invoke BindingWhenOnSyntax methods\n    bindingInWhenOnSyntax.onActivation((context: interfaces.Context, ninja: Ninja) =>\n      // DO NOTHING\n      ninja);\n\n    // assert invoked BindingWhenSyntax methods\n    expect(onActivationStub.callCount).eql(1);\n\n  });","file":"syntax/binding_in_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingOnSyntax"],"updatePoint":{"line":9,"column":45},"line":9,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingOnSyntax = new BindingOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingOnSyntax: any = bindingOnSyntax;\n\n    expect(_bindingOnSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to configure the activation handler of a binding","suites":["BindingOnSyntax"],"updatePoint":{"line":24,"column":69},"line":24,"code":"  it(\"Should be able to configure the activation handler of a binding\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingOnSyntax = new BindingOnSyntax<Ninja>(binding);\n\n    bindingOnSyntax.onActivation((context: interfaces.Context, ninja: Ninja) => {\n      const handler = {};\n      return new Proxy<Ninja>(ninja, handler);\n    });\n\n    expect(binding.onActivation).not.to.eql(null);\n\n  });","file":"syntax/binding_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingToSyntax"],"updatePoint":{"line":12,"column":45},"line":12,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingToSyntax = new BindingToSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingToSyntax: any = bindingToSyntax;\n\n    expect(_bindingToSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_to_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to configure the type of a binding","suites":["BindingToSyntax"],"updatePoint":{"line":27,"column":55},"line":27,"code":"  it(\"Should be able to configure the type of a binding\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    // let bindingWithClassAsId = new Binding<Ninja>(Ninja, BindingScopeEnum.Transient);\n    const bindingToSyntax = new BindingToSyntax<Ninja>(binding);\n\n    expect(binding.type).eql(BindingTypeEnum.Invalid);\n\n    bindingToSyntax.to(Ninja);\n    expect(binding.type).eql(BindingTypeEnum.Instance);\n    expect(binding.implementationType).not.to.eql(null);\n\n    (bindingToSyntax as any)._binding = binding;\n    bindingToSyntax.toConstantValue(new Ninja());\n    expect(binding.type).eql(BindingTypeEnum.ConstantValue);\n    expect(binding.cache instanceof Ninja).eql(true);\n\n    bindingToSyntax.toDynamicValue((context: interfaces.Context) => new Ninja());\n    expect(binding.type).eql(BindingTypeEnum.DynamicValue);\n    expect(typeof binding.dynamicValue).eql(\"function\");\n\n    const dynamicValueFactory: any = binding.dynamicValue;\n    expect(dynamicValueFactory(null) instanceof Ninja).eql(true);\n\n    bindingToSyntax.toConstructor<Ninja>(Ninja);\n    expect(binding.type).eql(BindingTypeEnum.Constructor);\n    expect(binding.implementationType).not.to.eql(null);\n\n    bindingToSyntax.toFactory<Ninja>((context: interfaces.Context) =>\n      () =>\n        new Ninja());\n\n    expect(binding.type).eql(BindingTypeEnum.Factory);\n    expect(binding.factory).not.to.eql(null);\n\n    const f = () => \"test\";\n    bindingToSyntax.toFunction(f);\n    expect(binding.type).eql(BindingTypeEnum.Function);\n    expect(binding.cache === f).eql(true);\n\n    bindingToSyntax.toAutoFactory<Ninja>(ninjaIdentifier);\n\n    expect(binding.type).eql(BindingTypeEnum.Factory);\n    expect(binding.factory).not.to.eql(null);\n\n    bindingToSyntax.toAutoNamedFactory<Ninja>(ninjaIdentifier);\n\n    expect(binding.type).eql(BindingTypeEnum.Factory);\n    expect(binding.factory).not.to.eql(null);\n\n    const mockContext = {\n      container: {\n        getNamed: sinon.stub()\n      }\n    };\n\n    if (binding.factory !== null) {\n      binding.factory((mockContext as unknown as interfaces.Context))(ninjaIdentifier);\n      sinon.assert.calledOnce(mockContext.container.getNamed);\n    }\n\n    bindingToSyntax.toProvider<Ninja>((context: interfaces.Context) =>\n      () =>\n        new Promise<Ninja>((resolve) => {\n          resolve(new Ninja());\n        }));\n\n    expect(binding.type).eql(BindingTypeEnum.Provider);\n    expect(binding.provider).not.to.eql(null);\n\n  });","file":"syntax/binding_to_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should prevent invalid function bindings","suites":["BindingToSyntax"],"updatePoint":{"line":105,"column":46},"line":105,"code":"  it(\"Should prevent invalid function bindings\", () => {\n\n    interface Ninja { }\n\n    @injectable()\n    class Ninja implements Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingToSyntax = new BindingToSyntax<Ninja>(binding);\n\n    const f = function () {\n      bindingToSyntax.toFunction(5);\n    };\n\n    expect(f).to.throw(ERROR_MSGS.INVALID_FUNCTION_BINDING);\n\n  });","file":"syntax/binding_to_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingWhenOnSyntax"],"updatePoint":{"line":21,"column":45},"line":21,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenOnSyntax = new BindingWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingWhenOnSyntax: any = bindingWhenOnSyntax;\n\n    expect(_bindingWhenOnSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should provide access to BindingWhenSyntax methods","suites":["BindingWhenOnSyntax"],"updatePoint":{"line":36,"column":56},"line":36,"code":"  it(\"Should provide access to BindingWhenSyntax methods\", () => {\n\n    interface Army { }\n\n    @injectable()\n    class Army implements Army { }\n\n    interface ZombieArmy { }\n\n    @injectable()\n    class ZombieArmy implements ZombieArmy { }\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenOnSyntax = new BindingWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingWhenOnSyntax: any = bindingWhenOnSyntax;\n\n    // stubs for BindingWhenSyntax methods\n    const whenStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"when\").returns(null);\n    const whenTargetNamedStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"whenTargetNamed\").returns(null);\n    const whenTargetTaggedStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"whenTargetTagged\").returns(null);\n    const whenInjectedIntoStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"whenInjectedInto\").returns(null);\n    const whenParentNamedStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"whenParentNamed\").returns(null);\n    const whenParentTaggedStub = sinon.stub(_bindingWhenOnSyntax._bindingWhenSyntax, \"whenParentTagged\").returns(null);\n\n    const whenAnyAncestorIsStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorIs\").returns(null);\n\n    const whenNoAncestorIsStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorIs\").returns(null);\n\n    const whenAnyAncestorNamedStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorNamed\").returns(null);\n\n    const whenNoAncestorNamedStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorNamed\").returns(null);\n\n    const whenNoAncestorTaggedStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorTagged\").returns(null);\n\n    const whenAnyAncestorTaggedStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorTagged\").returns(null);\n\n    const whenAnyAncestorMatchesStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenAnyAncestorMatches\").returns(null);\n\n    const whenNoAncestorMatchesStub = sinon.stub(\n      _bindingWhenOnSyntax._bindingWhenSyntax, \"whenNoAncestorMatches\").returns(null);\n\n    // invoke BindingWhenOnSyntax methods\n    bindingWhenOnSyntax.when((request: interfaces.Request) => true);\n    bindingWhenOnSyntax.whenTargetNamed(\"test\");\n    bindingWhenOnSyntax.whenTargetTagged(\"test\", true);\n    bindingWhenOnSyntax.whenInjectedInto(\"army\");\n    bindingWhenOnSyntax.whenInjectedInto(Army);\n    bindingWhenOnSyntax.whenParentNamed(\"test\");\n    bindingWhenOnSyntax.whenParentTagged(\"test\", true);\n    bindingWhenOnSyntax.whenAnyAncestorIs(Army);\n    bindingWhenOnSyntax.whenNoAncestorIs(ZombieArmy);\n    bindingWhenOnSyntax.whenAnyAncestorNamed(\"test\");\n    bindingWhenOnSyntax.whenAnyAncestorTagged(\"test\", true);\n    bindingWhenOnSyntax.whenNoAncestorNamed(\"test\");\n    bindingWhenOnSyntax.whenNoAncestorTagged(\"test\", true);\n    bindingWhenOnSyntax.whenAnyAncestorMatches((request: interfaces.Request) => true);\n    bindingWhenOnSyntax.whenNoAncestorMatches((request: interfaces.Request) => true);\n\n    // assert invoked BindingWhenSyntax methods\n    expect(whenStub.callCount).eql(1);\n    expect(whenTargetNamedStub.callCount).eql(1);\n    expect(whenTargetTaggedStub.callCount).eql(1);\n    expect(whenInjectedIntoStub.callCount).eql(2);\n    expect(whenParentNamedStub.callCount).eql(1);\n    expect(whenParentTaggedStub.callCount).eql(1);\n    expect(whenAnyAncestorIsStub.callCount).eql(1);\n    expect(whenNoAncestorIsStub.callCount).eql(1);\n    expect(whenAnyAncestorNamedStub.callCount).eql(1);\n    expect(whenAnyAncestorTaggedStub.callCount).eql(1);\n    expect(whenNoAncestorNamedStub.callCount).eql(1);\n    expect(whenNoAncestorTaggedStub.callCount).eql(1);\n    expect(whenAnyAncestorMatchesStub.callCount).eql(1);\n    expect(whenNoAncestorMatchesStub.callCount).eql(1);\n\n  });","file":"syntax/binding_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should provide access to BindingOnSyntax methods","suites":["BindingWhenOnSyntax"],"updatePoint":{"line":124,"column":54},"line":124,"code":"  it(\"Should provide access to BindingOnSyntax methods\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenOnSyntax = new BindingWhenOnSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingWhenOnSyntax: any = bindingWhenOnSyntax;\n\n    // stubs for BindingWhenSyntax methods\n    const onActivationStub = sinon.stub(_bindingWhenOnSyntax._bindingOnSyntax, \"onActivation\").returns(null);\n\n    // invoke BindingWhenOnSyntax methods\n    bindingWhenOnSyntax.onActivation((context: interfaces.Context, ninja: Ninja) =>\n      // DO NOTHING\n      ninja);\n\n    // assert invoked BindingWhenSyntax methods\n    expect(onActivationStub.callCount).eql(1);\n\n  });","file":"syntax/binding_when_on_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should set its own properties correctly","suites":["BindingWhenSyntax"],"updatePoint":{"line":15,"column":45},"line":15,"code":"  it(\"Should set its own properties correctly\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenSyntax = new BindingWhenSyntax<Ninja>(binding);\n\n    // cast to any to be able to access private props\n    const _bindingWhenSyntax: any = bindingWhenSyntax;\n\n    expect(_bindingWhenSyntax._binding.serviceIdentifier).eql(ninjaIdentifier);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to configure custom constraint of a binding","suites":["BindingWhenSyntax"],"updatePoint":{"line":30,"column":64},"line":30,"code":"  it(\"Should be able to configure custom constraint of a binding\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenSyntax = new BindingWhenSyntax<Ninja>(binding);\n\n    bindingWhenSyntax.when((theRequest: interfaces.Request) =>\n      theRequest.target.name.equals(\"ninja\"));\n\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"ninja\", ninjaIdentifier);\n    const context = new Context(new Container());\n    const request = new Request(ninjaIdentifier, context, null, binding, target);\n    expect(binding.constraint(request)).eql(true);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should have false constraint binding null request whenTargetIsDefault","suites":["BindingWhenSyntax"],"updatePoint":{"line":48,"column":75},"line":48,"code":"  it(\"Should have false constraint binding null request whenTargetIsDefault\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    const shurikenBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const shurikenBindingWhenSyntax = new BindingWhenSyntax<Weapon>(shurikenBinding);\n\n    shurikenBindingWhenSyntax.whenTargetIsDefault();\n    expect(shurikenBinding.constraint(null)).eql(false);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to constraint a binding to a named target","suites":["BindingWhenSyntax"],"updatePoint":{"line":62,"column":62},"line":62,"code":"  it(\"Should be able to constraint a binding to a named target\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenSyntax = new BindingWhenSyntax<Ninja>(binding);\n\n    const named = \"primary\";\n\n    bindingWhenSyntax.whenTargetNamed(named);\n    expect(binding.constraint).not.to.eql(null);\n\n    const context = new Context(new Container());\n\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"ninja\", ninjaIdentifier, named);\n    const request = new Request(ninjaIdentifier, context, null, binding, target);\n    expect(binding.constraint(request)).eql(true);\n\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"ninja\", ninjaIdentifier);\n    const request2 = new Request(ninjaIdentifier, context, null, binding, target2);\n    expect(binding.constraint(request2)).eql(false);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to constraint a binding to a tagged target","suites":["BindingWhenSyntax"],"updatePoint":{"line":87,"column":63},"line":87,"code":"  it(\"Should be able to constraint a binding to a tagged target\", () => {\n\n    interface Ninja { }\n    const ninjaIdentifier = \"Ninja\";\n\n    const binding = new Binding<Ninja>(ninjaIdentifier, BindingScopeEnum.Transient);\n    const bindingWhenSyntax = new BindingWhenSyntax<Ninja>(binding);\n\n    bindingWhenSyntax.whenTargetTagged(\"canSwim\", true);\n    expect(binding.constraint).not.to.eql(null);\n\n    const context = new Context(new Container());\n\n    const target = new Target(TargetTypeEnum.ConstructorArgument, \"ninja\", ninjaIdentifier, new Metadata(\"canSwim\", true));\n    const request = new Request(ninjaIdentifier, context, null, binding, target);\n    expect(binding.constraint(request)).eql(true);\n\n    const target2 = new Target(TargetTypeEnum.ConstructorArgument, \"ninja\", ninjaIdentifier, new Metadata(\"canSwim\", false));\n    const request2 = new Request(ninjaIdentifier, context, null, binding, target2);\n    expect(binding.constraint(request2)).eql(false);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to constraint a binding to its parent","suites":["BindingWhenSyntax"],"updatePoint":{"line":110,"column":58},"line":110,"code":"  it(\"Should be able to constraint a binding to its parent\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    interface JaponeseWarrior {\n      katana: Weapon;\n    }\n\n    interface ChineseWarrior {\n      shuriken: Weapon;\n    }\n\n    class Ninja implements ChineseWarrior {\n      public shuriken: Weapon;\n      public constructor(shuriken: Weapon) {\n        this.shuriken = shuriken;\n      }\n    }\n\n    class Samurai implements JaponeseWarrior {\n      public katana: Weapon;\n      public constructor(katana: Weapon) {\n        this.katana = katana;\n      }\n    }\n\n    const context = new Context(new Container());\n\n    const samuraiBinding = new Binding<Samurai>(\"Samurai\", BindingScopeEnum.Transient);\n    samuraiBinding.implementationType = Samurai;\n    const samuraiTarget = new Target(TargetTypeEnum.Variable, \"\", \"Samurai\");\n    const samuraiRequest = new Request(\"Samurai\", context, null, samuraiBinding, samuraiTarget);\n\n    const ninjaBinding = new Binding<Ninja>(\"Ninja\", BindingScopeEnum.Transient);\n    ninjaBinding.implementationType = Ninja;\n    const ninjaTarget = new Target(TargetTypeEnum.Variable, \"\", \"Ninja\");\n    const ninjaRequest = new Request(\"Ninja\", context, null, ninjaBinding, ninjaTarget);\n\n    const katanaBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const katanaBindingWhenSyntax = new BindingWhenSyntax<Weapon>(katanaBinding);\n    const katanaTarget = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Weapon\");\n    const katanaRequest = new Request(\"Weapon\", context, samuraiRequest, katanaBinding, katanaTarget);\n\n    const shurikenBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const shurikenBindingWhenSyntax = new BindingWhenSyntax<Weapon>(shurikenBinding);\n    const shurikenTarget = new Target(TargetTypeEnum.ConstructorArgument, \"shuriken\", \"Weapon\");\n    const shurikenRequest = new Request(\"Weapon\", context, ninjaRequest, shurikenBinding, shurikenTarget);\n\n    katanaBindingWhenSyntax.whenInjectedInto(Samurai);\n    expect(katanaBinding.constraint(katanaRequest)).eql(true);\n    expect(katanaBinding.constraint(shurikenRequest)).eql(false);\n\n    katanaBindingWhenSyntax.whenInjectedInto(Ninja);\n    expect(katanaBinding.constraint(katanaRequest)).eql(false);\n    expect(katanaBinding.constraint(shurikenRequest)).eql(true);\n\n    shurikenBindingWhenSyntax.whenInjectedInto(Samurai);\n    expect(shurikenBinding.constraint(katanaRequest)).eql(true);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(false);\n\n    shurikenBindingWhenSyntax.whenInjectedInto(Ninja);\n    expect(shurikenBinding.constraint(katanaRequest)).eql(false);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(true);\n\n    katanaBindingWhenSyntax.whenInjectedInto(\"Samurai\");\n    expect(katanaBinding.constraint(katanaRequest)).eql(true);\n    expect(katanaBinding.constraint(shurikenRequest)).eql(false);\n\n    katanaBindingWhenSyntax.whenInjectedInto(\"Ninja\");\n    expect(katanaBinding.constraint(katanaRequest)).eql(false);\n    expect(katanaBinding.constraint(shurikenRequest)).eql(true);\n\n    shurikenBindingWhenSyntax.whenInjectedInto(\"Samurai\");\n    expect(shurikenBinding.constraint(katanaRequest)).eql(true);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(false);\n\n    shurikenBindingWhenSyntax.whenInjectedInto(\"Ninja\");\n    expect(shurikenBinding.constraint(katanaRequest)).eql(false);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(true);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to constraint a binding to a named parent","suites":["BindingWhenSyntax","Weapon"],"updatePoint":{"line":194,"column":62},"line":194,"code":"  it(\"Should be able to constraint a binding to a named parent\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    interface JaponeseWarrior {\n      katana: Weapon;\n    }\n\n    interface ChineseWarrior {\n      shuriken: Weapon;\n    }\n\n    class Ninja implements ChineseWarrior {\n      public shuriken: Weapon;\n      public constructor(shuriken: Weapon) {\n        this.shuriken = shuriken;\n      }\n    }\n\n    class Samurai implements JaponeseWarrior {\n      public katana: Weapon;\n      public constructor(katana: Weapon) {\n        this.katana = katana;\n      }\n    }\n\n    const samuraiBinding = new Binding<Samurai>(\"Samurai\", BindingScopeEnum.Transient);\n    samuraiBinding.implementationType = Samurai;\n\n    const context = new Context(new Container());\n\n    const samuraiTarget = new Target(TargetTypeEnum.ConstructorArgument, \"\", \"Samurai\", \"japonese\");\n    const samuraiRequest = new Request(\"Samurai\", context, null, samuraiBinding, samuraiTarget);\n    const ninjaBinding = new Binding<Ninja>(\"Ninja\", BindingScopeEnum.Transient);\n\n    ninjaBinding.implementationType = Ninja;\n\n    const ninjaTarget = new Target(TargetTypeEnum.ConstructorArgument, \"\", \"Ninja\", \"chinese\");\n    const ninjaRequest = new Request(\"Ninja\", context, null, ninjaBinding, ninjaTarget);\n\n    const katanaBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const katanaBindingWhenSyntax = new BindingWhenSyntax<Weapon>(katanaBinding);\n    const katanaTarget = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Weapon\");\n    const katanaRequest = new Request(\"Weapon\", context, samuraiRequest, katanaBinding, katanaTarget);\n\n    const shurikenBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const shurikenBindingWhenSyntax = new BindingWhenSyntax<Weapon>(shurikenBinding);\n    const shurikenTarget = new Target(TargetTypeEnum.ConstructorArgument, \"shuriken\", \"Weapon\");\n    const shurikenRequest = new Request(\"Weapon\", context, ninjaRequest, shurikenBinding, shurikenTarget);\n\n    katanaBindingWhenSyntax.whenParentNamed(\"chinese\");\n    shurikenBindingWhenSyntax.whenParentNamed(\"chinese\");\n    expect(katanaBinding.constraint(katanaRequest)).eql(false);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(true);\n\n    katanaBindingWhenSyntax.whenParentNamed(\"japonese\");\n    shurikenBindingWhenSyntax.whenParentNamed(\"japonese\");\n    expect(katanaBinding.constraint(katanaRequest)).eql(true);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(false);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to constraint a binding to a tagged parent","suites":["BindingWhenSyntax","Weapon"],"updatePoint":{"line":258,"column":63},"line":258,"code":"  it(\"Should be able to constraint a binding to a tagged parent\", () => {\n\n    interface Weapon {\n      name: string;\n    }\n\n    interface JaponeseWarrior {\n      katana: Weapon;\n    }\n\n    interface ChineseWarrior {\n      shuriken: Weapon;\n    }\n\n    class Ninja implements ChineseWarrior {\n      public shuriken: Weapon;\n      public constructor(shuriken: Weapon) {\n        this.shuriken = shuriken;\n      }\n    }\n\n    class Samurai implements JaponeseWarrior {\n      public katana: Weapon;\n      public constructor(katana: Weapon) {\n        this.katana = katana;\n      }\n    }\n\n    const context = new Context(new Container());\n\n    const samuraiBinding = new Binding<Samurai>(\"Samurai\", BindingScopeEnum.Transient);\n    samuraiBinding.implementationType = Samurai;\n\n    const samuraiTarget = new Target(TargetTypeEnum.ConstructorArgument, \"\", \"Samurai\", new Metadata(\"sneaky\", false));\n    const samuraiRequest = new Request(\"Samurai\", context, null, samuraiBinding, samuraiTarget);\n\n    const ninjaBinding = new Binding<Ninja>(\"Ninja\", BindingScopeEnum.Transient);\n    ninjaBinding.implementationType = Ninja;\n    const ninjaTarget = new Target(TargetTypeEnum.ConstructorArgument, \"\", \"Ninja\", new Metadata(\"sneaky\", true));\n    const ninjaRequest = new Request(\"Ninja\", context, null, ninjaBinding, ninjaTarget);\n\n    const katanaBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const katanaBindingWhenSyntax = new BindingWhenSyntax<Weapon>(katanaBinding);\n    const katanaTarget = new Target(TargetTypeEnum.ConstructorArgument, \"katana\", \"Weapon\");\n    const katanaRequest = new Request(\"Weapon\", context, samuraiRequest, katanaBinding, katanaTarget);\n\n    const shurikenBinding = new Binding<Weapon>(\"Weapon\", BindingScopeEnum.Transient);\n    const shurikenBindingWhenSyntax = new BindingWhenSyntax<Weapon>(shurikenBinding);\n    const shurikenTarget = new Target(TargetTypeEnum.ConstructorArgument, \"shuriken\", \"Weapon\");\n    const shurikenRequest = new Request(\"Weapon\", context, ninjaRequest, shurikenBinding, shurikenTarget);\n\n    katanaBindingWhenSyntax.whenParentTagged(\"sneaky\", true);\n    shurikenBindingWhenSyntax.whenParentTagged(\"sneaky\", true);\n    expect(katanaBinding.constraint(katanaRequest)).eql(false);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(true);\n\n    katanaBindingWhenSyntax.whenParentTagged(\"sneaky\", false);\n    shurikenBindingWhenSyntax.whenParentTagged(\"sneaky\", false);\n    expect(katanaBinding.constraint(katanaRequest)).eql(true);\n    expect(shurikenBinding.constraint(shurikenRequest)).eql(false);\n\n  });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a type constraint to some of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":424,"column":74},"line":424,"code":"    it(\"Should be able to apply a type constraint to some of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenAnyAncestorIs(NinjaMaster);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      shurikenBindingWhenSyntax.whenAnyAncestorIs(NinjaStudent);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenAnyAncestorIs(SamuraiMaster);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenAnyAncestorIs(SamuraiStudent);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a type constraint to none of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":444,"column":74},"line":444,"code":"    it(\"Should be able to apply a type constraint to none of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenNoAncestorIs(NinjaMaster);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      shurikenBindingWhenSyntax.whenNoAncestorIs(NinjaStudent);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenNoAncestorIs(SamuraiMaster);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenNoAncestorIs(SamuraiStudent);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a named constraint to some of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":464,"column":75},"line":464,"code":"    it(\"Should be able to apply a named constraint to some of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenAnyAncestorNamed(\"chinese\");\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      shurikenBindingWhenSyntax.whenAnyAncestorNamed(\"chinese\");\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenAnyAncestorNamed(\"japonese\");\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenAnyAncestorNamed(\"japonese\");\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a named constraint to none of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":484,"column":75},"line":484,"code":"    it(\"Should be able to apply a named constraint to none of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenNoAncestorNamed(\"chinese\");\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      shurikenBindingWhenSyntax.whenNoAncestorNamed(\"chinese\");\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenNoAncestorNamed(\"japonese\");\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenNoAncestorNamed(\"japonese\");\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a tagged constraint to some of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":504,"column":76},"line":504,"code":"    it(\"Should be able to apply a tagged constraint to some of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenAnyAncestorTagged(\"sneaky\", true);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      shurikenBindingWhenSyntax.whenAnyAncestorTagged(\"sneaky\", false);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenAnyAncestorTagged(\"sneaky\", true);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenAnyAncestorTagged(\"sneaky\", false);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a tagged constraint to none of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":524,"column":76},"line":524,"code":"    it(\"Should be able to apply a tagged constraint to none of its ancestors\", () => {\n\n      shurikenBindingWhenSyntax.whenNoAncestorTagged(\"sneaky\", true);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      shurikenBindingWhenSyntax.whenNoAncestorTagged(\"sneaky\", false);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenNoAncestorTagged(\"sneaky\", true);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenNoAncestorTagged(\"sneaky\", false);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a custom constraint to some of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":544,"column":76},"line":544,"code":"    it(\"Should be able to apply a custom constraint to some of its ancestors\", () => {\n\n      const anyAncestorIsNinjaMasterConstraint = typeConstraint(NinjaMaster);\n      const anyAncestorIsNinjaStudentConstraint = typeConstraint(NinjaStudent);\n\n      shurikenBindingWhenSyntax.whenAnyAncestorMatches(anyAncestorIsNinjaMasterConstraint);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      shurikenBindingWhenSyntax.whenAnyAncestorMatches(anyAncestorIsNinjaStudentConstraint);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      const anyAncestorIsSamuraiMasterConstraint = typeConstraint(SamuraiMaster);\n      const anyAncestorIsSamuraiStudentConstraint = typeConstraint(SamuraiStudent);\n\n      katanaBindingWhenSyntax.whenAnyAncestorMatches(anyAncestorIsSamuraiMasterConstraint);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n\n      katanaBindingWhenSyntax.whenAnyAncestorMatches(anyAncestorIsSamuraiStudentConstraint);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to apply a custom constraint to none of its ancestors","suites":["BindingWhenSyntax","BindingWhenSyntax.when*Ancestor*()","Weapon"],"updatePoint":{"line":570,"column":76},"line":570,"code":"    it(\"Should be able to apply a custom constraint to none of its ancestors\", () => {\n\n      const anyAncestorIsNinjaMasterConstraint = typeConstraint(NinjaMaster);\n      const anyAncestorIsNinjaStudentConstraint = typeConstraint(NinjaStudent);\n\n      shurikenBindingWhenSyntax.whenNoAncestorMatches(anyAncestorIsNinjaMasterConstraint);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(true);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(false);\n\n      shurikenBindingWhenSyntax.whenNoAncestorMatches(anyAncestorIsNinjaStudentConstraint);\n      expect(shurikenBinding.constraint(woodShurikenRequest)).eql(false);\n      expect(shurikenBinding.constraint(ironShurikenRequest)).eql(true);\n\n      const anyAncestorIsSamuraiMasterConstraint = typeConstraint(SamuraiMaster);\n      const anyAncestorIsSamuraiStudentConstraint = typeConstraint(SamuraiStudent);\n\n      katanaBindingWhenSyntax.whenNoAncestorMatches(anyAncestorIsSamuraiMasterConstraint);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(true);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(false);\n\n      katanaBindingWhenSyntax.whenNoAncestorMatches(anyAncestorIsSamuraiStudentConstraint);\n      expect(katanaBinding.constraint(woodKatanaRequest)).eql(false);\n      expect(katanaBinding.constraint(ironKatanaRequest)).eql(true);\n    });","file":"syntax/binding_when_syntax.test.ts","skipped":false,"dir":"test"},{"name":"Should be return false when a request object is not provided","suites":["BindingInSyntax"],"updatePoint":{"line":6,"column":66},"line":6,"code":"  it(\"Should be return false when a request object is not provided\", () => {\n\n    const result = typeConstraint(\"TYPE\")(null);\n    expect(result).to.eql(false);\n\n  });","file":"syntax/constraint_helpers.test.ts","skipped":false,"dir":"test"},{"name":"should thrown an exception non factory binding.type","suites":["getFactoryDetails"],"updatePoint":{"line":6,"column":57},"line":6,"code":"  it(\"should thrown an exception non factory binding.type\", () => {\n    const binding = new Binding(\"\", \"Singleton\");\n    binding.type = \"Instance\";\n    expect(() => getFactoryDetails(binding)).to.throw(\"Unexpected factory type Instance\");\n  });","file":"utils/binding_utils.test.ts","skipped":false,"dir":"test"},{"name":"Should be able to generate an id","suites":["ID"],"updatePoint":{"line":6,"column":38},"line":6,"code":"  it(\"Should be able to generate an id\", () => {\r\n    const id1 = id();\r\n    expect(id1).to.be.a(\"number\");\r\n  });\r","file":"utils/id.test.ts","skipped":false,"dir":"test"},{"name":"Should unwrap LazyServiceIdentifier in getConstructorArgsAsTarget","suites":["Reflection Utilities Unit Tests"],"updatePoint":{"line":9,"column":73},"line":9,"code":"    it('Should unwrap LazyServiceIdentifier in getConstructorArgsAsTarget', () => {\n\n        interface Ninja {\n            fight(): string;\n        }\n\n        interface Katana {\n            hit(): string;\n        }\n\n        @injectable()\n        class Katana implements Katana {\n            public hit() {\n                return \"cut!\";\n            }\n        }\n\n        const TYPES = {\n            Katana: Symbol.for(\"Katana\"),\n            Ninja: Symbol.for(\"Ninja\"),\n        };\n\n        @injectable()\n        class Ninja implements Ninja {\n\n        private _katana: Katana;\n\n        public constructor(\n            @inject(new LazyServiceIdentifer(() => TYPES.Katana)) katana: Katana,\n        ) {\n            this._katana = katana;\n        }\n\n        public fight() { return this._katana.hit(); }\n\n        }\n\n        const container = new Container();\n        container.bind<Ninja>(TYPES.Ninja).to(Ninja);\n        container.bind<Katana>(TYPES.Katana).to(Katana);\n\n        const unwrapSpy = sinon.spy(LazyServiceIdentifer.prototype, 'unwrap');\n\n        const dependencies = getDependencies(new MetadataReader(), Ninja);\n\n        expect(dependencies.length).to.be.eql(1);\n        sinon.assert.calledOnce(unwrapSpy);\n\n        sinon.restore();\n    });","file":"utils/reflection.test.ts","skipped":false,"dir":"test"},{"name":"Should return a good function name","suites":["Serialization"],"updatePoint":{"line":8,"column":40},"line":8,"code":"  it(\"Should return a good function name\", () => {\r\n\r\n    function testFunction() {\r\n      return false;\r\n    }\r\n\r\n    expect(getFunctionName(testFunction)).eql(\"testFunction\");\r\n\r\n  });\r","file":"utils/serialization.test.ts","skipped":false,"dir":"test"},{"name":"Should return a good function name by using the regex","suites":["Serialization"],"updatePoint":{"line":18,"column":59},"line":18,"code":"  it(\"Should return a good function name by using the regex\", () => {\r\n\r\n    const testFunction = { name: null };\r\n    testFunction.toString = () =>\r\n      \"function testFunction\";\r\n\r\n    expect(getFunctionName(testFunction)).eql(\"testFunction\");\r\n\r\n  });\r","file":"utils/serialization.test.ts","skipped":false,"dir":"test"},{"name":"Should not fail when target is not named or tagged","suites":["Serialization"],"updatePoint":{"line":28,"column":56},"line":28,"code":"  it(\"Should not fail when target is not named or tagged\", () => {\r\n    const serviceIdentifier = \"SomeTypeId\";\r\n    const target = new Target(TargetTypeEnum.Variable, \"\", serviceIdentifier);\r\n    const list = listMetadataForTarget(serviceIdentifier, target);\r\n    expect(list).to.eql(` ${serviceIdentifier}`);\r\n  });\r","file":"utils/serialization.test.ts","skipped":false,"dir":"test"},{"name":"Should extract symbol description","suites":["Serialization"],"updatePoint":{"line":35,"column":39},"line":35,"code":"  it(\"Should extract symbol description\", () => {\r\n    const symbolWithDescription = Symbol(\"description\");\r\n    expect(getSymbolDescription(symbolWithDescription)).to.equal(\"description\");\r\n\r\n    const symbolWithoutDescription = Symbol();\r\n    expect(getSymbolDescription(symbolWithoutDescription)).to.equal(\"\");\r\n  });\r","file":"utils/serialization.test.ts","skipped":false,"dir":"test"}]}