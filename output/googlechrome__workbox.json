{"repo":"GoogleChrome/workbox","url":"https://github.com/GoogleChrome/workbox","branch":"v6","configs":[{"package":"workbox","lang":"js","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should have top a level module for every export in index.mjs (and vise-versa)","suites":["[all] Window and SW packages"],"updatePoint":{"line":27,"column":83,"index":731},"line":27,"code":"  it(`should have top a level module for every export in index.mjs (and vise-versa)`, async function () {\n    for (const pkg of windowAndSWPackages) {\n      const packagePath = path.join(__dirname, '..', '..', '..', 'packages', pkg.name);\n\n      // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const indexFile = path.join(packagePath, `index.${ext}`);\n      const indexContents = await fs.readFile(indexFile, 'utf-8');\n\n      // Use the acorn parser to generate a list of named exports.\n      const namedExports = [];\n      const indexAST = acorn.parse(indexContents, {\n        ecmaVersion: 6,\n        sourceType: 'module'\n      });\n      for (const node of indexAST.body) {\n        if (node.type === 'ExportDefaultDeclaration') {\n          throw new Error(`'index.${ext}' files cannot contain default exports`);\n        }\n        if (node.type === 'ExportNamedDeclaration') {\n          for (const specifier of node.specifiers) {\n            namedExports.push(specifier.exported.name);\n          }\n        }\n      }\n\n      // Inspect the package directory to get a list of top-level, public\n      // module basenames.\n      const topLevelFiles = glob.sync(`*.${ext}`, {\n        ignore: ['index', 'types', '_types', '_version'].map(file => `${file}.${ext}`),\n        cwd: packagePath\n      }).map(file => path.basename(file, `.${ext}`));\n\n      // Assert there's a 1-to-1 mapping between exports and top-level files.\n      expect(namedExports.sort()).to.deep.equal(topLevelFiles.sort());\n    }\n  });","file":"all/node/test-exports.js","skipped":false,"dir":"test"},{"name":"should have top a level module for every export in _private.mjs (and vise-versa)","suites":["[all] Window and SW packages"],"updatePoint":{"line":65,"column":86,"index":2365},"line":65,"code":"  it(`should have top a level module for every export in _private.mjs (and vise-versa)`, async function () {\n    for (const pkg of windowAndSWPackages) {\n      // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const packagePath = path.join(__dirname, '..', '..', '..', 'packages', pkg.name);\n      const privateFile = path.join(packagePath, `_private.${ext}`);\n\n      // Only some packages have a `_private.mjs` module.\n      if (!fs.existsSync(privateFile)) {\n        continue;\n      }\n      const privateContents = await fs.readFile(privateFile, 'utf-8');\n\n      // Use the acorn parser to generate a list of named exports.\n      const namedExports = [];\n      const indexAST = acorn.parse(privateContents, {\n        ecmaVersion: 6,\n        sourceType: 'module'\n      });\n      for (const node of indexAST.body) {\n        if (node.type === 'ExportDefaultDeclaration') {\n          throw new Error(`'_private.${ext}' files cannot contain default exports`);\n        }\n        if (node.type === 'ExportNamedDeclaration') {\n          if (node.specifiers.length === 0) {\n            throw new Error(`'_private.${ext}' files may only contain a single, named-export block`);\n          }\n          for (const specifier of node.specifiers) {\n            namedExports.push(specifier.exported.name);\n          }\n        }\n      }\n\n      // Inspect the package directory to get a list of top-level, public\n      // module basenames.\n      const privateDirectoryPath = path.join(packagePath, '_private');\n      const topLevelFiles = glob.sync(`*.${ext}`, {\n        cwd: privateDirectoryPath\n      }).map(file => path.basename(file, `.${ext}`));\n\n      // Assert there's a 1-to-1 mapping between exports and top-level files.\n      expect(namedExports.sort()).to.deep.equal(topLevelFiles.sort());\n    }\n  });","file":"all/node/test-exports.js","skipped":false,"dir":"test"},{"name":"should run JSDocs and have no unexpected results","suites":["[all] JSDocs"],"updatePoint":{"line":19,"column":54,"index":474},"line":19,"code":"  it('should run JSDocs and have no unexpected results', async function () {\n    // Windows is super unhappy with the JSDocs build pipeline.\n    // With gulp.cmd in spawn, the query string used by the baseline template\n    // causes issues.\n    if (process.platform === 'win32') {\n      this.skip();\n      return;\n    }\n    this.timeout(60 * 1000);\n    const projectRoot = upath.join(__dirname, '..', '..', '..');\n    const docsPath = upath.join(projectRoot, 'docs');\n    await docs_build();\n    const docs = glob.sync('*.html', {\n      cwd: docsPath\n    });\n\n    // global.html is only added when the docs have stray global values.\n    expect(docs.includes('global.html'), `'global.html' should not be present in ${docsPath}`).to.be.false;\n\n    // On some occasions, module.exports can leak into JSDocs, and breaks\n    // into the final template.\n    const indexAllHTML = await fse.readFile(upath.join(docsPath, 'index-all.html'), 'utf8');\n    expect(indexAllHTML.includes('<a href=\"module.html#.exports\">module.exports</a>'), `'module.exports' was found in index-all.html`).to.be.false;\n\n    // We document this private method because we expect developers to\n    // override it in their extending classes.\n    const privateMethodAllowlist = ['_handle'];\n\n    // string.matchAll() isn't supported before node v12...\n    const regexp = /<a href=\"([^\"]+)\">/g;\n    let match;\n    while ((match = regexp.exec(indexAllHTML)) !== null) {\n      const href = match[1];\n      if (href.includes('#_') && !privateMethodAllowlist.some(allow => href.endsWith(allow))) {\n        throw new Error(`Private method found in JSDocs: ${href}`);\n      }\n    }\n  });","file":"all/node/test-jsdocs.js","skipped":false,"dir":"test"},{"name":"should expose correct main, browser and module fields","suites":["[all] Test package.json"],"updatePoint":{"line":23,"column":59,"index":727},"line":23,"code":"  it(`should expose correct main, browser and module fields`, function () {\n    const packageFiles = glob.sync('packages/**/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      const pkg = require(packagePath);\n      switch (pkg.workbox.packageType) {\n        case 'sw':\n          {\n            const propertiesToCheck = ['main', 'module'];\n            propertiesToCheck.forEach(propertyName => {\n              if (!pkg[propertyName]) {\n                throw new Error(`The package.json at '${upath.relative(process.cwd(), packagePath)}' isn't exposing a '${propertyName}' property`);\n              }\n              const fullPath = upath.join(upath.dirname(packagePath), pkg[propertyName]);\n              if (!fs.existsSync(fullPath)) {\n                throw new Error(`${upath.relative(process.cwd(), packagePath)} has an invalid '${propertyName}' property: '${pkg[propertyName]}'`);\n              }\n            });\n            break;\n          }\n        case 'window':\n          {\n            break;\n          }\n        case 'node':\n          {\n            break;\n          }\n        case 'node_ts':\n          {\n            break;\n          }\n        default:\n          throw new Error(`Unknown package.json workbox.packageType: '${pkg.workbox.packageType}' in ${upath.relative(process.cwd(), packagePath)}`);\n      }\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should import _version.mjs in each .mjs file","suites":["[all] Test package.json"],"updatePoint":{"line":63,"column":50,"index":2193},"line":63,"code":"  it(`should import _version.mjs in each .mjs file`, function () {\n    // Find directories with package.json file\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-sw modules\n      const pkg = require(packagePath);\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      }\n\n      // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n\n      // Glob for all js and mjs files in the package\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const packageFiles = glob.sync(`packages/${packageName}/**/*.${ext}`, {\n        ignore: ['packages/*/node_modules/**/*', `packages/*/_version.${ext}`, `packages/*/${constants.PACKAGE_BUILD_DIRNAME}/**/*`],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      });\n      const importRegex = new RegExp(`import\\\\s+'[./]+_version\\\\.${ext}';`);\n\n      // Find the version in each file.\n      packageFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = importRegex.exec(fileContents);\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should contain the file version","suites":["[all] Test package.json"],"updatePoint":{"line":100,"column":37,"index":3725},"line":100,"code":"  it(`should contain the file version`, function () {\n    const versionRegex = /['|\"]workbox:((?:[^:'\"]*|:)*)['|\"]/;\n\n    // Find directories with package.json file\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-browser modules\n      const pkg = require(packagePath);\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      }\n\n      // Glob for all js and mjs files in the package\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const packageFiles = glob.sync(`packages/${packageName}/${constants.PACKAGE_BUILD_DIRNAME}/**/*.{js,mjs}`, {\n        ignore: ['packages/*/node_modules/**/*'],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      });\n\n      // Find the version in each file.\n      packageFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = versionRegex.exec(fileContents);\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n        const metadata = results[1].split(':');\n        try {\n          expect(metadata[0]).to.equal(pkg.name.replace('workbox-', ''));\n          expect(metadata[1]).to.equal(pkg.version);\n        } catch (err) {\n          throw new Error(`Invalid file version ${filePath}: ${metadata}`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should have correct details in _version.mjs","suites":["[all] Test package.json"],"updatePoint":{"line":141,"column":49,"index":5333},"line":141,"code":"  it(`should have correct details in _version.mjs`, function () {\n    const versionRegex = /['|\"]workbox:((?:[^:'\"]*|:)*)['|\"]/;\n\n    // Find directories with package.json file\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-browser modules\n      const pkg = require(packagePath);\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      }\n\n      // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const versionFiles = glob.sync(`packages/${packageName}/_version.${ext}`, {\n        ignore: ['packages/*/node_modules/**/*'],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      });\n\n      // Find the version in each file.\n      versionFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = versionRegex.exec(fileContents);\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n        const metadata = results[1].split(':');\n        try {\n          expect(metadata[0]).to.equal(pkg.name.replace('workbox-', ''));\n          expect(metadata[1]).to.equal(pkg.version);\n        } catch (err) {\n          throw new Error(`Invalid file version ${filePath}: ${metadata}`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should only use a namespace that matches its package name","suites":["[all] Test package.json"],"updatePoint":{"line":184,"column":63,"index":7048},"line":184,"code":"  it(`should only use a namespace that matches its package name`, function () {\n    const pkgs = getPackages({\n      type: 'sw'\n    });\n    for (const pkg of pkgs) {\n      // These rules don't apply to workbox-sw\n      if (pkg.name === 'workbox-sw') continue;\n\n      // Remove the `workbox-` prefix.\n      const pkgNameSuffix = pkg.name.replace(/^workbox-/, '');\n\n      // Remvoe the `workbox.` prefix.\n      const pkgNamespaceSuffix = pkg.workbox.browserNamespace.replace(/^workbox\\./, '');\n      if (camelCase(pkgNameSuffix) !== pkgNamespaceSuffix) {\n        throw new Error(ol`Invalid browser namespace:\n            ${pkg.workbox.browserNamespace}. The browser namespace must include\n            the package name camelCased (${camelCase(pkgNameSuffix)}).`);\n      }\n    }\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should not have files with \"console\" or \"%cworwbox\"","suites":["[all] prod builds"],"updatePoint":{"line":23,"column":57,"index":764},"line":23,"code":"  it(`should not have files with \"console\" or \"%cworwbox\"`, function () {\n    const invalidFiles = [];\n    buildFiles.forEach(filePath => {\n      const fileContents = fse.readFileSync(filePath).toString();\n      if (fileContents.indexOf(`console`) > -1 &&\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      !filePath.includes('workbox-precaching') || fileContents.indexOf(`%cworkbox`) > -1) {\n        invalidFiles.push(filePath);\n      }\n    });\n    if (invalidFiles.length > 0) {\n      logHelper.error(`Files with 'console' in them\\n`, JSON.stringify(invalidFiles, null, 2));\n      throw new Error(oneLine`\n        Found ${invalidFiles.length} files with \"console\" or \"%cworkbox\" in\n        the final build. Please ensure all 'logger' calls are wrapped in a\n        \"if (process.env.NODE_ENV !== 'production') {...}\" conditional.\n      `);\n    }\n  });","file":"all/node/test-prod-builds.js","skipped":false,"dir":"test"},{"name":"should not have files with hasOwnProperty","suites":["[all] prod builds"],"updatePoint":{"line":42,"column":47,"index":1627},"line":42,"code":"  it(`should not have files with hasOwnProperty`, function () {\n    const invalidFiles = [];\n    buildFiles.forEach(filePath => {\n      const fileContents = fse.readFileSync(filePath).toString();\n      if (fileContents.indexOf(`.hasOwnProperty('default')`) !== -1) {\n        invalidFiles.push(filePath);\n      }\n    });\n    if (invalidFiles.length > 0) {\n      logHelper.error(`Files with 'hasOwnProperty('default')' in them\\n`, JSON.stringify(invalidFiles, null, 2));\n      throw new Error(oneLine`\n        Found ${invalidFiles.length} files with \"hasOwnProperty('default')\"\n        in the final build. Please convert these to named exports to be friendly\n        to Rollup.\n      `);\n    }\n  });","file":"all/node/test-prod-builds.js","skipped":false,"dir":"test"},{"name":"should install  using yarn","suites":["[all] Yarn Installation"],"updatePoint":{"line":19,"column":53,"index":632},"line":19,"code":"    it(`should install ${packageToInstall} using yarn`, async function () {\n      this.timeout(5 * 60 * 1000);\n      try {\n        const packagePath = upath.resolve('packages', packageToInstall);\n        await execa('yarn', ['add', packagePath], {\n          cwd: temporaryDirectory\n        });\n      } catch (error) {\n        if (error.code === 'ENOENT') {\n          // Skip the test if yarn isn't installed.\n          // (It will always be installed on GitHub Actions.)\n          this.skip();\n        } else {\n          throw error;\n        }\n      }\n    });","file":"all/node/test-yarn-installation.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-background-sync]"],"updatePoint":{"line":22,"column":30,"index":636},"line":22,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-background-sync/sw/');\n  });","file":"workbox-background-sync/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker","suites":["[workbox-background-sync] Load and use Background Sync"],"updatePoint":{"line":37,"column":44,"index":1227},"line":37,"code":"  it(`should load a page with service worker`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    const url = `/test/workbox-background-sync/static/basic-example/example.txt`;\n    const err = await webdriver.executeAsyncScript((url, cb) => {\n      return fetch(url).then(() => cb()).catch(err => cb(err.message));\n    }, url);\n    expect(err).to.not.exist;\n    await waitUntil(() => {\n      const count = requestCounter.getURLCount(url);\n      return count > 0;\n    }, 20, 500);\n  });","file":"workbox-background-sync/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-broadcast-update]"],"updatePoint":{"line":26,"column":30,"index":800},"line":26,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-broadcast-update/sw/');\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message when there's a cache update to a regular request","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":40,"column":81,"index":1485},"line":40,"code":"  it(`should broadcast a message when there's a cache update to a regular request`, async function () {\n    // Fetch `apiURL`, which should put it in the cache (but not trigger an update)\n    const err1 = await webdriver.executeAsyncScript((apiURL, cb) => {\n      fetch(apiURL).then(() => cb()).catch(err => cb(err.message));\n    }, apiURL);\n    expect(err1).to.not.exist;\n\n    // Fetch `apiURL` again, which should trigger an update message.\n    const err2 = await webdriver.executeAsyncScript((apiURL, cb) => {\n      fetch(apiURL).then(() => cb()).catch(err => cb(err.message));\n    }, apiURL);\n    expect(err2).to.not.exist;\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(messages.length).to.equal(1);\n    expect(messages[0]).to.deep.equal({\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: apiURL\n      }\n    });\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message when there's a cache update to a navigation request","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":70,"column":84,"index":2615},"line":70,"code":"  it(`should broadcast a message when there's a cache update to a navigation request`, async function () {\n    templateData.assign({\n      title: 'Broadcast Cache Update Test',\n      body: 'Second test, initial body.',\n      script: `\n        window.__messages = [];\n        navigator.serviceWorker.addEventListener('message', (event) => {\n          window.__messages.push(event.data);\n        });\n      `\n    });\n    const dynamicPageURL = testingURL + 'integration.html.njk?second';\n\n    // Navigate to a dynamic page whose content can be updated from with this\n    // test, and wait until the cache is populated.\n    await webdriver.get(dynamicPageURL);\n    await webdriver.wait(async () => {\n      return webdriver.executeAsyncScript(async (url, cb) => {\n        cb(await caches.match(url));\n      }, dynamicPageURL);\n    });\n\n    // Update the template data with new content,\n    // then refresh and wait until the update message is received.\n    templateData.assign({\n      body: 'Second test, with and updated body.'\n    });\n    await webdriver.get(webdriver.getCurrentUrl());\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(messages.length).to.equal(1);\n    expect(messages[0]).to.deep.equal({\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: dynamicPageURL\n      }\n    });\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message to all open window clients by default","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":116,"column":70,"index":4192},"line":116,"code":"  it(`should broadcast a message to all open window clients by default`, async function () {\n    const iframeManager = new IframeManager(webdriver);\n    templateData.assign({\n      title: 'Broadcast Cache Update Test',\n      body: 'Third test, initial body.',\n      script: `\n        window.__messages = [];\n        navigator.serviceWorker.addEventListener('message', (event) => {\n          window.__messages.push(event.data);\n        });\n      `\n    });\n    const dynamicPageURL = testingURL + 'integration.html.njk?third';\n\n    // Navigate to a dynamic page whose content can be updated from with this\n    // test, and wait until the cache is populated.\n    await webdriver.get(dynamicPageURL);\n    await webdriver.wait(async () => {\n      return webdriver.executeAsyncScript(async (url, cb) => {\n        cb(await caches.match(url));\n      }, dynamicPageURL);\n    });\n\n    // Update the template data and open an iframe to trigger the cache update.\n    templateData.assign({\n      body: 'Third test, with an updated body.'\n    });\n    await iframeManager.createIframeClient(dynamicPageURL);\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const tab1Messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(tab1Messages).to.eql([{\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: dynamicPageURL\n      }\n    }]);\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should only broadcast a message to the client that made the request when notifyAllClients is false","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":161,"column":104,"index":5785},"line":161,"code":"  it(`should only broadcast a message to the client that made the request when notifyAllClients is false`, async function () {\n    const url = `${apiURL}?notifyAllClientsTest`;\n    const iframeManager = new IframeManager(webdriver);\n    await webdriver.get(testingURL);\n    await webdriver.executeAsyncScript((url, cb) => {\n      fetch(url).then(() => cb()).catch(err => cb(err.message));\n    }, url);\n    const iframeClient = await iframeManager.createIframeClient(testingURL);\n    await iframeClient.executeAsyncScript(`fetch(${JSON.stringify(url)})`);\n    await iframeClient.wait('window.__messages.length > 0');\n    const populatedMessages = await iframeClient.executeAsyncScript('window.__messages');\n    expect(populatedMessages).to.eql([{\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: url\n      }\n    }]);\n    const unpopulatedMessages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(unpopulatedMessages).to.be.empty;\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-build] Test Dependencies"],"updatePoint":{"line":12,"column":39,"index":353},"line":12,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-build'), {\n        ignoreDirs: ['test', 'build', 'demo'],\n        ignoreMatches: ['@babel/preset-env', '@babel/runtime', 'type-fest', 'workbox-background-sync', 'workbox-broadcast-update', 'workbox-cacheable-response', 'workbox-core', 'workbox-expiration', 'workbox-google-analytics', 'workbox-navigation-preload', 'workbox-precaching', 'workbox-range-requests', 'workbox-recipes', 'workbox-routing', 'workbox-strategies', 'workbox-streams', 'workbox-sw', 'workbox-window']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n        resolve();\n      });\n    });\n  });","file":"workbox-build/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-build] Test Dependencies"],"updatePoint":{"line":31,"column":36,"index":1635},"line":31,"code":"  it(`should have no devDependencies`, function () {\n    // This test exists because there have been a number of situations where\n    // dependencies have been used from the top level project and NOT from\n    // this module itself. So dependencies are checked above and devDependencies\n    // can be put in top level.\n    const pkg = require('../../../packages/workbox-build/package.json');\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('No devDependencies in this module.');\n    }\n  });","file":"workbox-build/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is missing","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] required parameters"],"updatePoint":{"line":44,"column":67,"index":2103},"line":44,"code":"      it(`should fail validation when '${requiredParam}' is missing`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        delete options[requiredParam];\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, requiredParam);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is present","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":53,"column":70,"index":2546},"line":53,"code":"      it(`should fail validation when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is an unexpected value","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":62,"column":71,"index":2997},"line":62,"code":"      it(`should fail validation when '${param}' is an unexpected value`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[param] = () => {};\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when there are no manifest entries or runtimeCaching","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":68,"column":74,"index":3302},"line":68,"code":"    it(`should reject when there are no manifest entries or runtimeCaching`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS);\n      // This temporary directory will be empty.\n      options.globDirectory = tempy.directory();\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(errors['no-manifest-entries-or-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":76,"column":72,"index":3759},"line":76,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          __WB_DISABLE_DEV_LOGS: undefined,\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should include the versioning strings in the generated bundle","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":120,"column":69,"index":5194},"line":120,"code":"    it(`should include the versioning strings in the generated bundle`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        inlineWorkboxRuntime: true\n      });\n      const {\n        count,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      const contents = await fse.readFile(swDest, 'utf8');\n      // This isn't the exact string, but it's close enough.\n      expect(contents).to.include(`workbox:core:`);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should disable logging when disableDevLogs is set to true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":137,"column":65,"index":5825},"line":137,"code":"    it(`should disable logging when disableDevLogs is set to true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        disableDevLogs: true,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          __WB_DISABLE_DEV_LOGS: true,\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additional importScripts","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":182,"column":103,"index":7319},"line":182,"code":"    it(`should use defaults when all the required parameters are present, with additional importScripts`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const importScripts = ['manifest.js'];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        importScripts,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [...importScripts]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additional configuration","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":227,"column":103,"index":8832},"line":227,"code":"    it(`should use defaults when all the required parameters are present, with additional configuration`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const directoryIndex = 'test.html';\n      const ignoreURLParametersMatching = [/test1/, /test2/];\n      const cacheId = 'test';\n      const additionalOptions = {\n        cacheId,\n        directoryIndex,\n        ignoreURLParametersMatching,\n        clientsClaim: true,\n        skipWaiting: true\n      };\n      const options = Object.assign({}, BASE_OPTIONS, additionalOptions, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          clientsClaim: [[]],\n          skipWaiting: [[]],\n          setCacheNameDetails: [[{\n            prefix: cacheId\n          }]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {\n            directoryIndex,\n            ignoreURLParametersMatching\n          }]]\n        },\n        addEventListenerValidation: addEventListenerStub => {\n          // When skipWaiting is true, the 'message' addEventListener shouldn't be called.\n          expect(addEventListenerStub.called).to.be.false;\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additionalManifestEntries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":292,"column":104,"index":11025},"line":292,"code":"    it(`should use defaults when all the required parameters are present, with additionalManifestEntries`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        additionalManifestEntries: ['/one', {\n          url: '/two',\n          revision: null\n        }, {\n          url: '/three',\n          revision: '333'\n        },\n        // See https://github.com/GoogleChrome/workbox/issues/2558\n        {\n          url: '/four',\n          revision: '123',\n          integrity: '456'\n        }],\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      // The string additionalManifestEntries entry should lead to one warning.\n      expect(warnings).to.have.length(1);\n      expect(count).to.eql(10);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            revision: null,\n            url: '/one'\n          }, {\n            revision: null,\n            url: '/two'\n          }, {\n            revision: '333',\n            url: '/three'\n          }, {\n            url: '/four',\n            revision: '123',\n            integrity: '456'\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add a 'message' event listener when 'skipWaiting: false'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":362,"column":71,"index":13144},"line":362,"code":"    it(`should add a 'message' event listener when 'skipWaiting: false'`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const additionalOptions = {\n        skipWaiting: false\n      };\n      const options = Object.assign({}, BASE_OPTIONS, additionalOptions, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        },\n        addEventListenerValidation: addEventListenerStub => {\n          expect(addEventListenerStub.calledOnce).to.be.true;\n          expect(addEventListenerStub.firstCall.args[0]).to.eql('message');\n          // This isn't the *cleanest* possible way of testing the message event\n          // handler, but given the constraints of this node-based environment,\n          // it seems the most effective way to ensure the right code gets run.\n          expect(addEventListenerStub.firstCall.args[1].toString()).to.eql(`event => {\\n    if (event.data && event.data.type === 'SKIP_WAITING') {\\n      self.skipWaiting();\\n    }\\n  }`);\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'navigateFallback'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":416,"column":97,"index":15294},"line":416,"code":"    it(`should use defaults when all the required parameters are present, with 'navigateFallback'`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const navigateFallback = 'test.html';\n      const navigateFallbackDenylist = [/test1/, /test2/];\n      const navigateFallbackAllowlist = [/test3/, /test4/];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        navigateFallback,\n        navigateFallbackDenylist,\n        navigateFallbackAllowlist,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          createHandlerBoundToURL: [[navigateFallback]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[{\n            name: 'NavigationRoute'\n          }]],\n          NavigationRoute: [['/urlWithCacheKey', {\n            denylist: navigateFallbackDenylist,\n            allowlist: navigateFallbackAllowlist\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with symlinks","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":473,"column":87,"index":17261},"line":473,"code":"    it(`should use defaults when all the required parameters are present, with symlinks`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(GLOB_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'link/index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'globFollow' and  symlinks","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":519,"column":105,"index":18864},"line":519,"code":"    it(`should use defaults when all the required parameters are present, with 'globFollow' and  symlinks`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(GLOB_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        globFollow: false,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(4);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2707, 2629]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'link/index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":560,"column":115,"index":20298},"line":560,"code":"    it(`should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        offlineGoogleAnalytics: true\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          initialize: [[{}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to a config","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":605,"column":119,"index":21807},"line":605,"code":"    it(`should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to a config`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        offlineGoogleAnalytics: {\n          parameterOverrides: {\n            cd1: 'offline'\n          }\n        }\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          initialize: [[{\n            parameterOverrides: {\n              cd1: 'offline'\n            }\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":658,"column":66,"index":23429},"line":658,"code":"    it(`should support using a swDest that includes a subdirectory`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sub', 'directory', 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should inline the Workbox runtime when 'inlineWorkboxRuntime' is true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":676,"column":77,"index":24092},"line":676,"code":"    it(`should inline the Workbox runtime when 'inlineWorkboxRuntime' is true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        inlineWorkboxRuntime: true\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      // We can't validate the generated sw.js file, unfortunately.\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'urlPattern' is missing from 'runtimeCaching'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":704,"column":72,"index":25119},"line":704,"code":"    it(`should reject when 'urlPattern' is missing from 'runtimeCaching'`, async function () {\n      const handler = STRING_HANDLER;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          handler\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'urlPattern');\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'handler' is missing from 'runtimeCaching'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":713,"column":69,"index":25484},"line":713,"code":"    it(`should reject when 'handler' is missing from 'runtimeCaching'`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'handler');\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'handler' is not a valid strategy name","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":722,"column":65,"index":25852},"line":722,"code":"    it(`should reject when 'handler' is not a valid strategy name`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern,\n          handler: 'invalid'\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'handler');\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not require using precaching","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":734,"column":43,"index":26292},"line":734,"code":"    it(`should not require using precaching`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: STRING_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      delete options.globDirectory;\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(0);\n      expect(size).to.eql(0);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          registerRoute: [[STRING_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support a single string 'urlPattern' and a string 'handler'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":766,"column":74,"index":27236},"line":766,"code":"    it(`should support a single string 'urlPattern' and a string 'handler'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: STRING_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[STRING_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support a single function 'urlPattern' and a string 'handler'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":817,"column":76,"index":28812},"line":817,"code":"    it(`should support a single function 'urlPattern' and a string 'handler'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: FUNCTION_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          // See https://github.com/chaijs/chai/issues/697\n          registerRoute: [['params => true', {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support setting individual 'options' each, for multiple 'runtimeCaching' entries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":869,"column":95,"index":30466},"line":869,"code":"    it(`should support setting individual 'options' each, for multiple 'runtimeCaching' entries`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const firstRuntimeCachingOptions = {\n        cacheName: 'first-cache-name',\n        expiration: {\n          maxEntries: 1,\n          maxAgeSeconds: 1,\n          purgeOnQuotaError: false\n        }\n      };\n      const secondRuntimeCachingOptions = {\n        cacheName: 'second-cache-name',\n        cacheableResponse: {\n          headers: {\n            'X-Test': 'test'\n          },\n          statuses: [0, 200]\n        },\n        precacheFallback: {\n          fallbackURL: '/test'\n        }\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: STRING_HANDLER,\n        options: firstRuntimeCachingOptions\n      }, {\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: STRING_HANDLER,\n        options: secondRuntimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[{\n            cacheName: firstRuntimeCachingOptions.cacheName,\n            plugins: [{}]\n          }], [{\n            cacheName: secondRuntimeCachingOptions.cacheName,\n            plugins: [{}, {}]\n          }]],\n          ExpirationPlugin: [[firstRuntimeCachingOptions.expiration]],\n          CacheableResponsePlugin: [[secondRuntimeCachingOptions.cacheableResponse]],\n          PrecacheFallbackPlugin: [[secondRuntimeCachingOptions.precacheFallback]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[REGEXP_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD], [REGEXP_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject with a ValidationError when 'networkTimeoutSeconds' is used and handler is not 'NetworkFirst'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":956,"column":115,"index":33296},"line":956,"code":"    it(`should reject with a ValidationError when 'networkTimeoutSeconds' is used and handler is not 'NetworkFirst'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCachingOptions = {\n        networkTimeoutSeconds: 1\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: 'NetworkOnly',\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(errors['invalid-network-timeout-seconds']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support passing in a function when allowed","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":974,"column":57,"index":33904},"line":974,"code":"    it(`should support passing in a function when allowed`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const handler = () => {};\n      const urlPattern = () => {};\n      const runtimeCachingOptions = {\n        backgroundSync: {\n          name: 'test',\n          options: {\n            onSync: () => {}\n          }\n        },\n        plugins: [{\n          cachedResponseWillBeUsed: () => {}\n        }]\n      };\n      const runtimeCaching = [{\n        handler,\n        urlPattern,\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[runtimeCachingOptions]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[urlPattern.toString(), handler.toString(), DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support 'networkTimeoutSeconds' when handler is 'NetworkFirst'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1037,"column":77,"index":35787},"line":1037,"code":"    it(`should support 'networkTimeoutSeconds' when handler is 'NetworkFirst'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const networkTimeoutSeconds = 1;\n      const handler = 'NetworkFirst';\n      const runtimeCachingOptions = {\n        networkTimeoutSeconds,\n        plugins: []\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler,\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[runtimeCachingOptions]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[REGEXP_URL_PATTERN, {\n            name: handler\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'options.expiration' is used without 'options.cacheName'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1095,"column":83,"index":37576},"line":1095,"code":"    it(`should reject when 'options.expiration' is used without 'options.cacheName'`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern,\n          handler: 'NetworkFirst',\n          options: {\n            expiration: {\n              maxEntries: 5\n            }\n          }\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['cache-name-required']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should ignore swDest and workbox-*.js when generating manifest entries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1110,"column":78,"index":38114},"line":1110,"code":"    it(`should ignore swDest and workbox-*.js when generating manifest entries`, async function () {\n      const tempDirectory = tempy.directory();\n      await fse.copy(BASE_OPTIONS.globDirectory, tempDirectory);\n      const swDest = upath.join(tempDirectory, 'service-worker.js');\n      await fse.createFile(swDest);\n      // See https://rollupjs.org/guide/en/#outputchunkfilenames\n      await fse.createFile(upath.join(tempDirectory, 'workbox-abcd1234.js'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory: tempDirectory,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1158,"column":88,"index":39831},"line":1158,"code":"    it(`should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        navigationPreload: true\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['nav-preload-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1164,"column":88,"index":40178},"line":1164,"code":"    it(`should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: undefined,\n        navigationPreload: true\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['nav-preload-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should generate when 'navigationPreload' is true and 'runtimeCaching' is valid","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1171,"column":86,"index":40558},"line":1171,"code":"    it(`should generate when 'navigationPreload' is true and 'runtimeCaching' is valid`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const urlPattern = /test/;\n      const handler = 'CacheFirst';\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        runtimeCaching: [{\n          urlPattern,\n          handler\n        }],\n        navigationPreload: true\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          enable: [[]],\n          registerRoute: [[urlPattern, {\n            name: handler\n          }, 'GET']]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":35,"column":70,"index":1596},"line":35,"code":"      it(`should fail validation when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is an unexpected value","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":44,"column":71,"index":2048},"line":44,"code":"      it(`should fail validation when '${param}' is an unexpected value`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[param] = () => {};\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":52,"column":72,"index":2460},"line":52,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'globPatterns' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":84,"column":92,"index":3463},"line":84,"code":"    it(`should use defaults when all the required parameters, and 'globPatterns' are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globPatterns: ['**/*.html', '**/*.js']\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(4);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2707, 2629]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'globIgnores' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":112,"column":91,"index":4351},"line":112,"code":"    it(`should use defaults when all the required parameters, and 'globIgnores' are present`, async function () {\n      const options = Object.assign({\n        globIgnores: ['**/*.html', '**/*.js']\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([69, 75]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, 'globIgnores', and 'globPatterns' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":134,"column":107,"index":5119},"line":134,"code":"    it(`should use defaults when all the required parameters, 'globIgnores', and 'globPatterns' are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globPatterns: ['**/*.css', '**/*.js'],\n        globIgnores: ['node_modules/**/*', '**/*2*']\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([216, 219]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'maximumFileSizeToCacheInBytes' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":157,"column":109,"index":5941},"line":157,"code":"    it(`should use defaults when all the required parameters, and 'maximumFileSizeToCacheInBytes' are present`, async function () {\n      const options = Object.assign({\n        maximumFileSizeToCacheInBytes: 50\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.have.lengthOf(2);\n      expect(manifestEntries).to.matchPattern([{\n        revision: /^[0-9a-f]{32}$/,\n        url: 'page-1.html'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'page-2.html'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'styles/stylesheet-1.css'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'styles/stylesheet-2.css'\n      }]);\n      expect(count).to.eql(4);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([101, 109]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'templatedURLs' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":185,"column":93,"index":6849},"line":185,"code":"    it(`should use defaults when all the required parameters, and 'templatedURLs' are present`, async function () {\n      const url1 = 'url1';\n      const url2 = 'url2';\n      const options = Object.assign({\n        templatedURLs: {\n          [url1]: ['**/*.html'],\n          [url2]: 'string dependency'\n        }\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'url1',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'url2',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(8);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([5162, 5324]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'manifestTransforms' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":230,"column":98,"index":8159},"line":230,"code":"    it(`should use defaults when all the required parameters, and 'manifestTransforms' are present`, async function () {\n      // This filters out all entries unless the url property includes the string '1'.\n      const transform1 = entries => {\n        const manifest = entries.filter(entry => {\n          return entry.url.includes('1');\n        });\n        return {\n          manifest\n        };\n      };\n      // This modifies all entries to prefix the url property with the string '/prefix/'.\n      const transform2 = entries => {\n        const manifest = entries.filter(entry => {\n          entry.url = `/prefix/${entry.url}`;\n          return entry;\n        });\n        return {\n          manifest\n        };\n      };\n      const options = Object.assign({\n        manifestTransforms: [transform1, transform2]\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: '/prefix/page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: '/prefix/styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([50, 54]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'globFollow' and symlinks","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":271,"column":104,"index":9538},"line":271,"code":"    it(`should use defaults when all the required parameters are present, with 'globFollow' and symlinks`, async function () {\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(SRC_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        globFollow: false\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'link/index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(4);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2707, 2629]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when  is used","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] removed options"],"updatePoint":{"line":314,"column":55,"index":10951},"line":314,"code":"      it(`should fail validation when ${option} is used`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS, {\n          [option]: value\n        });\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, option);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is missing","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] required parameters"],"updatePoint":{"line":43,"column":58,"index":1943},"line":43,"code":"      it(`should reject when '${requiredParam}' is missing`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        delete options[requiredParam];\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, requiredParam);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is present","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":52,"column":61,"index":2381},"line":52,"code":"      it(`should reject when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is null","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":61,"column":47,"index":2812},"line":61,"code":"      it(`should reject when '${param}' is null`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[param] = null;\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when 'swSrc' is invalid","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":69,"column":63,"index":3171},"line":69,"code":"    it(`should throw the expected error when 'swSrc' is invalid`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: 'DOES_NOT_EXIST'\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['invalid-sw-src']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there is no match for 'injectionPoint'","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":75,"column":83,"index":3484},"line":75,"code":"    it(`should throw the expected error when there is no match for 'injectionPoint'`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: upath.join(SW_SRC_DIR, 'bad-no-injection.js')\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['injection-point-not-found']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there is no match for 'injectionPoint' and 'swSrc' and 'swDest' are the same","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":81,"column":121,"index":3875},"line":81,"code":"    it(`should throw the expected error when there is no match for 'injectionPoint' and 'swSrc' and 'swDest' are the same`, async function () {\n      const swFile = upath.join(SW_SRC_DIR, 'bad-no-injection.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: swFile,\n        swDest: swFile\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['same-src-and-dest']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there are multiple matches for 'injectionPoint'","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":89,"column":92,"index":4282},"line":89,"code":"    it(`should throw the expected error when there are multiple matches for 'injectionPoint'`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: upath.join(SW_SRC_DIR, 'bad-multiple-injection.js')\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['multiple-injection-points']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":97,"column":72,"index":4710},"line":97,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use absolute paths in the filePaths return value","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":141,"column":63,"index":6053},"line":141,"code":"    it(`should use absolute paths in the filePaths return value`, async function () {\n      // Deliberately use a relative path for swDest.\n      const swDest = upath.relative('.', tempy.file({\n        extension: 'js'\n      }));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        filePaths,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      // Use upath.resolve() to confirm that we get back an absolute path.\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, when workboxSW.precache() is called twice","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":157,"column":115,"index":6691},"line":157,"code":"    it(`should use defaults when all the required parameters are present, when workboxSW.precache() is called twice`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc: upath.join(SW_SRC_DIR, 'multiple-calls.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [['./sample-import.js']],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]], [['/extra-assets/example.1234.css', '/extra-assets/example-2.1234.js']]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, when a custom 'injectionPoint' is used","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":203,"column":112,"index":8267},"line":203,"code":"    it(`should use defaults when all the required parameters are present, when a custom 'injectionPoint' is used`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        injectionPoint: 'self.__custom_injection_point',\n        swSrc: upath.join(SW_SRC_DIR, 'custom-injection-point.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support using the default 'injectionPoint' when precacheAndRoute() is called with options","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":249,"column":104,"index":9776},"line":249,"code":"    it(`should support using the default 'injectionPoint' when precacheAndRoute() is called with options`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc: upath.join(SW_SRC_DIR, 'precache-and-route-options.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {\n            cleanURLs: true\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should ignore swSrc and swDest when generating manifest entries","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":296,"column":71,"index":11242},"line":296,"code":"    it(`should ignore swSrc and swDest when generating manifest entries`, async function () {\n      const tempDirectory = tempy.directory();\n      await fse.copy(BASE_OPTIONS.globDirectory, tempDirectory);\n      const swSrc = upath.join(tempDirectory, 'sw-src-service-worker.js');\n      await fse.copyFile(upath.join(SW_SRC_DIR, 'basic.js'), swSrc);\n      const swDest = upath.join(tempDirectory, 'sw-dest-service-worker.js');\n      await fse.createFile(swDest);\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc,\n        swDest,\n        globDirectory: tempDirectory\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":345,"column":69,"index":12942},"line":345,"code":"    it(`should update the sourcemap to account for manifest injection`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-sourcemap.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const sourcemapDest = upath.join(outputDir, 'basic-with-sourcemap.js.map');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest), sourcemapDest]);\n      const actualSourcemap = await fse.readJSON(sourcemapDest);\n      const expectedSourcemap = await fse.readJSON(upath.join(SW_SRC_DIR, '..', 'expected-source-map.js.map'));\n      expect(actualSourcemap).to.eql(expectedSourcemap);\n\n      // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not update the sourcemap if it uses a data: URL","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":372,"column":62,"index":14073},"line":372,"code":"    it(`should not update the sourcemap if it uses a data: URL`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-sourcemap-data-url.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n\n      // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should perform injection, but report a warning if the sourcemap file can't be found","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":393,"column":91,"index":14826},"line":393,"code":"    it(`should perform injection, but report a warning if the sourcemap file can't be found`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-invalid-sourcemap.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings.length).to.eql(1);\n      expect(warnings[0]).to.include(errors['cant-find-sourcemap']);\n      expect(count).to.eql(6);\n      // Line ending differences lead to different sizes on Windows.\n      expect(size).to.be.oneOf([2782, 2698]);\n\n      // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when  is used","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] removed options"],"updatePoint":{"line":427,"column":55,"index":16033},"line":427,"code":"      it(`should fail validation when ${option} is used`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS, {\n          [option]: value\n        });\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, option);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not make any changes when additionalManifestEntries is empty","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":23,"column":73,"index":704},"line":23,"code":"  it(`should not make any changes when additionalManifestEntries is empty`, function () {\n    const transform = additionalManifestEntriesTransform([]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }],\n      warnings: []\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should add the additionalManifestEntries to the end of the existing manifest","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":33,"column":82,"index":1019},"line":33,"code":"  it(`should add the additionalManifestEntries to the end of the existing manifest`, function () {\n    const transform = additionalManifestEntriesTransform([{\n      url: '/second',\n      revision: null\n    }, {\n      url: '/third',\n      revision: null\n    }]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }, {\n        url: '/second',\n        size: 0,\n        revision: null\n      }, {\n        url: '/third',\n        size: 0,\n        revision: null\n      }],\n      warnings: []\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should return a warning, along with the modified manifest, when additionalManifestEntries contains a string or an entry without revision","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":57,"column":142,"index":1644},"line":57,"code":"  it(`should return a warning, along with the modified manifest, when additionalManifestEntries contains a string or an entry without revision`, function () {\n    const transform = additionalManifestEntriesTransform(['/second', {\n      url: '/third'\n    }]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }, {\n        url: '/second',\n        size: 0,\n        revision: null\n      }, {\n        url: '/third',\n        size: 0\n      }],\n      warnings: [errors['string-entry-warning'] + '\\n  - /second\\n  - /third\\n']\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should pass 'babelPresetEnvTargets' to @babel/preset-env","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":66,"column":62,"index":1846},"line":66,"code":"  it(`should pass 'babelPresetEnvTargets' to @babel/preset-env`, async function () {\n    const babelPresetEnvTargets = ['target1', 'target2'];\n    await bundle({\n      babelPresetEnvTargets\n    });\n\n    // This is ugly, but necessary due to the way babel() is configured.\n    const babelParams = stubs['@rollup/plugin-babel'].babel.args[0][0];\n    expect(babelParams.presets[0][1].targets.browsers).to.eql(babelPresetEnvTargets);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should use loadz0r and configure manualChunks when 'inlineWorkboxRuntime' is false","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":76,"column":88,"index":2308},"line":76,"code":"  it(`should use loadz0r and configure manualChunks when 'inlineWorkboxRuntime' is false`, async function () {\n    await bundle({\n      inlineWorkboxRuntime: false\n    });\n    expect(stubs.rollup.rollup.args[0][0].manualChunks).to.be.a('function');\n    expect(stubs['@surma/rollup-plugin-off-main-thread'].calledOnce).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should not use loadz0r or configure manualChunks when 'inlineWorkboxRuntime' is true","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":83,"column":90,"index":2646},"line":83,"code":"  it(`should not use loadz0r or configure manualChunks when 'inlineWorkboxRuntime' is true`, async function () {\n    await bundle({\n      inlineWorkboxRuntime: true\n    });\n    expect(stubs.rollup.rollup.args[0][0].manualChunks).not.to.exist;\n    expect(stubs['@surma/rollup-plugin-off-main-thread'].notCalled).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should replace NODE_ENV with the 'mode' value","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":90,"column":51,"index":2936},"line":90,"code":"  it(`should replace NODE_ENV with the 'mode' value`, async function () {\n    const mode = 'mode-value';\n    await bundle({\n      mode\n    });\n    expect(stubs['@rollup/plugin-replace'].args).to.eql([[{\n      'preventAssignment': true,\n      'process.env.NODE_ENV': `\"${mode}\"`\n    }]]);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should use terser when 'mode' is 'production'","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":100,"column":51,"index":3230},"line":100,"code":"  it(`should use terser when 'mode' is 'production'`, async function () {\n    const mode = 'production';\n    await bundle({\n      mode\n    });\n    expect(stubs['rollup-plugin-terser'].terser.calledOnce).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should not use terser when 'mode' is not 'production'","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":107,"column":59,"index":3459},"line":107,"code":"  it(`should not use terser when 'mode' is not 'production'`, async function () {\n    const mode = 'something-else';\n    await bundle({\n      mode\n    });\n    expect(stubs['rollup-plugin-terser'].terser.notCalled).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should pass the 'sourcemap' parameter value through to Rollup","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":114,"column":67,"index":3699},"line":114,"code":"  it(`should pass the 'sourcemap' parameter value through to Rollup`, async function () {\n    const sourcemap = true;\n    await bundle({\n      sourcemap\n    });\n    expect(stubs.rollupStub.generate.args[0][0].sourcemap).to.eql(sourcemap);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should process the generated Rollup bundle into the expected return value","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":121,"column":79,"index":3956},"line":121,"code":"  it(`should process the generated Rollup bundle into the expected return value`, async function () {\n    const files = await bundle({});\n    expect(files).to.eql([{\n      contents: 'asset-source',\n      name: 'asset-filename'\n    }, {\n      contents: 'chunk1-code',\n      name: 'chunk1-filename'\n    }, {\n      contents: 'sourcemap-contents',\n      name: 'chunk2-filename.map'\n    }, {\n      contents: 'chunk2-code//# sourceMappingURL=chunk2-filename.map\\n',\n      name: 'chunk2-filename'\n    }]);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"getModuleURL() should throw when moduleName is undefined","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":16,"column":62,"index":589},"line":16,"code":"  it(`getModuleURL() should throw when moduleName is undefined`, function () {\n    expect(() => cdnUtils.getModuleURL()).to.throw(errors['no-module-name']);\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL('workbox-sw', 'dev') should throw","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":19,"column":52,"index":742},"line":19,"code":"  it(`getModuleURL('workbox-sw', 'dev') should throw`, function () {\n    expect(() => cdnUtils.getModuleURL('workbox-sw', 'dev')).to.throw('workbox-sw');\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL(moduleName) should return the expected URL","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":22,"column":61,"index":911},"line":22,"code":"  it(`getModuleURL(moduleName) should return the expected URL`, function () {\n    const moduleName = 'workbox-sw';\n    const url = cdnUtils.getModuleURL(moduleName);\n    expect(url.startsWith(CDN_ORIGIN)).to.be.true;\n    expect(url.includes(moduleName)).to.be.true;\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL('workbox-routing', buildType) should return the expected URL","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":28,"column":79,"index":1201},"line":28,"code":"  it(`getModuleURL('workbox-routing', buildType) should return the expected URL`, function () {\n    const moduleName = 'workbox-routing';\n    const buildType = 'prod';\n    const url = cdnUtils.getModuleURL(moduleName, buildType);\n    expect(url.startsWith(CDN_ORIGIN)).to.be.true;\n    expect(url.includes(moduleName)).to.be.true;\n    expect(url.includes(buildType)).to.be.true;\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"should reject with an error when the copy fails","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":20,"column":53,"index":758},"line":20,"code":"  it(`should reject with an error when the copy fails`, async function () {\n    const {\n      copyWorkboxLibraries\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        ensureDir: sinon.stub().resolves(),\n        copy: sinon.stub().rejects('INJECTED_ERROR')\n      }\n    });\n    try {\n      await copyWorkboxLibraries(ABSOLUTE_DEST_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-copy-workbox-libraries']);\n    }\n  });","file":"workbox-build/node/lib/copy-workbox-libraries.js","skipped":false,"dir":"test"},{"name":"should resolve with the new directory name, using a destDir of ","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":37,"column":81,"index":1383},"line":37,"code":"    it(`should resolve with the new directory name, using a destDir of ${destDir}`, async function () {\n      const copyStub = sinon.stub().resolves();\n      const ensureDirStub = sinon.stub().resolves();\n      const {\n        copyWorkboxLibraries\n      } = proxyquire(MODULE_PATH, {\n        'fs-extra': {\n          copy: copyStub,\n          ensureDir: ensureDirStub\n        }\n      });\n      const workboxDirectory = await copyWorkboxLibraries(destDir);\n      // The workboxDirectory value is a relative path from destDir to the\n      // new directory. We check if ensureDir was called with the combined upath.\n      const expectedPath = upath.join(destDir, workboxDirectory);\n      expect(expectedPath).to.eql(ensureDirStub.args[0][0]);\n\n      // The total number of package build directories that were copied:\n      expect(copyStub.callCount).to.eql(15);\n    });","file":"workbox-build/node/lib/copy-workbox-libraries.js","skipped":false,"dir":"test"},{"name":"should perform the expected escaping:  => ","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":16,"column":71,"index":698},"line":16,"code":"    it(`should perform the expected escaping: ${original} => ${escaped}`, async function () {\n      expect(escapeRegExp(original)).to.eql(escaped);\n    });","file":"workbox-build/node/lib/escape-regexp.js","skipped":false,"dir":"test"},{"name":"should return the expected composite details for a single file","suites":["[workbox-build] lib/get-composite-details.js"],"updatePoint":{"line":25,"column":68,"index":660},"line":25,"code":"  it(`should return the expected composite details for a single file`, function () {\n    const details = getCompositeDetails(URL, [ENTRY1]);\n    expect(details).to.eql({\n      file: URL,\n      hash: '00c6ee2e21a7548de6260cf72c4f4b5b',\n      size: ENTRY1.size\n    });\n  });","file":"workbox-build/node/lib/get-composite-details.js","skipped":false,"dir":"test"},{"name":"should return the expected composite details for multiple files","suites":["[workbox-build] lib/get-composite-details.js"],"updatePoint":{"line":33,"column":69,"index":934},"line":33,"code":"  it(`should return the expected composite details for multiple files`, function () {\n    const details = getCompositeDetails(URL, [ENTRY1, ENTRY2]);\n    expect(details).to.eql({\n      file: URL,\n      hash: '3dcd1f089c4a94cbbedb7a00d7ec9829',\n      size: ENTRY1.size + ENTRY2.size\n    });\n  });","file":"workbox-build/node/lib/get-composite-details.js","skipped":false,"dir":"test"},{"name":"should throw when there's a glob.sync() error","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":24,"column":51,"index":791},"line":24,"code":"  it(`should throw when there's a glob.sync() error`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      glob: {\n        sync: () => {\n          throw new Error();\n        }\n      }\n    });\n    try {\n      getFileDetails({\n        globDirectory: GLOB_DIRECTORY,\n        globPattern: GLOB_PATTERN\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-glob-files']);\n    }\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should return a warning when the pattern doesn't match anything","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":44,"column":69,"index":1307},"line":44,"code":"  it(`should return a warning when the pattern doesn't match anything`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      glob: {\n        sync: () => []\n      }\n    });\n    const {\n      globbedFileDetails,\n      warning\n    } = getFileDetails({\n      globDirectory: GLOB_DIRECTORY,\n      globPattern: GLOB_PATTERN\n    });\n    expect(globbedFileDetails).to.be.empty;\n    expect(warning).to.have.string(errors['useless-glob-pattern']);\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should return array of file details, without null values","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":62,"column":62,"index":1778},"line":62,"code":"  it(`should return array of file details, without null values`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      'glob': {\n        sync: () => {\n          return [FILE1, FILE2, DIRECTORY];\n        }\n      },\n      './get-file-size': {\n        getFileSize: value => {\n          if (upath.normalize(value) === upath.normalize(DIRECTORY)) {\n            return null;\n          }\n          return SIZE;\n        }\n      },\n      './get-file-hash': {\n        getFileHash: value => {\n          if (upath.normalize(value) === upath.normalize(DIRECTORY)) {\n            throw new Error(`getFileHash(${DIRECTORY}) shouldn't have been called.`);\n          }\n          return HASH;\n        }\n      }\n    });\n    const {\n      globbedFileDetails,\n      warning\n    } = getFileDetails({\n      globDirectory: GLOB_DIRECTORY,\n      globPattern: GLOB_PATTERN\n    });\n    expect(warning).to.eql('');\n    expect(globbedFileDetails).to.deep.equal([{\n      file: FILE1,\n      hash: HASH,\n      size: SIZE\n    }, {\n      file: FILE2,\n      hash: HASH,\n      size: SIZE\n    }]);\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should throw when there's a fs.readFileSync() error","suites":["[workbox-build] lib/get-file-hash.js"],"updatePoint":{"line":17,"column":57,"index":581},"line":17,"code":"  it(`should throw when there's a fs.readFileSync() error`, function () {\n    const {\n      getFileHash\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        readFileSync: () => {\n          throw new Error();\n        }\n      }\n    });\n    try {\n      getFileHash(FILE);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-get-file-hash']);\n    }\n  });","file":"workbox-build/node/lib/get-file-hash.js","skipped":false,"dir":"test"},{"name":"should return the hash corresponding to a file's contents","suites":["[workbox-build] lib/get-file-hash.js"],"updatePoint":{"line":34,"column":63,"index":1024},"line":34,"code":"  it(`should return the hash corresponding to a file's contents`, function () {\n    const buffer = Buffer.alloc(10);\n    const hashForBuffer = 'a63c90cc3684ad8b0a2176a6a8fe9005';\n    const {\n      getFileHash\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        readFileSync: file => {\n          if (file !== FILE) {\n            throw new Error(`Unexpected file name: ${file}`);\n          }\n          return buffer;\n        }\n      }\n    });\n    const hash = getFileHash(FILE);\n    expect(hash).to.eql(hashForBuffer);\n  });","file":"workbox-build/node/lib/get-file-hash.js","skipped":false,"dir":"test"},{"name":"should return empty info when neither globDirectory nor templatedURLs are provided","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":23,"column":88,"index":752},"line":23,"code":"  it(`should return empty info when neither globDirectory nor templatedURLs are provided`, async function () {\n    const {\n      getFileManifestEntries\n    } = require(MODULE_PATH);\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({});\n    expect(count).to.eql(0);\n    expect(size).to.eql(0);\n    expect(manifestEntries).to.have.lengthOf(0);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should not return the same file twice","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":36,"column":43,"index":1102},"line":36,"code":"  it(`should not return the same file twice`, async function () {\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE, FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS\n    });\n    expect(count).to.eql(1);\n    expect(size).to.eql(FILE.size);\n    expect(manifestEntries).to.deep.equal([{\n      url: FILE.file,\n      revision: FILE.hash\n    }]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when a templatedURL matches a globbed file","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":64,"column":61,"index":1808},"line":64,"code":"  it(`should throw when a templatedURL matches a globbed file`, async function () {\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n    try {\n      await getFileManifestEntries({\n        globDirectory: GLOB_DIRECTORY,\n        globPatterns: GLOB_PATTERNS,\n        templatedURLs: {\n          [FILE.file]: ''\n        }\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['templated-url-matches-glob']);\n    }\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should treat an exception thrown by getFileDetails() as a warning message","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":90,"column":79,"index":2532},"line":90,"code":"  it(`should treat an exception thrown by getFileDetails() as a warning message`, async function () {\n    const warningMessage = 'test warning';\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          throw new Error(warningMessage);\n        }\n      }\n    });\n    const {\n      warnings\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS,\n      templatedURLs: {\n        [FILE.file]: ''\n      }\n    });\n    expect(warnings).to.eql([warningMessage]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when a templatedURL contains a pattern that doesn't match anything","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":112,"column":85,"index":3143},"line":112,"code":"  it(`should throw when a templatedURL contains a pattern that doesn't match anything`, async function () {\n    const {\n      getFileManifestEntries\n    } = require(MODULE_PATH);\n    try {\n      await getFileManifestEntries({\n        globDirectory: GLOB_DIRECTORY,\n        templatedURLs: {\n          [FILE.file]: GLOB_PATTERNS\n        }\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['bad-template-urls-asset']);\n    }\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should return results that take both glob patterns and templatedURLs into account","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":128,"column":87,"index":3651},"line":128,"code":"  it(`should return results that take both glob patterns and templatedURLs into account`, async function () {\n    const url1 = '/path/to/url1';\n    const url2 = '/path/to/url2';\n    const stringValue = 'string';\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS,\n      templatedURLs: {\n        [url1]: GLOB_PATTERNS,\n        [url2]: stringValue\n      }\n    });\n    expect(count).to.eql(3);\n    expect(size).to.eql(FILE.size + FILE.size + stringValue.length);\n    expect(manifestEntries).to.deep.equal([{\n      url: FILE.file,\n      revision: FILE.hash\n    }, {\n      url: url1,\n      // This is the hash of FILE.hash.\n      revision: '00c6ee2e21a7548de6260cf72c4f4b5b'\n    }, {\n      url: url2,\n      // THis is the hash of stringValue.\n      revision: 'b45cffe084dd3d20d928bee85e7b0f21'\n    }]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when fs.statSync() fails","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":17,"column":43,"index":570},"line":17,"code":"  it(`should throw when fs.statSync() fails`, function () {\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          throw new Error();\n        }\n      }\n    });\n    try {\n      getFileSize(FILE);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-get-file-size']);\n    }\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return null for non-files","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":34,"column":38,"index":984},"line":34,"code":"  it(`should return null for non-files`, function () {\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          return {\n            isFile: () => false\n          };\n        }\n      }\n    });\n    const size = getFileSize(FILE);\n    expect(size).not.to.exist;\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return the expected file size","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":49,"column":42,"index":1316},"line":49,"code":"  it(`should return the expected file size`, function () {\n    const expectedSize = 1234;\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          return {\n            isFile: () => true,\n            size: expectedSize\n          };\n        }\n      }\n    });\n    const size = getFileSize(FILE);\n    expect(size).to.eql(expectedSize);\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return the expected details","suites":["[workbox-build] lib/get-string-details.js"],"updatePoint":{"line":14,"column":40,"index":438},"line":14,"code":"  it(`should return the expected details`, function () {\n    const inputToExpectedDetails = new Map([[['/url-one', 'first-one'], {\n      file: '/url-one',\n      hash: 'e725107146e32e2e7e75feaa303b7fbc',\n      size: 9\n    }], [['/url-two', 'another-string'], {\n      file: '/url-two',\n      hash: '7fb80c5fad3565fd6ce3d9f61a53c659',\n      size: 14\n    }]]);\n    for (const [[url, string], expectedDetails] of inputToExpectedDetails) {\n      const details = getStringDetails(url, string);\n      expect(details).to.eql(expectedDetails);\n    }\n  });","file":"workbox-build/node/lib/get-string-details.js","skipped":false,"dir":"test"},{"name":"should return the expected hashes","suites":["[workbox-build] lib/get-string-hash.js"],"updatePoint":{"line":14,"column":39,"index":428},"line":14,"code":"  it(`should return the expected hashes`, function () {\n    const stringsToHashes = new Map([['abc', '900150983cd24fb0d6963f7d28e17f72'], ['xyz', 'd16fb36f0911f878998c136191af705e']]);\n    for (const [string, hash] of stringsToHashes) {\n      expect(getStringHash(string)).to.eql(hash);\n    }\n  });","file":"workbox-build/node/lib/get-string-hash.js","skipped":false,"dir":"test"},{"name":"should handle bad URLs in the manifest","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":24,"column":44,"index":692},"line":24,"code":"  it(`should handle bad URLs in the manifest`, function () {\n    const badInputs = [null, undefined, true, false, {}, []];\n    const modifications = {\n      '/example-1': '/example-1-altered',\n      '/example-2/multi-section/1234': '/example-2-altered/5678'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    for (const badInput of badInputs) {\n      expect(() => transform([{\n        url: badInput\n      }])).to.throw(errors['manifest-entry-bad-url']);\n    }\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should handle bad modifyURLPrefixTransform input","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":37,"column":54,"index":1191},"line":37,"code":"  it(`should handle bad modifyURLPrefixTransform input`, function () {\n    const badInputs = [null, undefined, true, false, [], '', {\n      Hi: []\n    }];\n    for (const badInput of badInputs) {\n      expect(() => modifyURLPrefixTransform(badInput)).to.throw(errors['modify-url-prefix-bad-prefixes']);\n    }\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should strip prefixes","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":45,"column":27,"index":1478},"line":45,"code":"  it(`should strip prefixes`, function () {\n    const modifications = {\n      '/first-match': ''\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/12345/hello'\n      }, {\n        url: '/second-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should prepend prefixes","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":58,"column":29,"index":1815},"line":58,"code":"  it(`should prepend prefixes`, function () {\n    const modifications = {\n      '': '/public'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/public/first-match/12345/hello'\n      }, {\n        url: '/public/second-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should only replace the initial match","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":71,"column":43,"index":2187},"line":71,"code":"  it(`should only replace the initial match`, function () {\n    const modifications = {\n      '/first-match': '/second-match',\n      '/second-match': '/third-match'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/second-match/12345/hello'\n      }, {\n        url: '/third-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should not replace when the match is not at the start of the URL","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":85,"column":70,"index":2629},"line":85,"code":"  it(`should not replace when the match is not at the start of the URL`, function () {\n    const modifications = {\n      '/hello': '/altered'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: getManifest()\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should return [] when nothing is used","suites":["[workbox-build] lib/module-registry.js","getImportStatements()"],"updatePoint":{"line":23,"column":45,"index":823},"line":23,"code":"    it(`should return [] when nothing is used`, function () {\n      expect(moduleRegistry.getImportStatements()).to.be.empty;\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"return the expected output given multiple calls to use()","suites":["[workbox-build] lib/module-registry.js","getImportStatements()"],"updatePoint":{"line":26,"column":64,"index":976},"line":26,"code":"    it(`return the expected output given multiple calls to use()`, function () {\n      const module1Name = moduleRegistry.use('workbox-core', 'index');\n      // Multiple use()s should result in only one entry.\n      moduleRegistry.use('workbox-core', 'index');\n      const module2Name = moduleRegistry.use('workbox-routing', 'index');\n      const importStatements = moduleRegistry.getImportStatements();\n      expect(importStatements).to.have.members([`import {index as workbox_core_index} from '${basePath}/packages/workbox-core/index.mjs';`, `import {index as workbox_routing_index} from '${basePath}/packages/workbox-routing/index.mjs';`]);\n      expect(importStatements[0]).to.contain(module1Name);\n      expect(importStatements[1]).to.contain(module2Name);\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should return the expected name","suites":["[workbox-build] lib/module-registry.js","getLocalName()"],"updatePoint":{"line":38,"column":39,"index":1770},"line":38,"code":"    it(`should return the expected name`, function () {\n      expect(moduleRegistry.getLocalName('a-b-c', 'd')).to.eql('a_b_c_d');\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should return the expected name when called via use()","suites":["[workbox-build] lib/module-registry.js","getLocalName()"],"updatePoint":{"line":41,"column":61,"index":1931},"line":41,"code":"    it(`should return the expected name when called via use()`, function () {\n      expect(moduleRegistry.use('a-b-c', 'd')).to.eql('a_b_c_d');\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should handle bad URLs in the manifest","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":26,"column":44,"index":790},"line":26,"code":"  it(`should handle bad URLs in the manifest`, function () {\n    const badInputs = [null, undefined, true, false, {}, []];\n    const transform = noRevisionForURLsMatchingTransform(/ignored/);\n    for (const badInput of badInputs) {\n      expect(() => transform([{\n        url: badInput\n      }])).to.throw(errors['manifest-entry-bad-url']);\n    }\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should handle bad dontCacheBustURLsMatching input","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":35,"column":55,"index":1154},"line":35,"code":"  it(`should handle bad dontCacheBustURLsMatching input`, function () {\n    const badInputs = [null, undefined, true, false, [], '', {\n      Hi: []\n    }];\n    for (const badInput of badInputs) {\n      expect(() => noRevisionForURLsMatchingTransform(badInput)).to.throw(errors['invalid-dont-cache-bust']);\n    }\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should set revision info to null in a single matching entry","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":43,"column":65,"index":1482},"line":43,"code":"  it(`should set revision info to null in a single matching entry`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/first-match/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: [{\n        url: '/first-match/12345/hello',\n        revision: null\n      }, {\n        url: '/second-match/12345/hello',\n        revision: '1234abcd'\n      }, {\n        url: '/third-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should set revision info to null in multiple matching entries","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":57,"column":67,"index":1919},"line":57,"code":"  it(`should set revision info to null in multiple matching entries`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/12345/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: [{\n        url: '/first-match/12345/hello',\n        revision: null\n      }, {\n        url: '/second-match/12345/hello',\n        revision: null\n      }, {\n        url: '/third-match/12345/hello',\n        revision: null\n      }]\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should do nothing when there's a match for an entry without a revision","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":72,"column":76,"index":2377},"line":72,"code":"  it(`should do nothing when there's a match for an entry without a revision`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/third-match/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: MANIFEST\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should throw an error if templating fails","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":17,"column":47,"index":590},"line":17,"code":"  it(`should throw an error if templating fails`, function () {\n    const manifestEntries = ['ignored'];\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': () => {\n        throw new Error();\n      }\n    });\n    try {\n      populateSWTemplate({\n        manifestEntries\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['populating-sw-tmpl-failed']);\n    }\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should throw an error if both manifestEntries and runtimeCaching are empty","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":35,"column":80,"index":1107},"line":35,"code":"  it(`should throw an error if both manifestEntries and runtimeCaching are empty`, function () {\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': () => {}\n    });\n    try {\n      populateSWTemplate({\n        manifestEntries: [],\n        runtimeCaching: []\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['no-manifest-entries-or-runtime-caching']);\n    }\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should pass the expected options to the template using mostly defaults","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":51,"column":76,"index":1590},"line":51,"code":"  it(`should pass the expected options to the template using mostly defaults`, function () {\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const swTemplate = 'template';\n    const precacheOptionsString = '{}';\n    const manifestEntries = ['ignored'];\n    const innerStub = sinon.stub().returns('');\n    const outerStub = sinon.stub().returns(innerStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': outerStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      manifestEntries\n    });\n    expect(outerStub.alwaysCalledWith(swTemplate)).to.be.true;\n\n    // Doing a strict comparison with functions isn't easy.\n    expect(innerStub.args[0][0].use).to.be.a('function');\n    delete innerStub.args[0][0].use;\n    expect(innerStub.args[0]).to.eql([{\n      manifestEntries,\n      cacheId: undefined,\n      cleanupOutdatedCaches: undefined,\n      clientsClaim: undefined,\n      disableDevLogs: undefined,\n      importScripts: undefined,\n      navigateFallback: undefined,\n      navigateFallbackDenylist: undefined,\n      navigateFallbackAllowlist: undefined,\n      navigationPreload: undefined,\n      offlineAnalyticsConfigString: undefined,\n      precacheOptionsString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      skipWaiting: undefined\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should pass the expected options to the template","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":94,"column":54,"index":3066},"line":94,"code":"  it(`should pass the expected options to the template`, function () {\n    const cacheId = 'test-cache-id';\n    const cleanupOutdatedCaches = true;\n    const clientsClaim = true;\n    const directoryIndex = 'index.html';\n    const disableDevLogs = true;\n    const handleFetch = true;\n    const ignoreURLParametersMatching = [/a/, /b/];\n    const importScripts = ['test.js'];\n    const manifestEntries = [{\n      url: '/path/to/index.html',\n      revision: '1234'\n    }];\n    const navigateFallback = '/shell.html';\n    const navigateFallbackDenylist = [/another-test/];\n    const navigateFallbackAllowlist = [/test/];\n    const navigationPreload = true;\n    const offlineGoogleAnalytics = true;\n    const offlineAnalyticsConfigString = '{}';\n    const runtimeCaching = [];\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const skipWaiting = true;\n    const swTemplate = 'template';\n    const precacheOptionsString = '{\\n  \"directoryIndex\": \"index.html\",\\n  \"ignoreURLParametersMatching\": [/a/, /b/]\\n}';\n\n    // There are two stages in templating: creating the active template function\n    // from an initial string, and passing variables to that template function\n    // to get back a final, populated template string.\n    // We need to stub out both of those steps to test the full flow.\n    const templatePopulationStub = sinon.stub().returns('');\n    const templateCreationStub = sinon.stub().returns(templatePopulationStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': templateCreationStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      cacheId,\n      cleanupOutdatedCaches,\n      clientsClaim,\n      directoryIndex,\n      disableDevLogs,\n      handleFetch,\n      ignoreURLParametersMatching,\n      importScripts,\n      manifestEntries,\n      navigateFallback,\n      navigateFallbackDenylist,\n      navigateFallbackAllowlist,\n      navigationPreload,\n      offlineGoogleAnalytics,\n      runtimeCaching,\n      skipWaiting\n    });\n    expect(templateCreationStub.alwaysCalledWith(swTemplate)).to.be.true;\n\n    // Doing a strict comparison with functions isn't easy.\n    expect(templatePopulationStub.args[0][0].use).to.be.a('function');\n    delete templatePopulationStub.args[0][0].use;\n    expect(templatePopulationStub.args[0]).to.eql([{\n      cacheId,\n      cleanupOutdatedCaches,\n      clientsClaim,\n      disableDevLogs,\n      importScripts,\n      manifestEntries,\n      navigateFallback,\n      navigateFallbackDenylist,\n      navigateFallbackAllowlist,\n      navigationPreload,\n      offlineAnalyticsConfigString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      precacheOptionsString,\n      skipWaiting\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should handle a complex offlineGoogleAnalytics value when populating the template","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":176,"column":87,"index":5978},"line":176,"code":"  it(`should handle a complex offlineGoogleAnalytics value when populating the template`, function () {\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const swTemplate = 'template';\n    const precacheOptionsString = '{}';\n    const offlineGoogleAnalytics = {\n      parameterOverrides: {\n        cd1: 'offline'\n      },\n      hitFilter: params => {\n        // Comments are stripped.\n        params.set('cm1', params.get('qt'));\n      }\n    };\n    const offlineAnalyticsConfigString = `{\\n\\tparameterOverrides: {\\n\\t\\tcd1: 'offline'\\n\\t},\\n\\thitFilter: (params) => {\\n        \\n        params.set('cm1', params.get('qt'));\\n      }\\n}`;\n    const manifestEntries = ['ignored'];\n    const innerStub = sinon.stub().returns('');\n    const outerStub = sinon.stub().returns(innerStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': outerStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      manifestEntries,\n      offlineGoogleAnalytics\n    });\n    expect(outerStub.alwaysCalledWith(swTemplate)).to.be.true;\n\n    // Doing a strict comparison with functions isn't easy.\n    expect(innerStub.args[0][0].use).to.be.a('function');\n    delete innerStub.args[0][0].use;\n    expect(innerStub.args[0]).to.eql([{\n      manifestEntries,\n      cacheId: undefined,\n      cleanupOutdatedCaches: undefined,\n      clientsClaim: undefined,\n      disableDevLogs: undefined,\n      importScripts: undefined,\n      navigateFallback: undefined,\n      navigateFallbackDenylist: undefined,\n      navigateFallbackAllowlist: undefined,\n      navigationPreload: undefined,\n      offlineAnalyticsConfigString,\n      precacheOptionsString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      skipWaiting: undefined\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should be a no-op if there's no match","suites":["[workbox-build] lib/replace-and-update-source-map"],"updatePoint":{"line":26,"column":43,"index":892},"line":26,"code":"  it(`should be a no-op if there's no match`, async function () {\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      jsFilename: JS_FILENAME,\n      originalSource: SOURCE,\n      originalMap: SOURCE_MAP,\n      searchString: 'is-not-found',\n      replaceString: 'ignored'\n    });\n    expect(JSON.parse(map)).to.eql(SOURCE_MAP);\n    expect(source).to.eql(SOURCE);\n  });","file":"workbox-build/node/lib/replace-and-update-source-map.js","skipped":false,"dir":"test"},{"name":"should be perform the replacement and update the sourcemap when there is a match","suites":["[workbox-build] lib/replace-and-update-source-map"],"updatePoint":{"line":40,"column":86,"index":1335},"line":40,"code":"  it(`should be perform the replacement and update the sourcemap when there is a match`, async function () {\n    const searchString = 'bc';\n    const replaceString = 'wxyz';\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      searchString,\n      replaceString,\n      jsFilename: JS_FILENAME,\n      originalSource: SOURCE,\n      originalMap: SOURCE_MAP\n    });\n    const expectedSourceMap = Object.assign({}, SOURCE_MAP, {\n      mappings: 'AAAA,KAAG,GAAG,AAAG,CAAC'\n    });\n    expect(JSON.parse(map)).to.eql(expectedSourceMap);\n    expect(source).to.eql('awxyzdefkl');\n  });","file":"workbox-build/node/lib/replace-and-update-source-map.js","skipped":false,"dir":"test"},{"name":"should throw when urlPattern isn't set","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":123,"column":44,"index":5371},"line":123,"code":"  it(`should throw when urlPattern isn't set`, function () {\n    const runtimeCachingOptions = [{\n      handler: 'CacheFirst'\n    }];\n    expect(() => {\n      runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    }).to.throw(errors['urlPattern-is-required']);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should throw when handler isn't set","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":131,"column":41,"index":5648},"line":131,"code":"  it(`should throw when handler isn't set`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /xyz/\n    }];\n    expect(() => {\n      runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    }).to.throw(errors['handler-string-is-required']);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support an empty array of runtimeCaching options","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":139,"column":61,"index":5945},"line":139,"code":"  it(`should support an empty array of runtimeCaching options`, function () {\n    const runtimeCachingOptions = [];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support a single option with a RegExp urlPattern, using mostly defaults","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":144,"column":84,"index":6238},"line":144,"code":"  it(`should support a single option with a RegExp urlPattern, using mostly defaults`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /xyz/,\n      handler: 'CacheFirst'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support multiple options, each setting multiple properties","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":154,"column":71,"index":6655},"line":154,"code":"  it(`should support multiple options, each setting multiple properties`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'NetworkFirst',\n      options: {\n        networkTimeoutSeconds: 20,\n        cacheName: 'abc-cache',\n        expiration: {\n          maxEntries: 5,\n          maxAgeSeconds: 50\n        },\n        broadcastUpdate: {\n          channelName: 'test'\n        },\n        backgroundSync: {\n          name: 'test'\n        },\n        precacheFallback: {\n          fallbackURL: '/test1'\n        },\n        rangeRequests: false,\n        fetchOptions: {\n          headers: {\n            Custom: 'Header'\n          }\n        }\n      }\n    }, {\n      urlPattern: '/test',\n      handler: 'StaleWhileRevalidate',\n      options: {\n        expiration: {\n          maxEntries: 10\n        },\n        cacheableResponse: {\n          statuses: [0, 200]\n        },\n        broadcastUpdate: {\n          channelName: 'test',\n          options: {\n            source: 'test-source'\n          }\n        },\n        backgroundSync: {\n          name: 'test',\n          options: {\n            maxRetentionTime: 123\n          }\n        },\n        rangeRequests: true,\n        precacheFallback: {\n          fallbackURL: '/test2'\n        },\n        matchOptions: {\n          ignoreSearch: true\n        }\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support a string urlPattern, using mostly defaults","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":215,"column":63,"index":8147},"line":215,"code":"  it(`should support a string urlPattern, using mostly defaults`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: '/path/to/file',\n      handler: 'CacheFirst'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support handler being a function","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":223,"column":45,"index":8471},"line":223,"code":"  it(`should support handler being a function`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: () => {}\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support registering non-GET methods","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":231,"column":48,"index":8784},"line":231,"code":"  it(`should support registering non-GET methods`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      method: 'POST'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support custom plugins","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":240,"column":35,"index":9110},"line":240,"code":"  it(`should support custom plugins`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            return response;\n          },\n          cacheDidUpdate: async ({\n            cacheName,\n            request,\n            oldResponse,\n            newResponse\n          }) => {},\n          cachedResponseWillBeUsed: async ({\n            cacheName,\n            request,\n            matchOptions,\n            cachedResponse\n          }) => {\n            return cachedResponse;\n          },\n          requestWillFetch: async ({\n            request\n          }) => {\n            return request;\n          },\n          fetchDidFail: async ({\n            originalRequest,\n            request,\n            error\n          }) => {}\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('cacheWillUpdate: async')).to.true;\n    expect(convertedOptions[0].includes('cacheDidUpdate: async')).to.true;\n    expect(convertedOptions[0].includes('cachedResponseWillBeUsed: async')).to.true;\n    expect(convertedOptions[0].includes('requestWillFetch: async')).to.true;\n    expect(convertedOptions[0].includes('fetchDidFail: async')).to.true;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should strip comments on custom plugins","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":286,"column":45,"index":10542},"line":286,"code":"  it(`should strip comments on custom plugins`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            // Commenting\n            return response;\n          },\n          cachedResponseWillBeUsed: async ({\n            cacheName,\n            request,\n            matchOptions,\n            cachedResponse\n          }) => {\n            /* Commenting */\n            return cachedResponse;\n          }\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('// Commenting')).to.false;\n    expect(convertedOptions[0].includes('/* Commenting */')).to.false;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should keep contents with // that are not comments","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":315,"column":56,"index":11408},"line":315,"code":"  it(`should keep contents with // that are not comments`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            // Commenting\n\n            if (request.url === 'https://test.com') {\n              return null;\n            }\n            return response;\n          }\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('// Commenting')).to.false;\n    expect(convertedOptions[0].includes('https://test.com')).to.true;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should filter out files above maximumFileSizeToCacheInBytes","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":31,"column":65,"index":837},"line":31,"code":"  it(`should filter out files above maximumFileSizeToCacheInBytes`, async function () {\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      maximumFileSizeToCacheInBytes: MAXIMUM_FILE_SIZE,\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size);\n    expect(count).to.eql(2);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should remove revision info based on dontCacheBustURLsMatching","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":50,"column":68,"index":1371},"line":50,"code":"  it(`should remove revision info based on dontCacheBustURLsMatching`, async function () {\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      dontCacheBustURLsMatching: new RegExp(ENTRY1.file),\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: null\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should modify the URLs based on modifyURLPrefix","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":72,"column":53,"index":1960},"line":72,"code":"  it(`should modify the URLs based on modifyURLPrefix`, async function () {\n    const prefix = 'prefix/';\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      modifyURLPrefix: {\n        '': prefix\n      },\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: prefix + ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: prefix + ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: prefix + ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should use custom manifestTransforms","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":97,"column":42,"index":2597},"line":97,"code":"  it(`should use custom manifestTransforms`, async function () {\n    const prefix1 = 'prefix1/';\n    const prefix2 = 'prefix2/';\n    const warning1 = 'test warning 1';\n    const warning2 = 'test warning 1';\n    const transformParam = 'test param';\n    const transform1 = (files, param) => {\n      expect(param).to.eql(transformParam);\n      const manifest = files.map(file => {\n        file.url = prefix1 + file.url;\n        return file;\n      });\n      return {\n        manifest,\n        warnings: [warning1]\n      };\n    };\n    const transform2 = (files, param) => {\n      expect(param).to.eql(transformParam);\n      const manifest = files.map(file => {\n        file.url = prefix2 + file.url;\n        return file;\n      });\n      return {\n        manifest,\n        warnings: [warning2]\n      };\n    };\n    const {\n      size,\n      count,\n      manifestEntries,\n      warnings\n    } = await transformManifest({\n      fileDetails: FILE_DETAILS,\n      manifestTransforms: [transform1, transform2],\n      transformParam\n    });\n    expect(warnings).to.eql([warning1, warning2]);\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: prefix2 + prefix1 + ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: prefix2 + prefix1 + ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: prefix2 + prefix1 + ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should support an async manifestTransform","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":149,"column":47,"index":4069},"line":149,"code":"  it(`should support an async manifestTransform`, async function () {\n    const asyncTransform = async manifest => {\n      await Promise.resolve();\n      return {\n        manifest,\n        warnings: []\n      };\n    };\n    const {\n      size,\n      count,\n      manifestEntries,\n      warnings\n    } = await transformManifest({\n      fileDetails: FILE_DETAILS,\n      manifestTransforms: [asyncTransform]\n    });\n    expect(warnings).to.be.empty;\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should return undefined paths when url is undefined","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":19,"column":57,"index":679},"line":19,"code":"  it(`should return undefined paths when url is undefined`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = require(MODULE_PATH);\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(undefined, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return undefined paths when url starts with data:","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":32,"column":62,"index":1074},"line":32,"code":"  it(`should return undefined paths when url starts with data:`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = require(MODULE_PATH);\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(`data:${URL}`, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return undefined paths and a warning when the resolved URL path doesn't exist","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":45,"column":90,"index":1501},"line":45,"code":"  it(`should return undefined paths and a warning when the resolved URL path doesn't exist`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        existsSync: () => false\n      }\n    });\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(URL, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.include(errors['cant-find-sourcemap']);\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return valid paths and no warning when the resolved URL path exists","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":62,"column":80,"index":2006},"line":62,"code":"  it(`should return valid paths and no warning when the resolved URL path exists`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        existsSync: () => true\n      },\n      'upath': {\n        resolve: (...args) => args.join('/')\n      }\n    });\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(URL, SWSRC, SWDEST);\n    expect(destPath).to.eql('dist/sw.js.map');\n    expect(srcPath).to.eq('src/sw.js.map');\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"() should throw when validation fails","suites":["[workbox-build] entry-points/options/validate-options.js"],"updatePoint":{"line":36,"column":52,"index":1023},"line":36,"code":"    it(`${func}() should throw when validation fails`, function () {\n      const validateOptions = proxyquire(MODULE_PATH, {\n        'ajv': {\n          default: AJVFailsValidation\n        },\n        '@apideck/better-ajv-errors': {\n          betterAjvErrors: sinon.stub().returns([{\n            message: 'message1',\n            path: 'path1',\n            suggestion: 'suggestion1'\n          }, {\n            message: 'message2',\n            path: 'path2',\n            suggestion: 'suggestion2'\n          }])\n        }\n      });\n      expect(() => validateOptions[func]()).to.throw(validateOptions.WorkboxConfigError, `[path1] message1. suggestion1\\n\\n[path2] message2. suggestion2`);\n    });","file":"workbox-build/node/lib/validate-options.js","skipped":false,"dir":"test"},{"name":"() should not throw when validation passes","suites":["[workbox-build] entry-points/options/validate-options.js"],"updatePoint":{"line":55,"column":57,"index":1719},"line":55,"code":"    it(`${func}() should not throw when validation passes`, function () {\n      const validateOptions = proxyquire(MODULE_PATH, {\n        ajv: {\n          default: AJVPassesValidation\n        }\n      });\n      const defaultOptions = validateOptions[func]({\n        globDirectory: '.'\n      });\n      expect(defaultOptions).to.be.an('object');\n    });","file":"workbox-build/node/lib/validate-options.js","skipped":false,"dir":"test"},{"name":"should reject with an error when fs-extra.mkdirp() fails","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":18,"column":62,"index":659},"line":18,"code":"  it(`should reject with an error when fs-extra.mkdirp() fails`, async function () {\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.reject(new Error())\n      }\n    });\n    try {\n      await writeSWUsingDefaultTemplate({});\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-make-sw-directory']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should reject with an error when fs-extra.writeFile() fails","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":36,"column":65,"index":1190},"line":36,"code":"  it(`should reject with an error when fs-extra.writeFile() fails`, async function () {\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.resolve(),\n        writeFile: () => Promise.reject(new Error())\n      }\n    });\n    try {\n      await writeSWUsingDefaultTemplate({\n        manifestEntries: ['ignored']\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['sw-write-failure']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should reject with a specific error when fs-extra.writeFile() fails due to EISDIR","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":57,"column":87,"index":1820},"line":57,"code":"  it(`should reject with a specific error when fs-extra.writeFile() fails due to EISDIR`, async function () {\n    const eisdirError = new Error();\n    eisdirError.code = 'EISDIR';\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.resolve(),\n        readFile: () => Promise.resolve(),\n        writeFile: () => Promise.reject(eisdirError)\n      },\n      './bundle': {\n        bundle: async () => [{\n          name: 'ignored',\n          contents: 'ignored'\n        }]\n      }\n    });\n    try {\n      await writeSWUsingDefaultTemplate({\n        manifestEntries: ['ignored']\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['sw-write-failure-directory']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should call fs-extra.writeFile() with the expected parameters when everything succeeds","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":87,"column":92,"index":2706},"line":87,"code":"  it(`should call fs-extra.writeFile() with the expected parameters when everything succeeds`, async function () {\n    const expectedPath = upath.join('expected', 'path');\n    const swDest = upath.join(expectedPath, 'sw.js');\n    const file1 = 'file1.js';\n    const file2 = 'file2.js';\n    const contents1 = 'contents1';\n    const contents2 = 'contents2';\n    const writeFileStub = sinon.stub().returns(Promise.resolve());\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        mkdirp: path => {\n          expect(path).to.eql(expectedPath);\n        },\n        readFile: () => Promise.resolve(),\n        writeFile: writeFileStub\n      },\n      './bundle': {\n        bundle: async () => [{\n          name: upath.join(expectedPath, file1),\n          contents: contents1\n        }, {\n          name: upath.join(expectedPath, file2),\n          contents: contents2\n        }]\n      },\n      './populate-sw-template': {\n        populateSWTemplate: () => ''\n      }\n    });\n    await writeSWUsingDefaultTemplate({\n      swDest\n    });\n\n    // There should be exactly two calls to fs-extra.writeFile().\n    expect(writeFileStub.args).to.eql([[upath.resolve(expectedPath, file1), contents1], [upath.resolve(expectedPath, file2), contents2]]);\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-cacheable-response]"],"updatePoint":{"line":24,"column":30,"index":776},"line":24,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-cacheable-response/sw/');\n  });","file":"workbox-cacheable-response/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page and cache entries","suites":["[workbox-cacheable-response] Plugin"],"updatePoint":{"line":34,"column":42,"index":1266},"line":34,"code":"  it(`should load a page and cache entries`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    const error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['cacheable-response-cache']);\n    const cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]);\n  });","file":"workbox-cacheable-response/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should reject when both parameters are missing","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":55,"column":54,"index":1742},"line":55,"code":"    it(`should reject when both parameters are missing`, async function () {\n      await expect(app()).to.eventually.be.rejectedWith(errors['missing-input']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command is unknown and options is present","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":58,"column":72,"index":1927},"line":58,"code":"    it(`should reject when the command is unknown and options is present`, async function () {\n      await expect(app({\n        input: [UNKNOWN_COMMAND, PROXIED_CONFIG_FILE]\n      })).to.eventually.be.rejectedWith(errors['unknown-command']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command parameter is copyLibraries and options is missing","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":63,"column":88,"index":2193},"line":63,"code":"    it(`should reject when the command parameter is copyLibraries and options is missing`, async function () {\n      await expect(app({\n        input: ['copyLibraries']\n      })).to.eventually.be.rejectedWith(errors['missing-dest-dir-param']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command parameter is  and options does not exist","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":69,"column":91,"index":2500},"line":69,"code":"      it(`should reject when the command parameter is ${command} and options does not exist`, async function () {\n        const loggerErrorStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/logger.js': {\n            logger: {\n              error: loggerErrorStub\n            }\n          }\n        });\n        try {\n          await app({\n            input: [command, INVALID_CONFIG_FILE]\n          });\n          throw new Error('Unexpected success.');\n        } catch (error) {\n          expect(loggerErrorStub.calledOnce).to.be.true;\n          expect(loggerErrorStub.alwaysCalledWithExactly(errors['invalid-common-js-module'])).to.be.true;\n          expect(error.message).to.have.string(INVALID_CONFIG_FILE);\n        }\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject with a WorkboxConfigError when workbox-build.() is called","suites":["[workbox-cli] app.js","failures due to workbox-build runtime errors"],"updatePoint":{"line":105,"column":118,"index":3687},"line":105,"code":"        it(`should reject with a WorkboxConfigError when workbox-build.${command}(${JSON.stringify(config)}) is called`, async function () {\n          const {\n            app\n          } = proxyquire(MODULE_PATH, {\n            './lib/logger': {\n              logger: {\n                error: sinon.stub(),\n                log: sinon.stub()\n              }\n            },\n            './lib/read-config': {\n              readConfig: options => {\n                expect(options).to.eql(PROXIED_CONFIG_FILE);\n                return config;\n              }\n            }\n          });\n          await expect(app({\n            input: [command, PROXIED_CONFIG_FILE]\n          })).to.eventually.be.rejectedWith(WorkboxConfigError);\n        });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject with a generic runtime error when the workbox-build.() rejects for any other reason","suites":["[workbox-cli] app.js","failures due to workbox-build runtime errors"],"updatePoint":{"line":127,"column":117,"index":4431},"line":127,"code":"      it(`should reject with a generic runtime error when the workbox-build.${command}() rejects for any other reason`, async function () {\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/logger': {\n            logger: {\n              log: sinon.stub()\n            }\n          },\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          'workbox-build': {\n            [command]: config => {\n              expect(config).to.eql(PROXIED_CONFIG);\n              throw PROXIED_ERROR;\n            }\n          }\n        });\n        await expect(app({\n          input: [command, PROXIED_CONFIG_FILE]\n        })).to.eventually.be.rejectedWith(PROXIED_ERROR);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":157,"column":87,"index":5353},"line":157,"code":"      it(`should call logger.log() upon successfully running workbox-build.${command}()`, async function () {\n        const loggerLogStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_NO_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command, PROXIED_CONFIG_FILE]\n        });\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.warn() to report warnings, and then logger.log() upon successfully running workbox-build.()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":184,"column":130,"index":6221},"line":184,"code":"      it(`should call logger.warn() to report warnings, and then logger.log() upon successfully running workbox-build.${command}()`, async function () {\n        const loggerLogStub = sinon.stub();\n        const loggerWarningStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub,\n              warn: loggerWarningStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_WITH_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command, PROXIED_CONFIG_FILE]\n        });\n        expect(loggerWarningStub.calledOnce).to.be.true;\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.() using the default config file location","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":214,"column":126,"index":7231},"line":214,"code":"      it(`should call logger.log() upon successfully running workbox-build.${command}() using the default config file location`, async function () {\n        const loggerLogStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              const defaultConfigPath = upath.join(process.cwd(), constants.defaultConfigFile);\n              expect(options).to.eql(defaultConfigPath);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub,\n              error: loggerLogStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_NO_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command]\n        });\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.copyWorkboxLibraries()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":244,"column":95,"index":8179},"line":244,"code":"    it(`should call logger.log() upon successfully running workbox-build.copyWorkboxLibraries()`, async function () {\n      const loggerLogStub = sinon.stub();\n      const {\n        app\n      } = proxyquire(MODULE_PATH, {\n        './lib/logger': {\n          logger: {\n            log: loggerLogStub\n          }\n        },\n        'workbox-build': {\n          copyWorkboxLibraries: destDir => {\n            expect(destDir).to.eql(PROXIED_DEST_DIR);\n            return upath.join(destDir, 'workbox');\n          }\n        }\n      });\n      await app({\n        input: ['copyLibraries', PROXIED_DEST_DIR]\n      });\n      expect(loggerLogStub.callCount).to.eql(3);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call params.showHelp() when passed 'help'","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":266,"column":56,"index":8807},"line":266,"code":"    it(`should call params.showHelp() when passed 'help'`, async function () {\n      const {\n        app\n      } = require(MODULE_PATH);\n      const params = {\n        input: ['help'],\n        showHelp: sinon.stub()\n      };\n      await app(params);\n      expect(params.showHelp.calledOnce).to.be.true;\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call params.showHelp() when not passed any command","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":277,"column":65,"index":9127},"line":277,"code":"    it(`should call params.showHelp() when not passed any command`, async function () {\n      const {\n        app\n      } = require(MODULE_PATH);\n      const params = {\n        input: [],\n        showHelp: sinon.stub()\n      };\n      await app(params);\n      expect(params.showHelp.calledOnce).to.be.true;\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-cli] package.json"],"updatePoint":{"line":12,"column":39,"index":346},"line":12,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-cli'), {\n        ignoreDirs: ['build'],\n        ignoreMatches: ['@babel/runtime']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n        resolve();\n      });\n    });\n  });","file":"workbox-cli/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-cli] package.json"],"updatePoint":{"line":31,"column":36,"index":1236},"line":31,"code":"  it(`should have no devDependencies`, function () {\n    const pkg = require('../../../packages/workbox-cli/package.json');\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('There should not be devDependencies in this module.');\n    }\n  });","file":"workbox-cli/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should return an empty string when passed an error with no stack","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":16,"column":70,"index":557},"line":16,"code":"  it(`should return an empty string when passed an error with no stack`, function () {\n    const error = new Error();\n    error.stack = '';\n    expect(cleanupStackTrace(error, CURRENT_MODULE_NAME)).to.eql('');\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude every stack frame prior to the first frame of ","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":21,"column":89,"index":792},"line":21,"code":"  it(`should exclude every stack frame prior to the first frame of ${CURRENT_MODULE_NAME}`, function () {\n    const error = new Error();\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(1);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude every stack frame prior to the first frame of , when the error is nested","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":27,"column":115,"index":1129},"line":27,"code":"  it(`should exclude every stack frame prior to the first frame of ${CURRENT_MODULE_NAME}, when the error is nested`, function () {\n    let error;\n    (() => {\n      error = new Error();\n    })();\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(2);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude error.message, and just return the stack frames","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":36,"column":68,"index":1453},"line":36,"code":"  it(`should exclude error.message, and just return the stack frames`, function () {\n    const error = new Error(`line 1\\nline 2\\nline 3`);\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(1);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should be a string","suites":["[workbox-cli] lib/help-text.js"],"updatePoint":{"line":11,"column":24,"index":304},"line":11,"code":"  it(`should be a string`, function () {\n    const {\n      helpText\n    } = require('../../../../packages/workbox-cli/build/lib/help-text');\n    expect(helpText).to.be.a('string');\n  });","file":"workbox-cli/node/lib/help-text.js","skipped":false,"dir":"test"},{"name":"should call console.log() when logger.debug() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":22,"column":59,"index":599},"line":22,"code":"  it(`should call console.log() when logger.debug() is used`, function () {\n    const stub = sandbox.stub(console, 'log');\n    logger.debug('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.log() when logger.log() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":28,"column":57,"index":815},"line":28,"code":"  it(`should call console.log() when logger.log() is used`, function () {\n    const stub = sandbox.stub(console, 'log');\n    logger.log('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.warn() when logger.warn() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":34,"column":59,"index":1031},"line":34,"code":"  it(`should call console.warn() when logger.warn() is used`, function () {\n    const stub = sandbox.stub(console, 'warn');\n    logger.warn('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.error() when logger.error() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":40,"column":61,"index":1251},"line":40,"code":"  it(`should call console.error() when logger.error() is used`, function () {\n    const stub = sandbox.stub(console, 'error');\n    logger.error('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should reject with a 'invalid-config-location' error when the answer is an empty string","suites":["[workbox-cli] lib/questions/ask-config-location.js"],"updatePoint":{"line":19,"column":93,"index":795},"line":19,"code":"  it(`should reject with a 'invalid-config-location' error when the answer is an empty string`, async function () {\n    const {\n      askConfigLocation\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: ''\n        })\n      }\n    });\n    try {\n      await askConfigLocation();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-config-location']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-config-location.js","skipped":false,"dir":"test"},{"name":"should resolve with the valid answer to the question","suites":["[workbox-cli] lib/questions/ask-config-location.js"],"updatePoint":{"line":36,"column":58,"index":1255},"line":36,"code":"  it(`should resolve with the valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askConfigLocation\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askConfigLocation();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-config-location.js","skipped":false,"dir":"test"},{"name":"should reject with a 'no-file-extensions-found' error when the globDirectory doesn't contain any matching files","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":22,"column":117,"index":940},"line":22,"code":"  it(`should reject with a 'no-file-extensions-found' error when the globDirectory doesn't contain any matching files`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, []);\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    try {\n      await askExtensionsToCache(GLOB_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-file-extensions-found']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should reject with a 'no-file-extensions-selected' error when the answer is an empty array","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":46,"column":96,"index":1591},"line":46,"code":"  it(`should reject with a 'no-file-extensions-selected' error when the answer is an empty array`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, [`file.${SINGLE_EXTENSION}`]);\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: []\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    try {\n      await askExtensionsToCache(GLOB_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-file-extensions-selected']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should resolve with the expected value when the answer is a single extension","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":75,"column":82,"index":2365},"line":75,"code":"  it(`should resolve with the expected value when the answer is a single extension`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, [`file.${SINGLE_EXTENSION}`]);\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: [SINGLE_EXTENSION]\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    const answer = await askExtensionsToCache(GLOB_DIRECTORY);\n    expect(answer).to.eql([`**/*.${SINGLE_EXTENSION}`]);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should resolve with the expected value when the answer is multiple extensions","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":100,"column":83,"index":3067},"line":100,"code":"  it(`should resolve with the expected value when the answer is multiple extensions`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, MULTIPLE_EXTENSIONS.map(extension => `file.${extension}`));\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: MULTIPLE_EXTENSIONS\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    const answer = await askExtensionsToCache(GLOB_DIRECTORY);\n    expect(answer).to.eql([`**/*.{${MULTIPLE_EXTENSIONS.join(',')}}`]);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should ignore the expected directories and extensions","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":125,"column":59,"index":3790},"line":125,"code":"  it(`should ignore the expected directories and extensions`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        expect(config.ignore).to.eql(['**/node_modules/**', '**/*.map']);\n        callback(null, MULTIPLE_EXTENSIONS.map(extension => `file.${extension}`));\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: MULTIPLE_EXTENSIONS\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    await askExtensionsToCache(GLOB_DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should ask all the expected questions in the correct order, and return the expected result in generateSW mode","suites":["[workbox-cli] lib/questions/ask-questions.js"],"updatePoint":{"line":14,"column":115,"index":576},"line":14,"code":"  it(`should ask all the expected questions in the correct order, and return the expected result in generateSW mode`, async function () {\n    // Using a stub that returns an increasing value for each call makes it\n    // easy to verify that all the stubs are called in the expected order,\n    // and to verify that the stub's responses are used to create the overall\n    // response in the expected fashion.\n    let count = 0;\n    const stub = sinon.stub();\n    const {\n      askQuestions\n    } = proxyquire(MODULE_PATH, {\n      './ask-root-of-web-app': {\n        askRootOfWebApp: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-extensions-to-cache': {\n        askExtensionsToCache: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-dest': {\n        askSWDest: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-config-location': {\n        askConfigLocation: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-start_url-query-params': {\n        askQueryParametersInStartUrl: stub.callsFake(() => Promise.resolve(count++))\n      }\n    });\n    const answer = await askQuestions();\n    expect(answer).to.eql({\n      config: {\n        globDirectory: 0,\n        globPatterns: 1,\n        swDest: 2,\n        ignoreURLParametersMatching: 4\n      },\n      configLocation: 3\n    });\n    expect(stub.callCount).to.eql(5);\n  });","file":"workbox-cli/node/lib/questions/ask-questions.js","skipped":false,"dir":"test"},{"name":"should ask all the expected questions in the correct order, and return the expected result in injectManifest mode","suites":["[workbox-cli] lib/questions/ask-questions.js"],"updatePoint":{"line":52,"column":119,"index":1976},"line":52,"code":"  it(`should ask all the expected questions in the correct order, and return the expected result in injectManifest mode`, async function () {\n    // Using a stub that returns an increasing value for each call makes it\n    // easy to verify that all the stubs are called in the expected order,\n    // and to verify that the stub's responses are used to create the overall\n    // response in the expected fashion.\n    let count = 0;\n    const stub = sinon.stub();\n    const {\n      askQuestions\n    } = proxyquire(MODULE_PATH, {\n      './ask-root-of-web-app': {\n        askRootOfWebApp: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-extensions-to-cache': {\n        askExtensionsToCache: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-src': {\n        askSWSrc: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-dest': {\n        askSWDest: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-config-location': {\n        askConfigLocation: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-start_url-query-params': {\n        askQueryParametersInStartUrl: stub.callsFake(() => Promise.resolve(count++))\n      }\n    });\n    const answer = await askQuestions({\n      injectManifest: true\n    });\n    expect(answer).to.eql({\n      config: {\n        globDirectory: 0,\n        globPatterns: 1,\n        swSrc: 2,\n        swDest: 3\n      },\n      configLocation: 4\n    });\n    expect(stub.callCount).to.eql(5);\n  });","file":"workbox-cli/node/lib/questions/ask-questions.js","skipped":false,"dir":"test"},{"name":"should reject with a 'glob-directory-invalid' error when the answer isn't a valid directory","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":24,"column":97,"index":1053},"line":24,"code":"  it(`should reject with a 'glob-directory-invalid' error when the answer isn't a valid directory`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              // This will return false when our injected DIRECTORY value is\n              // passed in.\n              return path !== DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    try {\n      await askRootOfWebApp();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['glob-directory-invalid']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should reject with a 'glob-directory-invalid' error when the manual input is provided (directory does not exist)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":55,"column":118,"index":1957},"line":55,"code":"  it(`should reject with a 'glob-directory-invalid' error when the manual input is provided (directory does not exist)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path !== CHILD_DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    try {\n      await askRootOfWebApp();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['glob-directory-invalid']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when no child directories are present (default: use current directory)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":85,"column":127,"index":2821},"line":85,"code":"  it(`should resolve with a valid answer to the question when no child directories are present (default: use current directory)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              // This will return true when our injected DIRECTORY value is\n              // passed in.\n              return path === DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":112,"column":105,"index":3608},"line":112,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists and name contains white space)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":138,"column":135,"index":4383},"line":138,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists and name contains white space)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY_WHITE_SPACE\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY_WHITE_SPACE;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY_WHITE_SPACE);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists and name is composed of only white space)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":164,"column":146,"index":5205},"line":164,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists and name is composed of only white space)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY_BLANK\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY_BLANK;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY_BLANK);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a default search parameters if answered no to the question","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":28,"column":84,"index":1246},"line":28,"code":"  it(`should resolve with a default search parameters if answered no to the question`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = false;\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(DEFAULT_IGNORED_URL_PARAMETERS);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'no-search-parameters-supplied' if answered yes and no url search parameters are passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":42,"column":106,"index":1824},"line":42,"code":"  it(`should throw 'no-search-parameters-supplied' if answered yes and no url search parameters are passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching\n        })\n      }\n    });\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'invalid-search-parameters-supplied' if url search parameter passed is prefixed with '?' or '/'","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":60,"column":114,"index":2498},"line":60,"code":"  it(`should throw 'invalid-search-parameters-supplied' if url search parameter passed is prefixed with '?' or '/'`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = '?source';\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'invalid-search-parameters-supplied' if one of the provided url search parameters is prefixed with '?' or '/'","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":80,"column":128,"index":3321},"line":80,"code":"  it(`should throw 'invalid-search-parameters-supplied' if one of the provided url search parameters is prefixed with '?' or '/'`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search,version,?language';\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should resolve with a list of search parameters when a valid url search parameter is passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":100,"column":97,"index":4130},"line":100,"code":"  it(`should resolve with a list of search parameters when a valid url search parameter is passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search';\n    const expectedAnswer = DEFAULT_IGNORED_URL_PARAMETERS.concat(toRegex(ignoreURLParametersMatching));\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should resolve with a list of search parameters when a valid list of url search parameters is passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":117,"column":106,"index":4924},"line":117,"code":"  it(`should resolve with a list of search parameters when a valid list of url search parameters is passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search,version,language';\n    const expectedAnswer = DEFAULT_IGNORED_URL_PARAMETERS.concat(ignoreURLParametersMatching.split(',').map(toRegex));\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should reject with a 'invalid-sw-dest' error when the answer is empty","suites":["[workbox-cli] lib/questions/ask-sw-dest.js"],"updatePoint":{"line":19,"column":75,"index":753},"line":19,"code":"  it(`should reject with a 'invalid-sw-dest' error when the answer is empty`, async function () {\n    const {\n      askSWDest\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: ''\n        })\n      }\n    });\n    try {\n      await askSWDest();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-sw-dest']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-sw-dest.js","skipped":false,"dir":"test"},{"name":"should reject with a valid answer to the question","suites":["[workbox-cli] lib/questions/ask-sw-dest.js"],"updatePoint":{"line":36,"column":55,"index":1186},"line":36,"code":"  it(`should reject with a valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askSWDest\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askSWDest();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-sw-dest.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question","suites":["[workbox-cli] lib/questions/ask-sw-src.js"],"updatePoint":{"line":16,"column":56,"index":645},"line":16,"code":"  it(`should resolve with a valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askSWSrc\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askSWSrc();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-sw-src.js","skipped":false,"dir":"test"},{"name":"should write the configuration to the expected location based on the answers provided","suites":["[workbox-cli] lib/run-wizard.js"],"updatePoint":{"line":15,"column":91,"index":555},"line":15,"code":"  it(`should write the configuration to the expected location based on the answers provided`, async function () {\n    const configLocation = upath.join('path', 'to', 'config.js');\n    const config = {\n      dummy: 123,\n      regExp: [/1/, /2/]\n    };\n    const fseWriteFileStub = sinon.stub().resolves();\n    const loggerStub = sinon.stub();\n    const {\n      runWizard\n    } = proxyquire(MODULE_PATH, {\n      './logger': {\n        logger: {\n          log: loggerStub\n        }\n      },\n      './questions/ask-questions': {\n        askQuestions: () => {\n          return {\n            config,\n            configLocation\n          };\n        }\n      },\n      'fs-extra': {\n        writeFile: fseWriteFileStub\n      }\n    });\n    await runWizard();\n    const fseArgs = fseWriteFileStub.firstCall.args;\n    expect(fseArgs[0]).to.eql(configLocation);\n    // See https://github.com/GoogleChrome/workbox/issues/2796\n    expect(fseArgs[1]).to.eql(`module.exports = {\n\\tdummy: 123,\n\\tregExp: [\n\\t\\t/1/,\n\\t\\t/2/\n\\t]\n};`);\n    expect(loggerStub.calledTwice).to.be.true;\n  });","file":"workbox-cli/node/lib/run-wizard.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-core]"],"updatePoint":{"line":20,"column":30,"index":522},"line":20,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-core/sw/');\n  });","file":"workbox-core/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load workbox-core in a service worker.","suites":["[workbox-core] Load core in the browser"],"updatePoint":{"line":28,"column":51,"index":896},"line":28,"code":"  it(`should load workbox-core in a service worker.`, async function () {\n    await webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n\n    // If the service worker activated, it meant the assertions in sw.js were\n    // met and workbox-core exposes the expected API and defaults that were\n    // expected\n  });","file":"workbox-core/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-expiration]"],"updatePoint":{"line":24,"column":30,"index":768},"line":24,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-expiration/sw/');\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with entries managed by maxEntries","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":34,"column":59,"index":1243},"line":34,"code":"  it(`should load a page with entries managed by maxEntries`, async function () {\n    const swURL = `${baseURL}sw-max-entries.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-max-entries']);\n    let cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]);\n    error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-2.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has be cleaned up.\n    await waitUntil(async () => {\n      cachedRequests = await runInSW('cacheURLs', keys[0]);\n      return cachedRequests.length === 1 && cachedRequests[0] === `${baseURL}example-2.txt`;\n    });\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with entries managed by maxAgeSeconds","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":70,"column":62,"index":2673},"line":70,"code":"  it(`should load a page with entries managed by maxAgeSeconds`, async function () {\n    const swURL = `${baseURL}sw-max-age-seconds.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-max-age-seconds']);\n    let cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]);\n\n    // Wait 2 seconds to expire entry.\n    await new Promise(resolve => {\n      setTimeout(resolve, 2000);\n    });\n    error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-2.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has be cleaned up.\n    await waitUntil(async () => {\n      cachedRequests = await runInSW('cacheURLs', keys[0]);\n      return cachedRequests.length === 1 && cachedRequests[0] === `${baseURL}example-2.txt`;\n    });\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should clean up when deleteCacheAndMetadata() is called","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":111,"column":61,"index":4226},"line":111,"code":"  it(`should clean up when deleteCacheAndMetadata() is called`, async function () {\n    const swURL = `${baseURL}sw-deletion.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    let keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-deletion']);\n    const existence = await runInSW('doesDbExist', 'workbox-expiration');\n    expect(existence).to.be.true;\n    error = await webdriver.executeAsyncScript(cb => {\n      navigator.serviceWorker.addEventListener('message', event => {\n        cb(event.data);\n      }, {\n        once: true\n      });\n      navigator.serviceWorker.controller.postMessage('delete');\n    });\n    if (error) {\n      throw new Error(error);\n    }\n\n    // After cleanup, there shouldn't be any cache keys or IndexedDB entries\n    // with the cacheName 'expiration-plugin-deletion'.\n    keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal([]);\n    const entries = (await runInSW('getObjectStoreEntries', 'workbox-expiration', 'cache-entries')).filter(entry => {\n      return entry.cacheName === 'expiration-plugin-deletion';\n    });\n    expect(entries).to.deep.equal([]);\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-google-analytics]"],"updatePoint":{"line":23,"column":30,"index":663},"line":23,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-google-analytics/sw/');\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker","suites":["[workbox-google-analytics] initialize"],"updatePoint":{"line":57,"column":44,"index":2022},"line":57,"code":"  it(`should load a page with service worker`, async function () {\n    const err = await webdriver.executeAsyncScript(done => {\n      fetch('https://www.google-analytics.com/analytics.js', {\n        mode: 'no-cors'\n      }).then(() => done(), err => done(err.message));\n    });\n    expect(err).to.not.exist;\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"replay failed Google Analytics hits","suites":["[workbox-google-analytics] initialize"],"updatePoint":{"line":65,"column":41,"index":2333},"line":65,"code":"  it(`replay failed Google Analytics hits`, async function () {\n    // Skip this test in browsers that don't support background sync.\n    // TODO(philipwalton): figure out a way to work around this.\n    const browserSupportsSync = await webdriver.executeScript(() => {\n      return 'SyncManager' in window;\n    });\n    if (!browserSupportsSync) this.skip();\n\n    // Send a hit while online to ensure regular requests work.\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'beacon', {\n        transport_type: 'beacon',\n        event_callback: () => done()\n      });\n    });\n    let requests = await webdriver.executeAsyncScript(messageSW, {\n      action: 'get-spied-requests'\n    });\n    expect(requests).to.have.lengthOf(1);\n\n    // Reset the spied requests array.\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'clear-spied-requests'\n    });\n\n    // Switch the service worker into \"offline\" mode.\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'simulate-offline',\n      value: true\n    });\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'beacon', {\n        transport_type: 'beacon',\n        event_label: Date.now(),\n        event_callback: () => {\n          // See https://github.com/GoogleChrome/workbox/issues/2168\n          setTimeout(done, 50);\n        }\n      });\n    });\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'pixel', {\n        transport_type: 'image',\n        event_label: Date.now(),\n        event_callback: () => {\n          // See https://github.com/GoogleChrome/workbox/issues/2168\n          setTimeout(done, 50);\n        }\n      });\n    });\n\n    // This request should not match GA routes, so it shouldn't be replayed.\n    await webdriver.executeAsyncScript(done => {\n      fetch('https://httpbin.org/get').then(() => done());\n    });\n\n    // Get all spied requests and ensure there haven't been any (since we're\n    // offline).\n    requests = await webdriver.executeAsyncScript(messageSW, {\n      action: 'get-spied-requests'\n    });\n    expect(requests).to.have.lengthOf(0);\n\n    // Switch the service worker into \"online\" mode.\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'simulate-offline',\n      value: false\n    });\n\n    // Dispatch a sync event.\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'dispatch-sync-event'\n    });\n\n    // Wait until all expected requests have replayed.\n    await waitUntil(async () => {\n      requests = await webdriver.executeAsyncScript(messageSW, {\n        action: 'get-spied-requests'\n      });\n      return requests.length === 2;\n    }, 25, 200);\n\n    // Parse the request bodies to set the params as an object and convert the\n    // qt param to a number.\n    for (const request of requests) {\n      request.params = qs.parse(request.body);\n      request.params.qt = Number(request.params.qt);\n      request.originalTime = request.timestamp - request.params.qt;\n    }\n    expect(requests[0].params.ea).to.equal('beacon');\n    expect(requests[1].params.ea).to.equal('pixel');\n\n    // Ensure the hit's qt params were present and greater than 0,\n    // and ensure those values reflect the original order of the hits.\n    expect(requests[0].params.qt > 0).to.be.true;\n    expect(requests[1].params.qt > 0).to.be.true;\n    expect(requests[0].originalTime < requests[1].originalTime).to.be.true;\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should support disabling previously enabled navigation preload","suites":["navigationPreload.disable"],"updatePoint":{"line":27,"column":68,"index":1223},"line":27,"code":"  it(`should support disabling previously enabled navigation preload`, async function () {\n    await activateAndControlSW(`${baseURL}sw-default-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n    if (!isEnabled) {\n      // Just bail early if navigation preload isn't supported, since testing\n      // the disable flow isn't meaningful.\n      return this.skip();\n    }\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL);\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(1);\n\n    // Active the new service worker that has navigation preload disabled.\n    await activateAndControlSW(`${baseURL}sw-disable.js`);\n    await global.__workbox.webdriver.get(integrationURL);\n\n    // With navigation preload now disabled, the synthetic response from the\n    // service worker should fulfill the navigation request, and the server\n    // won't get another HTTP request.\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(1);\n  });","file":"workbox-navigation-preload/integration/test-disable.js","skipped":false,"dir":"test"},{"name":"should make a network request if navigation preload is supported","suites":["navigationPreload.enable"],"updatePoint":{"line":27,"column":70,"index":1224},"line":27,"code":"  it(`should make a network request if navigation preload is supported`, async function () {\n    await activateAndControlSW(`${baseURL}sw-default-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL);\n\n    // If navigation preload is enabled, there should be 1 request. Otherwise,\n    // no requests.\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(isEnabled ? 1 : 0);\n\n    // Check to make sure that the correct header value was sent if navigation\n    // preload is enabled.\n    expect(requestCounter.getHeaderCount('true')).to.eql(isEnabled ? 1 : 0);\n  });","file":"workbox-navigation-preload/integration/test-enable.js","skipped":false,"dir":"test"},{"name":"should make a network request if navigation preload is supported, with a custom header value","suites":["navigationPreload.enable"],"updatePoint":{"line":41,"column":98,"index":1984},"line":41,"code":"  it(`should make a network request if navigation preload is supported, with a custom header value`, async function () {\n    await activateAndControlSW(`${baseURL}sw-custom-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL);\n\n    // If navigation preload is enabled, there should be 1 request. Otherwise,\n    // no requests.\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(isEnabled ? 1 : 0);\n\n    // Check to make sure that the correct header value was sent if navigation\n    // preload is enabled.\n    expect(requestCounter.getHeaderCount('custom-value')).to.eql(isEnabled ? 1 : 0);\n\n    // There shouldn't be any requests with the default header value, 'true'.\n    expect(requestCounter.getHeaderCount('true')).to.eql(0);\n  });","file":"workbox-navigation-preload/integration/test-enable.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-navigation-preload]"],"updatePoint":{"line":13,"column":30,"index":354},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-navigation-preload/sw/');\n  });","file":"workbox-navigation-preload/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"should clean up outdated precached after activation","suites":["[workbox-precaching] cleanupOutdatedCaches()"],"updatePoint":{"line":19,"column":57,"index":886},"line":19,"code":"  it(`should clean up outdated precached after activation`, async function () {\n    // Add an item to an outdated cache.\n    const preActivateKeys = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      // Opening a cache with a given name will cause it to \"exist\", even if it's empty.\n      caches.open('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/').then(() => caches.keys()).then(keys => cb(keys)).catch(err => cb(err.message));\n    });\n    expect(preActivateKeys).to.include('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n    expect(preActivateKeys).to.not.include('workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n\n    // Register the first service worker.\n    await activateAndControlSW(`${baseURL}sw.js`);\n    const postActivateKeys = await runInSW('cachesKeys');\n    expect(postActivateKeys).to.not.include('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n    expect(postActivateKeys).to.include('workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n  });","file":"workbox-precaching/integration/test-cleanup-outdated-caches.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker ","suites":["[workbox-precaching] Precache and Update"],"updatePoint":{"line":19,"column":45,"index":860},"line":19,"code":"  it(`should load a page with service worker `, async function () {\n    const SW_1_URL = `${baseURL}sw-1.js`;\n    const SW_2_URL = `${baseURL}sw-2.js`;\n    const cacheName = 'workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/precache-and-update/';\n    let requestCounter = global.__workbox.server.startCountingRequests();\n\n    // Register the first service worker.\n    await activateAndControlSW(SW_1_URL);\n\n    // Check that only the precache cache was created.\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.eql([cacheName]);\n\n    // Check that the cached requests are what we expect for sw-1.js\n    let cachedRequests = await runInSW('cacheURLs', cacheName);\n    expect(cachedRequests).to.have.members(['http://localhost:3004/test/workbox-precaching/static/precache-and-update/index.html?__WB_REVISION__=1', 'http://localhost:3004/test/workbox-precaching/static/precache-and-update/styles/index.css?__WB_REVISION__=1']);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.equal(1);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.equal(1);\n\n    // Unregister the old counter, and start a new count.\n    global.__workbox.server.stopCountingRequests(requestCounter);\n    requestCounter = global.__workbox.server.startCountingRequests();\n\n    // Request the page and check that the precached assets weren't requested from the network.\n    // Include the default ignoreURLParametersMatching query parameters.\n    await global.__workbox.webdriver.get(`${baseURL}index.html`);\n    await global.__workbox.webdriver.get(`${baseURL}index.html?utm_source=test`);\n    await global.__workbox.webdriver.get(`${baseURL}index.html?fbclid=test`);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html?utm_source=test')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html?fbclid=test')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.eql(0);\n\n    // Unregister the old counter, and start a new count.\n    global.__workbox.server.stopCountingRequests(requestCounter);\n    requestCounter = global.__workbox.server.startCountingRequests();\n\n    // Activate the second service worker\n    await activateAndControlSW(SW_2_URL);\n    // Add a slight delay for the caching operation to complete.\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.equal(1);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/hashed-file.abcd1234.txt')).to.equal(1);\n\n    // Check that the cached entries were deleted / added as expected when\n    // updating from sw-1.js to sw-2.js\n    cachedRequests = await runInSW('cacheURLs', cacheName);\n    expect(cachedRequests).to.have.members(['http://localhost:3004/test/workbox-precaching/static/precache-and-update/index.html?__WB_REVISION__=2', 'http://localhost:3004/test/workbox-precaching/static/precache-and-update/hashed-file.abcd1234.txt']);\n\n    // Unregister the old counter, and start a new count.\n    global.__workbox.server.stopCountingRequests(requestCounter);\n    requestCounter = global.__workbox.server.startCountingRequests();\n    await global.__workbox.webdriver.get(baseURL);\n\n    // Ensure the HTML page is returned from cache and not network.\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/')).to.eql(0);\n    // Ensure the now deleted index.css file is returned from network and not cache.\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.equal(1);\n    global.__workbox.server.stopCountingRequests(requestCounter);\n  });","file":"workbox-precaching/integration/test-precache-and-update.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-precaching]"],"updatePoint":{"line":13,"column":30,"index":346},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-precaching/sw/');\n  });","file":"workbox-precaching/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-range-requests]"],"updatePoint":{"line":22,"column":30,"index":634},"line":22,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-range-requests/sw/');\n  });","file":"workbox-range-requests/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should return a partial response that satisfies the request's Range: header, and an error response when it can't be satisfied","suites":["[workbox-range-requests] Plugin"],"updatePoint":{"line":33,"column":131,"index":1207},"line":33,"code":"  it(`should return a partial response that satisfies the request's Range: header, and an error response when it can't be satisfied`, async function () {\n    const swURL = `${testingURL}sw.js`;\n    await activateAndControlSW(swURL);\n    const dummyURL = `this-file-doesnt-exist.txt`;\n    const partialResponseBody = await webdriver.executeAsyncScript((dummyURL, cb) => {\n      // Prime the cache, and then make the Range: request.\n      fetch(new Request(dummyURL, {\n        headers: {\n          Range: `bytes=5-6`\n        }\n      })).then(response => response.text()).then(text => cb(text)).catch(error => cb(error.message));\n    }, dummyURL);\n\n    // The values used for the byte range are inclusive, so we'll end up with\n    // 11 characters returned in the partial response.\n    expect(partialResponseBody).to.eql('56');\n    const errorResponseStatus = await webdriver.executeAsyncScript((dummyURL, cb) => {\n      // These are arbitrary large values that extend past the end of the file.\n      fetch(new Request(dummyURL, {\n        headers: {\n          Range: `bytes=100-101`\n        }\n      })).then(response => cb(response.status));\n    }, dummyURL);\n\n    // The expected error status is 416 (Range Not Satisfiable)\n    expect(errorResponseStatus).to.eql(416);\n  });","file":"workbox-range-requests/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page and route requests","suites":["[workbox-routing] Route via NavigationRoute"],"updatePoint":{"line":15,"column":43,"index":618},"line":15,"code":"  it(`should load a page and route requests`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await global.__workbox.webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    const nestedURL = `${testingURL}TestNavigationURL`;\n    await global.__workbox.webdriver.get(nestedURL);\n    const bodyText = await global.__workbox.webdriver.executeScript(() => {\n      return document.body.textContent;\n    });\n    expect(bodyText).to.equal(`NavigationRoute.${nestedURL}`);\n  });","file":"workbox-routing/integration/test-navigation-route.js","skipped":false,"dir":"test"},{"name":"should honor a route created by a Route object","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":19,"column":52,"index":736},"line":19,"code":"  it(`should honor a route created by a Route object`, async function () {\n    const testURL = `${testServerAddress}/routeObject`;\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should honor a same-origin route created by a string","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":26,"column":58,"index":1159},"line":26,"code":"  it(`should honor a same-origin route created by a string`, async function () {\n    const testURL = `${testServerAddress}/sameOrigin`;\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should honor a cross-origin route created by a string","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":33,"column":59,"index":1582},"line":33,"code":"  it(`should honor a cross-origin route created by a string`, async function () {\n    const testURL = 'https://example.com/crossOrigin';\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should return a 404 when passed a URL that isn't routed and doesn't exist","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":40,"column":79,"index":2025},"line":40,"code":"  it(`should return a 404 when passed a URL that isn't routed and doesn't exist`, async function () {\n    const testURL = `${testServerAddress}/doesNotMatch`;\n    const responseStatus = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => cb(response.status)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseStatus).to.eql(404);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should load a page and route requests","suites":["[workbox-routing] Route via RegExp"],"updatePoint":{"line":15,"column":43,"index":604},"line":15,"code":"  it(`should load a page and route requests`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await global.__workbox.webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    let testCounter = 0;\n    let response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExp/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExp.${testServerAddress}/RegExp/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/regular-expression/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`regular-expression.${testServerAddress}/regular-expression/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExpRoute/RegExp/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExpRoute.RegExp.${testServerAddress}/RegExpRoute/RegExp/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExpRoute/regular-expression/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExpRoute.regular-expression.${testServerAddress}/RegExpRoute/regular-expression/${testCounter}/`);\n  });","file":"workbox-routing/integration/test-routing-regex.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-routing]"],"updatePoint":{"line":13,"column":30,"index":343},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-routing/sw/');\n  });","file":"workbox-routing/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"should respond with a cached response","suites":["[workbox-strategies] CacheFirst Requests"],"updatePoint":{"line":23,"column":43,"index":972},"line":23,"code":"  it(`should respond with a cached response`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(new URL(`/test/workbox-strategies/static/cache-first/example.txt`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response.trim()).to.equal('hello');\n    expect(requestCounter.getURLCount('/test/workbox-strategies/static/cache-first/example.txt')).to.eql(1);\n\n    // This request should come from cache and not the server\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(new URL(`/test/workbox-strategies/static/cache-first/example.txt`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response.trim()).to.equal('hello');\n    expect(requestCounter.getURLCount('/test/workbox-strategies/static/cache-first/example.txt')).to.eql(1);\n  });","file":"workbox-strategies/integration/test-cacheFirst.js","skipped":false,"dir":"test"},{"name":"should respond with a cached response","suites":["[workbox-strategies] CacheOnly"],"updatePoint":{"line":18,"column":43,"index":771},"line":18,"code":"  it(`should respond with a cached response`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/CacheOnly/InCache/`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response).to.eql('Cached');\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/CacheOnly/NotInCache/`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response).to.not.eql('Cached');\n  });","file":"workbox-strategies/integration/test-cacheOnly.js","skipped":false,"dir":"test"},{"name":"should respond with a non-cached entry but stash request in a cache","suites":["[workbox-strategies] NetworkFirst Requests"],"updatePoint":{"line":20,"column":73,"index":954},"line":20,"code":"  it(`should respond with a non-cached entry but stash request in a cache`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    const cacheName = 'network-first';\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim();\n    expect(firstResponse).to.not.equal('Cached');\n\n    // Writing to the cache is asynchronous, so this might not happen right away.\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === firstResponse;\n    });\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.not.equal(firstResponse);\n\n    // Writing to the cache is asynchronous, so this might not happen right away.\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === secondResponse;\n    });\n  });","file":"workbox-strategies/integration/test-networkFirst.js","skipped":false,"dir":"test"},{"name":"should respond with a non-cached entry","suites":["[workbox-strategies] NetworkOnly Requests"],"updatePoint":{"line":19,"column":44,"index":859},"line":19,"code":"  it(`should respond with a non-cached entry`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim();\n    expect(firstResponse).to.not.eql('Cached');\n    await runInSW('clearAllCaches');\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.not.eql(firstResponse);\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.eql([]);\n  });","file":"workbox-strategies/integration/test-networkOnly.js","skipped":false,"dir":"test"},{"name":"should respond with cached entry and update it","suites":["[workbox-strategies] StaleWhileRevalidate Requests"],"updatePoint":{"line":20,"column":52,"index":950},"line":20,"code":"  it(`should respond with cached entry and update it`, async function () {\n    const swURL = `${baseURL}sw.js`;\n\n    // Wait for the service worker to register and activate.\n    await activateAndControlSW(swURL);\n    const cacheName = 'stale-while-revalidate';\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim();\n\n    // Writing to the cache is asynchronous, so this might not happen right away.\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === firstResponse;\n    });\n\n    // This response should come from cache and not the server\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.eql(firstResponse);\n\n    // Writing to the cache is asynchronous, so this might not happen right away.\n    // We expect a new value, updated from the network, different than secondResponse.\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText !== secondResponse;\n    });\n  });","file":"workbox-strategies/integration/test-staleWhileRevalidate.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-strategies]"],"updatePoint":{"line":13,"column":30,"index":346},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-strategies/sw/');\n  });","file":"workbox-strategies/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-streams]"],"updatePoint":{"line":25,"column":30,"index":683},"line":25,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-streams/sw/');\n  });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should return the expected response for the '' approach","suites":["[workbox-streams] Integration Tests"],"updatePoint":{"line":44,"column":74,"index":1466},"line":44,"code":"    it(`should return the expected response for the '${testCase}' approach`, async function () {\n      const {\n        text,\n        headers\n      } = await webdriver.executeAsyncScript(async (testCase, cb) => {\n        try {\n          const response = await fetch(new URL(testCase, location));\n          const headers = [...response.headers].sort((a, b) => {\n            return a[0] > b[0];\n          });\n          const text = await response.text();\n          cb({\n            headers,\n            text\n          });\n        } catch (error) {\n          cb({\n            text: error.message\n          });\n        }\n      }, testCase);\n      if (text === 'No streams support') {\n        this.skip();\n      } else {\n        expect(text).to.eql('01234\\n');\n        expect(headers).to.eql([['content-type', 'text/plain'], ['x-test-case', testCase]]);\n      }\n    });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should error when a stream source results in an opaque response","suites":["[workbox-streams] Integration Tests"],"updatePoint":{"line":73,"column":69,"index":2329},"line":73,"code":"  it(`should error when a stream source results in an opaque response`, async function () {\n    const {\n      text\n    } = await webdriver.executeAsyncScript(async (crossOriginURL, cb) => {\n      try {\n        const url = new URL('/crossOriginURL', location);\n        url.searchParams.set('cross-origin-url', crossOriginURL);\n        const response = await fetch(url);\n        const text = await response.text();\n        cb({\n          text\n        });\n      } catch (error) {\n        cb({\n          text: error.name\n        });\n      }\n    }, crossOriginURL);\n    if (text === 'No streams support') {\n      this.skip();\n    } else {\n      // The exception name varies from browser to browser.\n      expect(text).to.be.oneOf(['TypeError', 'AbortError']);\n    }\n  });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-sw]"],"updatePoint":{"line":20,"column":30,"index":474},"line":20,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-sw/sw/');\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should fail to activate an invalid SW which loads non-existent modules","suites":["WorkboxSW interface"],"updatePoint":{"line":36,"column":76,"index":1181},"line":36,"code":"  it(`should fail to activate an invalid SW which loads non-existent modules`, async function () {\n    const invalidSW = 'invalid-sw.js';\n    const outcome = await wasRegistrationSuccessful(invalidSW);\n    expect(outcome).to.be.false;\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should be able to activate a SW which loads all valid modules","suites":["WorkboxSW interface"],"updatePoint":{"line":41,"column":67,"index":1413},"line":41,"code":"  it(`should be able to activate a SW which loads all valid modules`, async function () {\n    const validSW = 'valid-sw.js';\n    const outcome = await wasRegistrationSuccessful(validSW);\n    expect(outcome).to.be.true;\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-webpack-plugin] Test Dependencies"],"updatePoint":{"line":12,"column":39,"index":362},"line":12,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-webpack-plugin'), {\n        ignoreDirs: ['test', 'build', 'demo'],\n        ignoreMatches: ['@babel/runtime']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n        resolve();\n      });\n    });\n  });","file":"workbox-webpack-plugin/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-webpack-plugin] Test Dependencies"],"updatePoint":{"line":31,"column":36,"index":1279},"line":31,"code":"  it(`should have no devDependencies`, function () {\n    // This test exists because there have been a number of situations where\n    // dependencies have been used from the top level project and NOT from\n    // this module itself. So dependencies are checked above and devDependencies\n    // can be put in top level.\n    const pkg = require('../../../packages/workbox-build/package.json');\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('No devDependencies in this module.');\n    }\n  });","file":"workbox-webpack-plugin/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":41,"column":77,"index":1965},"line":41,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Please check your GenerateSW plugin configuration:\\n[WebpackGenerateSW] 'invalid' property is not expected to be here. Did you mean property 'include'?`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":71,"column":54,"index":3027},"line":71,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with importScriptsViaChunks","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":113,"column":59,"index":4379},"line":113,"code":"    it(`should work when called with importScriptsViaChunks`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        devtool: 'source-map',\n        entry: {\n          main: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          imported: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          importScriptsViaChunks: ['imported', 'INVALID_CHUNK_NAME']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty;\n          // There should be a warning logged, due to INVALID_CHUNK_NAME.\n          expect(statsJson.warnings).to.have.length(1);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(8);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              // imported-[chunkhash].js.map should *not* be included.\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [/^imported-[0-9a-f]{20}\\.js$/]],\n              // imported-[chunkhash].js should *not* be included.\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with additionalManifestEntries","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":161,"column":62,"index":6177},"line":161,"code":"    it(`should work when called with additionalManifestEntries`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          additionalManifestEntries: [{\n            url: 'one',\n            revision: null\n          }, {\n            url: 'two',\n            revision: null\n          }, {\n            url: 'three',\n            revision: '333'\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          const statsJson = stats.toJson();\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.length(0);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: 'one'\n              }, {\n                revision: '333',\n                url: 'three'\n              }, {\n                revision: null,\n                url: 'two'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":226,"column":50,"index":8150},"line":226,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":271,"column":100,"index":9656},"line":271,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          chunkFilename: '[name].js',\n          filename: 'main.js',\n          path: outputDir\n        },\n        optimization: {\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        plugins: [new GenerateSW({\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'main.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'vendors~main.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":320,"column":56,"index":11095},"line":320,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":365,"column":103,"index":12601},"line":365,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":410,"column":54,"index":14106},"line":410,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":457,"column":54,"index":15673},"line":457,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":524,"column":60,"index":17904},"line":524,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(9);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":567,"column":70,"index":19447},"line":567,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new GenerateSW({\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(6);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js.map'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":609,"column":56,"index":20774},"line":609,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":658,"column":74,"index":22307},"line":658,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":707,"column":51,"index":23827},"line":707,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          // upath.resolve() will always return an absolute upath.\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":748,"column":57,"index":25225},"line":748,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":791,"column":81,"index":26745},"line":791,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings).to.have.members([`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`]);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(12);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":867,"column":31,"index":29367},"line":867,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support projects that bundle WASM code","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] WASM Code"],"updatePoint":{"line":910,"column":53,"index":30753},"line":910,"code":"    it(`should support projects that bundle WASM code`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'wasm-project');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'index.js')\n        },\n        output: {\n          filename: '[name].js',\n          globalObject: 'self',\n          path: outputDir\n        },\n        plugins: [new WorkerPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // Bundling WASM into a Worker seems to lead to different hashes in\n          // different environments. Instead of hardcoding hash checks, just\n          // confirm that we output the expected number of files, which will\n          // only be true if the build was successful.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(6);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using MemoryFS as the outputFileSystem","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filesystem options"],"updatePoint":{"line":946,"column":61,"index":32018},"line":946,"code":"    it(`should support using MemoryFS as the outputFileSystem`, function (done) {\n      const memoryFS = new MemoryFS();\n      const outputDir = '/output/dir';\n      memoryFS.mkdirpSync(outputDir);\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.outputFileSystem = memoryFS;\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = memoryFS.readdirSync(outputDir);\n          expect(files).to.have.length(3);\n          const swString = memoryFS.readFileSync(`${outputDir}/service-worker.js`, 'utf-8');\n          await validateServiceWorkerRuntime({\n            swString,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":988,"column":75,"index":33491},"line":988,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1032,"column":74,"index":35080},"line":1032,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: 'sw1.js'\n        }), new GenerateSW({\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1088,"column":51,"index":36906},"line":1088,"code":"    it(`should support inlining the Workbox runtime`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime and generating sourcemaps","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1120,"column":77,"index":37957},"line":1120,"code":"    it(`should support inlining the Workbox runtime and generating sourcemaps`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true,\n          sourcemap: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1153,"column":66,"index":39024},"line":1153,"code":"    it(`should support using a swDest that includes a subdirectory`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: upath.join('sub', 'directory', 'service-worker.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // Make sure that the expected generated service worker files are\n          // output into the subdirectory.\n          const files = await globby('**/*', {\n            cwd: upath.join(outputDir, 'sub', 'directory')\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1184,"column":44,"index":40042},"line":1184,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1222,"column":34,"index":41240},"line":1222,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1263,"column":37,"index":42530},"line":1263,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(959);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty;\n          expect(statsJson.warnings).to.have.members([warningMessage]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":47,"column":77,"index":2148},"line":47,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Please check your InjectManifest plugin configuration:\\n[WebpackInjectManifest] 'invalid' property is not expected to be here. Did you mean property 'include'?`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when the swSrc contains multiple injection points","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":76,"column":100,"index":3218},"line":76,"code":"    it(`should lead to a webpack compilation error when the swSrc contains multiple injection points`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'bad-multiple-injection.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Multiple instances of self.__WB_MANIFEST were found in your SW source. Include it only once. For more info, see https://github.com/GoogleChrome/workbox/issues/2681`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":106,"column":54,"index":4357},"line":106,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":151,"column":50,"index":5758},"line":151,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":198,"column":100,"index":7312},"line":198,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          chunkFilename: '[name].js',\n          filename: 'main.js',\n          path: outputDir\n        },\n        optimization: {\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'main.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'vendors~main.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":249,"column":56,"index":8799},"line":249,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":296,"column":103,"index":10353},"line":296,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":343,"column":54,"index":11906},"line":343,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":393,"column":54,"index":13531},"line":393,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":463,"column":69,"index":15822},"line":463,"code":"    it(`should update the sourcemap to account for manifest injection`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, '..', '..', 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'service-worker.js.map'));\n\n          // The mappings will vary depending on the webpack version.\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should handle a custom output.sourceMapFilename","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":510,"column":55,"index":17524},"line":510,"code":"    it(`should handle a custom output.sourceMapFilename`, function (done) {\n      const outputDir = tempy.directory();\n      const sourceMapFilename = upath.join('subdir', '[file].map');\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          sourceMapFilename,\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, '..', '..', 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'subdir', 'service-worker.js.map'));\n\n          // The mappings will vary depending on the webpack version.\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not fail if the sourcemap is missing from the assets","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":559,"column":67,"index":19345},"line":559,"code":"    it(`should not fail if the sourcemap is missing from the assets`, function (done) {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-missing-sourcemap.js');\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: false,\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map and minimization are used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":602,"column":92,"index":20773},"line":602,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map and minimization are used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: true\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest'\n            // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n          });\n\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map is used without minimization","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":645,"column":95,"index":22291},"line":645,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map is used without minimization`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest'\n            // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n          });\n\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":688,"column":60,"index":23800},"line":688,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(7);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":734,"column":70,"index":25401},"line":734,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js.map'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":778,"column":56,"index":26776},"line":778,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":829,"column":74,"index":28357},"line":829,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":880,"column":51,"index":29925},"line":880,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":921,"column":57,"index":31265},"line":921,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":966,"column":81,"index":32833},"line":966,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings).to.have.members([`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`]);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":1044,"column":31,"index":35503},"line":1044,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support projects that bundle WASM code","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] WASM Code"],"updatePoint":{"line":1090,"column":53,"index":36947},"line":1090,"code":"    it(`should support projects that bundle WASM code`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'wasm-project');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'index.js')\n        },\n        output: {\n          filename: '[name].js',\n          globalObject: 'self',\n          path: outputDir\n        },\n        plugins: [new WorkerPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // Bundling WASM into a Worker seems to lead to different hashes in\n          // different environments. Instead of hardcoding hash checks, just\n          // confirm that we output the expected number of files, which will\n          // only be true if the build was successful.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1129,"column":44,"index":38279},"line":1129,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1169,"column":34,"index":39525},"line":1169,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use webpackCompilationPlugins with DefinePlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1212,"column":62,"index":40888},"line":1212,"code":"    it(`should use webpackCompilationPlugins with DefinePlugin`, function (done) {\n      const prefix = 'replaced-by-define-plugin';\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-define-plugin.js');\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js',\n          webpackCompilationPlugins: [new webpack.DefinePlugin({\n            __PREFIX__: JSON.stringify(prefix)\n          })]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              setCacheNameDetails: [[{\n                prefix\n              }]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1259,"column":37,"index":42422},"line":1259,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(959);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([warningMessage]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should rename a swSrc with a .ts extension to .js","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] TypeScript compilation"],"updatePoint":{"line":1320,"column":57,"index":44530},"line":1320,"code":"    it(`should rename a swSrc with a .ts extension to .js`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('*', {\n            cwd: outputDir\n          });\n          expect(files).to.contain('sw.js');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1350,"column":75,"index":45540},"line":1350,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(2);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should only log once per invocation when using multiple plugin instances","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1394,"column":80,"index":47112},"line":1394,"code":"    it(`should only log once per invocation when using multiple plugin instances`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker1.js'\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a single warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790#issuecomment-640132556\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple plugin instances"],"updatePoint":{"line":1444,"column":74,"index":48954},"line":1444,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw1.js'\n        }), new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid, parsable JavaScript","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest injection in development mode"],"updatePoint":{"line":1501,"column":49,"index":50863},"line":1501,"code":"    it(`should produce valid, parsable JavaScript`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swDest: 'sw.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw-src.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'sw.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile: swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when compileSrc is false and webpackCompilationPlugins is used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1543,"column":82,"index":52252},"line":1543,"code":"    it(`should warn when compileSrc is false and webpackCompilationPlugins is used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json'),\n          webpackCompilationPlugins: [{}]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members(['compileSrc is false, so the webpackCompilationPlugins option will be ignored.']);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a JSON file","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1572,"column":60,"index":53317},"line":1572,"code":"    it(`should support injecting a manifest into a JSON file`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = await fse.readJSON(upath.join(outputDir, 'injected-manifest.json'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a CJS module","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1606,"column":61,"index":54480},"line":1606,"code":"    it(`should support injecting a manifest into a CJS module`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = require(upath.join(outputDir, 'injected-manifest.js'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":40,"column":77,"index":1918},"line":40,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.length(1);\n          expect(statsJson.errors[0].message).to.eql(`Please check your GenerateSW plugin configuration:\\n[WebpackGenerateSW] 'invalid' property is not expected to be here. Did you mean property 'include'?`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":71,"column":54,"index":3034},"line":71,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with importScriptsViaChunks","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":113,"column":59,"index":4386},"line":113,"code":"    it(`should work when called with importScriptsViaChunks`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        devtool: 'source-map',\n        entry: {\n          main: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          imported: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          importScriptsViaChunks: ['imported', 'INVALID_CHUNK_NAME']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty;\n          // There should be a warning logged, due to INVALID_CHUNK_NAME.\n          expect(statsJson.warnings).to.have.length(1);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(8);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              // imported-[chunkhash].js.map should *not* be included.\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [/^imported-[0-9a-f]{20}\\.js$/]],\n              // imported-[chunkhash].js should *not* be included.\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with additionalManifestEntries","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":161,"column":62,"index":6150},"line":161,"code":"    it(`should work when called with additionalManifestEntries`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          additionalManifestEntries: [{\n            url: 'one',\n            revision: null\n          }, {\n            url: 'two',\n            revision: null\n          }, {\n            url: 'three',\n            revision: '333'\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          const statsJson = stats.toJson();\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.length(0);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: 'one'\n              }, {\n                revision: '333',\n                url: 'three'\n              }, {\n                revision: null,\n                url: 'two'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":226,"column":50,"index":8123},"line":226,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":271,"column":100,"index":9629},"line":271,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          filename: '[chunkhash].js',\n          path: outputDir\n        },\n        optimization: {\n          minimize: false,\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        performance: {\n          hints: false\n        },\n        plugins: [new GenerateSW({\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":323,"column":56,"index":11111},"line":323,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":368,"column":103,"index":12617},"line":368,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":413,"column":54,"index":14122},"line":413,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":460,"column":54,"index":15689},"line":460,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":527,"column":60,"index":17920},"line":527,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(9);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":570,"column":70,"index":19463},"line":570,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: 'manifest-normally-ignored.js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest-normally-ignored.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":608,"column":56,"index":20674},"line":608,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":657,"column":74,"index":22207},"line":657,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":706,"column":51,"index":23727},"line":706,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          // upath.resolve() will always return an absolute upath.\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":747,"column":57,"index":25125},"line":747,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":790,"column":81,"index":26645},"line":790,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings[0].message).to.eql(`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(12);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":866,"column":31,"index":29267},"line":866,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using MemoryFS as the outputFileSystem","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filesystem options"],"updatePoint":{"line":908,"column":61,"index":30607},"line":908,"code":"    it(`should support using MemoryFS as the outputFileSystem`, function (done) {\n      const memoryFS = new MemoryFS();\n      const outputDir = '/output/dir';\n      memoryFS.mkdirpSync(outputDir);\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.outputFileSystem = memoryFS;\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = memoryFS.readdirSync(outputDir);\n          expect(files).to.have.length(3);\n          const swString = memoryFS.readFileSync(`${outputDir}/service-worker.js`, 'utf-8');\n          await validateServiceWorkerRuntime({\n            swString,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":950,"column":75,"index":32080},"line":950,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":994,"column":74,"index":33669},"line":994,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: 'sw1.js'\n        }), new GenerateSW({\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1050,"column":51,"index":35495},"line":1050,"code":"    it(`should support inlining the Workbox runtime`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime and generating sourcemaps","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1082,"column":77,"index":36553},"line":1082,"code":"    it(`should support inlining the Workbox runtime and generating sourcemaps`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true,\n          sourcemap: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1115,"column":66,"index":37627},"line":1115,"code":"    it(`should support using a swDest that includes a subdirectory`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: upath.join('sub', 'directory', 'service-worker.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n\n          // Make sure that the expected generated service worker files are\n          // output into the subdirectory.\n          const files = await globby('**/*', {\n            cwd: upath.join(outputDir, 'sub', 'directory')\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1146,"column":44,"index":38645},"line":1146,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1184,"column":34,"index":39850},"line":1184,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1225,"column":37,"index":41147},"line":1225,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(30);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(warningMessage);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":46,"column":77,"index":2101},"line":46,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors[0].message).to.eql(`Please check your InjectManifest plugin configuration:\\n[WebpackInjectManifest] 'invalid' property is not expected to be here. Did you mean property 'include'?`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when the swSrc contains multiple injection points","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":75,"column":100,"index":3171},"line":75,"code":"    it(`should lead to a webpack compilation error when the swSrc contains multiple injection points`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'bad-multiple-injection.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors[0].message).to.eql(`Multiple instances of self.__WB_MANIFEST were found in your SW source. Include it only once. For more info, see https://github.com/GoogleChrome/workbox/issues/2681`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":105,"column":54,"index":4310},"line":105,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":150,"column":50,"index":5711},"line":150,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":197,"column":100,"index":7265},"line":197,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          filename: '[chunkhash].js',\n          path: outputDir\n        },\n        optimization: {\n          minimize: false,\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        performance: {\n          hints: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":251,"column":56,"index":8795},"line":251,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":298,"column":103,"index":10349},"line":298,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":345,"column":54,"index":11902},"line":345,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":395,"column":54,"index":13527},"line":395,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":465,"column":69,"index":15818},"line":465,"code":"    it(`should update the sourcemap to account for manifest injection`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'service-worker.js.map'));\n\n          // The mappings will vary depending on the webpack version.\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should handle a custom output.sourceMapFilename","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":512,"column":55,"index":17508},"line":512,"code":"    it(`should handle a custom output.sourceMapFilename`, function (done) {\n      const outputDir = tempy.directory();\n      const sourceMapFilename = upath.join('subdir', '[file].map');\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          sourceMapFilename,\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'subdir', 'service-worker.js.map'));\n\n          // The mappings will vary depending on the webpack version.\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not fail if the sourcemap is missing from the assets","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":561,"column":67,"index":19317},"line":561,"code":"    it(`should not fail if the sourcemap is missing from the assets`, function (done) {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-missing-sourcemap.js');\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: false,\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map and minimization are used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":604,"column":92,"index":20745},"line":604,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map and minimization are used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: true\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest'\n            // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n          });\n\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map is used without minimization","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":647,"column":95,"index":22263},"line":647,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map is used without minimization`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest'\n            // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n          });\n\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":690,"column":60,"index":23772},"line":690,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(7);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":736,"column":70,"index":25373},"line":736,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: 'manifest-normally-ignored.js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest-normally-ignored.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":776,"column":56,"index":26632},"line":776,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":827,"column":74,"index":28213},"line":827,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":878,"column":51,"index":29781},"line":878,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":919,"column":57,"index":31121},"line":919,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":964,"column":81,"index":32689},"line":964,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings[0].message).to.eql(`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":1042,"column":31,"index":35359},"line":1042,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1087,"column":44,"index":36746},"line":1087,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1127,"column":34,"index":37999},"line":1127,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use webpackCompilationPlugins with DefinePlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1170,"column":62,"index":39369},"line":1170,"code":"    it(`should use webpackCompilationPlugins with DefinePlugin`, function (done) {\n      const prefix = 'replaced-by-define-plugin';\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-define-plugin.js');\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js',\n          webpackCompilationPlugins: [new webpack.DefinePlugin({\n            __PREFIX__: JSON.stringify(prefix)\n          })]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              setCacheNameDetails: [[{\n                prefix\n              }]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1217,"column":37,"index":40910},"line":1217,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(30);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(warningMessage);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should rename a swSrc with a .ts extension to .js","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] TypeScript compilation"],"updatePoint":{"line":1278,"column":57,"index":43024},"line":1278,"code":"    it(`should rename a swSrc with a .ts extension to .js`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('*', {\n            cwd: outputDir\n          });\n          expect(files).to.contain('sw.js');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1308,"column":75,"index":44041},"line":1308,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(2);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should only log once per invocation when using multiple plugin instances","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1352,"column":80,"index":45620},"line":1352,"code":"    it(`should only log once per invocation when using multiple plugin instances`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker1.js'\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0);\n\n              // There should be a single warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790#issuecomment-640132556\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple plugin instances"],"updatePoint":{"line":1402,"column":74,"index":47469},"line":1402,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw1.js'\n        }), new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid, parsable JavaScript","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest injection in development mode"],"updatePoint":{"line":1459,"column":49,"index":49385},"line":1459,"code":"    it(`should produce valid, parsable JavaScript`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swDest: 'sw.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw-src.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'sw.js');\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile: swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should error when compileSrc is false and webpackCompilationPlugins is used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1501,"column":83,"index":50782},"line":1501,"code":"    it(`should error when compileSrc is false and webpackCompilationPlugins is used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json'),\n          webpackCompilationPlugins: [{}]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql('compileSrc is false, so the webpackCompilationPlugins option will be ignored.');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a JSON file","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1530,"column":60,"index":51854},"line":1530,"code":"    it(`should support injecting a manifest into a JSON file`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = await fse.readJSON(upath.join(outputDir, 'injected-manifest.json'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a CJS module","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1564,"column":61,"index":53024},"line":1564,"code":"    it(`should support injecting a manifest into a CJS module`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = require(upath.join(outputDir, 'injected-manifest.js'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"passes all window unit tests","suites":["[workbox-window]"],"updatePoint":{"line":37,"column":34,"index":1038},"line":37,"code":"  it(`passes all window unit tests`, async function () {\n    await runUnitTests('/test/workbox-window/window/');\n  });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"registers a new service worker","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":57,"column":38,"index":1523},"line":57,"code":"    it(`registers a new service worker`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk');\n          await wb.register();\n          const reg = await navigator.serviceWorker.getRegistration();\n          const sw = reg.installing || reg.waiting || reg.active;\n          cb({\n            scriptURL: sw.scriptURL\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      });\n      expect(result.scriptURL).to.equal(`${testPath}sw-clients-claim.js.njk`);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for a new SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":75,"column":52,"index":2161},"line":75,"code":"    it(`reports all events for a new SW registration`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk');\n          const installedSpy = sinon.spy();\n          const waitingSpy = sinon.spy();\n          const activatedSpy = sinon.spy();\n          const controllingSpy = sinon.spy();\n          wb.addEventListener('installed', installedSpy);\n          wb.addEventListener('waiting', waitingSpy);\n          wb.addEventListener('activated', activatedSpy);\n          wb.addEventListener('controlling', controllingSpy);\n          await wb.register();\n          await window.activatedAndControlling(wb);\n          cb({\n            isUpdate: installedSpy.args[0][0].isUpdate,\n            installedSpyCallCount: installedSpy.callCount,\n            waitingSpyCallCount: waitingSpy.callCount,\n            controllingSpyCallCount: controllingSpy.callCount,\n            controllingIsExternal: controllingSpy.args[0][0].isExternal,\n            activatedSpyCallCount: activatedSpy.callCount\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      });\n\n      // Test for truthiness because some browsers structure clone\n      // `undefined` to `null`.\n      expect(result.isUpdate).to.not.be.ok;\n      expect(result.controllingIsExternal).to.not.be.ok;\n      expect(result.installedSpyCallCount).to.equal(1);\n      expect(result.activatedSpyCallCount).to.equal(1);\n      expect(result.controllingSpyCallCount).to.equal(1);\n\n      //  A new installation shouldn't enter the waiting phase.\n      expect(result.waitingSpyCallCount).to.equal(0);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for an updated SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":115,"column":57,"index":3866},"line":115,"code":"    it(`reports all events for an updated SW registration`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb1 = new Workbox('sw-clients-claim.js.njk?v=1');\n          const redundantSpy = sinon.spy();\n          const wb1ControllingSpy = sinon.spy();\n          wb1.addEventListener('redundant', redundantSpy);\n          wb1.addEventListener('controlling', wb1ControllingSpy);\n          await wb1.register();\n          await window.activatedAndControlling(wb1);\n          const wb2 = new Workbox('sw-clients-claim.js.njk?v=2');\n          const installedSpy = sinon.spy();\n          const waitingSpy = sinon.spy();\n          const activatedSpy = sinon.spy();\n          const wb2ControllingSpy = sinon.spy();\n          wb2.addEventListener('installed', installedSpy);\n          wb2.addEventListener('waiting', waitingSpy);\n          wb2.addEventListener('activated', activatedSpy);\n          wb2.addEventListener('controlling', wb2ControllingSpy);\n          await wb2.register();\n\n          // Once the newly updated SW is in control, report back.\n          await window.activatedAndControlling(wb2);\n          cb({\n            wb1IsUpdate: redundantSpy.args[0][0].isUpdate,\n            wb2IsUpdate: installedSpy.args[0][0].isUpdate,\n            wb1ControllingIsExternal: wb1ControllingSpy.args[0][0].isExternal,\n            wb2ControllingIsExternal: wb2ControllingSpy.args[0][0].isExternal,\n            installedSpyCallCount: installedSpy.callCount,\n            waitingSpyCallCount: waitingSpy.callCount,\n            controllingSpyCallCount: wb2ControllingSpy.callCount,\n            activatedSpyCallCount: activatedSpy.callCount\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      });\n\n      // Test for truthiness because some browsers structure clone\n      // `undefined` to `null`.\n      expect(result.wb1IsUpdate).to.not.be.ok;\n      expect(result.wb2IsUpdate).to.equal(true);\n      expect(result.wb1ControllingIsExternal).to.not.be.ok;\n      expect(result.wb2ControllingIsExternal).to.not.be.ok;\n      expect(result.installedSpyCallCount).to.equal(1);\n      expect(result.waitingSpyCallCount).to.equal(0);\n      expect(result.activatedSpyCallCount).to.equal(1);\n      expect(result.controllingSpyCallCount).to.equal(1);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for an external SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":166,"column":58,"index":6226},"line":166,"code":"    it(`reports all events for an external SW registration`, async function () {\n      const iframeManager = new IframeManager(webdriver);\n      await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk');\n\n          // Use a global variable so these are accessible to future\n          // `executeAsyncAndCatch()` calls.\n          self.__spies = {\n            installedSpy: sinon.spy(),\n            waitingSpy: sinon.spy(),\n            activatedSpy: sinon.spy(),\n            controllingSpy: sinon.spy()\n          };\n          wb.addEventListener('installed', self.__spies.installedSpy);\n          wb.addEventListener('waiting', self.__spies.waitingSpy);\n          wb.addEventListener('activated', self.__spies.activatedSpy);\n          wb.addEventListener('controlling', self.__spies.controllingSpy);\n          await wb.register();\n\n          // Resolve this execution block once the SW is in control.\n          await window.activatedAndControlling(wb);\n          cb();\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      });\n\n      // Update the version in sw.js to trigger a new installation.\n      templateData.assign({\n        version: '2'\n      });\n      const secondPath = `${testPath}?second`;\n      const iframeClient = await iframeManager.createIframeClient(secondPath);\n      const location = await iframeClient.executeAsyncScript(`\n        const wb = new Workbox('sw-clients-claim.js.njk');\n        wb.register()\n          .then(() => window.activatedAndControlling(wb))\n          .then(() => location.href);\n      `);\n\n      // Just confirm we're operating on the page we expect.\n      expect(location).to.eql(secondPath);\n      const result = await executeAsyncAndCatch(async cb => {\n        cb({\n          location: location.href,\n          installedSpyArgs: JSON.stringify(self.__spies.installedSpy.args),\n          waitingSpyArgs: JSON.stringify(self.__spies.waitingSpy.args),\n          activatedSpyArgs: JSON.stringify(self.__spies.activatedSpy.args),\n          controllingSpyArgs: JSON.stringify(self.__spies.controllingSpy.args)\n        });\n      });\n      const installedSpyArgs = JSON.parse(result.installedSpyArgs);\n      const waitingSpyArgs = JSON.parse(result.waitingSpyArgs);\n      const activatedSpyArgs = JSON.parse(result.activatedSpyArgs);\n      const controllingSpyArgs = JSON.parse(result.controllingSpyArgs);\n\n      // Just confirm we're operating on the page we expect.\n      expect(result.location).to.eql(testPath);\n      expect(installedSpyArgs.length, 'installedSpy').to.eql(2);\n      expect(waitingSpyArgs.length, 'waitingSpy').to.eql(0);\n      expect(activatedSpyArgs.length, 'activatedSpy').to.eql(2);\n      expect(controllingSpyArgs.length, 'controllingSpy').to.eql(2);\n      expect(installedSpyArgs[0][0].isExternal).to.eql(false);\n      expect(activatedSpyArgs[0][0].isExternal).to.eql(false);\n      expect(controllingSpyArgs[0][0].isExternal).to.eql(false);\n      expect(installedSpyArgs[1][0].isExternal).to.eql(true);\n      expect(activatedSpyArgs[1][0].isExternal).to.eql(true);\n      expect(controllingSpyArgs[1][0].isExternal).to.eql(true);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"}]}