{"repo":"auth0/node-jsonwebtoken","url":"https://github.com/auth0/node-jsonwebtoken","branch":"master","configs":[{"package":"jsonwebtoken","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should error with with value ","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":26,"column":64,"index":822},"line":26,"code":"      it(`should error with with value ${util.inspect(audience)}`, function (done) {\n        signWithAudience(audience, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"audience\" must be a string or array');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":37,"column":46,"index":1257},"line":37,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        audience: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"audience\" must be a string or array');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error when \"aud\" is in payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":48,"column":45,"index":1654},"line":48,"code":"    it('should error when \"aud\" is in payload', function (done) {\n      signWithAudience('my_aud', {\n        aud: ''\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.audience\" option. The payload already has an \"aud\" property.');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":58,"column":42,"index":2034},"line":58,"code":"    it('should error with a string payload', function (done) {\n      signWithAudience('my_aud', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for string payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":66,"column":42,"index":2376},"line":66,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithAudience('my_aud', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for object payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":85,"column":95,"index":3312},"line":85,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud', 'urn:foo');\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":94,"column":73,"index":3675},"line":94,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":102,"column":83,"index":4085},"line":102,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":110,"column":72,"index":4526},"line":110,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":118,"column":82,"index":4941},"line":118,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":126,"column":100,"index":5422},"line":126,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":144,"column":95,"index":6372},"line":144,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":153,"column":73,"index":6760},"line":153,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":161,"column":83,"index":7170},"line":161,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":169,"column":72,"index":7611},"line":169,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":177,"column":82,"index":8026},"line":177,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":185,"column":100,"index":8507},"line":185,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of stings verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":194,"column":74,"index":9041},"line":194,"code":"        it('should verify with an array of stings verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:foo', 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":202,"column":63,"index":9423},"line":202,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:[a-z]{3}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":210,"column":73,"index":9809},"line":210,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:f[o]{2}$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":220,"column":57,"index":10283},"line":220,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:foo', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":228,"column":63,"index":10652},"line":228,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:f[o]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":236,"column":66,"index":11030},"line":236,"code":"        it('should verify with an array of Regex verify \"audience\"', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":244,"column":96,"index":11458},"line":244,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":252,"column":96,"index":11884},"line":252,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:foo'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":262,"column":57,"index":12346},"line":262,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:bar', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":270,"column":63,"index":12715},"line":270,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:b[ar]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":278,"column":73,"index":13101},"line":278,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":286,"column":96,"index":13530},"line":286,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":294,"column":96,"index":13957},"line":294,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode without verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":312,"column":67,"index":14601},"line":312,"code":"      it('should verify and decode without verify \"audience\" option', function (done) {\n        verifyWithAudience(token, undefined, (err, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.null;\n            expect(decoded).to.not.have.property('aud');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":320,"column":73,"index":14934},"line":320,"code":"      it('should error on no match with a string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":328,"column":83,"index":15344},"line":328,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":336,"column":72,"index":15785},"line":336,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":344,"column":82,"index":16200},"line":344,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":352,"column":100,"index":16681},"line":352,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":23,"column":65,"index":777},"line":23,"code":"      it(`should error with with value ${util.inspect(expiresIn)}`, function (done) {\n        signWithExpiresIn(expiresIn, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"expiresIn\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":34,"column":46,"index":1265},"line":34,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        expiresIn: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"expiresIn\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error when \"exp\" is in payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":45,"column":45,"index":1702},"line":45,"code":"    it('should error when \"exp\" is in payload', function (done) {\n      signWithExpiresIn(100, {\n        exp: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.expiresIn\" option the payload already has an \"exp\" property.');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":55,"column":42,"index":2079},"line":55,"code":"    it('should error with a string payload', function (done) {\n      signWithExpiresIn(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for string payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":63,"column":42,"index":2418},"line":63,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithExpiresIn(100, Buffer.from('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for object payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"exp\" claim validation"],"updatePoint":{"line":76,"column":59,"index":2970},"line":76,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        signWithExpiresIn(undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"exp\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","\"exp\" in payload validation"],"updatePoint":{"line":92,"column":59,"index":3545},"line":92,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        const header = {\n          alg: 'HS256'\n        };\n        const payload = {\n          exp\n        };\n        const token = jws.sign({\n          header,\n          payload,\n          secret: 'secret',\n          encoding: 'utf8'\n        });\n        testUtils.verifyJWTHelper(token, 'secret', {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid exp value');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":126,"column":64,"index":4471},"line":126,"code":"    it('should set correct \"exp\" with negative number of seconds', function (done) {\n      signWithExpiresIn(-10, {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":138,"column":64,"index":4928},"line":138,"code":"    it('should set correct \"exp\" with positive number of seconds', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":149,"column":50,"index":5338},"line":149,"code":"    it('should set correct \"exp\" with zero seconds', function (done) {\n      signWithExpiresIn(0, {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":161,"column":62,"index":5787},"line":161,"code":"    it('should set correct \"exp\" with negative string timespan', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":173,"column":62,"index":6246},"line":173,"code":"    it('should set correct \"exp\" with positive string timespan', function (done) {\n      signWithExpiresIn('10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":185,"column":58,"index":6700},"line":185,"code":"    it('should set correct \"exp\" with zero string timespan', function (done) {\n      signWithExpiresIn('0 s', {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given -Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":199,"column":50,"index":7197},"line":199,"code":"    it('should set null \"exp\" when given -Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":212,"column":55,"index":7622},"line":212,"code":"    it('should set null \"exp\" when given value Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value NaN","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":225,"column":50,"index":8036},"line":225,"code":"    it('should set null \"exp\" when given value NaN', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" when \"iat\" is passed","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":236,"column":53,"index":8398},"line":236,"code":"    it('should set correct \"exp\" when \"iat\" is passed', function (done) {\n      signWithExpiresIn(-10, {\n        iat: 80\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTimestamp\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":249,"column":50,"index":8832},"line":249,"code":"    it('should verify \"exp\" using \"clockTimestamp\"', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTimestamp: 69\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTolerance\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":263,"column":50,"index":9337},"line":263,"code":"    it('should verify \"exp\" using \"clockTolerance\"', function (done) {\n      signWithExpiresIn(5, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTimestamp: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 65);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should ignore a expired token when \"ignoreExpiration\" is true","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":278,"column":69,"index":9890},"line":278,"code":"    it('should ignore a expired token when \"ignoreExpiration\" is true', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          ignoreExpiration: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is at current time","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":292,"column":58,"index":10412},"line":292,"code":"    it('should error on verify if \"exp\" is at current time', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: 60\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is before current time using clockTolerance","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":305,"column":83,"index":10913},"line":305,"code":"    it('should error on verify if \"exp\" is before current time using clockTolerance', function (done) {\n      signWithExpiresIn(-5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTolerance: 5\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":32,"column":55,"index":1034},"line":32,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        signWithIssueAt(iat, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err.message).to.equal('\"iat\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of undefined","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":43,"column":42,"index":1447},"line":43,"code":"    it('should error with iat of undefined', function (done) {\n      testUtils.signJWTHelper({\n        iat: undefined\n      }, 'secret', {\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err.message).to.equal('\"iat\" should be a number of seconds');\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","\"iat\" in payload with \"maxAge\" option validation"],"updatePoint":{"line":60,"column":55,"index":2062},"line":60,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        const header = {\n          alg: 'HS256'\n        };\n        const payload = {\n          iat\n        };\n        const token = jws.sign({\n          header,\n          payload,\n          secret: 'secret',\n          encoding: 'utf8'\n        });\n        verifyWithIssueAt(token, '1 min', {}, 'secret', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err.message).to.equal('iat required when maxAge is specified');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to string","suites":["issue at","with string payload"],"updatePoint":{"line":241,"column":36,"index":7470},"line":241,"code":"    it('should not add iat to string', function (done) {\n      const payload = 'string payload';\n      const options = {\n        algorithm: 'HS256'\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to stringified object","suites":["issue at","with string payload"],"updatePoint":{"line":254,"column":48,"index":7910},"line":254,"code":"    it('should not add iat to stringified object', function (done) {\n      const payload = '{}';\n      const options = {\n        algorithm: 'HS256',\n        header: {\n          typ: 'JWT'\n        }\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.equal(null);\n          expect(JSON.stringify(decoded)).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":21,"column":62,"index":682},"line":21,"code":"      it(`should error with with value ${util.inspect(issuer)}`, function (done) {\n        signWithIssuer(issuer, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"issuer\" must be a string');\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":32,"column":46,"index":1105},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        issuer: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"issuer\" must be a string');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error when \"iss\" is in payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":43,"column":45,"index":1489},"line":43,"code":"    it('should error when \"iss\" is in payload', function (done) {\n      signWithIssuer('foo', {\n        iss: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.issuer\" option. The payload already has an \"iss\" property.');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":53,"column":42,"index":1865},"line":53,"code":"    it('should error with a string payload', function (done) {\n      signWithIssuer('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for string payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":61,"column":42,"index":2200},"line":61,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithIssuer('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for object payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"iss\" if verify \"issuer\" option not provided","suites":["issuer","when signing and verifying a token"],"updatePoint":{"line":71,"column":70,"index":2644},"line":71,"code":"    it('should not verify \"iss\" if verify \"issuer\" option not provided', function (done) {\n      signWithIssuer(undefined, {\n        iss: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iss', 'foo');\n          });\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":85,"column":46,"index":3141},"line":85,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":98,"column":43,"index":3604},"line":98,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":113,"column":69,"index":4127},"line":113,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":128,"column":68,"index":4699},"line":128,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":143,"column":46,"index":5281},"line":143,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('bar', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":156,"column":43,"index":5753},"line":156,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":171,"column":69,"index":6285},"line":171,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":186,"column":68,"index":6870},"line":186,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":21,"column":61,"index":673},"line":21,"code":"      it(`should error with with value ${util.inspect(jwtid)}`, function (done) {\n        signWithJWTId(jwtid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"jwtid\" must be a string');\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":32,"column":46,"index":1092},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        jwtid: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"jwtid\" must be a string');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error when \"jti\" is in payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":43,"column":45,"index":1474},"line":43,"code":"    it('should error when \"jti\" is in payload', function (done) {\n      signWithJWTId('foo', {\n        jti: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.jwtid\" option. The payload already has an \"jti\" property.');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":53,"column":42,"index":1848},"line":53,"code":"    it('should error with a string payload', function (done) {\n      signWithJWTId('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for string payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":61,"column":42,"index":2181},"line":61,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithJWTId('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for object payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"jti\" if verify \"jwtid\" option not provided","suites":["jwtid","when signing and verifying a token"],"updatePoint":{"line":71,"column":69,"index":2622},"line":71,"code":"    it('should not verify \"jti\" if verify \"jwtid\" option not provided', function (done) {\n      signWithJWTId(undefined, {\n        jti: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('jti', 'foo');\n          });\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":85,"column":43,"index":3107},"line":85,"code":"      it('should verify with \"jwtid\" option', function (done) {\n        signWithJWTId('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            jwtid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jti\" in payload","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":98,"column":45,"index":3570},"line":98,"code":"      it('should verify with \"jti\" in payload', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            jetid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error if \"jti\" does not match verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":113,"column":68,"index":4090},"line":113,"code":"      it('should error if \"jti\" does not match verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'bar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error without \"jti\" and with verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":128,"column":67,"index":4655},"line":128,"code":"      it('should error without \"jti\" and with verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, 'secret', {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":23,"column":65,"index":780},"line":23,"code":"      it(`should error with with value ${util.inspect(notBefore)}`, function (done) {\n        signWithNotBefore(notBefore, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"notBefore\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":34,"column":46,"index":1268},"line":34,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        notBefore: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"notBefore\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error when \"nbf\" is in payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":45,"column":45,"index":1705},"line":45,"code":"    it('should error when \"nbf\" is in payload', function (done) {\n      signWithNotBefore(100, {\n        nbf: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.notBefore\" option the payload already has an \"nbf\" property.');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":55,"column":42,"index":2082},"line":55,"code":"    it('should error with a string payload', function (done) {\n      signWithNotBefore(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for string payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":63,"column":42,"index":2421},"line":63,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithNotBefore(100, new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for object payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"nbf\" claim validation"],"updatePoint":{"line":76,"column":59,"index":2972},"line":76,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        signWithNotBefore(undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"nbf\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","\"nbf\" in payload validation"],"updatePoint":{"line":92,"column":59,"index":3547},"line":92,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        const header = {\n          alg: 'HS256'\n        };\n        const payload = {\n          nbf\n        };\n        const token = jws.sign({\n          header,\n          payload,\n          secret: 'secret',\n          encoding: 'utf8'\n        });\n        testUtils.verifyJWTHelper(token, 'secret', {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid nbf value');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":126,"column":64,"index":4477},"line":126,"code":"    it('should set correct \"nbf\" with negative number of seconds', function (done) {\n      signWithNotBefore(-10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":137,"column":64,"index":4902},"line":137,"code":"    it('should set correct \"nbf\" with positive number of seconds', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":149,"column":50,"index":5343},"line":149,"code":"    it('should set correct \"nbf\" with zero seconds', function (done) {\n      signWithNotBefore(0, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":160,"column":62,"index":5764},"line":160,"code":"    it('should set correct \"nbf\" with negative string timespan', function (done) {\n      signWithNotBefore('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":171,"column":62,"index":6191},"line":171,"code":"    it('should set correct \"nbf\" with positive string timespan', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":183,"column":58,"index":6644},"line":183,"code":"    it('should set correct \"nbf\" with zero string timespan', function (done) {\n      signWithNotBefore('0 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given -Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":196,"column":50,"index":7113},"line":196,"code":"    it('should set null \"nbf\" when given -Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":209,"column":55,"index":7538},"line":209,"code":"    it('should set null \"nbf\" when given value Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value NaN","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":222,"column":50,"index":7952},"line":222,"code":"    it('should set null \"nbf\" when given value NaN', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" when \"iat\" is passed","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":233,"column":53,"index":8314},"line":233,"code":"    it('should set correct \"nbf\" when \"iat\" is passed', function (done) {\n      signWithNotBefore(-10, {\n        iat: 40\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 30);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTimestamp\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":246,"column":50,"index":8748},"line":246,"code":"    it('should verify \"nbf\" using \"clockTimestamp\"', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTimestamp: 70\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTolerance\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":260,"column":50,"index":9253},"line":260,"code":"    it('should verify \"nbf\" using \"clockTolerance\"', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTolerance: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 65);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should ignore a not active token when \"ignoreNotBefore\" is true","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":274,"column":71,"index":9777},"line":274,"code":"    it('should ignore a not active token when \"ignoreNotBefore\" is true', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          ignoreNotBefore: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":288,"column":61,"index":10300},"line":288,"code":"    it('should error on verify if \"nbf\" is after current time', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: 61\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time using clockTolerance","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":301,"column":82,"index":10800},"line":301,"code":"    it('should error on verify if \"nbf\" is after current time using clockTolerance', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, 'secret', {\n          clockTolerance: 4\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":21,"column":61,"index":673},"line":21,"code":"      it(`should error with with value ${util.inspect(keyid)}`, function (done) {\n        signWithKeyId(keyid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"keyid\" must be a string');\n          });\n        });\n      });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":32,"column":46,"index":1092},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        keyid: undefined,\n        algorithm: 'HS256'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"keyid\" must be a string');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should not add \"kid\" header when \"keyid\" option not provided","suites":["keyid","when signing a token"],"updatePoint":{"line":45,"column":68,"index":1552},"line":45,"code":"    it('should not add \"kid\" header when \"keyid\" option not provided', function (done) {\n      signWithKeyId(undefined, {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.not.have.property('kid');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and an object payload","suites":["keyid","when signing a token"],"updatePoint":{"line":56,"column":85,"index":1967},"line":56,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and an object payload', function (done) {\n      signWithKeyId('foo', {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a Buffer payload","suites":["keyid","when signing a token"],"updatePoint":{"line":67,"column":84,"index":2380},"line":67,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a Buffer payload', function (done) {\n      signWithKeyId('foo', new Buffer('a Buffer payload'), (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a string payload","suites":["keyid","when signing a token"],"updatePoint":{"line":78,"column":84,"index":2821},"line":78,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a string payload', function (done) {\n      signWithKeyId('foo', 'a string payload', (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["maxAge option"],"updatePoint":{"line":53,"column":55,"index":1305},"line":53,"code":"    it(`should error with value ${util.inspect(maxAge)}`, function (done) {\n      expect(() => jwt.verify(token, 'secret', {\n        maxAge,\n        algorithm: 'HS256'\n      })).to.throw(jwt.JsonWebTokenError, '\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n      jwt.verify(token, 'secret', {\n        maxAge,\n        algorithm: 'HS256'\n      }, err => {\n        expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n        expect(err.message).to.equal('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n        done();\n      });\n    });","file":"option-maxAge.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["nonce option"],"updatePoint":{"line":34,"column":54,"index":956},"line":34,"code":"    it(`should error with value ${util.inspect(nonce)}`, function (done) {\n      testUtils.verifyJWTHelper(token, 'secret', {\n        nonce\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n          expect(err).to.have.property('message', 'nonce must be a non-empty string');\n        });\n      });\n    });","file":"option-nonce.test.js","skipped":false,"dir":"test"}]}