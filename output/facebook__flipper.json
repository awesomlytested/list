{"repo":"facebook/flipper","url":"https://github.com/facebook/flipper","branch":"main","configs":[{"package":"flipper-pkg-lib","lang":"ts","dir":"desktop/pkg-lib/src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-pkg","lang":"ts","dir":"desktop/pkg/src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-lib","lang":"ts","dir":"desktop/plugin-lib/src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-crash-reporter","lang":"js","dir":"desktop/plugins/public/crash_reporter/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-databases","lang":"js","dir":"desktop/plugins/public/databases/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-inspector","lang":"js","dir":"desktop/plugins/public/layout/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-device-logs","lang":"js","dir":"desktop/plugins/public/logs/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-navigation","lang":"js","dir":"desktop/plugins/public/navigation/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-network","lang":"js","dir":"desktop/plugins/public/network/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"flipper-plugin-sea-mammals","lang":"js","dir":"desktop/plugins/public/seamammals/src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"js-flipper","lang":"ts","dir":"js/js-flipper/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"ReactNativeFlipperExample","lang":"js","dir":"react-native/ReactNativeFlipperExample/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"returns a list of registered plugins","suites":["client","message handling","getPlugins"],"updatePoint":{"line":65,"column":46},"line":65,"code":"      it('returns a list of registered plugins', async () => {\n        const serverReceivedMessages = new WSMessageAccumulator();\n        wsServer.on('connection', (ws) => {\n          ws.send(JSON.stringify({method: 'getPlugins', id: 0}));\n          ws.on('message', (message) =>\n            serverReceivedMessages.add(message.toString()),\n          );\n        });\n\n        client.addPlugin({\n          getId: () => '42',\n          onConnect: () => undefined,\n          onDisconnect: () => undefined,\n        });\n\n        await client.start('universe', {urlBase, websocketFactory});\n\n        const expectedGetPluginsResponse = {\n          id: 0,\n          success: {\n            plugins: ['42'],\n          },\n        };\n        const actualGetPluginsReponse = await serverReceivedMessages.newMessage;\n        expect(actualGetPluginsReponse).toBe(\n          JSON.stringify(expectedGetPluginsResponse),\n        );\n      });","file":"client.spec.ts","skipped":false,"dir":"js/js-flipper/src/__tests__"},{"name":"onError is called if message handling has failed, connection is closed, client reconnects","suites":["client","message handling","getPlugins"],"updatePoint":{"line":95,"column":97},"line":95,"code":"    it('onError is called if message handling has failed, connection is closed, client reconnects', async () => {\n      const onError = jest.fn();\n\n      let resolveFirstConnectionPromise: () => void;\n      const firstConnectionPromise = new Promise<void>((resolve) => {\n        resolveFirstConnectionPromise = resolve;\n      });\n      wsServer.on('connection', (ws) => {\n        resolveFirstConnectionPromise();\n        // Send a malformed message to cause a failure\n        ws.send('{{{');\n      });\n\n      // Capturing a moment when the client received an error\n      const receivedErrorPromise = new Promise<void>((resolve) =>\n        onError.mockImplementationOnce(() => {\n          resolve();\n        }),\n      );\n\n      await client.start('universe', {urlBase, websocketFactory, onError});\n\n      // Capturing a moment when the client was closed because of the error\n      const closedPromise = new Promise<void>((resolve) => {\n        const originalOnclose = (client as any).ws.onclose;\n        (client as any).ws.onclose = (data: unknown) => {\n          originalOnclose(data);\n          resolve();\n        };\n      });\n\n      await receivedErrorPromise;\n      expect(onError).toBeCalledTimes(1);\n\n      // Make sure that the connection went through\n      await firstConnectionPromise;\n\n      wsServer.removeAllListeners('connection');\n\n      let resolveSecondConnectionPromise: () => void;\n      const secondConnectionPromise = new Promise<void>((resolve) => {\n        resolveSecondConnectionPromise = resolve;\n      });\n      wsServer.on('connection', () => {\n        resolveSecondConnectionPromise();\n      });\n\n      // Make sure the current client is closed\n      // When it closes, it schedules a reconnection\n      await closedPromise;\n\n      // Now, once the reconnection is scheduled, we can advance timers to do the actual reconnection\n      clock.tick(RECONNECT_TIMEOUT);\n\n      // Make sure that the client reconnects\n      await secondConnectionPromise;\n    });","file":"client.spec.ts","skipped":false,"dir":"js/js-flipper/src/__tests__"},{"name":"onError is called if connection has failed, it is called every time Flipper fails to reconnect","suites":["client","connection"],"updatePoint":{"line":155,"column":102},"line":155,"code":"    it('onError is called if connection has failed, it is called every time Flipper fails to reconnect', async () => {\n      allowConnection = false;\n\n      const onError = jest.fn();\n\n      expect(onError).toBeCalledTimes(0);\n      client.start('universe', {urlBase, websocketFactory, onError});\n\n      // Expect connection request to fail\n      await new Promise((resolve) => onError.mockImplementationOnce(resolve));\n      expect(onError).toBeCalledTimes(1);\n      // Checking that the request went through to the server\n      expect(verifyClient).toBeCalledTimes(1);\n\n      // Exepect reconnection attempts to fail\n      for (let i = 2; i < 10; i++) {\n        clock.tick(RECONNECT_TIMEOUT);\n        await new Promise((resolve) => onError.mockImplementationOnce(resolve));\n        expect(onError).toBeCalledTimes(i);\n        expect(verifyClient).toBeCalledTimes(i);\n      }\n    });","file":"client.spec.ts","skipped":false,"dir":"js/js-flipper/src/__tests__"},{"name":"renders correctly","suites":[],"updatePoint":{"line":14,"column":21,"index":408},"line":14,"code":"it('renders correctly', () => {\n  renderer.create( /*#__PURE__*/React.createElement(App, null));\n});","file":"App-test.js","skipped":false,"dir":"react-native/ReactNativeFlipperExample/__tests__"}]}