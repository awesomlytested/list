{"repo":"websockets/ws","url":"https://github.com/websockets/ws","branch":"master","configs":[{"package":"ws","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"never returns uninitialized data","suites":["bufferUtil","concat"],"updatePoint":{"line":9,"column":40,"index":202},"line":9,"code":"    it('never returns uninitialized data', () => {\n      const buf = concat([Buffer.from([1, 2]), Buffer.from([3, 4])], 6);\n      assert.ok(buf.equals(Buffer.from([1, 2, 3, 4])));\n    });","file":"buffer-util.test.js","skipped":false,"dir":"test"},{"name":"is exposed as a property of the `WebSocket` class","suites":["createWebSocketStream"],"updatePoint":{"line":21,"column":55,"index":502},"line":21,"code":"  it('is exposed as a property of the `WebSocket` class', () => {\n    assert.strictEqual(WebSocket.createWebSocketStream, createWebSocketStream);\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"returns a `Duplex` stream","suites":["createWebSocketStream"],"updatePoint":{"line":24,"column":31,"index":630},"line":24,"code":"  it('returns a `Duplex` stream', () => {\n    const duplex = createWebSocketStream(new EventEmitter());\n    assert.ok(duplex instanceof Duplex);\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"passes the options object to the `Duplex` constructor","suites":["createWebSocketStream"],"updatePoint":{"line":28,"column":59,"index":809},"line":28,"code":"  it('passes the options object to the `Duplex` constructor', done => {\n    const wss = new WebSocket.Server({\n      port: 0\n    }, () => {\n      const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      const duplex = createWebSocketStream(ws, {\n        allowHalfOpen: false,\n        encoding: 'utf8'\n      });\n      duplex.on('data', chunk => {\n        assert.strictEqual(chunk, 'hi');\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n      });\n    });\n    wss.on('connection', ws => {\n      ws.send(Buffer.from('hi'));\n      ws.close();\n    });\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"buffers writes if `readyState` is `CONNECTING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":50,"column":54,"index":1439},"line":50,"code":"    it('buffers writes if `readyState` is `CONNECTING`', done => {\n      const chunk = randomBytes(1024);\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        const duplex = createWebSocketStream(ws);\n        duplex.write(chunk);\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(message, chunk);\n            assert.ok(isBinary);\n            assert.strictEqual(code, 1005);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"errors if a write occurs when `readyState` is `CLOSING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":73,"column":63,"index":2262},"line":73,"code":"    it('errors if a write occurs when `readyState` is `CLOSING`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(duplex.destroyed);\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          ws._receiver.on('conclude', () => {\n            duplex.write('hi');\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"errors if a write occurs when `readyState` is `CLOSED`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":97,"column":62,"index":3054},"line":97,"code":"    it('errors if a write occurs when `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(duplex.destroyed);\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('close', () => {\n          duplex.write('hi');\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not error if `_final()` is called while connecting","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":119,"column":63,"index":3785},"line":119,"code":"    it('does not error if `_final()` is called while connecting', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n        duplex.resume();\n        duplex.end();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"makes `_final()` a noop if no socket is assigned","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":133,"column":56,"index":4256},"line":133,"code":"    it('makes `_final()` a noop if no socket is assigned', done => {\n      const server = createServer();\n      server.on('upgrade', (request, socket) => {\n        socket.on('end', socket.end);\n        const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Accept: foo'];\n        socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n      });\n      server.listen(() => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        const duplex = WebSocket.createWebSocketStream(ws);\n        const final = duplex._final;\n        duplex._final = callback => {\n          called.push('final');\n          assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n          assert.strictEqual(ws._socket, null);\n          final(callback);\n        };\n        duplex.on('error', err => {\n          called.push('error');\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Accept header');\n        });\n        duplex.on('finish', () => {\n          called.push('finish');\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['final', 'error']);\n          server.close(done);\n        });\n        ws.on('upgrade', () => {\n          process.nextTick(() => {\n            duplex.end();\n          });\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"reemits errors","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":170,"column":22,"index":5633},"line":170,"code":"    it('reemits errors', done => {\n      let duplexCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          duplex.on('close', () => {\n            duplexCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          serverClientCloseEventEmitted = true;\n          if (duplexCloseEventEmitted) wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not swallow errors that may occur while destroying","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":198,"column":63,"index":6780},"line":198,"code":"    it('does not swallow errors that may occur while destroying', done => {\n      const frame = Buffer.concat(Sender.frame(Buffer.from([0x22, 0xfa, 0xec, 0x78]), {\n        fin: true,\n        rsv1: true,\n        opcode: 0x02,\n        mask: false,\n        readOnly: false\n      }));\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.code, 'Z_DATA_ERROR');\n          assert.strictEqual(err.errno, -3);\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        let bytesRead = 0;\n        ws.on('open', () => {\n          ws._socket.on('data', chunk => {\n            bytesRead += chunk.length;\n            if (bytesRead === frame.length) duplex.destroy();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(frame);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not suppress the throwing behavior of 'error' events","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":232,"column":65,"index":7889},"line":232,"code":"    it(\"does not suppress the throwing behavior of 'error' events\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        createWebSocketStream(ws);\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n      });\n      assert.strictEqual(process.listenerCount('uncaughtException'), 1);\n      const [listener] = process.listeners('uncaughtException');\n      process.removeAllListeners('uncaughtException');\n      process.once('uncaughtException', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n        process.on('uncaughtException', listener);\n        wss.close(done);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"is destroyed after 'end' and 'finish' are emitted (1/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":252,"column":63,"index":8719},"line":252,"code":"    it(\"is destroyed after 'end' and 'finish' are emitted (1/2)\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('end', () => {\n          events.push('end');\n          assert.ok(duplex.destroyed);\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['finish', 'end']);\n          wss.close(done);\n        });\n        duplex.on('finish', () => {\n          events.push('finish');\n          assert.ok(!duplex.destroyed);\n          assert.ok(duplex.readable);\n          duplex.resume();\n        });\n        ws.on('close', () => {\n          duplex.end();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"is destroyed after 'end' and 'finish' are emitted (2/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":282,"column":63,"index":9629},"line":282,"code":"    it(\"is destroyed after 'end' and 'finish' are emitted (2/2)\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('end', () => {\n          events.push('end');\n          assert.ok(!duplex.destroyed);\n          assert.ok(duplex.writable);\n          duplex.end();\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['end', 'finish']);\n          wss.close(done);\n        });\n        duplex.on('finish', () => {\n          events.push('finish');\n        });\n        duplex.resume();\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (1/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":308,"column":34,"index":10402},"line":308,"code":"    it('handles backpressure (1/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        // eslint-disable-next-line no-unused-vars\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const duplex = createWebSocketStream(ws);\n        duplex.resume();\n        duplex.on('drain', () => {\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n          duplex.end();\n        });\n        const chunk = randomBytes(1024);\n        let ret;\n        do {\n          ret = duplex.write(chunk);\n        } while (ret !== false);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (2/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":331,"column":34,"index":11078},"line":331,"code":"    it('handles backpressure (2/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        perMessageDeflate: true\n      }, () => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        const read = duplex._read;\n        duplex._read = () => {\n          duplex._read = read;\n          called.push('read');\n          assert.ok(ws._receiver._writableState.needDrain);\n          read();\n          assert.ok(ws._socket.isPaused());\n        };\n        ws.on('open', () => {\n          ws._socket.on('pause', () => {\n            duplex.resume();\n          });\n          ws._receiver.on('drain', () => {\n            called.push('drain');\n            assert.ok(!ws._socket.isPaused());\n            duplex.end();\n          });\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(randomBytes(16 * 1024), {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(Buffer.alloc(1), {\n            rsv1: true,\n            ...opts\n          })];\n\n          // This hack is used because there is no guarantee that more than\n          // 16 KiB will be sent as a single TCP packet.\n          ws._socket.push(Buffer.concat(list));\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['read', 'drain']);\n          wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (3/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":380,"column":34,"index":12628},"line":380,"code":"    it('handles backpressure (3/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        perMessageDeflate: true\n      }, () => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        const read = duplex._read;\n        duplex._read = () => {\n          called.push('read');\n          assert.ok(!ws._receiver._writableState.needDrain);\n          read();\n          assert.ok(!ws._socket.isPaused());\n          duplex.end();\n        };\n        ws.on('open', () => {\n          ws._receiver.on('drain', () => {\n            called.push('drain');\n            assert.ok(ws._socket.isPaused());\n            duplex.resume();\n          });\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(randomBytes(16 * 1024), {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(Buffer.alloc(1), {\n            rsv1: true,\n            ...opts\n          })];\n          ws._socket.push(Buffer.concat(list));\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['drain', 'read']);\n          wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"can be destroyed (1/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":423,"column":30,"index":13953},"line":423,"code":"    it('can be destroyed (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const error = new Error('Oops');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.strictEqual(err, error);\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          duplex.destroy(error);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"can be destroyed (2/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":441,"column":30,"index":14498},"line":441,"code":"    it('can be destroyed (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n        ws.on('open', () => {\n          duplex.destroy();\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"converts text messages to strings in readable object mode","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":455,"column":65,"index":14936},"line":455,"code":"    it('converts text messages to strings in readable object mode', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws, {\n          readableObjectMode: true\n        });\n        duplex.on('data', data => {\n          events.push('data');\n          assert.strictEqual(data, 'foo');\n        });\n        duplex.on('end', () => {\n          events.push('end');\n          duplex.end();\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['data', 'end']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket if `readyState` is `CLOSING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":482,"column":55,"index":15738},"line":482,"code":"    it('resumes the socket if `readyState` is `CLOSING`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        ws.on('message', () => {\n          assert.ok(ws._socket.isPaused());\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n          duplex.end();\n          process.nextTick(() => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n            duplex.resume();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send(randomBytes(16 * 1024));\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["Event","#ctor"],"updatePoint":{"line":12,"column":31,"index":231},"line":12,"code":"    it('takes a `type` argument', () => {\n      const event = new Event('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["Event","Properties","`target`"],"updatePoint":{"line":19,"column":40,"index":445},"line":19,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'target');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["Event","Properties","`target`"],"updatePoint":{"line":26,"column":28,"index":795},"line":26,"code":"      it('defaults to `null`', () => {\n        const event = new Event('foo');\n        assert.strictEqual(event.target, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["Event","Properties","`type`"],"updatePoint":{"line":32,"column":40,"index":983},"line":32,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'type');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["CloseEvent"],"updatePoint":{"line":43,"column":27,"index":1379},"line":43,"code":"  it('inherits from `Event`', () => {\n    assert.ok(CloseEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["CloseEvent","#ctor"],"updatePoint":{"line":47,"column":31,"index":1509},"line":47,"code":"    it('takes a `type` argument', () => {\n      const event = new CloseEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["CloseEvent","#ctor"],"updatePoint":{"line":51,"column":44,"index":1660},"line":51,"code":"    it('takes an optional `options` argument', () => {\n      const event = new CloseEvent('close', {\n        code: 1000,\n        reason: 'foo',\n        wasClean: true\n      });\n      assert.strictEqual(event.type, 'close');\n      assert.strictEqual(event.code, 1000);\n      assert.strictEqual(event.reason, 'foo');\n      assert.strictEqual(event.wasClean, true);\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`code`"],"updatePoint":{"line":65,"column":40,"index":2097},"line":65,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'code');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to 0","suites":["CloseEvent","Properties","`code`"],"updatePoint":{"line":72,"column":23,"index":2445},"line":72,"code":"      it('defaults to 0', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.code, 0);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`reason`"],"updatePoint":{"line":78,"column":40,"index":2637},"line":78,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'reason');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to an empty string","suites":["CloseEvent","Properties","`reason`"],"updatePoint":{"line":85,"column":37,"index":3001},"line":85,"code":"      it('defaults to an empty string', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.reason, '');\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`wasClean`"],"updatePoint":{"line":91,"column":40,"index":3198},"line":91,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'wasClean');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to false","suites":["CloseEvent","Properties","`wasClean`"],"updatePoint":{"line":98,"column":27,"index":3554},"line":98,"code":"      it('defaults to false', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.wasClean, false);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["ErrorEvent"],"updatePoint":{"line":106,"column":27,"index":3749},"line":106,"code":"  it('inherits from `Event`', () => {\n    assert.ok(ErrorEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["ErrorEvent","#ctor"],"updatePoint":{"line":110,"column":31,"index":3879},"line":110,"code":"    it('takes a `type` argument', () => {\n      const event = new ErrorEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["ErrorEvent","#ctor"],"updatePoint":{"line":114,"column":44,"index":4030},"line":114,"code":"    it('takes an optional `options` argument', () => {\n      const error = new Error('Oops');\n      const event = new ErrorEvent('error', {\n        error,\n        message: error.message\n      });\n      assert.strictEqual(event.type, 'error');\n      assert.strictEqual(event.error, error);\n      assert.strictEqual(event.message, error.message);\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["ErrorEvent","Properties","`error`"],"updatePoint":{"line":127,"column":40,"index":4450},"line":127,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(ErrorEvent.prototype, 'error');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["ErrorEvent","Properties","`error`"],"updatePoint":{"line":134,"column":28,"index":4804},"line":134,"code":"      it('defaults to `null`', () => {\n        const event = new ErrorEvent('error');\n        assert.strictEqual(event.error, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["ErrorEvent","Properties","`message`"],"updatePoint":{"line":140,"column":40,"index":5001},"line":140,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(ErrorEvent.prototype, 'message');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to an empty string","suites":["ErrorEvent","Properties","`message`"],"updatePoint":{"line":147,"column":37,"index":5366},"line":147,"code":"      it('defaults to an empty string', () => {\n        const event = new ErrorEvent('error');\n        assert.strictEqual(event.message, '');\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["MessageEvent"],"updatePoint":{"line":155,"column":27,"index":5559},"line":155,"code":"  it('inherits from `Event`', () => {\n    assert.ok(MessageEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["MessageEvent","#ctor"],"updatePoint":{"line":159,"column":31,"index":5691},"line":159,"code":"    it('takes a `type` argument', () => {\n      const event = new MessageEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["MessageEvent","#ctor"],"updatePoint":{"line":163,"column":44,"index":5844},"line":163,"code":"    it('takes an optional `options` argument', () => {\n      const event = new MessageEvent('message', {\n        data: 'bar'\n      });\n      assert.strictEqual(event.type, 'message');\n      assert.strictEqual(event.data, 'bar');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["MessageEvent","Properties","`data`"],"updatePoint":{"line":173,"column":40,"index":6147},"line":173,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(MessageEvent.prototype, 'data');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["MessageEvent","Properties","`data`"],"updatePoint":{"line":180,"column":28,"index":6502},"line":180,"code":"      it('defaults to `null`', () => {\n        const event = new MessageEvent('message');\n        assert.strictEqual(event.data, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"parses a single extension","suites":["extension","parse"],"updatePoint":{"line":10,"column":33,"index":200},"line":10,"code":"    it('parses a single extension', () => {\n      assert.deepStrictEqual(parse('foo'), {\n        foo: [{\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses params","suites":["extension","parse"],"updatePoint":{"line":18,"column":21,"index":373},"line":18,"code":"    it('parses params', () => {\n      assert.deepStrictEqual(parse('foo;bar;baz=1;bar=2'), {\n        foo: [{\n          bar: [true, '2'],\n          baz: ['1'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses multiple extensions","suites":["extension","parse"],"updatePoint":{"line":28,"column":34,"index":625},"line":28,"code":"    it('parses multiple extensions', () => {\n      assert.deepStrictEqual(parse('foo,bar;baz,foo;baz'), {\n        foo: [{\n          __proto__: null\n        }, {\n          baz: [true],\n          __proto__: null\n        }],\n        bar: [{\n          baz: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses quoted params","suites":["extension","parse"],"updatePoint":{"line":43,"column":28,"index":960},"line":43,"code":"    it('parses quoted params', () => {\n      assert.deepStrictEqual(parse('foo;bar=\"hi\"'), {\n        foo: [{\n          bar: ['hi'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"\\\\0\"'), {\n        foo: [{\n          bar: ['0'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"b\\\\a\\\\z\"'), {\n        foo: [{\n          bar: ['baz'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"b\\\\az\";bar'), {\n        foo: [{\n          bar: ['baz', true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.throws(() => parse('foo;bar=\"baz\"qux'), /^SyntaxError: Unexpected character at index 13$/);\n      assert.throws(() => parse('foo;bar=\"baz\" qux'), /^SyntaxError: Unexpected character at index 14$/);\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"works with names that match `Object.prototype` property names","suites":["extension","parse"],"updatePoint":{"line":75,"column":69,"index":1939},"line":75,"code":"    it('works with names that match `Object.prototype` property names', () => {\n      assert.deepStrictEqual(parse('hasOwnProperty, toString'), {\n        hasOwnProperty: [{\n          __proto__: null\n        }],\n        toString: [{\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;constructor'), {\n        foo: [{\n          constructor: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"ignores the optional white spaces","suites":["extension","parse"],"updatePoint":{"line":93,"column":41,"index":2399},"line":93,"code":"    it('ignores the optional white spaces', () => {\n      const header = 'foo; bar\\t; \\tbaz=1\\t ;  bar=\"1\"\\t\\t, \\tqux\\t ;norf';\n      assert.deepStrictEqual(parse(header), {\n        foo: [{\n          bar: [true, '1'],\n          baz: ['1'],\n          __proto__: null\n        }],\n        qux: [{\n          norf: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a name is empty","suites":["extension","parse"],"updatePoint":{"line":108,"column":42,"index":2798},"line":108,"code":"    it('throws an error if a name is empty', () => {\n      [[',', 0], ['foo,,', 4], ['foo,  ,', 6], ['foo;=', 4], ['foo; =', 5], ['foo;;', 4], ['foo; ;', 5], ['foo;bar=,', 8], ['foo;bar=\"\"', 9]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a white space is misplaced","suites":["extension","parse"],"updatePoint":{"line":113,"column":53,"index":3165},"line":113,"code":"    it('throws an error if a white space is misplaced', () => {\n      [[' foo', 0], ['f oo', 2], ['foo;ba r', 7], ['foo;bar =', 8], ['foo;bar= ', 8], ['foo;bar=ba z', 11]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a token contains invalid characters","suites":["extension","parse"],"updatePoint":{"line":118,"column":62,"index":3507},"line":118,"code":"    it('throws an error if a token contains invalid characters', () => {\n      [['f@o', 1], ['f\\\\oo', 1], ['\"foo\"', 0], ['f\"oo\"', 1], ['foo;b@r', 5], ['foo;b\\\\ar', 5], ['foo;\"bar\"', 4], ['foo;b\"ar\"', 5], ['foo;bar=b@z', 9], ['foo;bar=b\\\\az ', 9], ['foo;bar=\"b@z\"', 10], ['foo;bar=\"baz;\"', 12], ['foo;bar=b\"az\"', 9], ['foo;bar=\"\\\\\\\\\"', 10]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the header value ends prematurely","suites":["extension","parse"],"updatePoint":{"line":123,"column":60,"index":4006},"line":123,"code":"    it('throws an error if the header value ends prematurely', () => {\n      ['', 'foo ', 'foo\\t', 'foo, ', 'foo;', 'foo;bar ', 'foo;bar,', 'foo;bar; ', 'foo;bar=', 'foo;bar=\"baz', 'foo;bar=\"1\\\\', 'foo;bar=\"baz\" '].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: Unexpected end of input$/);\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats a single extension","suites":["extension","format"],"updatePoint":{"line":130,"column":34,"index":4354},"line":130,"code":"    it('formats a single extension', () => {\n      const extensions = format({\n        foo: {}\n      });\n      assert.strictEqual(extensions, 'foo');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats params","suites":["extension","format"],"updatePoint":{"line":136,"column":22,"index":4500},"line":136,"code":"    it('formats params', () => {\n      const extensions = format({\n        foo: {\n          bar: [true, 2],\n          baz: 1\n        }\n      });\n      assert.strictEqual(extensions, 'foo; bar; bar=2; baz=1');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats multiple extensions","suites":["extension","format"],"updatePoint":{"line":145,"column":35,"index":4730},"line":145,"code":"    it('formats multiple extensions', () => {\n      const extensions = format({\n        foo: [{}, {\n          baz: true\n        }],\n        bar: {\n          baz: true\n        }\n      });\n      assert.strictEqual(extensions, 'foo, foo; baz, bar; baz');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"takes a `concurrency` argument","suites":["Limiter","#ctor"],"updatePoint":{"line":7,"column":38,"index":187},"line":7,"code":"    it('takes a `concurrency` argument', () => {\n      const limiter = new Limiter(0);\n      assert.strictEqual(limiter.concurrency, Infinity);\n    });","file":"limiter.test.js","skipped":false,"dir":"test"},{"name":"limits the number of jobs allowed to run concurrently","suites":["Limiter","#kRun"],"updatePoint":{"line":13,"column":61,"index":396},"line":13,"code":"    it('limits the number of jobs allowed to run concurrently', done => {\n      const limiter = new Limiter(1);\n      limiter.add(callback => {\n        setImmediate(() => {\n          callback();\n          assert.strictEqual(limiter.jobs.length, 0);\n          assert.strictEqual(limiter.pending, 1);\n        });\n      });\n      limiter.add(callback => {\n        setImmediate(() => {\n          callback();\n          assert.strictEqual(limiter.pending, 0);\n          done();\n        });\n      });\n      assert.strictEqual(limiter.jobs.length, 1);\n    });","file":"limiter.test.js","skipped":false,"dir":"test"},{"name":"creates an offer","suites":["PerMessageDeflate","#offer"],"updatePoint":{"line":8,"column":24,"index":252},"line":8,"code":"    it('creates an offer', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      assert.deepStrictEqual(perMessageDeflate.offer(), {\n        client_max_window_bits: true\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses the configuration options","suites":["PerMessageDeflate","#offer"],"updatePoint":{"line":14,"column":38,"index":471},"line":14,"code":"    it('uses the configuration options', () => {\n      const perMessageDeflate = new PerMessageDeflate({\n        serverNoContextTakeover: true,\n        clientNoContextTakeover: true,\n        serverMaxWindowBits: 10,\n        clientMaxWindowBits: 11\n      });\n      assert.deepStrictEqual(perMessageDeflate.offer(), {\n        server_no_context_takeover: true,\n        client_no_context_takeover: true,\n        server_max_window_bits: 10,\n        client_max_window_bits: 11\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a parameter has multiple values","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":30,"column":58,"index":1016},"line":30,"code":"    it('throws an error if a parameter has multiple values', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover; server_no_context_takeover');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Parameter \"server_no_context_takeover\" must have only a single value$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a parameter has an invalid name","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":35,"column":58,"index":1438},"line":35,"code":"    it('throws an error if a parameter has an invalid name', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate;foo');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unknown parameter \"foo\"$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_no_context_takeover has a value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":40,"column":65,"index":1770},"line":40,"code":"    it('throws an error if client_no_context_takeover has a value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; client_no_context_takeover=10');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_no_context_takeover\": 10$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_no_context_takeover has a value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":45,"column":65,"index":2170},"line":45,"code":"    it('throws an error if server_no_context_takeover has a value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover=10');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_no_context_takeover\": 10$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":50,"column":70,"index":2575},"line":50,"code":"    it('throws an error if server_max_window_bits has an invalid value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let extensions = extension.parse('permessage-deflate; server_max_window_bits=7');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_max_window_bits\": 7$/);\n      extensions = extension.parse('permessage-deflate; server_max_window_bits');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_max_window_bits\": true$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts an offer with no parameters","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":58,"column":45,"index":3221},"line":58,"code":"      it('accepts an offer with no parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {});\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts an offer with parameters","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":62,"column":42,"index":3419},"line":62,"code":"      it('accepts an offer with parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 10,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"prefers the configuration options","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":73,"column":43,"index":4031},"line":73,"code":"      it('prefers the configuration options', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverNoContextTakeover: true,\n          clientNoContextTakeover: true,\n          serverMaxWindowBits: 12,\n          clientMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=14; client_max_window_bits=13');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 12,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts the first supported offer","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":89,"column":43,"index":4737},"line":89,"code":"      it('accepts the first supported offer', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10, permessage-deflate');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_no_context_takeover is unsupported","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":99,"column":70,"index":5220},"line":99,"code":"      it('throws an error if server_no_context_takeover is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverNoContextTakeover: false\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits is unsupported","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":106,"column":66,"index":5664},"line":106,"code":"      it('throws an error if server_max_window_bits is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: false\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits is less than configuration","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":113,"column":78,"index":6115},"line":113,"code":"      it('throws an error if server_max_window_bits is less than configuration', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is unsupported on client","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":120,"column":76,"index":6561},"line":120,"code":"      it('throws an error if client_max_window_bits is unsupported on client', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        }, true);\n        const extensions = extension.parse('permessage-deflate');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":127,"column":72,"index":6976},"line":127,"code":"      it('throws an error if client_max_window_bits has an invalid value', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=16');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": 16$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts a response with no parameters","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":134,"column":47,"index":7408},"line":134,"code":"      it('accepts a response with no parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({});\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {});\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts a response with parameters","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":138,"column":44,"index":7602},"line":138,"code":"      it('accepts a response with parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({});\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 10,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_no_context_takeover is unsupported","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":149,"column":70,"index":8235},"line":149,"code":"      it('throws an error if client_no_context_takeover is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientNoContextTakeover: false\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected parameter \"client_no_context_takeover\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is unsupported","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":156,"column":66,"index":8678},"line":156,"code":"      it('throws an error if client_max_window_bits is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: false\n        });\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected or invalid parameter \"client_max_window_bits\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is greater than configuration","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":163,"column":81,"index":9138},"line":163,"code":"      it('throws an error if client_max_window_bits is greater than configuration', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        });\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=11');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected or invalid parameter \"client_max_window_bits\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":170,"column":72,"index":9586},"line":170,"code":"      it('throws an error if client_max_window_bits has an invalid value', () => {\n        const perMessageDeflate = new PerMessageDeflate();\n        let extensions = extension.parse('permessage-deflate; client_max_window_bits=16');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": 16$/);\n        extensions = extension.parse('permessage-deflate; client_max_window_bits');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": true$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses the config value if client_max_window_bits is not specified","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":177,"column":74,"index":10241},"line":177,"code":"      it('uses the config value if client_max_window_bits is not specified', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        });\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {\n          client_max_window_bits: 10\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with unfragmented messages","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":188,"column":40,"index":10582},"line":188,"code":"    it('works with unfragmented messages', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from([1, 2, 3]);\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with fragmented messages","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":201,"column":38,"index":11056},"line":201,"code":"    it('works with fragmented messages', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from([1, 2, 3, 4]);\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf.slice(0, 2), false, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.compress(buf.slice(2), true, (err, compressed2) => {\n          if (err) return done(err);\n          perMessageDeflate.decompress(compressed1, false, (err, data1) => {\n            if (err) return done(err);\n            perMessageDeflate.decompress(compressed2, true, (err, data2) => {\n              if (err) return done(err);\n              assert.ok(Buffer.concat([data1, data2]).equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with the negotiated parameters","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":220,"column":44,"index":11870},"line":220,"code":"    it('works with the negotiated parameters', done => {\n      const perMessageDeflate = new PerMessageDeflate({\n        memLevel: 5,\n        level: 9\n      });\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"honors the `level` option","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":237,"column":33,"index":12633},"line":237,"code":"    it('honors the `level` option', done => {\n      const lev0 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 0\n        }\n      });\n      const lev9 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 9\n        }\n      });\n      const extensionStr = 'permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11';\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      lev0.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev9.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev0.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        lev0.decompress(compressed1, true, (err, decompressed1) => {\n          if (err) return done(err);\n          lev9.compress(buf, true, (err, compressed2) => {\n            if (err) return done(err);\n            lev9.decompress(compressed2, true, (err, decompressed2) => {\n              if (err) return done(err);\n\n              // Level 0 compression actually adds a few bytes due to headers.\n              assert.ok(compressed1.length > buf.length);\n              // Level 9 should not, of course.\n              assert.ok(compressed2.length < buf.length);\n              // Ensure they both decompress back properly.\n              assert.ok(decompressed1.equals(buf));\n              assert.ok(decompressed2.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"honors the `zlib{Deflate,Inflate}Options` option","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":274,"column":56,"index":14214},"line":274,"code":"    it('honors the `zlib{Deflate,Inflate}Options` option', done => {\n      const lev0 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 0,\n          chunkSize: 256\n        },\n        zlibInflateOptions: {\n          chunkSize: 2048\n        }\n      });\n      const lev9 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 9,\n          chunkSize: 128\n        },\n        zlibInflateOptions: {\n          chunkSize: 1024\n        }\n      });\n\n      // Note no context takeover so we can get a hold of the raw streams after\n      // we do the dance.\n      const extensionStr = 'permessage-deflate; server_max_window_bits=10; ' + 'client_max_window_bits=11';\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      lev0.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev9.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev0.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        lev0.decompress(compressed1, true, (err, decompressed1) => {\n          if (err) return done(err);\n          lev9.compress(buf, true, (err, compressed2) => {\n            if (err) return done(err);\n            lev9.decompress(compressed2, true, (err, decompressed2) => {\n              if (err) return done(err);\n              // Level 0 compression actually adds a few bytes due to headers.\n              assert.ok(compressed1.length > buf.length);\n              // Level 9 should not, of course.\n              assert.ok(compressed2.length < buf.length);\n              // Ensure they both decompress back properly.\n              assert.ok(decompressed1.equals(buf));\n              assert.ok(decompressed2.equals(buf));\n\n              // Assert options were set.\n              assert.ok(lev0._deflate._level === 0);\n              assert.ok(lev9._deflate._level === 9);\n              assert.ok(lev0._deflate._chunkSize === 256);\n              assert.ok(lev9._deflate._chunkSize === 128);\n              assert.ok(lev0._inflate._chunkSize === 2048);\n              assert.ok(lev9._inflate._chunkSize === 1024);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"doesn't use contex takeover if not allowed","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":329,"column":50,"index":16407},"line":329,"code":"    it(\"doesn't use contex takeover if not allowed\", done => {\n      const perMessageDeflate = new PerMessageDeflate({}, true);\n      const extensions = extension.parse('permessage-deflate;server_no_context_takeover');\n      const buf = Buffer.from('foofoo');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(compressed1, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          perMessageDeflate.compress(data, true, (err, compressed2) => {\n            if (err) return done(err);\n            assert.strictEqual(compressed2.length, compressed1.length);\n            perMessageDeflate.decompress(compressed2, true, (err, data) => {\n              if (err) return done(err);\n              assert.ok(data.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses contex takeover if allowed","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":351,"column":39,"index":17401},"line":351,"code":"    it('uses contex takeover if allowed', done => {\n      const perMessageDeflate = new PerMessageDeflate({}, true);\n      const extensions = extension.parse('permessage-deflate');\n      const buf = Buffer.from('foofoo');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(compressed1, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          perMessageDeflate.compress(data, true, (err, compressed2) => {\n            if (err) return done(err);\n            assert.ok(compressed2.length < compressed1.length);\n            perMessageDeflate.decompress(compressed2, true, (err, data) => {\n              if (err) return done(err);\n              assert.ok(data.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"calls the callback when an error occurs (inflate)","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":373,"column":57,"index":18378},"line":373,"code":"    it('calls the callback when an error occurs (inflate)', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const data = Buffer.from('something invalid');\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.decompress(data, true, err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'Z_DATA_ERROR');\n        assert.strictEqual(err.errno, -3);\n        done();\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"doesn't call the callback twice when `maxPayload` is exceeded","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":384,"column":69,"index":18836},"line":384,"code":"    it(\"doesn't call the callback twice when `maxPayload` is exceeded\", done => {\n      const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n      const buf = Buffer.from('A'.repeat(50));\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.message, 'Max payload size exceeded');\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the deflate stream is closed prematurely","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":397,"column":70,"index":19396},"line":397,"code":"    it('calls the callback if the deflate stream is closed prematurely', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from('A'.repeat(50));\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'The deflate stream was closed while data was being processed');\n        done();\n      });\n      process.nextTick(() => perMessageDeflate.cleanup());\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"recreates the inflate stream if it ends","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":408,"column":47,"index":19890},"line":408,"code":"    it('recreates the inflate stream if it ends', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; client_no_context_takeover; ' + 'server_no_context_takeover');\n      const buf = Buffer.from('33343236313533b7000000', 'hex');\n      const expected = Buffer.from('12345678');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.decompress(buf, true, (err, data) => {\n        assert.ok(data.equals(expected));\n        perMessageDeflate.decompress(buf, true, (err, data) => {\n          assert.ok(data.equals(expected));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"parses an unmasked text message","suites":["Receiver"],"updatePoint":{"line":13,"column":37,"index":371},"line":13,"code":"  it('parses an unmasked text message', done => {\n    const receiver = new Receiver();\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a close message","suites":["Receiver"],"updatePoint":{"line":22,"column":28,"index":670},"line":22,"code":"  it('parses a close message', done => {\n    const receiver = new Receiver();\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1005);\n      assert.strictEqual(data, EMPTY_BUFFER);\n      done();\n    });\n    receiver.write(Buffer.from('8800', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a close message spanning multiple writes","suites":["Receiver"],"updatePoint":{"line":31,"column":53,"index":979},"line":31,"code":"  it('parses a close message spanning multiple writes', done => {\n    const receiver = new Receiver();\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1000);\n      assert.deepStrictEqual(data, Buffer.from('DONE'));\n      done();\n    });\n    receiver.write(Buffer.from('8806', 'hex'));\n    receiver.write(Buffer.from('03e8444F4E45', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a masked text message","suites":["Receiver"],"updatePoint":{"line":41,"column":34,"index":1336},"line":41,"code":"  it('parses a masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from('5:::{\"name\":\"echo\"}'));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from('81933483a86801b992524fa1c60959e68a5216e6cb005ba1d5', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a masked text message longer than 125 B","suites":["Receiver"],"updatePoint":{"line":52,"column":52,"index":1737},"line":52,"code":"  it('parses a masked text message longer than 125 B', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(200));\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x01,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame.slice(0, 2));\n    setImmediate(() => receiver.write(frame.slice(2)));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a really long masked text message","suites":["Receiver"],"updatePoint":{"line":73,"column":46,"index":2327},"line":73,"code":"  it('parses a really long masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(64 * 1024));\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x01,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message","suites":["Receiver"],"updatePoint":{"line":93,"column":51,"index":2860},"line":93,"code":"  it('parses a 300 B fragmented masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: true\n    };\n    const frame1 = Buffer.concat(Sender.frame(fragment1, {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(fragment2, {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame1);\n    receiver.write(frame2);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a ping message","suites":["Receiver"],"updatePoint":{"line":123,"column":27,"index":3624},"line":123,"code":"  it('parses a ping message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('Hello');\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('ping', data => {\n      assert.deepStrictEqual(data, msg);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a ping message with no data","suites":["Receiver"],"updatePoint":{"line":142,"column":40,"index":4089},"line":142,"code":"  it('parses a ping message with no data', done => {\n    const receiver = new Receiver();\n    receiver.on('ping', data => {\n      assert.strictEqual(data, EMPTY_BUFFER);\n      done();\n    });\n    receiver.write(Buffer.from('8900', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message with a ping in the middle (1/2)","suites":["Receiver"],"updatePoint":{"line":150,"column":83,"index":4378},"line":150,"code":"  it('parses a 300 B fragmented masked text message with a ping in the middle (1/2)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const pingMessage = Buffer.from('Hello');\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: true\n    };\n    const frame1 = Buffer.concat(Sender.frame(fragment1, {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(pingMessage, {\n      fin: true,\n      opcode: 0x09,\n      ...options\n    }));\n    const frame3 = Buffer.concat(Sender.frame(fragment2, {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    let gotPing = false;\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      assert.ok(gotPing);\n      done();\n    });\n    receiver.on('ping', data => {\n      gotPing = true;\n      assert.ok(data.equals(pingMessage));\n    });\n    receiver.write(frame1);\n    receiver.write(frame2);\n    receiver.write(frame3);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message with a ping in the middle (2/2)","suites":["Receiver"],"updatePoint":{"line":193,"column":83,"index":5554},"line":193,"code":"  it('parses a 300 B fragmented masked text message with a ping in the middle (2/2)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const pingMessage = Buffer.from('Hello');\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: false\n    };\n    const frame1 = Buffer.concat(Sender.frame(Buffer.from(fragment1), {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(Buffer.from(pingMessage), {\n      fin: true,\n      opcode: 0x09,\n      ...options\n    }));\n    const frame3 = Buffer.concat(Sender.frame(Buffer.from(fragment2), {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    let chunks = [];\n    const splitBuffer = buf => {\n      const i = Math.floor(buf.length / 2);\n      return [buf.slice(0, i), buf.slice(i)];\n    };\n    chunks = chunks.concat(splitBuffer(frame1));\n    chunks = chunks.concat(splitBuffer(frame2));\n    chunks = chunks.concat(splitBuffer(frame3));\n    let gotPing = false;\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      assert.ok(gotPing);\n      done();\n    });\n    receiver.on('ping', data => {\n      gotPing = true;\n      assert.ok(data.equals(pingMessage));\n    });\n    for (let i = 0; i < chunks.length; ++i) {\n      receiver.write(chunks[i]);\n    }\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 100 B masked binary message","suites":["Receiver"],"updatePoint":{"line":244,"column":42,"index":7028},"line":244,"code":"  it('parses a 100 B masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(100);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 256 B masked binary message","suites":["Receiver"],"updatePoint":{"line":264,"column":42,"index":7540},"line":264,"code":"  it('parses a 256 B masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(256);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 200 KiB masked binary message","suites":["Receiver"],"updatePoint":{"line":284,"column":44,"index":8054},"line":284,"code":"  it('parses a 200 KiB masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 200 KiB unmasked binary message","suites":["Receiver"],"updatePoint":{"line":304,"column":46,"index":8577},"line":304,"code":"  it('parses a 200 KiB unmasked binary message', done => {\n    const receiver = new Receiver();\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: false,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a compressed message","suites":["Receiver"],"updatePoint":{"line":322,"column":33,"index":9060},"line":322,"code":"  it('parses a compressed message', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf = Buffer.from('Hello');\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, buf);\n      assert.ok(!isBinary);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a compressed and fragmented message","suites":["Receiver"],"updatePoint":{"line":342,"column":48,"index":9700},"line":342,"code":"  it('parses a compressed and fragmented message', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf1 = Buffer.from('foo');\n    const buf2 = Buffer.from('bar');\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.concat([buf1, buf2]));\n      assert.ok(!isBinary);\n      done();\n    });\n    perMessageDeflate.compress(buf1, false, (err, fragment1) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0x41, fragment1.length]));\n      receiver.write(fragment1);\n      perMessageDeflate.compress(buf2, true, (err, fragment2) => {\n        if (err) return done(err);\n        receiver.write(Buffer.from([0x80, fragment2.length]));\n        receiver.write(fragment2);\n      });\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a buffer with thousands of frames","suites":["Receiver"],"updatePoint":{"line":368,"column":46,"index":10625},"line":368,"code":"  it('parses a buffer with thousands of frames', done => {\n    const buf = Buffer.allocUnsafe(40000);\n    for (let i = 0; i < buf.length; i += 2) {\n      buf[i] = 0x81;\n      buf[i + 1] = 0x00;\n    }\n    const receiver = new Receiver();\n    let counter = 0;\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(data, EMPTY_BUFFER);\n      assert.ok(!isBinary);\n      if (++counter === 20000) done();\n    });\n    receiver.write(buf);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (unfragmented)","suites":["Receiver"],"updatePoint":{"line":383,"column":68,"index":11106},"line":383,"code":"  it('resets `totalPayloadLength` only on final frame (unfragmented)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (fragmented)","suites":["Receiver"],"updatePoint":{"line":396,"column":66,"index":11587},"line":396,"code":"  it('resets `totalPayloadLength` only on final frame (fragmented)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('01024865', 'hex'));\n    assert.strictEqual(receiver._totalPayloadLength, 2);\n    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (fragmented + ping)","suites":["Receiver"],"updatePoint":{"line":411,"column":73,"index":12180},"line":411,"code":"  it('resets `totalPayloadLength` only on final frame (fragmented + ping)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    let data;\n    receiver.on('ping', buf => {\n      assert.strictEqual(receiver._totalPayloadLength, 2);\n      data = buf;\n    });\n    receiver.on('message', (buf, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, EMPTY_BUFFER);\n      assert.deepStrictEqual(buf, Buffer.from('Hello'));\n      assert.ok(isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('02024865', 'hex'));\n    receiver.write(Buffer.from('8900', 'hex'));\n    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"ignores any data after a close frame","suites":["Receiver"],"updatePoint":{"line":432,"column":42,"index":12912},"line":432,"code":"  it('ignores any data after a close frame', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const results = [];\n    const push = results.push.bind(results);\n    receiver.on('conclude', push).on('message', push);\n    receiver.on('finish', () => {\n      assert.deepStrictEqual(results, [EMPTY_BUFFER, false, 1005, EMPTY_BUFFER]);\n      done();\n    });\n    receiver.write(Buffer.from([0xc1, 0x01, 0x00]));\n    receiver.write(Buffer.from([0x88, 0x00]));\n    receiver.write(Buffer.from([0x81, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV1 is on and permessage-deflate is disabled","suites":["Receiver"],"updatePoint":{"line":451,"column":69,"index":13620},"line":451,"code":"  it('emits an error if RSV1 is on and permessage-deflate is disabled', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xc2, 0x80, 0x00, 0x00, 0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV1 is on and opcode is 0","suites":["Receiver"],"updatePoint":{"line":462,"column":50,"index":14096},"line":462,"code":"  it('emits an error if RSV1 is on and opcode is 0', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x40, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV2 is on","suites":["Receiver"],"updatePoint":{"line":479,"column":34,"index":14706},"line":479,"code":"  it('emits an error if RSV2 is on', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV2 and RSV3 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xa2, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV3 is on","suites":["Receiver"],"updatePoint":{"line":490,"column":34,"index":15153},"line":490,"code":"  it('emits an error if RSV3 is on', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV2 and RSV3 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x92, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the first frame in a fragmented message has opcode 0","suites":["Receiver"],"updatePoint":{"line":501,"column":76,"index":15642},"line":501,"code":"  it('emits an error if the first frame in a fragmented message has opcode 0', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 0');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has opcode 1 in the middle of a fragmented message","suites":["Receiver"],"updatePoint":{"line":512,"column":82,"index":16122},"line":512,"code":"  it('emits an error if a frame has opcode 1 in the middle of a fragmented message', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 1');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x01, 0x00]));\n    receiver.write(Buffer.from([0x01, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has opcode 2 in the middle of a fragmented message","suites":["Receiver"],"updatePoint":{"line":524,"column":82,"index":16649},"line":524,"code":"  it('emits an error if a frame has opcode 2 in the middle of a fragmented message', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 2');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x01, 0x00]));\n    receiver.write(Buffer.from([0x02, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the FIN bit off","suites":["Receiver"],"updatePoint":{"line":536,"column":59,"index":17153},"line":536,"code":"  it('emits an error if a control frame has the FIN bit off', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_FIN');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: FIN must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x09, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the RSV1 bit on","suites":["Receiver"],"updatePoint":{"line":547,"column":59,"index":17607},"line":547,"code":"  it('emits an error if a control frame has the RSV1 bit on', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xc9, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the FIN bit off","suites":["Receiver"],"updatePoint":{"line":564,"column":59,"index":18242},"line":564,"code":"  it('emits an error if a control frame has the FIN bit off', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_FIN');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: FIN must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x09, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has the MASK bit off (server mode)","suites":["Receiver"],"updatePoint":{"line":575,"column":66,"index":18703},"line":575,"code":"  it('emits an error if a frame has the MASK bit off (server mode)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_MASK');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x02, 0x68, 0x69]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has the MASK bit on (client mode)","suites":["Receiver"],"updatePoint":{"line":588,"column":65,"index":19205},"line":588,"code":"  it('emits an error if a frame has the MASK bit on (client mode)', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_MASK');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x82, 0x56, 0x3a, 0xac, 0x80, 0x3e, 0x53]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has a payload bigger than 125 B","suites":["Receiver"],"updatePoint":{"line":599,"column":71,"index":19713},"line":599,"code":"  it('emits an error if a control frame has a payload bigger than 125 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid payload length 126');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x89, 0x7e]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a data frame has a payload bigger than 2^53 - 1 B","suites":["Receiver"],"updatePoint":{"line":610,"column":73,"index":20210},"line":610,"code":"  it('emits an error if a data frame has a payload bigger than 2^53 - 1 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Unsupported WebSocket frame: payload length > 2^53 - 1');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    receiver.write(Buffer.from([0x82, 0x7f]));\n    setImmediate(() => receiver.write(Buffer.from([0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a text frame contains invalid UTF-8 data (1/2)","suites":["Receiver"],"updatePoint":{"line":622,"column":70,"index":20811},"line":622,"code":"  it('emits an error if a text frame contains invalid UTF-8 data (1/2)', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x04, 0xce, 0xba, 0xe1, 0xbd]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a text frame contains invalid UTF-8 data (2/2)","suites":["Receiver"],"updatePoint":{"line":633,"column":70,"index":21302},"line":633,"code":"  it('emits an error if a text frame contains invalid UTF-8 data (2/2)', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf = Buffer.from([0xce, 0xba, 0xe1, 0xbd]);\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame has a payload of 1 B","suites":["Receiver"],"updatePoint":{"line":655,"column":58,"index":22123},"line":655,"code":"  it('emits an error if a close frame has a payload of 1 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid payload length 1');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x01]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame contains an invalid close code","suites":["Receiver"],"updatePoint":{"line":666,"column":68,"index":22613},"line":666,"code":"  it('emits an error if a close frame contains an invalid close code', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CLOSE_CODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid status code 0');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x02, 0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame contains invalid UTF-8 data","suites":["Receiver"],"updatePoint":{"line":677,"column":65,"index":23097},"line":677,"code":"  it('emits an error if a close frame contains invalid UTF-8 data', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x06, 0x03, 0xef, 0xce, 0xba, 0xe1, 0xbd]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame payload length is bigger than `maxPayload`","suites":["Receiver"],"updatePoint":{"line":688,"column":74,"index":23604},"line":688,"code":"  it('emits an error if a frame payload length is bigger than `maxPayload`', done => {\n    const receiver = new Receiver({\n      isServer: true,\n      maxPayload: 20 * 1024\n    });\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the message length exceeds `maxPayload`","suites":["Receiver"],"updatePoint":{"line":711,"column":63,"index":24325},"line":711,"code":"  it('emits an error if the message length exceeds `maxPayload`', done => {\n    const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      },\n      isServer: false,\n      maxPayload: 25\n    });\n    const buf = Buffer.from('A'.repeat(50));\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the sum of fragment lengths exceeds `maxPayload`","suites":["Receiver"],"updatePoint":{"line":735,"column":72,"index":25205},"line":735,"code":"  it('emits an error if the sum of fragment lengths exceeds `maxPayload`', done => {\n    const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      },\n      isServer: false,\n      maxPayload: 25\n    });\n    const buf = Buffer.from('A'.repeat(15));\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    perMessageDeflate.compress(buf, false, (err, fragment1) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0x41, fragment1.length]));\n      receiver.write(fragment1);\n      perMessageDeflate.compress(buf, true, (err, fragment2) => {\n        if (err) return done(err);\n        receiver.write(Buffer.from([0x80, fragment2.length]));\n        receiver.write(fragment2);\n      });\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'nodebuffer' binary type","suites":["Receiver"],"updatePoint":{"line":764,"column":41,"index":26279},"line":764,"code":"  it(\"honors the 'nodebuffer' binary type\", done => {\n    const receiver = new Receiver();\n    const frags = [crypto.randomBytes(7321), crypto.randomBytes(137), crypto.randomBytes(285787), crypto.randomBytes(3)];\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.concat(frags));\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'arraybuffer' binary type","suites":["Receiver"],"updatePoint":{"line":782,"column":42,"index":26904},"line":782,"code":"  it(\"honors the 'arraybuffer' binary type\", done => {\n    const receiver = new Receiver({\n      binaryType: 'arraybuffer'\n    });\n    const frags = [crypto.randomBytes(19221), crypto.randomBytes(954), crypto.randomBytes(623987)];\n    receiver.on('message', (data, isBinary) => {\n      assert.ok(data instanceof ArrayBuffer);\n      assert.deepStrictEqual(Buffer.from(data), Buffer.concat(frags));\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'fragments' binary type","suites":["Receiver"],"updatePoint":{"line":803,"column":40,"index":27603},"line":803,"code":"  it(\"honors the 'fragments' binary type\", done => {\n    const receiver = new Receiver({\n      binaryType: 'fragments'\n    });\n    const frags = [crypto.randomBytes(17), crypto.randomBytes(419872), crypto.randomBytes(83), crypto.randomBytes(9928), crypto.randomBytes(1)];\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, frags);\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the `skipUTF8Validation` option (1/2)","suites":["Receiver"],"updatePoint":{"line":823,"column":50,"index":28281},"line":823,"code":"  it('honors the `skipUTF8Validation` option (1/2)', done => {\n    const receiver = new Receiver({\n      skipUTF8Validation: true\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from([0xf8]));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x01, 0xf8]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the `skipUTF8Validation` option (2/2)","suites":["Receiver"],"updatePoint":{"line":834,"column":50,"index":28634},"line":834,"code":"  it('honors the `skipUTF8Validation` option (2/2)', done => {\n    const receiver = new Receiver({\n      skipUTF8Validation: true\n    });\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1000);\n      assert.deepStrictEqual(data, Buffer.from([0xf8]));\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x03, 0x03, 0xe8, 0xf8]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"does not mutate the input buffer if data is `readOnly`","suites":["Sender",".frame"],"updatePoint":{"line":24,"column":62,"index":565},"line":24,"code":"    it('does not mutate the input buffer if data is `readOnly`', () => {\n      const buf = Buffer.from([1, 2, 3, 4, 5]);\n      Sender.frame(buf, {\n        readOnly: true,\n        rsv1: false,\n        mask: true,\n        opcode: 2,\n        fin: true\n      });\n      assert.ok(buf.equals(Buffer.from([1, 2, 3, 4, 5])));\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"honors the `rsv1` option","suites":["Sender",".frame"],"updatePoint":{"line":35,"column":32,"index":861},"line":35,"code":"    it('honors the `rsv1` option', () => {\n      const list = Sender.frame(EMPTY_BUFFER, {\n        readOnly: false,\n        mask: false,\n        rsv1: true,\n        opcode: 1,\n        fin: true\n      });\n      assert.strictEqual(list[0][0] & 0x40, 0x40);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"accepts a string as first argument","suites":["Sender",".frame"],"updatePoint":{"line":45,"column":42,"index":1134},"line":45,"code":"    it('accepts a string as first argument', () => {\n      const list = Sender.frame('€', {\n        readOnly: false,\n        rsv1: false,\n        mask: false,\n        opcode: 1,\n        fin: true\n      });\n      assert.deepStrictEqual(list[0], Buffer.from('8103', 'hex'));\n      assert.deepStrictEqual(list[1], Buffer.from('e282ac', 'hex'));\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses data if compress option is enabled","suites":["Sender","#send"],"updatePoint":{"line":58,"column":53,"index":1529},"line":58,"code":"    it('compresses data if compress option is enabled', done => {\n      const chunks = [];\n      const perMessageDeflate = new PerMessageDeflate();\n      const mockSocket = new MockSocket({\n        write: chunk => {\n          chunks.push(chunk);\n          if (chunks.length !== 6) return;\n          assert.strictEqual(chunks[0].length, 2);\n          assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n          assert.strictEqual(chunks[2].length, 2);\n          assert.strictEqual(chunks[2][0] & 0x40, 0x40);\n          assert.strictEqual(chunks[4].length, 2);\n          assert.strictEqual(chunks[4][0] & 0x40, 0x40);\n          done();\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const options = {\n        compress: true,\n        fin: true\n      };\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send(array.buffer, options);\n      sender.send(array, options);\n      sender.send('hi', options);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"honors the compression threshold","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":88,"column":42,"index":2613},"line":88,"code":"      it('honors the compression threshold', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate();\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 2) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.notStrictEqual(chunk[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1], 'hi');\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('hi', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses all fragments of a fragmented message","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":111,"column":58,"index":3494},"line":111,"code":"      it('compresses all fragments of a fragmented message', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 3\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 9);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 4);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('123', {\n          compress: true,\n          fin: false\n        });\n        sender.send('12', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"does not compress any fragments of a fragmented message","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":143,"column":65,"index":4671},"line":143,"code":"      it('does not compress any fragments of a fragmented message', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 3\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[1].length, 2);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 3);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('12', {\n          compress: true,\n          fin: false\n        });\n        sender.send('123', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses empty buffer as first fragment","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":175,"column":51,"index":5834},"line":175,"code":"      it('compresses empty buffer as first fragment', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 0\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 5);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 6);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send(Buffer.alloc(0), {\n          compress: true,\n          fin: false\n        });\n        sender.send('data', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses empty buffer as last fragment","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":207,"column":50,"index":7008},"line":207,"code":"      it('compresses empty buffer as last fragment', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 0\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 10);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 1);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('data', {\n          compress: true,\n          fin: false\n        });\n        sender.send(Buffer.alloc(0), {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"works with multiple types of data","suites":["Sender","#ping"],"updatePoint":{"line":242,"column":41,"index":8216},"line":242,"code":"    it('works with multiple types of data', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: data => {\n          if (++count < 3) return;\n          if (count % 2) {\n            assert.ok(data.equals(Buffer.from([0x89, 0x02])));\n          } else if (count < 8) {\n            assert.ok(data.equals(Buffer.from([0x68, 0x69])));\n          } else {\n            assert.strictEqual(data, 'hi');\n            done();\n          }\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.ping(array.buffer, false);\n      sender.ping(array, false);\n      sender.ping('hi', false);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"works with multiple types of data","suites":["Sender","#pong"],"updatePoint":{"line":273,"column":41,"index":9170},"line":273,"code":"    it('works with multiple types of data', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: data => {\n          if (++count < 3) return;\n          if (count % 2) {\n            assert.ok(data.equals(Buffer.from([0x8a, 0x02])));\n          } else if (count < 8) {\n            assert.ok(data.equals(Buffer.from([0x68, 0x69])));\n          } else {\n            assert.strictEqual(data, 'hi');\n            done();\n          }\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.pong(array.buffer, false);\n      sender.pong(array, false);\n      sender.pong('hi', false);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the first argument is invalid","suites":["Sender","#close"],"updatePoint":{"line":304,"column":56,"index":10140},"line":304,"code":"    it('throws an error if the first argument is invalid', () => {\n      const mockSocket = new MockSocket();\n      const sender = new Sender(mockSocket);\n      assert.throws(() => sender.close('error'), /^TypeError: First argument must be a valid error code number$/);\n      assert.throws(() => sender.close(1004), /^TypeError: First argument must be a valid error code number$/);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the message is greater than 123 bytes","suites":["Sender","#close"],"updatePoint":{"line":310,"column":64,"index":10538},"line":310,"code":"    it('throws an error if the message is greater than 123 bytes', () => {\n      const mockSocket = new MockSocket();\n      const sender = new Sender(mockSocket);\n      assert.throws(() => sender.close(1000, 'a'.repeat(124)), /^RangeError: The message must not be greater than 123 bytes$/);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"should consume all data before closing","suites":["Sender","#close"],"updatePoint":{"line":315,"column":46,"index":10819},"line":315,"code":"    it('should consume all data before closing', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: (data, cb) => {\n          count++;\n          if (cb) cb();\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.send('bar', {\n        compress: true,\n        fin: true\n      });\n      sender.send('baz', {\n        compress: true,\n        fin: true\n      });\n      sender.close(1000, undefined, false, () => {\n        assert.strictEqual(count, 8);\n        done();\n      });\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"parses a single subprotocol","suites":["subprotocol","parse"],"updatePoint":{"line":9,"column":35,"index":196},"line":9,"code":"    it('parses a single subprotocol', () => {\n      assert.deepStrictEqual(parse('foo'), new Set(['foo']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"parses multiple subprotocols","suites":["subprotocol","parse"],"updatePoint":{"line":12,"column":36,"index":313},"line":12,"code":"    it('parses multiple subprotocols', () => {\n      assert.deepStrictEqual(parse('foo,bar,baz'), new Set(['foo', 'bar', 'baz']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"ignores the optional white spaces","suites":["subprotocol","parse"],"updatePoint":{"line":15,"column":41,"index":457},"line":15,"code":"    it('ignores the optional white spaces', () => {\n      const header = 'foo , bar\\t, \\tbaz\\t ,  qux\\t\\t,norf';\n      assert.deepStrictEqual(parse(header), new Set(['foo', 'bar', 'baz', 'qux', 'norf']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is empty","suites":["subprotocol","parse"],"updatePoint":{"line":19,"column":49,"index":678},"line":19,"code":"    it('throws an error if a subprotocol is empty', () => {\n      [[',', 0], ['foo,,', 4], ['foo,  ,', 6]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is duplicated","suites":["subprotocol","parse"],"updatePoint":{"line":24,"column":54,"index":951},"line":24,"code":"    it('throws an error if a subprotocol is duplicated', () => {\n      ['foo,foo,bar', 'foo,bar,foo'].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: The \"foo\" subprotocol is duplicated$/);\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a white space is misplaced","suites":["subprotocol","parse"],"updatePoint":{"line":29,"column":53,"index":1188},"line":29,"code":"    it('throws an error if a white space is misplaced', () => {\n      [['f oo', 2], [' foo', 0]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol contains invalid characters","suites":["subprotocol","parse"],"updatePoint":{"line":34,"column":68,"index":1461},"line":34,"code":"    it('throws an error if a subprotocol contains invalid characters', () => {\n      [['f@o', 1], ['f\\\\oo', 1], ['foo,b@r', 5]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the header value ends prematurely","suites":["subprotocol","parse"],"updatePoint":{"line":39,"column":60,"index":1742},"line":39,"code":"    it('throws an error if the header value ends prematurely', () => {\n      ['foo ', 'foo, ', 'foo,bar ', 'foo,bar,'].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: Unexpected end of input$/);\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"returns false if it finds invalid bytes","suites":["extension","isValidUTF8"],"updatePoint":{"line":9,"column":47,"index":217},"line":9,"code":"    it('returns false if it finds invalid bytes', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf8])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for overlong encodings","suites":["extension","isValidUTF8"],"updatePoint":{"line":12,"column":44,"index":347},"line":12,"code":"    it('returns false for overlong encodings', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xc0, 0xa0])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xe0, 0x80, 0xa0])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf0, 0x80, 0x80, 0xa0])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for code points in the range U+D800 - U+DFFF","suites":["extension","isValidUTF8"],"updatePoint":{"line":17,"column":66,"index":669},"line":17,"code":"    it('returns false for code points in the range U+D800 - U+DFFF', () => {\n      for (let i = 0xa0; i < 0xc0; i++) {\n        for (let j = 0x80; j < 0xc0; j++) {\n          assert.strictEqual(isValidUTF8(Buffer.from([0xed, i, j])), false);\n        }\n      }\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for code points greater than U+10FFFF","suites":["extension","isValidUTF8"],"updatePoint":{"line":24,"column":59,"index":928},"line":24,"code":"    it('returns false for code points greater than U+10FFFF', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf4, 0x90, 0x80, 0x80])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf5, 0x80, 0x80, 0x80])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns true for a well-formed UTF-8 byte sequence","suites":["extension","isValidUTF8"],"updatePoint":{"line":28,"column":58,"index":1175},"line":28,"code":"    it('returns true for a well-formed UTF-8 byte sequence', () => {\n      // prettier-ignore\n      const buf = Buffer.from([0xe2, 0x82, 0xAC,\n      // €\n      0xf0, 0x90, 0x8c, 0x88,\n      // 𐍈\n      0x24 // $\n      ]);\n\n      assert.strictEqual(isValidUTF8(buf), true);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"throws an error if no option object is passed","suites":["WebSocketServer","#ctor"],"updatePoint":{"line":20,"column":53,"index":568},"line":20,"code":"    it('throws an error if no option object is passed', () => {\n      assert.throws(() => new WebSocket.Server(), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if required options are not specified","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":24,"column":63,"index":848},"line":24,"code":"      it('throws an error if required options are not specified', () => {\n        assert.throws(() => new WebSocket.Server({}), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if mutually exclusive options are specified","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":27,"column":69,"index":1108},"line":27,"code":"      it('throws an error if mutually exclusive options are specified', () => {\n        const server = http.createServer();\n        const variants = [{\n          port: 0,\n          noServer: true,\n          server\n        }, {\n          port: 0,\n          noServer: true\n        }, {\n          port: 0,\n          server\n        }, {\n          noServer: true,\n          server\n        }];\n        for (const options of variants) {\n          assert.throws(() => new WebSocket.Server(options), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n        }\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"exposes options passed to constructor","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":47,"column":47,"index":1713},"line":47,"code":"      it('exposes options passed to constructor', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          assert.strictEqual(wss.options.port, 0);\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"accepts the `maxPayload` option","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":55,"column":41,"index":1947},"line":55,"code":"      it('accepts the `maxPayload` option', done => {\n        const maxPayload = 20480;\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          maxPayload,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws._receiver._maxPayload, maxPayload);\n          assert.strictEqual(ws._receiver._extensions['permessage-deflate']._maxPayload, maxPayload);\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"honors the `WebSocket` option","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":71,"column":39,"index":2549},"line":71,"code":"      it('honors the `WebSocket` option', done => {\n        class CustomWebSocket extends WebSocket.WebSocket {\n          get foo() {\n            return 'foo';\n          }\n        }\n        const wss = new WebSocket.Server({\n          port: 0,\n          WebSocket: CustomWebSocket\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', ws => {\n          assert.ok(ws instanceof CustomWebSocket);\n          assert.strictEqual(ws.foo, 'foo');\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits an error if http server bind fails","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":91,"column":48,"index":3172},"line":91,"code":"    it('emits an error if http server bind fails', done => {\n      const wss1 = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const wss2 = new WebSocket.Server({\n          port: wss1.address().port\n        });\n        wss2.on('error', () => wss1.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"starts a server on a given port","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":101,"column":39,"index":3459},"line":101,"code":"    it('starts a server on a given port', done => {\n      const port = 1337;\n      const wss = new WebSocket.Server({\n        port\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', () => wss.close(done));\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"binds the server on any IPv6 address when available","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":111,"column":59,"index":3789},"line":111,"code":"    it('binds the server on any IPv6 address when available', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        assert.strictEqual(wss._server.address().address, '::');\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses a precreated http server","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":119,"column":37,"index":4021},"line":119,"code":"    it('uses a precreated http server', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          server\n        });\n        wss.on('connection', () => {\n          server.close(done);\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"426s for non-Upgrade requests","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":132,"column":37,"index":4423},"line":132,"code":"    it('426s for non-Upgrade requests', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        http.get(`http://localhost:${wss.address().port}`, res => {\n          let body = '';\n          assert.strictEqual(res.statusCode, 426);\n          res.on('data', chunk => {\n            body += chunk;\n          });\n          res.on('end', () => {\n            assert.strictEqual(body, http.STATUS_CODES[426]);\n            wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses a precreated http server listening on IPC","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":149,"column":54,"index":4952},"line":149,"code":"    it('uses a precreated http server listening on IPC', done => {\n      const randomString = crypto.randomBytes(16).toString('hex');\n      const ipcPath = process.platform === 'win32' ? `\\\\\\\\.\\\\pipe\\\\ws-pipe-${randomString}` : path.join(os.tmpdir(), `ws-${randomString}.sock`);\n      const server = http.createServer();\n      server.listen(ipcPath, () => {\n        const wss = new WebSocket.Server({\n          server\n        });\n        wss.on('connection', (ws, req) => {\n          if (wss.clients.size === 1) {\n            assert.strictEqual(req.url, '/foo?bar=bar');\n          } else {\n            assert.strictEqual(req.url, '/');\n            for (const client of wss.clients) {\n              client.close();\n            }\n            server.close(done);\n          }\n        });\n        const ws = new WebSocket(`ws+unix:${ipcPath}:/foo?bar=bar`);\n        ws.on('open', () => new WebSocket(`ws+unix:${ipcPath}`));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns the address of the server","suites":["WebSocketServer","#address"],"updatePoint":{"line":174,"column":41,"index":5913},"line":174,"code":"    it('returns the address of the server', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const addr = wss.address();\n        assert.deepStrictEqual(addr, wss._server.address());\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error when operating in \"noServer\" mode","suites":["WebSocketServer","#address"],"updatePoint":{"line":183,"column":57,"index":6197},"line":183,"code":"    it('throws an error when operating in \"noServer\" mode', () => {\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      assert.throws(() => {\n        wss.address();\n      }, /^Error: The server is operating in \"noServer\" mode$/);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns `null` if called after close","suites":["WebSocketServer","#address"],"updatePoint":{"line":191,"column":44,"index":6450},"line":191,"code":"    it('returns `null` if called after close', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss.address(), null);\n          done();\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"does not throw if called multiple times","suites":["WebSocketServer","#close"],"updatePoint":{"line":203,"column":47,"index":6744},"line":203,"code":"    it('does not throw if called multiple times', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.on('close', done);\n        wss.close();\n        wss.close();\n        wss.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"doesn't close a precreated server","suites":["WebSocketServer","#close"],"updatePoint":{"line":213,"column":41,"index":6984},"line":213,"code":"    it(\"doesn't close a precreated server\", done => {\n      const server = http.createServer();\n      const realClose = server.close;\n      server.close = () => {\n        done(new Error('Must not close pre-created server'));\n      };\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', () => {\n        wss.close();\n        server.close = realClose;\n        server.close(done);\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"invokes the callback in noServer mode","suites":["WebSocketServer","#close"],"updatePoint":{"line":232,"column":45,"index":7575},"line":232,"code":"    it('invokes the callback in noServer mode', done => {\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      wss.close(done);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"cleans event handlers on precreated server","suites":["WebSocketServer","#close"],"updatePoint":{"line":238,"column":50,"index":7743},"line":238,"code":"    it('cleans event handlers on precreated server', done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        wss.close(() => {\n          assert.strictEqual(server.listenerCount('listening'), 0);\n          assert.strictEqual(server.listenerCount('upgrade'), 0);\n          assert.strictEqual(server.listenerCount('error'), 0);\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event after the server closes","suites":["WebSocketServer","#close"],"updatePoint":{"line":252,"column":55,"index":8234},"line":252,"code":"    it(\"emits the 'close' event after the server closes\", done => {\n      let serverCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        net.createConnection({\n          port: wss.address().port\n        });\n      });\n      wss._server.on('connection', socket => {\n        wss.close();\n\n        //\n        // The server is closing. Ensure this does not emit a `'close'`\n        // event before the server is actually closed.\n        //\n        wss.close();\n        process.nextTick(() => {\n          socket.end();\n        });\n      });\n      wss._server.on('close', () => {\n        serverCloseEventEmitted = true;\n      });\n      wss.on('close', () => {\n        assert.ok(serverCloseEventEmitted);\n        done();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event if client tracking is disabled","suites":["WebSocketServer","#close"],"updatePoint":{"line":281,"column":62,"index":9028},"line":281,"code":"    it(\"emits the 'close' event if client tracking is disabled\", done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        clientTracking: false\n      });\n      wss.on('close', done);\n      wss.close();\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the server is already closed","suites":["WebSocketServer","#close"],"updatePoint":{"line":289,"column":58,"index":9260},"line":289,"code":"    it('calls the callback if the server is already closed', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss._state, 2);\n          wss.close(err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'The server is not running');\n            done();\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event if the server is already closed","suites":["WebSocketServer","#close"],"updatePoint":{"line":303,"column":63,"index":9693},"line":303,"code":"    it(\"emits the 'close' event if the server is already closed\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss._state, 2);\n          wss.on('close', done);\n          wss.close();\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns a list of connected clients","suites":["WebSocketServer","#clients"],"updatePoint":{"line":316,"column":43,"index":10017},"line":316,"code":"    it('returns a list of connected clients', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        assert.strictEqual(wss.clients.size, 0);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', () => {\n        assert.strictEqual(wss.clients.size, 1);\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can be disabled","suites":["WebSocketServer","#clients"],"updatePoint":{"line":329,"column":23,"index":10420},"line":329,"code":"    it('can be disabled', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        clientTracking: false\n      }, () => {\n        assert.strictEqual(wss.clients, undefined);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close());\n      });\n      wss.on('connection', ws => {\n        assert.strictEqual(wss.clients, undefined);\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is updated when client terminates the connection","suites":["WebSocketServer","#clients"],"updatePoint":{"line":343,"column":56,"index":10923},"line":343,"code":"    it('is updated when client terminates the connection', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.terminate());\n      });\n      wss.on('connection', ws => {\n        ws.on('close', () => {\n          assert.strictEqual(wss.clients.size, 0);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is updated when client closes the connection","suites":["WebSocketServer","#clients"],"updatePoint":{"line":357,"column":52,"index":11365},"line":357,"code":"    it('is updated when client closes the connection', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close());\n      });\n      wss.on('connection', ws => {\n        ws.on('close', () => {\n          assert.strictEqual(wss.clients.size, 0);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns true when the path matches","suites":["WebSocketServer","#shouldHandle"],"updatePoint":{"line":373,"column":42,"index":11835},"line":373,"code":"    it('returns true when the path matches', () => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      assert.strictEqual(wss.shouldHandle({\n        url: '/foo'\n      }), true);\n      assert.strictEqual(wss.shouldHandle({\n        url: '/foo?bar=baz'\n      }), true);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns false when the path doesn't match","suites":["WebSocketServer","#shouldHandle"],"updatePoint":{"line":385,"column":49,"index":12169},"line":385,"code":"    it(\"returns false when the path doesn't match\", () => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      assert.strictEqual(wss.shouldHandle({\n        url: '/bar'\n      }), false);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can be used for a pre-existing server","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":396,"column":45,"index":12454},"line":396,"code":"    it('can be used for a pre-existing server', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          noServer: true\n        });\n        server.on('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.send('hello');\n            ws.close();\n          });\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('hello'));\n          assert.ok(!isBinary);\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"closes the connection when path doesn't match","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":416,"column":53,"index":13146},"line":416,"code":"    it(\"closes the connection when path doesn't match\", done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        path: '/ws'\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"closes the connection when protocol version is Hixie-76","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":436,"column":63,"index":13743},"line":436,"code":"    it('closes the connection when protocol version is Hixie-76', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'WebSocket',\n            'Sec-WebSocket-Key1': '4 @1  46546xW%0l 1 5',\n            'Sec-WebSocket-Key2': '12998 5 Y3 1  .P00',\n            'Sec-WebSocket-Protocol': 'sample'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if called twice with the same socket","suites":["WebSocketServer","#completeUpgrade"],"updatePoint":{"line":465,"column":60,"index":14693},"line":465,"code":"    it('throws an error if called twice with the same socket', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          noServer: true\n        });\n        server.on('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.close();\n          });\n          assert.throws(() => wss.handleUpgrade(req, socket, head, NOOP), err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'server.handleUpgrade() was called more than once with the ' + 'same socket, possibly due to a misconfiguration');\n            return true;\n          });\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', () => {\n          ws.on('close', () => {\n            server.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the HTTP method is not GET","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":491,"column":43,"index":15655},"line":491,"code":"    it('fails if the HTTP method is not GET', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.request({\n          method: 'POST',\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 405);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid HTTP method');\n            wss.close(done);\n          });\n        });\n        req.end();\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Upgrade header field value is not \"websocket\"","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":520,"column":66,"index":16532},"line":520,"code":"    it('fails if the Upgrade header field value is not \"websocket\"', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'foo'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid Upgrade header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Key header is invalid (1/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":547,"column":62,"index":17353},"line":547,"code":"    it('fails if the Sec-WebSocket-Key header is invalid (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Key header is invalid (2/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":574,"column":62,"index":18201},"line":574,"code":"    it('fails if the Sec-WebSocket-Key header is invalid (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'P5l8BJcZwRc='\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Version header is invalid (1/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":602,"column":66,"index":19102},"line":602,"code":"    it('fails if the Sec-WebSocket-Version header is invalid (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ=='\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Version header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Version header is invalid (2/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":630,"column":66,"index":20019},"line":630,"code":"    it('fails if the Sec-WebSocket-Version header is invalid (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 12\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Version header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails is the Sec-WebSocket-Protocol header is invalid","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":659,"column":61,"index":20972},"line":659,"code":"    it('fails is the Sec-WebSocket-Protocol header is invalid', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Protocol': 'foo;bar'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid Sec-WebSocket-Protocol header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":689,"column":63,"index":21966},"line":689,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Extensions': 'permessage-deflate; server_max_window_bits=foo'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid or unacceptable Sec-WebSocket-Extensions header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'wsClientError' event","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":720,"column":39,"index":23028},"line":720,"code":"    it(\"emits the 'wsClientError' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.request({\n          method: 'POST',\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          wss.close(done);\n        });\n        req.end();\n      });\n      wss.on('wsClientError', (err, socket, request) => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid HTTP method');\n        assert.ok(request instanceof http.IncomingMessage);\n        assert.strictEqual(request.method, 'POST');\n        socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the WebSocket server is closing or closed","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":749,"column":58,"index":23990},"line":749,"code":"    it('fails if the WebSocket server is closing or closed', done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      server.on('upgrade', (req, socket, head) => {\n        wss.close();\n        wss.handleUpgrade(req, socket, head, () => {\n          done(new Error('Unexpected callback invocation'));\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('unexpected-response', (req, res) => {\n          assert.strictEqual(res.statusCode, 503);\n          res.resume();\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"handles unsupported extensions","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":769,"column":38,"index":24662},"line":769,"code":"    it('handles unsupported extensions', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Extensions': 'foo; bar'\n          }\n        });\n        req.on('upgrade', (res, socket, head) => {\n          if (head.length) socket.unshift(head);\n          socket.once('data', chunk => {\n            assert.strictEqual(chunk[0], 0x88);\n            socket.destroy();\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        assert.strictEqual(ws.extensions, '');\n        ws.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client synchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":799,"column":41,"index":25600},"line":799,"code":"      it('can reject client synchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: () => false,\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 401);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can accept client synchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":822,"column":41,"index":26335},"line":822,"code":"      it('can accept client synchronously', done => {\n        const server = https.createServer({\n          cert: fs.readFileSync('test/fixtures/certificate.pem'),\n          key: fs.readFileSync('test/fixtures/key.pem')\n        });\n        const wss = new WebSocket.Server({\n          verifyClient: info => {\n            assert.strictEqual(info.origin, 'https://example.com');\n            assert.strictEqual(info.req.headers.foo, 'bar');\n            assert.ok(info.secure, true);\n            return true;\n          },\n          server\n        });\n        wss.on('connection', () => {\n          server.close(done);\n        });\n        server.listen(0, () => {\n          const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n            headers: {\n              Origin: 'https://example.com',\n              foo: 'bar'\n            },\n            rejectUnauthorized: false\n          });\n          ws.on('open', ws.close);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can accept client asynchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":850,"column":42,"index":27293},"line":850,"code":"      it('can accept client asynchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (o, cb) => process.nextTick(cb, true),\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', () => wss.close(done));\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":860,"column":42,"index":27677},"line":860,"code":"      it('can reject client asynchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => process.nextTick(cb, false),\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 401);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously w/ status code","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":883,"column":57,"index":28458},"line":883,"code":"      it('can reject client asynchronously w/ status code', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => process.nextTick(cb, false, 404),\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 404);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously w/ custom headers","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":906,"column":60,"index":29247},"line":906,"code":"      it('can reject client asynchronously w/ custom headers', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => {\n            process.nextTick(cb, false, 503, '', {\n              'Retry-After': 120\n            });\n          },\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 503);\n            assert.strictEqual(res.headers['retry-after'], '120');\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"doesn't emit the 'connection' event if socket is closed prematurely","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":935,"column":75,"index":30207},"line":935,"code":"    it(\"doesn't emit the 'connection' event if socket is closed prematurely\", done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          verifyClient: ({\n            req: {\n              socket\n            }\n          }, cb) => {\n            assert.strictEqual(socket.readable, true);\n            assert.strictEqual(socket.writable, true);\n            socket.on('end', () => {\n              assert.strictEqual(socket.readable, false);\n              assert.strictEqual(socket.writable, true);\n              cb(true);\n            });\n          },\n          server\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n        const socket = net.connect({\n          port: server.address().port,\n          allowHalfOpen: true\n        }, () => {\n          socket.end(['GET / HTTP/1.1', 'Host: localhost', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==', 'Sec-WebSocket-Version: 13', '\\r\\n'].join('\\r\\n'));\n        });\n        socket.on('end', () => {\n          wss.close();\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"handles data passed along with the upgrade request","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":969,"column":58,"index":31406},"line":969,"code":"    it('handles data passed along with the upgrade request', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.request({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13\n          }\n        });\n        const list = Sender.frame(Buffer.from('Hello'), {\n          fin: true,\n          rsv1: false,\n          opcode: 0x01,\n          mask: true,\n          readOnly: false\n        });\n        req.write(Buffer.concat(list));\n        req.end();\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (data, isBinary) => {\n          assert.deepStrictEqual(data, Buffer.from('Hello'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"allows to select a subprotocol","suites":["WebSocketServer","Connection establishing","`handleProtocols`"],"updatePoint":{"line":1001,"column":40,"index":32349},"line":1001,"code":"      it('allows to select a subprotocol', done => {\n        const handleProtocols = (protocols, request) => {\n          assert.ok(request instanceof http.IncomingMessage);\n          assert.strictEqual(request.url, '/');\n          return Array.from(protocols).pop();\n        };\n        const wss = new WebSocket.Server({\n          handleProtocols,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, ['foo', 'bar']);\n          ws.on('open', () => {\n            assert.strictEqual(ws.protocol, 'bar');\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'headers' event","suites":["WebSocketServer","Connection establishing","`handleProtocols`"],"updatePoint":{"line":1022,"column":33,"index":33047},"line":1022,"code":"    it(\"emits the 'headers' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('headers', (headers, request) => {\n        assert.deepStrictEqual(headers.slice(0, 3), ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade']);\n        assert.ok(request instanceof http.IncomingMessage);\n        assert.strictEqual(request.url, '/');\n        wss.on('connection', () => wss.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is disabled by default","suites":["WebSocketServer","permessage-deflate"],"updatePoint":{"line":1038,"column":30,"index":33689},"line":1038,"code":"    it('is disabled by default', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', (ws, req) => {\n        assert.strictEqual(req.headers['sec-websocket-extensions'], 'permessage-deflate; client_max_window_bits');\n        assert.strictEqual(ws.extensions, '');\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses configuration options","suites":["WebSocketServer","permessage-deflate"],"updatePoint":{"line":1051,"column":34,"index":34174},"line":1051,"code":"    it('uses configuration options', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          clientMaxWindowBits: 8\n        },\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('upgrade', res => {\n          assert.strictEqual(res.headers['sec-websocket-extensions'], 'permessage-deflate; client_max_window_bits=8');\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error when using an invalid url","suites":["WebSocket","#ctor"],"updatePoint":{"line":36,"column":49,"index":812},"line":36,"code":"    it('throws an error when using an invalid url', () => {\n      assert.throws(() => new WebSocket('foo'), /^SyntaxError: Invalid URL: foo$/);\n      assert.throws(() => new WebSocket('https://websocket-echo.com'), /^SyntaxError: The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws\\+unix:\"$/);\n      assert.throws(() => new WebSocket('ws+unix:'), /^SyntaxError: The URL's pathname is empty$/);\n      assert.throws(() => new WebSocket('wss://websocket-echo.com#foo'), /^SyntaxError: The URL contains a fragment identifier$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is invalid or duplicated","suites":["WebSocket","#ctor"],"updatePoint":{"line":42,"column":65,"index":1365},"line":42,"code":"    it('throws an error if a subprotocol is invalid or duplicated', () => {\n      for (const subprotocol of [null, '', 'a,b', ['a', 'a']]) {\n        assert.throws(() => new WebSocket('ws://localhost', subprotocol), /^SyntaxError: An invalid or duplicated subprotocol was specified$/);\n      }\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts `url.URL` objects as url","suites":["WebSocket","#ctor"],"updatePoint":{"line":47,"column":40,"index":1641},"line":47,"code":"    it('accepts `url.URL` objects as url', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = (req, opts) => {\n        assert.strictEqual(opts.host, '::1');\n        assert.strictEqual(req.path, '/');\n        done();\n      };\n      const ws = new WebSocket(new URL('ws://[::1]'), {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts the `options` object as 3rd argument","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":59,"column":54,"index":2023},"line":59,"code":"      it('accepts the `options` object as 3rd argument', () => {\n        const agent = new CustomAgent();\n        let count = 0;\n        let ws;\n        agent.addRequest = req => {\n          assert.strictEqual(req.getHeader('sec-websocket-protocol'), undefined);\n          count++;\n        };\n        ws = new WebSocket('ws://localhost', undefined, {\n          agent\n        });\n        ws = new WebSocket('ws://localhost', [], {\n          agent\n        });\n        assert.strictEqual(count, 2);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts the `maxPayload` option","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":75,"column":41,"index":2516},"line":75,"code":"      it('accepts the `maxPayload` option', done => {\n        const maxPayload = 20480;\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: true,\n            maxPayload\n          });\n          ws.on('open', () => {\n            assert.strictEqual(ws._receiver._maxPayload, maxPayload);\n            assert.strictEqual(ws._receiver._extensions['permessage-deflate']._maxPayload, maxPayload);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error when using an invalid `protocolVersion`","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":95,"column":65,"index":3236},"line":95,"code":"      it('throws an error when using an invalid `protocolVersion`', () => {\n        const options = {\n          agent: new CustomAgent(),\n          protocolVersion: 1000\n        };\n        assert.throws(() => new WebSocket('ws://localhost', options), /^RangeError: Unsupported protocol version: 1000 \\(supported versions: 8, 13\\)$/);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `generateMask` option","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":102,"column":42,"index":3557},"line":102,"code":"      it('honors the `generateMask` option', done => {\n        const data = Buffer.from('foo');\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            generateMask() {}\n          });\n          ws.on('open', () => {\n            ws.send(data);\n          });\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1005);\n            assert.deepStrictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const chunks = [];\n          ws._socket.prependListener('data', chunk => {\n            chunks.push(chunk);\n          });\n          ws.on('message', message => {\n            assert.deepStrictEqual(message, data);\n            assert.deepStrictEqual(Buffer.concat(chunks).slice(2, 6), Buffer.alloc(4));\n            ws.close();\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable property of class","suites":["WebSocket","Constants","\\`\\`"],"updatePoint":{"line":142,"column":43,"index":4773},"line":142,"code":"        it('is enumerable property of class', () => {\n          const descriptor = Object.getOwnPropertyDescriptor(WebSocket, state);\n          assert.deepStrictEqual(descriptor, {\n            configurable: false,\n            enumerable: true,\n            value: readyStates[state],\n            writable: false\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable property of prototype","suites":["WebSocket","Constants","\\`\\`"],"updatePoint":{"line":151,"column":47,"index":5114},"line":151,"code":"        it('is enumerable property of prototype', () => {\n          const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, state);\n          assert.deepStrictEqual(descriptor, {\n            configurable: false,\n            enumerable: true,\n            value: readyStates[state],\n            writable: false\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":165,"column":40,"index":5552},"line":165,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'binaryType');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set !== undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to 'nodebuffer'","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":172,"column":34,"index":5916},"line":172,"code":"      it(\"defaults to 'nodebuffer'\", () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.binaryType, 'nodebuffer');\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be changed to 'arraybuffer' or 'fragments'","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":178,"column":56,"index":6150},"line":178,"code":"      it(\"can be changed to 'arraybuffer' or 'fragments'\", () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        ws.binaryType = 'arraybuffer';\n        assert.strictEqual(ws.binaryType, 'arraybuffer');\n        ws.binaryType = 'foo';\n        assert.strictEqual(ws.binaryType, 'arraybuffer');\n        ws.binaryType = 'fragments';\n        assert.strictEqual(ws.binaryType, 'fragments');\n        ws.binaryType = '';\n        assert.strictEqual(ws.binaryType, 'fragments');\n        ws.binaryType = 'nodebuffer';\n        assert.strictEqual(ws.binaryType, 'nodebuffer');\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":195,"column":40,"index":6818},"line":195,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'bufferedAmount');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to zero","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":202,"column":26,"index":7178},"line":202,"code":"      it('defaults to zero', () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.bufferedAmount, 0);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to zero upon \"open\"","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":208,"column":38,"index":7387},"line":208,"code":"      it('defaults to zero upon \"open\"', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.onopen = () => {\n            assert.strictEqual(ws.bufferedAmount, 0);\n            wss.close(done);\n          };\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"takes into account the data in the sender queue","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":222,"column":57,"index":7832},"line":222,"code":"      it('takes into account the data in the sender queue', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('foo');\n            assert.strictEqual(ws.bufferedAmount, 3);\n            ws.send('bar', err => {\n              assert.ifError(err);\n              assert.strictEqual(ws.bufferedAmount, 0);\n              wss.close(done);\n            });\n            assert.strictEqual(ws.bufferedAmount, 6);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"takes into account the data in the socket queue","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":247,"column":57,"index":8631},"line":247,"code":"      it('takes into account the data in the socket queue', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        });\n        wss.on('connection', ws => {\n          const data = Buffer.alloc(1024, 61);\n          while (ws.bufferedAmount === 0) {\n            ws.send(data);\n          }\n          assert.ok(ws.bufferedAmount > 0);\n          assert.strictEqual(ws.bufferedAmount, ws._socket._writableState.length);\n          ws.on('close', () => wss.close(done));\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":266,"column":40,"index":9284},"line":266,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'bufferedAmount');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the negotiated extensions names (1/2)","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":273,"column":55,"index":9673},"line":273,"code":"      it('exposes the negotiated extensions names (1/2)', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.extensions, '');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.extensions, '');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the negotiated extensions names (2/2)","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":289,"column":55,"index":10236},"line":289,"code":"      it('exposes the negotiated extensions names (2/2)', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.extensions, 'permessage-deflate');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.extensions, 'permessage-deflate');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`isPaused`"],"updatePoint":{"line":308,"column":40,"index":10898},"line":308,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'isPaused');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"indicates whether the websocket is paused","suites":["WebSocket","Attributes","`isPaused`"],"updatePoint":{"line":315,"column":51,"index":11277},"line":315,"code":"      it('indicates whether the websocket is paused', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            ws.pause();\n            assert.ok(ws.isPaused);\n            ws.resume();\n            assert.ok(!ws.isPaused);\n            ws.close();\n            wss.close(done);\n          });\n          assert.ok(!ws.isPaused);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`protocol`"],"updatePoint":{"line":333,"column":40,"index":11807},"line":333,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'protocol');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the subprotocol selected by the server","suites":["WebSocket","Attributes","`protocol`"],"updatePoint":{"line":340,"column":56,"index":12191},"line":340,"code":"      it('exposes the subprotocol selected by the server', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const port = wss.address().port;\n          const ws = new WebSocket(`ws://localhost:${port}`, 'foo');\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.protocol, 'foo');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.protocol, 'foo');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":359,"column":40,"index":12822},"line":359,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'readyState');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to `CONNECTING`","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":366,"column":34,"index":13186},"line":366,"code":"      it('defaults to `CONNECTING`', () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `OPEN` once connection is established","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":372,"column":57,"index":13429},"line":372,"code":"      it('is set to `OPEN` once connection is established', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            assert.strictEqual(ws.readyState, WebSocket.OPEN);\n            ws.close();\n          });\n          ws.on('close', () => wss.close(done));\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `CLOSED` once connection is closed","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":384,"column":54,"index":13856},"line":384,"code":"      it('is set to `CLOSED` once connection is closed', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            wss.close(done);\n          });\n          ws.on('open', () => ws.close(1001));\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `CLOSED` once connection is terminated","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":396,"column":58,"index":14293},"line":396,"code":"      it('is set to `CLOSED` once connection is terminated', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            wss.close(done);\n          });\n          ws.on('open', () => ws.terminate());\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`url`"],"updatePoint":{"line":410,"column":40,"index":14750},"line":410,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'url');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the server url","suites":["WebSocket","Attributes","`url`"],"updatePoint":{"line":417,"column":32,"index":15105},"line":417,"code":"      it('exposes the server url', () => {\n        const url = 'ws://localhost';\n        const ws = new WebSocket(url, {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.url, url);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an 'error' event if an error occurs","suites":["WebSocket","Events"],"updatePoint":{"line":427,"column":49,"index":15384},"line":427,"code":"    it(\"emits an 'error' event if an error occurs\", done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          serverClientCloseEventEmitted = true;\n          if (clientCloseEventEmitted) wss.close(done);\n        });\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not re-emit `net.Socket` errors","suites":["WebSocket","Events"],"updatePoint":{"line":456,"column":44,"index":16564},"line":456,"code":"    it('does not re-emit `net.Socket` errors', done => {\n      const codes = ['EPIPE', 'ECONNABORTED', 'ECANCELED', 'ECONNRESET'];\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.on('error', err => {\n            assert.ok(err instanceof Error);\n            assert.ok(codes.includes(err.code), `Unexpected code: ${err.code}`);\n            ws.on('close', (code, message) => {\n              assert.strictEqual(code, 1006);\n              assert.strictEqual(message, EMPTY_BUFFER);\n              wss.close(done);\n            });\n          });\n          for (const client of wss.clients) client.terminate();\n          ws.send('foo');\n          ws.send('bar');\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an 'upgrade' event","suites":["WebSocket","Events"],"updatePoint":{"line":478,"column":32,"index":17387},"line":478,"code":"    it(\"emits an 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('upgrade', res => {\n          assert.ok(res instanceof http.IncomingMessage);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'ping' event","suites":["WebSocket","Events"],"updatePoint":{"line":492,"column":28,"index":17790},"line":492,"code":"    it(\"emits a 'ping' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('ping', () => wss.close(done));\n      });\n      wss.on('connection', ws => {\n        ws.ping();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'pong' event","suites":["WebSocket","Events"],"updatePoint":{"line":504,"column":28,"index":18127},"line":504,"code":"    it(\"emits a 'pong' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('pong', () => wss.close(done));\n      });\n      wss.on('connection', ws => {\n        ws.pong();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'redirect' event","suites":["WebSocket","Events"],"updatePoint":{"line":516,"column":32,"index":18468},"line":516,"code":"    it(\"emits a 'redirect' event\", done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.close();\n          });\n        });\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('redirect', (url, req) => {\n          assert.strictEqual(ws._redirects, 1);\n          assert.strictEqual(url, `ws://localhost:${port}/foo`);\n          assert.ok(req instanceof http.ClientRequest);\n          ws.on('close', code => {\n            assert.strictEqual(code, 1005);\n            server.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Upgrade header field value is not \"websocket\"","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":551,"column":66,"index":19698},"line":551,"code":"    it('fails if the Upgrade header field value is not \"websocket\"', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Connection: Upgrade\\r\\n' + 'Upgrade: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Upgrade header');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Accept header is invalid","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":563,"column":59,"index":20233},"line":563,"code":"    it('fails if the Sec-WebSocket-Accept header is invalid', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + 'Sec-WebSocket-Accept: CxYS6+NgJSBG74mdgLvGscRvpns=\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Accept header');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"close event is raised when server closes connection","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":575,"column":59,"index":20846},"line":575,"code":"    it('close event is raised when server closes connection', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('close', (code, reason) => {\n        assert.strictEqual(code, 1006);\n        assert.strictEqual(reason, EMPTY_BUFFER);\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"error is emitted if server aborts connection","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":587,"column":52,"index":21482},"line":587,"code":"    it('error is emitted if server aborts connection', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + `Content-Length: ${http.STATUS_CODES[401].length}\\r\\n` + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Unexpected server response: 401');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"unexpected response can be read when sent by server","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":599,"column":59,"index":22129},"line":599,"code":"    it('unexpected response can be read when sent by server', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', () => done(new Error(\"Unexpected 'error' event\")));\n      ws.on('unexpected-response', (req, res) => {\n        assert.strictEqual(res.statusCode, 401);\n        let data = '';\n        res.on('data', v => {\n          data += v;\n        });\n        res.on('end', () => {\n          assert.strictEqual(data, 'foo');\n          done();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"request can be aborted when unexpected response is sent by server","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":618,"column":73,"index":22966},"line":618,"code":"    it('request can be aborted when unexpected response is sent by server', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', () => done(new Error(\"Unexpected 'error' event\")));\n      ws.on('unexpected-response', (req, res) => {\n        assert.strictEqual(res.statusCode, 401);\n        res.on('end', done);\n        req.abort();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the opening handshake timeout expires","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":631,"column":54,"index":23645},"line":631,"code":"    it('fails if the opening handshake timeout expires', done => {\n      server.once('upgrade', (req, socket) => socket.on('end', socket.end));\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://localhost:${port}`, {\n        handshakeTimeout: 100\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Opening handshake has timed out');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected Sec-WebSocket-Extensions header is received","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":644,"column":74,"index":24202},"line":644,"code":"    it('fails if an unexpected Sec-WebSocket-Extensions header is received', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        perMessageDeflate: false\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":659,"column":69,"index":25096},"line":659,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo;=\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Extensions header');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":672,"column":69,"index":25906},"line":672,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: ' + 'permessage-deflate; client_max_window_bits=7\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Extensions header');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected extension is received (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":685,"column":58,"index":26749},"line":685,"code":"    it('fails if an unexpected extension is received (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server indicated an extension that was not requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected extension is received (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":698,"column":58,"index":27559},"line":698,"code":"    it('fails if an unexpected extension is received (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: permessage-deflate,foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server indicated an extension that was not requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends a subprotocol when none was requested","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":711,"column":67,"index":28397},"line":711,"code":"    it('fails if server sends a subprotocol when none was requested', done => {\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('headers', headers => {\n        headers.push('Sec-WebSocket-Protocol: foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent a subprotocol but none was requested');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends an invalid subprotocol (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":726,"column":58,"index":29009},"line":726,"code":"    it('fails if server sends an invalid subprotocol (1/2)', done => {\n      const wss = new WebSocket.Server({\n        handleProtocols: () => 'baz',\n        server\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent an invalid subprotocol');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends an invalid subprotocol (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":739,"column":58,"index":29561},"line":739,"code":"    it('fails if server sends an invalid subprotocol (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Protocol:\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent an invalid subprotocol');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends no subprotocol","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":752,"column":44,"index":30349},"line":752,"code":"    it('fails if server sends no subprotocol', done => {\n      const wss = new WebSocket.Server({\n        handleProtocols() {},\n        server\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent no subprotocol');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not follow redirects by default","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":765,"column":44,"index":30871},"line":765,"code":"    it('does not follow redirects by default', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 301 Moved Permanently\\r\\n' + 'Location: ws://localhost:8080\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Unexpected server response: 301');\n        assert.strictEqual(ws._redirects, 0);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `followRedirects` option","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":778,"column":43,"index":31485},"line":778,"code":"    it('honors the `followRedirects` option', done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, NOOP);\n        });\n      });\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://localhost:${port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => {\n        assert.strictEqual(ws.url, `ws://localhost:${port}/foo`);\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `maxRedirects` option","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":800,"column":40,"index":32239},"line":800,"code":"    it('honors the `maxRedirects` option', done => {\n      const onUpgrade = (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /\\r\\n\\r\\n');\n      };\n      server.on('upgrade', onUpgrade);\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true,\n        maxRedirects: 1\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Maximum redirects exceeded');\n        assert.strictEqual(ws._redirects, 2);\n        server.removeListener('upgrade', onUpgrade);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the redirect URL is invalid (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":818,"column":59,"index":32976},"line":818,"code":"    it('emits an error if the redirect URL is invalid (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: ws://\\r\\n\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof SyntaxError);\n        assert.strictEqual(err.message, 'Invalid URL: ws://');\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the redirect URL is invalid (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":833,"column":59,"index":33604},"line":833,"code":"    it('emits an error if the redirect URL is invalid (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: http://localhost\\r\\n\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof SyntaxError);\n        assert.strictEqual(err.message, 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"');\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"uses the first url userinfo when following redirects","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":848,"column":60,"index":34289},"line":848,"code":"    it('uses the first url userinfo when following redirects', done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      const authorization = 'Basic Zm9vOmJhcg==';\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://baz:qux@localhost:${port}/foo\\r\\n\\r\\n`);\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, (ws, req) => {\n            assert.strictEqual(req.headers.authorization, authorization);\n            ws.close();\n          });\n        });\n      });\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://foo:bar@localhost:${port}`, {\n        followRedirects: true\n      });\n      assert.strictEqual(ws._req.getHeader('Authorization'), authorization);\n      ws.on('close', code => {\n        assert.strictEqual(code, 1005);\n        assert.strictEqual(ws.url, `ws://baz:qux@localhost:${port}/foo`);\n        assert.strictEqual(ws._redirects, 1);\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the `auth` option","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is no 'redirect' event listener"],"updatePoint":{"line":892,"column":35,"index":36001},"line":892,"code":"        it('drops the `auth` option', done => {\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.on('error', NOOP);\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, undefined);\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${port}`, {\n              auth: 'foo:bar',\n              followRedirects: true,\n              rejectUnauthorized: false\n            });\n            assert.strictEqual(ws._req.getHeader('Authorization'), 'Basic Zm9vOmJhcg==');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              server.close(done);\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization and Cookie headers","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is no 'redirect' event listener"],"updatePoint":{"line":926,"column":54,"index":37475},"line":926,"code":"        it('drops the Authorization and Cookie headers', done => {\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.on('error', NOOP);\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, undefined);\n              assert.strictEqual(req.headers.cookie, undefined);\n              assert.strictEqual(req.headers.host, headers.host);\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${port}`, {\n              followRedirects: true,\n              headers,\n              rejectUnauthorized: false\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              server.close(done);\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not drop any headers by default","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is at least one 'redirect' event listener"],"updatePoint":{"line":972,"column":48,"index":39516},"line":972,"code":"        it('does not drop any headers by default', done => {\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.on('error', NOOP);\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, headers.authorization);\n              assert.strictEqual(req.headers.cookie, headers.cookie);\n              assert.strictEqual(req.headers.host, headers.host);\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${port}`, {\n              followRedirects: true,\n              headers,\n              rejectUnauthorized: false\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('redirect', (url, req) => {\n              assert.strictEqual(ws._redirects, 1);\n              assert.strictEqual(url, `ws://localhost:${port}/`);\n              assert.notStrictEqual(firstRequest, req);\n              assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n              assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n              assert.strictEqual(req.getHeader('Host'), headers.host);\n              ws.on('close', code => {\n                assert.strictEqual(code, 1005);\n                server.close(done);\n              });\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the `auth` option","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1026,"column":35,"index":41977},"line":1026,"code":"        it('drops the `auth` option', done => {\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              auth: 'foo:bar',\n              followRedirects: true\n            });\n            assert.strictEqual(ws._req.getHeader('Authorization'), 'Basic Zm9vOmJhcg==');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              wss.close(done);\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, Cookie and Host headers (1/4)","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1051,"column":66,"index":43041},"line":1051,"code":"        it('drops the Authorization, Cookie and Host headers (1/4)', done => {\n          // Test the `ws:` to `ws:` case.\n\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              followRedirects: true,\n              headers\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              wss.close(done);\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            assert.strictEqual(req.headers.cookie, undefined);\n            assert.strictEqual(req.headers.host, `localhost:${wss.address().port}`);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, Cookie and Host headers (2/4)","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1088,"column":66,"index":44652},"line":1088,"code":"        it('drops the Authorization, Cookie and Host headers (2/4)', done => {\n          // Test the `ws:` to `ws+unix:` case.\n\n          const randomString = crypto.randomBytes(16).toString('hex');\n          const ipcPath = process.platform === 'win32' ? `\\\\\\\\.\\\\pipe\\\\ws-pipe-${randomString}` : path.join(os.tmpdir(), `ws-${randomString}.sock`);\n          server.once('upgrade', (req, socket) => {\n            socket.end(`HTTP/1.1 302 Found\\r\\nLocation: ws+unix:${ipcPath}\\r\\n\\r\\n`);\n          });\n          const redirectedServer = http.createServer();\n          const wss = new WebSocket.Server({\n            server: redirectedServer\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            assert.strictEqual(req.headers.cookie, undefined);\n            assert.strictEqual(req.headers.host, 'localhost');\n            ws.close();\n          });\n          redirectedServer.listen(ipcPath, () => {\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              followRedirects: true,\n              headers\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws+unix:${ipcPath}`);\n              assert.strictEqual(ws._redirects, 1);\n              redirectedServer.close(done);\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, Cookie and Host headers (3/4)","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1128,"column":66,"index":46530},"line":1128,"code":"        it('drops the Authorization, Cookie and Host headers (3/4)', done => {\n          // Test the `ws+unix:` to `ws+unix:` case.\n\n          const randomString1 = crypto.randomBytes(16).toString('hex');\n          const randomString2 = crypto.randomBytes(16).toString('hex');\n          let redirectingServerIpcPath;\n          let redirectedServerIpcPath;\n          if (process.platform === 'win32') {\n            redirectingServerIpcPath = `\\\\\\\\.\\\\pipe\\\\ws-pipe-${randomString1}`;\n            redirectedServerIpcPath = `\\\\\\\\.\\\\pipe\\\\ws-pipe-${randomString2}`;\n          } else {\n            redirectingServerIpcPath = path.join(os.tmpdir(), `ws-${randomString1}.sock`);\n            redirectedServerIpcPath = path.join(os.tmpdir(), `ws-${randomString2}.sock`);\n          }\n          const redirectingServer = http.createServer();\n          redirectingServer.on('upgrade', (req, socket) => {\n            socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws+unix:${redirectedServerIpcPath}\\r\\n\\r\\n`);\n          });\n          const redirectedServer = http.createServer();\n          const wss = new WebSocket.Server({\n            server: redirectedServer\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            assert.strictEqual(req.headers.cookie, undefined);\n            assert.strictEqual(req.headers.host, 'localhost');\n            ws.close();\n          });\n          redirectingServer.listen(redirectingServerIpcPath, listening);\n          redirectedServer.listen(redirectedServerIpcPath, listening);\n          let callCount = 0;\n          function listening() {\n            if (++callCount !== 2) return;\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const ws = new WebSocket(`ws+unix:${redirectingServerIpcPath}`, {\n              followRedirects: true,\n              headers\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws+unix:${redirectedServerIpcPath}`);\n              assert.strictEqual(ws._redirects, 1);\n              redirectingServer.close();\n              redirectedServer.close(done);\n            });\n          }\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, Cookie and Host headers (4/4)","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1183,"column":66,"index":49169},"line":1183,"code":"        it('drops the Authorization, Cookie and Host headers (4/4)', done => {\n          // Test the `ws+unix:` to `ws:` case.\n\n          const redirectingServer = http.createServer();\n          const redirectedServer = http.createServer();\n          const wss = new WebSocket.Server({\n            server: redirectedServer\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            assert.strictEqual(req.headers.cookie, undefined);\n            assert.strictEqual(req.headers.host, `localhost:${redirectedServer.address().port}`);\n            ws.close();\n          });\n          const randomString = crypto.randomBytes(16).toString('hex');\n          const ipcPath = process.platform === 'win32' ? `\\\\\\\\.\\\\pipe\\\\ws-pipe-${randomString}` : path.join(os.tmpdir(), `ws-${randomString}.sock`);\n          redirectingServer.listen(ipcPath, listening);\n          redirectedServer.listen(0, listening);\n          let callCount = 0;\n          function listening() {\n            if (++callCount !== 2) return;\n            const port = redirectedServer.address().port;\n            redirectingServer.on('upgrade', (req, socket) => {\n              socket.end(`HTTP/1.1 302 Found\\r\\nLocation: ws://localhost:${port}\\r\\n\\r\\n`);\n            });\n            const headers = {\n              authorization: 'Basic Zm9vOmJhcg==',\n              cookie: 'foo=bar',\n              host: 'foo'\n            };\n            const ws = new WebSocket(`ws+unix:${ipcPath}`, {\n              followRedirects: true,\n              headers\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              redirectingServer.close();\n              redirectedServer.close(done);\n            });\n          }\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not drop any headers by default","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is at least one 'redirect' event listener"],"updatePoint":{"line":1232,"column":48,"index":51467},"line":1232,"code":"        it('does not drop any headers by default', done => {\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar',\n            host: 'foo'\n          };\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              followRedirects: true,\n              headers\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('redirect', (url, req) => {\n              assert.strictEqual(ws._redirects, 1);\n              assert.strictEqual(url, `ws://localhost:${port}/`);\n              assert.notStrictEqual(firstRequest, req);\n              assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n              assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n              assert.strictEqual(req.getHeader('Host'), headers.host);\n              ws.on('close', code => {\n                assert.strictEqual(code, 1005);\n                wss.close(done);\n              });\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, headers.authorization);\n            assert.strictEqual(req.headers.cookie, headers.cookie);\n            assert.strictEqual(req.headers.host, headers.host);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to abort the request without swallowing errors","suites":["WebSocket","Connection establishing","In a listener of the 'redirect' event"],"updatePoint":{"line":1276,"column":63,"index":53455},"line":1276,"code":"      it('allows to abort the request without swallowing errors', done => {\n        server.once('upgrade', (req, socket) => {\n          socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        });\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('redirect', (url, req) => {\n          assert.strictEqual(ws._redirects, 1);\n          assert.strictEqual(url, `ws://localhost:${port}/foo`);\n          req.on('socket', () => {\n            req.abort();\n          });\n          ws.on('error', err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'socket hang up');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1006);\n              done();\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to remove headers","suites":["WebSocket","Connection establishing","In a listener of the 'redirect' event"],"updatePoint":{"line":1300,"column":34,"index":54311},"line":1300,"code":"      it('allows to remove headers', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const port = wss.address().port;\n          server.once('upgrade', (req, socket) => {\n            socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n          });\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar'\n          };\n          const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n            followRedirects: true,\n            headers\n          });\n          ws.on('redirect', (url, req) => {\n            assert.strictEqual(ws._redirects, 1);\n            assert.strictEqual(url, `ws://localhost:${port}/`);\n            assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n            req.removeHeader('authorization');\n            req.removeHeader('cookie');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              wss.close(done);\n            });\n          });\n        });\n        wss.on('connection', (ws, req) => {\n          assert.strictEqual(req.headers.authorization, undefined);\n          assert.strictEqual(req.headers.cookie, undefined);\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects when pathname is not null","suites":["WebSocket","Connection with query string"],"updatePoint":{"line":1338,"column":42,"index":55763},"line":1338,"code":"    it('connects when pathname is not null', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const port = wss.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}/?token=qwerty`);\n        ws.on('open', () => {\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects when pathname is null","suites":["WebSocket","Connection with query string"],"updatePoint":{"line":1352,"column":38,"index":56155},"line":1352,"code":"    it('connects when pathname is null', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const port = wss.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}?token=qwerty`);\n        ws.on('open', () => {\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CONNECTING` or `CLOSED`","suites":["WebSocket","#pause"],"updatePoint":{"line":1368,"column":64,"index":56607},"line":1368,"code":"    it('does nothing if `readyState` is `CONNECTING` or `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        assert.ok(!ws.isPaused);\n        ws.pause();\n        assert.ok(!ws.isPaused);\n        ws.on('open', () => {\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            ws.pause();\n            assert.ok(!ws.isPaused);\n            wss.close(done);\n          });\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"pauses the socket","suites":["WebSocket","#pause"],"updatePoint":{"line":1388,"column":25,"index":57228},"line":1388,"code":"    it('pauses the socket', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.pause();\n        assert.ok(ws.isPaused);\n        assert.ok(ws._socket.isPaused());\n        ws.terminate();\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#ping"],"updatePoint":{"line":1406,"column":55,"index":57760},"line":1406,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      assert.throws(() => ws.ping(), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.ping(NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#ping"],"updatePoint":{"line":1413,"column":60,"index":58126},"line":1413,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.ping('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.ping();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.ping('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.ping();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#ping"],"updatePoint":{"line":1437,"column":64,"index":59022},"line":1437,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.ping('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.ping(err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 2);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a ping with no data","suites":["WebSocket","#ping"],"updatePoint":{"line":1461,"column":36,"index":59903},"line":1461,"code":"    it('can send a ping with no data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping(() => {\n            ws.ping();\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pings = 0;\n        ws.on('ping', data => {\n          assert.ok(Buffer.isBuffer(data));\n          assert.strictEqual(data.length, 0);\n          if (++pings === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a ping with data","suites":["WebSocket","#ping"],"updatePoint":{"line":1482,"column":33,"index":60492},"line":1482,"code":"    it('can send a ping with data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping('hi', () => {\n            ws.ping('hi', true);\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pings = 0;\n        ws.on('ping', message => {\n          assert.strictEqual(message.toString(), 'hi');\n          if (++pings === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send numbers as ping payload","suites":["WebSocket","#ping"],"updatePoint":{"line":1502,"column":40,"index":61073},"line":1502,"code":"    it('can send numbers as ping payload', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('ping', message => {\n          assert.strictEqual(message.toString(), '0');\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the data size is greater than 125 bytes","suites":["WebSocket","#ping"],"updatePoint":{"line":1519,"column":66,"index":61578},"line":1519,"code":"    it('throws an error if the data size is greater than 125 bytes', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          assert.throws(() => ws.ping(Buffer.alloc(126)), /^RangeError: The data size must not be greater than 125 bytes$/);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#pong"],"updatePoint":{"line":1535,"column":55,"index":62105},"line":1535,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      assert.throws(() => ws.pong(), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.pong(NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#pong"],"updatePoint":{"line":1542,"column":60,"index":62471},"line":1542,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.pong('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.pong();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.pong('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.pong();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#pong"],"updatePoint":{"line":1566,"column":64,"index":63367},"line":1566,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.pong('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.pong(err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 2);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a pong with no data","suites":["WebSocket","#pong"],"updatePoint":{"line":1590,"column":36,"index":64248},"line":1590,"code":"    it('can send a pong with no data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong(() => {\n            ws.pong();\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pongs = 0;\n        ws.on('pong', data => {\n          assert.ok(Buffer.isBuffer(data));\n          assert.strictEqual(data.length, 0);\n          if (++pongs === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a pong with data","suites":["WebSocket","#pong"],"updatePoint":{"line":1611,"column":33,"index":64837},"line":1611,"code":"    it('can send a pong with data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong('hi', () => {\n            ws.pong('hi', true);\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pongs = 0;\n        ws.on('pong', message => {\n          assert.strictEqual(message.toString(), 'hi');\n          if (++pongs === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send numbers as pong payload","suites":["WebSocket","#pong"],"updatePoint":{"line":1631,"column":40,"index":65418},"line":1631,"code":"    it('can send numbers as pong payload', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('pong', message => {\n          assert.strictEqual(message.toString(), '0');\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the data size is greater than 125 bytes","suites":["WebSocket","#pong"],"updatePoint":{"line":1648,"column":66,"index":65923},"line":1648,"code":"    it('throws an error if the data size is greater than 125 bytes', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          assert.throws(() => ws.pong(Buffer.alloc(126)), /^RangeError: The data size must not be greater than 125 bytes$/);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CONNECTING` or `CLOSED`","suites":["WebSocket","#resume"],"updatePoint":{"line":1664,"column":64,"index":66461},"line":1664,"code":"    it('does nothing if `readyState` is `CONNECTING` or `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        assert.ok(!ws.isPaused);\n\n        // Verify that no exception is thrown.\n        ws.resume();\n        ws.on('open', () => {\n          ws.pause();\n          assert.ok(ws.isPaused);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            ws.resume();\n            assert.ok(ws.isPaused);\n            wss.close(done);\n          });\n          ws.terminate();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket","suites":["WebSocket","#resume"],"updatePoint":{"line":1687,"column":26,"index":67159},"line":1687,"code":"    it('resumes the socket', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.pause();\n        assert.ok(ws.isPaused);\n        assert.ok(ws._socket.isPaused());\n        ws.resume();\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.close();\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#send"],"updatePoint":{"line":1708,"column":55,"index":67784},"line":1708,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      assert.throws(() => ws.send('hi'), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.send('hi', NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#send"],"updatePoint":{"line":1715,"column":60,"index":68160},"line":1715,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.send('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.send();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.send('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.send();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#send"],"updatePoint":{"line":1739,"column":64,"index":69056},"line":1739,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.send('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.send('hi', err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 4);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a big binary message","suites":["WebSocket","#send"],"updatePoint":{"line":1763,"column":37,"index":69944},"line":1763,"code":"    it('can send a big binary message', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(5 * 1024 * 1024);\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 5;\n        }\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send(array));\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from(array.buffer));\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send text data","suites":["WebSocket","#send"],"updatePoint":{"line":1787,"column":26,"index":70700},"line":1787,"code":"    it('can send text data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send('hi'));\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('hi'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not override the `fin` option","suites":["WebSocket","#send"],"updatePoint":{"line":1808,"column":42,"index":71341},"line":1808,"code":"    it('does not override the `fin` option', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send('fragment', {\n            fin: false\n          });\n          ws.send('fragment', {\n            fin: true\n          });\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from('fragmentfragment'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sends numbers as strings","suites":["WebSocket","#send"],"updatePoint":{"line":1831,"column":32,"index":71987},"line":1831,"code":"    it('sends numbers as strings', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from('0'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `TypedArray`","suites":["WebSocket","#send"],"updatePoint":{"line":1849,"column":31,"index":72502},"line":1849,"code":"    it('can send a `TypedArray`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(6);\n        for (let i = 0; i < array.length; ++i) {\n          array[i] = i / 2;\n        }\n        const partial = array.subarray(2, 5);\n        const buf = Buffer.from(partial.buffer, partial.byteOffset, partial.byteLength);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(partial);\n          ws.close();\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, buf);\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send an `ArrayBuffer`","suites":["WebSocket","#send"],"updatePoint":{"line":1877,"column":33,"index":73397},"line":1877,"code":"    it('can send an `ArrayBuffer`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(5);\n        for (let i = 0; i < array.length; ++i) {\n          array[i] = i / 2;\n        }\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(array.buffer);\n          ws.close();\n        });\n        ws.onmessage = event => {\n          assert.ok(event.data.equals(Buffer.from(array.buffer)));\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `Buffer`","suites":["WebSocket","#send"],"updatePoint":{"line":1902,"column":27,"index":74127},"line":1902,"code":"    it('can send a `Buffer`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const buf = Buffer.from('foobar');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(buf);\n          ws.close();\n        });\n        ws.onmessage = event => {\n          assert.deepStrictEqual(event.data, buf);\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback when data is written out","suites":["WebSocket","#send"],"updatePoint":{"line":1924,"column":51,"index":74769},"line":1924,"code":"    it('calls the callback when data is written out', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send('hi', err => {\n            assert.ifError(err);\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when the `data` argument is falsy","suites":["WebSocket","#send"],"updatePoint":{"line":1940,"column":47,"index":75211},"line":1940,"code":"    it('works when the `data` argument is falsy', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send();\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.strictEqual(message, EMPTY_BUFFER);\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `mask` option","suites":["WebSocket","#send"],"updatePoint":{"line":1958,"column":32,"index":75725},"line":1958,"code":"    it('honors the `mask` option', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send('hi', {\n          mask: false\n        }));\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          clientCloseEventEmitted = true;\n          if (serverClientCloseEventEmitted) wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        const chunks = [];\n        ws._socket.prependListener('data', chunk => {\n          chunks.push(chunk);\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be set');\n          assert.ok(Buffer.concat(chunks).slice(0, 2).equals(Buffer.from('8102', 'hex')));\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (1/3)","suites":["WebSocket","#close"],"updatePoint":{"line":1995,"column":62,"index":77133},"line":1995,"code":"    it('closes the connection if called while connecting (1/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.close(1001);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (2/3)","suites":["WebSocket","#close"],"updatePoint":{"line":2009,"column":62,"index":77712},"line":2009,"code":"    it('closes the connection if called while connecting (2/3)', done => {\n      const wss = new WebSocket.Server({\n        verifyClient: (info, cb) => setTimeout(cb, 300, true),\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        setTimeout(() => ws.close(1001), 150);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (3/3)","suites":["WebSocket","#close"],"updatePoint":{"line":2024,"column":62,"index":78377},"line":2024,"code":"    it('closes the connection if called while connecting (3/3)', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => {\n            server.close(done);\n          });\n        });\n        ws.on('unexpected-response', (req, res) => {\n          assert.strictEqual(res.statusCode, 502);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'foo');\n            ws.close();\n          });\n        });\n      });\n      server.on('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write(`HTTP/1.1 502 ${http.STATUS_CODES[502]}\\r\\n` + 'Connection: keep-alive\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from an error listener while connecting","suites":["WebSocket","#close"],"updatePoint":{"line":2053,"column":61,"index":79601},"line":2053,"code":"    it('can be called from an error listener while connecting', done => {\n      const ws = new WebSocket('ws://localhost:1337');\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'ECONNREFUSED');\n        ws.close();\n        ws.on('close', () => done());\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'redirect' event","suites":["WebSocket","#close"],"updatePoint":{"line":2063,"column":61,"index":80016},"line":2063,"code":"    it(\"can be called from a listener of the 'redirect' event\", done => {\n      const server = http.createServer();\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('open', () => {\n          done(new Error(\"Unexpected 'open' event\"));\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', code => {\n            assert.strictEqual(code, 1006);\n            server.close(done);\n          });\n        });\n        ws.on('redirect', () => {\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'upgrade' event","suites":["WebSocket","#close"],"updatePoint":{"line":2089,"column":60,"index":80933},"line":2089,"code":"    it(\"can be called from a listener of the 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.on('upgrade', () => ws.close());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sends the close status code only when necessary","suites":["WebSocket","#close"],"updatePoint":{"line":2103,"column":55,"index":81525},"line":2103,"code":"    it('sends the close status code only when necessary', done => {\n      let sent;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.once('data', data => {\n            sent = data;\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.once('data', received => {\n          assert.deepStrictEqual(received.slice(0, 2), Buffer.from([0x88, 0x80]));\n          assert.deepStrictEqual(sent, Buffer.from([0x88, 0x00]));\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1005);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when close reason is not specified","suites":["WebSocket","#close"],"updatePoint":{"line":2128,"column":48,"index":82352},"line":2128,"code":"    it('works when close reason is not specified', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close(1000));\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, message) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(message, EMPTY_BUFFER);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when close reason is specified","suites":["WebSocket","#close"],"updatePoint":{"line":2143,"column":44,"index":82847},"line":2143,"code":"    it('works when close reason is specified', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close(1000, 'some reason'));\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, message) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(message, Buffer.from('some reason'));\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"permits all buffered data to be delivered","suites":["WebSocket","#close"],"updatePoint":{"line":2158,"column":49,"index":83376},"line":2158,"code":"    it('permits all buffered data to be delivered', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          threshold: 0\n        },\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const messages = [];\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1005);\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        const callback = err => assert.ifError(err);\n        ws.send('foo', callback);\n        ws.send('bar', callback);\n        ws.send('baz', callback);\n        ws.close();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows close code 1013","suites":["WebSocket","#close"],"updatePoint":{"line":2186,"column":30,"index":84237},"line":2186,"code":"    it('allows close code 1013', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1013);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1013));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows close code 1014","suites":["WebSocket","#close"],"updatePoint":{"line":2198,"column":30,"index":84610},"line":2198,"code":"    it('allows close code 1014', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1014);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1014));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CLOSED`","suites":["WebSocket","#close"],"updatePoint":{"line":2210,"column":48,"index":85001},"line":2210,"code":"    it('does nothing if `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1005);\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.close();\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close());\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sets a timer for the closing handshake to complete","suites":["WebSocket","#close"],"updatePoint":{"line":2224,"column":58,"index":85483},"line":2224,"code":"    it('sets a timer for the closing handshake to complete', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(reason, Buffer.from('some reason'));\n          wss.close(done);\n        });\n        ws.on('open', () => {\n          let callbackCalled = false;\n          assert.strictEqual(ws._closeTimer, null);\n          ws.send('foo', () => {\n            callbackCalled = true;\n          });\n          ws.close(1000, 'some reason');\n\n          //\n          // Check that the close timer is set even if the `Sender.close()`\n          // callback is not called.\n          //\n          assert.strictEqual(callbackCalled, false);\n          assert.strictEqual(ws._closeTimer._idleTimeout, 30000);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (1/2)","suites":["WebSocket","#terminate"],"updatePoint":{"line":2253,"column":62,"index":86471},"line":2253,"code":"    it('closes the connection if called while connecting (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.terminate();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (2/2)","suites":["WebSocket","#terminate"],"updatePoint":{"line":2267,"column":62,"index":87050},"line":2267,"code":"    it('closes the connection if called while connecting (2/2)', done => {\n      const wss = new WebSocket.Server({\n        verifyClient: (info, cb) => setTimeout(cb, 300, true),\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        setTimeout(() => ws.terminate(), 150);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from an error listener while connecting","suites":["WebSocket","#terminate"],"updatePoint":{"line":2282,"column":61,"index":87714},"line":2282,"code":"    it('can be called from an error listener while connecting', done => {\n      const ws = new WebSocket('ws://localhost:1337');\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'ECONNREFUSED');\n        ws.terminate();\n        ws.on('close', () => done());\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'redirect' event","suites":["WebSocket","#terminate"],"updatePoint":{"line":2292,"column":61,"index":88133},"line":2292,"code":"    it(\"can be called from a listener of the 'redirect' event\", done => {\n      const server = http.createServer();\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('open', () => {\n          done(new Error(\"Unexpected 'open' event\"));\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', code => {\n            assert.strictEqual(code, 1006);\n            server.close(done);\n          });\n        });\n        ws.on('redirect', () => {\n          ws.terminate();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'upgrade' event","suites":["WebSocket","#terminate"],"updatePoint":{"line":2318,"column":60,"index":89054},"line":2318,"code":"    it(\"can be called from a listener of the 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.on('upgrade', () => ws.terminate());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CLOSED`","suites":["WebSocket","#terminate"],"updatePoint":{"line":2332,"column":48,"index":89643},"line":2332,"code":"    it('does nothing if `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.terminate();\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.terminate());\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `on{close,error,message,open}` attributes","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2348,"column":62,"index":90186},"line":2348,"code":"    it('supports the `on{close,error,message,open}` attributes', () => {\n      for (const property of ['onclose', 'onerror', 'onmessage', 'onopen']) {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, property);\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set !== undefined);\n      }\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      assert.strictEqual(ws.onmessage, null);\n      assert.strictEqual(ws.onclose, null);\n      assert.strictEqual(ws.onerror, null);\n      assert.strictEqual(ws.onopen, null);\n      ws.onmessage = NOOP;\n      ws.onerror = NOOP;\n      ws.onclose = NOOP;\n      ws.onopen = NOOP;\n      assert.strictEqual(ws.onmessage, NOOP);\n      assert.strictEqual(ws.onclose, NOOP);\n      assert.strictEqual(ws.onerror, NOOP);\n      assert.strictEqual(ws.onopen, NOOP);\n      ws.onmessage = 'foo';\n      assert.strictEqual(ws.onmessage, null);\n      assert.strictEqual(ws.listenerCount('message'), 0);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works like the `EventEmitter` interface","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2375,"column":47,"index":91324},"line":2375,"code":"    it('works like the `EventEmitter` interface', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.onmessage = messageEvent => {\n          assert.strictEqual(messageEvent.data, 'foo');\n          ws.onclose = closeEvent => {\n            assert.strictEqual(closeEvent.wasClean, true);\n            assert.strictEqual(closeEvent.code, 1005);\n            assert.strictEqual(closeEvent.reason, '');\n            wss.close(done);\n          };\n          ws.close();\n        };\n        ws.onopen = () => ws.send('foo');\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't return listeners added with `on`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2400,"column":48,"index":92144},"line":2400,"code":"    it(\"doesn't return listeners added with `on`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.on('open', NOOP);\n      assert.deepStrictEqual(ws.listeners('open'), [NOOP]);\n      assert.strictEqual(ws.onopen, null);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't remove listeners added with `on`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2408,"column":48,"index":92435},"line":2408,"code":"    it(\"doesn't remove listeners added with `on`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.on('close', NOOP);\n      ws.onclose = NOOP;\n      let listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.onclose = NOOP;\n      listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `addEventListener` method","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2424,"column":46,"index":93058},"line":2424,"code":"    it('supports the `addEventListener` method', () => {\n      const events = [];\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('foo', () => {});\n      assert.strictEqual(ws.listenerCount('foo'), 0);\n      function onOpen() {\n        events.push('open');\n        assert.strictEqual(ws.listenerCount('open'), 1);\n      }\n      ws.addEventListener('open', onOpen);\n      ws.addEventListener('open', onOpen);\n      assert.strictEqual(ws.listenerCount('open'), 1);\n      const listener = {\n        handleEvent() {\n          events.push('message');\n          assert.strictEqual(this, listener);\n          assert.strictEqual(ws.listenerCount('message'), 0);\n        }\n      };\n      ws.addEventListener('message', listener, {\n        once: true\n      });\n      ws.addEventListener('message', listener);\n      assert.strictEqual(ws.listenerCount('message'), 1);\n      ws.addEventListener('close', NOOP);\n      ws.onclose = NOOP;\n      let listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.onerror = NOOP;\n      ws.addEventListener('error', NOOP);\n      listeners = ws.listeners('error');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.emit('open');\n      ws.emit('message', EMPTY_BUFFER, false);\n      assert.deepStrictEqual(events, ['open', 'message']);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't return listeners added with `addEventListener`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2466,"column":62,"index":94682},"line":2466,"code":"    it(\"doesn't return listeners added with `addEventListener`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('open', NOOP);\n      const listeners = ws.listeners('open');\n      assert.strictEqual(listeners.length, 1);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(ws.onopen, null);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't remove listeners added with `addEventListener`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2476,"column":62,"index":95091},"line":2476,"code":"    it(\"doesn't remove listeners added with `addEventListener`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('close', NOOP);\n      ws.onclose = NOOP;\n      let listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.onclose = NOOP;\n      listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `removeEventListener` method","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2492,"column":49,"index":95753},"line":2492,"code":"    it('supports the `removeEventListener` method', () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      const listener = {\n        handleEvent() {}\n      };\n      ws.addEventListener('message', listener);\n      ws.addEventListener('open', NOOP);\n      assert.strictEqual(ws.listeners('message')[0][kListener], listener);\n      assert.strictEqual(ws.listeners('open')[0][kListener], NOOP);\n      ws.removeEventListener('message', () => {});\n      assert.strictEqual(ws.listeners('message')[0][kListener], listener);\n      ws.removeEventListener('message', listener);\n      ws.removeEventListener('open', NOOP);\n      assert.strictEqual(ws.listenerCount('message'), 0);\n      assert.strictEqual(ws.listenerCount('open'), 0);\n      ws.addEventListener('message', NOOP, {\n        once: true\n      });\n      ws.addEventListener('open', NOOP, {\n        once: true\n      });\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      assert.strictEqual(ws.listeners('open')[0][kListener], NOOP);\n      ws.removeEventListener('message', () => {});\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      ws.removeEventListener('message', NOOP);\n      ws.removeEventListener('open', NOOP);\n      assert.strictEqual(ws.listenerCount('message'), 0);\n      assert.strictEqual(ws.listenerCount('open'), 0);\n\n      // Listeners not added with `websocket.addEventListener()`.\n      ws.on('message', NOOP);\n      assert.deepStrictEqual(ws.listeners('message'), [NOOP]);\n      ws.removeEventListener('message', NOOP);\n      assert.deepStrictEqual(ws.listeners('message'), [NOOP]);\n      ws.onclose = NOOP;\n      assert.strictEqual(ws.listeners('close')[0][kListener], NOOP);\n      ws.removeEventListener('close', NOOP);\n      assert.strictEqual(ws.listeners('close')[0][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"wraps text data in a `MessageEvent`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2534,"column":43,"index":97622},"line":2534,"code":"    it('wraps text data in a `MessageEvent`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('open', () => {\n          ws.send('hi');\n          ws.close();\n        });\n        ws.addEventListener('message', event => {\n          assert.ok(event instanceof MessageEvent);\n          assert.strictEqual(event.data, 'hi');\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"receives a `CloseEvent` when server closes (1000)","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2557,"column":57,"index":98321},"line":2557,"code":"    it('receives a `CloseEvent` when server closes (1000)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.ok(event.wasClean);\n          assert.strictEqual(event.reason, '');\n          assert.strictEqual(event.code, 1000);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1000));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"receives a `CloseEvent` when server closes (4000)","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2572,"column":57,"index":98877},"line":2572,"code":"    it('receives a `CloseEvent` when server closes (4000)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.ok(event.wasClean);\n          assert.strictEqual(event.reason, 'some daft reason');\n          assert.strictEqual(event.code, 4000);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(4000, 'some daft reason'));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sets `target` and `type` on events","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2587,"column":42,"index":99454},"line":2587,"code":"    it('sets `target` and `type` on events', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const err = new Error('forced');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('open', event => {\n          assert.ok(event instanceof Event);\n          assert.strictEqual(event.type, 'open');\n          assert.strictEqual(event.target, ws);\n        });\n        ws.addEventListener('message', event => {\n          assert.ok(event instanceof MessageEvent);\n          assert.strictEqual(event.type, 'message');\n          assert.strictEqual(event.target, ws);\n          ws.close();\n        });\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.strictEqual(event.type, 'close');\n          assert.strictEqual(event.target, ws);\n          ws.emit('error', err);\n        });\n        ws.addEventListener('error', event => {\n          assert.ok(event instanceof ErrorEvent);\n          assert.strictEqual(event.message, 'forced');\n          assert.strictEqual(event.type, 'error');\n          assert.strictEqual(event.target, ws);\n          assert.strictEqual(event.error, err);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', client => client.send('hi'));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"passes binary data as a Node.js `Buffer` by default","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2621,"column":59,"index":100810},"line":2621,"code":"    it('passes binary data as a Node.js `Buffer` by default', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.onmessage = evt => {\n          assert.ok(Buffer.isBuffer(evt.data));\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.send(new Uint8Array(4096));\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"ignores `binaryType` for text messages","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2636,"column":46,"index":101257},"line":2636,"code":"    it('ignores `binaryType` for text messages', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.binaryType = 'arraybuffer';\n        ws.onmessage = evt => {\n          assert.strictEqual(evt.data, 'foo');\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to update `binaryType` on the fly","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2652,"column":48,"index":101729},"line":2652,"code":"    it('allows to update `binaryType` on the fly', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        function testType(binaryType, next) {\n          const buf = Buffer.from(binaryType);\n          ws.binaryType = binaryType;\n          ws.onmessage = evt => {\n            if (binaryType === 'nodebuffer') {\n              assert.ok(Buffer.isBuffer(evt.data));\n              assert.ok(evt.data.equals(buf));\n            } else if (binaryType === 'arraybuffer') {\n              assert.ok(evt.data instanceof ArrayBuffer);\n              assert.ok(Buffer.from(evt.data).equals(buf));\n            } else if (binaryType === 'fragments') {\n              assert.deepStrictEqual(evt.data, [buf]);\n            }\n            next();\n          };\n          ws.send(buf);\n        }\n        ws.onopen = () => {\n          testType('nodebuffer', () => {\n            testType('arraybuffer', () => {\n              testType('fragments', () => {\n                ws.close();\n                wss.close(done);\n              });\n            });\n          });\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects to secure websocket server","suites":["WebSocket","SSL"],"updatePoint":{"line":2694,"column":43,"index":103091},"line":2694,"code":"    it('connects to secure websocket server', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', () => {\n        server.close(done);\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://127.0.0.1:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects to secure websocket server with client side certificate","suites":["WebSocket","SSL"],"updatePoint":{"line":2712,"column":72,"index":103694},"line":2712,"code":"    it('connects to secure websocket server with client side certificate', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        ca: [fs.readFileSync('test/fixtures/ca-certificate.pem')],\n        key: fs.readFileSync('test/fixtures/key.pem'),\n        requestCert: true\n      });\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      server.on('upgrade', (request, socket, head) => {\n        assert.ok(socket.authorized);\n        wss.handleUpgrade(request, socket, head, ws => {\n          ws.on('close', code => {\n            assert.strictEqual(code, 1005);\n            server.close(done);\n          });\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          cert: fs.readFileSync('test/fixtures/client-certificate.pem'),\n          key: fs.readFileSync('test/fixtures/client-key.pem'),\n          rejectUnauthorized: false\n        });\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"cannot connect to secure websocket server via ws://","suites":["WebSocket","SSL"],"updatePoint":{"line":2740,"column":59,"index":104748},"line":2740,"code":"    it('cannot connect to secure websocket server via ws://', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('error', () => {\n          server.close(done);\n          wss.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send and receive text data","suites":["WebSocket","SSL"],"updatePoint":{"line":2758,"column":38,"index":105306},"line":2758,"code":"    it('can send and receive text data', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('foobar'));\n          assert.ok(!isBinary);\n          server.close(done);\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', () => {\n          ws.send('foobar');\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a big binary message","suites":["WebSocket","SSL"],"updatePoint":{"line":2783,"column":37,"index":106096},"line":2783,"code":"    it('can send a big binary message', done => {\n      const buf = crypto.randomBytes(5 * 1024 * 1024);\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(message);\n          ws.close();\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', () => ws.send(buf));\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, buf);\n          assert.ok(isBinary);\n          server.close(done);\n        });\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to disable sending the SNI extension","suites":["WebSocket","SSL"],"updatePoint":{"line":2811,"column":51,"index":107043},"line":2811,"code":"    it('allows to disable sending the SNI extension', done => {\n      const original = tls.connect;\n      tls.connect = options => {\n        assert.strictEqual(options.servername, '');\n        tls.connect = original;\n        done();\n      };\n      const ws = new WebSocket('wss://127.0.0.1', {\n        servername: ''\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works around a double 'error' event bug in Node.js","suites":["WebSocket","SSL"],"updatePoint":{"line":2822,"column":58,"index":107385},"line":2822,"code":"    it(\"works around a double 'error' event bug in Node.js\", function (done) {\n      //\n      // The `minVersion` and `maxVersion` options are not supported in\n      // Node.js < 10.16.0.\n      //\n      if (process.versions.modules < 64) return this.skip();\n\n      //\n      // The `'error'` event can be emitted multiple times by the\n      // `http.ClientRequest` object in Node.js < 13. This test reproduces the\n      // issue in Node.js 12.\n      //\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem'),\n        minVersion: 'TLSv1.2'\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          maxVersion: 'TLSv1.1',\n          rejectUnauthorized: false\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          server.close(done);\n          wss.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"adds the authorization header if the url has userinfo","suites":["WebSocket","Request headers"],"updatePoint":{"line":2856,"column":61,"index":108500},"line":2856,"code":"    it('adds the authorization header if the url has userinfo', done => {\n      const agent = new CustomAgent();\n      const userinfo = 'test:testpass';\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(userinfo).toString('base64')}`);\n        done();\n      };\n      const ws = new WebSocket(`ws://${userinfo}@localhost`, {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `auth` option","suites":["WebSocket","Request headers"],"updatePoint":{"line":2867,"column":32,"index":108891},"line":2867,"code":"    it('honors the `auth` option', done => {\n      const agent = new CustomAgent();\n      const auth = 'user:pass';\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(auth).toString('base64')}`);\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        agent,\n        auth\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"favors the url userinfo over the `auth` option","suites":["WebSocket","Request headers"],"updatePoint":{"line":2879,"column":54,"index":109294},"line":2879,"code":"    it('favors the url userinfo over the `auth` option', done => {\n      const agent = new CustomAgent();\n      const auth = 'foo:bar';\n      const userinfo = 'baz:qux';\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(userinfo).toString('base64')}`);\n        done();\n      };\n      const ws = new WebSocket(`ws://${userinfo}@localhost`, {\n        agent,\n        auth\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"adds custom headers","suites":["WebSocket","Request headers"],"updatePoint":{"line":2892,"column":27,"index":109718},"line":2892,"code":"    it('adds custom headers', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('cookie'), 'foo=bar');\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        headers: {\n          Cookie: 'foo=bar'\n        },\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"excludes default ports from host header","suites":["WebSocket","Request headers"],"updatePoint":{"line":2905,"column":47,"index":110081},"line":2905,"code":"    it('excludes default ports from host header', () => {\n      const options = {\n        lookup() {}\n      };\n      const variants = [['wss://localhost:8443', 'localhost:8443'], ['wss://localhost:443', 'localhost'], ['ws://localhost:88', 'localhost:88'], ['ws://localhost:80', 'localhost']];\n      for (const [url, host] of variants) {\n        const ws = new WebSocket(url, options);\n        assert.strictEqual(ws._req.getHeader('host'), host);\n      }\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't add the origin header by default","suites":["WebSocket","Request headers"],"updatePoint":{"line":2915,"column":48,"index":110544},"line":2915,"code":"    it(\"doesn't add the origin header by default\", done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('origin'), undefined);\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `origin` option (1/2)","suites":["WebSocket","Request headers"],"updatePoint":{"line":2925,"column":40,"index":110842},"line":2925,"code":"    it('honors the `origin` option (1/2)', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('origin'), 'https://example.com:8000');\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        origin: 'https://example.com:8000',\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `origin` option (2/2)","suites":["WebSocket","Request headers"],"updatePoint":{"line":2936,"column":40,"index":111201},"line":2936,"code":"    it('honors the `origin` option (2/2)', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-origin'), 'https://example.com:8000');\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        origin: 'https://example.com:8000',\n        protocolVersion: 8,\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enabled by default","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2950,"column":29,"index":111638},"line":2950,"code":"    it('is enabled by default', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), 'permessage-deflate; client_max_window_bits');\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be disabled","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2960,"column":23,"index":111972},"line":2960,"code":"    it('can be disabled', done => {\n      const agent = new CustomAgent();\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), undefined);\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        perMessageDeflate: false,\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send extension parameters","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2971,"column":37,"index":112319},"line":2971,"code":"    it('can send extension parameters', done => {\n      const agent = new CustomAgent();\n      const value = 'permessage-deflate; server_no_context_takeover;' + ' client_no_context_takeover; server_max_window_bits=10;' + ' client_max_window_bits';\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), value);\n        done();\n      };\n      const ws = new WebSocket('ws://localhost', {\n        perMessageDeflate: {\n          clientNoContextTakeover: true,\n          serverNoContextTakeover: true,\n          clientMaxWindowBits: true,\n          serverMaxWindowBits: 10\n        },\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"consumes all received data when connection is closed (1/2)","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2988,"column":66,"index":113009},"line":2988,"code":"    it('consumes all received data when connection is closed (1/2)', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          threshold: 0\n        },\n        port: 0\n      }, () => {\n        const messages = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.on('close', () => {\n            assert.strictEqual(ws._receiver._state, 5);\n          });\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz', 'qux']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.send('bar');\n        ws.send('baz');\n        ws.send('qux', () => ws._socket.end());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"consumes all received data when connection is closed (2/2)","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":3019,"column":66,"index":113991},"line":3019,"code":"    it('consumes all received data when connection is closed (2/2)', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const messageLengths = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.prependListener('close', () => {\n            assert.strictEqual(ws._receiver._state, 5);\n            assert.strictEqual(ws._socket._readableState.length, 3);\n          });\n          const push = ws._socket.push;\n\n          // Override `ws._socket.push()` to know exactly when data is\n          // received and call `ws.terminate()` immediately after that without\n          // relying on a timer.\n          ws._socket.push = data => {\n            ws._socket.push = push;\n            ws._socket.push(data);\n            ws.terminate();\n          };\n          const payload1 = Buffer.alloc(15 * 1024);\n          const payload2 = Buffer.alloc(1);\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(payload1, {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(payload2, {\n            rsv1: true,\n            ...opts\n          })];\n          for (let i = 0; i < 399; i++) {\n            list.push(list[list.length - 2], list[list.length - 1]);\n          }\n\n          // This hack is used because there is no guarantee that more than\n          // 16 KiB will be sent as a single TCP packet.\n          push.call(ws._socket, Buffer.concat(list));\n          wss.clients.values().next().value.send(payload2, {\n            compress: false\n          });\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.ok(isBinary);\n          messageLengths.push(message.length);\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.strictEqual(messageLengths.length, 402);\n          assert.strictEqual(messageLengths[0], 15360);\n          assert.strictEqual(messageLengths[messageLengths.length - 1], 1);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"handles a close frame received while compressing data","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":3080,"column":61,"index":116200},"line":3080,"code":"    it('handles a close frame received while compressing data', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n          perMessageDeflate: {\n            threshold: 0\n          }\n        });\n        ws.on('open', () => {\n          ws._receiver.on('conclude', () => {\n            assert.ok(ws._sender._deflating);\n          });\n          ws.send('foo');\n          ws.send('bar');\n          ws.send('baz');\n          ws.send('qux');\n        });\n      });\n      wss.on('connection', ws => {\n        const messages = [];\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', (code, reason) => {\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz', 'qux']);\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          wss.close(done);\n        });\n        ws.close(1000);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being decompressed","suites":["WebSocket","permessage-deflate","#close"],"updatePoint":{"line":3116,"column":54,"index":117321},"line":3116,"code":"      it('can be used while data is being decompressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const messages = [];\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            ws._socket.on('end', () => {\n              assert.strictEqual(ws._receiver._state, 5);\n            });\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.ok(!isBinary);\n            if (messages.push(message.toString()) > 1) return;\n            ws.close(1000);\n          });\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(messages, ['', '', '', '']);\n            assert.strictEqual(code, 1000);\n            assert.deepStrictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const buf = Buffer.from('c10100c10100c10100c10100', 'hex');\n          ws._socket.write(buf);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send text data","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3147,"column":28,"index":118402},"line":3147,"code":"      it('can send text data', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('hi', {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from('hi'));\n            assert.ok(!isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            ws.send(message, {\n              binary: isBinary,\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `TypedArray`","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3180,"column":33,"index":119343},"line":3180,"code":"      it('can send a `TypedArray`', done => {\n        const array = new Float32Array(5);\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 2;\n        }\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send(array, {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from(array.buffer));\n            assert.ok(isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            assert.ok(isBinary);\n            ws.send(message, {\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send an `ArrayBuffer`","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3217,"column":35,"index":120425},"line":3217,"code":"      it('can send an `ArrayBuffer`', done => {\n        const array = new Float32Array(5);\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 2;\n        }\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send(array.buffer, {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from(array.buffer));\n            assert.ok(isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            assert.ok(isBinary);\n            ws.send(message, {\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"ignores the `compress` option if the extension is disabled","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3254,"column":68,"index":121547},"line":3254,"code":"      it('ignores the `compress` option if the extension is disabled', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: false\n          });\n          ws.on('open', () => {\n            ws.send('hi', {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from('hi'));\n            assert.ok(!isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            ws.send(message, {\n              binary: isBinary,\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the socket is closed prematurely","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3282,"column":64,"index":122413},"line":3282,"code":"      it('calls the callback if the socket is closed prematurely', done => {\n        const called = [];\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('foo');\n            ws.send('bar', err => {\n              called.push(1);\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n            });\n            ws.send('baz');\n            ws.send('qux', err => {\n              called.push(2);\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n            });\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('close', () => {\n            assert.deepStrictEqual(called, [1, 2]);\n            wss.close(done);\n          });\n          ws._socket.end();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being compressed","suites":["WebSocket","permessage-deflate","#terminate"],"updatePoint":{"line":3320,"column":52,"index":123759},"line":3320,"code":"      it('can be used while data is being compressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('hi', err => {\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n              ws.on('close', () => {\n                wss.close(done);\n              });\n            });\n            ws.terminate();\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being decompressed","suites":["WebSocket","permessage-deflate","#terminate"],"updatePoint":{"line":3345,"column":54,"index":124594},"line":3345,"code":"      it('can be used while data is being decompressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          const messages = [];\n          ws.on('message', (message, isBinary) => {\n            assert.ok(!isBinary);\n            if (messages.push(message.toString()) > 1) return;\n            process.nextTick(() => {\n              assert.strictEqual(ws._receiver._state, 5);\n              ws.terminate();\n            });\n          });\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(messages, ['', '', '', '']);\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const buf = Buffer.from('c10100c10100c10100c10100', 'hex');\n          ws._socket.write(buf);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes cleanly after simultaneous errors (1/2)","suites":["WebSocket","Connection close"],"updatePoint":{"line":3375,"column":54,"index":125664},"line":3375,"code":"    it('closes cleanly after simultaneous errors (1/2)', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          // Write an invalid frame in both directions to trigger simultaneous\n          // failure.\n          const chunk = Buffer.from([0x85, 0x00]);\n          wss.clients.values().next().value._socket.write(chunk);\n          ws._socket.write(chunk);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes cleanly after simultaneous errors (2/2)","suites":["WebSocket","Connection close"],"updatePoint":{"line":3415,"column":54,"index":127349},"line":3415,"code":"    it('closes cleanly after simultaneous errors (2/2)', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          // Write an invalid frame in both directions and change the\n          // `readyState` to `WebSocket.CLOSING`.\n          const chunk = Buffer.from([0x85, 0x00]);\n          const serverWs = wss.clients.values().next().value;\n          serverWs._socket.write(chunk);\n          serverWs.close();\n          ws._socket.write(chunk);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket when an error occurs","suites":["WebSocket","Connection close"],"updatePoint":{"line":3458,"column":47,"index":129133},"line":3458,"code":"    it('resumes the socket when an error occurs', done => {\n      const maxPayload = 16 * 1024;\n      const wss = new WebSocket.Server({\n        maxPayload,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const list = [...Sender.frame(Buffer.alloc(maxPayload + 1), {\n          fin: true,\n          opcode: 0x02,\n          mask: true,\n          readOnly: false\n        })];\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n          assert.strictEqual(err.message, 'Max payload size exceeded');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        ws._socket.push(Buffer.concat(list));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket when the close frame is received","suites":["WebSocket","Connection close"],"updatePoint":{"line":3486,"column":59,"index":130121},"line":3486,"code":"    it('resumes the socket when the close frame is received', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const opts = {\n          fin: true,\n          mask: true,\n          readOnly: false\n        };\n        const list = [...Sender.frame(Buffer.alloc(16 * 1024), {\n          opcode: 0x02,\n          ...opts\n        }), ...Sender.frame(EMPTY_BUFFER, {\n          opcode: 0x08,\n          ...opts\n        })];\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1005);\n          assert.strictEqual(reason, EMPTY_BUFFER);\n          wss.close(done);\n        });\n        ws._socket.push(Buffer.concat(list));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"}]}