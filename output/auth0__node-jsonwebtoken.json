{"repo":"auth0/node-jsonwebtoken","url":"https://github.com/auth0/node-jsonwebtoken","branch":"master","configs":[{"package":"jsonwebtoken","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should error with with value ","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":26,"column":64,"index":822},"line":26,"code":"      it(`should error with with value ${util.inspect(audience)}`, function (done) {\n        signWithAudience(audience, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"audience\" must be a string or array');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":37,"column":46,"index":1257},"line":37,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        audience: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"audience\" must be a string or array');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error when \"aud\" is in payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":48,"column":45,"index":1653},"line":48,"code":"    it('should error when \"aud\" is in payload', function (done) {\n      signWithAudience('my_aud', {\n        aud: ''\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.audience\" option. The payload already has an \"aud\" property.');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":58,"column":42,"index":2033},"line":58,"code":"    it('should error with a string payload', function (done) {\n      signWithAudience('my_aud', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for string payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["audience","`jwt.sign` \"audience\" option validation"],"updatePoint":{"line":66,"column":42,"index":2375},"line":66,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithAudience('my_aud', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for object payload');\n        });\n      });\n    });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":85,"column":95,"index":3311},"line":85,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud', 'urn:foo');\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":94,"column":73,"index":3674},"line":94,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":102,"column":83,"index":4084},"line":102,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":110,"column":72,"index":4525},"line":110,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":118,"column":82,"index":4940},"line":118,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with a \"aud\" of \"urn:foo\" in payload"],"updatePoint":{"line":126,"column":100,"index":5421},"line":126,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode with verify \"audience\" option of ","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":144,"column":95,"index":6371},"line":144,"code":"        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":153,"column":73,"index":6759},"line":153,"code":"      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":161,"column":83,"index":7169},"line":161,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":169,"column":72,"index":7610},"line":169,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":177,"column":82,"index":8025},"line":177,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"],"updatePoint":{"line":185,"column":100,"index":8506},"line":185,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of stings verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":194,"column":74,"index":9040},"line":194,"code":"        it('should verify with an array of stings verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:foo', 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":202,"column":63,"index":9422},"line":202,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:[a-z]{3}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching on both \"urn:foo\" and \"urn:bar\""],"updatePoint":{"line":210,"column":73,"index":9808},"line":210,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:f[o]{2}$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":220,"column":57,"index":10282},"line":220,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:foo', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":228,"column":63,"index":10651},"line":228,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:f[o]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":236,"column":66,"index":11029},"line":236,"code":"        it('should verify with an array of Regex verify \"audience\"', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":244,"column":96,"index":11457},"line":244,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking for a matching for \"urn:foo\""],"updatePoint":{"line":252,"column":96,"index":11883},"line":252,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:foo'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string verify \"audience\"","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":262,"column":57,"index":12345},"line":262,"code":"        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:bar', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":270,"column":63,"index":12714},"line":270,"code":"        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:b[ar]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":278,"column":73,"index":13100},"line":278,"code":"        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a string and a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":286,"column":96,"index":13529},"line":286,"code":"        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify with an array containing a Regex and a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload","when checking matching for \"urn:bar\""],"updatePoint":{"line":294,"column":96,"index":13956},"line":294,"code":"        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should verify and decode without verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":312,"column":67,"index":14600},"line":312,"code":"      it('should verify and decode without verify \"audience\" option', function (done) {\n        verifyWithAudience(token, undefined, (err, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.null;\n            expect(decoded).to.not.have.property('aud');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":320,"column":73,"index":14933},"line":320,"code":"      it('should error on no match with a string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of string verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":328,"column":83,"index":15343},"line":328,"code":"      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with a Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":336,"column":72,"index":15784},"line":336,"code":"      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of Regex verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":344,"column":82,"index":16199},"line":344,"code":"      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error on no match with an array of a Regex and a string in verify \"audience\" option","suites":["audience","when signing and verifying a token with \"audience\" option","without a \"aud\" value in payload"],"updatePoint":{"line":352,"column":100,"index":16680},"line":352,"code":"      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match');\n          });\n        });\n      });","file":"claim-aud.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":24,"column":65,"index":866},"line":24,"code":"      it(`should error with with value ${util.inspect(expiresIn)}`, function (done) {\n        signWithExpiresIn(expiresIn, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"expiresIn\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":35,"column":46,"index":1354},"line":35,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        expiresIn: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"expiresIn\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error when \"exp\" is in payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":46,"column":45,"index":1791},"line":46,"code":"    it('should error when \"exp\" is in payload', function (done) {\n      signWithExpiresIn(100, {\n        exp: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.expiresIn\" option the payload already has an \"exp\" property.');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":56,"column":42,"index":2168},"line":56,"code":"    it('should error with a string payload', function (done) {\n      signWithExpiresIn(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for string payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["expires","`jwt.sign` \"expiresIn\" option validation"],"updatePoint":{"line":64,"column":42,"index":2507},"line":64,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithExpiresIn(100, Buffer.from('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for object payload');\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","`jwt.sign` \"exp\" claim validation"],"updatePoint":{"line":77,"column":59,"index":3059},"line":77,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        signWithExpiresIn(undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"exp\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["expires","\"exp\" in payload validation"],"updatePoint":{"line":93,"column":59,"index":3634},"line":93,"code":"      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          exp\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid exp value');\n          });\n        });\n      });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":119,"column":64,"index":4472},"line":119,"code":"    it('should set correct \"exp\" with negative number of seconds', function (done) {\n      signWithExpiresIn(-10, {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive number of seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":131,"column":64,"index":4930},"line":131,"code":"    it('should set correct \"exp\" with positive number of seconds', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero seconds","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":142,"column":50,"index":5341},"line":142,"code":"    it('should set correct \"exp\" with zero seconds', function (done) {\n      signWithExpiresIn(0, {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with negative string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":154,"column":62,"index":5791},"line":154,"code":"    it('should set correct \"exp\" with negative string timespan', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with positive string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":166,"column":62,"index":6251},"line":166,"code":"    it('should set correct \"exp\" with positive string timespan', function (done) {\n      signWithExpiresIn('10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" with zero string timespan","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":178,"column":58,"index":6706},"line":178,"code":"    it('should set correct \"exp\" with zero string timespan', function (done) {\n      signWithExpiresIn('0 s', {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given -Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":192,"column":50,"index":7204},"line":192,"code":"    it('should set null \"exp\" when given -Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value Infinity","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":205,"column":55,"index":7629},"line":205,"code":"    it('should set null \"exp\" when given value Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set null \"exp\" when given value NaN","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":218,"column":50,"index":8043},"line":218,"code":"    it('should set null \"exp\" when given value NaN', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"exp\" when \"iat\" is passed","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":229,"column":53,"index":8405},"line":229,"code":"    it('should set correct \"exp\" when \"iat\" is passed', function (done) {\n      signWithExpiresIn(-10, {\n        iat: 80\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTimestamp\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":242,"column":50,"index":8840},"line":242,"code":"    it('should verify \"exp\" using \"clockTimestamp\"', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 69\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should verify \"exp\" using \"clockTolerance\"","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":256,"column":50,"index":9346},"line":256,"code":"    it('should verify \"exp\" using \"clockTolerance\"', function (done) {\n      signWithExpiresIn(5, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 65);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should ignore a expired token when \"ignoreExpiration\" is true","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":271,"column":69,"index":9900},"line":271,"code":"    it('should ignore a expired token when \"ignoreExpiration\" is true', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreExpiration: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is at current time","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":285,"column":58,"index":10423},"line":285,"code":"    it('should error on verify if \"exp\" is at current time', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: 60\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"exp\" is before current time using clockTolerance","suites":["expires","when signing and verifying a token with expires option"],"updatePoint":{"line":298,"column":83,"index":10925},"line":298,"code":"    it('should error on verify if \"exp\" is before current time using clockTolerance', function (done) {\n      signWithExpiresIn(-5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 5\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });","file":"claim-exp.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":33,"column":55,"index":1118},"line":33,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        signWithIssueAt(iat, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err.message).to.equal('\"iat\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of undefined","suites":["issue at","`jwt.sign` \"iat\" claim validation"],"updatePoint":{"line":44,"column":42,"index":1531},"line":44,"code":"    it('should error with iat of undefined', function (done) {\n      testUtils.signJWTHelper({\n        iat: undefined\n      }, 'secret', {\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err.message).to.equal('\"iat\" should be a number of seconds');\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with iat of ","suites":["issue at","\"iat\" in payload with \"maxAge\" option validation"],"updatePoint":{"line":61,"column":55,"index":2145},"line":61,"code":"      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          iat\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        verifyWithIssueAt(token, '1 min', {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err.message).to.equal('iat required when maxAge is specified');\n          });\n        });\n      });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to string","suites":["issue at","with string payload"],"updatePoint":{"line":234,"column":36,"index":7432},"line":234,"code":"    it('should not add iat to string', function (done) {\n      const payload = 'string payload';\n      const options = {\n        algorithm: 'none'\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should not add iat to stringified object","suites":["issue at","with string payload"],"updatePoint":{"line":247,"column":48,"index":7871},"line":247,"code":"    it('should not add iat to stringified object', function (done) {\n      const payload = '{}';\n      const options = {\n        algorithm: 'none',\n        header: {\n          typ: 'JWT'\n        }\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.equal(null);\n          expect(JSON.stringify(decoded)).to.equal(payload);\n        });\n      });\n    });","file":"claim-iat.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":21,"column":62,"index":681},"line":21,"code":"      it(`should error with with value ${util.inspect(issuer)}`, function (done) {\n        signWithIssuer(issuer, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"issuer\" must be a string');\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":32,"column":46,"index":1104},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        issuer: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"issuer\" must be a string');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error when \"iss\" is in payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":43,"column":45,"index":1488},"line":43,"code":"    it('should error when \"iss\" is in payload', function (done) {\n      signWithIssuer('foo', {\n        iss: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.issuer\" option. The payload already has an \"iss\" property.');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":53,"column":42,"index":1864},"line":53,"code":"    it('should error with a string payload', function (done) {\n      signWithIssuer('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for string payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["issuer","`jwt.sign` \"issuer\" option validation"],"updatePoint":{"line":61,"column":42,"index":2199},"line":61,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithIssuer('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for object payload');\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"iss\" if verify \"issuer\" option not provided","suites":["issuer","when signing and verifying a token"],"updatePoint":{"line":71,"column":70,"index":2643},"line":71,"code":"    it('should not verify \"iss\" if verify \"issuer\" option not provided', function (done) {\n      signWithIssuer(undefined, {\n        iss: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iss', 'foo');\n          });\n        });\n      });\n    });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":85,"column":46,"index":3141},"line":85,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":98,"column":43,"index":3605},"line":98,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":113,"column":69,"index":4129},"line":113,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with string \"issuer\" option"],"updatePoint":{"line":128,"column":68,"index":4702},"line":128,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"issuer\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":143,"column":46,"index":5285},"line":143,"code":"      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('bar', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should verify with a string \"iss\"","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":156,"column":43,"index":5758},"line":156,"code":"      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error if \"iss\" does not match verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":171,"column":69,"index":6291},"line":171,"code":"      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error without \"iss\" and with verify \"issuer\" option","suites":["issuer","when signing and verifying a token","with array \"issuer\" option"],"updatePoint":{"line":186,"column":68,"index":6877},"line":186,"code":"      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });","file":"claim-iss.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":21,"column":61,"index":672},"line":21,"code":"      it(`should error with with value ${util.inspect(jwtid)}`, function (done) {\n        signWithJWTId(jwtid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"jwtid\" must be a string');\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":32,"column":46,"index":1091},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        jwtid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"jwtid\" must be a string');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error when \"jti\" is in payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":43,"column":45,"index":1473},"line":43,"code":"    it('should error when \"jti\" is in payload', function (done) {\n      signWithJWTId('foo', {\n        jti: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.jwtid\" option. The payload already has an \"jti\" property.');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":53,"column":42,"index":1847},"line":53,"code":"    it('should error with a string payload', function (done) {\n      signWithJWTId('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for string payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["jwtid","`jwt.sign` \"jwtid\" option validation"],"updatePoint":{"line":61,"column":42,"index":2180},"line":61,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithJWTId('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for object payload');\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should not verify \"jti\" if verify \"jwtid\" option not provided","suites":["jwtid","when signing and verifying a token"],"updatePoint":{"line":71,"column":69,"index":2621},"line":71,"code":"    it('should not verify \"jti\" if verify \"jwtid\" option not provided', function (done) {\n      signWithJWTId(undefined, {\n        jti: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('jti', 'foo');\n          });\n        });\n      });\n    });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":85,"column":43,"index":3107},"line":85,"code":"      it('should verify with \"jwtid\" option', function (done) {\n        signWithJWTId('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should verify with \"jti\" in payload","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":98,"column":45,"index":3571},"line":98,"code":"      it('should verify with \"jti\" in payload', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jetid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error if \"jti\" does not match verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":113,"column":68,"index":4092},"line":113,"code":"      it('should error if \"jti\" does not match verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'bar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error without \"jti\" and with verify \"jwtid\" option","suites":["jwtid","when signing and verifying a token","with \"jwtid\" option"],"updatePoint":{"line":128,"column":67,"index":4658},"line":128,"code":"      it('should error without \"jti\" and with verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });","file":"claim-jti.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":24,"column":65,"index":869},"line":24,"code":"      it(`should error with with value ${util.inspect(notBefore)}`, function (done) {\n        signWithNotBefore(notBefore, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"notBefore\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":35,"column":46,"index":1357},"line":35,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        notBefore: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"notBefore\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error when \"nbf\" is in payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":46,"column":45,"index":1794},"line":46,"code":"    it('should error when \"nbf\" is in payload', function (done) {\n      signWithNotBefore(100, {\n        nbf: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.notBefore\" option the payload already has an \"nbf\" property.');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a string payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":56,"column":42,"index":2171},"line":56,"code":"    it('should error with a string payload', function (done) {\n      signWithNotBefore(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for string payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with a Buffer payload","suites":["not before","`jwt.sign` \"notBefore\" option validation"],"updatePoint":{"line":64,"column":42,"index":2510},"line":64,"code":"    it('should error with a Buffer payload', function (done) {\n      signWithNotBefore(100, new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for object payload');\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","`jwt.sign` \"nbf\" claim validation"],"updatePoint":{"line":77,"column":59,"index":3061},"line":77,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        signWithNotBefore(undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"nbf\" should be a number of seconds');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["not before","\"nbf\" in payload validation"],"updatePoint":{"line":93,"column":59,"index":3636},"line":93,"code":"      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          nbf\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid nbf value');\n          });\n        });\n      });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":119,"column":64,"index":4478},"line":119,"code":"    it('should set correct \"nbf\" with negative number of seconds', function (done) {\n      signWithNotBefore(-10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive number of seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":130,"column":64,"index":4904},"line":130,"code":"    it('should set correct \"nbf\" with positive number of seconds', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero seconds","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":142,"column":50,"index":5346},"line":142,"code":"    it('should set correct \"nbf\" with zero seconds', function (done) {\n      signWithNotBefore(0, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with negative string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":153,"column":62,"index":5768},"line":153,"code":"    it('should set correct \"nbf\" with negative string timespan', function (done) {\n      signWithNotBefore('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with positive string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":164,"column":62,"index":6196},"line":164,"code":"    it('should set correct \"nbf\" with positive string timespan', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" with zero string timespan","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":176,"column":58,"index":6650},"line":176,"code":"    it('should set correct \"nbf\" with zero string timespan', function (done) {\n      signWithNotBefore('0 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given -Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":189,"column":50,"index":7120},"line":189,"code":"    it('should set null \"nbf\" when given -Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value Infinity","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":202,"column":55,"index":7545},"line":202,"code":"    it('should set null \"nbf\" when given value Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set null \"nbf\" when given value NaN","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":215,"column":50,"index":7959},"line":215,"code":"    it('should set null \"nbf\" when given value NaN', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should set correct \"nbf\" when \"iat\" is passed","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":226,"column":53,"index":8321},"line":226,"code":"    it('should set correct \"nbf\" when \"iat\" is passed', function (done) {\n      signWithNotBefore(-10, {\n        iat: 40\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 30);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTimestamp\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":239,"column":50,"index":8756},"line":239,"code":"    it('should verify \"nbf\" using \"clockTimestamp\"', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 70\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should verify \"nbf\" using \"clockTolerance\"","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":253,"column":50,"index":9262},"line":253,"code":"    it('should verify \"nbf\" using \"clockTolerance\"', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 65);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should ignore a not active token when \"ignoreNotBefore\" is true","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":267,"column":71,"index":9787},"line":267,"code":"    it('should ignore a not active token when \"ignoreNotBefore\" is true', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreNotBefore: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":281,"column":61,"index":10311},"line":281,"code":"    it('should error on verify if \"nbf\" is after current time', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: 61\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error on verify if \"nbf\" is after current time using clockTolerance","suites":["not before","when signing and verifying a token with \"notBefore\" option"],"updatePoint":{"line":294,"column":82,"index":10812},"line":294,"code":"    it('should error on verify if \"nbf\" is after current time using clockTolerance', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 4\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });","file":"claim-nbf.test.js","skipped":false,"dir":"test"},{"name":"should error with with value ","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":21,"column":61,"index":672},"line":21,"code":"      it(`should error with with value ${util.inspect(keyid)}`, function (done) {\n        signWithKeyId(keyid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"keyid\" must be a string');\n          });\n        });\n      });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with with value undefined","suites":["keyid","`jwt.sign` \"keyid\" option validation"],"updatePoint":{"line":32,"column":46,"index":1091},"line":32,"code":"    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        keyid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"keyid\" must be a string');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should not add \"kid\" header when \"keyid\" option not provided","suites":["keyid","when signing a token"],"updatePoint":{"line":45,"column":68,"index":1551},"line":45,"code":"    it('should not add \"kid\" header when \"keyid\" option not provided', function (done) {\n      signWithKeyId(undefined, {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.not.have.property('kid');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and an object payload","suites":["keyid","when signing a token"],"updatePoint":{"line":56,"column":85,"index":1966},"line":56,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and an object payload', function (done) {\n      signWithKeyId('foo', {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a Buffer payload","suites":["keyid","when signing a token"],"updatePoint":{"line":67,"column":84,"index":2379},"line":67,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a Buffer payload', function (done) {\n      signWithKeyId('foo', new Buffer('a Buffer payload'), (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should add \"kid\" header when \"keyid\" option is provided and a string payload","suites":["keyid","when signing a token"],"updatePoint":{"line":78,"column":84,"index":2820},"line":78,"code":"    it('should add \"kid\" header when \"keyid\" option is provided and a string payload', function (done) {\n      signWithKeyId('foo', 'a string payload', (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });","file":"header-kid.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["maxAge option"],"updatePoint":{"line":51,"column":55,"index":1251},"line":51,"code":"    it(`should error with value ${util.inspect(maxAge)}`, function (done) {\n      expect(() => jwt.verify(token, undefined, {\n        maxAge\n      })).to.throw(jwt.JsonWebTokenError, '\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n      jwt.verify(token, undefined, {\n        maxAge\n      }, err => {\n        expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n        expect(err.message).to.equal('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n        done();\n      });\n    });","file":"option-maxAge.test.js","skipped":false,"dir":"test"},{"name":"should error with value ","suites":["nonce option"],"updatePoint":{"line":34,"column":54,"index":957},"line":34,"code":"    it(`should error with value ${util.inspect(nonce)}`, function (done) {\n      testUtils.verifyJWTHelper(token, undefined, {\n        nonce\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n          expect(err).to.have.property('message', 'nonce must be a non-empty string');\n        });\n      });\n    });","file":"option-nonce.test.js","skipped":false,"dir":"test"}]}