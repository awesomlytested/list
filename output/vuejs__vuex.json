{"repo":"vuejs/vuex","url":"https://github.com/vuejs/vuex","branch":"dev","configs":[{"package":"vuex","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"classic","suites":["e2e/cart"],"updatePoint":{"line":36,"column":15,"index":1525},"line":36,"code":"  test('classic', async () => {\n    await testCart('http://localhost:8080/classic/shopping-cart/');\n  }, E2E_TIMEOUT);","file":"e2e/cart.spec.js","skipped":false,"dir":"test"},{"name":"composition","suites":["e2e/cart"],"updatePoint":{"line":39,"column":19,"index":1648},"line":39,"code":"  test('composition', async () => {\n    await testCart('http://localhost:8080/composition/shopping-cart/');\n  }, E2E_TIMEOUT);","file":"e2e/cart.spec.js","skipped":false,"dir":"test"},{"name":"classic","suites":["e2e/chat"],"updatePoint":{"line":35,"column":15,"index":1690},"line":35,"code":"  test('classic', async () => {\n    await testChat('http://localhost:8080/classic/chat/');\n  }, E2E_TIMEOUT);","file":"e2e/chat.spec.js","skipped":false,"dir":"test"},{"name":"composition","suites":["e2e/chat"],"updatePoint":{"line":38,"column":19,"index":1804},"line":38,"code":"  test('composition', async () => {\n    await testChat('http://localhost:8080/composition/chat/');\n  }, E2E_TIMEOUT);","file":"e2e/chat.spec.js","skipped":false,"dir":"test"},{"name":"classic","suites":["e2e/counter"],"updatePoint":{"line":27,"column":15,"index":1010},"line":27,"code":"  test('classic', async () => {\n    await testCounter('http://localhost:8080/classic/counter/');\n  }, E2E_TIMEOUT);","file":"e2e/counter.spec.js","skipped":false,"dir":"test"},{"name":"composition","suites":["e2e/counter"],"updatePoint":{"line":30,"column":19,"index":1130},"line":30,"code":"  test('composition', async () => {\n    await testCounter('http://localhost:8080/composition/counter/');\n  }, E2E_TIMEOUT);","file":"e2e/counter.spec.js","skipped":false,"dir":"test"},{"name":"classic","suites":["e2e/todomvc"],"updatePoint":{"line":154,"column":15,"index":5658},"line":154,"code":"  test('classic', async () => {\n    await testTodoMVC('http://localhost:8080/classic/todomvc/');\n  }, E2E_TIMEOUT);","file":"e2e/todomvc.spec.js","skipped":false,"dir":"test"},{"name":"composition","suites":["e2e/todomvc"],"updatePoint":{"line":157,"column":19,"index":5778},"line":157,"code":"  test('composition', async () => {\n    await testTodoMVC('http://localhost:8080/composition/todomvc/');\n  }, E2E_TIMEOUT);","file":"e2e/todomvc.spec.js","skipped":false,"dir":"test"},{"name":"mapState (array)","suites":["Helpers"],"updatePoint":{"line":4,"column":22,"index":194},"line":4,"code":"  it('mapState (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      }\n    });\n    const vm = mount(store, {\n      computed: mapState(['a'])\n    });\n    expect(vm.a).toBe(1);\n    store.state.a++;\n    expect(vm.a).toBe(2);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (object)","suites":["Helpers"],"updatePoint":{"line":17,"column":23,"index":456},"line":17,"code":"  it('mapState (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      getters: {\n        b: () => 2\n      }\n    });\n    const vm = mount(store, {\n      computed: mapState({\n        a: (state, getters) => {\n          return state.a + getters.b;\n        }\n      })\n    });\n    expect(vm.a).toBe(3);\n    store.state.a++;\n    expect(vm.a).toBe(4);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with namespace)","suites":["Helpers"],"updatePoint":{"line":37,"column":31,"index":856},"line":37,"code":"  it('mapState (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          },\n          getters: {\n            b: state => state.a + 1\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: mapState('foo', {\n        a: (state, getters) => {\n          return state.a + getters.b;\n        }\n      })\n    });\n    expect(vm.a).toBe(3);\n    store.state.foo.a++;\n    expect(vm.a).toBe(5);\n    store.replaceState({\n      foo: {\n        a: 3\n      }\n    });\n    expect(vm.a).toBe(7);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with namespace and a nested module)","suites":["Helpers"],"updatePoint":{"line":70,"column":51,"index":1506},"line":70,"code":"  it('mapState (with namespace and a nested module)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          },\n          modules: {\n            bar: {\n              state: {\n                b: 2\n              }\n            }\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: mapState('foo', {\n        value: state => state\n      })\n    });\n    expect(vm.value.a).toBe(1);\n    expect(vm.value.bar.b).toBe(2);\n    expect(vm.value.b).toBeUndefined();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with undefined states)","suites":["Helpers"],"updatePoint":{"line":97,"column":38,"index":2076},"line":97,"code":"  it('mapState (with undefined states)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: mapState('foo')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapState: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (array)","suites":["Helpers"],"updatePoint":{"line":115,"column":26,"index":2569},"line":115,"code":"  it('mapMutations (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations(['inc', 'dec'])\n    });\n    vm.inc();\n    expect(store.state.count).toBe(1);\n    vm.dec();\n    expect(store.state.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (object)","suites":["Helpers"],"updatePoint":{"line":133,"column":27,"index":2985},"line":133,"code":"  it('mapMutations (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations({\n        plus: 'inc',\n        minus: 'dec'\n      })\n    });\n    vm.plus();\n    expect(store.state.count).toBe(1);\n    vm.minus();\n    expect(store.state.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (function)","suites":["Helpers"],"updatePoint":{"line":154,"column":29,"index":3443},"line":154,"code":"  it('mapMutations (function)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc(state, amount) {\n          state.count += amount;\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations({\n        plus(commit, amount) {\n          commit('inc', amount + 1);\n        }\n      })\n    });\n    vm.plus(42);\n    expect(store.state.count).toBe(43);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (with namespace)","suites":["Helpers"],"updatePoint":{"line":175,"column":35,"index":3890},"line":175,"code":"  it('mapMutations (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations('foo', {\n        plus: 'inc',\n        minus: 'dec'\n      })\n    });\n    vm.plus();\n    expect(store.state.foo.count).toBe(1);\n    vm.minus();\n    expect(store.state.foo.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (function with namepsace)","suites":["Helpers"],"updatePoint":{"line":201,"column":44,"index":4484},"line":201,"code":"  it('mapMutations (function with namepsace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc(state, amount) {\n              state.count += amount;\n            }\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations('foo', {\n        plus(commit, amount) {\n          commit('inc', amount + 1);\n        }\n      })\n    });\n    vm.plus(42);\n    expect(store.state.foo.count).toBe(43);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (with undefined mutations)","suites":["Helpers"],"updatePoint":{"line":227,"column":45,"index":5062},"line":227,"code":"  it('mapMutations (with undefined mutations)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapMutations('foo')\n    });\n    expect(vm.inc).toBeUndefined();\n    expect(vm.dec).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapMutations: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (array)","suites":["Helpers"],"updatePoint":{"line":250,"column":24,"index":5719},"line":250,"code":"  it('mapGetters (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      },\n      getters: {\n        hasAny: ({\n          count\n        }) => count > 0,\n        negative: ({\n          count\n        }) => count < 0\n      }\n    });\n    const vm = mount(store, {\n      computed: mapGetters(['hasAny', 'negative'])\n    });\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(false);\n    store.commit('inc');\n    expect(vm.hasAny).toBe(true);\n    expect(vm.negative).toBe(false);\n    store.commit('dec');\n    store.commit('dec');\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (object)","suites":["Helpers"],"updatePoint":{"line":281,"column":25,"index":6470},"line":281,"code":"  it('mapGetters (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      },\n      getters: {\n        hasAny: ({\n          count\n        }) => count > 0,\n        negative: ({\n          count\n        }) => count < 0\n      }\n    });\n    const vm = mount(store, {\n      computed: mapGetters({\n        a: 'hasAny',\n        b: 'negative'\n      })\n    });\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(false);\n    store.commit('inc');\n    expect(vm.a).toBe(true);\n    expect(vm.b).toBe(false);\n    store.commit('dec');\n    store.commit('dec');\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with namespace)","suites":["Helpers"],"updatePoint":{"line":315,"column":33,"index":7223},"line":315,"code":"  it('mapGetters (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          getters: {\n            hasAny: ({\n              count\n            }) => count > 0,\n            negative: ({\n              count\n            }) => count < 0\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: mapGetters('foo', {\n        a: 'hasAny',\n        b: 'negative'\n      })\n    });\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(false);\n    store.commit('foo/inc');\n    expect(vm.a).toBe(true);\n    expect(vm.b).toBe(false);\n    store.commit('foo/dec');\n    store.commit('foo/dec');\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with namespace and nested module)","suites":["Helpers"],"updatePoint":{"line":354,"column":51,"index":8151},"line":354,"code":"  it('mapGetters (with namespace and nested module)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          modules: {\n            bar: {\n              namespaced: true,\n              state: {\n                count: 0\n              },\n              mutations: {\n                inc: state => state.count++,\n                dec: state => state.count--\n              },\n              getters: {\n                hasAny: ({\n                  count\n                }) => count > 0,\n                negative: ({\n                  count\n                }) => count < 0\n              }\n            },\n            cat: {\n              state: {\n                count: 9\n              },\n              getters: {\n                count: ({\n                  count\n                }) => count\n              }\n            }\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: {\n        ...mapGetters('foo/bar', ['hasAny', 'negative']),\n        ...mapGetters('foo', ['count'])\n      }\n    });\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(false);\n    store.commit('foo/bar/inc');\n    expect(vm.hasAny).toBe(true);\n    expect(vm.negative).toBe(false);\n    store.commit('foo/bar/dec');\n    store.commit('foo/bar/dec');\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(true);\n    expect(vm.count).toBe(9);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with undefined getters)","suites":["Helpers"],"updatePoint":{"line":409,"column":41,"index":9559},"line":409,"code":"  it('mapGetters (with undefined getters)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          getters: {\n            hasAny: ({\n              count\n            }) => count > 0,\n            negative: ({\n              count\n            }) => count < 0\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      computed: mapGetters('foo')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(vm.b).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapGetters: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (array)","suites":["Helpers"],"updatePoint":{"line":440,"column":24,"index":10388},"line":440,"code":"  it('mapActions (array)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a,\n        b\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions(['a', 'b'])\n    });\n    vm.a();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.b();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (object)","suites":["Helpers"],"updatePoint":{"line":458,"column":25,"index":10775},"line":458,"code":"  it('mapActions (object)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a,\n        b\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions({\n        foo: 'a',\n        bar: 'b'\n      })\n    });\n    vm.foo();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.bar();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (function)","suites":["Helpers"],"updatePoint":{"line":479,"column":27,"index":11202},"line":479,"code":"  it('mapActions (function)', () => {\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions({\n        foo(dispatch, arg) {\n          dispatch('a', arg + 'bar');\n        }\n      })\n    });\n    vm.foo('foo');\n    expect(a.mock.calls[0][1]).toBe('foobar');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (with namespace)","suites":["Helpers"],"updatePoint":{"line":496,"column":33,"index":11573},"line":496,"code":"  it('mapActions (with namespace)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a,\n            b\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions('foo/', {\n        foo: 'a',\n        bar: 'b'\n      })\n    });\n    vm.foo();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.bar();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (function with namespace)","suites":["Helpers"],"updatePoint":{"line":522,"column":42,"index":12117},"line":522,"code":"  it('mapActions (function with namespace)', () => {\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions('foo/', {\n        foo(dispatch, arg) {\n          dispatch('a', arg + 'bar');\n        }\n      })\n    });\n    vm.foo('foo');\n    expect(a.mock.calls[0][1]).toBe('foobar');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (with undefined actions)","suites":["Helpers"],"updatePoint":{"line":544,"column":41,"index":12594},"line":544,"code":"  it('mapActions (with undefined actions)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a\n          }\n        }\n      }\n    });\n    const vm = mount(store, {\n      methods: mapActions('foo/')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(a).not.toHaveBeenCalled();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapActions: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"createNamespacedHelpers","suites":["Helpers"],"updatePoint":{"line":564,"column":29,"index":13156},"line":564,"code":"  it('createNamespacedHelpers', () => {\n    const actionA = jest.fn();\n    const actionB = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          getters: {\n            isEven: state => state.count % 2 === 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          actions: {\n            actionA,\n            actionB\n          }\n        }\n      }\n    });\n    const {\n      mapState,\n      mapGetters,\n      mapMutations,\n      mapActions\n    } = createNamespacedHelpers('foo/');\n    const vm = mount(store, {\n      computed: {\n        ...mapState(['count']),\n        ...mapGetters(['isEven'])\n      },\n      methods: {\n        ...mapMutations(['inc', 'dec']),\n        ...mapActions(['actionA', 'actionB'])\n      }\n    });\n    expect(vm.count).toBe(0);\n    expect(vm.isEven).toBe(true);\n    store.state.foo.count++;\n    expect(vm.count).toBe(1);\n    expect(vm.isEven).toBe(false);\n    vm.inc();\n    expect(store.state.foo.count).toBe(2);\n    expect(store.getters['foo/isEven']).toBe(true);\n    vm.dec();\n    expect(store.state.foo.count).toBe(1);\n    expect(store.getters['foo/isEven']).toBe(false);\n    vm.actionA();\n    expect(actionA).toHaveBeenCalled();\n    expect(actionB).not.toHaveBeenCalled();\n    vm.actionB();\n    expect(actionB).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mutations","suites":["Hot Reload"],"updatePoint":{"line":7,"column":15,"index":214},"line":7,"code":"  it('mutations', function () {\n    const mutations = {\n      [TEST](state, n) {\n        state.a += n;\n      }\n    };\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations,\n      modules: {\n        nested: {\n          state: {\n            a: 2\n          },\n          mutations,\n          modules: {\n            one: {\n              state: {\n                a: 3\n              },\n              mutations\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 4\n                  },\n                  mutations\n                },\n                three: {\n                  state: {\n                    a: 5\n                  },\n                  mutations\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 6\n          },\n          mutations\n        }\n      }\n    });\n    store.commit(TEST, 1);\n    expect(store.state.a).toBe(2);\n    expect(store.state.nested.a).toBe(3);\n    expect(store.state.nested.one.a).toBe(4);\n    expect(store.state.nested.nested.two.a).toBe(5);\n    expect(store.state.nested.nested.three.a).toBe(6);\n    expect(store.state.four.a).toBe(7);\n\n    // hot reload only root mutations\n    store.hotUpdate({\n      mutations: {\n        [TEST](state, n) {\n          state.a = n;\n        }\n      }\n    });\n    store.commit(TEST, 1);\n    expect(store.state.a).toBe(1); // only root mutation updated\n    expect(store.state.nested.a).toBe(4);\n    expect(store.state.nested.one.a).toBe(5);\n    expect(store.state.nested.nested.two.a).toBe(6);\n    expect(store.state.nested.nested.three.a).toBe(7);\n    expect(store.state.four.a).toBe(8);\n\n    // hot reload modules\n    store.hotUpdate({\n      modules: {\n        nested: {\n          state: {\n            a: 234\n          },\n          mutations,\n          modules: {\n            one: {\n              state: {\n                a: 345\n              },\n              mutations\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 456\n                  },\n                  mutations\n                },\n                three: {\n                  state: {\n                    a: 567\n                  },\n                  mutations\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 678\n          },\n          mutations\n        }\n      }\n    });\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(2);\n    expect(store.state.nested.a).toBe(6); // should not reload initial state\n    expect(store.state.nested.one.a).toBe(7); // should not reload initial state\n    expect(store.state.nested.nested.two.a).toBe(8); // should not reload initial state\n    expect(store.state.nested.nested.three.a).toBe(9); // should not reload initial state\n    expect(store.state.four.a).toBe(10); // should not reload initial state\n\n    // hot reload all\n    store.hotUpdate({\n      mutations: {\n        [TEST](state, n) {\n          state.a -= n;\n        }\n      },\n      modules: {\n        nested: {\n          state: {\n            a: 234\n          },\n          mutations: {\n            [TEST](state, n) {\n              state.a += n;\n            }\n          },\n          modules: {\n            one: {\n              state: {\n                a: 345\n              },\n              mutations: {\n                [TEST](state, n) {\n                  state.a += n;\n                }\n              }\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 456\n                  },\n                  mutations: {\n                    [TEST](state, n) {\n                      state.a += n;\n                    }\n                  }\n                },\n                three: {\n                  state: {\n                    a: 567\n                  },\n                  mutations: {\n                    [TEST](state, n) {\n                      state.a -= n;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 678\n          },\n          mutations: {\n            [TEST](state, n) {\n              state.a -= n;\n            }\n          }\n        }\n      }\n    });\n    store.commit(TEST, 3);\n    expect(store.state.a).toBe(-1);\n    expect(store.state.nested.a).toBe(9);\n    expect(store.state.nested.one.a).toBe(10);\n    expect(store.state.nested.nested.two.a).toBe(11);\n    expect(store.state.nested.nested.three.a).toBe(6);\n    expect(store.state.four.a).toBe(7);\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"actions","suites":["Hot Reload"],"updatePoint":{"line":204,"column":13,"index":4934},"line":204,"code":"  it('actions', () => {\n    const store = new Vuex.Store({\n      state: {\n        list: []\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.list.push(n);\n        }\n      },\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 1);\n        }\n      },\n      modules: {\n        a: {\n          actions: {\n            [TEST]({\n              commit\n            }) {\n              commit(TEST, 2);\n            }\n          }\n        }\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2');\n\n    // update root\n    store.hotUpdate({\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 3);\n        }\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2,3,2');\n\n    // update modules\n    store.hotUpdate({\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 4);\n        }\n      },\n      modules: {\n        a: {\n          actions: {\n            [TEST]({\n              commit\n            }) {\n              commit(TEST, 5);\n            }\n          }\n        }\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2,3,2,4,5');\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"getters","suites":["Hot Reload"],"updatePoint":{"line":273,"column":13,"index":6182},"line":273,"code":"  it('getters', done => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++\n      },\n      getters: {\n        count: state => state.count\n      },\n      actions: {\n        check({\n          getters\n        }, value) {\n          expect(getters.count).toBe(value);\n        }\n      }\n    });\n    const spy = jest.fn();\n    const vm = mount(store, {\n      computed: {\n        a: () => store.getters.count\n      },\n      watch: {\n        a: spy\n      }\n    });\n    expect(vm.a).toBe(0);\n    store.dispatch('check', 0);\n    store.commit('inc');\n    expect(vm.a).toBe(1);\n    store.dispatch('check', 1);\n\n    // update getters\n    store.hotUpdate({\n      getters: {\n        count: state => state.count * 10\n      }\n    });\n    expect(vm.a).toBe(10);\n    store.dispatch('check', 10);\n    if (isSSR) {\n      done();\n    } else {\n      nextTick(() => {\n        expect(spy).toHaveBeenCalled();\n        done();\n      });\n    }\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"provide warning if a new module is given","suites":["Hot Reload"],"updatePoint":{"line":324,"column":46,"index":7217},"line":324,"code":"  it('provide warning if a new module is given', () => {\n    const store = new Vuex.Store({});\n    jest.spyOn(console, 'warn').mockImplementation();\n    store.hotUpdate({\n      modules: {\n        test: {\n          state: {\n            count: 0\n          }\n        }\n      }\n    });\n    expect(console.warn).toHaveBeenCalledWith('[vuex] trying to add a new module \\'test\\' on hot reloading, ' + 'manual reload is needed');\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"update namespace","suites":["Hot Reload"],"updatePoint":{"line":338,"column":22,"index":7621},"line":338,"code":"  it('update namespace', () => {\n    // prevent to print notification of unknown action/mutation\n    jest.spyOn(console, 'error').mockImplementation();\n    const actionSpy = jest.fn();\n    const mutationSpy = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        a: {\n          namespaced: true,\n          state: {\n            value: 1\n          },\n          getters: {\n            foo: state => state.value\n          },\n          actions: {\n            foo: actionSpy\n          },\n          mutations: {\n            foo: mutationSpy\n          }\n        }\n      }\n    });\n    expect(store.state.a.value).toBe(1);\n    expect(store.getters['a/foo']).toBe(1);\n    store.dispatch('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1);\n    store.commit('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1);\n    store.hotUpdate({\n      modules: {\n        a: {\n          namespaced: false\n        }\n      }\n    });\n    expect(store.state.a.value).toBe(1);\n    expect(store.getters['a/foo']).toBe(undefined); // removed\n    expect(store.getters['foo']).toBe(1); // renamed\n\n    // should not be called\n    store.dispatch('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1);\n\n    // should be called\n    store.dispatch('foo');\n    expect(actionSpy).toHaveBeenCalledTimes(2);\n\n    // should not be called\n    store.commit('a/foo');\n    expect(mutationSpy).toHaveBeenCalledTimes(1);\n\n    // should be called\n    store.commit('foo');\n    expect(mutationSpy).toHaveBeenCalledTimes(2);\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"get","suites":["ModuleCollection"],"updatePoint":{"line":3,"column":9,"index":106},"line":3,"code":"  it('get', () => {\n    const collection = new ModuleCollection({\n      state: {\n        value: 1\n      },\n      modules: {\n        a: {\n          state: {\n            value: 2\n          }\n        },\n        b: {\n          state: {\n            value: 3\n          },\n          modules: {\n            c: {\n              state: {\n                value: 4\n              }\n            }\n          }\n        }\n      }\n    });\n    expect(collection.get([]).state.value).toBe(1);\n    expect(collection.get(['a']).state.value).toBe(2);\n    expect(collection.get(['b']).state.value).toBe(3);\n    expect(collection.get(['b', 'c']).state.value).toBe(4);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"getNamespace","suites":["ModuleCollection"],"updatePoint":{"line":33,"column":18,"index":763},"line":33,"code":"  it('getNamespace', () => {\n    const module = (namespaced, children) => {\n      return {\n        namespaced,\n        modules: children\n      };\n    };\n    const collection = new ModuleCollection({\n      namespace: 'ignore/',\n      // root module namespace should be ignored\n      modules: {\n        a: module(true, {\n          b: module(false, {\n            c: module(true)\n          }),\n          d: module(true)\n        })\n      }\n    });\n    const check = (path, expected) => {\n      const type = 'test';\n      const namespace = collection.getNamespace(path);\n      expect(namespace + type).toBe(expected);\n    };\n    check(['a'], 'a/test');\n    check(['a', 'b'], 'a/test');\n    check(['a', 'b', 'c'], 'a/c/test');\n    check(['a', 'd'], 'a/d/test');\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"register","suites":["ModuleCollection"],"updatePoint":{"line":62,"column":14,"index":1520},"line":62,"code":"  it('register', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: 1\n      }\n    });\n    collection.register(['b'], {\n      state: {\n        value: 2\n      }\n    });\n    collection.register(['a', 'b'], {\n      state: {\n        value: 3\n      }\n    });\n    expect(collection.get(['a']).state.value).toBe(1);\n    expect(collection.get(['b']).state.value).toBe(2);\n    expect(collection.get(['a', 'b']).state.value).toBe(3);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"unregister","suites":["ModuleCollection"],"updatePoint":{"line":83,"column":16,"index":2020},"line":83,"code":"  it('unregister', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: true\n      }\n    });\n    expect(collection.get(['a']).state.value).toBe(true);\n    collection.unregister(['a']);\n    expect(collection.get(['a'])).toBe(undefined);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"isRegistered","suites":["ModuleCollection"],"updatePoint":{"line":94,"column":18,"index":2331},"line":94,"code":"  it('isRegistered', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: true\n      }\n    });\n    collection.register(['a', 'b'], {\n      state: {\n        value: false\n      }\n    });\n    expect(collection.isRegistered(['a'])).toBe(true);\n    expect(collection.isRegistered(['a', 'b'])).toBe(true);\n    expect(collection.isRegistered(['c'])).toBe(false);\n    expect(collection.isRegistered(['c', 'd'])).toBe(false);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"does not unregister initial modules","suites":["ModuleCollection"],"updatePoint":{"line":111,"column":41,"index":2844},"line":111,"code":"  it('does not unregister initial modules', () => {\n    const collection = new ModuleCollection({\n      modules: {\n        a: {\n          state: {\n            value: true\n          }\n        }\n      }\n    });\n    collection.unregister(['a']);\n    expect(collection.get(['a']).state.value).toBe(true);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"warns when unregistering non existing module","suites":["ModuleCollection"],"updatePoint":{"line":124,"column":50,"index":3160},"line":124,"code":"  it('warns when unregistering non existing module', () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const collection = new ModuleCollection({});\n    collection.unregister(['a']);\n    expect(spy).toHaveBeenCalled();\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"get state","suites":["Module"],"updatePoint":{"line":3,"column":15,"index":81},"line":3,"code":"  it('get state', () => {\n    const module = new Module({\n      state: {\n        value: true\n      }\n    });\n    expect(module.state).toEqual({\n      value: true\n    });\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get state: should return object if state option is empty","suites":["Module"],"updatePoint":{"line":13,"column":62,"index":304},"line":13,"code":"  it('get state: should return object if state option is empty', () => {\n    const module = new Module({});\n    expect(module.state).toEqual({});\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get namespacer: no namespace option","suites":["Module"],"updatePoint":{"line":17,"column":41,"index":435},"line":17,"code":"  it('get namespacer: no namespace option', () => {\n    const module = new Module({});\n    expect(module.namespaced).toBe(false);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get namespacer: namespace option is true","suites":["Module"],"updatePoint":{"line":21,"column":46,"index":576},"line":21,"code":"  it('get namespacer: namespace option is true', () => {\n    let module = new Module({\n      namespaced: true\n    });\n    expect(module.namespaced).toBe(true);\n    module = new Module({\n      namespaced: 100\n    });\n    expect(module.namespaced).toBe(true);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"add child method","suites":["Module"],"updatePoint":{"line":31,"column":22,"index":816},"line":31,"code":"  it('add child method', () => {\n    const module = new Module({});\n    module.addChild('v1', new Module({}));\n    module.addChild('v2', new Module({}));\n    expect(Object.keys(module._children)).toEqual(['v1', 'v2']);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"remove child method","suites":["Module"],"updatePoint":{"line":37,"column":25,"index":1044},"line":37,"code":"  it('remove child method', () => {\n    const module = new Module({});\n    module.addChild('v1', new Module({}));\n    module.addChild('v2', new Module({}));\n    expect(Object.keys(module._children)).toEqual(['v1', 'v2']);\n    module.removeChild('v2');\n    module.removeChild('abc');\n    expect(Object.keys(module._children)).toEqual(['v1']);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get child method","suites":["Module"],"updatePoint":{"line":46,"column":22,"index":1389},"line":46,"code":"  it('get child method', () => {\n    const module = new Module({});\n    const subModule1 = new Module({\n      state: {\n        name: 'v1'\n      }\n    });\n    const subModule2 = new Module({\n      state: {\n        name: 'v2'\n      }\n    });\n    module.addChild('v1', subModule1);\n    module.addChild('v2', subModule2);\n    expect(module.getChild('v2')).toEqual(subModule2);\n    expect(module.getChild('v1')).toEqual(subModule1);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"update method","suites":["Module"],"updatePoint":{"line":63,"column":19,"index":1820},"line":63,"code":"  it('update method', () => {\n    const originObject = {\n      state: {\n        name: 'vuex',\n        version: '2.x.x'\n      },\n      namespaced: true,\n      actions: {\n        a1: () => {},\n        a2: () => {}\n      },\n      mutations: {\n        m1: () => {},\n        m2: () => {}\n      },\n      getters: {\n        g1: () => {},\n        g2: () => {}\n      }\n    };\n    const newObject = {\n      actions: {\n        a3: () => {},\n        a4: () => {}\n      },\n      mutations: {\n        m3: () => {},\n        m2: () => {}\n      },\n      getters: {\n        g1: () => {}\n      },\n      namespaced: false,\n      state: {\n        name: 'vuex',\n        version: '3.x.x'\n      }\n    };\n    const module = new Module(originObject);\n    expect(module._rawModule).toEqual(originObject);\n    module.update(newObject);\n    expect(module._rawModule.actions).toEqual(newObject.actions);\n    expect(module._rawModule.mutations).toEqual(newObject.mutations);\n    expect(module._rawModule.getters).toEqual(newObject.getters);\n    expect(module._rawModule.namespaced).toEqual(newObject.namespaced);\n    expect(module._rawModule.state).toEqual(originObject.state);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachChild method","suites":["Module"],"updatePoint":{"line":110,"column":25,"index":2979},"line":110,"code":"  it('forEachChild method', () => {\n    const module = new Module({});\n    const module1 = new Module({});\n    const module2 = new Module({});\n    module.addChild('v1', module1);\n    module.addChild('v2', module2);\n    const collections = [];\n    module.forEachChild(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([module2, module1]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachAction method","suites":["Module"],"updatePoint":{"line":123,"column":26,"index":3397},"line":123,"code":"  it('forEachAction method', () => {\n    const action1 = () => {};\n    const action2 = () => {};\n    const module = new Module({\n      actions: {\n        action1,\n        action2\n      }\n    });\n    const collections = [];\n    module.forEachAction(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([action1, action2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachGetter method","suites":["Module"],"updatePoint":{"line":139,"column":26,"index":3795},"line":139,"code":"  it('forEachGetter method', () => {\n    const getter1 = () => {};\n    const getter2 = () => {};\n    const module = new Module({\n      getters: {\n        getter1,\n        getter2\n      }\n    });\n    const collections = [];\n    module.forEachGetter(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([getter1, getter2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachMutation method","suites":["Module"],"updatePoint":{"line":155,"column":28,"index":4195},"line":155,"code":"  it('forEachMutation method', () => {\n    const mutation1 = () => {};\n    const mutation2 = () => {};\n    const module = new Module({\n      mutations: {\n        mutation1,\n        mutation2\n      }\n    });\n    const collections = [];\n    module.forEachMutation(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([mutation1, mutation2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration","suites":["Modules","module registration"],"updatePoint":{"line":7,"column":35,"index":228},"line":7,"code":"    it('dynamic module registration', () => {\n      const store = new Vuex.Store({\n        strict: true,\n        modules: {\n          foo: {\n            state: {\n              bar: 1\n            },\n            mutations: {\n              inc: state => state.bar++\n            },\n            actions: {\n              incFoo: ({\n                commit\n              }) => commit('inc')\n            },\n            getters: {\n              bar: state => state.bar\n            }\n          }\n        }\n      });\n      expect(() => {\n        store.registerModule('hi', {\n          state: {\n            a: 1\n          },\n          mutations: {\n            inc: state => state.a++\n          },\n          actions: {\n            inc: ({\n              commit\n            }) => commit('inc')\n          },\n          getters: {\n            a: state => state.a\n          }\n        });\n      }).not.toThrow();\n      expect(store._mutations.inc.length).toBe(2);\n      expect(store.state.hi.a).toBe(1);\n      expect(store.getters.a).toBe(1);\n\n      // assert initial modules work as expected after dynamic registration\n      expect(store.state.foo.bar).toBe(1);\n      expect(store.getters.bar).toBe(1);\n\n      // test dispatching actions defined in dynamic module\n      store.dispatch('inc');\n      expect(store.state.hi.a).toBe(2);\n      expect(store.getters.a).toBe(2);\n      expect(store.state.foo.bar).toBe(2);\n      expect(store.getters.bar).toBe(2);\n\n      // unregister\n      store.unregisterModule('hi');\n      expect(store.state.hi).toBeUndefined();\n      expect(store.getters.a).toBeUndefined();\n      expect(store._mutations.inc.length).toBe(1);\n      expect(store._actions.inc).toBeUndefined();\n\n      // assert initial modules still work as expected after unregister\n      store.dispatch('incFoo');\n      expect(store.state.foo.bar).toBe(3);\n      expect(store.getters.bar).toBe(3);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration with namespace inheritance","suites":["Modules","module registration"],"updatePoint":{"line":74,"column":62,"index":2139},"line":74,"code":"    it('dynamic module registration with namespace inheritance', () => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true\n          }\n        }\n      });\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      store.registerModule(['a', 'b'], {\n        state: {\n          value: 1\n        },\n        getters: {\n          foo: state => state.value\n        },\n        actions: {\n          foo: actionSpy\n        },\n        mutations: {\n          foo: mutationSpy\n        }\n      });\n      expect(store.state.a.b.value).toBe(1);\n      expect(store.getters['a/foo']).toBe(1);\n      store.dispatch('a/foo');\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/foo');\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module existance test","suites":["Modules","module registration"],"updatePoint":{"line":105,"column":37,"index":2917},"line":105,"code":"    it('dynamic module existance test', () => {\n      const store = new Vuex.Store({});\n      store.registerModule('bonjour', {});\n      expect(store.hasModule('bonjour')).toBe(true);\n      store.unregisterModule('bonjour');\n      expect(store.hasModule('bonjour')).toBe(false);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module existance test with nested modules","suites":["Modules","module registration"],"updatePoint":{"line":112,"column":57,"index":3224},"line":112,"code":"    it('dynamic module existance test with nested modules', () => {\n      const store = new Vuex.Store({});\n      store.registerModule('a', {});\n      store.registerModule(['a', 'b'], {});\n      expect(store.hasModule(['a'])).toBe(true);\n      expect(store.hasModule(['a', 'b'])).toBe(true);\n      expect(store.hasModule(['c'])).toBe(false);\n      expect(store.hasModule(['c', 'd'])).toBe(false);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration preserving hydration","suites":["Modules","module registration"],"updatePoint":{"line":121,"column":56,"index":3628},"line":121,"code":"    it('dynamic module registration preserving hydration', () => {\n      const store = new Vuex.Store({});\n      store.replaceState({\n        a: {\n          foo: 'state'\n        }\n      });\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      store.registerModule('a', {\n        namespaced: true,\n        getters: {\n          foo: state => state.foo\n        },\n        actions: {\n          foo: actionSpy\n        },\n        mutations: {\n          foo: mutationSpy\n        }\n      }, {\n        preserveState: true\n      });\n      expect(store.state.a.foo).toBe('state');\n      expect(store.getters['a/foo']).toBe('state');\n      store.dispatch('a/foo');\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/foo');\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"should keep getters when component gets destroyed","suites":["Modules","module registration"],"updatePoint":{"line":151,"column":57,"index":4434},"line":151,"code":"    it('should keep getters when component gets destroyed', async () => {\n      const store = new Vuex.Store();\n      const spy = jest.fn();\n      const moduleA = {\n        namespaced: true,\n        state: () => ({\n          value: 1\n        }),\n        getters: {\n          getState(state) {\n            spy();\n            return state.value;\n          }\n        },\n        mutations: {\n          increment: state => {\n            state.value++;\n          }\n        }\n      };\n      const CompA = {\n        template: `<div />`,\n        created() {\n          this.$store.registerModule('moduleA', moduleA);\n        }\n      };\n      const CompB = {\n        template: `<div />`\n      };\n      const vm = mount(store, {\n        components: {\n          CompA,\n          CompB\n        },\n        data: () => ({\n          show: 'a'\n        }),\n        render() {\n          return this.show === 'a' ? h(CompA) : h(CompB);\n        }\n      });\n      expect(store.getters['moduleA/getState']).toBe(1);\n      expect(spy).toHaveBeenCalledTimes(1);\n      vm.show = 'b';\n      await nextTick();\n      store.commit('moduleA/increment');\n      expect(store.getters['moduleA/getState']).toBe(2);\n      expect(spy).toHaveBeenCalledTimes(2);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"should not fire an unrelated watcher","suites":["Modules","module registration"],"updatePoint":{"line":203,"column":42,"index":5667},"line":203,"code":"  it('should not fire an unrelated watcher', done => {\n    const spy = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        a: {\n          state: {\n            value: 1\n          }\n        },\n        b: {}\n      }\n    });\n    store.watch(state => state.a, spy);\n    store.registerModule(['b', 'c'], {\n      state: {\n        value: 2\n      }\n    });\n    nextTick(() => {\n      expect(spy).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"state as function (multiple module in same store)","suites":["Modules","modules usage"],"updatePoint":{"line":227,"column":57,"index":6176},"line":227,"code":"    it('state as function (multiple module in same store)', () => {\n      const module = {\n        state() {\n          return {\n            a: 0\n          };\n        },\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n        }\n      };\n      const store = new Vuex.Store({\n        modules: {\n          one: module,\n          two: module\n        }\n      });\n      expect(store.state.one.a).toBe(0);\n      expect(store.state.two.a).toBe(0);\n      store.commit(TEST, 1);\n      expect(store.state.one.a).toBe(1);\n      expect(store.state.two.a).toBe(1);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"state as function (same module in multiple stores)","suites":["Modules","modules usage"],"updatePoint":{"line":252,"column":58,"index":6775},"line":252,"code":"    it('state as function (same module in multiple stores)', () => {\n      const module = {\n        state() {\n          return {\n            a: 0\n          };\n        },\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n        }\n      };\n      const storeA = new Vuex.Store({\n        modules: {\n          foo: module\n        }\n      });\n      const storeB = new Vuex.Store({\n        modules: {\n          bar: module\n        }\n      });\n      expect(storeA.state.foo.a).toBe(0);\n      expect(storeB.state.bar.a).toBe(0);\n      storeA.commit(TEST, 1);\n      expect(storeA.state.foo.a).toBe(1);\n      expect(storeB.state.bar.a).toBe(0);\n      storeB.commit(TEST, 2);\n      expect(storeA.state.foo.a).toBe(1);\n      expect(storeB.state.bar.a).toBe(2);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: mutation","suites":["Modules","modules usage"],"updatePoint":{"line":284,"column":24,"index":7536},"line":284,"code":"    it('module: mutation', function () {\n      const mutations = {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      };\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        mutations,\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            mutations,\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                mutations\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    mutations\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    mutations\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            mutations\n          }\n        }\n      });\n      store.commit(TEST, 1);\n      expect(store.state.a).toBe(2);\n      expect(store.state.nested.a).toBe(3);\n      expect(store.state.nested.one.a).toBe(4);\n      expect(store.state.nested.nested.two.a).toBe(5);\n      expect(store.state.nested.nested.three.a).toBe(6);\n      expect(store.state.four.a).toBe(7);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: action","suites":["Modules","modules usage"],"updatePoint":{"line":342,"column":22,"index":8911},"line":342,"code":"    it('module: action', function () {\n      let calls = 0;\n      const makeAction = n => {\n        return {\n          [TEST]({\n            state,\n            rootState\n          }) {\n            calls++;\n            expect(state.a).toBe(n);\n            expect(rootState).toBe(store.state);\n          }\n        };\n      };\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        actions: makeAction(1),\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            actions: makeAction(2),\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                actions: makeAction(3)\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    actions: makeAction(4)\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    actions: makeAction(5)\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            actions: makeAction(6)\n          }\n        }\n      });\n      store.dispatch(TEST);\n      expect(calls).toBe(6);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: getters","suites":["Modules","modules usage"],"updatePoint":{"line":403,"column":23,"index":10298},"line":403,"code":"    it('module: getters', function () {\n      const makeGetter = n => ({\n        [`getter${n}`]: (state, getters, rootState) => {\n          expect(getters.constant).toBe(0);\n          expect(rootState).toBe(store.state);\n          return state.a;\n        }\n      });\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        getters: {\n          constant: () => 0,\n          ...makeGetter(1)\n        },\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            getters: makeGetter(2),\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                getters: makeGetter(3)\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    getters: makeGetter(4)\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    getters: makeGetter(5)\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            getters: makeGetter(6)\n          }\n        }\n      });\n      [1, 2, 3, 4, 5, 6].forEach(n => {\n        expect(store.getters[`getter${n}`]).toBe(n);\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: namespace","suites":["Modules","modules usage"],"updatePoint":{"line":462,"column":25,"index":11730},"line":462,"code":"    it('module: namespace', () => {\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              a: 1\n            },\n            getters: {\n              b: () => 2\n            },\n            actions: {\n              [TEST]: actionSpy\n            },\n            mutations: {\n              [TEST]: mutationSpy\n            }\n          }\n        }\n      });\n      expect(store.state.a.a).toBe(1);\n      expect(store.getters['a/b']).toBe(2);\n      store.dispatch('a/' + TEST);\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/' + TEST);\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: nested namespace","suites":["Modules","modules usage"],"updatePoint":{"line":491,"column":32,"index":12488},"line":491,"code":"    it('module: nested namespace', () => {\n      // mock module generator\n      const actionSpys = [];\n      const mutationSpys = [];\n      const createModule = (name, namespaced, children) => {\n        const actionSpy = jest.fn();\n        const mutationSpy = jest.fn();\n        actionSpys.push(actionSpy);\n        mutationSpys.push(mutationSpy);\n        return {\n          namespaced,\n          state: {\n            [name]: true\n          },\n          getters: {\n            [name]: state => state[name]\n          },\n          actions: {\n            [name]: actionSpy\n          },\n          mutations: {\n            [name]: mutationSpy\n          },\n          modules: children\n        };\n      };\n\n      // mock module\n      const modules = {\n        a: createModule('a', true, {\n          // a/a\n          b: createModule('b', false, {\n            // a/b - does not add namespace\n            c: createModule('c', true) // a/c/c\n          }),\n\n          d: createModule('d', true) // a/d/d\n        })\n      };\n\n      const store = new Vuex.Store({\n        modules\n      });\n      const expectedTypes = ['a/a', 'a/b', 'a/c/c', 'a/d/d'];\n\n      // getters\n      expectedTypes.forEach(type => {\n        expect(store.getters[type]).toBe(true);\n      });\n\n      // actions\n      expectedTypes.forEach(type => {\n        store.dispatch(type);\n      });\n      actionSpys.forEach(spy => {\n        expect(spy).toHaveBeenCalledTimes(1);\n      });\n\n      // mutations\n      expectedTypes.forEach(type => {\n        store.commit(type);\n      });\n      mutationSpys.forEach(spy => {\n        expect(spy).toHaveBeenCalledTimes(1);\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: getters are namespaced in namespaced module","suites":["Modules","modules usage"],"updatePoint":{"line":557,"column":59,"index":14148},"line":557,"code":"    it('module: getters are namespaced in namespaced module', () => {\n      const store = new Vuex.Store({\n        state: {\n          value: 'root'\n        },\n        getters: {\n          foo: state => state.value\n        },\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              value: 'module'\n            },\n            getters: {\n              foo: state => state.value,\n              bar: (state, getters) => getters.foo,\n              baz: (state, getters, rootState, rootGetters) => rootGetters.foo\n            }\n          }\n        }\n      });\n      expect(store.getters['a/foo']).toBe('module');\n      expect(store.getters['a/bar']).toBe('module');\n      expect(store.getters['a/baz']).toBe('root');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: action context is namespaced in namespaced module","suites":["Modules","modules usage"],"updatePoint":{"line":583,"column":65,"index":14915},"line":583,"code":"    it('module: action context is namespaced in namespaced module', done => {\n      const rootActionSpy = jest.fn();\n      const rootMutationSpy = jest.fn();\n      const moduleActionSpy = jest.fn();\n      const moduleMutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        state: {\n          value: 'root'\n        },\n        getters: {\n          foo: state => state.value\n        },\n        actions: {\n          foo: rootActionSpy\n        },\n        mutations: {\n          foo: rootMutationSpy\n        },\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              value: 'module'\n            },\n            getters: {\n              foo: state => state.value\n            },\n            actions: {\n              foo: moduleActionSpy,\n              test({\n                dispatch,\n                commit,\n                getters,\n                rootGetters\n              }) {\n                expect(getters.foo).toBe('module');\n                expect(rootGetters.foo).toBe('root');\n                dispatch('foo');\n                expect(moduleActionSpy).toHaveBeenCalledTimes(1);\n                dispatch('foo', null, {\n                  root: true\n                });\n                expect(rootActionSpy).toHaveBeenCalledTimes(1);\n                commit('foo');\n                expect(moduleMutationSpy).toHaveBeenCalledTimes(1);\n                commit('foo', null, {\n                  root: true\n                });\n                expect(rootMutationSpy).toHaveBeenCalledTimes(1);\n                done();\n              }\n            },\n            mutations: {\n              foo: moduleMutationSpy\n            }\n          }\n        }\n      });\n      store.dispatch('a/test');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: use other module that has same namespace","suites":["Modules","modules usage"],"updatePoint":{"line":643,"column":56,"index":16648},"line":643,"code":"    it('module: use other module that has same namespace', done => {\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        modules: {\n          parent: {\n            namespaced: true,\n            modules: {\n              a: {\n                state: {\n                  value: 'a'\n                },\n                getters: {\n                  foo: state => state.value\n                },\n                actions: {\n                  foo: actionSpy\n                },\n                mutations: {\n                  foo: mutationSpy\n                }\n              },\n              b: {\n                state: {\n                  value: 'b'\n                },\n                getters: {\n                  bar: (state, getters) => getters.foo\n                },\n                actions: {\n                  test({\n                    dispatch,\n                    commit,\n                    getters\n                  }) {\n                    expect(getters.foo).toBe('a');\n                    expect(getters.bar).toBe('a');\n                    dispatch('foo');\n                    expect(actionSpy).toHaveBeenCalled();\n                    commit('foo');\n                    expect(mutationSpy).toHaveBeenCalled();\n                    done();\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n      store.dispatch('parent/test');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: warn when module overrides state","suites":["Modules","modules usage"],"updatePoint":{"line":694,"column":48,"index":18089},"line":694,"code":"    it('module: warn when module overrides state', () => {\n      jest.spyOn(console, 'warn').mockImplementation();\n      const store = new Vuex.Store({\n        modules: {\n          foo: {\n            state() {\n              return {\n                value: 1\n              };\n            },\n            modules: {\n              value: {\n                state: () => 2\n              }\n            }\n          }\n        }\n      });\n      expect(store.state.foo.value).toBe(2);\n      expect(console.warn).toHaveBeenCalledWith(`[vuex] state field \"value\" was overridden by a module with the same name at \"foo.value\"`);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dispatching multiple actions in different modules","suites":["Modules","modules usage"],"updatePoint":{"line":715,"column":57,"index":18720},"line":715,"code":"    it('dispatching multiple actions in different modules', done => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            actions: {\n              [TEST]() {\n                return 1;\n              }\n            }\n          },\n          b: {\n            actions: {\n              [TEST]() {\n                return new Promise(r => r(2));\n              }\n            }\n          }\n        }\n      });\n      store.dispatch(TEST).then(res => {\n        expect(res[0]).toBe(1);\n        expect(res[1]).toBe(2);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"root actions dispatched in namespaced modules","suites":["Modules","modules usage"],"updatePoint":{"line":740,"column":53,"index":19285},"line":740,"code":"    it('root actions dispatched in namespaced modules', done => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                root: true,\n                handler() {\n                  return 1;\n                }\n              }\n            }\n          },\n          b: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                root: true,\n                handler() {\n                  return new Promise(r => r(2));\n                }\n              }\n            }\n          },\n          c: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                handler() {\n                  // Should not be called\n                  return 3;\n                }\n              }\n            }\n          },\n          d: {\n            namespaced: true,\n            actions: {\n              [TEST]() {\n                // Should not be called\n                return 4;\n              }\n            }\n          }\n        }\n      });\n      store.dispatch(TEST).then(res => {\n        expect(res.length).toBe(2);\n        expect(res[0]).toBe(1);\n        expect(res[1]).toBe(2);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"plugins","suites":["Modules","modules usage"],"updatePoint":{"line":794,"column":15,"index":20511},"line":794,"code":"    it('plugins', function () {\n      let initState;\n      const actionSpy = jest.fn();\n      const mutations = [];\n      const subscribeActionSpy = jest.fn();\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n        },\n        actions: {\n          [TEST]: actionSpy\n        },\n        plugins: [store => {\n          initState = store.state;\n          store.subscribe((mut, state) => {\n            expect(state).toBe(state);\n            mutations.push(mut);\n          });\n          store.subscribeAction(subscribeActionSpy);\n        }]\n      });\n      expect(initState).toBe(store.state);\n      store.commit(TEST, 2);\n      store.dispatch(TEST, 2);\n      expect(mutations.length).toBe(1);\n      expect(mutations[0].type).toBe(TEST);\n      expect(mutations[0].payload).toBe(2);\n      expect(actionSpy).toHaveBeenCalled();\n      expect(subscribeActionSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"action before/after subscribers","suites":["Modules","modules usage"],"updatePoint":{"line":832,"column":39,"index":21601},"line":832,"code":"    it('action before/after subscribers', done => {\n      const beforeSpy = jest.fn();\n      const afterSpy = jest.fn();\n      const store = new Vuex.Store({\n        actions: {\n          [TEST]: () => Promise.resolve()\n        },\n        plugins: [store => {\n          store.subscribeAction({\n            before: beforeSpy,\n            after: afterSpy\n          });\n        }]\n      });\n      store.dispatch(TEST, 2);\n      expect(beforeSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n      expect(afterSpy).not.toHaveBeenCalled();\n      nextTick(() => {\n        expect(afterSpy).toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"action error subscribers","suites":["Modules","modules usage"],"updatePoint":{"line":861,"column":30,"index":22345},"line":861,"code":"  it('action error subscribers', done => {\n    const beforeSpy = jest.fn();\n    const afterSpy = jest.fn();\n    const errorSpy = jest.fn();\n    const error = new Error();\n    const store = new Vuex.Store({\n      actions: {\n        [TEST]: () => Promise.reject(error)\n      },\n      plugins: [store => {\n        store.subscribeAction({\n          before: beforeSpy,\n          after: afterSpy,\n          error: errorSpy\n        });\n      }]\n    });\n    store.dispatch(TEST, 2).catch(() => {\n      expect(beforeSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n      expect(afterSpy).not.toHaveBeenCalled();\n      nextTick(() => {\n        expect(afterSpy).not.toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state);\n        expect(errorSpy).toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state, error);\n        done();\n      });\n    });\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts a mutation should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":897,"column":45,"index":23310},"line":897,"code":"  it('asserts a mutation should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        mutations: {\n          test: null\n        }\n      });\n    }).toThrowError(/mutations should be function but \"mutations\\.test\" is null/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                mutations: {\n                  test: 123\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/mutations should be function but \"mutations\\.test\" in module \"foo\\.bar\" is 123/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts an action should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":921,"column":44,"index":23920},"line":921,"code":"  it('asserts an action should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        actions: {\n          test: 'test'\n        }\n      });\n    }).toThrowError(/actions should be function or object with \"handler\" function but \"actions\\.test\" is \"test\"/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                actions: {\n                  test: 'error'\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/actions should be function or object with \"handler\" function but \"actions\\.test\" in module \"foo\\.bar\" is \"error\"/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts a getter should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":945,"column":43,"index":24597},"line":945,"code":"  it('asserts a getter should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        getters: {\n          test: undefined\n        }\n      });\n    }).toThrowError(/getters should be function but \"getters\\.test\" is undefined/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                getters: {\n                  test: true\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/getters should be function but \"getters\\.test\" in module \"foo\\.bar\" is true/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"committing mutations","suites":["Store"],"updatePoint":{"line":7,"column":26,"index":220},"line":7,"code":"  it('committing mutations', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      }\n    });\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"committing with object style","suites":["Store"],"updatePoint":{"line":21,"column":34,"index":501},"line":21,"code":"  it('committing with object style', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, payload) {\n          state.a += payload.amount;\n        }\n      }\n    });\n    store.commit({\n      type: TEST,\n      amount: 2\n    });\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts committed type","suites":["Store"],"updatePoint":{"line":38,"column":28,"index":829},"line":38,"code":"  it('asserts committed type', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        // Maybe registered with undefined type accidentally\n        // if the user has typo in a constant type\n        undefined(state, n) {\n          state.a += n;\n        }\n      }\n    });\n    expect(() => {\n      store.commit(undefined, 2);\n    }).toThrowError(/expects string as the type, but found undefined/);\n    expect(store.state.a).toBe(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching actions, sync","suites":["Store"],"updatePoint":{"line":56,"column":31,"index":1320},"line":56,"code":"  it('dispatching actions, sync', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          commit(TEST, n);\n        }\n      }\n    });\n    store.dispatch(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching with object style","suites":["Store"],"updatePoint":{"line":77,"column":35,"index":1717},"line":77,"code":"  it('dispatching with object style', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, payload) {\n          commit(TEST, payload.amount);\n        }\n      }\n    });\n    store.dispatch({\n      type: TEST,\n      amount: 2\n    });\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching actions, with returned Promise","suites":["Store"],"updatePoint":{"line":101,"column":48,"index":2180},"line":101,"code":"  it('dispatching actions, with returned Promise', done => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              commit(TEST, n);\n              resolve();\n            }, 0);\n          });\n        }\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.dispatch(TEST, 2).then(() => {\n      expect(store.state.a).toBe(3);\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"composing actions with async/await","suites":["Store"],"updatePoint":{"line":130,"column":40,"index":2790},"line":130,"code":"  it('composing actions with async/await', done => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              commit(TEST, n);\n              resolve();\n            }, 0);\n          });\n        },\n        two: async ({\n          commit,\n          dispatch\n        }, n) => {\n          await dispatch(TEST, 1);\n          expect(store.state.a).toBe(2);\n          commit(TEST, n);\n        }\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.dispatch('two', 3).then(() => {\n      expect(store.state.a).toBe(5);\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"detecting action Promise errors","suites":["Store"],"updatePoint":{"line":167,"column":37,"index":3590},"line":167,"code":"  it('detecting action Promise errors', done => {\n    const store = new Vuex.Store({\n      actions: {\n        [TEST]() {\n          return new Promise((resolve, reject) => {\n            reject('no');\n          });\n        }\n      }\n    });\n    const spy = jest.fn();\n    store._devtoolHook = {\n      emit: spy\n    };\n    const thenSpy = jest.fn();\n    store.dispatch(TEST).then(thenSpy).catch(err => {\n      expect(thenSpy).not.toHaveBeenCalled();\n      expect(err).toBe('no');\n      expect(spy).toHaveBeenCalledWith('vuex:error', 'no');\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts dispatched type","suites":["Store"],"updatePoint":{"line":189,"column":29,"index":4147},"line":189,"code":"  it('asserts dispatched type', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        // Maybe registered with undefined type accidentally\n        // if the user has typo in a constant type\n        undefined({\n          commit\n        }, n) {\n          commit(TEST, n);\n        }\n      }\n    });\n    expect(() => {\n      store.dispatch(undefined, 2);\n    }).toThrowError(/expects string as the type, but found undefined/);\n    expect(store.state.a).toBe(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"getters","suites":["Store"],"updatePoint":{"line":214,"column":13,"index":4735},"line":214,"code":"  it('getters', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 0\n      },\n      getters: {\n        state: state => state.a > 0 ? 'hasAny' : 'none'\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      },\n      actions: {\n        check({\n          getters\n        }, value) {\n          // check for exposing getters into actions\n          expect(getters.state).toBe(value);\n        }\n      }\n    });\n    expect(store.getters.state).toBe('none');\n    store.dispatch('check', 'none');\n    store.commit(TEST, 1);\n    expect(store.getters.state).toBe('hasAny');\n    store.dispatch('check', 'hasAny');\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"store injection","suites":["Store"],"updatePoint":{"line":242,"column":21,"index":5408},"line":242,"code":"  it('store injection', () => {\n    const store = new Vuex.Store();\n    const vm = mount(store, {});\n    expect(vm.$store).toBe(store);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should warn silent option depreciation","suites":["Store"],"updatePoint":{"line":247,"column":44,"index":5573},"line":247,"code":"  it('should warn silent option depreciation', () => {\n    jest.spyOn(console, 'warn').mockImplementation();\n    const store = new Vuex.Store({\n      mutations: {\n        [TEST]() {}\n      }\n    });\n    store.commit(TEST, {}, {\n      silent: true\n    });\n    expect(console.warn).toHaveBeenCalledWith(`[vuex] mutation type: ${TEST}. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools');\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts the call with the new operator","suites":["Store"],"updatePoint":{"line":259,"column":44,"index":6001},"line":259,"code":"  it('asserts the call with the new operator', () => {\n    expect(() => {\n      Vuex.Store({});\n    }).toThrowError(/Cannot call a class as a function/);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should accept state as function","suites":["Store"],"updatePoint":{"line":264,"column":37,"index":6154},"line":264,"code":"  it('should accept state as function', () => {\n    const store = new Vuex.Store({\n      state: () => ({\n        a: 1\n      }),\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should not call root state function twice","suites":["Store"],"updatePoint":{"line":279,"column":47,"index":6491},"line":279,"code":"  it('should not call root state function twice', () => {\n    const spy = jest.fn().mockReturnValue(1);\n    new Vuex.Store({\n      state: spy\n    });\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribe: should handle subscriptions / unsubscriptions","suites":["Store"],"updatePoint":{"line":286,"column":62,"index":6704},"line":286,"code":"  it('subscribe: should handle subscriptions / unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const secondSubscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      mutations: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribe(subscribeSpy);\n    store.subscribe(secondSubscribeSpy);\n    store.commit(TEST, testPayload);\n    unsubscribe();\n    store.commit(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(secondSubscribeSpy).toHaveBeenCalled();\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n    expect(secondSubscribeSpy).toHaveBeenCalledTimes(2);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribe: should handle subscriptions with synchronous unsubscriptions","suites":["Store"],"updatePoint":{"line":309,"column":77,"index":7477},"line":309,"code":"  it('subscribe: should handle subscriptions with synchronous unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      mutations: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribe(() => unsubscribe());\n    store.subscribe(subscribeSpy);\n    store.commit(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribeAction: should handle subscriptions with synchronous unsubscriptions","suites":["Store"],"updatePoint":{"line":327,"column":83,"index":8051},"line":327,"code":"  it('subscribeAction: should handle subscriptions with synchronous unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      actions: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribeAction(() => unsubscribe());\n    store.subscribeAction(subscribeSpy);\n    store.dispatch(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"watch: with resetting vm","suites":["Store"],"updatePoint":{"line":348,"column":32,"index":8667},"line":348,"code":"    it('watch: with resetting vm', done => {\n      const store = new Vuex.Store({\n        state: {\n          count: 0\n        },\n        mutations: {\n          [TEST]: state => state.count++\n        }\n      });\n      const spy = jest.fn();\n      store.watch(state => state.count, spy);\n\n      // reset store vm\n      store.registerModule('test', {});\n      nextTick(() => {\n        store.commit(TEST);\n        expect(store.state.count).toBe(1);\n        nextTick(() => {\n          expect(spy).toHaveBeenCalled();\n          done();\n        });\n      });\n    });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"watch: getter function has access to store's getters object","suites":["Store"],"updatePoint":{"line":371,"column":68,"index":9263},"line":371,"code":"    it('watch: getter function has access to store\\'s getters object', done => {\n      const store = new Vuex.Store({\n        state: {\n          count: 0\n        },\n        mutations: {\n          [TEST]: state => state.count++\n        },\n        getters: {\n          getCount: state => state.count\n        }\n      });\n      const getter = function getter(state, getters) {\n        return state.count;\n      };\n      const spy = jest.spyOn({\n        getter\n      }, 'getter');\n      const spyCb = jest.fn();\n      store.watch(spy, spyCb);\n      nextTick(() => {\n        store.commit(TEST);\n        expect(store.state.count).toBe(1);\n        nextTick(() => {\n          expect(spy).toHaveBeenCalledWith(store.state, store.getters);\n          done();\n        });\n      });\n    });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"find: returns item when it was found","suites":["util"],"updatePoint":{"line":3,"column":42,"index":152},"line":3,"code":"  it('find: returns item when it was found', () => {\n    const list = [33, 22, 112, 222, 43];\n    expect(find(list, function (a) {\n      return a % 2 === 0;\n    })).toEqual(22);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"find: returns undefined when item was not found","suites":["util"],"updatePoint":{"line":9,"column":53,"index":347},"line":9,"code":"  it('find: returns undefined when item was not found', () => {\n    const list = [1, 2, 3];\n    expect(find(list, function (a) {\n      return a === 9000;\n    })).toEqual(undefined);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: normal structure","suites":["util"],"updatePoint":{"line":15,"column":32,"index":514},"line":15,"code":"  it('deepCopy: normal structure', () => {\n    const original = {\n      a: 1,\n      b: 'string',\n      c: true,\n      d: null,\n      e: undefined\n    };\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: nested structure","suites":["util"],"updatePoint":{"line":26,"column":32,"index":746},"line":26,"code":"  it('deepCopy: nested structure', () => {\n    const original = {\n      a: {\n        b: 1,\n        c: [2, 3, {\n          d: 4\n        }]\n      }\n    };\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: circular structure","suites":["util"],"updatePoint":{"line":38,"column":34,"index":979},"line":38,"code":"  it('deepCopy: circular structure', () => {\n    const original = {\n      a: 1\n    };\n    original.circular = original;\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"forEachValue","suites":["util"],"updatePoint":{"line":46,"column":18,"index":1162},"line":46,"code":"  it('forEachValue', () => {\n    let number = 1;\n    function plus(value, key) {\n      number += value;\n    }\n    const origin = {\n      a: 1,\n      b: 3\n    };\n    forEachValue(origin, plus);\n    expect(number).toEqual(5);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"isObject","suites":["util"],"updatePoint":{"line":58,"column":14,"index":1388},"line":58,"code":"  it('isObject', () => {\n    expect(isObject(1)).toBe(false);\n    expect(isObject('String')).toBe(false);\n    expect(isObject(undefined)).toBe(false);\n    expect(isObject({})).toBe(true);\n    expect(isObject(null)).toBe(false);\n    expect(isObject([])).toBe(true);\n    expect(isObject(new Function())).toBe(false);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"isPromise","suites":["util"],"updatePoint":{"line":67,"column":15,"index":1710},"line":67,"code":"  it('isPromise', () => {\n    const promise = new Promise(() => {}, () => {});\n    expect(isPromise(1)).toBe(false);\n    expect(isPromise(promise)).toBe(true);\n    expect(isPromise(new Function())).toBe(false);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"assert","suites":["util"],"updatePoint":{"line":73,"column":12,"index":1924},"line":73,"code":"  it('assert', () => {\n    expect(assert.bind(null, false, 'Hello')).toThrowError('[vuex] Hello');\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"}]}