{"repo":"prisma/prisma","url":"https://github.com/prisma/prisma","branch":"main","configs":[{"package":"prisma","lang":"ts","dir":"packages/cli/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/client","lang":"ts","dir":"packages/client/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/debug","lang":"ts","dir":"packages/debug/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/engine-core","lang":"ts","dir":"packages/engine-core/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/generator-helper","lang":"ts","dir":"packages/generator-helper/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/integration-tests","lang":"js","dir":"packages/integration-tests/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/migrate","lang":"ts","dir":"packages/migrate/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/sdk","lang":"ts","dir":"packages/sdk/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"schema-engine","suites":["artificial-panic introspection"],"updatePoint":{"line":24,"column":19},"line":24,"code":"  it('schema-engine', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(6)\n    process.env.FORCE_PANIC_SCHEMA_ENGINE = '1'\n\n    const command = new DbPull()\n    try {\n      await command.parse(['--print'])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] This is the debugPanic artificial panic\n\n      `)\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schemaPath).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = \"postgres://user:password@randomhost:5432\"\n        }\n\n      `),\n        expect(e).toMatchObject({\n          area: 'LIFT_CLI',\n        })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"formatter","suites":["artificial-panic formatter"],"updatePoint":{"line":69,"column":15},"line":69,"code":"  it('formatter', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_PRISMA_SCHEMA = '1'\n\n    const command = new Format()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(serialize(e.message)).toMatchInlineSnapshot(\n        `RuntimeError: panicked at 'This is the panic triggered by \\`prisma_fmt::debug_panic()\\`', prisma-schema-wasm/src/lib.rs:0:0`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schemaPath.replace(/\\\\/g, '/')) // replace due to Windows CI\n        .toContain('prisma/schema.prisma')\n      expect(e).toMatchObject({\n        schema: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"get-config","suites":["artificial-panic get-config"],"updatePoint":{"line":99,"column":16},"line":99,"code":"  it('get-config', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_CONFIG = '1'\n\n    const command = new Validate()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(serialize(e.message)).toMatchInlineSnapshot(\n        `RuntimeError: panicked at 'This is the panic triggered by \\`prisma_fmt::debug_panic()\\`', prisma-schema-wasm/src/lib.rs:0:0`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = \"postgres://user:password@randomhost:5432\"\n        }\n\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["artificial-panic validate"],"updatePoint":{"line":141,"column":14},"line":141,"code":"  it('validate', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_DMMF = '1'\n\n    const command = new Validate()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(serialize(e.message)).toMatchInlineSnapshot(\n        `RuntimeError: panicked at 'This is the panic triggered by \\`prisma_fmt::debug_panic()\\`', prisma-schema-wasm/src/lib.rs:0:0`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = \"postgres://user:password@randomhost:5432\"\n        }\n\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["artificial-panic validate"],"updatePoint":{"line":175,"column":12},"line":175,"code":"  it('format', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_DMMF = '1'\n\n    const command = new Format()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(serialize(e.message)).toMatchInlineSnapshot(\n        `RuntimeError: panicked at 'This is the panic triggered by \\`prisma_fmt::debug_panic()\\`', prisma-schema-wasm/src/lib.rs:0:0`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = \"postgres://user:password@randomhost:5432\"\n        }\n\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"getDMMF","suites":["artificial-panic getDMMF"],"updatePoint":{"line":217,"column":13},"line":217,"code":"  it('getDMMF', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_DMMF = '1'\n\n    try {\n      await getDMMF({\n        datamodel: /* prisma */ `generator client {\n  provider = \"prisma-client-js\"\n}`,\n      })\n    } catch (e) {\n      expect(serialize(e.message)).toMatchInlineSnapshot(\n        `RuntimeError: panicked at 'This is the panic triggered by \\`prisma_fmt::debug_panic()\\`', prisma-schema-wasm/src/lib.rs:0:0`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact --option [value]","suites":[],"updatePoint":{"line":7,"column":34},"line":7,"code":"it('should redact --option [value]', () => {\n  for (const option of SENSITIVE_CLI_OPTIONS) {\n    expect(redactCommandArray(['cmd', option, 'secret'])).toEqual(['cmd', option, '[redacted]'])\n  }\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact --option=[value]","suites":[],"updatePoint":{"line":13,"column":34},"line":13,"code":"it('should redact --option=[value]', () => {\n  for (const option of SENSITIVE_CLI_OPTIONS) {\n    expect(redactCommandArray(['cmd', `${option}=secret`])).toEqual(['cmd', `${option}=[redacted]`])\n  }\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a PostgreSQL connection string","suites":[],"updatePoint":{"line":19,"column":48},"line":19,"code":"it('should redact a PostgreSQL connection string', () => {\n  expect(redactCommandArray(['init', '--url', '\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"']))\n    .toMatchInlineSnapshot(`\n    [\n      init,\n      --url,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a MySQL connection string","suites":[],"updatePoint":{"line":30,"column":43},"line":30,"code":"it('should redact a MySQL connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url \"mysql://janedoe:mypassword@localhost:3306/mydb?connection_limit=5&socket_timeout\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a MongoDB connection string","suites":[],"updatePoint":{"line":44,"column":45},"line":44,"code":"it('should redact a MongoDB connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url \"mongodb+srv://root:<password>@cluster0.ab1cd.mongodb.net/myDatabase?retryWrites=true&w=majority\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a SQLite connection string","suites":[],"updatePoint":{"line":58,"column":44},"line":58,"code":"it('should redact a SQLite connection string', () => {\n  expect(redactCommandArray(['init', '--url', '\"file:./dev.db\"'])).toMatchInlineSnapshot(`\n    [\n      init,\n      --url,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a SQL Server connection string","suites":[],"updatePoint":{"line":68,"column":48},"line":68,"code":"it('should redact a SQL Server connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url=\"sqlserver://localhost:1433;initial catalog=sample;user=sa;password=mypassword;\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a path with for example --schema","suites":[],"updatePoint":{"line":82,"column":50},"line":82,"code":"it('should redact a path with for example --schema', () => {\n  expect(redactCommandArray(['cmd', '--schema', '../../../../directory/my_schema.prisma'])).toMatchInlineSnapshot(`\n    [\n      cmd,\n      --schema,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a name with for example --name","suites":[],"updatePoint":{"line":92,"column":48},"line":92,"code":"it('should redact a name with for example --name', () => {\n  expect(redactCommandArray(['cmd', '--name', '1234_my_name'])).toMatchInlineSnapshot(`\n    [\n      cmd,\n      --name,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read data from Prisma schema","suites":[],"updatePoint":{"line":102,"column":39},"line":102,"code":"it('should read data from Prisma schema', async () => {\n  ctx.fixture('checkpoint-read-schema')\n\n  await expect(tryToReadDataFromSchema('./schema.prisma')).resolves.toMatchInlineSnapshot(`\n    {\n      schemaGeneratorsProviders: [\n        prisma-client-js,\n        something,\n      ],\n      schemaPreviewFeatures: [\n        extendedIndexes,\n      ],\n      schemaProvider: sqlite,\n    }\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":53,"column":32},"line":53,"code":"it('no params should return help', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":61,"column":14},"line":61,"code":"it('wrong flag', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":69,"column":13},"line":69,"code":"it('help flag', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":77,"column":19},"line":77,"code":"it('unknown command', async () => {\n  await expect(cliInstance.parse(['doesnotexist'])).resolves.toThrow()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"introspect should include deprecation warning","suites":[],"updatePoint":{"line":81,"column":49},"line":81,"code":"it('introspect should include deprecation warning', async () => {\n  const result = cliInstance.parse(['introspect'])\n\n  await expect(result).rejects.toMatchInlineSnapshot(`\n          Could not find a schema.prisma file that is required for this command.\n          You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n        `)\n  expect(ctx.mocked['console.log'].mock.calls).toHaveLength(0)\n  expect(ctx.mocked['console.info'].mock.calls).toHaveLength(0)\n  expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n    prisma:warn \n    prisma:warn The prisma introspect command is deprecated. Please use prisma db pull instead.\n    prisma:warn \n  `)\n  expect(ctx.mocked['console.error'].mock.calls).toHaveLength(0)\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should add a trailing EOL","suites":["format"],"updatePoint":{"line":18,"column":31},"line":18,"code":"  it('should add a trailing EOL', async () => {\n    ctx.fixture('example-project/prisma')\n    await Format.new().parse([])\n    expect(fs.read('schema.prisma')).toMatchSnapshot()\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should add missing backrelation","suites":["format"],"updatePoint":{"line":24,"column":37},"line":24,"code":"  it('should add missing backrelation', async () => {\n    ctx.fixture('example-project/prisma')\n    await Format.new().parse(['--schema=missing-backrelation.prisma'])\n    expect(fs.read('missing-backrelation.prisma')).toMatchSnapshot()\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw if schema is broken","suites":["format"],"updatePoint":{"line":30,"column":38},"line":30,"code":"  it('should throw if schema is broken', async () => {\n    ctx.fixture('example-project/prisma')\n    await expect(Format.new().parse(['--schema=broken.prisma'])).rejects.toThrow()\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should succeed and show a warning on stderr (preview feature deprecated)","suites":["format"],"updatePoint":{"line":35,"column":78},"line":35,"code":"  it('should succeed and show a warning on stderr (preview feature deprecated)', async () => {\n    ctx.fixture('lint-warnings')\n    await expect(Format.new().parse(['--schema=preview-feature-deprecated.prisma'])).resolves.toBeTruthy()\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            Prisma schema warning:\n            - Preview feature \"nativeTypes\" is deprecated. The functionality can be used without specifying it as a preview feature.\n      `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw with an error and show a warning on stderr (preview feature deprecated)","suites":["format"],"updatePoint":{"line":48,"column":90},"line":48,"code":"  it('should throw with an error and show a warning on stderr (preview feature deprecated)', async () => {\n    ctx.fixture('lint-warnings')\n    await expect(Format.new().parse(['--schema=preview-feature-deprecated-and-error.prisma'])).rejects.toThrow('P1012')\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            Prisma schema warning:\n            - Preview feature \"nativeTypes\" is deprecated. The functionality can be used without specifying it as a preview feature.\n      `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should succeed and NOT show a warning when PRISMA_DISABLE_WARNINGS is truthy","suites":["format"],"updatePoint":{"line":61,"column":82},"line":61,"code":"  it('should succeed and NOT show a warning when PRISMA_DISABLE_WARNINGS is truthy', async () => {\n    ctx.fixture('lint-warnings')\n\n    process.env.PRISMA_DISABLE_WARNINGS = 'true'\n\n    await expect(Format.new().parse(['--schema=preview-feature-deprecated.prisma'])).resolves.toBeTruthy()\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toEqual('')\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toEqual('')\n  })","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should work with a custom output dir","suites":["using cli"],"updatePoint":{"line":12,"column":42},"line":12,"code":"  it('should work with a custom output dir', async () => {\n    ctx.fixture('example-project')\n    const data = await ctx.cli('generate')\n\n    if (typeof data.signal === 'number' && data.signal !== 0) {\n      throw new Error(data.stderr + data.stdout)\n    }\n\n    const { main } = await import(ctx.fs.path('main.ts'))\n    expect(replaceEngineType(data.stdout)).toMatchSnapshot()\n    await expect(main()).resolves.toMatchSnapshot()\n  }, 60_000) // timeout","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should error with exit code 1 with incorrect schema","suites":["using cli"],"updatePoint":{"line":25,"column":57},"line":25,"code":"  it('should error with exit code 1 with incorrect schema', async () => {\n    ctx.fixture('broken-example-project')\n    await expect(ctx.cli('generate').catch((e) => e.exitCode)).resolves.toEqual(1)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should work with a custom generator","suites":["using cli"],"updatePoint":{"line":30,"column":41},"line":30,"code":"  it('should work with a custom generator', async () => {\n    ctx.fixture('custom-generator')\n    const data = await ctx.cli('generate')\n\n    if (typeof data.signal === 'number' && data.signal !== 0) {\n      throw new Error(data.stderr + data.stdout)\n    }\n\n    expect(data.stdout).toContain(`I am a minimal generator`)\n  }, 75_000) // timeout","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should work","suites":["--schema from project directory"],"updatePoint":{"line":43,"column":41},"line":43,"code":"  it('--schema relative path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-project-dir')\n    const result = await Generate.new().parse(['--schema=./schema.prisma'])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should fail - invalid path","suites":["--schema from project directory"],"updatePoint":{"line":64,"column":56},"line":64,"code":"  it('--schema relative path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const result = Generate.new().parse(['--schema=./doesnotexists.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(\n      `Provided --schema at ./doesnotexists.prisma doesn't exist.`,\n    )\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should work","suites":["--schema from project directory"],"updatePoint":{"line":72,"column":41},"line":72,"code":"  it('--schema absolute path: should work', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const absoluteSchemaPath = path.resolve('./schema.prisma')\n    const result = await Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    expect(replaceEngineType(result)).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should fail - invalid path","suites":["--schema from project directory"],"updatePoint":{"line":87,"column":56},"line":87,"code":"  it('--schema absolute path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const absoluteSchemaPath = path.resolve('./doesnotexists.prisma')\n    const result = Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    await expect(result).rejects.toThrow(`Provided --schema at ${absoluteSchemaPath} doesn't exist.`)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should work","suites":["--schema from parent directory"],"updatePoint":{"line":96,"column":41},"line":96,"code":"  it('--schema relative path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-parent-dir')\n    const result = await Generate.new().parse(['--schema=./subdirectory/schema.prisma'])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./subdirectory/@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './subdirectory/@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './subdirectory/@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should fail - invalid path","suites":["--schema from parent directory"],"updatePoint":{"line":117,"column":56},"line":117,"code":"  it('--schema relative path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-parent-dir')\n\n    const result = Generate.new().parse(['--schema=./subdirectory/doesnotexists.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(\n      `Provided --schema at ./subdirectory/doesnotexists.prisma doesn't exist.`,\n    )\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should work","suites":["--schema from parent directory"],"updatePoint":{"line":126,"column":41},"line":126,"code":"  it('--schema absolute path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-parent-dir')\n    const absoluteSchemaPath = path.resolve('./subdirectory/schema.prisma')\n    const result = await Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./subdirectory/@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './subdirectory/@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './subdirectory/@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should fail - invalid path","suites":["--schema from parent directory"],"updatePoint":{"line":148,"column":56},"line":148,"code":"  it('--schema absolute path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-parent-dir')\n\n    const absoluteSchemaPath = path.resolve('./subdirectory/doesnotexists.prisma')\n    const result = Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    await expect(result).rejects.toThrow(`Provided --schema at ${absoluteSchemaPath} doesn't exist.`)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--generator: should work - valid generator names","suites":["--schema from parent directory"],"updatePoint":{"line":156,"column":54},"line":156,"code":"  it('--generator: should work - valid generator names', async () => {\n    ctx.fixture('example-project')\n    const result = await Generate.new().parse([\n      '--schema=./prisma/multiple-generator.prisma',\n      '--generator=client',\n      '--generator=client_3',\n    ])\n    const output = stripAnsi(replaceEngineType(result))\n\n    expect(output).toMatchSnapshot()\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--generator: should fail - single invalid generator name","suites":["--schema from parent directory"],"updatePoint":{"line":168,"column":62},"line":168,"code":"  it('--generator: should fail - single invalid generator name', async () => {\n    ctx.fixture('example-project')\n\n    await expect(\n      Generate.new().parse([\n        '--schema=./prisma/multiple-generator.prisma',\n        '--generator=client',\n        '--generator=invalid_client',\n      ]),\n    ).rejects.toMatchSnapshot()\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--generator: should fail - multiple invalid generator names","suites":["--schema from parent directory"],"updatePoint":{"line":180,"column":65},"line":180,"code":"  it('--generator: should fail - multiple invalid generator names', async () => {\n    ctx.fixture('example-project')\n\n    await expect(\n      Generate.new().parse([\n        '--schema=./prisma/multiple-generator.prisma',\n        '--generator=client',\n        '--generator=invalid_client',\n        '--generator=invalid_client_2',\n      ]),\n    ).rejects.toMatchSnapshot()\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"is schema and env written on disk replace","suites":[],"updatePoint":{"line":10,"column":47},"line":10,"code":"test('is schema and env written on disk replace', async () => {\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatch(defaultEnv())\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with url param","suites":[],"updatePoint":{"line":22,"column":26},"line":22,"code":"test('works with url param', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--url', 'file:dev.db')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlite'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"file:dev.db\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - postgresql","suites":[],"updatePoint":{"line":43,"column":44},"line":43,"code":"test('works with provider param - postgresql', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'postgresql')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('postgresql'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - cockroachdb","suites":[],"updatePoint":{"line":64,"column":45},"line":64,"code":"test('works with provider param - cockroachdb', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'cockroachdb')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('cockroachdb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:26257/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider and url params - cockroachdb","suites":[],"updatePoint":{"line":85,"column":54},"line":85,"code":"test('works with provider and url params - cockroachdb', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli(\n    'init',\n    '--datasource-provider',\n    'cockroachdb',\n    '--url',\n    'postgres://prisma@localhost:26257/defaultdb',\n  )\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('cockroachdb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:26257/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - mysql","suites":[],"updatePoint":{"line":112,"column":39},"line":112,"code":"test('works with provider param - mysql', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'mysql')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('mysql'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - SQLITE","suites":[],"updatePoint":{"line":133,"column":40},"line":133,"code":"test('works with provider param - SQLITE', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'SQLITE')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlite'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"file:./dev.db\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - SqlServer","suites":[],"updatePoint":{"line":154,"column":43},"line":154,"code":"test('works with provider param - SqlServer', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'SqlServer')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlserver'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=SA;password=randompassword;\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - MongoDB","suites":[],"updatePoint":{"line":175,"column":41},"line":175,"code":"test('works with provider param - MongoDB', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'MongoDB')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('mongodb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"mongodb+srv://root:randompassword@cluster0.ab1cd.mongodb.net/mydb?retryWrites=true&w=majority\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"errors with invalid provider param","suites":[],"updatePoint":{"line":196,"column":40},"line":196,"code":"test('errors with invalid provider param', async () => {\n  ctx.fixture('init')\n  const result = ctx.cli('init', '--datasource-provider', 'INVALID')\n  await expect(result).rejects.toThrow()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"warns when DATABASE_URL present in .env ","suites":[],"updatePoint":{"line":202,"column":46},"line":202,"code":"test('warns when DATABASE_URL present in .env ', async () => {\n  fs.writeFileSync(join(ctx.tmpDir, '.env'), `DATABASE_URL=\"postgres://dont:overwrite@me:5432/tests\"`)\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.all!)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatch(`DATABASE_URL=\"postgres://dont:overwrite@me:5432/tests\"`)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"appends when .env present","suites":[],"updatePoint":{"line":215,"column":31},"line":215,"code":"test('appends when .env present', async () => {\n  fs.writeFileSync(join(ctx.tmpDir, '.env'), `SOMETHING=\"is here\"`)\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchSnapshot()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"writes a minimal .gitignore file","suites":[],"updatePoint":{"line":228,"column":38},"line":228,"code":"test('writes a minimal .gitignore file', async () => {\n  ctx.fixture('init')\n  await ctx.cli('init')\n  const gitignore = fs.readFileSync(join(ctx.tmpDir, '.gitignore'), 'utf-8')\n  expect(gitignore).toMatch(defaultGitIgnore())\n\n  expect(gitignore).toMatchSnapshot()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"ignore .gitignore file if already present (do not override)","suites":[],"updatePoint":{"line":237,"column":65},"line":237,"code":"test('ignore .gitignore file if already present (do not override)', async () => {\n  ctx.fixture('init')\n  const gitignorePath = join(ctx.tmpDir, '.gitignore')\n  fs.writeFileSync(gitignorePath, `# This should not be overridden`)\n  const gitignoreBefore = fs.readFileSync(gitignorePath, 'utf-8')\n  await ctx.cli('init')\n  const gitignoreAfter = fs.readFileSync(gitignorePath, 'utf-8')\n  expect(gitignoreAfter).toEqual(gitignoreBefore)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should fail if url is prisma://","suites":["Studio CLI"],"updatePoint":{"line":41,"column":37},"line":41,"code":"  it('should fail if url is prisma://', async () => {\n    ctx.fixture('schema-only-data-proxy')\n\n    const result = Studio.new().parse([])\n\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      Using the Data Proxy (connection URL starting with protocol prisma://) is not supported for this CLI command prisma studio yet. \n\n      More information about Data Proxy: https://pris.ly/d/data-proxy-cli\n\n    `)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should fail if url is prisma:// and directUrl is set","suites":["Studio CLI"],"updatePoint":{"line":55,"column":58},"line":55,"code":"  it('should fail if url is prisma:// and directUrl is set', async () => {\n    ctx.fixture('schema-only-data-proxy-direct-url')\n\n    const result = Studio.new().parse([])\n\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      Using the Data Proxy (connection URL starting with protocol prisma://) is not supported for this CLI command prisma studio yet. \n\n      More information about Data Proxy: https://pris.ly/d/data-proxy-cli\n\n    `)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can start up correctly","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":103,"column":30},"line":103,"code":"  test('can start up correctly', async () => {\n    const res = await fetch(`http://localhost:${STUDIO_TEST_PORT}`)\n    expect(res.status).toEqual(200)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `findMany` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":108,"column":41},"line":108,"code":"  test('can respond to `findMany` queries', async () => {\n    const res = await sendRequest({\n      requestId: 1,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'findMany',\n          args: {\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `create` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":135,"column":39},"line":135,"code":"  test('can respond to `create` queries', async () => {\n    const res = await sendRequest({\n      requestId: 2,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'create',\n          args: {\n            data: {\n              id: 3,\n              string: '',\n              int: 0,\n              float: 0.0,\n              datetime: '2020-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `update` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":179,"column":39},"line":179,"code":"  test('can respond to `update` queries', async () => {\n    const res = await sendRequest({\n      requestId: 3,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'update',\n          args: {\n            where: {\n              id: 1,\n            },\n            data: {\n              string: 'Changed String',\n              int: 100,\n              float: 100.5,\n              datetime: '2025-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `delete` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":225,"column":39},"line":225,"code":"  test('can respond to `delete` queries', async () => {\n    const res = await sendRequest({\n      requestId: 4,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'delete',\n          args: {\n            where: { id: 2 },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can start up correctly","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":286,"column":30},"line":286,"code":"  test('can start up correctly', async () => {\n    const res = await fetch(`http://localhost:${STUDIO_TEST_PORT}`)\n    expect(res.status).toEqual(200)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `findMany` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":291,"column":41},"line":291,"code":"  test('can respond to `findMany` queries', async () => {\n    const res = await sendRequest({\n      requestId: 1,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'findMany',\n          args: {\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `create` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":318,"column":39},"line":318,"code":"  test('can respond to `create` queries', async () => {\n    const res = await sendRequest({\n      requestId: 2,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'create',\n          args: {\n            data: {\n              id: 3,\n              string: '',\n              int: 0,\n              float: 0.0,\n              datetime: '2020-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `update` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":362,"column":39},"line":362,"code":"  test('can respond to `update` queries', async () => {\n    const res = await sendRequest({\n      requestId: 3,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'update',\n          args: {\n            where: {\n              id: 1,\n            },\n            data: {\n              string: 'Changed String',\n              int: 100,\n              float: 100.5,\n              datetime: '2025-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `delete` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":408,"column":39},"line":408,"code":"  test('can respond to `delete` queries', async () => {\n    const res = await sendRequest({\n      requestId: 4,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'delete',\n          args: {\n            where: { id: 2 },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should succeed if schema is valid","suites":["validate"],"updatePoint":{"line":18,"column":39},"line":18,"code":"  it('should succeed if schema is valid', async () => {\n    ctx.fixture('example-project/prisma')\n    await expect(Validate.new().parse(['--schema=schema.prisma'])).resolves.toContain('is valid')\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw if schema is invalid","suites":["validate"],"updatePoint":{"line":23,"column":39},"line":23,"code":"  it('should throw if schema is invalid', async () => {\n    ctx.fixture('example-project/prisma')\n    await expect(Validate.new().parse(['--schema=broken.prisma'])).rejects.toThrow('Prisma schema validation')\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw if env var is not set","suites":["validate"],"updatePoint":{"line":28,"column":40},"line":28,"code":"  it('should throw if env var is not set', async () => {\n    ctx.fixture('example-project/prisma')\n    await expect(Validate.new().parse(['--schema=env-does-not-exists.prisma'])).rejects.toThrow(\n      'Environment variable not found',\n    )\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should succeed and show a warning on stderr (preview feature deprecated)","suites":["validate"],"updatePoint":{"line":35,"column":78},"line":35,"code":"  it('should succeed and show a warning on stderr (preview feature deprecated)', async () => {\n    ctx.fixture('lint-warnings')\n    await expect(Validate.new().parse(['--schema=preview-feature-deprecated.prisma'])).resolves.toBeTruthy()\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n      Prisma schema warning:\n      - Preview feature \"nativeTypes\" is deprecated. The functionality can be used without specifying it as a preview feature.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw with an error and show a warning on stderr (preview feature deprecated)","suites":["validate"],"updatePoint":{"line":48,"column":90},"line":48,"code":"  it('should throw with an error and show a warning on stderr (preview feature deprecated)', async () => {\n    ctx.fixture('lint-warnings')\n    await expect(Validate.new().parse(['--schema=preview-feature-deprecated-and-error.prisma'])).rejects.toThrow(\n      'P1012',\n    )\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                          Prisma schema warning:\n                                          - Preview feature \"nativeTypes\" is deprecated. The functionality can be used without specifying it as a preview feature.\n                          `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should succeed and NOT show a warning when PRISMA_DISABLE_WARNINGS is truthy","suites":["validate"],"updatePoint":{"line":63,"column":82},"line":63,"code":"  it('should succeed and NOT show a warning when PRISMA_DISABLE_WARNINGS is truthy', async () => {\n    ctx.fixture('lint-warnings')\n\n    process.env.PRISMA_DISABLE_WARNINGS = 'true'\n\n    await expect(Validate.new().parse(['--schema=preview-feature-deprecated.prisma'])).resolves.toBeTruthy()\n\n    // stderr\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toEqual('')\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toEqual('')\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should reject NoAction referential action on Postgres when relationMode = \"prisma\"","suites":["validate","referential actions"],"updatePoint":{"line":80,"column":90},"line":80,"code":"    it('should reject NoAction referential action on Postgres when relationMode = \"prisma\"', async () => {\n      expect.assertions(1)\n\n      try {\n        await Validate.new().parse(['--schema', './prisma/postgres.prisma'])\n      } catch (e) {\n        expect(serializeQueryEngineName(e.message)).toMatchInlineSnapshot(`\n          Prisma schema validation - (validate wasm)\n          Error code: P1012\n          error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n            -->  schema.prisma:21\n             | \n          20 |   id       String @id @default(cuid())\n          21 |   user     SomeUser @relation(fields: [userId], references: [id], onUpdate: NoAction)\n             | \n          error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n            -->  schema.prisma:28\n             | \n          27 |   id       String @id @default(cuid())\n          28 |   user     SomeUser @relation(fields: [userId], references: [id], onDelete: NoAction)\n             | \n\n          Validation Error Count: 2\n          [Context: validate]\n\n          Prisma CLI Version : 0.0.0\n        `)\n      }\n    })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should reject NoAction referential action on sqlite when relationMode = \"prisma\"","suites":["validate","referential actions"],"updatePoint":{"line":110,"column":88},"line":110,"code":"    it('should reject NoAction referential action on sqlite when relationMode = \"prisma\"', async () => {\n      expect.assertions(1)\n\n      try {\n        await Validate.new().parse(['--schema', './prisma/postgres.prisma'])\n      } catch (e) {\n        expect(serializeQueryEngineName(e.message)).toMatchInlineSnapshot(`\n          Prisma schema validation - (validate wasm)\n          Error code: P1012\n          error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n            -->  schema.prisma:21\n             | \n          20 |   id       String @id @default(cuid())\n          21 |   user     SomeUser @relation(fields: [userId], references: [id], onUpdate: NoAction)\n             | \n          error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n            -->  schema.prisma:28\n             | \n          27 |   id       String @id @default(cuid())\n          28 |   user     SomeUser @relation(fields: [userId], references: [id], onDelete: NoAction)\n             | \n\n          Validation Error Count: 2\n          [Context: validate]\n\n          Prisma CLI Version : 0.0.0\n        `)\n      }\n    })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should accept NoAction referential action on e.g. MySQL when relationMode = \"prisma\"","suites":["validate","referential actions"],"updatePoint":{"line":140,"column":92},"line":140,"code":"    it('should accept NoAction referential action on e.g. MySQL when relationMode = \"prisma\"', async () => {\n      const result = await Validate.new().parse(['--schema', './prisma/mysql.prisma'])\n      expect(result).toBeTruthy()\n    })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should error when dependent generator is missing","suites":[],"updatePoint":{"line":6,"column":52},"line":6,"code":"it('should error when dependent generator is missing', async () => {\n  expect.assertions(1)\n\n  try {\n    await execa.node(path.join(__dirname, '../../build/index.js'), ['generate'], {\n      cwd: path.join(__dirname, './fixtures/dependent-generator'),\n      stdio: 'pipe',\n    })\n  } catch (e) {\n    expect(e.stderr).toMatchSnapshot()\n  }\n})","file":"dependent-generator.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in root folder and custom-path","suites":[],"updatePoint":{"line":6,"column":56},"line":6,"code":"it('should read .env file in root folder and custom-path', () => {\n  ctx.fixture('dotenv-1-custom-schema-path')\n  loadEnvFile('./custom-path/schema.prisma', true)\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_WHEN_CUSTOM_SCHEMA_PATH_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT).toEqual('shouldbebread')\n  expect(process.env.DOTENV_PRISMA_WHEN_CUSTOM_SCHEMA_PATH_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-1-custom-schema-path.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in prisma folder","suites":[],"updatePoint":{"line":6,"column":42},"line":6,"code":"it('should read .env file in prisma folder', () => {\n  ctx.fixture('dotenv-2-prisma-folder')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-2-prisma-folder.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw error","suites":[],"updatePoint":{"line":5,"column":22},"line":5,"code":"it('should throw error', async () => {\n  ctx.fixture('dotenv-3-conflict')\n  expect.assertions(1)\n\n  await expect(\n    ctx.cli('validate').catch((e) => {\n      const message = e.message.split('\\n').slice(1).join('\\n')\n      throw new Error(message)\n    }),\n  ).rejects.toThrowErrorMatchingInlineSnapshot(`\n          Error: There is a conflict between env var in .env and prisma/.env\n          Conflicting env vars:\n            SHOULD_THROW\n\n          We suggest to move the contents of prisma/.env to .env to consolidate your env vars.\n\n        `)\n})","file":"dotenv-3-conflict.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in prisma folder when there is no schema","suites":[],"updatePoint":{"line":6,"column":66},"line":6,"code":"it('should read .env file in prisma folder when there is no schema', () => {\n  ctx.fixture('dotenv-4-prisma-no-schema')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_NO_SCHEMA_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-4-prisma-when-no-schema.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should not load root .env file","suites":[],"updatePoint":{"line":6,"column":34},"line":6,"code":"it('should not load root .env file', () => {\n  ctx.fixture('dotenv-5-only-root')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-5-only-root.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read expanded env vars","suites":[],"updatePoint":{"line":6,"column":33},"line":6,"code":"it('should read expanded env vars', () => {\n  ctx.fixture('dotenv-6-expand')\n  loadEnvFile('./expand/schema.prisma', true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_EXPAND_DATABASE_URL_WITH_SCHEMA).toEqual(\n    'postgres://user:password@server.host:5432/database?ssl=1&schema=schema1234',\n  )\n})","file":"dotenv-6-expand.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":104,"column":14},"line":104,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":109,"column":16},"line":109,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":118,"column":15},"line":118,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":127,"column":15},"line":127,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":136,"column":18},"line":136,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Error validating datasource \\`db\\`: the URL must start with the protocol \\`postgresql://\\` or \\`postgres://\\`.\n            -->  schema.prisma:5\n             | \n           4 |   provider = \"postgresql\"\n           5 |   url      = env(\"SOME_DEFINED_INVALID_URL\")\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":158,"column":21},"line":158,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":167,"column":19},"line":167,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":182,"column":16},"line":182,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":191,"column":15},"line":191,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":200,"column":15},"line":200,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":209,"column":18},"line":209,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Environment variable not found: SOME_UNDEFINED_DB.\n            -->  schema.prisma:5\n             | \n           4 |   provider = \"postgresql\"\n           5 |   url      = env(\"SOME_UNDEFINED_DB\")\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":231,"column":21},"line":231,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":240,"column":19},"line":240,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":255,"column":14},"line":255,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":266,"column":16},"line":266,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('validate'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":275,"column":14},"line":275,"code":"    it('format', async () => {\n      expect.assertions(1)\n\n      try {\n        await Format.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(\n          urlIsMissingValidationError('validate'),\n        )\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","empty-schema"],"updatePoint":{"line":293,"column":14},"line":293,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","empty-schema"],"updatePoint":{"line":298,"column":16},"line":298,"code":"    it('validate', async () => {\n      const result = await Validate.new().parse([])\n      expect(result).toMatch(/^The schema at (.*) is valid 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":309,"column":15},"line":309,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('get-config'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":318,"column":15},"line":318,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('get-config'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":327,"column":18},"line":327,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Argument \"url\" is missing in data source block \"db\".\n            -->  schema.prisma:3\n             | \n           2 | \n           3 | datasource db {\n           4 |   provider = \"postgresql\"\n           5 | }\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":351,"column":21},"line":351,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('get-config'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":360,"column":19},"line":360,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('get-config'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":377,"column":15},"line":377,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(aDatasourceBlockIsMissingError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":386,"column":15},"line":386,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(thereIsNoDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":395,"column":18},"line":395,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(thereIsNoDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":406,"column":21},"line":406,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(aDatasourceBlockIsMissingError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":415,"column":19},"line":415,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(aDatasourceBlockIsMissingError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should exit 1 and print a message when Node.js version is lower than minimum - 16.0","suites":[],"updatePoint":{"line":7,"column":87},"line":7,"code":"it('should exit 1 and print a message when Node.js version is lower than minimum - 16.0', () => {\n  const mockExit = jest.spyOn(process, 'exit').mockImplementation()\n\n  printMessageAndExitIfUnsupportedNodeVersion('v16.0.0')\n\n  expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n    ┌──────────────────────────────────────────────┐\n    │    Prisma only supports Node.js >= 16.13.    │\n    │    Please upgrade your Node.js version.      │\n    └──────────────────────────────────────────────┘\n  `)\n\n  expect(mockExit).toHaveBeenCalledWith(1)\n  mockExit.mockRestore()\n})","file":"preinstall.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should exit 1 and print a message when Node.js version is lower than minimum - 14.13","suites":[],"updatePoint":{"line":23,"column":88},"line":23,"code":"it('should exit 1 and print a message when Node.js version is lower than minimum - 14.13', () => {\n  const mockExit = jest.spyOn(process, 'exit').mockImplementation()\n\n  printMessageAndExitIfUnsupportedNodeVersion('v14.13.0')\n\n  expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n    ┌──────────────────────────────────────────────┐\n    │    Prisma only supports Node.js >= 16.13.    │\n    │    Please upgrade your Node.js version.      │\n    └──────────────────────────────────────────────┘\n  `)\n\n  expect(mockExit).toHaveBeenCalledWith(1)\n  mockExit.mockRestore()\n})","file":"preinstall.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should do nothing when Node.js version is supported - 16.13","suites":[],"updatePoint":{"line":39,"column":63},"line":39,"code":"it('should do nothing when Node.js version is supported - 16.13', () => {\n  printMessageAndExitIfUnsupportedNodeVersion('v16.13.0')\n\n  expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n})","file":"preinstall.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should do nothing when Node.js version is supported - current","suites":[],"updatePoint":{"line":45,"column":65},"line":45,"code":"it('should do nothing when Node.js version is supported - current', () => {\n  printMessageAndExitIfUnsupportedNodeVersion(process.version)\n\n  expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n})","file":"preinstall.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"normal release","suites":[],"updatePoint":{"line":33,"column":20},"line":33,"code":"test('normal release', () => {\n  printUpdateMessageFromTo('4.5.0', '4.6.0')\n  expect(consoleErrorMock.mock.calls[0][0]).toMatchInlineSnapshot(`\n    ┌─────────────────────────────────────────────────────────┐\n    │  Update available 4.5.0 -> 4.6.0                        │\n    │  Run the following to update                            │\n    │    npm i --save-dev prisma@4.6.0                        │\n    │    npm i @prisma/client@4.6.0                           │\n    └─────────────────────────────────────────────────────────┘\n  `)\n})","file":"printUpdateMessage.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"integration version with long name","suites":[],"updatePoint":{"line":45,"column":40},"line":45,"code":"test('integration version with long name', () => {\n  printUpdateMessageFromTo('4.5.0-integration-use-keep-alive-for-node-fetch.1', '4.6.0')\n  expect(consoleErrorMock.mock.calls[0][0]).toMatchInlineSnapshot(`\n    ┌───────────────────────────────────────────────────────────────────────────────┐\n    │  Update available 4.5.0-integration-use-keep-alive-for-node-fetch.1 -> 4.6.0  │\n    │  Run the following to update                                                  │\n    │    npm i --save-dev prisma@4.6.0                                              │\n    │    npm i @prisma/client@4.6.0                                                 │\n    └───────────────────────────────────────────────────────────────────────────────┘\n  `)\n})","file":"printUpdateMessage.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"dev tag - minor","suites":["update available message"],"updatePoint":{"line":8,"column":21},"line":8,"code":"  it('dev tag - minor', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1-dev.18',\n        current_version: '2.16.0-dev.8',\n        package: 'prisma',\n        release_tag: 'dev',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('npm i --save-dev prisma@dev')\n    expect(message).toContain('npm i @prisma/client@dev')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"dev tag - major","suites":["update available message"],"updatePoint":{"line":25,"column":21},"line":25,"code":"  it('dev tag - major', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1-dev.18',\n        current_version: '3.0.1-dev.8',\n        package: 'prisma',\n        release_tag: 'dev',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('This is a major update')\n    expect(message).toContain('npm i --save-dev prisma@dev')\n    expect(message).toContain('npm i @prisma/client@dev')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"latest tag - minor","suites":["update available message"],"updatePoint":{"line":43,"column":24},"line":43,"code":"  it('latest tag - minor', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1',\n        current_version: '2.16.0',\n        package: 'prisma',\n        release_tag: 'latest',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('npm i --save-dev prisma@latest')\n    expect(message).toContain('npm i @prisma/client@latest')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"latest tag - major","suites":["update available message"],"updatePoint":{"line":60,"column":24},"line":60,"code":"  it('latest tag - major', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1',\n        current_version: '3.0.0',\n        package: 'prisma',\n        release_tag: 'latest',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('This is a major update')\n    expect(message).toContain('npm i --save-dev prisma@latest')\n    expect(message).toContain('npm i @prisma/client@latest')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should error correctly with invalid flags","suites":["BinaryEngine"],"updatePoint":{"line":9,"column":49},"line":9,"code":"  test('should error correctly with invalid flags', async () => {\n    // Skip for Node-API library\n    // TODO Better scoping when to run this test so this conditional is not necessary\n    if (getClientEngineType() === ClientEngineType.Library) {\n      return\n    }\n\n    try {\n      const engine = new BinaryEngine({\n        dirname: __dirname,\n        flags: ['--flag-that-does-not-exist'],\n        datamodelPath: path.join(__dirname, './runtime-tests/blog/schema.prisma'),\n        tracingHelper: disabledTracingHelper,\n        env: {},\n        cwd: process.cwd(),\n        logEmitter: new EventEmitter(),\n      })\n      await engine.start()\n    } catch (e) {\n      expect(e.message).toMatch(` Found argument '--flag-that-does-not-exist' which wasn't expected`)\n    }\n  })","file":"binaryEngine.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and a single engine","suites":["library"],"updatePoint":{"line":13,"column":60},"line":13,"code":"  it('generates annotations for a schema and a single engine', () => {\n    const annotations = buildNFTAnnotations(false, ClientEngineType.Library, ['debian-openssl-1.1.x'], 'out')\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and multiple engines","suites":["library"],"updatePoint":{"line":25,"column":61},"line":25,"code":"  it('generates annotations for a schema and multiple engines', () => {\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and a single engine","suites":["binary"],"updatePoint":{"line":50,"column":60},"line":50,"code":"  it('generates annotations for a schema and a single engine', () => {\n    const annotations = buildNFTAnnotations(false, ClientEngineType.Binary, ['debian-openssl-1.1.x'], 'out')\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n            path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n            path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n            path.join(__dirname, \"schema.prisma\");\n            path.join(process.cwd(), \"out/schema.prisma\")\n        `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and multiple engines","suites":["binary"],"updatePoint":{"line":62,"column":61},"line":62,"code":"  it('generates annotations for a schema and multiple engines', () => {\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Binary,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n            path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n            path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n\n            path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n            path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n\n            path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n            path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n            path.join(__dirname, \"schema.prisma\");\n            path.join(process.cwd(), \"out/schema.prisma\")\n        `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates no annotations","suites":["dataproxy"],"updatePoint":{"line":87,"column":30},"line":87,"code":"  it('generates no annotations', () => {\n    const annotations = buildNFTAnnotations(\n      true,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    // TODO: when using .toMatchInlineSnapshot(), this fails after updating snapshots.\n    // Probably an issue with the snapshot serializer?\n    expect(normalizePaths(annotations)).toBe(``)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"replaces platforms with [\"rhel-openssl-1.0.x\"] on Netlify","suites":["special cases"],"updatePoint":{"line":106,"column":63},"line":106,"code":"  it('replaces platforms with [\"rhel-openssl-1.0.x\"] on Netlify', () => {\n    process.env.NETLIFY = 'true'\n\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    delete process.env.NETLIFY\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n\n    expect(annotations).toContain('rhel-openssl-1.0.x')\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with 0","suites":["deepGet"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  test('work with 0', () => {\n    const obj = {\n      aggregateUser: {\n        count: 0,\n      },\n    }\n    const path = ['aggregateUser', 'count']\n    const result = deepGet(obj, path)\n    expect(result).toMatchInlineSnapshot(`0`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with false","suites":["deepGet"],"updatePoint":{"line":15,"column":23},"line":15,"code":"  test('work with false', () => {\n    const obj = {\n      aggregateUser: {\n        count: false,\n      },\n    }\n    const path = ['aggregateUser', 'count']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`false`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with deep object","suites":["deepGet"],"updatePoint":{"line":25,"column":29},"line":25,"code":"  test('work with deep object', () => {\n    const obj = {\n      very: {\n        deep: {\n          obj: {\n            with: {\n              deep: 'stuff',\n            },\n          },\n        },\n      },\n    }\n    const path = ['very', 'deep', 'obj']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`\n      {\n        with: {\n          deep: stuff,\n        },\n      }\n    `)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"return undefined for invalid path","suites":["deepGet"],"updatePoint":{"line":47,"column":41},"line":47,"code":"  test('return undefined for invalid path', () => {\n    const obj = {\n      very: {\n        deep: {\n          obj: {\n            with: {\n              deep: 'stuff',\n            },\n          },\n        },\n      },\n    }\n    const path = ['very', 'deep', 'obj2']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`undefined`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with array","suites":["deepGet"],"updatePoint":{"line":63,"column":23},"line":63,"code":"  test('work with array', () => {\n    const obj = [\n      {\n        id: 1,\n      },\n    ]\n\n    const path = ['0', 'id']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`1`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"int","suites":["deserializeRawResults"],"updatePoint":{"line":4,"column":11},"line":4,"code":"  test('int', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'int',\n            prisma__value: 42,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 42,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bigint","suites":["deserializeRawResults"],"updatePoint":{"line":21,"column":14},"line":21,"code":"  test('bigint', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bigint',\n            prisma__value: '10000',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: BigInt(10000),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"floating point","suites":["deserializeRawResults"],"updatePoint":{"line":38,"column":22},"line":38,"code":"  test('floating point', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'float',\n            prisma__value: 1.5,\n          },\n          b: {\n            prisma__type: 'double',\n            prisma__value: 0.5,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 1.5,\n        b: 0.5,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"string","suites":["deserializeRawResults"],"updatePoint":{"line":60,"column":14},"line":60,"code":"  test('string', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'string',\n            prisma__value: 'hello',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'hello',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"enum","suites":["deserializeRawResults"],"updatePoint":{"line":77,"column":12},"line":77,"code":"  test('enum', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'enum',\n            prisma__value: 'value',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'value',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bytes","suites":["deserializeRawResults"],"updatePoint":{"line":94,"column":13},"line":94,"code":"  test('bytes', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bytes',\n            prisma__value: 'Ynl0ZXM=',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: Buffer.from('bytes'),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bool","suites":["deserializeRawResults"],"updatePoint":{"line":111,"column":12},"line":111,"code":"  test('bool', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bool',\n            prisma__value: true,\n          },\n          b: {\n            prisma__type: 'bool',\n            prisma__value: false,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: true,\n        b: false,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"null","suites":["deserializeRawResults"],"updatePoint":{"line":133,"column":12},"line":133,"code":"  test('null', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'null',\n            prisma__value: null,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: null,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"json","suites":["deserializeRawResults"],"updatePoint":{"line":150,"column":12},"line":150,"code":"  test('json', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'json',\n            prisma__value: {\n              a: 1,\n              b: [2],\n            },\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: {\n          a: 1,\n          b: [2],\n        },\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"date and time","suites":["deserializeRawResults"],"updatePoint":{"line":173,"column":21},"line":173,"code":"  test('date and time', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'datetime',\n            prisma__value: '2022-01-01T00:00:00.000Z',\n          },\n          b: {\n            prisma__type: 'date',\n            prisma__value: '2022-05-04',\n          },\n          c: {\n            prisma__type: 'time',\n            prisma__value: '14:10:45.912',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: new Date('2022-01-01T00:00:00.000Z'),\n        b: new Date('2022-05-04T00:00:00.000Z'),\n        c: new Date('1970-01-01T14:10:45.912Z'),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"unsupported","suites":["deserializeRawResults"],"updatePoint":{"line":200,"column":19},"line":200,"code":"  test('unsupported', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'char',\n            prisma__value: 'a',\n          },\n          b: {\n            prisma__type: 'xml',\n            prisma__value: '<xml></xml>',\n          },\n          c: {\n            prisma__type: 'uuid',\n            prisma__value: '00000000-0000-0000-0000-000000000000',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'a',\n        b: '<xml></xml>',\n        c: '00000000-0000-0000-0000-000000000000',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"array","suites":["deserializeRawResults"],"updatePoint":{"line":227,"column":13},"line":227,"code":"  test('array', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'array',\n            prisma__value: [\n              {\n                prisma__type: 'int',\n                prisma__value: 1,\n              },\n              {\n                prisma__type: 'int',\n                prisma__value: 2,\n              },\n            ],\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: [1, 2],\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum filter mysql","suites":["dmmf"],"updatePoint":{"line":5,"column":30},"line":5,"code":"  test('dmmf enum filter mysql', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"mysql\"\n        url      = env(\"MY_MYSQL_DB\")\n      }\n      \n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n      \n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    const dmmf = await getDMMF({ datamodel })\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'NestedEnumPostKindFilter'))\n      .toMatchInlineSnapshot(`\n      {\n        constraints: {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: [\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: EnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: NestedEnumPostKindFilter,\n      }\n    `)\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'EnumPostKindFilter')).toMatchInlineSnapshot(`\n      {\n        constraints: {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: [\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: EnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: EnumPostKindFilter,\n      }\n    `)\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum filter postgresql","suites":["dmmf"],"updatePoint":{"line":178,"column":35},"line":178,"code":"  test('dmmf enum filter postgresql', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"postgresql\"\n        url      = env(\"MY_POSTGRES_DB\")\n      }\n      \n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n      \n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    const dmmf = await getDMMF({ datamodel })\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'NestedEnumPostKindFilter'))\n      .toMatchInlineSnapshot(`\n      {\n        constraints: {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: [\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: EnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: ListEnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: ListEnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: NestedEnumPostKindFilter,\n      }\n    `)\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'EnumPostKindFilter')).toMatchInlineSnapshot(`\n      {\n        constraints: {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: [\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: EnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: ListEnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          {\n            inputTypes: [\n              {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: fieldRefTypes,\n                namespace: prisma,\n                type: ListEnumPostKindFieldRefInput,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          {\n            inputTypes: [\n              {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: EnumPostKindFilter,\n      }\n    `)\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum should fail on sqlite","suites":["dmmf"],"updatePoint":{"line":375,"column":39},"line":375,"code":"  test('dmmf enum should fail on sqlite', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"sqlite\"\n        url      = \"file:./dev.db\"\n      }\n\n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n\n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    try {\n      await getDMMF({ datamodel })\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n        Prisma schema validation - (get-dmmf wasm)\n        Error code: P1012\n        error: Error validating: You defined the enum \\`PostKind\\`. But the current connector does not support enums.\n          -->  schema.prisma:14\n           | \n        13 | \n        14 |       enum PostKind {\n        15 |         NICE\n        16 |         AWESOME\n        17 |       }\n           | \n\n        Validation Error Count: 1\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf types","suites":[],"line":27,"code":"test.skip('dmmf types', async () => {","file":"dmmfTypes.test.ts","skipped":true,"dir":"packages/client/src/__tests__"},{"name":"ignore comments","suites":[],"updatePoint":{"line":4,"column":21},"line":4,"code":"test('ignore comments', () => {\n  const datamodel = `datasource db {\n    provider = \"sqlite\"\n    // url = \"file:another/wrong/folder/dev.db\"\n    url      = \"file:my/folder/dev.db\"\n  }\n\n  generator client {\n    provider  = \"prisma-client-js\"\n    output    = \"@prisma/client\"\n    transpile = false\n  }\n\n  model User {\n    id    String  @id @default(uuid())\n    email String  @unique\n    name  String?\n    posts Post[]\n  }\n\n  model Post {\n    id         String   @id @default(uuid())\n    createdAt  DateTime @default(now())\n    updatedAt  DateTime @updatedAt\n    randomDate DateTime\n    published  Boolean\n    title      String\n    content    String?\n    author     User?\n  }\n\n  /// Role num comment\n  enum Role {\n    USER\n    ADMIN\n  }`\n\n  const result = extractSqliteSources(datamodel, '/cwd', '/outputdir')\n\n  expect(result).toMatchInlineSnapshot(`\n    [\n      {\n        name: db,\n        url: ../cwd/my/folder/dev.db,\n      },\n    ]\n  `)\n\n  let serializedResult = serializeDatasources(result)\n\n  // TODO: Windows: fixup to work around a bug in jestSnapshotSerializer\n  if (process.platform === 'win32') {\n    serializedResult = serializedResult.replace(/\\\\\\\\/g, '/')\n  }\n\n  expect(serializedResult).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"../cwd/my/folder/dev.db\"\n      }\n    ]\n  `)\n})","file":"extractSqliteSources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"basic happy path","suites":[],"updatePoint":{"line":69,"column":22},"line":69,"code":"test('basic happy path', () => {\n  const datamodel = `datasource db {\n    provider = \"sqlite\"\n    url      = \"file:my/folder/dev.db\"\n    \n  }\n\n  generator client {\n    provider  = \"prisma-client-js\"\n    output    = \"@prisma/client\"\n    transpile = false\n  }\n\n  model User {\n    id    String  @id @default(uuid())\n    email String  @unique\n    name  String?\n    posts Post[]\n  }\n\n  model Post {\n    id         String   @id @default(uuid())\n    createdAt  DateTime @default(now())\n    updatedAt  DateTime @updatedAt\n    randomDate DateTime\n    published  Boolean\n    title      String\n    content    String?\n    author     User?\n  }\n\n  /// Role num comment\n  enum Role {\n    USER\n    ADMIN\n  }`\n\n  const result = extractSqliteSources(datamodel, '/cwd', '/outputdir')\n\n  expect(result).toMatchInlineSnapshot(`\n    [\n      {\n        name: db,\n        url: ../cwd/my/folder/dev.db,\n      },\n    ]\n  `)\n\n  let serializedResult = serializeDatasources(result)\n\n  // TODO: Windows: fixup to work around a bug in jestSnapshotSerializer\n  if (process.platform === 'win32') {\n    serializedResult = serializedResult.replace(/\\\\\\\\/g, '/')\n  }\n\n  expect(serializedResult).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"../cwd/my/folder/dev.db\"\n      }\n    ]\n  `)\n})","file":"extractSqliteSources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"minimal","suites":["generator"],"updatePoint":{"line":17,"column":15},"line":17,"code":"  test('minimal', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'schema.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    const manifest = omit<any, any>(generator.manifest, ['version']) as any\n\n    if (manifest.requiresEngineVersion.length !== 40) {\n      throw new Error(`Generator manifest should have \"requiresEngineVersion\" with length 40`)\n    }\n    manifest.requiresEngineVersion = 'ENGINE_VERSION_TEST'\n\n    if (getClientEngineType() === ClientEngineType.Library) {\n      expect(manifest).toMatchInlineSnapshot(`\n        {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: [\n            libqueryEngine,\n          ],\n        }\n      `)\n    } else {\n      expect(manifest).toMatchInlineSnapshot(`\n        {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: [\n            queryEngine,\n          ],\n        }\n      `)\n    }\n\n    expect(omit(generator.options!.generator, ['output'])).toMatchInlineSnapshot(`\n      {\n        binaryTargets: [\n          {\n            fromEnvVar: null,\n            native: true,\n            value: TEST_PLATFORM,\n          },\n        ],\n        config: {},\n        name: client,\n        previewFeatures: [],\n        provider: {\n          fromEnvVar: null,\n          value: prisma-client-js,\n        },\n      }\n    `)\n\n    expect(path.relative(__dirname, parseEnvValue(generator.options!.generator.output!))).toMatchInlineSnapshot(\n      `node_modules/@prisma/client`,\n    )\n\n    await generator.generate()\n    const photonDir = path.join(__dirname, 'node_modules/@prisma/client')\n    expect(fs.existsSync(photonDir)).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index-browser.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.d.ts'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'runtime'))).toBe(true)\n    generator.stop()\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"denylist from engine validation","suites":["generator"],"updatePoint":{"line":103,"column":39},"line":103,"code":"  test('denylist from engine validation', async () => {\n    expect.assertions(1)\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    try {\n      await getGenerator({\n        schemaPath: path.join(__dirname, 'denylist.prisma'),\n        baseDir: __dirname,\n        printDownloadProgress: false,\n        skipDownload: true,\n        dataProxy: false,\n      })\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n        Prisma schema validation - (get-dmmf wasm)\n        Error code: P1012\n        error: Error validating model \"public\": The model name \\`public\\` is invalid. It is a reserved name. Please change it. Read more at https://pris.ly/d/naming-models\n          -->  schema.prisma:10\n           | \n         9 | \n        10 | model public {\n        11 |   id Int @id\n        12 | }\n           | \n        error: Error validating model \"return\": The model name \\`return\\` is invalid. It is a reserved name. Please change it. Read more at https://pris.ly/d/naming-models\n          -->  schema.prisma:14\n           | \n        13 | \n        14 | model return {\n        15 |   id Int @id\n        16 | }\n           | \n\n        Validation Error Count: 2\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"schema path does not exist","suites":["generator"],"updatePoint":{"line":155,"column":34},"line":155,"code":"  test('schema path does not exist', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    let doesNotExistError\n    try {\n      await getGenerator({\n        schemaPath: path.join(__dirname, 'doesnotexist.prisma'),\n        baseDir: __dirname,\n        printDownloadProgress: false,\n        skipDownload: true,\n        dataProxy: false,\n      })\n    } catch (e) {\n      doesNotExistError = e\n    } finally {\n      expect(stripAnsi(doesNotExistError.message).split('generation' + path.sep)[1]).toMatchInlineSnapshot(\n        `doesnotexist.prisma does not exist`,\n      )\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"override client package","suites":["generator"],"updatePoint":{"line":187,"column":31},"line":187,"code":"  test('override client package', async () => {\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'main-package-override.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    try {\n      await expect(generator.generate()).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Generating client into /client/src/__tests__/generation/__fixture__/@prisma/client is not allowed.\n        This package is used by \\`prisma generate\\` and overwriting its content is dangerous.\n\n        Suggestion:\n        In /client/src/__tests__/generation/main-package-override.prisma replace:\n\n        8 output   = \"./__fixture__/@prisma/client\"\n        with\n        8 output   = \"./__fixture__/.prisma/client\"\n\n        You won't need to change your imports.\n        Imports from \\`@prisma/client\\` will be automatically forwarded to \\`.prisma/client\\`\n      `)\n    } finally {\n      generator.stop()\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"mongo","suites":["generator"],"updatePoint":{"line":216,"column":13},"line":216,"code":"  test('mongo', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'mongo.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    const manifest = omit<any, any>(generator.manifest, ['version']) as any\n\n    if (manifest.requiresEngineVersion.length !== 40) {\n      throw new Error(`Generator manifest should have \"requiresEngineVersion\" with length 40`)\n    }\n    manifest.requiresEngineVersion = 'ENGINE_VERSION_TEST'\n\n    if (getClientEngineType(generator.config) === ClientEngineType.Library) {\n      expect(manifest).toMatchInlineSnapshot(`\n        {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: [\n            libqueryEngine,\n          ],\n        }\n      `)\n    } else {\n      expect(manifest).toMatchInlineSnapshot(`\n        {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: [\n            queryEngine,\n          ],\n        }\n      `)\n    }\n\n    expect(omit(generator.options!.generator, ['output'])).toMatchInlineSnapshot(`\n      {\n        binaryTargets: [\n          {\n            fromEnvVar: null,\n            native: true,\n            value: TEST_PLATFORM,\n          },\n        ],\n        config: {},\n        name: client,\n        previewFeatures: [],\n        provider: {\n          fromEnvVar: null,\n          value: prisma-client-js,\n        },\n      }\n    `)\n\n    expect(path.relative(__dirname, parseEnvValue(generator.options!.generator.output!))).toMatchInlineSnapshot(\n      `node_modules/@prisma/client`,\n    )\n\n    await generator.generate()\n    const photonDir = path.join(__dirname, 'node_modules/@prisma/client')\n    expect(fs.existsSync(photonDir)).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index-browser.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.d.ts'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'runtime'))).toBe(true)\n    generator.stop()\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"info and warn","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('info and warn', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'info',\n    },\n    {\n      emit: 'event',\n      level: 'warn',\n    },\n  ])\n\n  expect(level).toMatchInlineSnapshot(`info`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"query","suites":[],"updatePoint":{"line":18,"column":11},"line":18,"code":"test('query', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'query',\n    },\n  ])\n\n  expect(level).toMatchInlineSnapshot(`undefined`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings and objects","suites":[],"updatePoint":{"line":29,"column":25},"line":29,"code":"test('strings and objects', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'query',\n    },\n    'warn',\n  ])\n\n  expect(level).toMatchInlineSnapshot(`warn`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings","suites":[],"updatePoint":{"line":40,"column":13},"line":40,"code":"test('strings', () => {\n  const level = getLogLevel('warn')\n\n  expect(level).toMatchInlineSnapshot(`warn`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings array","suites":[],"updatePoint":{"line":46,"column":19},"line":46,"code":"test('strings array', () => {\n  const level = getLogLevel(['warn', 'error'])\n\n  expect(level).toMatchInlineSnapshot(`error`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine-native-binaryTarget: binary","suites":[],"updatePoint":{"line":8,"column":48},"line":8,"code":"test('missing-engine-native-binaryTarget: binary', async () => {\n  if (getClientEngineType() !== ClientEngineType.Binary) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  let binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n\n  if (process.platform === 'win32') {\n    binaryPath += '.exe'\n  }\n\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/binary.test.ts:0:0\n\n      36 })\n      37 \n      38 await expect(async () => {\n    → 39   await prisma.user.findMany(\n    Prisma Client could not locate the Query Engine for runtime \"TEST_PLATFORM\".\n\n    This is likely caused by tooling that has not copied \"query-engine-TEST_PLATFORM\" to the deployment folder.\n    Ensure that you ran \\`prisma generate\\` and that \"query-engine-TEST_PLATFORM\" has been copied to \"src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\".\n\n    We would appreciate if you could take the time to share some information with us.\n    Please help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\n\n    The following locations have been searched:\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget\n  `)\n})","file":"integration/errors/missing-engine-native-binaryTarget/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine-native-binaryTarget: library","suites":[],"updatePoint":{"line":8,"column":49},"line":8,"code":"test('missing-engine-native-binaryTarget: library', async () => {\n  if (getClientEngineType() !== ClientEngineType.Library) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  const binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/library.test.ts:0:0\n\n      31 })\n      32 \n      33 await expect(async () => {\n    → 34   await prisma.user.findMany(\n    Prisma Client could not locate the Query Engine for runtime \"TEST_PLATFORM\".\n\n    This is likely caused by tooling that has not copied \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\" to the deployment folder.\n    Ensure that you ran \\`prisma generate\\` and that \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\" has been copied to \"src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\".\n\n    We would appreciate if you could take the time to share some information with us.\n    Please help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\n\n    The following locations have been searched:\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget\n  `)\n})","file":"integration/errors/missing-engine-native-binaryTarget/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine: binary","suites":[],"updatePoint":{"line":8,"column":28},"line":8,"code":"test('missing-engine: binary', async () => {\n  if (getClientEngineType() !== ClientEngineType.Binary) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  let binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n\n  if (process.platform === 'win32') {\n    binaryPath += '.exe'\n  }\n\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine/binary.test.ts:0:0\n\n      36 })\n      37 \n      38 await expect(async () => {\n    → 39   await prisma.user.findMany(\n    Prisma Client could not locate the Query Engine for runtime \"TEST_PLATFORM\".\n\n    This is likely caused by tooling that has not copied \"query-engine-TEST_PLATFORM\" to the deployment folder.\n    Ensure that you ran \\`prisma generate\\` and that \"query-engine-TEST_PLATFORM\" has been copied to \"src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\".\n\n    We would appreciate if you could take the time to share some information with us.\n    Please help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\n\n    The following locations have been searched:\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine\n  `)\n})","file":"integration/errors/missing-engine/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine: library","suites":[],"updatePoint":{"line":8,"column":29},"line":8,"code":"test('missing-engine: library', async () => {\n  if (getClientEngineType() !== ClientEngineType.Library) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  const binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine/library.test.ts:0:0\n\n      31 })\n      32 \n      33 await expect(async () => {\n    → 34   await prisma.user.findMany(\n    Prisma Client could not locate the Query Engine for runtime \"TEST_PLATFORM\".\n\n    This is likely caused by tooling that has not copied \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\" to the deployment folder.\n    Ensure that you ran \\`prisma generate\\` and that \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\" has been copied to \"src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\".\n\n    We would appreciate if you could take the time to share some information with us.\n    Please help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\n\n    The following locations have been searched:\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine\n  `)\n})","file":"integration/errors/missing-engine/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema-mongo (binary)","suites":[],"updatePoint":{"line":3,"column":45},"line":3,"code":"test('not-so-exhaustive-schema-mongo (binary)', testGeneratedClient('binary'))","file":"integration/happy/not-so-exhaustive-schema-mongo/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema-mongo (data-proxy)","suites":[],"updatePoint":{"line":3,"column":49},"line":3,"code":"test('not-so-exhaustive-schema-mongo (data-proxy)', testGeneratedClient('dataProxy'))","file":"integration/happy/not-so-exhaustive-schema-mongo/data-proxy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf-types","suites":[],"updatePoint":{"line":15,"column":16},"line":15,"code":"test('dmmf-types', async () => {\n  const datamodel = fs.readFileSync(path.join(__dirname, 'schema.prisma'), 'utf-8')\n  const dmmf = await getDMMF({\n    datamodel,\n  })\n  const dmmfFile = path.join(__dirname, 'generated-dmmf.ts')\n\n  fs.writeFileSync(\n    dmmfFile,\n    `import { DMMF } from '@prisma/generator-helper'\n\n  const dmmf: DMMF.Document = ${JSON.stringify(dmmf, null, 2)}`,\n  )\n\n  await expect(compileFile(dmmfFile)).resolves.not.toThrow()\n})","file":"integration/happy/not-so-exhaustive-schema-mongo/dmmf-types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema-mongo (library)","suites":[],"updatePoint":{"line":3,"column":46},"line":3,"code":"test('not-so-exhaustive-schema-mongo (library)', testGeneratedClient('library'))","file":"integration/happy/not-so-exhaustive-schema-mongo/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema (binary)","suites":[],"updatePoint":{"line":3,"column":39},"line":3,"code":"test('not-so-exhaustive-schema (binary)', testGeneratedClient('binary'))","file":"integration/happy/not-so-exhaustive-schema/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema (data-proxy)","suites":[],"updatePoint":{"line":3,"column":43},"line":3,"code":"test('not-so-exhaustive-schema (data-proxy)', testGeneratedClient('dataProxy'))","file":"integration/happy/not-so-exhaustive-schema/data-proxy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf-types","suites":[],"updatePoint":{"line":15,"column":16},"line":15,"code":"test('dmmf-types', async () => {\n  const datamodel = fs.readFileSync(path.join(__dirname, 'schema.prisma'), 'utf-8')\n  const dmmf = await getDMMF({\n    datamodel,\n  })\n  const dmmfFile = path.join(__dirname, 'generated-dmmf.ts')\n\n  fs.writeFileSync(\n    dmmfFile,\n    `import { DMMF } from '@prisma/generator-helper'\n\n  const dmmf: DMMF.Document = ${JSON.stringify(dmmf, null, 2)}`,\n  )\n\n  await expect(compileFile(dmmfFile)).resolves.not.toThrow()\n})","file":"integration/happy/not-so-exhaustive-schema/dmmf-types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"not-so-exhaustive-schema (library)","suites":[],"updatePoint":{"line":3,"column":40},"line":3,"code":"test('not-so-exhaustive-schema (library)', testGeneratedClient('library'))","file":"integration/happy/not-so-exhaustive-schema/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"basic mergeBy","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('basic mergeBy', () => {\n  const arr1 = [\n    {\n      name: 'db',\n      url: 'file:old-url.db',\n    },\n  ]\n  const arr2 = [\n    {\n      name: 'db',\n      url: 'file:new-url.db',\n    },\n  ]\n  expect(mergeBy(arr1, arr2, (a) => a.name)).toMatchInlineSnapshot(`\n    [\n      {\n        name: db,\n        url: file:new-url.db,\n      },\n    ]\n  `)\n})","file":"mergeBy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"mergeBy should merge last item","suites":[],"updatePoint":{"line":26,"column":36},"line":26,"code":"test('mergeBy should merge last item', () => {\n  const arr1 = [\n    {\n      name: 'db',\n      url: 'file:old-url.db',\n    },\n  ]\n  const arr2 = [\n    {\n      name: 'db',\n      url: 'file:new-url.db',\n    },\n    {\n      name: 'db',\n      url: 'file:new-url2.db',\n    },\n  ]\n  expect(mergeBy(arr1, arr2, (a) => a.name)).toMatchInlineSnapshot(`\n    [\n      {\n        name: db,\n        url: file:new-url2.db,\n      },\n    ]\n  `)\n})","file":"mergeBy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"absolutizeRelativePath","suites":[],"updatePoint":{"line":9,"column":28},"line":9,"code":"test('absolutizeRelativePath', () => {\n  expect(absolutizeRelativePath('file:db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../prisma/db.db`)\n  expect(absolutizeRelativePath('file:/db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../../../../db.db`)\n  expect(absolutizeRelativePath('file:../db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../db.db`)\n  expect(absolutizeRelativePath('file:./db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../prisma/db.db`)\n\n  expect(absolutizeRelativePath('file:asd/another/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../prisma/asd/another/dir/db.db`,\n  )\n  expect(absolutizeRelativePath('file:/some/random/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../../../../some/random/dir/db.db`,\n  )\n  expect(\n    absolutizeRelativePath('file:/Users/tim/project/node_modules/@prisma/client/runtime', cwd, outputDir),\n  ).toMatchInlineSnapshot(``)\n  expect(absolutizeRelativePath('file:../another-dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../another-dir/db.db`,\n  )\n  expect(absolutizeRelativePath('file:./some/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../prisma/some/dir/db.db`,\n  )\n})","file":"resolveDatasources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"serializeDatasources","suites":[],"updatePoint":{"line":75,"column":26},"line":75,"code":"test('serializeDatasources', () => {\n  expect(serializeDatasources(datasources.map(datasourceToDatasourceOverwrite))).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"file:db.db\"\n      },\n      {\n        \"name\": \"db2\",\n        \"url\": \"file:./some-dir/db.db\"\n      },\n      {\n        \"name\": \"db3\",\n        \"url\": \"mysql:localhost\"\n      },\n      {\n        \"name\": \"db4\",\n        \"url\": \"postgresql://\"\n      }\n    ]\n  `)\n})","file":"resolveDatasources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"joins the argv array of strings input into one single string","suites":[],"updatePoint":{"line":16,"column":66},"line":16,"code":"test('joins the argv array of strings input into one single string', () => {\n  expect(getPostInstallTrigger()).toEqual('npm foo bar')\n})","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty original argv array results in just the package manager name as the command","suites":[],"updatePoint":{"line":20,"column":87},"line":20,"code":"test('empty original argv array results in just the package manager name as the command', () => {\n  process.env.npm_config_argv = '{\"original\":[]}'\n  expect(getPostInstallTrigger()).toEqual('npm')\n})","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"gets package manager name from npm_config_user_agent when matching userAgent pattern e.g. for %s","suites":["npm_config_user_agent"],"line":26,"code":"  test.each([['yarn'], ['npm'], ['pnpm'], ['qux']])(\n    'gets package manager name from npm_config_user_agent when matching userAgent pattern e.g. for %s',\n    (name) => {\n      process.env.npm_config_user_agent = `${name}/1.2.3`\n      expect(getPostInstallTrigger()).toEqual(`${name} foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"trailing whitespace on command trimmed","suites":["npm_config_user_agent"],"updatePoint":{"line":34,"column":46},"line":34,"code":"  test('trailing whitespace on command trimmed', () => {\n    process.env.npm_config_user_agent = 'npm /1.2.3'\n    expect(getPostInstallTrigger()).toEqual('npm foo bar')\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"leading whitespace on command trimmed","suites":["npm_config_user_agent"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  test('leading whitespace on command trimmed', () => {\n    process.env.npm_config_user_agent = '  npm/1.2.3'\n    expect(getPostInstallTrigger()).toEqual('npm foo bar')\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"if npm_config_user_agent not available then falls back to MISSING_NPM_CONFIG_USER_AGENT","suites":["npm_config_user_agent"],"line":43,"code":"  test.each([[undefined], [''], [' ']])(\n    'if npm_config_user_agent not available then falls back to MISSING_NPM_CONFIG_USER_AGENT',\n    (value) => {\n      if (value === undefined) {\n        delete process.env.npm_config_user_agent\n      } else {\n        process.env.npm_config_user_agent = value\n      }\n      delete process.env.npm_config_user_agent\n      expect(getPostInstallTrigger()).toEqual(`MISSING_NPM_CONFIG_USER_AGENT foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"if npm_config_user_agent not parsable then falls back to UNKNOWN_NPM_CONFIG_USER_AGENT","suites":["npm_config_user_agent"],"line":56,"code":"  test.each([['foo@1.2.3']])(\n    'if npm_config_user_agent not parsable then falls back to UNKNOWN_NPM_CONFIG_USER_AGENT',\n    (userAgentString) => {\n      process.env.npm_config_user_agent = userAgentString\n      expect(getPostInstallTrigger()).toEqual(`UNKNOWN_NPM_CONFIG_USER_AGENT(${userAgentString}) foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"%s","suites":["fails gracefully with"],"line":67,"code":"  test.each([\n    ['envar missing', undefined, UNABLE_TO_FIND_POSTINSTALL_TRIGGER__ENVAR_MISSING],\n    ['envar bad json', 'bah', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_PARSE_ERROR +': bah'],\n    ['envar bad json schema missing field', '{}', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_SCHEMA_ERROR+': {}'],\n    ['envar bad json schema bad field type', '{\"original\":1}', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_SCHEMA_ERROR+': {\"original\":1}'],\n  ])('%s', (_, envVarValue, expected) => {\n    if (envVarValue === undefined) {\n       delete process.env.npm_config_argv\n     } else  {\n       process.env.npm_config_argv = envVarValue\n     }\n    expect(getPostInstallTrigger()).toEqual(expected)\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty","suites":["serializeRawParameters"],"updatePoint":{"line":10,"column":13},"line":10,"code":"  test('empty', () => {\n    expect(serialize([])).toEqual([])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"primitives","suites":["serializeRawParameters"],"updatePoint":{"line":14,"column":18},"line":14,"code":"  test('primitives', () => {\n    const data = [0, 1, true, false, '', 'hi', null, undefined]\n    expect(serialize(data)).toEqual([0, 1, true, false, '', 'hi', null, null])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"date","suites":["serializeRawParameters"],"updatePoint":{"line":19,"column":12},"line":19,"code":"  test('date', () => {\n    const data = [new Date('2020-06-22T17:07:16.348Z')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'date',\n        prisma__value: '2020-06-22T17:07:16.348Z',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"BigInt","suites":["serializeRawParameters"],"updatePoint":{"line":30,"column":14},"line":30,"code":"  test('BigInt', () => {\n    const data = [BigInt('321804719213721')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bigint',\n        prisma__value: '321804719213721',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Decimal","suites":["serializeRawParameters"],"updatePoint":{"line":41,"column":15},"line":41,"code":"  test('Decimal', () => {\n    const data = [new Decimal(1.1)]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'decimal',\n        prisma__value: '1.1',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Buffer","suites":["serializeRawParameters"],"updatePoint":{"line":52,"column":14},"line":52,"code":"  test('Buffer', () => {\n    const data = [Buffer.from('hello')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'aGVsbG8=',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"typed byte arrays","suites":["serializeRawParameters"],"updatePoint":{"line":63,"column":25},"line":63,"code":"  test('typed byte arrays', () => {\n    const data = [\n      Int8Array.of(0x69, 0x6e, 0x74, 0x38),\n      Uint8Array.of(0x75, 0x69, 0x6e, 0x74, 0x38),\n      Uint8ClampedArray.of(0x75, 0x69, 0x6e, 0x74, 0x38, 0x63),\n    ]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'aW50OA==',\n      },\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'dWludDg=',\n      },\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'dWludDhj',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"ArrayBuffer","suites":["serializeRawParameters"],"updatePoint":{"line":86,"column":19},"line":86,"code":"  test('ArrayBuffer', () => {\n    const arrayBuffer = new ArrayBuffer(6)\n    const array = new Uint8Array(arrayBuffer)\n    array.set([0x62, 0x75, 0x66, 0x66, 0x65, 0x72])\n\n    expect(serialize([arrayBuffer])).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'YnVmZmVy',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"SharedArrayBuffer","suites":["serializeRawParameters"],"updatePoint":{"line":99,"column":25},"line":99,"code":"  test('SharedArrayBuffer', () => {\n    const sharedArrayBuffer = new SharedArrayBuffer(6)\n    const array = new Uint8Array(sharedArrayBuffer)\n    array.set([0x73, 0x68, 0x61, 0x72, 0x65, 0x64])\n\n    expect(serialize([sharedArrayBuffer])).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'c2hhcmVk',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"no BigInts","suites":["serializeRawParameters","objects"],"updatePoint":{"line":115,"column":20},"line":115,"code":"    test('no BigInts', () => {\n      const data = [\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: new Date('2020-06-22T17:07:16.348Z'),\n          buffer: Buffer.from('hello'),\n        },\n        {\n          nested: {\n            array: [new Date('2020-06-22T17:07:16.348Z'), '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ]\n\n      expect(serialize(data)).toEqual([\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: '2020-06-22T17:07:16.348Z',\n          buffer: { type: 'Buffer', data: [104, 101, 108, 108, 111] },\n        },\n        {\n          nested: {\n            array: ['2020-06-22T17:07:16.348Z', '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ])\n    })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"with BigInts","suites":["serializeRawParameters","objects"],"updatePoint":{"line":151,"column":22},"line":151,"code":"    test('with BigInts', () => {\n      const data = [\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: new Date('2020-06-22T17:07:16.348Z'),\n          bigInt: BigInt('321804719213721'),\n          buffer: Buffer.from('hello'),\n        },\n        {\n          nested: {\n            array: [new Date('2020-06-22T17:07:16.348Z'), BigInt('321804719213721')],\n          },\n        },\n        [123, BigInt('321804719213721')],\n      ]\n\n      expect(serialize(data)).toEqual([\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: '2020-06-22T17:07:16.348Z',\n          bigInt: '321804719213721',\n          buffer: { type: 'Buffer', data: [104, 101, 108, 108, 111] },\n        },\n        {\n          nested: {\n            array: ['2020-06-22T17:07:16.348Z', '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ])\n    })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":" does not depend on 'node' types","suites":["runtime .d.ts files"],"updatePoint":{"line":9,"column":49},"line":9,"code":"    test(`${file} does not depend on 'node' types`, () => {\n      const dtsContents = fs.readFileSync(path.join(runtimeDir, file), 'utf8')\n      expect(dtsContents).not.toContain('/// <reference types=\"node\" />')\n    })","file":"typeDeclaration.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"%s","suites":["valid types"],"line":22,"code":"  test.concurrent.each(subDirs)('%s', async (dir) => {\n    const testName = path.basename(dir)\n\n    const nodeModules = path.join(dir, 'node_modules')\n    if (fs.existsSync(nodeModules)) {\n      await del(nodeModules)\n    }\n    await generateInFolder({\n      projectDir: dir,\n      useLocalRuntime: false,\n      transpile: true,\n      packageSource,\n    })\n\n    const indexPath = path.join(dir, 'test.ts')\n    const tsdTestPath = path.join(dir, 'index.test-d.ts')\n    const engineSpecificTestPath = path.join(dir, `test.${getClientEngineType()}.ts`)\n\n    if (fs.existsSync(tsdTestPath)) {\n      await runTsd(dir)\n    }\n\n    if (testName.startsWith('unhappy')) {\n      await expect(compileFile(indexPath)).rejects.toThrow()\n    } else {\n      await expect(compileFile(indexPath)).resolves.not.toThrow()\n    }\n\n    if (fs.existsSync(engineSpecificTestPath)) {\n      if (testName.startsWith('unhappy')) {\n        await expect(compileFile(engineSpecificTestPath)).rejects.toThrow()\n      } else {\n        await expect(compileFile(engineSpecificTestPath)).resolves.not.toThrow()\n      }\n    }\n  })","file":"types/types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty","suites":["valid options"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('empty', () => {\n    expect.assertions(0)\n    validatePrismaClientOptions({}, ['db'])\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"full","suites":["valid options"],"updatePoint":{"line":8,"column":12},"line":8,"code":"  test('full', () => {\n    expect.assertions(0)\n    validatePrismaClientOptions(\n      {\n        datasources: {\n          db: {\n            url: '',\n          },\n        },\n        errorFormat: 'pretty',\n        log: ['error'],\n      },\n      ['db'],\n    )\n\n    validatePrismaClientOptions(\n      {\n        datasources: {\n          db: {\n            url: '',\n          },\n        },\n        errorFormat: 'pretty',\n        log: [\n          {\n            emit: 'event',\n            level: 'error',\n          },\n        ],\n      },\n      ['db'],\n    )\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"typos","suites":["invalid options"],"updatePoint":{"line":44,"column":13},"line":44,"code":"  test('typos', () => {\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorsFormat: 'minimal',\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Unknown property errorsFormat provided to PrismaClient constructor. Did you mean \"errorFormat\"?\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          datasources: {\n            asd: {},\n          },\n        },\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Unknown datasource asd provided to PrismaClient constructor. Available datasources: db\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          datasources: {\n            db: { murl: '' },\n          },\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid value {\"db\":{\"murl\":\"\"}} for datasource \"db\" provided to PrismaClient constructor.\n      It should have this form: { url: \"CONNECTION_STRING\" }\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          log: [{ helo: 'world' }],\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid property helo for \"log\" provided to PrismaClient constructor\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          log: ['muery'],\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid log level \"muery\" provided to PrismaClient constructor. Did you mean \"query\"?\n      Read more at https://pris.ly/d/client-constructor\n    `)\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should not log if it is not enabled","suites":["debug"],"updatePoint":{"line":7,"column":43},"line":7,"code":"  test('should not log if it is not enabled', () => {\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\"[]\"`)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"basic.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"should log if its enabled","suites":["debug"],"updatePoint":{"line":26,"column":33},"line":26,"code":"  test('should log if its enabled', () => {\n    const debug = Debug('a-namespace')\n    const logs: string[] = []\n\n    Debug.enable('a-namespace')\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\n      \"[\n        \" a-namespace Does it even log?\",\n        \" a-namespace I dont know\"\n      ]\"\n    `)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\n      a-namespace Does it even log?\n      a-namespace I dont know\"\n    `)\n  })","file":"basic.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"empty env var works as expected","suites":["debug"],"updatePoint":{"line":6,"column":39},"line":6,"code":"  test('empty env var works as expected', async () => {\n    process.env.DEBUG = ''\n\n    const { Debug, getLogs } = await import('../index')\n\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(logs).toMatchInlineSnapshot(`[]`)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"env-disabled.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"env vars work as expected","suites":["debug"],"updatePoint":{"line":6,"column":33},"line":6,"code":"  test('env vars work as expected', async () => {\n    process.env.DEBUG = 'my-namespace'\n\n    const { Debug, getLogs } = await import('../index')\n\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\n      \"[\n        \" my-namespace Does it even log?\",\n        \" my-namespace I dont know\"\n      ]\"\n    `)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"env-enabled.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"minimal-executable","suites":["generatorHandler"],"updatePoint":{"line":91,"column":26},"line":91,"code":"  test('minimal-executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('minimal-executable'))\n    await generator.init()\n    const manifest = await generator.getManifest(stubOptions.generator)\n    expect(manifest).toMatchInlineSnapshot(`\n      {\n        \"defaultOutput\": \"default-output\",\n        \"denylists\": {\n          \"models\": [\n            \"SomeForbiddenModel\",\n          ],\n        },\n        \"prettyName\": \"This is a pretty name\",\n        \"requiresEngines\": [\n          \"schema-engine\",\n          \"query-engine\",\n        ],\n        \"requiresGenerators\": [\n          \"prisma-client-js\",\n        ],\n      }\n    `)\n    expect(() => generator.generate(stubOptions)).not.toThrow()\n\n    generator.stop()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"failing-executable","suites":["generatorHandler"],"updatePoint":{"line":118,"column":26},"line":118,"code":"  test('failing-executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('failing-executable'))\n    await generator.init()\n    await expect(generator.getManifest(stubOptions.generator)).rejects.toThrow()\n    await expect(generator.generate(stubOptions)).rejects.toThrow()\n    generator.stop()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"failing-after-1s-executable","suites":["generatorHandler"],"updatePoint":{"line":126,"column":35},"line":126,"code":"  test('failing-after-1s-executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('failing-after-1s-executable'))\n    await generator.init()\n    await expect(generator.getManifest(stubOptions.generator)).rejects.toThrow('test')\n    generator.stop()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"nonexistent executable","suites":["generatorHandler"],"updatePoint":{"line":133,"column":30},"line":133,"code":"  test('nonexistent executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('this-executable-does-not-exist'))\n    await generator.init()\n    await expect(generator.getManifest(stubOptions.generator)).rejects.toThrow()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"SQLite: should succeed","suites":["Baselining"],"updatePoint":{"line":30,"column":28},"line":30,"code":"  it('SQLite: should succeed', async () => {\n    ctx.fixture('baseline-sqlite')\n    fs.remove('prisma/migrations')\n    fs.copy('prisma/dev.db', 'prisma/prod.db')\n\n    // Start with the dev database\n    process.env.DATABASE_URL = 'file:./dev.db'\n\n    // db pull\n    const dbPull = DbPull.new().parse([])\n    await expect(dbPull).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate dev --create-only\n    prompt.inject(['y'])\n    const migrateDevCreateOnly = MigrateDev.new().parse(['--create-only'])\n    await expect(migrateDevCreateOnly).resolves.toMatchInlineSnapshot(`\n      Prisma Migrate created the following migration without applying it 20201231000000_\n\n      You can now edit it and apply it by running prisma migrate dev.\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n\n      We need to reset the SQLite database \"dev.db\" at \"file:./dev.db\"\n      Do you want to continue? All data will be lost.\n\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate dev\n    const migrateDev = MigrateDev.new().parse([])\n    await expect(migrateDev).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // Switch to PROD database\n    process.env.DATABASE_URL = 'file:./prod.db'\n\n    // migrate resolve --applied migration_name\n    const migrationName = fs.list('prisma/migrations')![0]\n    const migrateResolveProd = MigrateResolve.new().parse(['--applied', migrationName])\n    await expect(migrateResolveProd).resolves.toMatchInlineSnapshot(`Migration 20201231000000_ marked as applied.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"prod.db\" at \"file:./prod.db\"\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate deploy\n    const migrateDeployProd = MigrateDeploy.new().parse([])\n    await expect(migrateDeployProd).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"prod.db\" at \"file:./prod.db\"\n\n      1 migration found in prisma/migrations\n\n\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"Baseline.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":3,"column":32},"line":3,"code":"it('no params should return help', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":12,"column":14},"line":12,"code":"it('wrong flag', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":21,"column":13},"line":21,"code":"it('help flag', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":30,"column":19},"line":30,"code":"it('unknown command', async () => {\n  await expect(DbCommand.new({}).parse(['doesnotexist'])).resolves.toThrow()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"requires --preview-feature flag","suites":["drop"],"updatePoint":{"line":9,"column":37},"line":9,"code":"  it('requires --preview-feature flag', async () => {\n    ctx.fixture('empty')\n\n    const result = DbDrop.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            This feature is currently in Preview. There may be bugs and it's not recommended to use it in production environments.\n            Please provide the --preview-feature flag to use this command.\n          `)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["drop"],"updatePoint":{"line":19,"column":35},"line":19,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                      Could not find a schema.prisma file that is required for this command.\n                      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n                  `)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db should fail (prompt)","suites":["drop"],"updatePoint":{"line":29,"column":42},"line":29,"code":"  it('with missing db should fail (prompt)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(`The database name entered \"y\" doesn't match \"dev.db\".`)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db should fail (--force)","suites":["drop"],"updatePoint":{"line":40,"column":43},"line":40,"code":"  it('with missing db should fail (--force)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const result = DbDrop.new().parse(['--preview-feature', '--force'])\n    // Schema engine error:\n    // Failed to delete SQLite database at \\`dev.db\\`.\n    // On Linux/macOS:\n    // No such file or directory (os error 2)\n    // On Windows:\n    // No such file or directory (os error 2)\n    await expect(result).rejects.toThrow(`Failed to delete SQLite database at \\`dev.db\\`.`)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (prompt)","suites":["drop"],"updatePoint":{"line":55,"column":26},"line":55,"code":"  it('should work (prompt)', async () => {\n    ctx.fixture('reset')\n\n    prompt.inject(['dev.db']) // simulate user input\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).resolves.toContain(`The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (--force)","suites":["drop"],"updatePoint":{"line":71,"column":27},"line":71,"code":"  it('should work (--force)', async () => {\n    ctx.fixture('reset')\n\n    const result = DbDrop.new().parse(['--preview-feature', '--force'])\n    await expect(result).resolves.toContain(`The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (-f)","suites":["drop"],"updatePoint":{"line":84,"column":22},"line":84,"code":"  it('should work (-f)', async () => {\n    ctx.fixture('reset')\n    const result = DbDrop.new().parse(['--preview-feature', '-f'])\n    await expect(result).resolves.toContain(`The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should be cancelled (prompt)","suites":["drop"],"updatePoint":{"line":96,"column":34},"line":96,"code":"  it('should be cancelled (prompt)', async () => {\n    ctx.fixture('reset')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate cancel\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Drop cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should ask for --force if not provided if CI","suites":["drop"],"updatePoint":{"line":117,"column":50},"line":117,"code":"  it('should ask for --force if not provided if CI', async () => {\n    ctx.fixture('reset')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(\n      `Use the --force flag to use the drop command in an unattended environment like prisma db drop --force --preview-feature`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --file and --stdin","suites":["db execute","generic"],"updatePoint":{"line":26,"column":49},"line":26,"code":"    it('should fail if missing --file and --stdin', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse([])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          Either --stdin or --file must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --file and --stdin are provided","suites":["db execute","generic"],"updatePoint":{"line":36,"column":59},"line":36,"code":"    it('should fail if both --file and --stdin are provided', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--file=1', '--stdin'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          --stdin and --file cannot be used at the same time. Only 1 must be provided. \n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --schema and --url","suites":["db execute","generic"],"updatePoint":{"line":46,"column":49},"line":46,"code":"    it('should fail if missing --schema and --url', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--file=1'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          Either --url or --schema must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --schema and --url are provided","suites":["db execute","generic"],"updatePoint":{"line":56,"column":59},"line":56,"code":"    it('should fail if both --schema and --url are provided', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--stdin', '--schema=1', '--url=1'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          --url and --schema cannot be used at the same time. Only 1 must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if --file does no exists","suites":["db execute","generic"],"updatePoint":{"line":66,"column":44},"line":66,"code":"    it('should fail if --file does no exists', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await DbExecute.new().parse(['--file=./doesnotexists.sql', '--schema=1'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`Provided --file at ./doesnotexists.sql doesn't exist.`)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if --schema does no exists","suites":["db execute","generic"],"updatePoint":{"line":78,"column":46},"line":78,"code":"    it('should fail if --schema does no exists', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--file=./script.sql', '--schema=./doesnoexists.schema'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`Provided --schema at ./doesnoexists.schema doesn't exist.`)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with not supported error with --file --schema","suites":["db execute","mongodb"],"updatePoint":{"line":93,"column":65},"line":93,"code":"    it('should fail with not supported error with --file --schema', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      fs.writeFileSync('script.js', 'Something for MongoDB')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.js'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              dbExecute is not supported on MongoDB\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass if no schema file in directory with --file --url","suites":["db execute","sqlite"],"updatePoint":{"line":113,"column":68},"line":113,"code":"    it('should pass if no schema file in directory with --file --url', async () => {\n      ctx.fixture('empty')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:./dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":140,"column":40},"line":140,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":148,"column":60},"line":148,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n\n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url=file:dev.db","suites":["db execute","sqlite"],"updatePoint":{"line":165,"column":49},"line":165,"code":"    it('should pass with --file --url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url=file:dev.db","suites":["db execute","sqlite"],"updatePoint":{"line":173,"column":55},"line":173,"code":"    it('should pass with empty --file --url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url=file:dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","sqlite"],"updatePoint":{"line":181,"column":71},"line":181,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url=file:doesnotexists.db","suites":["db execute","sqlite"],"updatePoint":{"line":200,"column":59},"line":200,"code":"    it('should pass with --file --url=file:doesnotexists.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:doesnotexists.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with --file --schema if there is a database error","suites":["db execute","sqlite"],"updatePoint":{"line":209,"column":69},"line":209,"code":"    it('should fail with --file --schema if there is a database error', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(1)\n\n      fs.writeFileSync('script.sql', 'DROP TABLE \"test-doesnotexists\";')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.message).toMatchInlineSnapshot(`\n          SQLite database error\n          no such table: test-doesnotexists\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":226,"column":77},"line":226,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQL,itshouldfail')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          SQLite database error\n          near \"ThisisnotSQL\": syntax error in ThisisnotSQL,itshouldfail at offset 0\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":282,"column":40},"line":282,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file","suites":["db execute","postgresql"],"updatePoint":{"line":290,"column":41},"line":290,"code":"    it('should use env var from .env file', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/using-dotenv.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`5432\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`5432\\`.\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":305,"column":60},"line":305,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":322,"column":37},"line":322,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":330,"column":43},"line":330,"code":"    it('should pass with empty --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if DROP DATABASE with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":342,"column":57},"line":342,"code":"    it('should fail if DROP DATABASE with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- Drop & Create & Drop\n      DROP DATABASE IF EXISTS \"test-dbexecute\";\n      CREATE DATABASE \"test-dbexecute\";\n      DROP DATABASE \"test-dbexecute\";`,\n      )\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toContain('ERROR: DROP DATABASE cannot')\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":361,"column":71},"line":361,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe::::////::randompassword@doesnotexist/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":381,"column":80},"line":381,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":399,"column":75},"line":399,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe:randompassword@doesnotexist:5432/mydb?schema=public',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1003 error with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":422,"column":57},"line":422,"code":"    it('should fail with P1003 error with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE \"test-doesnotexists\";')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1003')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1003\n\n          Database \\`test-doesnotexists\\` does not exist on the database server at \\`localhost:5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":440,"column":77},"line":440,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              db error: ERROR: syntax error at or near \"ThisisnotSQLitshouldfail\"\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":498,"column":40},"line":498,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file","suites":["db execute","postgresql"],"updatePoint":{"line":506,"column":41},"line":506,"code":"    it('should use env var from .env file', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/using-dotenv.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`26257\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`26257\\`.\n\n            `)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":521,"column":60},"line":521,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":538,"column":37},"line":538,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":546,"column":43},"line":546,"code":"    it('should pass with empty --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed if DROP DATABASE with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":556,"column":60},"line":556,"code":"    it('should succeed if DROP DATABASE with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(0)\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- Drop & Create & Drop\n      DROP DATABASE IF EXISTS \"test-dbexecute\";\n      CREATE DATABASE \"test-dbexecute\";\n      DROP DATABASE \"test-dbexecute\";`,\n      )\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":574,"column":71},"line":574,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe::::////::randompassword@doesnotexist/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":595,"column":80},"line":595,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":613,"column":75},"line":613,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe:randompassword@doesnotexist:5432/mydb?schema=public',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":636,"column":77},"line":636,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        db error: ERROR: at or near \"thisisnotsqlitshouldfail\": syntax error\n        DETAIL: source SQL:\n        ThisisnotSQLitshouldfail\n        ^\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":689,"column":40},"line":689,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with empty --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":698,"column":46},"line":698,"code":"    it('should fail with empty --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Query was empty\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":710,"column":60},"line":710,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nSTART TRANSACTION;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":727,"column":37},"line":727,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":735,"column":71},"line":735,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=mysql://johndoe::::////::randompassword@doesnotexist:3306/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":755,"column":80},"line":755,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":773,"column":75},"line":773,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=mysql://johndoe:randompassword@doesnotexist:3306/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`3306\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`3306\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":796,"column":69},"line":796,"code":"    it('should fail with SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE `test-doesnotexists`;')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Can't drop database 'test-doesnotexists'; database doesn't exist\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":808,"column":77},"line":808,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', 'This is not SQL, it should fail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'This is not SQL, it should fail' at line 1\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":873,"column":40},"line":873,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":881,"column":46},"line":881,"code":"    it('should pass with empty --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":889,"column":37},"line":889,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', jdbcConnectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":897,"column":60},"line":897,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN TRANSACTION;\n\nSELECT 1\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if DROP DATABASE in a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":916,"column":74},"line":916,"code":"    it('should fail if DROP DATABASE in a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN TRANSACTION;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        DROP DATABASE statement cannot be used inside a user transaction.\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":937,"column":71},"line":937,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=sqlserver://doesnotexist:1433;;;;database=tests-migrate;user=SA;password=Pr1sm4_Pr1sm4;trustServerCertificate=true;',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. Error parsing connection string: Conversion error: Invalid property key in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":958,"column":80},"line":958,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":976,"column":75},"line":976,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=sqlserver://doesnotexist:1433;database=tests-migrate;user=SA;password=Pr1sm4_Pr1sm4;trustServerCertificate=true;',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        // It should error with P1001 but code is undefined\n        // Tracked in following issue:\n        // https://github.com/prisma/prisma/issues/11407\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          Error creating a database connection.\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":999,"column":69},"line":999,"code":"    it('should fail with SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE \"test-doesnotexists\";')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Cannot drop the database 'test-doesnotexists', because it does not exist or you do not have permission.\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":1011,"column":77},"line":1011,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Could not find stored procedure 'ThisisnotSQLitshouldfail'.\n\n\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with cockroachdb provider)","suites":[],"updatePoint":{"line":64,"column":55},"line":64,"code":"  test('basic introspection (with cockroachdb provider)', async () => {\n    ctx.fixture('introspection/cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/cockroachdb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with postgresql provider) should fail","suites":[],"updatePoint":{"line":74,"column":66},"line":74,"code":"  test('basic introspection (with postgresql provider) should fail', async () => {\n    ctx.fixture('introspection/cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-postgresql-provider.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      You are trying to connect to a CockroachDB database, but the provider in your Prisma schema is \\`postgresql\\`. Please change it to \\`cockroachdb\\`.\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/cockroachdb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (no schema) --url","suites":[],"updatePoint":{"line":88,"column":45},"line":88,"code":"  test('basic introspection (no schema) --url', async () => {\n    ctx.fixture('introspection/cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/cockroachdb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with cockroach provider) --url ","suites":[],"updatePoint":{"line":98,"column":60},"line":98,"code":"  test('basic introspection (with cockroach provider) --url ', async () => {\n    ctx.fixture('introspection/cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/cockroachdb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with postgresql provider) --url should fail","suites":[],"updatePoint":{"line":108,"column":72},"line":108,"code":"  test('basic introspection (with postgresql provider) --url should fail', async () => {\n    ctx.fixture('introspection/cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--url',\n      setupParams.connectionString,\n      '--schema',\n      'with-postgresql-provider.prisma',\n    ])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      You are trying to connect to a CockroachDB database, but the provider in your Prisma schema is \\`postgresql\\`. Please change it to \\`cockroachdb\\`.\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/cockroachdb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":[],"updatePoint":{"line":27,"column":27},"line":27,"code":"  test('basic introspection', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/no-model.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate\" at \"localhost:27017\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n            - Introspecting based on datasource defined in prisma/no-model.prisma\n\n            ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/no-model.prisma in XXXms\n                  \n            *** WARNING ***\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n              - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n            Run prisma generate to generate Prisma Client.\n\n        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force (existing models)","suites":[],"updatePoint":{"line":60,"column":47},"line":60,"code":"  test('introspection --force (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate\" at \"localhost:27017\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n            - Introspecting based on datasource defined in prisma/schema.prisma\n\n            ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                  \n            *** WARNING ***\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n              - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n            Run prisma generate to generate Prisma Client.\n\n        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print (no existing models)","suites":[],"updatePoint":{"line":93,"column":50},"line":93,"code":"  test('introspection --print (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         UsersHobbiesObjects[]\n        tags            String[]\n      }\n\n      type UsersHobbiesObjects {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString3 Json\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            // *** WARNING ***\n            // \n            // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n            //   - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n            // \n            // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n            //   - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n            //   - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n            // \n        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=0 (no existing models)","suites":[],"updatePoint":{"line":151,"column":75},"line":151,"code":"  test('introspection --print --composite-type-depth=0 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=0'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      model users {\n        id              String  @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         Json[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                  // *** WARNING ***\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n                  // \n            `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=1 (no existing models)","suites":[],"updatePoint":{"line":190,"column":75},"line":190,"code":"  test('introspection --print --composite-type-depth=1 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         Json[]\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                  // *** WARNING ***\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                  // \n            `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force --composite-type-depth=-1 (existing models)","suites":[],"updatePoint":{"line":240,"column":73},"line":240,"code":"  test('introspection --force --composite-type-depth=-1 (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force', '--composite-type-depth=-1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate\" at \"localhost:27017\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n            - Introspecting based on datasource defined in prisma/schema.prisma\n\n            ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                  \n            *** WARNING ***\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n              - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n            Run prisma generate to generate Prisma Client.\n\n        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=-1 (no existing models)","suites":[],"updatePoint":{"line":273,"column":76},"line":273,"code":"  test('introspection --print --composite-type-depth=-1 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=-1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         UsersHobbiesObjects[]\n        tags            String[]\n      }\n\n      type UsersHobbiesObjects {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString3 Json\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                  // *** WARNING ***\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                  //   - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n                  // \n            `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":[],"updatePoint":{"line":331,"column":33},"line":331,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', MONGO_URI])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                  // *** WARNING ***\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n                  // \n                  // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n                  //   - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                  //   - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n                  // \n            `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --url - only generator defined","suites":[],"updatePoint":{"line":354,"column":52},"line":354,"code":"  test('introspection --url - only generator defined', async () => {\n    ctx.fixture('schema-only-mongodb/only-generator')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--url', MONGO_URI])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).not.toContain(`Datasource `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from schema.prisma`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n            - Introspecting\n\n            ✔ Introspected 1 model and 2 embedded documents and wrote them into schema.prisma in XXXms\n                  \n            *** WARNING ***\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n              - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n            Run prisma generate to generate Prisma Client.\n\n        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection with --force","suites":[],"updatePoint":{"line":387,"column":34},"line":387,"code":"  test('introspection with --force', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate\" at \"localhost:27017\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n            - Introspecting based on datasource defined in prisma/schema.prisma\n\n            ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                  \n            *** WARNING ***\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Model: \"users\", field: \"numberOrString1\", original data type: \"Json\"\n\n            The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type:\n              - Composite type: \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n              - Composite type: \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n            Run prisma generate to generate Prisma Client.\n\n        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"re-introspection should error (not supported) (existing models)","suites":[],"updatePoint":{"line":420,"column":71},"line":420,"code":"  test('re-introspection should error (not supported) (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Iterating on one schema using re-introspection with db pull is currently not supported with MongoDB provider.\n            You can explicitly ignore and override your current local schema file with prisma db pull --force\n            Some information will be lost (relations, comments, mapped fields, @ignore...), follow https://github.com/prisma/prisma/issues/9585 for more info.\n          `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate\" at \"localhost:27017\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mongodb.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["mysql"],"updatePoint":{"line":59,"column":27},"line":59,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/mysql')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/mysql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should succeed and add extensions property to the schema.prisma file","suites":["postgresql-extensions"],"updatePoint":{"line":59,"column":90},"line":59,"code":"  test('introspection should succeed and add extensions property to the schema.prisma file', async () => {\n    ctx.fixture('introspection/postgresql-extensions')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'schema.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    const introspectedSchema = ctx.mocked['console.log'].mock.calls.join('\\n')\n    expect(introspectedSchema).toMatchInlineSnapshot(`\n      generator client {\n        provider        = \"prisma-client-js\"\n        previewFeatures = [\"postgresqlExtensions\"]\n      }\n\n      datasource db {\n        provider   = \"postgresql\"\n        url        = env(\"TEST_POSTGRES_URI_MIGRATE\")\n        extensions = [citext(schema: \"public\")]\n      }\n\n      model Post {\n        id        String    @id\n        createdAt DateTime  @default(now())\n        updatedAt DateTime  @default(dbgenerated(\"'1970-01-01 00:00:00'::timestamp without time zone\"))\n        published Boolean   @default(false)\n        title     String\n        content   String?\n        authorId  String?\n        jsonData  Json?\n        coinflips Boolean[]\n        User      User?     @relation(fields: [authorId], references: [id])\n      }\n\n      model User {\n        id    String  @id\n        email String  @unique(map: \"User.email\")\n        name  String?\n        Post  Post[]\n      }\n\n      enum Role {\n        USER\n        ADMIN\n      }\n\n    `)\n    expect(introspectedSchema).toContain('[citext(schema:')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-extensions.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"re-introspection should succeed and keep defined extension in schema.prisma file","suites":["postgresql-extensions"],"updatePoint":{"line":110,"column":88},"line":110,"code":"  test('re-introspection should succeed and keep defined extension in schema.prisma file', async () => {\n    ctx.fixture('introspection/postgresql-extensions')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'schema-extensions-citext.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    const introspectedSchema = ctx.mocked['console.log'].mock.calls.join('\\n')\n    expect(introspectedSchema).toMatchInlineSnapshot(`\n      generator client {\n        provider        = \"prisma-client-js\"\n        previewFeatures = [\"postgresqlExtensions\"]\n      }\n\n      datasource db {\n        provider   = \"postgresql\"\n        url        = env(\"TEST_POSTGRES_URI_MIGRATE\")\n        extensions = [citext(schema: \"public\")]\n      }\n\n      model Post {\n        id        String    @id\n        createdAt DateTime  @default(now())\n        updatedAt DateTime  @default(dbgenerated(\"'1970-01-01 00:00:00'::timestamp without time zone\"))\n        published Boolean   @default(false)\n        title     String\n        content   String?\n        authorId  String?\n        jsonData  Json?\n        coinflips Boolean[]\n        User      User?     @relation(fields: [authorId], references: [id])\n      }\n\n      model User {\n        id    String  @id\n        email String  @unique(map: \"User.email\")\n        name  String?\n        Post  Post[]\n      }\n\n      enum Role {\n        USER\n        ADMIN\n      }\n\n    `)\n    expect(introspectedSchema).toContain('[citext(schema:')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-extensions.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":["postgresql - missing database"],"updatePoint":{"line":25,"column":33},"line":25,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      P1003 The introspected database does not exist: postgres://prisma:prisma@localhost:5432/unknown-database\n\n      prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n      To fix this, you have two options:\n\n      - manually create a database.\n      - make sure the database connection URL inside the datasource block in schema.prisma points to an existing database.\n\n      Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-missing-database.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without datasource property `schemas` it should error with P4001, empty database","suites":["postgresql-multischema"],"updatePoint":{"line":59,"column":88},"line":59,"code":"  test('without datasource property `schemas` it should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'without-schemas-in-datasource.prisma'])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[]` should error with P1012, array can not be empty","suites":["postgresql-multischema"],"updatePoint":{"line":71,"column":88},"line":71,"code":"  test('datasource property `schemas=[]` should error with P1012, array can not be empty', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-0-value.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      Prisma schema validation - (get-config wasm)\n      Error code: P1012\n      error: If provided, the schemas array can not be empty.\n        -->  schema.prisma:4\n         | \n       3 |   url      = env(\"TEST_POSTGRES_URI_MIGRATE\")\n       4 |   schemas  = []\n         | \n\n      Validation Error Count: 1\n      [Context: getConfig]\n\n      Prisma CLI Version : 0.0.0\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\", \"transactional\"]` should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":97,"column":78},"line":97,"code":"  test('datasource property `schemas=[\"base\", \"transactional\"]` should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-2-values.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            // *** WARNING ***\n            // \n            // These items were renamed due to their names being duplicates in the Prisma Schema Language:\n            //   - Type: \"enum\", name: \"base_status\"\n            //   - Type: \"enum\", name: \"transactional_status\"\n            //   - Type: \"model\", name: \"base_some_table\"\n            //   - Type: \"model\", name: \"transactional_some_table\"\n            // \n        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\"]` should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":119,"column":61},"line":119,"code":"  test('datasource property `schemas=[\"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-value.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database","suites":["postgresql-multischema"],"updatePoint":{"line":131,"column":96},"line":131,"code":"  test('datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-non-existing-value.prisma'])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":143,"column":79},"line":143,"code":"  test('datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--schema',\n      'with-schemas-in-datasource-1-existing-1-non-existing-value.prisma',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with --schemas=base without preview feature should error","suites":["postgresql-multischema"],"updatePoint":{"line":159,"column":70},"line":159,"code":"  test('--url with --schemas=base without preview feature should error', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n    ctx.fs.remove(`./schema.prisma`)\n\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString, '--schemas', 'base'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      The preview feature \\`multiSchema\\` must be enabled before using --schemas command line parameter.\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with --schemas=does-not-exist should error","suites":["postgresql-multischema"],"updatePoint":{"line":177,"column":56},"line":177,"code":"  test('--url with --schemas=does-not-exist should error', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString, '--schemas', 'does-not-exist'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      P4001 The introspected database was empty: postgres://prisma:prisma@localhost:5432/tests-migrate-db-pull-multischema-postgresql\n\n      prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n      To fix this, you have two options:\n\n      - manually create a table in your database.\n      - make sure the database connection URL inside the datasource block in schema.prisma points to a database that is not empty (it must contain at least one table).\n\n      Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url --schemas=base (1 existing schema) should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":203,"column":63},"line":203,"code":"  test('--url --schemas=base (1 existing schema) should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString, '--schemas', 'base'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url  --schemas=base,transactional (2 existing schemas) should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":216,"column":79},"line":216,"code":"  test('--url  --schemas=base,transactional (2 existing schemas) should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--url',\n      setupParams.connectionString,\n      '--schemas',\n      'base,transactional',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            // *** WARNING ***\n            // \n            // These items were renamed due to their names being duplicates in the Prisma Schema Language:\n            //   - Type: \"enum\", name: \"base_status\"\n            //   - Type: \"enum\", name: \"transactional_status\"\n            //   - Type: \"model\", name: \"base_some_table\"\n            //   - Type: \"model\", name: \"transactional_some_table\"\n            // \n        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url  --schemas=base,does-not-exist (1 existing schemas + 1 non-existing) should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":245,"column":97},"line":245,"code":"  test('--url  --schemas=base,does-not-exist (1 existing schemas + 1 non-existing) should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--url',\n      setupParams.connectionString,\n      '--schemas',\n      'base,does-not-exist',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with --schemas=[\"does-not-exist\", \"base\"] should error","suites":["postgresql-multischema"],"updatePoint":{"line":264,"column":68},"line":264,"code":"  test('--url with --schemas=[\"does-not-exist\", \"base\"] should error', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString, '--schemas', 'base'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=does-not-exist` should error with with P4001, empty database","suites":["postgresql-multischema"],"updatePoint":{"line":277,"column":88},"line":277,"code":"  test('--url with `?schema=does-not-exist` should error with with P4001, empty database', async () => {\n    const introspect = new DbPull()\n    // postgres://prisma:prisma@localhost:5432/tests-migrate?schema=does-not-exist\n    const connectionString = `${setupParams.connectionString}?schema=does-not-exist`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=base` should succeed","suites":["postgresql-multischema"],"updatePoint":{"line":290,"column":48},"line":290,"code":"  test('--url with `?schema=base` should succeed', async () => {\n    const introspect = new DbPull()\n    // postgres://prisma:prisma@localhost:5432/tests-migrate?schema=base\n    const connectionString = `${setupParams.connectionString}?schema=base`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql-multischema.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"`views` is null","suites":["postgresql-views","engine output","no preview feature"],"updatePoint":{"line":79,"column":25},"line":79,"code":"      it('`views` is null', async () => {\n        ctx.fixture(path.join(fixturePath))\n\n        const engine = new SchemaEngine({\n          projectDir: process.cwd(),\n          schemaPath: undefined,\n        })\n\n        const schema = await getSchema()\n\n        const introspectionResult = await engine.introspect({\n          schema,\n          force: false,\n        })\n\n        expect(introspectionResult.views).toEqual(null)\n        engine.stop()\n      })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"`views` is [] and no views folder is created","suites":["postgresql-views","engine output","with preview feature and no views defined"],"updatePoint":{"line":102,"column":54},"line":102,"code":"      it('`views` is [] and no views folder is created', async () => {\n        ctx.fixture(path.join(fixturePath))\n\n        const engine = new SchemaEngine({\n          projectDir: process.cwd(),\n          schemaPath: undefined,\n        })\n\n        const schema = await getSchema()\n\n        const introspectionResult = await engine.introspect({\n          schema,\n          force: false,\n        })\n\n        expect(introspectionResult.views).toEqual([])\n        engine.stop()\n\n        const listWithoutViews = await ctx.fs.listAsync('views')\n        expect(listWithoutViews).toEqual(undefined)\n      })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"`views` is [] and an empty existing views folder is deleted","suites":["postgresql-views","engine output","with preview feature and no views defined"],"updatePoint":{"line":124,"column":69},"line":124,"code":"      it('`views` is [] and an empty existing views folder is deleted', async () => {\n        ctx.fixture(path.join(fixturePath))\n\n        // Empty dir should be deleted along the views dir\n        await ctx.fs.dirAsync('views/empty-dir')\n\n        expect(await ctx.fs.listAsync()).toEqual(['node_modules', 'schema.prisma', 'setup.sql', 'views'])\n        expect(await ctx.fs.listAsync('views')).toEqual(['empty-dir'])\n\n        const engine = new SchemaEngine({\n          projectDir: process.cwd(),\n          schemaPath: undefined,\n        })\n\n        const schema = await getSchema()\n\n        const introspectionResult = await engine.introspect({\n          schema,\n          force: false,\n        })\n\n        expect(introspectionResult.views).toEqual([])\n        engine.stop()\n\n        const listWithoutViews = await ctx.fs.listAsync('views')\n        expect(listWithoutViews).toEqual(undefined)\n        // The views folder is deleted\n        expect(await ctx.fs.listAsync()).toEqual(['node_modules', 'schema.prisma', 'setup.sql'])\n      })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"`views` is [] and a non-empty existing views folder is kept","suites":["postgresql-views","engine output","with preview feature and no views defined"],"updatePoint":{"line":154,"column":69},"line":154,"code":"      it('`views` is [] and a non-empty existing views folder is kept', async () => {\n        ctx.fixture(path.join(fixturePath))\n\n        ctx.fs.write('views/README.md', 'Some readme markdown')\n        expect(await ctx.fs.listAsync()).toEqual(['node_modules', 'schema.prisma', 'setup.sql', 'views'])\n        expect(await ctx.fs.listAsync('views')).toEqual(['README.md'])\n\n        const engine = new SchemaEngine({\n          projectDir: process.cwd(),\n          schemaPath: undefined,\n        })\n\n        const schema = await getSchema()\n\n        const introspectionResult = await engine.introspect({\n          schema,\n          force: false,\n        })\n\n        expect(introspectionResult.views).toEqual([])\n        engine.stop()\n\n        const listWithoutViews = await ctx.fs.listAsync('views')\n        expect(listWithoutViews).toEqual(['README.md'])\n        expect(await ctx.fs.listAsync()).toEqual(['node_modules', 'schema.prisma', 'setup.sql', 'views'])\n      })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"re-introspection with views removed","suites":["postgresql-views","with preview feature, views defined and then removed"],"updatePoint":{"line":186,"column":45},"line":186,"code":"    test('re-introspection with views removed', async () => {\n      ctx.fixture(fixturePath)\n\n      const introspectWithViews = new DbPull()\n      const resultWithViews = introspectWithViews.parse([])\n      await expect(resultWithViews).resolves.toMatchInlineSnapshot(``)\n\n      const listWithViews = await ctx.fs.listAsync('views')\n      expect(listWithViews).toMatchInlineSnapshot(`\n        [\n          public,\n          work,\n        ]\n      `)\n\n      const treeWithViews = await ctx.fs.findAsync({\n        directories: false,\n        files: true,\n        recursive: true,\n        matching: 'views/**/*',\n      })\n      expect(treeWithViews).toMatchInlineSnapshot(`\n        [\n          views/public/simpleuser.sql,\n          views/work/workers.sql,\n        ]\n      `)\n\n      const dropViewsSQL = await ctx.fs.readAsync('./drop_views.sql', 'utf8')\n\n      // remove any view in the database\n      await runQueryPostgres(setupParams, dropViewsSQL!)\n\n      const introspectWithoutViews = new DbPull()\n      const resultWithoutViews = introspectWithoutViews.parse([])\n      await expect(resultWithoutViews).resolves.toMatchInlineSnapshot(``)\n\n      const listWithoutViews = await ctx.fs.listAsync('views')\n      expect(listWithoutViews).toEqual(undefined)\n\n      expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        Prisma schema loaded from schema.prisma\n        Datasource \"db\": PostgreSQL database \"tests-migrate-db-pull-postgresql-views\", schemas \"public, work\" at \"localhost:5432\"\n        Prisma schema loaded from schema.prisma\n        Datasource \"db\": PostgreSQL database \"tests-migrate-db-pull-postgresql-views\", schemas \"public, work\" at \"localhost:5432\"\n      `)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                        - Introspecting based on datasource defined in schema.prisma\n\n                        ✔ Introspected 2 models and wrote them into schema.prisma in XXXms\n                              \n                        *** WARNING ***\n\n                        The following views were ignored as they do not have a valid unique identifier or id. This is currently not supported by Prisma Client. Please refer to the documentation on defining unique identifiers in views: https://pris.ly/d/view-identifiers\n                          - \"simpleuser\"\n                          - \"workers\"\n\n                        Run prisma generate to generate Prisma Client.\n\n\n\n                        - Introspecting based on datasource defined in schema.prisma\n\n                        ✔ Introspected 2 models and wrote them into schema.prisma in XXXms\n                              \n                        Run prisma generate to generate Prisma Client.\n\n                  `)\n      expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["postgresql-views","with preview feature and views defined"],"updatePoint":{"line":265,"column":29},"line":265,"code":"    test('basic introspection', async () => {\n      ctx.fixture(fixturePath)\n\n      const introspect = new DbPull()\n      const result = introspect.parse([])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n\n      const list = await ctx.fs.listAsync('views')\n      expect(list).toMatchInlineSnapshot(`\n        [\n          public,\n          work,\n        ]\n      `)\n\n      const tree = await ctx.fs.findAsync({ directories: false, files: true, recursive: true, matching: 'views/**/*' })\n      expect(tree).toMatchInlineSnapshot(`\n        [\n          views/public/simpleuser.sql,\n          views/work/workers.sql,\n        ]\n      `)\n\n      expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        Prisma schema loaded from schema.prisma\n        Datasource \"db\": PostgreSQL database \"tests-migrate-db-pull-postgresql-views\", schemas \"public, work\" at \"localhost:5432\"\n      `)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n        - Introspecting based on datasource defined in schema.prisma\n\n        ✔ Introspected 2 models and wrote them into schema.prisma in XXXms\n              \n        *** WARNING ***\n\n        The following views were ignored as they do not have a valid unique identifier or id. This is currently not supported by Prisma Client. Please refer to the documentation on defining unique identifiers in views: https://pris.ly/d/view-identifiers\n          - \"simpleuser\"\n          - \"workers\"\n\n        Run prisma generate to generate Prisma Client.\n\n      `)\n      expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"extraneous empty subdirectories should be deleted and top files kept in views directory on introspect","suites":["postgresql-views","with preview feature and views defined"],"updatePoint":{"line":406,"column":111},"line":406,"code":"    test('extraneous empty subdirectories should be deleted and top files kept in views directory on introspect', async () => {\n      ctx.fixture(path.join(fixturePath))\n\n      await ctx.fs.dirAsync('views')\n      const initialList = await ctx.fs.listAsync('views')\n      expect(initialList).toMatchInlineSnapshot(`[]`)\n\n      // Empty dir should be deleted\n      await ctx.fs.dirAsync('views/empty-dir')\n      // Any file on the top level should be kept\n      await ctx.fs.fileAsync('views/README')\n      await ctx.fs.fileAsync('views/extraneous-file.sql')\n      const extraneousList = await ctx.fs.listAsync('views')\n      extraneousList?.sort((a, b) => a.localeCompare(b, 'en-US'))\n      expect(extraneousList).toMatchInlineSnapshot(`\n        [\n          empty-dir,\n          extraneous-file.sql,\n          README,\n        ]\n      `)\n\n      const introspect = new DbPull()\n      const result = introspect.parse([])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n\n      // the folders in `views` match the database schema names (public, work) of the views\n      // defined in the `setup.sql` file\n      const list = await ctx.fs.listAsync('views')\n      list?.sort((a, b) => a.localeCompare(b, 'en-US'))\n      expect(list).toMatchInlineSnapshot(`\n        [\n          extraneous-file.sql,\n          public,\n          README,\n          work,\n        ]\n      `)\n\n      const tree = await ctx.fs.findAsync({ directories: false, files: true, recursive: true, matching: 'views/**/*' })\n      tree?.sort((a, b) => a.localeCompare(b, 'en-US'))\n      expect(tree).toMatchInlineSnapshot(`\n        [\n          views/extraneous-file.sql,\n          views/public/simpleuser.sql,\n          views/README,\n          views/work/workers.sql,\n        ]\n      `)\n    })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["postgresql-views","no preview"],"updatePoint":{"line":461,"column":29},"line":461,"code":"    test('basic introspection', async () => {\n      ctx.fixture(path.join(fixturePath))\n\n      const introspect = new DbPull()\n      const result = introspect.parse([])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n\n      const list = await ctx.fs.listAsync('views')\n      expect(list).toMatchInlineSnapshot(`undefined`)\n\n      const tree = await ctx.fs.findAsync({ directories: false, files: true, recursive: true, matching: 'views/**/*' })\n      expect(tree).toMatchInlineSnapshot(`[]`)\n\n      expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        Prisma schema loaded from schema.prisma\n        Datasource \"db\": PostgreSQL database \"tests-migrate-db-pull-postgresql-views\", schemas \"public, work\" at \"localhost:5432\"\n      `)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n        - Introspecting based on datasource defined in schema.prisma\n\n        ✔ Introspected 2 models and wrote them into schema.prisma in XXXms\n              \n        Run prisma generate to generate Prisma Client.\n\n      `)\n      expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspect with already existing files in \"views\"","suites":["postgresql-views","no preview"],"updatePoint":{"line":493,"column":59},"line":493,"code":"    test('introspect with already existing files in \"views\"', async () => {\n      ctx.fixture(path.join(fixturePath))\n\n      await ctx.fs.dirAsync('views/extraneous-dir')\n      await ctx.fs.fileAsync('views/extraneous-file.sql')\n      const extraneousList = await ctx.fs.listAsync('views')\n      expect(extraneousList).toMatchInlineSnapshot(`\n        [\n          extraneous-dir,\n          extraneous-file.sql,\n        ]\n      `)\n\n      const introspect = new DbPull()\n      const result = introspect.parse([])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n\n      const list = await ctx.fs.listAsync('views')\n      expect(list).toMatchInlineSnapshot(`\n        [\n          extraneous-dir,\n          extraneous-file.sql,\n        ]\n      `)\n\n      const tree = await ctx.fs.findAsync({ directories: false, files: true, recursive: true, matching: 'views/**/*' })\n      expect(tree).toMatchInlineSnapshot(`\n        [\n          views/extraneous-file.sql,\n        ]\n      `)\n    })","file":"DbPull/postgresql-views.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["postgresql"],"updatePoint":{"line":59,"column":27},"line":59,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/postgresql')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":["postgresql"],"updatePoint":{"line":71,"column":33},"line":71,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should load .env file with --print","suites":["postgresql"],"updatePoint":{"line":82,"column":56},"line":82,"code":"  test('introspection should load .env file with --print', async () => {\n    ctx.fixture('schema-only-postgresql')\n    expect.assertions(7)\n\n    try {\n      await DbPull.new().parse(['--print', '--schema=./prisma/using-dotenv.prisma'])\n    } catch (e) {\n      expect(e.code).toEqual('P1001')\n      expect(e.message).toContain(`fromdotenvdoesnotexist`)\n    }\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should load .env file without --print","suites":["postgresql"],"updatePoint":{"line":100,"column":59},"line":100,"code":"  test('introspection should load .env file without --print', async () => {\n    ctx.fixture('schema-only-postgresql')\n    expect.assertions(7)\n\n    try {\n      await DbPull.new().parse(['--schema=./prisma/using-dotenv.prisma'])\n    } catch (e) {\n      expect(e.code).toEqual('P1001')\n      expect(e.message).toContain(`fromdotenvdoesnotexist`)\n    }\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/using-dotenv.prisma\n      Environment variables loaded from prisma/.env\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"fromdotenvdoesnotexist:5432\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                  - Introspecting based on datasource defined in prisma/using-dotenv.prisma\n\n                  ✖ Introspecting based on datasource defined in prisma/using-dotenv.prisma\n\n              `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --url with postgresql provider but schema has a sqlite provider should fail","suites":["postgresql"],"updatePoint":{"line":130,"column":97},"line":130,"code":"  test('introspection --url with postgresql provider but schema has a sqlite provider should fail', async () => {\n    ctx.fixture('schema-only-sqlite')\n    expect.assertions(7)\n\n    try {\n      await DbPull.new().parse(['--url', setupParams.connectionString])\n    } catch (e) {\n      expect(e.code).toEqual(undefined)\n      expect(e.message).toMatchInlineSnapshot(\n        `The database provider found in --url (postgresql) is different from the provider found in the Prisma schema (sqlite).`,\n      )\n    }\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection works with directUrl from env var","suites":["postgresql"],"updatePoint":{"line":153,"column":55},"line":153,"code":"  test('introspection works with directUrl from env var', async () => {\n    ctx.fixture('schema-only-data-proxy')\n    const result = DbPull.new().parse(['--schema', 'with-directUrl-env.prisma'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from with-directUrl-env.prisma\n      Environment variables loaded from .env\n      Datasource \"db\": PostgreSQL database \"tests-migrate-db-pull-postgresql\", schema \"public\" at \"localhost:5432\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                  - Introspecting based on datasource defined in with-directUrl-env.prisma\n\n                  ✔ Introspected 2 models and wrote them into with-directUrl-env.prisma in XXXms\n                        \n                  Run prisma generate to generate Prisma Client.\n\n            `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/postgresql.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["common/sqlite"],"updatePoint":{"line":16,"column":27},"line":16,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force","suites":["common/sqlite"],"updatePoint":{"line":28,"column":29},"line":28,"code":"  test('introspection --force', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with --url","suites":["common/sqlite"],"updatePoint":{"line":40,"column":38},"line":40,"code":"  test('basic introspection with --url', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'file:dev.db'])\n    await expect(result).resolves.toBe('')\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with schema and --url missing file: prefix should fail","suites":["common/sqlite"],"updatePoint":{"line":52,"column":82},"line":52,"code":"  test('basic introspection with schema and --url missing file: prefix should fail', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'withoutfileprefix.db'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Unknown protocol withoutfileprefix.db:`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection without schema and with --url missing \"file:\" prefix should fail","suites":["common/sqlite"],"updatePoint":{"line":64,"column":92},"line":64,"code":"  test('basic introspection without schema and with --url missing \"file:\" prefix should fail', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'withoutfileprefix.db'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Unknown protocol withoutfileprefix.db:`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with invalid --url if schema is unspecified","suites":["common/sqlite"],"updatePoint":{"line":75,"column":71},"line":75,"code":"  test('basic introspection with invalid --url if schema is unspecified', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'invalidstring'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Unknown protocol invalidstring:`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema and db do match","suites":["common/sqlite"],"updatePoint":{"line":86,"column":48},"line":86,"code":"  it('should succeed when schema and db do match', async () => {\n    ctx.fixture('introspect/prisma')\n    const result = DbPull.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in schema.prisma\n\n      ✔ Introspected 3 models and wrote them into schema.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema and db do match using --url","suites":["common/sqlite"],"updatePoint":{"line":109,"column":62},"line":109,"code":"  test('should succeed when schema and db do match using --url', async () => {\n    ctx.fixture('introspect/prisma')\n    const result = DbPull.new().parse(['--url=file:./dev.db'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting\n\n      ✔ Introspected 3 models and wrote them into schema.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with invalid --url - empty host","suites":["common/sqlite"],"updatePoint":{"line":132,"column":59},"line":132,"code":"  test('basic introspection with invalid --url - empty host', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'postgresql://root:prisma@/prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      P1013\n\n      The provided database string is invalid. empty host in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed and keep changes to valid schema and output warnings","suites":["common/sqlite"],"updatePoint":{"line":148,"column":73},"line":148,"code":"  it('should succeed and keep changes to valid schema and output warnings', async () => {\n    ctx.fixture('introspect')\n    const result = DbPull.new().parse(['--schema=./prisma/reintrospection.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/reintrospection.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/reintrospection.prisma\n\n      ✔ Introspected 3 models and wrote them into prisma/reintrospection.prisma in XXXms\n            \n      *** WARNING ***\n\n      These models were enriched with \\`@@map\\` information taken from the previous Prisma schema:\n        - \"AwesomeNewPost\"\n        - \"AwesomeProfile\"\n        - \"AwesomeUser\"\n\n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/reintrospection.prisma')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n        output   = \"../generated/client\"\n      }\n\n      datasource db {\n        provider = \"sqlite\"\n        url      = \"file:dev.db\"\n      }\n\n      model AwesomeUser {\n        email    String           @unique(map: \"User.email\")\n        id       Int              @id @default(autoincrement())\n        name     String?\n        newPosts AwesomeNewPost[]\n        profile  AwesomeProfile?\n\n        @@map(\"User\")\n      }\n\n      model AwesomeNewPost {\n        authorId  Int\n        content   String?\n        createdAt DateTime    @default(now())\n        id        Int         @id @default(autoincrement())\n        published Boolean     @default(false)\n        title     String\n        author    AwesomeUser @relation(fields: [authorId], references: [id], onDelete: Cascade)\n\n        @@map(\"Post\")\n      }\n\n      model AwesomeProfile {\n        bio    String?\n        id     Int         @id @default(autoincrement())\n        userId Int         @unique(map: \"Profile.userId\")\n        user   AwesomeUser @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n        @@map(\"Profile\")\n      }\n\n    `)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed and keep changes to valid schema and output warnings when using --print","suites":["common/sqlite"],"updatePoint":{"line":223,"column":92},"line":223,"code":"  it('should succeed and keep changes to valid schema and output warnings when using --print', async () => {\n    ctx.fixture('introspect')\n    const originalSchema = ctx.fs.read('prisma/reintrospection.prisma')\n    const result = DbPull.new().parse(['--print', '--schema=./prisma/reintrospection.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            // *** WARNING ***\n            // \n            // These models were enriched with \\`@@map\\` information taken from the previous Prisma schema:\n            //   - \"AwesomeNewPost\"\n            //   - \"AwesomeProfile\"\n            //   - \"AwesomeUser\"\n            // \n        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/reintrospection.prisma')).toStrictEqual(originalSchema)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema and db do not match","suites":["common/sqlite"],"updatePoint":{"line":246,"column":52},"line":246,"code":"  it('should succeed when schema and db do not match', async () => {\n    ctx.fixture('existing-db-histories-diverge')\n    const result = DbPull.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/schema.prisma\n\n      ✔ Introspected 3 models and wrote them into prisma/schema.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when db is missing","suites":["common/sqlite"],"updatePoint":{"line":269,"column":36},"line":269,"code":"  it('should fail when db is missing', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n        P1003 The introspected database does not exist: \n\n        prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n        To fix this, you have two options:\n\n        - manually create a database.\n        - make sure the database connection URL inside the datasource block in schema.prisma points to an existing database.\n\n        Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/schema.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/schema.prisma\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when db is empty","suites":["common/sqlite"],"updatePoint":{"line":303,"column":34},"line":303,"code":"  it('should fail when db is empty', async () => {\n    ctx.fixture('schema-only-sqlite')\n    ctx.fs.write('prisma/dev.db', '')\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      P4001 The introspected database was empty: \n\n      prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n      To fix this, you have two options:\n\n      - manually create a table in your database.\n      - make sure the database connection URL inside the datasource block in schema.prisma points to a database that is not empty (it must contain at least one table).\n\n      Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/schema.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/schema.prisma\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when Prisma schema is missing","suites":["common/sqlite"],"updatePoint":{"line":338,"column":47},"line":338,"code":"  it('should fail when Prisma schema is missing', async () => {\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      Could not find a schema.prisma file that is required for this command.\n      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when schema is invalid","suites":["common/sqlite"],"updatePoint":{"line":352,"column":40},"line":352,"code":"  it('should fail when schema is invalid', async () => {\n    ctx.fixture('introspect')\n    const result = DbPull.new().parse(['--schema=./prisma/invalid.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n      P1012\n\n      error: Error validating model \"something\": Each model must have at least one unique criteria that has only required fields. Either mark a single field with \\`@id\\`, \\`@unique\\` or add a multi field criterion with \\`@@id([])\\` or \\`@@unique([])\\` to the model.\n        -->  schema.prisma:11\n         | \n      10 | \n      11 | model something {\n      12 |   id Int\n      13 | }\n         | \n\n\n      Introspection failed as your current Prisma schema file is invalid\n\n      Please fix your current schema manually (using either prisma validate or the Prisma VS Code extension to understand what's broken and confirm you fixed it), and then run this command again.\n      Or run this command with the --force flag to ignore your current schema and overwrite it. All local modifications will be lost.\n\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/invalid.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/invalid.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/invalid.prisma\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema is invalid and using --force","suites":["common/sqlite"],"updatePoint":{"line":393,"column":61},"line":393,"code":"  it('should succeed when schema is invalid and using --force', async () => {\n    ctx.fixture('introspect')\n\n    const result = DbPull.new().parse(['--schema=./prisma/invalid.prisma', '--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/invalid.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/invalid.prisma\n\n      ✔ Introspected 3 models and wrote them into prisma/invalid.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/invalid.prisma')).toMatchSnapshot()\n  })","file":"DbPull/sqlite.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":[],"updatePoint":{"line":88,"column":27},"line":88,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/sqlserver')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":[],"updatePoint":{"line":100,"column":33},"line":100,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', process.env.TEST_MSSQL_JDBC_URI_MIGRATE!])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without datasource property `schemas` it should error with P4001, empty database","suites":[],"updatePoint":{"line":160,"column":88},"line":160,"code":"  test('without datasource property `schemas` it should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/sqlserver-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'without-schemas-in-datasource.prisma'])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[]` should error with P1012, array can not be empty","suites":[],"updatePoint":{"line":172,"column":88},"line":172,"code":"  test('datasource property `schemas=[]` should error with P1012, array can not be empty', async () => {\n    ctx.fixture('introspection/sqlserver-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-0-value.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      Prisma schema validation - (get-config wasm)\n      Error code: P1012\n      error: If provided, the schemas array can not be empty.\n        -->  schema.prisma:4\n         | \n       3 |   url      = env(\"TEST_MSSQL_JDBC_URI_MIGRATE\")\n       4 |   schemas  = []\n         | \n\n      Validation Error Count: 1\n      [Context: getConfig]\n\n      Prisma CLI Version : 0.0.0\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\", \"transactional\"]` should succeed","suites":[],"line":204,"code":"  test.skip('datasource property `schemas=[\"base\", \"transactional\"]` should succeed', async () => {","file":"DbPull/sqlserver.test.ts","skipped":true,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\"]` should succeed","suites":[],"updatePoint":{"line":227,"column":61},"line":227,"code":"  test('datasource property `schemas=[\"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/sqlserver-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-value.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database","suites":[],"updatePoint":{"line":239,"column":96},"line":239,"code":"  test('datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/sqlserver-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-non-existing-value.prisma'])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed","suites":[],"updatePoint":{"line":251,"column":79},"line":251,"code":"  test('datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/sqlserver-multischema')\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--schema',\n      'with-schemas-in-datasource-1-existing-1-non-existing-value.prisma',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=does-not-exist` should error with with P4001, empty database","suites":[],"updatePoint":{"line":267,"column":88},"line":267,"code":"  test('--url with `?schema=does-not-exist` should error with with P4001, empty database', async () => {\n    const introspect = new DbPull()\n    const connectionString = `${process.env.TEST_MSSQL_JDBC_URI_MIGRATE}schema=does-not-exist`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).rejects.toThrow(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=base` should succeed","suites":[],"updatePoint":{"line":279,"column":48},"line":279,"code":"  test('--url with `?schema=base` should succeed', async () => {\n    const introspect = new DbPull()\n    const connectionString = `${process.env.TEST_MSSQL_JDBC_URI_MIGRATE}schema=base`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull/sqlserver.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["push"],"updatePoint":{"line":24,"column":35},"line":24,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                      Could not find a schema.prisma file that is required for this command.\n                      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n                  `)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if nativeTypes VarChar on sqlite","suites":["push"],"updatePoint":{"line":34,"column":50},"line":34,"code":"  it('should fail if nativeTypes VarChar on sqlite', async () => {\n    ctx.fixture('nativeTypes-sqlite')\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P1012\n\n            error: Native type VarChar is not supported for sqlite connector.\n              -->  schema.prisma:12\n               | \n            11 |   id   Int    @id\n            12 |   name String @db.VarChar(100)\n               | \n\n\n          `)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"already in sync","suites":["push"],"updatePoint":{"line":51,"column":21},"line":51,"code":"  it('already in sync', async () => {\n    ctx.fixture('reset')\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"missing SQLite db should be created next to the schema.prisma file","suites":["push"],"updatePoint":{"line":64,"column":72},"line":64,"code":"  it('missing SQLite db should be created next to the schema.prisma file', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n    const schemaPath = 'prisma/schema.prisma'\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    await expect(ctx.fs.inspect(schemaPath)?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect(path.join(path.dirname(schemaPath), 'dev.db'))?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect('dev.db')?.size).toBeUndefined()\n\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"missing SQLite db should be created next to the --schema path","suites":["push"],"updatePoint":{"line":86,"column":67},"line":86,"code":"  it('missing SQLite db should be created next to the --schema path', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const oldSchemaPath = 'prisma/schema.prisma'\n    const newSchemaPath = 'something/schema.prisma'\n    ctx.fs.move(oldSchemaPath, newSchemaPath)\n\n    const result = DbPush.new().parse(['--schema', newSchemaPath])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from something/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    await expect(ctx.fs.inspect(oldSchemaPath)?.size).toBeUndefined()\n    await expect(ctx.fs.inspect(newSchemaPath)?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect(path.join(path.dirname(oldSchemaPath), 'dev.db'))?.size).toBeUndefined()\n    await expect(ctx.fs.inspect(path.join(path.dirname(newSchemaPath), 'dev.db'))?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect('dev.db')?.size).toBeUndefined()\n\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should ask for --accept-data-loss if not provided in CI","suites":["push"],"updatePoint":{"line":113,"column":61},"line":113,"code":"  it('should ask for --accept-data-loss if not provided in CI', async () => {\n    ctx.fixture('existing-db-warnings')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(\n      `Use the --accept-data-loss flag to ignore the data loss warnings like prisma db push --accept-data-loss`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings accepted (prompt)","suites":["push"],"updatePoint":{"line":125,"column":41},"line":125,"code":"  it('dataloss warnings accepted (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings cancelled (prompt)","suites":["push"],"updatePoint":{"line":147,"column":42},"line":147,"code":"  it('dataloss warnings cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      Push cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--accept-data-loss flag","suites":["push"],"updatePoint":{"line":172,"column":29},"line":172,"code":"  it('--accept-data-loss flag', async () => {\n    ctx.fixture('existing-db-warnings')\n    const result = DbPush.new().parse(['--accept-data-loss'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - drop accepted (prompt)","suites":["push"],"updatePoint":{"line":190,"column":43},"line":190,"code":"  it('unexecutable - drop accepted (prompt)', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n\n    const sqliteDbSizeBefore = ctx.fs.inspect('prisma/dev.db')!.size\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    const sqliteDbSizeAfter = ctx.fs.inspect('prisma/dev.db')!.size\n\n    expect(sqliteDbSizeBefore).toBeGreaterThan(10000)\n    expect(sqliteDbSizeAfter).toBeGreaterThan(10000)\n    expect(sqliteDbSizeAfter).toBeLessThan(sqliteDbSizeBefore)\n\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      ⚠️ We found changes that cannot be executed:\n\n        • Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n\n      The SQLite database \"dev.db\" from \"file:dev.db\" was successfully reset.\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - drop cancelled (prompt)","suites":["push"],"updatePoint":{"line":224,"column":44},"line":224,"code":"  it('unexecutable - drop cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      Push cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - --force-reset should succeed and print a log","suites":["push"],"updatePoint":{"line":249,"column":65},"line":249,"code":"  it('unexecutable - --force-reset should succeed and print a log', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = DbPush.new().parse(['--force-reset'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      The SQLite database \"dev.db\" at \"file:dev.db\" was successfully reset.\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - should ask for --force-reset in CI","suites":["push"],"updatePoint":{"line":264,"column":55},"line":264,"code":"  it('unexecutable - should ask for --force-reset in CI', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n\n                                                                        ⚠️ We found changes that cannot be executed:\n\n                                                                          • Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n                                                                        Use the --force-reset flag to drop the database before push like prisma db push --force-reset\n                                                                        All data will be lost.\n                                                                                \n                                                `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--force-reset should succeed and display a log","suites":["postgresql"],"updatePoint":{"line":318,"column":52},"line":318,"code":"  it('--force-reset should succeed and display a log', async () => {\n    ctx.fixture('schema-only-postgresql')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse(['--force-reset'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-db-push\", schema \"public\" at \"localhost:5432\"\n\n      The PostgreSQL database \"tests-migrate-db-push\" schema \"public\" at \"localhost:5432\" was successfully reset.\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work if url is prisma:// and directUrl defined","suites":["postgresql"],"updatePoint":{"line":337,"column":59},"line":337,"code":"  it('should work if url is prisma:// and directUrl defined', async () => {\n    ctx.fixture('schema-only-data-proxy')\n\n    prompt.inject(['n'])\n\n    const result = DbPush.new().parse(['--schema', 'with-directUrl-env.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Environment variables loaded from .env\n      Prisma schema loaded from with-directUrl-env.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-db-push\", schema \"public\" at \"localhost:5432\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`User\\` table, which is not empty (1 rows).\n\n\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"multiSchema: --force-reset should succeed and display a log","suites":["postgresql-multischema"],"updatePoint":{"line":398,"column":65},"line":398,"code":"  it('multiSchema: --force-reset should succeed and display a log', async () => {\n    ctx.fixture('introspection/postgresql-multischema')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse(['--force-reset'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from schema.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-db-push-multischema\", schemas \"base, transactional\" at \"localhost:5432\"\n\n      The PostgreSQL database \"tests-migrate-db-push-multischema\" schemas \"base, transactional\" at \"localhost:5432\" were successfully reset.\n\n      Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--force-reset should succeed and print a log","suites":["postgresql-multischema"],"updatePoint":{"line":444,"column":50},"line":444,"code":"  it('--force-reset should succeed and print a log', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse(['--force-reset'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate-existing-db\" at \"localhost:27017\"\n\n      The MongoDB database \"tests-migrate-existing-db\" at \"localhost:27017\" was successfully reset.\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings accepted (prompt)","suites":["postgresql-multischema"],"updatePoint":{"line":466,"column":41},"line":466,"code":"  it('dataloss warnings accepted (prompt)', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate-existing-db\" at \"localhost:27017\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings cancelled (prompt)","suites":["postgresql-multischema"],"updatePoint":{"line":486,"column":42},"line":486,"code":"  it('dataloss warnings cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate-existing-db\" at \"localhost:27017\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--accept-data-loss flag","suites":["postgresql-multischema"],"updatePoint":{"line":510,"column":29},"line":510,"code":"  it('--accept-data-loss flag', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n    const result = DbPush.new().parse(['--accept-data-loss'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeRocketEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MongoDB database \"tests-migrate-existing-db\" at \"localhost:27017\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.js","suites":["seed"],"updatePoint":{"line":9,"column":13},"line":9,"code":"  it('seed.js', async () => {\n    ctx.fixture('seed-sqlite-js')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toContain(`The seed command has been executed.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.js with -- extra args should succeed","suites":["seed"],"updatePoint":{"line":21,"column":47},"line":21,"code":"  it('seed.js with -- extra args should succeed', async () => {\n    ctx.fixture('seed-sqlite-js-extra-args')\n\n    const result = DbSeed.new().parse([\n      '--',\n      '--my-custom-arg-from-cli-1',\n      'my-value',\n      '--my-custom-arg-from-cli-2=my-value',\n      '-z',\n    ])\n    await expect(result).resolves.toContain(`The seed command has been executed.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js --my-custom-arg-from-config-1 my-value --my-custom-arg-from-config-2=my-value -y --my-custom-arg-from-cli-1 my-value --my-custom-arg-from-cli-2=my-value -z\\` ...`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.js with extra args but missing -- should throw with specific message","suites":["seed"],"updatePoint":{"line":39,"column":79},"line":39,"code":"  it('seed.js with extra args but missing -- should throw with specific message', async () => {\n    ctx.fixture('seed-sqlite-js-extra-args')\n\n    const result = DbSeed.new().parse(['--my-custom-arg-from-cli=my-value', '-z'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      unknown or unexpected option: --my-custom-arg-from-cli\n      Did you mean to pass these as arguments to your seed script? If so, add a -- separator before them:\n      $ prisma db seed -- --arg1 value1 --arg2 value2\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one broken seed.js file","suites":["seed"],"updatePoint":{"line":53,"column":29},"line":53,"code":"  it('one broken seed.js file', async () => {\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    ctx.fixture('seed-sqlite-js')\n    ctx.fs.write('prisma/seed.js', 'BROKEN_CODE_SHOULD_ERROR;')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join()).toContain('An error occurred while running the seed command:')\n    expect(mockExit).toHaveBeenCalledWith(1)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.ts","suites":["seed"],"updatePoint":{"line":70,"column":13},"line":70,"code":"  it('seed.ts', async () => {\n    ctx.fixture('seed-sqlite-ts')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toContain(`The seed command has been executed.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`ts-node prisma/seed.ts\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  }, 10_000)","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.ts - ESM","suites":["seed"],"updatePoint":{"line":81,"column":19},"line":81,"code":"  it('seed.ts - ESM', async () => {\n    ctx.fixture('seed-sqlite-ts-esm')\n\n    // Needs ts-node to be installed\n    await execa.command('npm i')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toContain(`The seed command has been executed.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node --loader ts-node/esm prisma/seed.ts\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    // \"high\" number since `npm install` can sometimes be very slow\n  }, 60_000)","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.sh","suites":["seed"],"updatePoint":{"line":97,"column":13},"line":97,"code":"  it('seed.sh', async () => {\n    ctx.fixture('seed-sqlite-sh')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toContain(`The seed command has been executed.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`./prisma/seed.sh\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no seed file","suites":["seed - legacy"],"updatePoint":{"line":110,"column":18},"line":110,"code":"  it('no seed file', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    ctx.fs.remove('prisma/seed.ts')\n    ctx.fs.remove('prisma/seed.sh')\n\n    try {\n      await DbSeed.new().parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`\n        To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n        1. Open the package.json of your project\n        2. Add one of the following examples to your package.json:\n\n        TypeScript:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"ts-node ./prisma/seed.ts\"\n        }\n        \\`\\`\\`\n        If you are using ESM (ECMAScript modules):\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"node --loader ts-node/esm ./prisma/seed.ts\"\n        }\n        \\`\\`\\`\n\n        And install the required dependencies by running:\n        npm i -D ts-node typescript @types/node\n\n        JavaScript:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"node ./prisma/seed.js\"\n        }\n        \\`\\`\\`\n\n        Bash:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"./prisma/seed.sh\"\n        }\n        \\`\\`\\`\n        And run \\`chmod +x prisma/seed.sh\\` to make it executable.\n        More information in our documentation:\n        https://pris.ly/d/seeding\n      `)\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"more than one seed file","suites":["seed - legacy"],"updatePoint":{"line":164,"column":29},"line":164,"code":"  it('more than one seed file', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\nTo configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n1. Open the package.json of your project\n2. Add the following example to it:\n\\`\\`\\`\n\"prisma\": {\n  \"seed\": \"node prisma/seed.js\"\n}\n\\`\\`\\`\n\nMore information in our documentation:\nhttps://pris.ly/d/seeding\n`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"custom --schema from package.json should enrich help setup","suites":["seed - legacy"],"updatePoint":{"line":187,"column":64},"line":187,"code":"  it('custom --schema from package.json should enrich help setup', async () => {\n    ctx.fixture('seed-sqlite-legacy-schema-from-package-json')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n            1. Open the package.json of your project\n            2. Add the following example to it:\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"node custom-folder/seed.js\"\n            }\n            \\`\\`\\`\n\n            More information in our documentation:\n            https://pris.ly/d/seeding\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"custom ts-node should warn","suites":["seed - legacy"],"updatePoint":{"line":209,"column":32},"line":209,"code":"  it('custom ts-node should warn', async () => {\n    ctx.fixture('seed-sqlite-legacy-custom-ts-node')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n            1. Open the package.json of your project\n            2. Add the following example to it:\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"ts-node prisma/seed.ts\"\n            }\n            \\`\\`\\`\n            If you are using ESM (ECMAScript modules):\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"node --loader ts-node/esm prisma/seed.ts\"\n            }\n            \\`\\`\\`\n\n            3. Install the required dependencies by running:\n            npm i -D ts-node typescript @types/node\n\n            More information in our documentation:\n            https://pris.ly/d/seeding\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `prisma:warn The \"ts-node\" script in the package.json is not used anymore since version 3.0 and can now be removed.`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"can create database - sqlite","suites":[],"updatePoint":{"line":8,"column":32},"line":8,"code":"it('can create database - sqlite', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const result = ensureDatabaseExists('create', schemaPath)\n  await expect(result).resolves.toMatchInlineSnapshot(`SQLite database dev.db created at file:dev.db`)\n})","file":"ensureDatabaseExists.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"force panic","suites":["introspection panic"],"updatePoint":{"line":6,"column":19},"line":6,"code":"  test('force panic', async () => {\n    expect.assertions(1)\n    process.env.FORCE_PANIC_SCHEMA_ENGINE = '1'\n    process.chdir(path.join(__dirname, 'fixtures', 'introspection', 'sqlite'))\n\n    const introspect = new DbPull()\n    try {\n      await introspect.parse(['--print'])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] This is the debugPanic artificial panic\n\n      `)\n    }\n  })","file":"handlePanic.introspect.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"test interactive engine panic","suites":["handlePanic migrate"],"updatePoint":{"line":74,"column":35},"line":74,"code":"  it('test interactive engine panic', async () => {\n    process.env.FORCE_PANIC_SCHEMA_ENGINE = '1'\n    const captureStdout = new CaptureStdout()\n    const files = {\n      'schema.prisma': `\n        datasource my_db {\n          provider = \"sqlite\"\n          url = \"file:./db/db_file.db\"\n          default = true\n        }\n\n        model User {\n          id Int @id\n        }\n      `,\n      'db/.keep': ``,\n    }\n    const schemaPath = join(testRootDir, Object.keys(files)[0])\n    await writeFiles(testRootDir, files)\n\n    captureStdout.startCapture()\n\n    let error\n    try {\n      const migrate = new Migrate(schemaPath)\n      await migrate.createMigration({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n        migrationName: 'setup',\n        draft: false,\n        prismaSchema: migrate.getPrismaSchema(),\n      })\n    } catch (err) {\n      // No to send error report\n      setTimeout(() => sendKeystrokes(io).then(), 5)\n      // No to create new issue\n      setTimeout(() => sendKeystrokes(io).then(), 5)\n      // This allows this test to be run in the CI\n      const getDatabaseVersionSafe = () => Promise.resolve(undefined)\n      try {\n        await handlePanic({\n          error: err,\n          cliVersion: packageJsonVersion,\n          enginesVersion,\n          command,\n          getDatabaseVersionSafe,\n        })\n      } catch (err) {\n        error = err\n      }\n    }\n    // We use prompts.inject() for testing in our CI\n    if (isCi() && Boolean((prompt as any)._injected?.length) === false) {\n      expect(error).toMatchInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] This is the debugPanic artificial panic\n\n      `)\n    } else {\n      const output = captureStdout.getCapturedText()\n      expect(stripAnsi(output.join('\\n'))).toMatchInlineSnapshot(``)\n    }\n    captureStdout.stopCapture()\n  })","file":"handlePanic.migrate.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"engine panic no interactive mode in CI","suites":["handlePanic migrate"],"updatePoint":{"line":138,"column":44},"line":138,"code":"  it('engine panic no interactive mode in CI', async () => {\n    process.env.FORCE_PANIC_SCHEMA_ENGINE = '1'\n\n    const files = {\n      'schema.prisma': `\n        datasource my_db {\n          provider = \"sqlite\"\n          url = \"file:./db/db_file.db\"\n          default = true\n        }\n\n        model User {\n          id Int @id\n        }\n      `,\n      'db/.keep': ``,\n    }\n    const schemaPath = join(testRootDir, Object.keys(files)[0])\n    await writeFiles(testRootDir, files)\n\n    try {\n      const migrate = new Migrate(schemaPath)\n      await migrate.createMigration({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n        migrationName: 'setup',\n        draft: false,\n        prismaSchema: migrate.getPrismaSchema(),\n      })\n    } catch (e) {\n      const error = e as RustPanic\n\n      expect(error).toMatchSnapshot()\n      expect(JSON.parse(JSON.stringify(error))).toMatchObject({\n        area: 'LIFT_CLI',\n        schemaPath,\n      })\n      expect(error.message).toContain('This is the debugPanic artificial panic')\n      expect(error.rustStack).toContain('[EXIT_PANIC]')\n\n      const isWindows = ['win32'].includes(process.platform)\n      if (!isWindows) {\n        expect(error.rustStack).toContain('std::panicking::')\n      }\n    }\n  })","file":"handlePanic.migrate.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection basic","suites":[],"updatePoint":{"line":6,"column":25},"line":6,"code":"test('introspection basic', async () => {\n  const engine = new SchemaEngine({\n    projectDir: __dirname,\n    schemaPath: 'schema.prisma',\n  })\n\n  const schema = await fs.promises.readFile(path.join(__dirname, 'schema.prisma'), { encoding: 'utf-8' })\n\n  const dbVersion = await engine.getDatabaseVersion({\n    datasource: {\n      tag: 'SchemaString',\n      schema,\n    },\n  })\n  expect(dbVersion.length > 0).toBe(true)\n\n  const result = await engine.introspect({ schema })\n  expect(result).toMatchInlineSnapshot(`\n    {\n      datamodel: datasource db {\n      provider = \"sqlite\"\n      url      = \"file:./blog.db\"\n    }\n\n    model Post {\n      author    Int\n      content   String?\n      createdAt DateTime @default(dbgenerated(\"'1970-01-01 00:00:00'\"))\n      kind      String?\n      published Boolean  @default(false)\n      title     String   @default(\"\")\n      updatedAt DateTime @default(dbgenerated(\"'1970-01-01 00:00:00'\"))\n      uuid      String   @id @unique(map: \"Post.uuid\")\n      User      User     @relation(fields: [author], references: [id], onUpdate: NoAction)\n    }\n\n    model User {\n      age     Int     @default(0)\n      amount  Float   @default(0)\n      balance Float   @default(0)\n      email   String  @unique(map: \"User.email\") @default(\"\")\n      id      Int     @id @unique(map: \"User.id\") @default(autoincrement())\n      name    String?\n      role    String  @default(\"USER\")\n      Post    Post[]\n    }\n    ,\n      views: null,\n      warnings: null,\n    }\n  `)\n})","file":"introspection/introspection.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":3,"column":32},"line":3,"code":"it('no params should return help', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":12,"column":14},"line":12,"code":"it('wrong flag', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":21,"column":13},"line":21,"code":"it('help flag', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":30,"column":19},"line":30,"code":"it('unknown command', async () => {\n  await expect(MigrateCommand.new({}).parse(['doesnotexist'])).resolves.toThrow()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":12,"column":35},"line":12,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no unapplied migrations","suites":["sqlite"],"updatePoint":{"line":23,"column":29},"line":23,"code":"  it('no unapplied migrations', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDeploy.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      No migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"1 unapplied migration","suites":["sqlite"],"updatePoint":{"line":42,"column":27},"line":42,"code":"  it('1 unapplied migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    fs.remove('prisma/dev.db')\n\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            The following migration have been applied:\n\n            migrations/\n              └─ 20201231000000_init/\n                └─ migration.sql\n                  \n            All migrations have been successfully applied.\n          `)\n\n    // Second time should do nothing (already applied)\n    const resultBis = MigrateDeploy.new().parse([])\n    await expect(resultBis).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      1 migration found in prisma/migrations\n\n      Applying migration \\`20201231000000_init\\`\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should throw if database is not empty","suites":["sqlite"],"updatePoint":{"line":82,"column":43},"line":82,"code":"  it('should throw if database is not empty', async () => {\n    ctx.fixture('existing-db-1-migration-conflict')\n\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P3005\n\n            The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline\n\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      1 migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if url is prisma://","suites":["postgresql"],"updatePoint":{"line":131,"column":37},"line":131,"code":"  it('should fail if url is prisma://', async () => {\n    ctx.fixture('schema-only-data-proxy')\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Using the Data Proxy (connection URL starting with protocol prisma://) is not supported for this CLI command prisma migrate deploy yet. Please use a direct connection to your database via the datasource 'directUrl' setting.\n\n    More information about Data Proxy: https://pris.ly/d/data-proxy-cli\n\n  `)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work if directUrl is set as an env var","suites":["postgresql"],"updatePoint":{"line":143,"column":51},"line":143,"code":"  it('should work if directUrl is set as an env var', async () => {\n    ctx.fixture('schema-only-data-proxy')\n    const result = MigrateDeploy.new().parse(['--schema', 'with-directUrl-env.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from .env\n      Prisma schema loaded from with-directUrl-env.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-deploy\", schema \"public\" at \"localhost:5432\"\n\n      No migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"invalid schema","suites":["common"],"updatePoint":{"line":34,"column":20},"line":34,"code":"  it('invalid schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    try {\n      await MigrateDev.new().parse(['--schema=./prisma/invalid.prisma'])\n      expect(true).toBe(false) // unreachable\n    } catch (error) {\n      expect(error.message).toMatchInlineSnapshot(`\n        Prisma schema validation - (get-config wasm)\n        Error code: P1012\n        error: Error validating: This line is invalid. It does not start with any known Prisma schema keyword.\n          -->  schema.prisma:10\n           | \n         9 | }\n        10 | model Blog {\n        11 | \n           | \n\n        Validation Error Count: 1\n        [Context: getConfig]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from prisma/invalid.prisma`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"provider array should fail","suites":["common"],"updatePoint":{"line":66,"column":32},"line":66,"code":"  it('provider array should fail', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    try {\n      await MigrateDev.new().parse(['--schema=./prisma/provider-array.prisma'])\n      expect(true).toBe(false) // unreachable\n    } catch (error) {\n      expect(error.message).toMatchInlineSnapshot(`\n        Prisma schema validation - (get-config wasm)\n        Error code: P1012\n        error: Error validating datasource \\`my_db\\`: The provider argument in a datasource must be a string literal\n          -->  schema.prisma:2\n           | \n         1 | datasource my_db {\n         2 |     provider = [\"postgresql\", \"sqlite\"]\n           | \n\n        Validation Error Count: 1\n        [Context: getConfig]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from prisma/provider-array.prisma`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":["common"],"updatePoint":{"line":96,"column":16},"line":96,"code":"  it('wrong flag', async () => {\n    const commandInstance = MigrateDev.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--something'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":["common"],"updatePoint":{"line":104,"column":15},"line":104,"code":"  it('help flag', async () => {\n    const commandInstance = MigrateDev.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--help'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":112,"column":35},"line":112,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dev should error in unattended environment","suites":["common"],"updatePoint":{"line":120,"column":48},"line":120,"code":"  it('dev should error in unattended environment', async () => {\n    ctx.fixture('transition-db-push-migrate')\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            Prisma Migrate has detected that the environment is non-interactive, which is not supported.\n\n            \\`prisma migrate dev\\` is an interactive command designed to create new migrations and evolve the database in development.\n            To apply existing migrations in deployments, use prisma migrate deploy.\n            See https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-deploy\n          `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"empty schema","suites":["sqlite"],"updatePoint":{"line":135,"column":18},"line":135,"code":"  it('empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDev.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Already in sync, no schema change or pending migration was found.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"first migration (--name)","suites":["sqlite"],"updatePoint":{"line":152,"column":30},"line":152,"code":"  it('first migration (--name)', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(fs.exists('prisma/migrations/migration_lock.toml')).toEqual('file')\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"snapshot of sql","suites":["sqlite"],"updatePoint":{"line":249,"column":21},"line":249,"code":"  it('snapshot of sql', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    const baseDir = path.join('prisma', 'migrations')\n    const migrationDirList = fs.list(baseDir)\n    const migrationFilePath = path.join(baseDir, migrationDirList![0], 'migration.sql')\n    const migrationFile = fs.read(migrationFilePath)\n    expect(migrationFile).toMatchInlineSnapshot(`\n      -- CreateTable\n      CREATE TABLE \"Blog\" (\n          \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n          \"viewCount20\" INTEGER NOT NULL\n      );\n\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (prompt)","suites":["sqlite"],"updatePoint":{"line":270,"column":40},"line":270,"code":"  it('draft migration and apply (prompt)', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    prompt.inject(['some-Draft'])\n\n    const draftResult = MigrateDev.new().parse(['--create-only'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_some_draft\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Enter a name for the new migration:\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_some_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_some_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration with empty schema (prompt)","suites":["sqlite"],"updatePoint":{"line":313,"column":48},"line":313,"code":"  it('draft migration with empty schema (prompt)', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    prompt.inject(['some-empty-Draft'])\n\n    const draftResult = MigrateDev.new().parse(['--schema=./prisma/empty.prisma', '--create-only'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_some_empty_draft\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Enter a name for the new migration:\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["sqlite"],"updatePoint":{"line":340,"column":40},"line":340,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"transition-db-push-migrate (prompt reset yes)","suites":["sqlite"],"updatePoint":{"line":378,"column":51},"line":378,"code":"  it('transition-db-push-migrate (prompt reset yes)', async () => {\n    ctx.fixture('transition-db-push-migrate')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n        - _Migration\n\n      We need to reset the SQLite database \"dev.db\" at \"file:dev.db\"\n      Do you want to continue? All data will be lost.\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"transition-db-push-migrate (prompt reset no)","suites":["sqlite"],"updatePoint":{"line":420,"column":50},"line":420,"code":"  it('transition-db-push-migrate (prompt reset no)', async () => {\n    ctx.fixture('transition-db-push-migrate')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n        - _Migration\n\n      We need to reset the SQLite database \"dev.db\" at \"file:dev.db\"\n      Do you want to continue? All data will be lost.\n\n      Reset cancelled.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"edited migration and unapplied empty draft","suites":["sqlite"],"updatePoint":{"line":458,"column":48},"line":458,"code":"  it('edited migration and unapplied empty draft', async () => {\n    ctx.fixture('edited-and-draft')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      The migration \\`20201231000000_test\\` was modified after it was applied.\n      We need to reset the SQLite database \"dev.db\" at \"file:dev.db\"\n      Do you want to continue? All data will be lost.\n\n      Applying migration \\`20201231000000_test\\`\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_test/\n          └─ migration.sql\n        └─ 20201231000000_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"removed applied migration and unapplied empty draft","suites":["sqlite"],"updatePoint":{"line":491,"column":57},"line":491,"code":"  it('removed applied migration and unapplied empty draft', async () => {\n    ctx.fixture('edited-and-draft')\n    fs.remove('prisma/migrations/20201117144659_test')\n\n    prompt.inject(['y', 'new-change'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      - Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      [+] Added tables\n        - Blog\n\n      - The migrations recorded in the database diverge from the local migrations directory.\n\n      We need to reset the SQLite database \"dev.db\" at \"file:dev.db\"\n      Do you want to continue? All data will be lost.\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n      Enter a name for the new migration:\n      Applying migration \\`20201231000000_new_change\\`\n\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_new_change/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"broken migration should fail","suites":["sqlite"],"updatePoint":{"line":541,"column":34},"line":541,"code":"  it('broken migration should fail', async () => {\n    ctx.fixture('broken-migration')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('near \"BROKEN\": syntax error')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: has a failed migration","suites":["sqlite"],"updatePoint":{"line":562,"column":40},"line":562,"code":"  it('existingdb: has a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('P3006')\n      expect(e.message).toContain('failed to apply cleanly to the shadow database.')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration edit migration with broken sql","suites":["sqlite"],"updatePoint":{"line":582,"column":60},"line":582,"code":"  it('existing-db-1-migration edit migration with broken sql', async () => {\n    ctx.fixture('existing-db-1-migration')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    // Edit with broken SQL\n    fs.write('prisma/migrations/20201014154943_init/migration.sql', 'CREATE BROKEN')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('P3006')\n      expect(e.message).toContain('failed to apply cleanly to the shadow database.')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Already in sync, no schema change or pending migration was found.\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unapplied draft","suites":["sqlite"],"updatePoint":{"line":612,"column":35},"line":612,"code":"  it('existingdb: 1 unapplied draft', async () => {\n    ctx.fixture('existing-db-1-draft')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unapplied draft + 1 schema change","suites":["sqlite"],"updatePoint":{"line":635,"column":53},"line":635,"code":"  it('existingdb: 1 unapplied draft + 1 schema change', async () => {\n    ctx.fixture('existing-db-1-draft-1-change')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n      Applying migration \\`20201231000000_\\`\n\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unexecutable schema change","suites":["sqlite"],"updatePoint":{"line":666,"column":46},"line":666,"code":"  it('existingdb: 1 unexecutable schema change', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ⚠️ We found changes that cannot be executed:\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      • Step 0 Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    You can use prisma migrate dev --create-only to create the migration file, and manually modify it to address the underlying issue(s).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Then run prisma migrate dev to apply it and verify it works.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unexecutable schema change with --create-only should succeed","suites":["sqlite"],"updatePoint":{"line":690,"column":80},"line":690,"code":"  it('existingdb: 1 unexecutable schema change with --create-only should succeed', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = MigrateDev.new().parse(['--create-only'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 warning from schema change (prompt yes)","suites":["sqlite"],"updatePoint":{"line":709,"column":59},"line":709,"code":"  it('existingdb: 1 warning from schema change (prompt yes)', async () => {\n    ctx.fixture('existing-db-1-warning')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                                    ⚠️  Warnings for the current datasource:\n\n                                                                                                                                                                                                                                                                                                                                                                                      • You are about to drop the \\`Blog\\` table, which is not empty (2 rows).\n                                                                                                                                                                                                                                                        `)\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 warning from schema change (prompt no)","suites":["sqlite"],"updatePoint":{"line":740,"column":58},"line":740,"code":"  it('existingdb: 1 warning from schema change (prompt no)', async () => {\n    ctx.fixture('existing-db-1-warning')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()])\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Migration cancelled.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                                    ⚠️  Warnings for the current datasource:\n\n                                                                                                                                                                                                                                                                                                                                                                                      • You are about to drop the \\`Blog\\` table, which is not empty (2 rows).\n                                                                                                                                                                                                                                                        `)\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one seed.ts file","suites":["sqlite"],"updatePoint":{"line":767,"column":24},"line":767,"code":"  test('one seed.ts file', async () => {\n    ctx.fixture('seed-sqlite-ts')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(removeSeedlingEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Enter a name for the new migration:\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n\n      Running seed command \\`ts-node prisma/seed.ts\\` ...\n\n      The seed command has been executed.\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one seed file --skip-seed","suites":["sqlite"],"updatePoint":{"line":801,"column":31},"line":801,"code":"  it('one seed file --skip-seed', async () => {\n    ctx.fixture('seed-sqlite-ts')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse(['--skip-seed'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Enter a name for the new migration:\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one broken seed.js file","suites":["sqlite"],"updatePoint":{"line":830,"column":29},"line":830,"code":"  it('one broken seed.js file', async () => {\n    ctx.fixture('seed-sqlite-js')\n    fs.write('prisma/seed.js', 'BROKEN_CODE_SHOULD_ERROR;')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Enter a name for the new migration:\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n\n      Running seed command \\`node prisma/seed.js\\` ...\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toContain(`An error occurred while running the seed command:`)\n    expect(mockExit).toHaveBeenCalledWith(1)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"legacy seed (no config in package.json)","suites":["sqlite"],"updatePoint":{"line":866,"column":45},"line":866,"code":"  it('legacy seed (no config in package.json)', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    // ctx.fs.remove('prisma/seed.ts')\n    ctx.fs.remove('prisma/seed.sh')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Enter a name for the new migration:\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"provider switch: postgresql to sqlite","suites":["sqlite"],"updatePoint":{"line":897,"column":43},"line":897,"code":"  it('provider switch: postgresql to sqlite', async () => {\n    ctx.fixture('provider-switch-postgresql-to-sqlite')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3019')\n      expect(e.message).toContain('P3019')\n      expect(e.message).toContain('The datasource provider')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["postgresql"],"updatePoint":{"line":956,"column":17},"line":956,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-postgresql')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["postgresql"],"updatePoint":{"line":980,"column":31},"line":980,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-postgresql')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["postgresql"],"updatePoint":{"line":1004,"column":28},"line":1004,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration with nativeTypes","suites":["postgresql"],"updatePoint":{"line":1028,"column":45},"line":1028,"code":"  it('create first migration with nativeTypes', async () => {\n    ctx.fixture('nativeTypes-postgresql')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["postgresql"],"updatePoint":{"line":1075,"column":40},"line":1075,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-postgresql')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["postgresql"],"updatePoint":{"line":1114,"column":40},"line":1114,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"need to reset prompt: (no) should succeed","suites":["postgresql"],"line":1167,"code":"  it.skip('need to reset prompt: (no) should succeed', async () => {","file":"MigrateDev.test.ts","skipped":true,"dir":"packages/migrate/src/__tests__"},{"name":"should work if directUrl is set as env var","suites":["postgresql"],"updatePoint":{"line":1208,"column":48},"line":1208,"code":"  it('should work if directUrl is set as env var', async () => {\n    ctx.fixture('schema-only-data-proxy')\n    const result = MigrateDev.new().parse(['--schema', 'with-directUrl-env.prisma', '--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from .env\n      Prisma schema loaded from with-directUrl-env.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Already in sync, no schema change or pending migration was found.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["postgresql"],"updatePoint":{"line":1264,"column":17},"line":1264,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["postgresql"],"updatePoint":{"line":1288,"column":31},"line":1288,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev-shadowdb\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["postgresql"],"updatePoint":{"line":1312,"column":28},"line":1312,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration with nativeTypes","suites":["postgresql"],"updatePoint":{"line":1336,"column":45},"line":1336,"code":"  it('create first migration with nativeTypes', async () => {\n    ctx.fixture('nativeTypes-cockroachdb')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  }, 40000)","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["postgresql"],"updatePoint":{"line":1359,"column":40},"line":1359,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["postgresql"],"updatePoint":{"line":1398,"column":40},"line":1398,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["mysql"],"updatePoint":{"line":1459,"column":17},"line":1459,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-mysql')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["mysql"],"updatePoint":{"line":1482,"column":31},"line":1482,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-mysql')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["mysql"],"updatePoint":{"line":1505,"column":28},"line":1505,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-mysql')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["mysql"],"updatePoint":{"line":1576,"column":40},"line":1576,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-mysql')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["mysql"],"updatePoint":{"line":1613,"column":40},"line":1613,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-mysql')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["mysql"],"updatePoint":{"line":1682,"column":17},"line":1682,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-sqlserver')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["mysql"],"updatePoint":{"line":1705,"column":31},"line":1705,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-sqlserver')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["mysql"],"updatePoint":{"line":1728,"column":28},"line":1728,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-sqlserver')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["mysql"],"updatePoint":{"line":1799,"column":40},"line":1799,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-sqlserver')\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["mysql"],"updatePoint":{"line":1835,"column":40},"line":1835,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-sqlserver')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQL Server database\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --from-... and --to-...","suites":["migrate diff","generic"],"updatePoint":{"line":20,"column":54},"line":20,"code":"    it('should fail if missing --from-... and --to-...', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse([])\n      await expect(result).rejects.toThrow()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if only --from-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":27,"column":50},"line":27,"code":"    it('should fail if only --from-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--from-empty'])\n      await expect(result).rejects.toThrow()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if only --to-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":34,"column":48},"line":34,"code":"    it('should fail if only --to-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--to-empty'])\n      await expect(result).rejects.toThrow()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if more than 1 --from-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":41,"column":57},"line":41,"code":"    it('should fail if more than 1 --from-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--from-url=file:dev.db'])\n      await expect(result).rejects.toThrow()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if more than 1 --to-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":48,"column":55},"line":48,"code":"    it('should fail if more than 1 --to-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--to-empty', '--to-url=file:dev.db'])\n      await expect(result).rejects.toThrow()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if schema does no exists, --from-schema-datasource","suites":["migrate diff","generic"],"updatePoint":{"line":55,"column":70},"line":55,"code":"    it('should fail if schema does no exists, --from-schema-datasource', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await MigrateDiff.new().parse(['--from-schema-datasource=./doesnoexists.prisma', '--to-empty'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toContain(`Error trying to read Prisma schema file at`)\n      }\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for empty/empty","suites":["migrate diff","generic"],"updatePoint":{"line":67,"column":35},"line":67,"code":"    it('should fail for empty/empty', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await MigrateDiff.new().parse(['--from-empty', '--to-empty'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          Could not determine the connector to use for diffing.\n\n\n        `)\n      }\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail --from-empty --to-url=file:doesnotexists.db","suites":["migrate diff","sqlite"],"updatePoint":{"line":85,"column":63},"line":85,"code":"    it('should fail --from-empty --to-url=file:doesnotexists.db', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:doesnotexists.db'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail --from-url=file:doesnotexists.db --to-empty ","suites":["migrate diff","sqlite"],"updatePoint":{"line":97,"column":64},"line":97,"code":"    it('should fail --from-url=file:doesnotexists.db --to-empty ', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:doesnotexists.db', '--to-empty'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if directory in path & sqlite file does not exist","suites":["migrate diff","sqlite"],"updatePoint":{"line":109,"column":69},"line":109,"code":"    it('should fail if directory in path & sqlite file does not exist', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:./something/doesnotexists.db', '--to-empty'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at ./something/doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-url=file:dev.db","suites":["migrate diff","sqlite"],"updatePoint":{"line":123,"column":53},"line":123,"code":"    it('should diff --from-empty --to-url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [+] Added tables\n                                                                                                                          - Post\n                                                                                                                          - Profile\n                                                                                                                          - User\n                                                                                                                          - _Migration\n\n                                                                                                                        [*] Changed the \\`Profile\\` table\n                                                                                                                          [+] Added unique index on columns (userId)\n\n                                                                                                                        [*] Changed the \\`User\\` table\n                                                                                                                          [+] Added unique index on columns (email)\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-url=file:dev.db --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":143,"column":62},"line":143,"code":"    it('should diff --from-empty --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db', '--script'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma","suites":["migrate diff","sqlite"],"updatePoint":{"line":151,"column":77},"line":151,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-schema-datamodel=./prisma/schema.prisma'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [+] Added tables\n                                                                                                                          - Blog\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":162,"column":86},"line":162,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse([\n        '--from-empty',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n            \"viewCount20\" INTEGER NOT NULL\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty","suites":["migrate diff","sqlite"],"updatePoint":{"line":180,"column":77},"line":180,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-schema-datamodel=./prisma/schema.prisma', '--to-empty'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [-] Removed tables\n                                                                                                                          - Blog\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":191,"column":86},"line":191,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty --script', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datamodel=./prisma/schema.prisma',\n        '--to-empty',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- DropTable\n        PRAGMA foreign_keys=off;\n        DROP TABLE \"Blog\";\n        PRAGMA foreign_keys=on;\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass if no schema file around","suites":["migrate diff","sqlite"],"updatePoint":{"line":208,"column":44},"line":208,"code":"    it('should pass if no schema file around', async () => {\n      ctx.fixture('empty')\n      // Create empty file, as the file needs to exists\n      ctx.fs.write('dev.db', '')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:dev.db', '--to-url=file:dev.db'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`No difference detected.`)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 2 when diff is not empty without --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":219,"column":73},"line":219,"code":"      it('should exit with code 2 when diff is not empty without --script', async () => {\n        ctx.fixture('schema-only-sqlite')\n\n        const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n          throw new Error('process.exit: ' + number)\n        })\n\n        const result = MigrateDiff.new().parse([\n          '--from-schema-datamodel=./prisma/schema.prisma',\n          '--to-empty',\n          '--exit-code',\n        ])\n\n        await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 2`)\n        expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                [-] Removed tables\n                                                                                  - Blog\n                                                                `)\n\n        expect(mockExit).toHaveBeenCalledTimes(1)\n        expect(mockExit).toHaveBeenCalledWith(2)\n        mockExit.mockRestore()\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 2 when diff is not empty with --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":245,"column":70},"line":245,"code":"      it('should exit with code 2 when diff is not empty with --script', async () => {\n        ctx.fixture('schema-only-sqlite')\n\n        const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n          throw new Error('process.exit: ' + number)\n        })\n\n        const result = MigrateDiff.new().parse([\n          '--from-schema-datamodel=./prisma/schema.prisma',\n          '--to-empty',\n          '--script',\n          '--exit-code',\n        ])\n\n        await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 2`)\n        expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n          -- DropTable\n          PRAGMA foreign_keys=off;\n          DROP TABLE \"Blog\";\n          PRAGMA foreign_keys=on;\n        `)\n\n        expect(mockExit).toHaveBeenCalledTimes(1)\n        expect(mockExit).toHaveBeenCalledWith(2)\n        mockExit.mockRestore()\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 0 when diff is empty with --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":273,"column":66},"line":273,"code":"      it('should exit with code 0 when diff is empty with --script', async () => {\n        ctx.fixture('empty')\n        // Create empty file, as the file needs to exists\n        ctx.fs.write('dev.db', '')\n\n        const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db', '--script', '--exit-code'])\n\n        await expect(result).resolves.toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`-- This is an empty migration.`)\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma","suites":["migrate diff","mongodb"],"updatePoint":{"line":303,"column":77},"line":303,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-schema-datamodel=./prisma/schema.prisma'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`[+] Collection \\`User\\``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty","suites":["migrate diff","mongodb"],"updatePoint":{"line":311,"column":77},"line":311,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse(['--from-schema-datamodel=./prisma/schema.prisma', '--to-empty'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`No difference detected.`)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with not supported error with --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":319,"column":58},"line":319,"code":"    it('should fail with not supported error with --script', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-empty',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Rendering to a script is not supported on MongoDB.\n\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":369,"column":101},"line":369,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString!,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INT4 NOT NULL,\n            \"viewCount20\" INT4 NOT NULL,\n\n            CONSTRAINT \"Blog_pkey\" PRIMARY KEY (\"id\")\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file with --from-schema-datasource","suites":["migrate diff","mongodb"],"updatePoint":{"line":390,"column":71},"line":390,"code":"    it('should use env var from .env file with --from-schema-datasource', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datasource=./prisma/using-dotenv.prisma',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n      ])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`26257\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`26257\\`.\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":407,"column":104},"line":407,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString!, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Error in Schema engine.\n              Reason: [/some/rust/path:0:0] called \\`Option::unwrap()\\` on a \\`None\\` value\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","postgresql"],"updatePoint":{"line":445,"column":101},"line":445,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INTEGER NOT NULL,\n            \"viewCount20\" INTEGER NOT NULL,\n\n            CONSTRAINT \"Blog_pkey\" PRIMARY KEY (\"id\")\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file with --from-schema-datasource","suites":["migrate diff","postgresql"],"updatePoint":{"line":466,"column":71},"line":466,"code":"    it('should use env var from .env file with --from-schema-datasource', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datasource=./prisma/using-dotenv.prisma',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n      ])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`5432\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`5432\\`.\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","postgresql"],"updatePoint":{"line":483,"column":104},"line":483,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] called \\`Option::unwrap()\\` on a \\`None\\` value\n\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work if directUrl is set as an env var","suites":["migrate diff","postgresql"],"updatePoint":{"line":494,"column":53},"line":494,"code":"    it('should work if directUrl is set as an env var', async () => {\n      ctx.fixture('schema-only-data-proxy')\n      const result = MigrateDiff.new().parse(['--from-schema-datasource', 'with-directUrl-env.prisma', '--to-empty'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`No difference detected.`)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mysql"],"updatePoint":{"line":536,"column":101},"line":536,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \\`Blog\\` (\n            \\`id\\` INTEGER NOT NULL,\n            \\`viewCount20\\` INTEGER NOT NULL,\n\n            PRIMARY KEY (\\`id\\`)\n        ) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","mysql"],"updatePoint":{"line":557,"column":104},"line":557,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] Column native type missing in mysql_renderer::render_column_type()\n\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mysql"],"updatePoint":{"line":612,"column":101},"line":612,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        jdbcConnectionString!,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        BEGIN TRY\n\n        BEGIN TRAN;\n\n        -- CreateTable\n        CREATE TABLE [dbo].[Blog] (\n            [id] INT NOT NULL,\n            [viewCount20] INT NOT NULL,\n            CONSTRAINT [Blog_pkey] PRIMARY KEY CLUSTERED ([id])\n        );\n\n        COMMIT TRAN;\n\n        END TRY\n        BEGIN CATCH\n\n        IF @@TRANCOUNT > 0\n        BEGIN\n            ROLLBACK TRAN;\n        END;\n        THROW\n\n        END CATCH\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=jdbcConnectionString --to-url=file:dev.db --script","suites":["migrate diff","mysql"],"updatePoint":{"line":649,"column":108},"line":649,"code":"    it('should fail for 2 different connectors --from-url=jdbcConnectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', jdbcConnectionString!, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Error in Schema engine.\n        Reason: [/some/rust/path:0:0] Missing column native type in mssql_renderer::render_column_type()\n\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":["common"],"updatePoint":{"line":15,"column":16},"line":15,"code":"  it('wrong flag', async () => {\n    const commandInstance = MigrateReset.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--something'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":["common"],"updatePoint":{"line":23,"column":15},"line":23,"code":"  it('help flag', async () => {\n    const commandInstance = MigrateReset.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--help'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":31,"column":35},"line":31,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (prompt)","suites":["reset"],"updatePoint":{"line":42,"column":26},"line":42,"code":"  it('should work (prompt)', async () => {\n    ctx.fixture('reset')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (--force)","suites":["reset"],"updatePoint":{"line":67,"column":27},"line":67,"code":"  it('should work (--force)', async () => {\n    ctx.fixture('reset')\n\n    const result = MigrateReset.new().parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db","suites":["reset"],"updatePoint":{"line":89,"column":21},"line":89,"code":"  it('with missing db', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const result = MigrateReset.new().parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without the migrations directory should fail (prompt)","suites":["reset"],"updatePoint":{"line":114,"column":59},"line":114,"code":"  it('without the migrations directory should fail (prompt)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/migrations')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should be cancelled if user send n (prompt)","suites":["reset"],"updatePoint":{"line":133,"column":49},"line":133,"code":"  it('should be cancelled if user send n (prompt)', async () => {\n    ctx.fixture('reset')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Reset cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(130)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset should error in unattended environment","suites":["reset"],"updatePoint":{"line":154,"column":50},"line":154,"code":"  it('reset should error in unattended environment', async () => {\n    ctx.fixture('reset')\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            Prisma Migrate has detected that the environment is non-interactive. It is recommended to run this command in an interactive environment.\n\n            Use --force to run this command without user interaction.\n            See https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-reset\n          `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - multiple seed files","suites":["reset"],"updatePoint":{"line":166,"column":33},"line":166,"code":"  it('reset - multiple seed files', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - multiple seed files - --skip-seed","suites":["reset"],"updatePoint":{"line":185,"column":47},"line":185,"code":"  it('reset - multiple seed files - --skip-seed', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse(['--skip-seed'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - seed.js","suites":["reset"],"updatePoint":{"line":194,"column":23},"line":194,"code":"  test('reset - seed.js', async () => {\n    ctx.fixture('seed-sqlite-js')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(removeSeedlingEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n\n      Running seed command \\`node prisma/seed.js\\` ...\n\n      The seed command has been executed.\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - seed.js - error should exit 1","suites":["reset"],"updatePoint":{"line":219,"column":45},"line":219,"code":"  test('reset - seed.js - error should exit 1', async () => {\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n    ctx.fixture('seed-sqlite-js')\n    ctx.fs.write('prisma/seed.js', 'BROKEN_CODE_SHOULD_ERROR;')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n\n      Running seed command \\`node prisma/seed.js\\` ...\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n            An error occurred while running the seed command:\n            Error: Command failed with exit code 1: node prisma/seed.js\n        `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - seed.ts","suites":["reset"],"updatePoint":{"line":251,"column":23},"line":251,"code":"  test('reset - seed.ts', async () => {\n    ctx.fixture('seed-sqlite-ts')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(removeSeedlingEmoji(ctx.mocked['console.info'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n        Prisma schema loaded from prisma/schema.prisma\n        Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n        SQLite database dev.db created at file:./dev.db\n\n\n        Database reset successful\n\n\n        Running seed command \\`ts-node prisma/seed.ts\\` ...\n\n        The seed command has been executed.\n      `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  }, 10_000)","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - legacy seed (no config in package.json)","suites":["reset"],"updatePoint":{"line":276,"column":53},"line":276,"code":"  it('reset - legacy seed (no config in package.json)', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    ctx.fs.remove('prisma/seed.ts')\n    // ctx.fs.remove('prisma/seed.sh')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work with directUrl","suites":["reset"],"updatePoint":{"line":300,"column":32},"line":300,"code":"  it('should work with directUrl', async () => {\n    ctx.fixture('reset-directurl')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":8,"column":35},"line":8,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateResolve.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no --applied or --rolled-back","suites":["common"],"updatePoint":{"line":16,"column":50},"line":16,"code":"  it('should fail if no --applied or --rolled-back', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            --applied or --rolled-back must be part of the command like:\n            prisma migrate resolve --applied 20201231000000_example\n            prisma migrate resolve --rolled-back 20201231000000_example\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --applied or --rolled-back","suites":["common"],"updatePoint":{"line":25,"column":52},"line":25,"code":"  it('should fail if both --applied or --rolled-back', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse(['--applied=something_applied', '--rolled-back=something_rolledback'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Pass either --applied or --rolled-back, not both.`)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no sqlite db - empty schema","suites":["sqlite"],"updatePoint":{"line":33,"column":48},"line":33,"code":"  it('should fail if no sqlite db - empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse(['--schema=./prisma/empty.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`P1003: Database dev.db does not exist at dev.db`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration doesn't exist","suites":["sqlite"],"updatePoint":{"line":50,"column":54},"line":50,"code":"  it(\"--applied should fail if migration doesn't exist\", async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--applied=does_not_exist'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3017\n\n            The migration does_not_exist could not be found. Please make sure that the migration exists, and that you included the whole name of the directory. (example: \"20201231000000_initial_migration\")\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration is already applied","suites":["sqlite"],"updatePoint":{"line":61,"column":59},"line":61,"code":"  it('--applied should fail if migration is already applied', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--applied=20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3008\n\n            The migration \\`20201231000000_init\\` is already recorded as applied in the database.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration is not in a failed state","suites":["sqlite"],"updatePoint":{"line":72,"column":65},"line":72,"code":"  it('--applied should fail if migration is not in a failed state', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--applied', '20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3008\n\n            The migration \\`20201231000000_init\\` is already recorded as applied in the database.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should work on a failed migration","suites":["sqlite"],"updatePoint":{"line":83,"column":49},"line":83,"code":"  it('--applied should work on a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--applied', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as applied.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should fail if migration doesn't exist","suites":["sqlite"],"updatePoint":{"line":99,"column":58},"line":99,"code":"  it(\"--rolled-back should fail if migration doesn't exist\", async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back=does_not_exist'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3011\n\n            Migration \\`does_not_exist\\` cannot be rolled back because it was never applied to the database. Hint: did you pass in the whole migration name? (example: \"20201231000000_initial_migration\")\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should fail if migration is not in a failed state","suites":["sqlite"],"updatePoint":{"line":110,"column":69},"line":110,"code":"  it('--rolled-back should fail if migration is not in a failed state', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3012\n\n            Migration \\`20201231000000_init\\` cannot be rolled back because it is not in a failed state.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should work on a failed migration","suites":["sqlite"],"updatePoint":{"line":121,"column":53},"line":121,"code":"  it('--rolled-back should work on a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back works if migration is already rolled back","suites":["sqlite"],"updatePoint":{"line":133,"column":61},"line":133,"code":"  it('--rolled-back works if migration is already rolled back', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n\n    // Try again\n    const result2 = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result2).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no db - invalid url","suites":["postgresql"],"updatePoint":{"line":154,"column":40},"line":154,"code":"  it('should fail if no db - invalid url', async () => {\n    ctx.fixture('schema-only-postgresql')\n    jest.setTimeout(10_000)\n\n    const result = MigrateResolve.new().parse(['--schema=./prisma/invalid-url.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P1001: Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n            Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"doesnotexist:5432\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no db - invalid url","suites":["postgresql"],"updatePoint":{"line":178,"column":40},"line":178,"code":"  it('should fail if no db - invalid url', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateResolve.new().parse(['--schema=./prisma/invalid-url.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P1001: Can't reach database server at \\`something.cockroachlabs.cloud\\`:\\`26257\\`\n\n            Please make sure your database server is running at \\`something.cockroachlabs.cloud\\`:\\`26257\\`.\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"db\": CockroachDB database \"clustername.defaultdb\", schema \"public\" at \"something.cockroachlabs.cloud:26257\"\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  }, 10_000)","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":8,"column":35},"line":8,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no sqlite db - empty schema","suites":["sqlite"],"updatePoint":{"line":19,"column":48},"line":19,"code":"  it('should fail if no sqlite db - empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateStatus.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`P1003: Database dev.db does not exist at dev.db`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-failed-migration","suites":["sqlite"],"updatePoint":{"line":32,"column":36},"line":32,"code":"  it('existing-db-1-failed-migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Following migration have failed:\n      20201231000000_failed\n\n      During development if the failed migration(s) have not been deployed to a production database you can then fix the migration(s) and run prisma migrate dev.\n\n      The failed migration(s) can be marked as rolled back or applied:\n            \n      - If you rolled back the migration(s) manually:\n      prisma migrate resolve --rolled-back \"20201231000000_failed\"\n\n      - If you fixed the database manually (hotfix):\n      prisma migrate resolve --applied \"20201231000000_failed\"\n\n      Read more about how to resolve migration issues in a production database:\n      https://pris.ly/d/migrate-resolve\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should error when database needs to be baselined","suites":["sqlite"],"updatePoint":{"line":69,"column":54},"line":69,"code":"  it('should error when database needs to be baselined', async () => {\n    ctx.fixture('baseline-sqlite')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse(['--schema=./prisma/using-file-as-url.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/using-file-as-url.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration","suites":["sqlite"],"updatePoint":{"line":95,"column":29},"line":95,"code":"  it('existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`Database schema is up to date!`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration-conflict","suites":["sqlite"],"updatePoint":{"line":111,"column":38},"line":111,"code":"  it('existing-db-1-migration-conflict', async () => {\n    ctx.fixture('existing-db-1-migration-conflict')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n      Following migration have not yet been applied:\n      20201231000000_init\n\n      To apply migrations in development run prisma migrate dev.\n      To apply migrations in production run prisma migrate deploy.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-brownfield","suites":["sqlite"],"updatePoint":{"line":137,"column":28},"line":137,"code":"  it('existing-db-brownfield', async () => {\n    ctx.fixture('existing-db-brownfield')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-warnings","suites":["sqlite"],"updatePoint":{"line":163,"column":26},"line":163,"code":"  it('existing-db-warnings', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset","suites":["sqlite"],"updatePoint":{"line":189,"column":11},"line":189,"code":"  it('reset', async () => {\n    ctx.fixture('reset')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`Database schema is up to date!`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-histories-diverge","suites":["sqlite"],"updatePoint":{"line":205,"column":35},"line":205,"code":"  it('existing-db-histories-diverge', async () => {\n    ctx.fixture('existing-db-histories-diverge')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      2 migrations found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Your local migration history and the migrations table from your database are different:\n\n      The last common migration is: 20201231000000_init\n\n      The migration have not yet been applied:\n      20201231000000_catage\n\n      The migration from the database are not found locally in prisma/migrations:\n      20201231000000_dogage\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if cannot connect","suites":["postgresql"],"updatePoint":{"line":238,"column":35},"line":238,"code":"  it('should fail if cannot connect', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateStatus.new().parse(['--schema=./prisma/invalid-url.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P1001: Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n      Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n    `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"doesnotexist:5432\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"simple schema","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('simple schema', () => {\n  const schema = `\ndatasource db {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"comments","suites":[],"updatePoint":{"line":32,"column":14},"line":32,"code":"test('comments', () => {\n  const schema = `\ndatasource db {\n// datasource db {\n  provider = \"sqlite\"\n  // provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema without datasource","suites":[],"updatePoint":{"line":63,"column":31},"line":63,"code":"test('schema without datasource', () => {\n  const schema = `\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema with multiple datasources","suites":[],"updatePoint":{"line":87,"column":38},"line":87,"code":"test('schema with multiple datasources', () => {\n  const schema = `\ndatasource db {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\ndatasource db2 {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource block not starting at the beginning of the file and not at the beginning of a line with generator should only return the generator block","suites":[],"updatePoint":{"line":121,"column":153},"line":121,"code":"test('datasource block not starting at the beginning of the file and not at the beginning of a line with generator should only return the generator block', () => {\n  const schema = `\n  datasource db {\n  provider = \"postgres\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"multiSchema\"]\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator client {\n      provider        = \"prisma-client-js\"\n      previewFeatures = [\"multiSchema\"]\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource block not starting at the beginning of a line with generator should only return the generator block","suites":[],"updatePoint":{"line":141,"column":116},"line":141,"code":"test('datasource block not starting at the beginning of a line with generator should only return the generator block', () => {\n  const schema = ` datasource db {\n  provider = \"postgres\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"multiSchema\"]\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator client {\n      provider        = \"prisma-client-js\"\n      previewFeatures = [\"multiSchema\"]\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed","suites":["applyMigrations"],"updatePoint":{"line":11,"column":20},"line":11,"code":"  it('should succeed', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.applyMigrations({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        appliedMigrationNames: [],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail on existing brownfield db","suites":["applyMigrations"],"updatePoint":{"line":27,"column":43},"line":27,"code":"  it('should fail on existing brownfield db', async () => {\n    ctx.fixture('existing-db-brownfield')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.applyMigrations({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P3005\n\n      The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline\n\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - ConnectionString - sqlite","suites":["createDatabase"],"updatePoint":{"line":46,"column":48},"line":46,"code":"  it('should succeed - ConnectionString - sqlite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const migrate = new Migrate()\n    const result = migrate.engine.createDatabase({\n      datasource: {\n        tag: 'ConnectionString',\n        url: 'file:dev.db',\n      },\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        databaseName: dev.db,\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - SchemaPath - postgresql","suites":["createDatabase"],"updatePoint":{"line":64,"column":46},"line":64,"code":"  it('should succeed - SchemaPath - postgresql', async () => {\n    ctx.fixture('schema-only')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate()\n    const result = migrate.engine.createDatabase({\n      datasource: {\n        tag: 'SchemaPath',\n        path: schemaPath,\n      },\n    })\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P1009\n\n      Database \\`tests\\` already exists on the database server at \\`localhost:5432\\`\n\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - existing-db-1-migration","suites":["createMigration"],"updatePoint":{"line":86,"column":46},"line":86,"code":"  it('should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.createMigration({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: 'my_migration',\n      draft: false,\n      prismaSchema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        generatedMigrationName: 20201231000000_my_migration,\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft should succeed - existing-db-1-migration","suites":["createMigration"],"updatePoint":{"line":106,"column":52},"line":106,"code":"  it('draft should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.createMigration({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: 'draft_123',\n      draft: true,\n      prismaSchema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        generatedMigrationName: 20201231000000_draft_123,\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - sqlite","suites":["dbExecute"],"updatePoint":{"line":128,"column":29},"line":128,"code":"  it('should succeed - sqlite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const migrate = new Migrate()\n    const result = migrate.engine.dbExecute({\n      datasourceType: {\n        tag: 'url',\n        url: 'file:dev.db',\n      },\n      script: `-- CreateTable\n      SELECT 1\n      `,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`null`)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"createMigration","suites":["devDiagnostic"],"updatePoint":{"line":147,"column":21},"line":147,"code":"  it('createMigration', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.devDiagnostic({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        action: {\n          tag: createMigration,\n        },\n      }\n    `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset because drift","suites":["devDiagnostic"],"updatePoint":{"line":165,"column":25},"line":165,"code":"  it('reset because drift', async () => {\n    ctx.fixture('existing-db-1-migration-conflict')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.devDiagnostic({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        action: {\n          reason: Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n        - _Migration\n      ,\n          tag: reset,\n        },\n      }\n    `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"optInToShadowDatabase true should succeed - existing-db-1-migration","suites":["diagnoseMigrationHistory"],"updatePoint":{"line":198,"column":73},"line":198,"code":"  it('optInToShadowDatabase true should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.diagnoseMigrationHistory({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      optInToShadowDatabase: true,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        editedMigrationNames: [],\n        failedMigrationNames: [],\n        hasMigrationsTable: true,\n        history: null,\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":" optInToShadowDatabase false should succeed - existing-db-1-migration","suites":["diagnoseMigrationHistory"],"updatePoint":{"line":218,"column":75},"line":218,"code":"  it(' optInToShadowDatabase false should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.diagnoseMigrationHistory({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      optInToShadowDatabase: false,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        editedMigrationNames: [],\n        failedMigrationNames: [],\n        hasMigrationsTable: true,\n        history: null,\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when database exists - SQLite","suites":["ensureConnectionValidity"],"updatePoint":{"line":240,"column":50},"line":240,"code":"  it('should succeed when database exists - SQLite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    ctx.fs.write('dev.db', '')\n    const migrate = new Migrate()\n    const result = migrate.engine.ensureConnectionValidity({\n      datasource: {\n        tag: 'ConnectionString',\n        url: 'file:dev.db',\n      },\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`{}`)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when database exists - PostgreSQL","suites":["ensureConnectionValidity"],"updatePoint":{"line":255,"column":54},"line":255,"code":"  it('should succeed when database exists - PostgreSQL', async () => {\n    ctx.fixture('schema-only')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate()\n    const result = migrate.engine.ensureConnectionValidity({\n      datasource: {\n        tag: 'SchemaPath',\n        path: schemaPath,\n      },\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`{}`)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when database does not exist - SQLite","suites":["ensureConnectionValidity"],"updatePoint":{"line":270,"column":55},"line":270,"code":"  it('should fail when database does not exist - SQLite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const migrate = new Migrate()\n    const result = migrate.engine.ensureConnectionValidity({\n      datasource: {\n        tag: 'ConnectionString',\n        url: 'file:dev.db',\n      },\n    })\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P1003\n\n      Database dev.db does not exist at dev.db\n\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when server does not exist - PostgreSQL","suites":["ensureConnectionValidity"],"updatePoint":{"line":289,"column":57},"line":289,"code":"  it('should fail when server does not exist - PostgreSQL', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const migrate = new Migrate()\n    const result = migrate.engine.ensureConnectionValidity({\n      datasource: {\n        tag: 'ConnectionString',\n        url: 'postgresql://server-does-not-exist:5432/db-does-not-exist',\n      },\n    })\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P1001\n\n      Can't reach database server at \\`server-does-not-exist\\`:\\`5432\\`\n\n      Please make sure your database server is running at \\`server-does-not-exist\\`:\\`5432\\`.\n\n    `)\n    migrate.stop()\n    // It was flaky on CI (but rare)\n    // higher timeout might help\n  }, 10_000)","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - schema-only-sqlite","suites":["evaluateDataLoss"],"updatePoint":{"line":315,"column":41},"line":315,"code":"  it('should succeed - schema-only-sqlite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.evaluateDataLoss({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      prismaSchema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        migrationSteps: 1,\n        unexecutableSteps: [],\n        warnings: [],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - existing-db-1-migration","suites":["evaluateDataLoss"],"updatePoint":{"line":336,"column":46},"line":336,"code":"  it('should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.evaluateDataLoss({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      prismaSchema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        migrationSteps: 0,\n        unexecutableSteps: [],\n        warnings: [],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"[No params] should succeed","suites":["getDatabaseVersion - PostgreSQL"],"updatePoint":{"line":358,"column":32},"line":358,"code":"  it('[No params] should succeed', async () => {\n    ctx.fixture('schema-only')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.getDatabaseVersion()\n    await expect(result).resolves.toContain('PostgreSQL')\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"[SchemaPath] should succeed","suites":["getDatabaseVersion - PostgreSQL"],"updatePoint":{"line":367,"column":33},"line":367,"code":"  it('[SchemaPath] should succeed', async () => {\n    ctx.fixture('schema-only')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate()\n    const result = migrate.engine.getDatabaseVersion({\n      datasource: {\n        tag: 'SchemaPath',\n        path: schemaPath,\n      },\n    })\n    await expect(result).resolves.toContain('PostgreSQL')\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"[SchemaString] should succeed","suites":["getDatabaseVersion - PostgreSQL"],"updatePoint":{"line":381,"column":35},"line":381,"code":"  it('[SchemaString] should succeed', async () => {\n    ctx.fixture('schema-only')\n    const schemaPath = (await getSchemaPath())!\n    const schema = (await fs.readAsync(schemaPath))!\n    const migrate = new Migrate()\n    const result = migrate.engine.getDatabaseVersion({\n      datasource: {\n        tag: 'SchemaString',\n        schema,\n      },\n    })\n    await expect(result).resolves.toContain('PostgreSQL')\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"[ConnectionString] should succeed","suites":["getDatabaseVersion - PostgreSQL"],"updatePoint":{"line":396,"column":39},"line":396,"code":"  it('[ConnectionString] should succeed', async () => {\n    const migrate = new Migrate()\n    const result = migrate.engine.getDatabaseVersion({\n      datasource: {\n        tag: 'ConnectionString',\n        url: process.env.TEST_POSTGRES_URI!,\n      },\n    })\n    await expect(result).resolves.toContain('PostgreSQL')\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - existing-db-1-migration","suites":["listMigrationDirectories"],"updatePoint":{"line":410,"column":46},"line":410,"code":"  it('should succeed - existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.listMigrationDirectories({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        migrations: [\n          20201231000000_init,\n        ],\n      }\n    `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed - schema-only-sqlite","suites":["listMigrationDirectories"],"updatePoint":{"line":428,"column":41},"line":428,"code":"  it('should succeed - schema-only-sqlite', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const result = migrate.engine.listMigrationDirectories({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        migrations: [],\n      }\n    `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail - existing-db-1-migration","suites":["markMigrationRolledBack"],"updatePoint":{"line":446,"column":43},"line":446,"code":"  it('should fail - existing-db-1-migration', async () => {\n    jest.setTimeout(10_000)\n    ctx.fixture('existing-db-1-migration')\n\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n\n    const resultMarkRolledBacked = migrate.engine.markMigrationRolledBack({\n      migrationName: '20201014154943_init',\n    })\n\n    await expect(resultMarkRolledBacked).rejects.toMatchInlineSnapshot(`\n          P3012\n\n          Migration \\`20201231000000_init\\` cannot be rolled back because it is not in a failed state.\n\n        `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration","suites":["markMigrationRolledBack"],"updatePoint":{"line":467,"column":29},"line":467,"code":"  it('existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = await migrate.engine.createMigration({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: 'draft_123',\n      draft: true,\n      prismaSchema: schema,\n    })\n\n    expect(result).toMatchInlineSnapshot(`\n      {\n        generatedMigrationName: 20201231000000_draft_123,\n      }\n    `)\n\n    fs.write(\n      path.join(migrate.migrationsDirectoryPath!, result.generatedMigrationName!, 'migration.sql'),\n      'SELECT SOMETHING_THAT_DOES_NOT_WORK',\n    )\n\n    try {\n      await migrate.engine.applyMigrations({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      })\n    } catch (e) {\n      expect(e.message).toContain('no such column: SOMETHING_THAT_DOES_NOT_WORK')\n    }\n\n    const resultMarkRolledBacked = migrate.engine.markMigrationRolledBack({\n      migrationName: result.generatedMigrationName!,\n    })\n\n    await expect(resultMarkRolledBacked).resolves.toMatchSnapshot()\n\n    const resultMarkAppliedFailed = migrate.engine.markMigrationApplied({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: result.generatedMigrationName!,\n    })\n\n    await expect(resultMarkAppliedFailed).resolves.toMatchSnapshot()\n\n    const resultMarkApplied = migrate.engine.markMigrationApplied({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: result.generatedMigrationName!,\n    })\n\n    await expect(resultMarkApplied).rejects.toMatchInlineSnapshot(`\n          P3008\n\n          The migration \\`20201231000000_draft_123\\` is already recorded as applied in the database.\n\n        `)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration","suites":["markMigrationApplied"],"updatePoint":{"line":528,"column":29},"line":528,"code":"  it('existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = await migrate.engine.createMigration({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: 'draft_123',\n      draft: true,\n      prismaSchema: schema,\n    })\n\n    expect(result).toMatchInlineSnapshot(`\n      {\n        generatedMigrationName: 20201231000000_draft_123,\n      }\n    `)\n\n    const resultMarkApplied = migrate.engine.markMigrationApplied({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n      migrationName: result.generatedMigrationName!,\n    })\n\n    await expect(resultMarkApplied).resolves.toMatchInlineSnapshot(`{}`)\n\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed if SQLite database file is missing","suites":["schemaPush"],"updatePoint":{"line":560,"column":55},"line":560,"code":"  it('should succeed if SQLite database file is missing', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.schemaPush({\n      force: false,\n      schema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        executedSteps: 1,\n        unexecutable: [],\n        warnings: [],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed without warning","suites":["schemaPush"],"updatePoint":{"line":580,"column":36},"line":580,"code":"  it('should succeed without warning', async () => {\n    ctx.fixture('existing-db-1-draft')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n    const result = migrate.engine.schemaPush({\n      force: false,\n      schema: schema,\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        executedSteps: 1,\n        unexecutable: [],\n        warnings: [],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should return executedSteps 0 with warning if dataloss detected","suites":["schemaPush"],"updatePoint":{"line":600,"column":69},"line":600,"code":"  it('should return executedSteps 0 with warning if dataloss detected', async () => {\n    ctx.fixture('existing-db-brownfield')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n\n    const result = migrate.engine.schemaPush({\n      force: false,\n      schema: schema.replace('Blog', 'Something'),\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        executedSteps: 0,\n        unexecutable: [],\n        warnings: [\n          You are about to drop the \\`Blog\\` table, which is not empty (1 rows).,\n        ],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"force should accept dataloss","suites":["schemaPush"],"updatePoint":{"line":623,"column":34},"line":623,"code":"  it('force should accept dataloss', async () => {\n    ctx.fixture('existing-db-brownfield')\n    const schemaPath = (await getSchemaPath())!\n    const migrate = new Migrate(schemaPath)\n    const schema = migrate.getPrismaSchema()\n\n    const result = migrate.engine.schemaPush({\n      force: true,\n      schema: schema.replace('Blog', 'Something'),\n    })\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n      {\n        executedSteps: 2,\n        unexecutable: [],\n        warnings: [\n          You are about to drop the \\`Blog\\` table, which is not empty (1 rows).,\n        ],\n      }\n    `)\n    migrate.stop()\n  })","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"}]}