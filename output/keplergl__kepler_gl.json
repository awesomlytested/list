{"repo":"keplergl/kepler.gl","url":"https://github.com/keplergl/kepler.gl","branch":"master","configs":[{"package":"kepler.gl","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"MapContainerFactory - display all options","suites":[],"updatePoint":{"line":34,"column":47,"index":1918},"line":34,"code":"test('MapContainerFactory - display all options', t => {\n  const onMapStyleLoaded = sinon.spy();\n  const onLayerClick = sinon.spy();\n  const props = {\n    ...initialProps,\n    mapStyle: {\n      bottomMapStyle: {\n        layers: [],\n        name: 'foo'\n      },\n      visibleLayerGroups: {}\n    },\n    onMapStyleLoaded,\n    visStateActions: {\n      ...initialProps.visStateActions,\n      onLayerClick\n    },\n    mapboxApiAccessToken: 'pyx-11'\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, props)));\n  }, 'MapContainer should not fail');\n  t.equal(wrapper.find(MapControl).length, 1, 'Should display 1 MapControl');\n  t.equal(wrapper.find(StaticMap).length, 1, 'Should display 1 InteractiveMap');\n  // Can't test overlay because mapboxgl is not supported in chromium\n  t.equal(wrapper.find('Attribution').length, 1, 'Should display 1 Attribution');\n  const instance = wrapper.find('MapContainer').instance();\n  instance._onMapboxStyleUpdate();\n  t.equal(onMapStyleLoaded.called, true, 'Should be calling onMapStyleLoaded');\n  instance._onCloseMapPopover();\n  t.equal(onLayerClick.called, true, 'Should be calling onLayerClick');\n  t.end();\n});","file":"browser-headless/component/map-container-test.js","skipped":false,"dir":"test"},{"name":"MapContainerFactory - _renderDeckOverlay","suites":[],"updatePoint":{"line":68,"column":46,"index":3187},"line":68,"code":"test('MapContainerFactory - _renderDeckOverlay', t => {\n  const props = {\n    ...initialProps,\n    mapboxApiAccessToken: 'pyx-11'\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, props)));\n  }, 'MapContainer should not fail');\n  const instance = wrapper.find('MapContainer').instance();\n  const _renderDeckOverlay = sinon.spy(instance, '_renderDeckOverlay');\n  instance.forceUpdate();\n  wrapper.update();\n  t.ok(_renderDeckOverlay.calledOnce, '_renderDeckOverlay be called once');\n  const args = _renderDeckOverlay.args[0];\n  _renderDeckOverlay.restore();\n\n  // Getting the DeckGl instance\n  const divWrapper = instance._renderDeckOverlay(...args);\n  const DeckGl = divWrapper.props.children;\n  const clickEvents = [];\n  const hoverEvents = [];\n  function onBeforeEvents() {\n    // reset logs\n    clickEvents.length = 0;\n    hoverEvents.length = 0;\n  }\n  const expectedCoordinate = [31.21911171679643, 30.040037294002644];\n  const expectedInfo = {\n    color: {\n      0: 16,\n      1: 0,\n      2: 0,\n      3: 1\n    },\n    coordinate: expectedCoordinate,\n    index: 15,\n    // layer: {}, only test id\n    // object: {data: allData[15], position: [], index: 15}, // test seperately\n    picked: true,\n    pixel: [192, 187],\n    // viewport: {}, // not tested\n    x: 192,\n    y: 187\n  };\n  const testCase = {\n    title: 'Picking',\n    props: {\n      ...DeckGl.props,\n      gl,\n      width: 800,\n      height: 800,\n      onClick: (info, event) => clickEvents.push({\n        info,\n        event\n      }),\n      onHover: (info, event) => {\n        info.mapIndex = 0;\n        hoverEvents.push({\n          info,\n          event\n        });\n      }\n    },\n    getTestCases: assert => [{\n      name: 'hover',\n      events: [{\n        type: 'mousemove',\n        x: 200,\n        y: 200\n      }, {\n        wait: 50\n      }],\n      onBeforeEvents,\n      // eslint-disable-next-line max-statements\n      onAfterEvents: ({\n        deck,\n        layers\n      }) => {\n        assert.is(hoverEvents.length, 1, 'onHover is called');\n        assert.is(hoverEvents[0].info.index, 15, 'object is picked');\n        assert.is(hoverEvents[0].info.picked, true, 'object is picked');\n        assert.is(hoverEvents[0].info.mapIndex, 0, 'onHover includes mapIndex value');\n        assert.deepEqual(layers[0].state.model.getUniforms().picking_uSelectedColor, [16, 0, 0], 'autoHighlight parameter is set');\n        [(\n        // test picking info\n        'color', 'coordinate', 'pixel', 'x', 'y')].forEach(key => {\n          assert.deepEqual(hoverEvents[0].info[key], expectedInfo[key], `picking info.${key} should be correct`);\n        });\n\n        // test picking info.object\n        t.ok(hoverEvents[0].info.object, 'should have info.object');\n        t.deepEqual(hoverEvents[0].info.object, props.visState.layerData[0].data[15], 'object should be layer data');\n        t.is(hoverEvents[0].info.layer.id, props.visState.layers[0].id, 'layer id should be correct');\n\n        // asign info object to to state and test map popover\n        const propsWithHoverInfo = {\n          ...initialProps,\n          visState: {\n            ...initialProps.visState,\n            hoverInfo: hoverEvents[0].info,\n            mousePos: {\n              ...initialProps.visState.mousePos,\n              coordinate: expectedCoordinate,\n              mousePosition: [200, 200]\n            }\n          }\n        };\n        t.doesNotThrow(() => {\n          wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, propsWithHoverInfo)));\n        }, 'render map container with map popover should not fail');\n        t.equal(wrapper.find(MapPopover).length, 1, 'should render 1 MapPopover');\n        const mapPopoverProps = wrapper.find(MapPopover).at(0).props();\n\n        // test MapPopoverProp\n        testMapPopoverProp(t, mapPopoverProps);\n        // map control and map popover both uses Tippy\n        t.equal(wrapper.find(Tippy).length, 2, 'should render Tippy');\n        t.equal(wrapper.find('table').length, 1, 'should render 1 table');\n        const table = wrapper.find('table').at(0);\n        const rows = table.find('.layer-hover-info__row');\n        t.equal(rows.length, 5, 'should render 5 rows');\n        const tippyProps = wrapper.find(Tippy).at(1).props();\n        const expectedClientRect = {\n          bottom: 200,\n          height: 0,\n          left: 200,\n          right: 200,\n          top: 200,\n          width: 0,\n          y: 200,\n          x: 200\n        };\n        const rect = tippyProps.getReferenceClientRect();\n        delete rect.toJSON;\n        t.deepEqual(rect, expectedClientRect, 'getReferenceClientRect should return correct rect');\n        const expectedTooltips = [['gps_data.utc_timestamp', '2016-09-17 00:24:24'], ['gps_data.types', 'driver_analytics'], ['epoch', '1472754400000'], ['has_result', ''], ['uid', '1']];\n        for (let i = 0; i < 5; i++) {\n          t.equal(rows.at(i).find('.row__name').text(), expectedTooltips[i][0], 'row name should be correct');\n          t.equal(rows.at(i).find('.row__value').text(), expectedTooltips[i][1], 'row value should be correct');\n        }\n      }\n    }]\n  };\n  new InteractionTestRunner(testCase.props).add(testCase.getTestCases(t)).run({\n    onTestStart: tc => t.comment(tc.name)\n  }).then(() => t.end());\n});","file":"browser-headless/component/map-container-test.js","skipped":false,"dir":"test"},{"name":"Components -> BottomWidget.mount -> initial state","suites":[],"updatePoint":{"line":44,"column":55,"index":2087},"line":44,"code":"test('Components -> BottomWidget.mount -> initial state', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(BottomWidget, defaultProps)));\n  }, 'BottomWidget should not fail without props');\n  t.equal(wrapper.find(TimeWidget).length, 0, 'should not render');\n  t.equal(wrapper.find(AnimationControl).length, 0, 'should not render');\n  t.end();\n});","file":"browser/components/bottom-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> AnimationControl.render","suites":[],"updatePoint":{"line":34,"column":43,"index":1947},"line":34,"code":"test('Components -> AnimationControl.render', t => {\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(AnimationControl, null));\n  }, 'Should not fail without props');\n  t.end();\n});","file":"browser/components/common/animation-control-test.js","skipped":false,"dir":"test"},{"name":"Components -> AnimationControl -> render with props","suites":[],"updatePoint":{"line":40,"column":57,"index":2172},"line":40,"code":"test('Components -> AnimationControl -> render with props', t => {\n  let wrapper;\n  const toggleAnimation = sinon.spy();\n  const setLayerAnimationTime = sinon.spy();\n  const timeline = getTimelineFromAnimationConfig(StateWTripGeojson.visState.animationConfig);\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(AnimationControl, {\n      isAnimatable: true,\n      setTimelineValue: setLayerAnimationTime,\n      toggleAnimation: toggleAnimation,\n      timeline: timeline\n    }));\n  }, 'Should not fail with trip layer props');\n  t.equal(wrapper.find('.animation-window-control').length, 0, 'should not render AnimationWindowControl');\n  t.ok(wrapper.find(PlaybackControls), 'should render PlaybackControls');\n  t.ok(wrapper.find(FloatingTimeDisplay), 'should render FloatingTimeDisplay');\n  wrapper.find(IconButton).at(0).simulate('click');\n  t.ok(toggleAnimation.calledOnce, 'should call toggleAnimation');\n  t.end();\n});","file":"browser/components/common/animation-control-test.js","skipped":false,"dir":"test"},{"name":"Components -> AnimationControl -> time display","suites":[],"updatePoint":{"line":60,"column":52,"index":3126},"line":60,"code":"test('Components -> AnimationControl -> time display', t => {\n  let wrapper;\n  const timeline = getTimelineFromAnimationConfig(StateWTripGeojson.visState.animationConfig);\n  // because we are using locale based formats, we set a locale here to make sure\n  // result are always the same\n  moment.locale('en');\n  const toggleAnimation = () => {};\n  const setLayerAnimationTime = () => {};\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(AnimationControl, {\n      isAnimatable: true,\n      setTimelineValue: setLayerAnimationTime,\n      toggleAnimation: toggleAnimation,\n      timeline: timeline\n    }));\n  }, 'Should not fail with props');\n  const timeDisplay = wrapper.find(FloatingTimeDisplay);\n  const timeDomainStart = wrapper.find('.animation-control__time-domain.domain-start');\n  const timeDomainEnd = wrapper.find('.animation-control__time-domain.domain-end');\n  t.equal(timeDisplay.length, 1, 'should render FloatingTimeDisplay');\n  t.equal(timeDomainStart.length, 1, 'should render timeDomainStart');\n  t.equal(timeDomainEnd.length, 1, 'should render timeDomainEnd');\n  t.equal(timeDomainStart.find('span').at(0).text(), '08/12/2019 2:34:21 AM', 'should render current domain start');\n  t.equal(timeDomainEnd.find('span').at(0).text(), '08/12/2019 3:00:36 AM', 'should render current domain end');\n  t.equal(timeDisplay.find('.animation-control__time-display__top').length, 1, 'should render 1 top row time');\n  t.equal(timeDisplay.find('.animation-control__time-display__top').at(0).find('.time-value').text(), '08/12/2019', 'should render correct date');\n  t.equal(timeDisplay.find('.animation-control__time-display__bottom').length, 1, 'should render 1 top row time');\n  t.equal(timeDisplay.find('.animation-control__time-display__bottom').at(0).find('.time-value').text(), '2:34:21 AM', 'should render correct time');\n  t.end();\n});","file":"browser/components/common/animation-control-test.js","skipped":false,"dir":"test"},{"name":"Components -> AnimationControl -> time display -> custom timezone and timeFormat","suites":[],"updatePoint":{"line":90,"column":86,"index":5045},"line":90,"code":"test('Components -> AnimationControl -> time display -> custom timezone and timeFormat', t => {\n  let wrapper;\n  const nextState = reducer(StateWTripGeojson.visState, setLayerAnimationTimeConfig({\n    timezone: 'America/New_York',\n    timeFormat: 'YYYY MMM DD hh:mm'\n  }));\n  const timeline = getTimelineFromAnimationConfig(nextState.animationConfig);\n  const toggleAnimation = () => {};\n  const setLayerAnimationTime = () => {};\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(AnimationControl, {\n      isAnimatable: true,\n      setTimelineValue: setLayerAnimationTime,\n      toggleAnimation: toggleAnimation,\n      timeline: timeline\n    }));\n  }, 'Should not fail with props');\n  const timeDisplay = wrapper.find(FloatingTimeDisplay);\n  const timeDomainStart = wrapper.find('.animation-control__time-domain.domain-start');\n  const timeDomainEnd = wrapper.find('.animation-control__time-domain.domain-end');\n  t.equal(timeDisplay.length, 1, 'should render FloatingTimeDisplay');\n  t.equal(timeDomainStart.length, 1, 'should render timeDomainStart');\n  t.equal(timeDomainEnd.length, 1, 'should render timeDomainEnd');\n  t.equal(timeDomainStart.find('span').at(0).text(), '2019 Aug 11 10:34', 'should render current domain start');\n  t.equal(timeDomainEnd.find('span').at(0).text(), '2019 Aug 11 11:00', 'should render current domain end');\n  t.equal(timeDisplay.find('.animation-control__time-display__bottom').length, 1, 'should render 1 bottom row time');\n  t.equal(timeDisplay.find('.animation-control__time-display__bottom').at(0).find('.time-value').text(), '2019 Aug 11 10:34', 'should render correct date');\n  t.equal(timeDisplay.find('.animation-control__time-display__top').length, 0, 'should render 0 bottom row');\n  t.end();\n});","file":"browser/components/common/animation-control-test.js","skipped":false,"dir":"test"},{"name":"Components -> ColorLegend.render","suites":[],"updatePoint":{"line":25,"column":38,"index":1340},"line":25,"code":"test('Components -> ColorLegend.render', t => {\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, null));\n  }, 'Show not fail without props');\n  const width = 180;\n  const fieldType = 'real';\n  const domain = [0, 20];\n  const scaleType = 'quantize';\n  const range = {\n    colors: ['#5A1846', '#900C3F', '#C70039', '#E3611C', '#F1920E', '#FFC300']\n  };\n  const displayLabel = true;\n  const props = {\n    scaleType,\n    displayLabel,\n    domain,\n    fieldType,\n    range,\n    width\n  };\n  let wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  t.equal(wrapper.find(LegendRow).length, 6, 'Should render 6 legends');\n  const row1 = wrapper.find(LegendRow).at(0).find('rect').at(0).html();\n  t.ok(row1.indexOf('fill: #5A1846'), 'should render color rect');\n  props.scaleType = 'quantile';\n  wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  t.equal(wrapper.find(LegendRow).length, 6, 'Should render 6 legends');\n  props.scaleType = 'log';\n  wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  t.equal(wrapper.find(LegendRow).length, 0, 'Should render 0 legends');\n  props.displayLabel = false;\n  props.scaleType = 'quantile';\n  wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  const row1Txt = wrapper.find(LegendRow).at(0).find('text').at(0).text();\n  t.equal(row1Txt, '', 'should not render text');\n  t.end();\n});","file":"browser/components/common/color-legend-test.js","skipped":false,"dir":"test"},{"name":"Components -> ColorLegend.render","suites":[],"updatePoint":{"line":62,"column":38,"index":2821},"line":62,"code":"test('Components -> ColorLegend.render', t => {\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, null));\n  }, 'Show not fail without props');\n  const width = 180;\n  const range = {\n    colorMap: [['apple', '#C1C9CC'], ['pear', '#DFB02F'], ['car', '#7F8120'], ['dog', '#DCD0A4'], ['chicken', '#AD5633']]\n  };\n  const props = {\n    displayLabel: true,\n    range,\n    width\n  };\n  let wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  t.equal(wrapper.find(LegendRow).length, 5, 'Should render 5 legends');\n  let row1 = wrapper.find(LegendRow).at(0).find('rect').at(0).html();\n  t.ok(row1.indexOf('fill: #C1C9CC'), 'should render color rect based on colorMap');\n  t.ok(row1.indexOf('apple'), 'should render color text based on colorMap');\n  props.range = {\n    colorLegends: {\n      '#DFB02F': 'Apple',\n      '#7F8120': 'Pear',\n      '#DCD0A4': 'Car',\n      '#AD5633': 'Dog',\n      '#C1C9CC': 'Chicken'\n    }\n  };\n  wrapper = mountWithTheme( /*#__PURE__*/React.createElement(ColorLegend, props));\n  t.equal(wrapper.find(LegendRow).length, 5, 'Should render 5 legends');\n  row1 = wrapper.find(LegendRow).at(0).find('rect').at(0).html();\n  t.ok(row1.indexOf('fill: #DFB02F'), 'should render color rect based on colorMap');\n  t.ok(row1.indexOf('Apple'), 'should render color text based on colorMap');\n  t.end();\n});","file":"browser/components/common/color-legend-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUploader.render","suites":[],"updatePoint":{"line":26,"column":39,"index":1405},"line":26,"code":"test('Components -> FileUploader.render', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, null)));\n  }, 'Show not fail without data');\n  t.equal(wrapper.find(FileDrop).length, 1, 'should render FileUploader');\n  t.equal(wrapper.find(UploadButton).length, 1, 'should render UploadButton');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUpload.onDrop","suites":[],"updatePoint":{"line":35,"column":37,"index":1833},"line":35,"code":"test('Components -> FileUpload.onDrop', t => {\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'tst-file.csv'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const stopPropagation = sinon.spy();\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    onFileUpload: onFileUpload,\n    fileExtensions: ['csv']\n  })));\n  t.equal(wrapper.find(FileDrop).length, 1, 'should render FileUploader');\n  const FileDropDiv = wrapper.find('.file-uploader__file-drop').at(0);\n  // mock file drop event\n  const mockEvent = {\n    stopPropagation,\n    dataTransfer: {\n      types: ['Files'],\n      files: mockFiles\n    }\n  };\n  FileDropDiv.simulate('drop', mockEvent);\n  t.ok(onFileUpload.called, 'onFileUpload should get called');\n  t.ok(stopPropagation.called, 'stopPropagation should get called');\n  const files = wrapper.find(FileUpload).children().first().state().files;\n  t.deepEqual(files, mockFiles, 'should set files to state');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUpload.onDrop -> render loading msg","suites":[],"updatePoint":{"line":65,"column":59,"index":2958},"line":65,"code":"test('Components -> FileUpload.onDrop -> render loading msg', t => {\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'tst-file.csv'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const mockFileProgress = {\n    'tst-file.csv': {\n      fileName: 'tst-file.csv',\n      percent: 1,\n      message: 'Done'\n    }\n  };\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    fileExtensions: ['csv', 'json', 'geojson'],\n    onFileUpload: onFileUpload,\n    fileLoading: {\n      fileCache: [],\n      filesToLoad: [],\n      onFinish: () => {}\n    },\n    fileLoadingProgress: mockFileProgress\n  })));\n  const FileDropDiv = wrapper.find('.file-uploader__file-drop').at(0);\n  // mock file drop event\n  const mockEvent = {\n    stopPropagation: () => {},\n    dataTransfer: {\n      types: ['Files'],\n      files: mockFiles\n    }\n  };\n  FileDropDiv.simulate('drop', mockEvent);\n  t.ok(onFileUpload.called, 'onFileUpload should get called');\n  const uploadMsg = wrapper.find('.file-upload-progress__message').at(0).html();\n  t.comment(uploadMsg);\n  t.ok(uploadMsg.includes('tst-file.csv', 'should render upload file msg'));\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUpload.onDrop -> render error msg","suites":[],"updatePoint":{"line":106,"column":57,"index":4244},"line":106,"code":"test('Components -> FileUpload.onDrop -> render error msg', t => {\n  const mockFiles = [{\n    type: 'png',\n    name: 'tst-file.png'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    onFileUpload: onFileUpload\n  })));\n  const FileDropDiv = wrapper.find('.file-uploader__file-drop').at(0);\n  // mock file drop event\n  const mockEvent = {\n    stopPropagation: () => {},\n    dataTransfer: {\n      types: ['Files'],\n      files: mockFiles\n    }\n  };\n  FileDropDiv.simulate('drop', mockEvent);\n  t.ok(onFileUpload.notCalled, 'onFileUpload should not get called');\n  t.ok(wrapper.find(WarningMsg), 'should render WarningMsg');\n  const errorFiles = wrapper.find(FileUpload).children().first().state().errorFiles;\n  t.deepEqual(errorFiles, ['tst-file.png'], 'should save files to errorFiles');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUpload.dragOver","suites":[],"updatePoint":{"line":133,"column":39,"index":5239},"line":133,"code":"test('Components -> FileUpload.dragOver', t => {\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'tst-file.csv'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    onFileUpload: onFileUpload\n  })));\n  t.equal(wrapper.find(FileDrop).length, 1, 'should render FileUploader');\n  const FileDropDiv = wrapper.find('.file-uploader__file-drop').at(0);\n  // mock file drop event\n  const mockEvent = {\n    dataTransfer: {\n      types: ['Files'],\n      files: mockFiles\n    }\n  };\n  FileDropDiv.simulate('dragover', mockEvent);\n  const dragOver = wrapper.find(FileUpload).children().first().state().dragOver;\n  t.ok(dragOver, 'dragOver should be set to true');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> FileUpload.dragLeave","suites":[],"updatePoint":{"line":158,"column":40,"index":6124},"line":158,"code":"test('Components -> FileUpload.dragLeave', t => {\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'tst-file.csv'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    onFileUpload: onFileUpload\n  })));\n  t.equal(wrapper.find(FileDrop).length, 1, 'should render FileUploader');\n  const FileDropDiv = wrapper.find('.file-uploader__file-drop').at(0);\n  // mock file drop event\n  const mockEvent = {\n    dataTransfer: {\n      types: ['Files'],\n      files: mockFiles\n    }\n  };\n  FileDropDiv.simulate('dragleave', mockEvent);\n  const dragOver = wrapper.find(FileUpload).children().first().state().dragOver;\n  t.notOk(dragOver, 'dragOver should be set to false');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> UploadButton fileInput","suites":[],"updatePoint":{"line":183,"column":42,"index":7016},"line":183,"code":"test('Components -> UploadButton fileInput', t => {\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'tst-file.csv'\n  }];\n  const onFileUpload = sinon.spy(arg => {\n    t.deepEqual(arg, mockFiles, 'should call onFileUpload with files');\n  });\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FileUpload, {\n    onFileUpload: onFileUpload,\n    fileExtensions: ['csv']\n  })));\n  const uploadButton = wrapper.find(UploadButton);\n  t.equal(uploadButton.length, 1, 'should render UploadButton');\n  const input = uploadButton.find('input');\n\n  // simulate click\n  uploadButton.find('.file-upload__upload-button-span').simulate('click');\n\n  // mock file drop event\n  const mockEvent = {\n    target: {\n      files: mockFiles\n    }\n  };\n\n  // change iwthout file?\n  input.simulate('change', {\n    target: {\n      files: null\n    }\n  });\n  t.ok(onFileUpload.notCalled, 'onFileUpload should not get called');\n  input.simulate('change', mockEvent);\n  t.ok(onFileUpload.called, 'onFileUpload should get called');\n  const files = wrapper.find(FileUpload).children().first().state().files;\n  t.deepEqual(files, mockFiles, 'should set files to state');\n  t.end();\n});","file":"browser/components/common/file-uploader-test.js","skipped":false,"dir":"test"},{"name":"Components -> ItemSelector.render","suites":[],"updatePoint":{"line":26,"column":39,"index":1406},"line":26,"code":"test('Components -> ItemSelector.render', t => {\n  let wrapper;\n  const onChange = sinon.spy();\n  const props = {\n    selectedItems: 'normal',\n    options: ['additive', 'normal', 'subtractive'],\n    multiSelect: false,\n    searchable: false,\n    onChange\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ItemSelector, props)));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find('.item-selector__dropdown').length, 1, 'should render DropdownSelect');\n  t.equal(wrapper.find(Typeahead).length, 0, 'should not render Typeahead');\n  t.equal(wrapper.find('.item-selector__dropdown').at(0).find('.list__item__anchor').text(), 'normal', 'should render selected value');\n\n  // click dropdown select\n  wrapper.find('.item-selector__dropdown').at(0).simulate('click');\n  t.equal(wrapper.find(Typeahead).length, 1, 'should render Typeahead');\n  t.equal(wrapper.find(DropdownList).length, 1, 'should render 1 Typeahead');\n  t.equal(wrapper.find(DropdownList).at(0).find(ListItem).length, 3, 'should render 3 ListItem');\n  t.equal(wrapper.find(DropdownList).at(0).find('.list__item__anchor').at(0).text(), 'additive', 'should render additive');\n  wrapper.find(DropdownList).at(0).find('.list__item').at(0).simulate('click');\n  t.deepEqual(onChange.args[0], ['additive'], 'should call additive');\n  t.end();\n});","file":"browser/components/common/item-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> ItemSelector.render over 100 options","suites":[],"updatePoint":{"line":53,"column":56,"index":2827},"line":53,"code":"test('Components -> ItemSelector.render over 100 options', t => {\n  let wrapper;\n  const onChange = sinon.spy();\n  const randomOptions = Array.from({\n    length: 120\n  }, () => Math.random().toString(16).substr(2, 8));\n  const props = {\n    selectedItems: '',\n    options: randomOptions,\n    multiSelect: false,\n    searchable: false,\n    onChange\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ItemSelector, props)));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find('.item-selector__dropdown').length, 1, 'should render DropdownSelect');\n  t.equal(wrapper.find(Typeahead).length, 0, 'should not render Typeahead');\n  t.equal(wrapper.find('.item-selector__dropdown').at(0).find('.list__item__anchor').text(), '', 'should render no select value');\n\n  // click dropdown select\n  wrapper.find('.item-selector__dropdown').at(0).simulate('click');\n  t.equal(wrapper.find(Typeahead).length, 1, 'should render Typeahead');\n  t.equal(wrapper.find(DropdownList).length, 1, 'should render 1 Typeahead');\n  t.equal(wrapper.find(DropdownList).at(0).find(ListItem).length, 100, 'should render first 100 ListItem');\n\n  // mockup scroll by triggering handleObserver() of IntersectionObserver\n  const mockedEntries = [{\n    isIntersecting: true,\n    boundingClientRect: {\n      x: 77,\n      y: 77,\n      width: 231,\n      height: 0,\n      top: 777,\n      right: 308,\n      bottom: 777,\n      left: 77\n    }\n  }];\n  const dropdown = wrapper.find(DropdownList).instance();\n  dropdown.prevY = 100;\n  dropdown.handleObserver(mockedEntries);\n  // update component\n  wrapper.update();\n  t.equal(wrapper.find(DropdownList).at(0).find(ListItem).length, 120, 'should render all 120 ListItem');\n\n  // mockup scroll again\n  dropdown.prevY = 110;\n  dropdown.handleObserver(mockedEntries);\n  wrapper.update();\n  t.equal(wrapper.find(DropdownList).at(0).find(ListItem).length, 120, 'should still render all 120 ListItem');\n  t.end();\n});","file":"browser/components/common/item-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> RangePlot.render","suites":[],"updatePoint":{"line":27,"column":36,"index":1434},"line":27,"code":"test('Components -> RangePlot.render', t => {\n  const props = {\n    histogram: [],\n    isEnlarged: true,\n    isRanged: true,\n    onBrush: () => {},\n    plotType: 'histogram',\n    range: [1421315219000, 1421348744000],\n    value: [1421315219000, 1421348744000],\n    width: 137\n  };\n  t.doesNotThrow(() => {\n    const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(RangePlot, props));\n  }, 'Show not fail without histogram');\n\n  // cant test D3 in jsDom for now\n  // props.histogram = [\n  //   {count: 20, x0: 1421315219000, x1: 1421315500000},\n  //   {count: 0, x0: 1421315500000, x1: 1421316000000},\n  //   {count: 0, x0: 1421316000000, x1: 1421316500000},\n  //   {count: 0, x0: 1421316500000, x1: 1421317000000},\n  //   {count: 0, x0: 1421317000000, x1: 1421317500000},\n  //   {count: 21, x0: 1421317500000, x1: 1421318000000}\n  // ];\n\n  t.doesNotThrow(() => {\n    const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(RangePlot, props));\n  }, 'Show not fail render histogram');\n  t.end();\n});","file":"browser/components/common/range-plot-test.js","skipped":false,"dir":"test"},{"name":"Components -> RangeSlider.render","suites":[],"updatePoint":{"line":25,"column":38,"index":1381},"line":25,"code":"test('Components -> RangeSlider.render', t => {\n  let wrapper;\n  const onChange = () => {};\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(RangeSlider, {\n      range: [0, 10],\n      value0: 1,\n      value1: 3,\n      onChange: onChange\n    })));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find(Slider).length, 1, 'should render Slider');\n  t.equal(wrapper.find(SliderHandle).length, 2, 'should render 2 Slider handle');\n  t.equal(wrapper.find(SliderBarHandle).length, 1, 'should render 1 Slider bar');\n  t.end();\n});","file":"browser/components/common/range-slider-test.js","skipped":false,"dir":"test"},{"name":"Components -> Container -> Mount with mint:true","suites":[],"updatePoint":{"line":39,"column":53,"index":1927},"line":39,"code":"test('Components -> Container -> Mount with mint:true', t => {\n  // mount with empty store\n  let store = mockStore({});\n  const spy = sinon.spy(Console, 'error');\n\n  // mount without id or a kepler.gl state\n  mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(Container, null)));\n  t.ok(spy.calledOnce, 'should call console.error once');\n  t.equal(spy.getCall(0).args[0], ERROR_MSG.noState, 'should warn when cannot find kepler.gl state');\n\n  // mount with kepler.gl state\n  store = mockStore(initialState);\n  let appReducer = combineReducers({\n    keplerGl: rootReducer\n  });\n  t.doesNotThrow(() => {\n    mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(Container, null)));\n  }, 'Should not throw error');\n  let actions = store.getActions();\n  let expectedActions0 = {\n    type: '@@kepler.gl/REGISTER_ENTRY',\n    payload: {\n      id: 'map',\n      mint: true,\n      mapboxApiAccessToken: undefined,\n      mapboxApiUrl: undefined,\n      mapStylesReplaceDefault: undefined,\n      initialUiState: undefined\n    }\n  };\n  t.deepEqual(actions, [expectedActions0], 'should register entry and request map style');\n\n  // dispatch register action to reducer\n  let nextState = appReducer({}, expectedActions0);\n  let expectedState = {\n    keplerGl: {\n      map: initialCoreState\n    }\n  };\n  t.deepEqual(nextState, expectedState, 'should register map to root reducer by default');\n\n  // mount with custom state\n  store = mockStore({\n    smoothie: {}\n  });\n  appReducer = combineReducers({\n    smoothie: rootReducer\n  });\n  let wrapper;\n  const testId = {\n    id: 'milkshake',\n    mapboxApiAccessToken: 'pk.smoothie'\n  };\n\n  // mount with mint: true\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(Container, {\n      getState: s => s.smoothie,\n      id: testId.id,\n      mapboxApiAccessToken: testId.mapboxApiAccessToken\n    })));\n  }, 'Should not throw error when mount');\n  actions = store.getActions();\n  expectedActions0 = {\n    type: '@@kepler.gl/REGISTER_ENTRY',\n    payload: {\n      id: 'milkshake',\n      mint: true,\n      mapboxApiAccessToken: 'pk.smoothie',\n      mapboxApiUrl: undefined,\n      mapStylesReplaceDefault: undefined,\n      initialUiState: undefined\n    }\n  };\n  t.deepEqual(actions, [expectedActions0], 'should register entry and request map style');\n  actions.splice(0, 2);\n  nextState = appReducer({}, expectedActions0);\n  expectedState = {\n    smoothie: {\n      milkshake: {\n        ...initialCoreState,\n        mapStyle: {\n          ...initialCoreState.mapStyle,\n          mapboxApiAccessToken: 'pk.smoothie'\n        }\n      }\n    }\n  };\n  t.deepEqual(nextState, expectedState, 'should register milkshake to root reducer');\n\n  // unmount\n  wrapper.unmount();\n  expectedActions0 = {\n    type: '@@kepler.gl/DELETE_ENTRY',\n    payload: 'milkshake'\n  };\n  actions = store.getActions();\n  t.deepEqual(actions, [expectedActions0], 'should call unmount');\n  nextState = appReducer(nextState, expectedActions0);\n  expectedState = {\n    smoothie: {}\n  };\n  t.deepEqual(nextState, expectedState, 'should delete milkshake from root reducer');\n  spy.restore();\n  t.end();\n});","file":"browser/components/container-test.js","skipped":false,"dir":"test"},{"name":"Components -> Container -> Mount with mint:false","suites":[],"updatePoint":{"line":151,"column":54,"index":5228},"line":151,"code":"test('Components -> Container -> Mount with mint:false', t => {\n  const spy = sinon.spy(Console, 'error');\n\n  // mount with custom state\n  const store = mockStore({\n    smoothie: {}\n  });\n  const appReducer = combineReducers({\n    smoothie: rootReducer\n  });\n  let wrapper;\n  const testId = {\n    id: 'milkshake'\n  };\n\n  // mount with mint: false\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(Container, {\n      getState: s => s.smoothie,\n      id: testId.id,\n      mint: false,\n      mapboxApiAccessToken: \"hello.world\"\n    })));\n  }, 'Should not throw error when mount');\n  let actions = store.getActions();\n  const expectedActions0 = {\n    type: '@@kepler.gl/REGISTER_ENTRY',\n    payload: {\n      id: 'milkshake',\n      mint: false,\n      mapboxApiAccessToken: 'hello.world',\n      mapboxApiUrl: undefined,\n      mapStylesReplaceDefault: undefined,\n      initialUiState: undefined\n    }\n  };\n  t.deepEqual(actions, [expectedActions0], 'should register entry and request map style');\n  actions.splice(0, 2);\n  const nextState = appReducer({}, expectedActions0);\n  const expectedState = {\n    smoothie: {\n      milkshake: {\n        ...initialCoreState,\n        mapStyle: {\n          ...initialCoreState.mapStyle,\n          // should replace access token\n          mapboxApiAccessToken: 'hello.world',\n          mapboxApiUrl: DEFAULT_MAPBOX_API_URL\n        }\n      }\n    }\n  };\n  t.deepEqual(nextState, expectedState, 'should register milkshake to root reducer');\n\n  // unmount\n  wrapper.unmount();\n  actions = store.getActions();\n  t.deepEqual(actions, [], 'should not call unmount');\n  spy.restore();\n  t.end();\n});","file":"browser/components/container-test.js","skipped":false,"dir":"test"},{"name":"Components -> Container -> Mount then rename","suites":[],"updatePoint":{"line":214,"column":50,"index":6946},"line":214,"code":"test('Components -> Container -> Mount then rename', t => {\n  const dispatch = sinon.spy();\n\n  // mount with custom state\n  const store = mockStore({\n    smoothie: {}\n  });\n  const appReducer = combineReducers({\n    smoothie: rootReducer\n  });\n  let wrapper;\n  const testId = {\n    id: 'milkshake'\n  };\n\n  // mount with mint: false\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Container, {\n      getState: s => s.smoothie,\n      id: testId.id,\n      mapboxApiAccessToken: \"hello.world\",\n      dispatch: dispatch,\n      store: store\n    }));\n  }, 'Should not throw error when mount');\n  const expectedActions0 = {\n    type: '@@kepler.gl/REGISTER_ENTRY',\n    payload: {\n      id: 'milkshake',\n      mint: true,\n      mapboxApiAccessToken: 'hello.world',\n      mapboxApiUrl: undefined,\n      mapStylesReplaceDefault: undefined,\n      initialUiState: undefined\n    }\n  };\n  t.deepEqual(store.getActions().pop(), expectedActions0, 'should register entry');\n  const nextState = appReducer({}, expectedActions0);\n  const expectedState = {\n    smoothie: {\n      milkshake: {\n        ...initialCoreState,\n        mapStyle: {\n          ...initialCoreState.mapStyle,\n          // should replace access token\n          mapboxApiAccessToken: 'hello.world'\n        }\n      }\n    }\n  };\n  t.deepEqual(nextState, expectedState, 'should register milkshake to root reducer');\n  wrapper.setProps({\n    id: 'milkshake-2'\n  });\n  // actions = store.getActions();\n  const expectedActions1 = {\n    type: '@@kepler.gl/RENAME_ENTRY',\n    payload: {\n      oldId: 'milkshake',\n      newId: 'milkshake-2'\n    }\n  };\n  t.deepEqual(store.getActions().pop(), expectedActions1, 'should rename entry');\n  const nextState1 = appReducer(nextState, expectedActions1);\n  const expectedState1 = {\n    smoothie: {\n      'milkshake-2': nextState.smoothie.milkshake\n    }\n  };\n  t.deepEqual(nextState1, expectedState1, 'should rename milkshake to milkshake-2');\n  // unmount\n  wrapper.unmount();\n  const expectedActions2 = {\n    type: '@@kepler.gl/DELETE_ENTRY',\n    payload: 'milkshake-2'\n  };\n  t.deepEqual(store.getActions().pop(), expectedActions2, 'should call unmount milkshake-2');\n  t.end();\n});","file":"browser/components/container-test.js","skipped":false,"dir":"test"},{"name":"FeatureActionPanel -> display layers","suites":[],"updatePoint":{"line":27,"column":42,"index":1451},"line":27,"code":"test('FeatureActionPanel -> display layers', t => {\n  const layers = [{\n    config: {\n      label: 'layer 1',\n      dataId: 'puppy'\n    }\n  }, {\n    config: {\n      label: 'layer 2',\n      dataId: 'puppy'\n    }\n  }];\n  const datasets = {\n    puppy: {\n      color: [123, 123, 123]\n    }\n  };\n  const onToggleLayer = sinon.spy();\n  const onDeleteFeature = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FeatureActionPanel, {\n      className: \"action-item-test\",\n      layers: layers,\n      datasets: datasets,\n      onToggleLayer: onToggleLayer,\n      onDeleteFeature: onDeleteFeature,\n      position: {\n        x: 0,\n        y: 0\n      }\n    })));\n  }, 'FeatureActionPanel should not fail mount');\n  t.equal(wrapper.find('Checkbox').length, 2, 'We should display only 2 layer checkbox');\n  for (let i = 0; i < wrapper.find('Checkbox').length; i++) {\n    t.equal(wrapper.find('Checkbox').at(i).find('label').text(), `layer ${i + 1}`, 'should render correct layer label');\n  }\n  t.end();\n});","file":"browser/components/editor/feature-action-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> with time filter","suites":[],"updatePoint":{"line":67,"column":56,"index":3552},"line":67,"code":"test('Components -> TimeWidget.mount -> with time filter', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, defaultProps)));\n  }, 'TimeWidget should not fail without props');\n  t.equal(wrapper.find(TimeWidget).length, 1, 'should render TimeWidget');\n  t.equal(wrapper.find(FloatingTimeDisplay).length, 1, 'should render FloatingTimeDisplay');\n  t.equal(wrapper.find(TimeRangeSlider).length, 1, 'should render TimeRangeSlider');\n  t.equal(wrapper.find(FieldSelector).length, 1, 'should render FieldSelector');\n  t.equal(wrapper.find(PlaybackControls).length, 1, 'should render PlaybackControls');\n\n  // check yAxisFields\n  const yAxisFields = wrapper.find(FieldSelector).at(0).props().fields;\n  t.deepEqual(yAxisFields.map(f => f.name), ['gps_data.lat', 'gps_data.lng', 'uid'], 'should only pass real / integer fields to yAxis');\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> test actions","suites":[],"updatePoint":{"line":83,"column":52,"index":4517},"line":83,"code":"test('Components -> TimeWidget.mount -> test actions', t => {\n  const onClose = sinon.spy();\n  const toggleAnimation = sinon.spy();\n  const updateAnimationSpeed = sinon.spy();\n  const setFilterAnimationWindow = sinon.spy();\n  const setFilterPlot = sinon.spy();\n  const setFilterAnimationTime = sinon.spy();\n\n  // mock slider client size width so that value calculation works\n  const clientSizeStub = mockHTMLElementClientSize('offsetWidth', 500);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      onClose: onClose,\n      toggleAnimation: toggleAnimation,\n      updateAnimationSpeed: updateAnimationSpeed,\n      setFilterAnimationWindow: setFilterAnimationWindow,\n      setFilterPlot: setFilterPlot,\n      setFilterAnimationTime: setFilterAnimationTime\n    }))), {\n      attachTo: document.body\n    });\n  }, 'mount TimeWidget should not fail');\n  t.equal(wrapper.find(Icons.Close).length, 1, 'should render Close icon');\n  t.equal(wrapper.find(Icons.Reset).length, 1, 'should render Reset icon');\n  t.equal(wrapper.find(Icons.Play).length, 1, 'should render Play icon');\n  t.equal(wrapper.find(Icons.FreeWindow).length, 1, 'should render Window icon');\n  t.equal(wrapper.find(AnimationSpeedSlider).length, 0, 'should  not render AnimationSpeedSlider iniitally');\n  t.equal(wrapper.find('.animation-window-control').length, 0, 'should not render AnimationWindowControl initially');\n\n  // hit play\n  wrapper.find(Icons.Play).at(0).simulate('click');\n  t.deepEqual(toggleAnimation.args[0], [0], 'should call toggle animation');\n\n  // hit speed icon\n  wrapper.find(Icons.Rocket).at(0).simulate('click');\n  t.equal(wrapper.find(AnimationSpeedSlider).length, 1, 'should render AnimationSpeedSlider');\n  t.equal(wrapper.find(AnimationSpeedSlider).at(0).find('.kg-range-slider__handle').length, 2, 'should render 2 speed slider handle');\n  const sliderHandle = wrapper.find(AnimationSpeedSlider).at(0).find('.kg-range-slider__handle').at(1);\n  sliderHandle.simulate('mousedown', {\n    clientX: 0\n  });\n\n  // simulate slider move\n  const mouseMove = new window.MouseEvent('mousemove', {\n    clientX: 100\n  });\n  document.dispatchEvent(mouseMove);\n\n  // test updateAnimationSpeed\n  t.deepEqual(updateAnimationSpeed.args[0], [0, 2], 'should call updateAnimationSpeed with speed');\n\n  // hit animation window\n  wrapper.find(Icons.FreeWindow).at(0).simulate('click');\n  t.equal(wrapper.find('.animation-window-control').length, 1, 'should render AnimationWindowControl initially');\n  t.equal(wrapper.find('.animation-window-control').at(0).find(IconButton).length, 1, 'should render 1 animate window options');\n\n  // select an animation option\n  wrapper.find('.animation-window-control').at(0).find(IconButton).at(0).simulate('click');\n  t.deepEqual(setFilterAnimationWindow.args[0], [{\n    id: StateWFilters.visState.filters[0].id,\n    animationWindow: 'incremental'\n  }], 'should call setFilterAnimationWindow');\n\n  // click yaxis select\n  wrapper.find('.item-selector__dropdown').at(0).simulate('click');\n  t.equal(wrapper.find(Typeahead).length, 1, 'should render dropdown select');\n  wrapper.find(Typeahead).find('.field-selector_list-item').at(0).simulate('click');\n  t.equal(setFilterPlot.args[0][0], 0, 'should pass filteridx to setFilterPlot');\n  t.equal(setFilterPlot.args[0][1].yAxis.name, 'gps_data.lat', 'should pass correct yAxis to setFilterPlot');\n\n  // hit close\n  wrapper.find(Icons.Close).at(0).simulate('click');\n  t.deepEqual(onClose.calledOnce, true, 'should call enlarged filter to close');\n  wrapper.detach();\n  clientSizeStub.restore();\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> test setFilterAnimationTime","suites":[],"updatePoint":{"line":161,"column":67,"index":8247},"line":161,"code":"test('Components -> TimeWidget.mount -> test setFilterAnimationTime', t => {\n  const setFilterAnimationTime = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      setFilterAnimationTime: setFilterAnimationTime\n    }))), {\n      attachTo: document.body\n    });\n  }, 'mount TimeWidget should not fail');\n\n  // mock slider client size width so that value calculation works\n  const clientSizeStub = mockHTMLElementClientSize('offsetWidth', 500);\n  t.equal(wrapper.find(RangeSlider).length, 1, 'should render RangeSlider');\n  const rangeSlider = wrapper.find(RangeSlider).at(0);\n  t.equal(rangeSlider.find(SliderHandle).length, 2, 'should render 2 slider handle');\n  rangeSlider.find(SliderHandle).at(0).find('.kg-range-slider__handle').at(0).simulate('mousedown', {\n    clientX: 0\n  });\n  // simulate slider move\n  const mouseMove = new window.MouseEvent('mousemove', {\n    clientX: 100\n  });\n  document.dispatchEvent(mouseMove);\n\n  // test updateAnimationSpeed\n  t.deepEqual(setFilterAnimationTime.args[0], [0, 'value', [1474594560000, 1474617600000]], 'should call setFilterAnimationTime with new value');\n\n  // cleanup\n  wrapper.detach();\n  clientSizeStub.restore();\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> test floating time display","suites":[],"updatePoint":{"line":194,"column":66,"index":9589},"line":194,"code":"test('Components -> TimeWidget.mount -> test floating time display', t => {\n  const topSelector = '.animation-control__time-display__top';\n  const bottomSelector = '.animation-control__time-display__bottom';\n  let wrapper;\n  // because we are using locale based formats, we set a locale here to make sure\n  // result are always the same\n  moment.locale('en');\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, defaultProps)));\n  }, 'mount TimeWidget should not fail');\n  const timeDisplay = wrapper.find(FloatingTimeDisplay);\n  t.equal(timeDisplay.find(topSelector).length, 1, 'should render 1 top row');\n  t.equal(timeDisplay.find(topSelector).at(0).find('.time-value').text(), '09/23/2016', 'should render correct date');\n  t.equal(timeDisplay.find(bottomSelector).length, 1, 'should render 1 bottom row');\n  t.equal(timeDisplay.find(bottomSelector).at(0).find('.time-value').length, 2, 'should render 2 time value');\n  t.equal(timeDisplay.find(bottomSelector).at(0).find('.time-value').at(0).text(), '5:00:00 AM', 'should render correct time');\n  t.equal(timeDisplay.find(bottomSelector).at(0).find('.time-value').at(1).text(), '8:00:00 AM', 'should render correct time');\n\n  // set TimeWidget prop\n  // filter with timezone and custom Format\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      filter: nextState.filters[0]\n    }))\n  });\n\n  // check time display again\n  const timeDisplay2 = wrapper.find(FloatingTimeDisplay);\n  t.equal(timeDisplay2.find(bottomSelector).at(0).find('.time-value').at(0).text(), '2016 Sep 23 01:00 am', 'should render correct time format and timezone');\n  t.equal(timeDisplay2.find(bottomSelector).at(0).find('.time-value').at(1).text(), '2016 Sep 23 04:00 am', 'should render correct time format and timezone');\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> TimeSliderMarker","suites":[],"updatePoint":{"line":226,"column":56,"index":11507},"line":226,"code":"test('Components -> TimeWidget.mount -> TimeSliderMarker', t => {\n  const clientSizeStub = mockHTMLElementClientSize('offsetWidth', 500);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, defaultProps)));\n  }, 'mount TimeWidget should not fail');\n  t.equal(wrapper.find(TimeSliderMarker).length, 1, 'should render TimeSliderMarker');\n  let d3Html = wrapper.find(TimeSliderMarker).at(0).find('.x.axis').html();\n\n  // moment.utc(1474588800000) -> \"2016-09-23 00:00\"\n  // moment.utc(1474617600000) -> \"2016-09-23 08:00\"\n  // Enyme cant detect element appended by d3\n  const expectedMarks = ['Fri 23', '01 AM', '02 AM', '03 AM', '04 AM', '05 AM', '06 AM', '07 AM', '08 AM'];\n  expectedMarks.forEach(mark => {\n    t.ok(d3Html.includes(`<text fill=\"currentColor\" y=\"12\" dy=\"0.71em\">${mark}</text>`), `should render correct time marker ${mark}`);\n  });\n\n  // set TimeWidget prop\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      filter: nextState.filters[0]\n    }))\n  });\n  d3Html = wrapper.find(TimeSliderMarker).at(0).find('.x.axis').html();\n\n  // moment.utc(1474588800000).tz('America/New_York') -> \"2016-09-22 20:00\"\n  // moment.utc(1474617600000).tz('America/New_York') -> \"2016-09-23 04:00\"\n  // Enyme cant detect element appended by d3\n  const expectedMarks2 = ['20 PM', '21 PM', '22 PM', '23 PM', 'Fri 23', '01 AM', '02 AM', '03 AM', '04 AM'];\n  expectedMarks2.forEach(mark => {\n    t.ok(d3Html.includes(`<text fill=\"currentColor\" y=\"12\" dy=\"0.71em\">${mark}</text>`), `should render correct time marker ${mark}`);\n  });\n  const inalidFilter = {\n    ...StateWFilters.visState.filters[0],\n    domain: null\n  };\n\n  // set TimeWidget prop\n  t.doesNotThrow(() => {\n    wrapper.setProps({\n      children: /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n        filter: inalidFilter\n      }))\n    });\n  }, 'mount TimeWidget with invalid filter should not fail');\n  clientSizeStub.restore();\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"Components -> TimeWidget.mount -> TimeTitle","suites":[],"updatePoint":{"line":274,"column":49,"index":13608},"line":274,"code":"test('Components -> TimeWidget.mount -> TimeTitle', t => {\n  const selector = '.time-range-slider__time-title .time-value span';\n  let wrapper;\n  // because we are using locale based formats, we set a locale here to make sure\n  // result are always the same\n  moment.locale('en');\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      showTimeDisplay: false\n    }))));\n  }, 'mount TimeWidget with showTimeDisplay false');\n  t.equal(wrapper.find(TimeRangeSliderTimeTitle).length, 1, 'should render TimeRangeSliderTimeTitle');\n  t.equal(wrapper.find(selector).length, 2, 'Should render 2 time title value');\n  let expected = ['09/23/2016 5:00:00 AM', '09/23/2016 8:00:00 AM'];\n  wrapper.find(selector).forEach((span, i) => {\n    t.equal(span.text(), expected[i], `should render correct time value ${expected[i]}`);\n  });\n\n  // set TimeWidget prop with timezone and custom Format time filter\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(TimeWidget, _extends({}, defaultProps, {\n      showTimeDisplay: false,\n      filter: nextState.filters[0]\n    }))\n  });\n  expected = ['2016 Sep 23 01:00 am', '2016 Sep 23 04:00 am'];\n  wrapper.find(selector).forEach((span, i) => {\n    t.equal(span.text(), expected[i], `should render correct time value ${expected[i]}`);\n  });\n  t.end();\n});","file":"browser/components/filters/time-widget-test.js","skipped":false,"dir":"test"},{"name":"GeocoderPanel - render","suites":[],"updatePoint":{"line":31,"column":28,"index":1686},"line":31,"code":"test('GeocoderPanel - render', t => {\n  const enabled = true;\n  const updateVisData = sinon.spy();\n  const removeDataset = sinon.spy();\n  const updateMap = sinon.spy();\n  const mockMapState = {\n    latitude: 33,\n    longitude: 127,\n    zoom: 8,\n    width: 800,\n    height: 800\n  };\n  const layerOrder = ['layer_1', 'layer_2'];\n  const mockUiState = InitialState.uiState;\n  const mockGeoItem = {\n    center: [1, 55],\n    text: 'mock',\n    bbox: [-1, 50, 4, 65]\n  };\n  const mockGeoItemWithOutBbox = {\n    center: [1, 55],\n    text: 'mock'\n  };\n  const mockPayload = [[{\n    data: {\n      fields: [{\n        name: 'lt',\n        id: 'lt',\n        displayName: 'lt',\n        format: '',\n        fieldIdx: 0,\n        type: 'integer',\n        analyzerType: 'INT',\n        valueAccessor: values => values[0]\n      }, {\n        name: 'ln',\n        id: 'ln',\n        displayName: 'ln',\n        format: '',\n        fieldIdx: 1,\n        type: 'integer',\n        analyzerType: 'INT',\n        valueAccessor: values => values[1]\n      }, {\n        name: 'icon',\n        id: 'icon',\n        displayName: 'icon',\n        format: '',\n        fieldIdx: 2,\n        type: 'string',\n        analyzerType: 'STRING',\n        valueAccessor: values => values[2]\n      }, {\n        name: 'text',\n        id: 'text',\n        displayName: 'text',\n        format: '',\n        fieldIdx: 3,\n        type: 'string',\n        analyzerType: 'STRING',\n        valueAccessor: values => values[3]\n      }],\n      rows: [[55, 1, 'place', 'mock']]\n    },\n    id: 'geocoder_dataset',\n    info: {\n      hidden: true,\n      id: 'geocoder_dataset',\n      label: 'geocoder_dataset'\n    }\n  }], {\n    keepExistingConfig: true\n  }, {\n    visState: {\n      layers: [{\n        id: 'geocoder_layer',\n        type: 'icon',\n        config: {\n          label: 'Geocoder Layer',\n          color: [255, 0, 0],\n          dataId: 'geocoder_dataset',\n          columns: {\n            lat: 'lt',\n            lng: 'ln',\n            icon: 'icon',\n            label: 'text'\n          },\n          isVisible: true,\n          hidden: true,\n          visConfig: {\n            radius: 80\n          }\n        }\n      }],\n      layerOrder: ['geocoder_layer', 'layer_1', 'layer_2']\n    }\n  }];\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(GeocoderPanel, {\n      isGeocoderEnabled: enabled,\n      mapboxApiAccessToken: MAPBOX_TOKEN,\n      mapState: mockMapState,\n      uiState: mockUiState,\n      updateVisData: updateVisData,\n      removeDataset: removeDataset,\n      updateMap: updateMap,\n      layerOrder: layerOrder\n    })));\n  }, 'Should render');\n  t.equal(wrapper.find(GeocoderPanel).length, 1, 'Should display 1 GeoCoderPanel');\n  t.equal(wrapper.find('Geocoder').length, 0, 'Should display 0 Geocoder because of invalid key');\n  const instance = wrapper.find(GeocoderPanel).instance();\n  instance.onSelected(null, mockGeoItem);\n  t.deepEqual(removeDataset.args, [['geocoder_dataset']], 'Should call removeDataset on onSelected');\n  cmpObjectKeys(t, [mockPayload], updateVisData.args, 'onSelected payload should have the correct params');\n  const actualDatasets = updateVisData.args[0][0];\n  const mockDatasets = mockPayload[0];\n  mockDatasets.forEach((mockDataset, index) => {\n    const {\n      data: mockDatasetData,\n      ...restMockDataset\n    } = mockDataset;\n    const {\n      data: actualDatasetData,\n      ...restActualDataset\n    } = actualDatasets[0];\n    cmpDatasetData(t, mockDatasetData, actualDatasetData, mockDataset.id);\n    t.deepEqual(restActualDataset, restMockDataset, `onSelected options dataset.${mockDataset.id} should be the same`);\n  });\n  t.deepEqual(updateVisData.args[0][1], mockPayload[1], 'onSelected options should be correct');\n  t.deepEqual(updateVisData.args[0][2], mockPayload[2], 'onSelected configuration should be correct');\n  const newVP = updateMap.args[0][0];\n  t.deepEqual({\n    latitude: newVP.latitude,\n    longitude: newVP.longitude,\n    zoom: newVP.zoom\n  }, {\n    latitude: 57.5,\n    longitude: 1.5,\n    zoom: 4\n  }, 'Should call updateMap action on onSelected w/ new viewport');\n  t.ok(newVP.transitionInterpolator, 'Should call updateMap action with transitionInterpolator');\n  instance.onSelected(null, mockGeoItemWithOutBbox);\n  const newVP2 = updateMap.args[1][0];\n  t.deepEqual({\n    latitude: newVP2.latitude,\n    longitude: newVP2.longitude,\n    zoom: newVP2.zoom\n  }, {\n    latitude: 55,\n    longitude: 1,\n    zoom: 11\n  }, 'Should call updateMapaction on onSelected w/o bbox');\n  instance.removeMarker();\n  t.deepEqual(removeDataset.args[1], ['geocoder_dataset'], 'Should be dispatching removeDataset action on removeMarker');\n  instance.removeGeocoderDataset();\n  t.deepEqual(removeDataset.args[2], ['geocoder_dataset'], 'Should be dispatching removeDataset action on removeGeocoderDataset');\n  t.end();\n});","file":"browser/components/geocoder-panel-test.js","skipped":false,"dir":"test"},{"name":"Geocoder -> testForCoordinates","suites":[],"updatePoint":{"line":191,"column":36,"index":6608},"line":191,"code":"test('Geocoder -> testForCoordinates', t => {\n  t.deepEqual(testForCoordinates('21.22,-138.0'), [true, 21.22, -138.0], 'should recognize valid coordinates');\n  t.deepEqual(testForCoordinates('san francisco'), [false, 'san francisco'], 'should recognize invalid coordinates');\n  t.deepEqual(testForCoordinates('91,123'), [false, '91,123'], 'should recognize invalid coordinates');\n  t.deepEqual(testForCoordinates('-21.122, -123.4321'), [true, -21.122, -123.4321], 'should recognize valid coordinates');\n  t.end();\n});","file":"browser/components/geocoder-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> injectComponents","suites":[],"updatePoint":{"line":34,"column":48,"index":2133},"line":34,"code":"test('Components -> injector -> injectComponents', t => {\n  const CustomHeader = () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header\"\n  }, \"smoothie\");\n  const myCustomHeaderFactory = () => CustomHeader;\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n\n  // test if custom header is rendered\n  t.ok(wrapper.find('.my-test-header').length, 'should render custom header');\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> missing deps","suites":[],"updatePoint":{"line":58,"column":44,"index":2922},"line":58,"code":"test('Components -> injector -> missing deps', t => {\n  const spy = sinon.spy(Console, 'error');\n  // eslint-disable-next-line react/display-name\n  const myCustomNameFactory = () => () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-name\"\n  }, \"name\");\n  // eslint-disable-next-line react/display-name\n  const myCustomHeaderFactory = Name => () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-1\"\n  }, /*#__PURE__*/React.createElement(Name, null), \"smoothie\");\n  myCustomHeaderFactory.deps = [myCustomNameFactory];\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n  t.ok(spy.notCalled, 'Should automatically add custom deps and not call console.error');\n  t.ok(wrapper.find('.my-test-header-name').length, 'should still render custom header name');\n  spy.restore();\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> wrong factory type","suites":[],"updatePoint":{"line":88,"column":50,"index":4143},"line":88,"code":"test('Components -> injector -> wrong factory type', t => {\n  const spy = sinon.spy(Console, 'error');\n  // eslint-disable-next-line react/display-name\n  const myCustomHeaderFactory = Name => () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-2\"\n  }, /*#__PURE__*/React.createElement(Name, null), \"smoothie\");\n  const KeplerGl = injectComponents([[undefined, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n  t.ok(spy.calledTwice, 'should call console.error twice');\n  t.equal(spy.getCall(0).args[0], 'Error injecting factory: ', 'should warn when default factory is not provided');\n\n  // test if custom header is rendered\n  t.ok(wrapper.find('.side-panel__panel-header').length, 'should render default header');\n  spy.restore();\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> wrong replacement type","suites":[],"updatePoint":{"line":116,"column":54,"index":5242},"line":116,"code":"test('Components -> injector -> wrong replacement type', t => {\n  const spy = sinon.spy(Console, 'error');\n  // const spy = sinon.spy(Console, 'error');\n\n  const KeplerGl = injectComponents([[PanelHeaderFactory, undefined]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n  t.ok(spy.calledTwice, 'should call console.error twice');\n  t.equal(spy.getCall(0).args[0], 'Error injecting replacement for: ', 'should warn when replace factory is not provided');\n\n  // test if custom header is rendered\n  t.ok(wrapper.find('.side-panel__panel-header').length, 'should render default header');\n  spy.restore();\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> replace and render existing","suites":[],"updatePoint":{"line":142,"column":59,"index":6163},"line":142,"code":"test('Components -> injector -> replace and render existing', t => {\n  myCustomHeaderFactory.deps = PanelHeaderFactory.deps;\n  function myCustomHeaderFactory(...deps) {\n    const PanelHeader = PanelHeaderFactory(...deps);\n    PanelHeader.defaultProps;\n    const MyHeader = props => {\n      return /*#__PURE__*/React.createElement(PanelHeader, _extends({}, props, {\n        appName: \"taro\"\n      }));\n    };\n    return MyHeader;\n  }\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"foo\",\n      mapboxApiAccessToken: \"smoothie_and_milkshake\"\n    })));\n  }, 'should not throw error when replace and render existing component');\n  t.equal(wrapper.find('.logo__link').text(), 'taro', 'should render provided prop');\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> withState.lens","suites":[],"updatePoint":{"line":173,"column":46,"index":7231},"line":173,"code":"test('Components -> injector -> withState.lens', t => {\n  const CustomHeader = ({\n    visState\n  }) => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-3\"\n  }, \"smoothie\");\n  const myCustomHeaderFactory = () => withState([visStateLens, mapStateLens, uiStateLens, mapStyleLens])(CustomHeader);\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n  const header = wrapper.find(CustomHeader).at(0);\n  const props = header.props();\n  t.ok(header, 'should render CustomHeader');\n  // test if custom header is rendered\n  t.ok(props.visState, 'should add visState to props');\n  t.ok(props.mapState, 'should add mapState to props');\n  t.ok(props.mapStyle, 'should add mapStyle to props');\n  t.ok(props.uiState, 'should add uiState to props');\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> withState.mapStateToProps","suites":[],"updatePoint":{"line":204,"column":57,"index":8392},"line":204,"code":"test('Components -> injector -> withState.mapStateToProps', t => {\n  const CustomHeader = ({\n    visState\n  }) => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-3\"\n  }, \"smoothie\");\n  const myCustomHeaderFactory = () => withState([], state => ({\n    ids: Object.keys(state)\n  }))(CustomHeader);\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n\n  // test if custom header is rendered\n  const header = wrapper.find(CustomHeader).at(0);\n  const props = header.props();\n  t.ok(header, 'should render CustomHeader');\n  t.deepEqual(props.ids, ['keplerGl'], 'should run mapStateToProps');\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> injector -> actions","suites":[],"updatePoint":{"line":235,"column":39,"index":9377},"line":235,"code":"test('Components -> injector -> actions', t => {\n  const CustomHeader = ({\n    add\n  }) => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"my-test-header-3\",\n    onClick: add\n  }, \"smoothie\");\n  const testAction = () => ({\n    type: 'ADD'\n  });\n  const myCustomHeaderFactory = () => withState([], state => state, {\n    add: testAction\n  })(CustomHeader);\n  const KeplerGl = injectComponents([[PanelHeaderFactory, myCustomHeaderFactory]]);\n\n  // assume instance reducer is already mounted\n  const store = mockStore({\n    keplerGl: {\n      foo: initialCoreState\n    }\n  });\n  const wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n    store: store\n  }, /*#__PURE__*/React.createElement(KeplerGl, {\n    id: \"foo\",\n    mapboxApiAccessToken: \"smoothie_and_milkshake\"\n  })));\n\n  // test if custom header is rendered\n  const header = wrapper.find(CustomHeader).at(0);\n  const props = header.props();\n  t.ok(header, 'should render CustomHeader');\n  t.ok(typeof props.add === 'function', 'should add actions');\n  wrapper.find(CustomHeader).simulate('click');\n  const lastAction = store.getActions().pop();\n  t.deepEqual(lastAction, {\n    type: 'ADD'\n  }, 'should dispatch custom actions');\n  t.end();\n});","file":"browser/components/injector-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount","suites":[],"updatePoint":{"line":52,"column":37,"index":3013},"line":52,"code":"test('Components -> KeplerGl -> Mount', t => {\n  drainTasksForTesting();\n  // mount with empty store\n  const store = mockStore(initialState);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  t.equal(wrapper.find(KeplerGl).length, 1, 'should render KeplerGl');\n  t.equal(wrapper.find(SidePanel).length, 1, 'should render SidePanel');\n  t.equal(wrapper.find(MapContainer).length, 1, 'should render MapContainer');\n  t.equal(wrapper.find(BottomWidget).length, 1, 'should render BottomWidget');\n  t.equal(wrapper.find(ModalContainer).length, 1, 'should render ModalContainer');\n  t.equal(wrapper.find(PlotContainer).length, 0, 'should not render PlotContainer');\n  t.equal(wrapper.find(NotificationPanel).length, 1, 'should render NotificationPanel');\n  t.equal(wrapper.find(GeocoderPanel).length, 0, 'should not render GeocoderPanel');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount -> readOnly","suites":[],"updatePoint":{"line":77,"column":49,"index":4206},"line":77,"code":"test('Components -> KeplerGl -> Mount -> readOnly', t => {\n  drainTasksForTesting();\n  // mount with readOnly true\n  const initialStateReadonly = {\n    keplerGl: {\n      map: {\n        ...initialCoreState,\n        uiState: {\n          ...initialCoreState.uiState,\n          readOnly: true\n        }\n      }\n    }\n  };\n  const store = mockStore(initialStateReadonly);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  t.equal(wrapper.find(KeplerGl).length, 1, 'should render KeplerGl');\n  t.equal(wrapper.find(SidePanel).length, 0, 'should not render SidePanel');\n  t.equal(wrapper.find(MapContainer).length, 1, 'should render MapContainer');\n  t.equal(wrapper.find(BottomWidget).length, 1, 'should render BottomWidget');\n  t.equal(wrapper.find(ModalContainer).length, 1, 'should render ModalContainer');\n  t.equal(wrapper.find(PlotContainer).length, 0, 'should not render PlotContainer');\n  t.equal(wrapper.find(NotificationPanel).length, 1, 'should render NotificationPanel');\n  t.equal(wrapper.find(GeocoderPanel).length, 0, 'should not render GeocoderPanel');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount -> Plot","suites":[],"updatePoint":{"line":113,"column":45,"index":5612},"line":113,"code":"test('Components -> KeplerGl -> Mount -> Plot', t => {\n  drainTasksForTesting();\n  // mount with readOnly true\n  const initialStatePlots = {\n    keplerGl: {\n      map: {\n        ...initialCoreState,\n        uiState: {\n          ...initialCoreState.uiState,\n          currentModal: EXPORT_IMAGE_ID,\n          exportImage: {\n            ...initialCoreState.uiState.exportImage,\n            exporting: true\n          }\n        }\n      }\n    }\n  };\n  const store = mockStore(initialStatePlots);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  t.equal(wrapper.find(KeplerGl).length, 1, 'should render KeplerGl');\n  t.equal(wrapper.find(SidePanel).length, 1, 'should render SidePanel');\n  t.equal(wrapper.find(MapContainer).length, 2, 'should render 2 MapContainer');\n  t.equal(wrapper.find(BottomWidget).length, 1, 'should render BottomWidget');\n  t.equal(wrapper.find(ModalContainer).length, 1, 'should render ModalContainer');\n  t.equal(wrapper.find(PlotContainer).length, 1, 'should render PlotContainer');\n  t.equal(wrapper.find(NotificationPanel).length, 1, 'should render NotificationPanel');\n  t.equal(wrapper.find(GeocoderPanel).length, 0, 'should not render GeocoderPanel');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount -> Split Maps","suites":[],"updatePoint":{"line":153,"column":51,"index":7146},"line":153,"code":"test('Components -> KeplerGl -> Mount -> Split Maps', t => {\n  drainTasksForTesting();\n  // mount with readOnly true\n  const initialStateSplitMap = {\n    keplerGl: {\n      map: {\n        ...initialCoreState,\n        visState: {\n          ...initialCoreState.visState,\n          splitMaps: [{\n            layers: {}\n          }, {\n            layers: {}\n          }]\n        }\n      }\n    }\n  };\n  const store = mockStore(initialStateSplitMap);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  t.equal(wrapper.find(KeplerGl).length, 1, 'should render KeplerGl');\n  t.equal(wrapper.find(SidePanel).length, 1, 'should render SidePanel');\n  t.equal(wrapper.find(MapContainer).length, 2, 'should render 2 MapContainer');\n  t.equal(wrapper.find(BottomWidget).length, 1, 'should render BottomWidget');\n  t.equal(wrapper.find(ModalContainer).length, 1, 'should render ModalContainer');\n  t.equal(wrapper.find(PlotContainer).length, 0, 'should render PlotContainer');\n  t.equal(wrapper.find(NotificationPanel).length, 1, 'should render NotificationPanel');\n  t.equal(wrapper.find(GeocoderPanel).length, 0, 'should not render GeocoderPanel');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount -> Load default map style task","suites":[],"updatePoint":{"line":193,"column":68,"index":8644},"line":193,"code":"test('Components -> KeplerGl -> Mount -> Load default map style task', t => {\n  // mount with empty store\n  drainTasksForTesting();\n  const store = mockStore(initialState);\n  t.doesNotThrow(() => {\n    mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  const actions = store.getActions();\n  const expectedActions = [{\n    type: ActionTypes.LOAD_MAP_STYLES,\n    payload: {\n      newStyles: DEFAULT_MAP_STYLES.reduce((accu, curr) => ({\n        ...accu,\n        [curr.id]: curr\n      }), {}),\n      onSuccess: undefined\n    }\n  }];\n  t.deepEqual(actions, expectedActions, 'Should mount kepler.gl and dispatch 1 action to load map styles');\n\n  // const tmpState0 = coreReducer(initialCoreState, actions[0]);\n  const tmpState = coreReducer(initialCoreState, actions[0]);\n  const [actionTask1, ...more] = drainTasksForTesting();\n  t.equal(more.length, 0, 'should dispatch 1 tasks');\n  const expectedTask = {\n    payload: [{\n      id: 'dark',\n      url: 'https://api.mapbox.com/styles/v1/uberdata/cjoqbbf6l9k302sl96tyvka09?pluginName=Keplergl&access_token=smoothie-the-cat'\n    }]\n  };\n  t.deepEqual(actionTask1.payload, expectedTask.payload, 'should create task to load map styles');\n  t.deepEqual(tmpState.mapStyle.isLoading, {\n    dark: true\n  }, 'should set mapStyle isLoading');\n  const resultState1 = coreReducer(tmpState, succeedTaskWithValues(actionTask1, [{\n    id: 'dark',\n    style: {\n      layers: [],\n      name: 'dark'\n    }\n  }]));\n  const expectedStateMapStyles = {\n    ...tmpState.mapStyle.mapStyles,\n    dark: {\n      ...DEFAULT_MAP_STYLES[1],\n      style: {\n        layers: [],\n        name: 'dark'\n      }\n    }\n  };\n  t.deepEqual(resultState1.mapStyle.mapStyles, expectedStateMapStyles, 'should update state with loaded map styles');\n  t.deepEqual(resultState1.mapStyle.isLoading, {\n    dark: false\n  }, 'should update state isLoading');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> Mount -> Load custom map style task","suites":[],"updatePoint":{"line":257,"column":67,"index":10787},"line":257,"code":"test('Components -> KeplerGl -> Mount -> Load custom map style task', t => {\n  drainTasksForTesting();\n  // mount with empty store\n  // set initialState to custom styleType\n  const initialCoreState1 = {\n    ...initialCoreState,\n    mapStyle: {\n      ...initialCoreState.mapStyle,\n      styleType: 'chai'\n    }\n  };\n  const initialState1 = {\n    keplerGl: {\n      map: initialCoreState1\n    }\n  };\n  const store = mockStore(initialState1);\n\n  //\n  const customStyle1 = {\n    id: 'smoothie',\n    url: 'mapbox://styles/smoothie/thecat'\n  };\n  const customStyle2 = {\n    id: 'milkshake',\n    style: {\n      id: 'mm',\n      layers: []\n    }\n  };\n  const customStyle3 = {\n    id: 'chai',\n    style: {\n      id: 'chai',\n      layers: []\n    },\n    layerGroups: [{\n      slug: 'label',\n      defaultVisibility: true\n    }]\n  };\n  t.doesNotThrow(() => {\n    mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(KeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch,\n      mapStyles: [customStyle1, customStyle2, customStyle3]\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n  const actions = store.getActions();\n  const expectedActions = [{\n    type: ActionTypes.LOAD_MAP_STYLES,\n    payload: {\n      newStyles: {\n        ...initialCoreState1.mapStyle.mapStyles,\n        milkshake: customStyle2,\n        chai: customStyle3,\n        smoothie: customStyle1\n      },\n      onSuccess: undefined\n    }\n  }];\n  t.deepEqual(actions, expectedActions, 'Should mount kepler.gl and dispatch 1 actions to load map styles');\n  const resultState1 = coreReducer(initialCoreState1, actions[0]);\n  const expectedMapStyleState1 = {\n    ...initialCoreState1.mapStyle,\n    mapStyles: {\n      ...initialCoreState1.mapStyle.mapStyles,\n      milkshake: {\n        id: 'milkshake',\n        style: {\n          id: 'mm',\n          layers: []\n        },\n        layerGroups: []\n      },\n      chai: customStyle3,\n      smoothie: {\n        id: 'smoothie',\n        url: 'mapbox://styles/smoothie/thecat',\n        layerGroups: []\n      }\n    },\n    visibleLayerGroups: {\n      label: true\n    },\n    threeDBuildingColor: [194.6103322548211, 191.81688250953655, 185.2988331038727],\n    bottomMapStyle: {\n      id: 'chai',\n      layers: []\n    },\n    topMapStyle: null,\n    editable: 1\n  };\n  t.deepEqual(resultState1.mapStyle, expectedMapStyleState1, 'Should load map style into reducer and create layer groups');\n  Object.keys(resultState1.mapStyle).forEach(key => {\n    t.deepEqual(resultState1.mapStyle[key], expectedMapStyleState1[key], `mapStyle[${key}] should be correct`);\n  });\n\n  // Do not remove this. Necessary for testing flow\n  // eslint-disable-next-line no-unused-vars\n  const actionTask1 = drainTasksForTesting();\n  t.equal(actionTask1.length, 0, 'should not dispatch action to load styles');\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"Components -> KeplerGl -> SidePanel -> Geocoder dataset display","suites":[],"updatePoint":{"line":379,"column":69,"index":14126},"line":379,"code":"test('Components -> KeplerGl -> SidePanel -> Geocoder dataset display', t => {\n  drainTasksForTesting();\n  const toggleSidePanel = sinon.spy();\n\n  // Create custom SidePanel that will accept toggleSidePanel as a spy\n  function CustomSidePanelFactory(...deps) {\n    const OriginalSidePanel = SidePanelFactory(...deps);\n    const CustomSidePanel = props => {\n      const customUIStateActions = {\n        ...props.uiStateActions,\n        toggleSidePanel\n      };\n      return /*#__PURE__*/React.createElement(OriginalSidePanel, _extends({}, props, {\n        uiStateActions: customUIStateActions\n      }));\n    };\n    return CustomSidePanel;\n  }\n  CustomSidePanelFactory.deps = SidePanelFactory.deps;\n  const CustomKeplerGl = appInjector.provide(SidePanelFactory, CustomSidePanelFactory).get(KeplerGlFactory);\n\n  // Create initial state based on mocked state with geocoder dataset and use that for mocking the store\n  const store = mockStore({\n    keplerGl: {\n      map: StateWithGeocoderDataset\n    }\n  });\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mount( /*#__PURE__*/React.createElement(Provider, {\n      store: store\n    }, /*#__PURE__*/React.createElement(CustomKeplerGl, {\n      id: \"map\",\n      mapboxApiAccessToken: \"smoothie-the-cat\",\n      selector: state => state.keplerGl.map,\n      dispatch: store.dispatch\n    })));\n  }, 'Should not throw error when mount KeplerGl');\n\n  // Check if we have 4 sidepanel tabs\n  t.equal(wrapper.find('.side-panel__tab').length, 4, 'should render 4 panel tabs');\n\n  // click layer tab\n  const layerTab = wrapper.find('.side-panel__tab').at(0);\n  layerTab.simulate('click');\n  t.ok(toggleSidePanel.calledWith('layer'), 'should call toggleSidePanel with layer');\n  t.notEqual(findGeocoderDatasetName(wrapper), GEOCODER_DATASET_NAME, `should not be equal to ${GEOCODER_DATASET_NAME}`);\n\n  // click filters tab\n  const filterTab = wrapper.find('.side-panel__tab').at(1);\n  filterTab.simulate('click');\n  t.ok(toggleSidePanel.calledWith('filter'), 'should call toggleSidePanel with filter');\n  t.notEqual(findGeocoderDatasetName(wrapper), GEOCODER_DATASET_NAME, `should not be equal to ${GEOCODER_DATASET_NAME}`);\n\n  // click interaction tab\n  const interactionTab = wrapper.find('.side-panel__tab').at(2);\n  interactionTab.simulate('click');\n  t.ok(toggleSidePanel.calledWith('interaction'), 'should call toggleSidePanel with interaction');\n  t.notEqual(findGeocoderDatasetName(wrapper), GEOCODER_DATASET_NAME, `should not be equal to ${GEOCODER_DATASET_NAME}`);\n  t.end();\n});","file":"browser/components/kepler-gl-test.js","skipped":false,"dir":"test"},{"name":"MapContainerFactory - display all options","suites":[],"updatePoint":{"line":29,"column":47,"index":1594},"line":29,"code":"test('MapContainerFactory - display all options', t => {\n  const onMapStyleLoaded = sinon.spy();\n  const onLayerClick = sinon.spy();\n  const props = {\n    ...initialProps,\n    mapStyle: {\n      bottomMapStyle: {\n        layers: [],\n        name: 'foo'\n      },\n      visibleLayerGroups: {}\n    },\n    onMapStyleLoaded,\n    visStateActions: {\n      ...initialProps.visStateActions,\n      onLayerClick\n    }\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, props)));\n  }, 'MapContainer should not fail without props');\n  t.equal(wrapper.find('MapControl').length, 1, 'Should display 1 MapControl');\n  t.equal(wrapper.find('InteractiveMap').length, 1, 'Should display 1 InteractiveMap');\n\n  // Editor\n  t.equal(wrapper.find('StaticMap').length, 1, 'Should display 1 DeckGl');\n  const instance = wrapper.find(MapContainer).instance();\n  instance._onMapboxStyleUpdate();\n  t.equal(onMapStyleLoaded.called, true, 'Should be calling onMapStyleLoaded');\n  instance._onCloseMapPopover();\n  t.equal(onLayerClick.called, true, 'Should be calling onLayerClick');\n  t.end();\n});","file":"browser/components/map-container-test.js","skipped":false,"dir":"test"},{"name":"MapControlFactory - display options","suites":[],"updatePoint":{"line":46,"column":41,"index":2585},"line":46,"code":"test('MapControlFactory - display options', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, initialProps)));\n  }, 'Map Container should not fail without props');\n\n  // wrapper\n  // MapControl\n  t.equal(wrapper.find(MapControl).length, 1, 'Should render MapControl');\n\n  // layer selector is not active\n  t.equal(wrapper.find(MapControlButton).length, 5, 'Should show 5 MapControlButton');\n  t.equal(wrapper.find(Split).length, 1, 'Should show 1 split map button');\n  t.equal(wrapper.find(Cube3d).length, 1, 'Should show 1 toggle 3d button');\n  t.equal(wrapper.find(Legend).length, 1, 'Should show 1 map legend button');\n  t.equal(wrapper.find(DrawPolygon).length, 1, 'Should show 1 map draw button');\n  t.equal(wrapper.find('.map-control-button__locale').length, 1, 'Should show 1 locale  button');\n\n  // with split map and active layer selector\n  const propsWithSplitMap = mapFieldsSelector(mockKeplerPropsWithState({\n    state: StateWSplitMaps\n  }));\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapContainer, propsWithSplitMap)\n  });\n\n  // 5 control buttons as legend is opened automatically in split map mode\n  t.equal(wrapper.find(MapControlButton).length, 5, 'Should show 5 MapControlButton');\n  t.equal(wrapper.find(Split).length, 0, 'Should show 0 split map split button');\n  t.equal(wrapper.find(Delete).length, 1, 'Should show 1 split map delete button');\n  t.equal(wrapper.find(Layers).length, 1, 'Should show 1 Layer button');\n\n  // with 0 mapcontrols\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapContainer, _extends({}, propsWithSplitMap, {\n      mapControls: {}\n    }))\n  });\n  t.equal(wrapper.find(MapControlButton).length, 0, 'Should show 0 MapControlButton');\n  t.end();\n});","file":"browser/components/map/map-control-test.js","skipped":false,"dir":"test"},{"name":"MapControlFactory - click options","suites":[],"updatePoint":{"line":87,"column":39,"index":4452},"line":87,"code":"test('MapControlFactory - click options', t => {\n  const onToggleSplitMap = sinon.spy();\n  const onTogglePerspective = sinon.spy();\n  const onToggleMapControl = sinon.spy();\n  const onSetEditorMode = sinon.spy();\n  const onToggleEditorVisibility = sinon.spy();\n  const onSetLocale = sinon.spy();\n  const visStateActions = {\n    setEditorMode: onSetEditorMode,\n    toggleEditorVisibility: onToggleEditorVisibility\n  };\n  const mapStateActions = {\n    toggleSplitMap: onToggleSplitMap,\n    togglePerspective: onTogglePerspective\n  };\n  const uiStateActions = {\n    toggleMapControl: onToggleMapControl,\n    setLocale: onSetLocale\n  };\n  let updateState = keplerGlReducerCore(StateWSplitMaps, toggleMapControl('mapLegend', 0));\n  const mapContainerProps = mapFieldsSelector(mockKeplerPropsWithState({\n    state: updateState,\n    visStateActions,\n    mapStateActions,\n    uiStateActions\n  }));\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, mapContainerProps)));\n  }, 'MapContainer should not fail without props');\n\n  // layer selector is not active\n  t.equal(wrapper.find(MapControlButton).length, 6, 'Should show 6 MapControlButton');\n  t.equal(wrapper.find(Delete).length, 1, 'Should show 1 delete split map button');\n  // click split Map\n  wrapper.find('.map-control-button.split-map').at(0).simulate('click');\n  t.ok(onToggleSplitMap.calledOnce, 'should call onToggleSplitMap');\n  t.deepEqual(onToggleSplitMap.args[0], [0], 'should call onToggleSplitMap with mapindex');\n\n  // click toggle3d\n  wrapper.find('.map-control-button.toggle-3d').at(0).simulate('click');\n  t.ok(onTogglePerspective.calledOnce, 'should call onTogglePerspective');\n\n  // click map legend\n  wrapper.find('.map-control-button.show-legend').at(0).simulate('click');\n  t.equal(wrapper.find(MapLegend).length, 1, 'should render MapLegend');\n\n  // click map draw\n  wrapper.find('.map-control-button.map-draw').at(0).simulate('click');\n  t.equal(wrapper.find(MapLegend).length, 1, 'should render MapLegend');\n  t.ok(onToggleMapControl.calledOnce, 'should call onToggleMapControl');\n  t.deepEqual(onToggleMapControl.args[0], ['mapDraw', 0], 'should call onToggleMapControl with mapDraw');\n\n  // click locale\n  wrapper.find('.map-control-button.locale-panel').at(0).simulate('click');\n  t.ok(onToggleMapControl.calledTwice, 'should call onToggleMapControl');\n  t.deepEqual(onToggleMapControl.args[1], ['mapLocale', 0], 'should call onToggleMapControl with mapLocale');\n\n  // click layer selector\n  wrapper.find('.map-control-button.toggle-layer').at(0).simulate('click');\n  t.ok(onToggleMapControl.calledThrice, 'should call onToggleMapControl');\n  t.deepEqual(onToggleMapControl.args[2], ['visibleLayers', 0], 'should call onToggleMapControl with visibleLayers');\n  t.end();\n});","file":"browser/components/map/map-control-test.js","skipped":false,"dir":"test"},{"name":"MapControlFactory - show panels","suites":[],"updatePoint":{"line":151,"column":37,"index":7319},"line":151,"code":"test('MapControlFactory - show panels', t => {\n  // show legend\n  let updateState = keplerGlReducerCore(StateWFiles, toggleMapControl('mapLegend', 0));\n  let mapContainerProps = mapFieldsSelector(mockKeplerPropsWithState({\n    state: updateState\n  }));\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapContainer, mapContainerProps)));\n  }, 'MapContainer should not fail without props');\n\n  // show legend\n  t.equal(wrapper.find(MapLegend).length, 1, 'should render 1 MapLegend');\n\n  // show layer selector\n  const toggleLayerForMap = sinon.spy();\n  const visStateActions = {\n    toggleLayerForMap\n  };\n  updateState = keplerGlReducerCore(StateWSplitMaps, toggleMapControl('visibleLayers', 1));\n  mapContainerProps = mapFieldsSelector(mockKeplerPropsWithState({\n    state: updateState,\n    visStateActions\n  }));\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapContainer, _extends({}, mapContainerProps, {\n      index: 1\n    }))\n  });\n\n  // click layer selector\n  t.equal(wrapper.find(MapLayerSelector).length, 1, 'should render 1 MapLayerSelector');\n  t.equal(wrapper.find('.map-layer-selector__item').length, Object.keys(updateState.visState.splitMaps[1].layers).length, 'MapLayerSelector should render correct number of layers');\n  wrapper.find('input').at(0).simulate('change');\n  t.ok(toggleLayerForMap.calledOnce, 'should call toggleLayerForMap');\n  t.deepEqual(toggleLayerForMap.args[0], [1, 'point-0'], 'should call toggleLayerForMap with mapIndex and layerid');\n  // show map draw panel\n  updateState = keplerGlReducerCore(StateWSplitMaps, toggleMapControl('mapDraw', 1));\n  mapContainerProps = mapFieldsSelector(mockKeplerPropsWithState({\n    state: updateState\n  }));\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapContainer, _extends({}, mapContainerProps, {\n      index: 1\n    }))\n  });\n  t.equal(wrapper.find(MapControlToolbar).length, 1, 'should render 1 MapControlToolbar');\n  t.equal(wrapper.find(MapControlToolbar).at(0).find(ToolbarItem).length, 3, 'should render 3 ToolbarItem');\n\n  // show locale\n  updateState = keplerGlReducerCore(StateWSplitMaps, toggleMapControl('mapLocale', 1));\n  mapContainerProps = mapFieldsSelector(mockKeplerPropsWithState({\n    state: updateState\n  }));\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapContainer, _extends({}, mapContainerProps, {\n      index: 1\n    }))\n  });\n  t.equal(wrapper.find(MapControlToolbar).length, 1, 'should render 1 MapControlToolbar');\n  t.equal(wrapper.find(MapControlToolbar).at(0).find(ToolbarItem).length, Object.keys(LOCALE_CODES).length, `should render ${Object.keys(LOCALE_CODES).length} LOCALE_CODES`);\n  Object.keys(LOCALE_CODES).forEach((locale, index) => {\n    t.equal(wrapper.find(MapControlToolbar).at(0).find(ToolbarItem).at(index).find('.toolbar-item__title').text(), LOCALES[locale], 'should render correct locale');\n  });\n  t.end();\n});","file":"browser/components/map/map-control-test.js","skipped":false,"dir":"test"},{"name":"Components -> MapLegend.render","suites":[],"updatePoint":{"line":29,"column":36,"index":1765},"line":29,"code":"test('Components -> MapLegend.render', t => {\n  t.doesNotThrow(() => {\n    mount( /*#__PURE__*/React.createElement(MapLegend, null));\n  }, 'Show not fail without data');\n  t.end();\n});","file":"browser/components/map/map-legend-test.js","skipped":false,"dir":"test"},{"name":"Components -> MapLegend.render -> with layers","suites":[],"updatePoint":{"line":35,"column":51,"index":1965},"line":35,"code":"test('Components -> MapLegend.render -> with layers', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n  const {\n    layers\n  } = initialState.visState;\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapLegend, {\n      layers: layers\n    })));\n  }, 'Show not fail with layers');\n  t.equal(wrapper.find(StyledMapControlLegend).length, layers.length, 'should render 3 layer legends');\n  const pointLegend = wrapper.find(StyledMapControlLegend).at(0);\n  const geojsonLegend = wrapper.find(StyledMapControlLegend).at(1);\n  const hexagonLegend = wrapper.find(StyledMapControlLegend).at(2);\n  testPointLayerLegend(t, pointLegend);\n  testGeojsonLegend(t, geojsonLegend);\n  testHexagonLayerLegend(t, hexagonLegend);\n  t.end();\n});","file":"browser/components/map/map-legend-test.js","skipped":false,"dir":"test"},{"name":"Map Popover - render","suites":[],"updatePoint":{"line":42,"column":26,"index":2093},"line":42,"code":"test('Map Popover - render', t => {\n  const onClose = sinon.spy();\n  defaultProps.onClose = onClose;\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapPopover, defaultProps)));\n  }, 'Should render');\n  t.equal(wrapper.find(MapPopover).length, 1, 'Should display 1 MapPopover');\n  t.equal(wrapper.find('.coordingate-hover-info').length, 0, 'Should display 0 coordinates');\n  t.equal(wrapper.find('.map-popover__layer-info').length, 0, 'Should display 0 layer info');\n  t.equal(wrapper.find(Pin).length, 0, 'Should display 0 pin');\n  t.equal(wrapper.find('.primary-label').length, 0, 'Should display 0 primary label');\n  t.equal(wrapper.find('.select-geometry').length, 0, 'Should not display select geometry for point layer');\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapPopover, _extends({}, defaultProps, {\n      isBase: true,\n      frozen: true\n    }))\n  });\n  t.equal(wrapper.find(Pin).length, 1, 'Should display 1 pin');\n  t.equal(wrapper.find('.primary-label').length, 1, 'Should display 1 primary label');\n  t.equal(wrapper.find('.select-geometry').length, 0, 'Should not display select geometry for point layer');\n\n  // click pin\n  wrapper.find('.popover-pin').at(0).simulate('click');\n  t.ok(onClose.called, 'should call onClose when click pin');\n  // render coordinate\n  wrapper.setProps({\n    children: /*#__PURE__*/React.createElement(MapPopover, _extends({}, defaultProps, {\n      coordinate: [127.12345678, -31.12345678],\n      zoom: 12.123\n    }))\n  });\n  t.equal(wrapper.find('CoordinateInfo').length, 1, 'Should render CoordinateInfo');\n  t.equal(wrapper.find('.row__value').at(0).text(), '-31.123457,', 'should render lat');\n  t.equal(wrapper.find('.row__value').at(1).text(), '127.123457,', 'should render longitude');\n  t.equal(wrapper.find('.row__value').at(2).text(), '12.1z', 'should render zoom');\n  t.end();\n});","file":"browser/components/map/map-popover-test.js","skipped":false,"dir":"test"},{"name":"Map Popover - render with layerHoverProp","suites":[],"updatePoint":{"line":81,"column":46,"index":4084},"line":81,"code":"test('Map Popover - render with layerHoverProp', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapPopover, _extends({}, defaultProps, {\n      layerHoverProp: layerHoverProp\n    }))));\n  }, 'Should render map popover with layerHoverProps');\n  t.equal(wrapper.find('LayerHoverInfo').length, 1, 'Should render LayerHoverInfo');\n  t.equal(wrapper.find('table').length, 1, 'Should render 1 table');\n  const table = wrapper.find('table').at(0);\n  const rows = table.find('.layer-hover-info__row');\n  t.equal(rows.length, 5, 'should render 5 rows');\n  const expectedTooltips = [['gps_data.utc_timestamp', '2016-09-17 00:24:24'], ['gps_data.types', 'driver_analytics'], ['epoch', '1472754400000'], ['has_result', ''], ['uid', '1']];\n  for (let i = 0; i < 5; i++) {\n    t.equal(rows.at(i).find('.row__name').text(), expectedTooltips[i][0], 'row name should be correct');\n    t.equal(rows.at(i).find('.row__value').text(), expectedTooltips[i][1], 'row value should be correct');\n  }\n  t.end();\n});","file":"browser/components/map/map-popover-test.js","skipped":false,"dir":"test"},{"name":"Map Popover - render with geojsonLayerHoverProp","suites":[],"updatePoint":{"line":100,"column":53,"index":5195},"line":100,"code":"test('Map Popover - render with geojsonLayerHoverProp', t => {\n  const setSelectedFeature = sinon.spy();\n  const onSetFeatures = sinon.spy();\n  const onClose = sinon.spy();\n  defaultProps.setSelectedFeature = setSelectedFeature;\n  defaultProps.onSetFeatures = onSetFeatures;\n  defaultProps.onClose = onClose;\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(MapPopover, _extends({}, defaultProps, {\n      isBase: true,\n      frozen: true,\n      layerHoverProp: geojsonLayerHoverProp\n    }))));\n  }, 'Should render map popover with geojsonLayerHoverProp');\n  t.equal(wrapper.find(MapPopover).length, 1, 'Should display 1 MapPopover');\n  t.equal(wrapper.find(Pin).length, 1, 'Should display 1 pin');\n  t.equal(wrapper.find('.primary-label').length, 1, 'Should display 1 primary label');\n\n  // click select geometry\n  wrapper.find('.select-geometry').at(0).simulate('click');\n  t.ok(setSelectedFeature.called, 'should call setSelectedFeature when click select geometry');\n  t.ok(onSetFeatures.called, 'should call onSetFeatures when click select geometry');\n  t.end();\n});","file":"browser/components/map/map-popover-test.js","skipped":false,"dir":"test"},{"name":"Compnents -> DataTableConfig","suites":[],"updatePoint":{"line":143,"column":34,"index":4767},"line":143,"code":"test('Compnents -> DataTableConfig', t => {\n  const expectedColumns = ['gps_data.utc_timestamp'];\n  const expectedColMeta = {\n    'gps_data.utc_timestamp': {\n      name: 'gps_data.utc_timestamp',\n      type: 'timestamp',\n      format: 'YYYY-M-D H:m:s'\n    }\n  };\n  const columns = expectedColumns;\n  const colMeta = expectedColMeta;\n  const setColumnDisplayFormat = sinon.spy();\n  const onClose = sinon.spy();\n  const DataTableConfig = DataTableConfigFactory();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(DataTableConfig, {\n      columns: columns,\n      colMeta: colMeta,\n      setColumnDisplayFormat: setColumnDisplayFormat,\n      onClose: onClose\n    })));\n  }, 'Show not fail without props');\n  const numberFormatConfigInput = wrapper.find(NumberFormatConfig);\n  t.equal(numberFormatConfigInput.length, 5, 'should render 5 NumberFormatConfig');\n  numberFormatConfigInput.at(0).find(InputLight).simulate('click');\n  const formatDropdown = wrapper.find(DropdownList);\n  t.equal(formatDropdown.length, 1, 'should render 1 format dropdown');\n  const integerDisplayOptions = formatDropdown.at(0).props().options;\n  t.deepEqual(integerDisplayOptions, getFieldFormatLabels('integer'), 'should render integer type formats');\n  numberFormatConfigInput.at(1).find(InputLight).simulate('click');\n  const floatDisplayOptions = wrapper.find(DropdownList).at(1).props().options;\n  t.deepEqual(floatDisplayOptions, getFieldFormatLabels('real'), 'should render real type formats');\n  numberFormatConfigInput.at(2).find(InputLight).simulate('click');\n  const timeDisplayOptions = wrapper.find(DropdownList).at(2).props().options;\n  t.deepEqual(timeDisplayOptions, getFieldFormatLabels('timestamp'), 'should render time type formats');\n  numberFormatConfigInput.at(3).find(InputLight).simulate('click');\n  const dateDisplayOptions = wrapper.find(DropdownList).at(3).props().options;\n  t.deepEqual(dateDisplayOptions, getFieldFormatLabels('date'), 'should render date type formats');\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DataTableModal.render: csv 1","suites":[],"updatePoint":{"line":186,"column":48,"index":6913},"line":186,"code":"test('Components -> DataTableModal.render: csv 1', t => {\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, null));\n  }, 'Show not fail without data');\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: StateWFiles.visState.datasets,\n    dataId: testCsvDataId\n  }));\n  t.equal(wrapper.find(DataTableModal).length, 1, 'should render DataTableModal data');\n  t.equal(wrapper.find(DatasetTabs).length, 1, 'should render DatasetTabs');\n  t.equal(wrapper.find(DatasetModalTab).length, 2, 'should render 1 DatasetModalTab');\n  t.equal(wrapper.find(DataTable).length, 1, 'should render 1 DataTable');\n  const props = wrapper.find(DataTable).at(0).props();\n  const expectedColumns = ['gps_data.utc_timestamp', 'gps_data.lat', 'gps_data.lng', 'gps_data.types', 'epoch', 'has_result', 'uid', 'time', 'begintrip_ts_utc', 'begintrip_ts_local', 'date'];\n  const expectedColMeta = {\n    'gps_data.utc_timestamp': {\n      name: 'gps_data.utc_timestamp',\n      type: 'timestamp',\n      format: 'YYYY-M-D H:m:s'\n    },\n    'gps_data.lat': {\n      name: 'gps_data.lat',\n      type: 'real'\n    },\n    'gps_data.lng': {\n      name: 'gps_data.lng',\n      type: 'real'\n    },\n    'gps_data.types': {\n      name: 'gps_data.types',\n      type: 'string'\n    },\n    epoch: {\n      name: 'epoch',\n      type: 'timestamp',\n      format: 'X'\n    },\n    has_result: {\n      name: 'has_result',\n      type: 'boolean'\n    },\n    uid: {\n      name: 'uid',\n      type: 'integer'\n    },\n    time: {\n      name: 'time',\n      type: 'timestamp',\n      format: 'YYYY-M-DTHH:mm:ss.SSSS'\n    },\n    begintrip_ts_utc: {\n      name: 'begintrip_ts_utc',\n      type: 'timestamp',\n      format: 'YYYY-M-D HH:mm:ssZZ'\n    },\n    begintrip_ts_local: {\n      name: 'begintrip_ts_local',\n      type: 'timestamp',\n      format: 'YYYY-M-D HH:mm:ssZZ'\n    },\n    date: {\n      name: 'date',\n      type: 'date',\n      format: 'YYYY-M-D'\n    }\n  };\n  t.deepEqual(props.columns, expectedColumns, 'DataTable should have the correct props.columns');\n  t.deepEqual(props.colMeta, expectedColMeta, 'DataTable should have the correct props.colMeta');\n  const datasetId = Object.keys(StateWFiles.visState.datasets)[0];\n  t.equal(props.dataContainer, StateWFiles.visState.datasets[datasetId].dataContainer, 'DataTable should have the correct props.dataContainer');\n  // we can't test it without mocking the canvas response\n  t.deepEqual(Object.keys(props.cellSizeCache), Object.keys(expectedColMeta), 'DataTable props.cellSizeCache should have all column keys');\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DataTableModal -> click tab","suites":[],"updatePoint":{"line":260,"column":47,"index":9520},"line":260,"code":"test('Components -> DataTableModal -> click tab', t => {\n  const showDatasetTable = sinon.spy();\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: StateWFiles.visState.datasets,\n    dataId: testCsvDataId,\n    showDatasetTable: showDatasetTable\n  }));\n  t.equal(wrapper.find(DatasetModalTab).length, 2, 'should render 2 DatasetModalTab');\n  t.equal(wrapper.find(DatasetModalTab).at(0).prop('active'), true, 'prop 0 active should be true');\n  t.equal(wrapper.find(DatasetModalTab).at(0).find('.dataset-name').text(), 'hello.csv', 'dataset name should be correct');\n  t.equal(wrapper.find(DatasetModalTab).at(1).prop('active'), false, 'prop 1 active should be true');\n  t.equal(wrapper.find(DatasetModalTab).at(1).find('.dataset-name').text(), 'zip.geojson', 'dataset name should be correct');\n  wrapper.find(DatasetModalTab).at(1).simulate('click');\n  t.ok(showDatasetTable.calledWith(testGeoJsonDataId));\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DataTableModal -> render DataTable: csv 1","suites":[],"updatePoint":{"line":276,"column":61,"index":10502},"line":276,"code":"test('Components -> DataTableModal -> render DataTable: csv 1', t => {\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: StateWFiles.visState.datasets,\n    dataId: testCsvDataId\n  }));\n  t.equal(wrapper.find(DataTable).length, 1, 'should render 1 DataTable');\n  const props = wrapper.find(DataTable).at(0).props();\n\n  // mock cellSizeCache, width and height\n  const enriched = {\n    ...props,\n    cellSizeCache: expectedCellSizeCache,\n    fixedWidth: 1500,\n    fixedHeight: 800,\n    theme: {}\n  };\n  const wrapper2 = mountWithTheme( /*#__PURE__*/React.createElement(DataTable, enriched));\n  const componentInstance = wrapper2.find('DataTable').instance();\n  const result = componentInstance.getCellSizeCache();\n  t.deepEqual(result, expectedExpandedCellSize, 'should calculate correct cell expansion');\n\n  // manully setting the state and update the component\n  componentInstance.setState(result);\n  wrapper2.update();\n  t.equal(wrapper2.find('.header-cell').length, testFields.length * 3, `should render ${testFields.length} headers`);\n  t.equal(wrapper2.find('.cell').length, testFields.length * testAllData.length, `should render ${testFields.length * testAllData.length} cells`);\n  const expectedRows = {\n    0: ['2016-09-17 00:09:55\\t', '29.9900937\\t', '31.2590542\\t', 'driver_analytics_0\\t', '1472688000000\\t', 'false\\t', '1\\t', '2016-09-23T00:00:00.000Z\\t', '2016-10-01 09:41:39+00:00\\t', '2016-10-01 09:41:39+00:00\\t', '2016-09-23\\n'],\n    1: ['2016-09-17 00:10:56\\t', '29.9927699\\t', '31.2461142\\t', 'driver_analytics\\t', '1472688000000\\t', 'false\\t', '2\\t', '2016-09-23T00:00:00.000Z\\t', '2016-10-01 09:46:37+00:00\\t', '2016-10-01 16:46:37+00:00\\t', '2016-09-23\\n'],\n    2: ['2016-09-17 00:11:56\\t', '29.9907261\\t', '31.2312742\\t', 'driver_analytics\\t', '1472688000000\\t', 'false\\t', '3\\t', '2016-09-23T00:00:00.000Z\\t', '\\t', '\\t', '2016-09-23\\n'],\n    13: ['2016-09-17 00:22:20\\t', '30.034391\\t', '31.2193991\\t', 'driver_analytics\\t', '1472754400000\\t', '\\t', '\\t', '2016-09-23T06:00:00.000Z\\t', '\\t', '\\t', '\\n']\n  };\n  Object.entries(expectedRows).forEach(keyAndRow => {\n    const [index, expectedRow] = keyAndRow;\n    const cells = wrapper2.find(`.row-${index}`);\n    t.equal(cells.length, testFields.length, 'should render 11 cells');\n    for (let c = 0; c < cells.length; c++) {\n      const cellText = cells.at(c).text();\n      t.equal(cellText, expectedRow[c], `should render cell ${expectedRow[c]} correctly`);\n    }\n  });\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DataTableModal -> render DataTable: sort, pin and display format","suites":[],"updatePoint":{"line":319,"column":84,"index":13031},"line":319,"code":"test('Components -> DataTableModal -> render DataTable: sort, pin and display format', t => {\n  const initialState = CloneDeep(StateWFiles.visState);\n\n  // set display format\n  const formats = {\n    'gps_data.lat': TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format\n  };\n  const nextState = visStateReducer(initialState, VisStateActions.setColumnDisplayFormat(testCsvDataId, formats));\n\n  // sort column\n  const nextState1 = visStateReducer(nextState, VisStateActions.sortTableColumn(testCsvDataId, 'gps_data.lat'));\n\n  // pin column\n  const nextState2 = visStateReducer(nextState1, VisStateActions.pinTableColumn(testCsvDataId, 'has_result'));\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: nextState2.datasets,\n    dataId: testCsvDataId\n  }));\n  const props = wrapper.find(DataTable).at(0).props();\n\n  // mock cellSizeCache, width and height\n  const enriched = {\n    ...props,\n    cellSizeCache: expectedCellSizeCache,\n    fixedWidth: 1300,\n    fixedHeight: 800,\n    theme: {}\n  };\n  const wrapper2 = mountWithTheme( /*#__PURE__*/React.createElement(DataTable, enriched));\n  const componentInstance = wrapper2.find('DataTable').instance();\n  const result = componentInstance.getCellSizeCache();\n  // manually setting the state and update the component\n  componentInstance.setState(result);\n  wrapper2.update();\n  const expectedHeaders = ['has_result', 'gps_data.utc_timestamp', 'gps_data.lat', 'gps_data.lng', 'gps_data.types', 'epoch', 'uid', 'time', 'begintrip_ts_utc', 'begintrip_ts_local', 'date'];\n  t.equal(wrapper2.find('.header-cell').length, testFields.length * 3, `should render ${testFields.length} headers`);\n  t.ok(wrapper2.find('.header-cell').at(0).hasClass('pinned-header-cell'), 'should assign pinned-header-cell class');\n  t.ok(wrapper2.find('.header-cell').at(0).hasClass('first-cell'), 'should assign first-cell class');\n  new Array(testFields.length).fill(0).forEach((d, i) => {\n    t.equal(wrapper2.find('.header-cell').at(i * 3).find('.col-name__name').text(), expectedHeaders[i], 'should render corrected pinned columns');\n  });\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DatableModal -> sort/pin/copy and display format should be called with the right params","suites":[],"updatePoint":{"line":362,"column":107,"index":15172},"line":362,"code":"test('Components -> DatableModal -> sort/pin/copy and display format should be called with the right params', t => {\n  const initialState = CloneDeep(StateWFiles.visState);\n  const copyTableColumn = sinon.spy();\n  const pinTableColumn = sinon.spy();\n  const sortTableColumn = sinon.spy();\n  const setColumnDisplayFormat = sinon.spy();\n  const column = 'gps_data.lat';\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: initialState.datasets,\n    dataId: testCsvDataId,\n    copyTableColumn: copyTableColumn,\n    pinTableColumn: pinTableColumn,\n    sortTableColumn: sortTableColumn,\n    setColumnDisplayFormat: setColumnDisplayFormat\n  }));\n  const {\n    sortTableColumn: testSortColumn,\n    pinTableColumn: testPinColumn,\n    copyTableColumn: testCopyColumn,\n    setColumnDisplayFormat: testSetColumnDisplayFormat\n  } = wrapper.find('DataTable').props();\n  testSortColumn(column);\n  testPinColumn(column);\n  testCopyColumn(column);\n  testSetColumnDisplayFormat({\n    [column]: TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format\n  });\n  t.equal(sortTableColumn.calledWith(testCsvDataId, column), true, 'should call sortTableColumn with dataId and column gps_data.lat');\n  t.equal(pinTableColumn.calledWith(testCsvDataId, column), true, 'should call pinTableColumn with dataId and column gps_data.lat');\n  t.equal(copyTableColumn.calledWith(testCsvDataId, column), true, 'should call copyTableColumn with dataId and column gps_data.lat');\n  t.equal(setColumnDisplayFormat.calledWith(testCsvDataId, {\n    [column]: TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format\n  }), true, 'should call setColumnDisplayFormat with dataId, column gps_data.lat, and format');\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> cellSize -> renderedSize","suites":[],"updatePoint":{"line":397,"column":44,"index":16822},"line":397,"code":"test('Components -> cellSize -> renderedSize', t => {\n  prepareMockCanvas();\n  const fields = [{\n    name: testColumns[0],\n    type: 'geojson'\n  }, {\n    name: testColumns[1],\n    type: 'real'\n  }, {\n    name: testColumns[2],\n    type: 'string'\n  }];\n  const dataContainer = createDataContainer(texts, {\n    fields\n  });\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: {\n      smoothie: {\n        id: 'smoothie',\n        dataContainer,\n        fields: [{\n          name: testColumns[0],\n          type: 'geojson',\n          displayName: testColumns[0]\n        }, {\n          name: testColumns[1],\n          type: 'real',\n          displayName: testColumns[1]\n        }, {\n          name: testColumns[2],\n          type: 'string',\n          displayName: testColumns[2]\n        }],\n        color: [113, 113, 113]\n      }\n    },\n    dataId: \"smoothie\"\n  }));\n  const props = wrapper.find(DataTable).at(0).props();\n  const expected = {\n    _geojson: {\n      row: 500,\n      header: 186\n    },\n    'income level of people over 65': {\n      row: 162,\n      header: 223\n    },\n    engagement: {\n      row: 162,\n      header: 186\n    }\n  };\n  t.deepEqual(props.cellSizeCache, expected, 'DataTable should have the correct props.cellSizeCache');\n  restoreMockCanvas();\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> DataTableModal.render: csv 2","suites":[],"updatePoint":{"line":454,"column":48,"index":18151},"line":454,"code":"test('Components -> DataTableModal.render: csv 2', t => {\n  const dataContainer = createDataContainer(geoStyleRows, {\n    fields: geoStyleFields\n  });\n\n  // manually set display format on the 5th field: radius (.2~e)\n  const fieldsWithDisplayFormat = geoStyleFields;\n  fieldsWithDisplayFormat[5].displayFormat = TOOLTIP_FORMATS.DECIMAL_SCIENTIFIC_FIXED_2.format;\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(DataTableModal, {\n    datasets: {\n      smoothie: {\n        id: 'smoothie',\n        dataContainer,\n        fields: fieldsWithDisplayFormat,\n        color: [113, 113, 113],\n        data: geoStyleRows\n      }\n    },\n    dataId: \"smoothie\"\n  }));\n  const props = wrapper.find(DataTable).at(0).props();\n  const cellSizeCache = {\n    _geojson: {\n      row: 400,\n      header: 91\n    },\n    fillColor: {\n      row: 75,\n      header: 90\n    },\n    lineColor: {\n      row: 75,\n      header: 94\n    },\n    lineWidth: {\n      row: 75,\n      header: 98\n    },\n    elevation: {\n      row: 75,\n      header: 94\n    },\n    radius: {\n      row: 75,\n      header: 90\n    }\n  };\n  const enriched = {\n    ...props,\n    cellSizeCache,\n    fixedWidth: 1200,\n    fixedHeight: 800,\n    theme: {}\n  };\n  const expectedExpandedCellSizeGeo = {\n    cellSizeCache: {\n      _geojson: 410,\n      fillColor: 90,\n      lineColor: 94,\n      lineWidth: 98,\n      elevation: 94,\n      radius: 90\n    },\n    ghost: 324\n  };\n  const wrapper2 = mountWithTheme( /*#__PURE__*/React.createElement(DataTable, enriched));\n  const componentInstance = wrapper2.find('DataTable').instance();\n  const result = componentInstance.getCellSizeCache();\n  t.deepEqual(result, expectedExpandedCellSizeGeo, 'should calculate correct cell expansion');\n  componentInstance.setState(result);\n  wrapper2.update();\n  t.equal(wrapper2.find('.header-cell').length, 21, `should render 7 header cells`);\n\n  // test header cell\n  const expectedHeaders = [geoStyleFields[0].name, geoStyleFields[1].name, geoStyleFields[2].name, geoStyleFields[3].name, geoStyleFields[4].name, geoStyleFields[5].name, ''];\n  expectedHeaders.forEach((name, index) => {\n    const header = wrapper2.find(`.header-cell.column-${index}`);\n    t.equal(header.length, 3, 'should render 1 header');\n    if (index < 6) {\n      const cellText = header.find('.col-name__name').text();\n      t.equal(cellText, expectedHeaders[index], 'should render correct column name');\n      const cellType = header.find(FieldToken);\n      t.equal(cellType.prop('type'), geoStyleFields[index].type, 'should render correct cell type');\n      t.equal(header.find(VertThreeDots).length, 1, 'should render more button');\n      t.equal(header.find(OptionDropdown).length, 1, 'should render OptionDropdown');\n    } else {\n      // if ghost cell\n      t.equal(header.at(2).text(), '', 'cell should be empty');\n    }\n  });\n  t.equal(wrapper2.find('.cell').length, 21, `should render 21 data cells`);\n  const expectedRows = {\n    0: ['{\"type\":\"Feature\",\"properties\":{\"fillColor\":[1,2,3],\"lineColor\":[4,5,6],\"lineWidth\":1,\"elevation\":10,\"radius\":5},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-122.1,37.3]}}\\t', '[1,2,3]\\t', '[4,5,6]\\t', '1\\t', '10\\t', '5e+0\\t', '\\n'],\n    1: ['{\"type\":\"Feature\",\"properties\":{\"fillColor\":[7,8,9],\"lineColor\":[4,5,6],\"lineWidth\":3,\"elevation\":10,\"radius\":5},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-122.2,37.2]}}\\t', '[7,8,9]\\t', '[4,5,6]\\t', '3\\t', '10\\t', '5e+0\\t', '\\n'],\n    2: ['{\"type\":\"Feature\",\"properties\":{\"fillColor\":[1,2,3],\"lineColor\":[4,5,6],\"lineWidth\":4,\"elevation\":10,\"radius\":5},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-122.3,37.1]}}\\t', '[1,2,3]\\t', '[4,5,6]\\t', '4\\t', '10\\t', '5e+0\\t', '\\n']\n  };\n  Object.entries(expectedRows).forEach(keyAndRow => {\n    const [index, expectedRow] = keyAndRow;\n    const cells = wrapper2.find(`.row-${index}`);\n    t.equal(cells.length, 7, 'should render 6 cells and 1 ghost cell');\n    for (let c = 0; c < cells.length; c++) {\n      const cellText = cells.at(c).text();\n      t.equal(cellText, expectedRow[c], `should render cell ${expectedRow[c]} correctly`);\n    }\n  });\n  t.end();\n});","file":"browser/components/modals/data-table-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ExportImageModal.mount","suites":[],"updatePoint":{"line":28,"column":42,"index":1558},"line":28,"code":"test('Components -> ExportImageModal.mount', t => {\n  const onUpdateImageSetting = sinon.spy();\n  const cleanupExportImage = () => {};\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ExportImageModal, {\n      mapW: 500,\n      mapH: 500,\n      exportImage: INITIAL_UI_STATE.exportImage,\n      onUpdateImageSetting: onUpdateImageSetting,\n      cleanupExportImage: cleanupExportImage\n    })));\n  }, 'Show not fail with props');\n  t.ok(onUpdateImageSetting.calledTwice, 'should call onUpdateImageSetting when mount');\n  t.deepEqual(onUpdateImageSetting.args, [[{\n    exporting: true\n  }], [{\n    mapH: 500,\n    mapW: 500\n  }]]);\n  t.equal(wrapper.find(ImagePreview).length, 1, 'should render ImagePreview');\n  const ratioOpts = wrapper.find('#export-image-modal__option_ratio').at(0).find(SelectionButton).map(c => c.text());\n  t.deepEqual(ratioOpts, ['Original Screen', '4:3', '16:9'], 'should render correct ratio options');\n  t.ok(wrapper.find('#export-image-modal__option_ratio').at(0).find(SelectionButton).at(0).props('selected'), 'first option should be selected');\n  wrapper.find('#export-image-modal__option_ratio').at(0).find(SelectionButton).at(0).simulate('click');\n  t.ok(onUpdateImageSetting.calledWith({\n    ratio: 'SCREEN'\n  }), 'should call update ratio');\n  const resolutionOpts = wrapper.find('#export-image-modal__option_resolution').at(0).find(SelectionButton).map(c => c.text());\n  t.deepEqual(resolutionOpts, ['1x', '2x'], 'should render correct ratio options');\n  t.ok(wrapper.find('#export-image-modal__option_resolution').at(0).find(SelectionButton).at(0).props('selected'), 'first option should be selected');\n  wrapper.find('#export-image-modal__option_resolution').at(0).find(SelectionButton).at(1).simulate('click');\n  t.ok(onUpdateImageSetting.calledWith({\n    resolution: 'TWO_X'\n  }), 'should call update resolution');\n  t.end();\n});","file":"browser/components/modals/export-image-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ExportImageModal.preview image","suites":[],"updatePoint":{"line":65,"column":50,"index":3536},"line":65,"code":"test('Components -> ExportImageModal.preview image', t => {\n  const onUpdateImageSetting = sinon.spy();\n  const cleanupExportImage = () => {};\n  const imageDataUri = 'data:image/png;base64,2i3u';\n  const exportImage = {\n    ...INITIAL_UI_STATE.exportImage,\n    imageDataUri,\n    imageSize: {\n      imageH: 500,\n      imageW: 500\n    }\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ExportImageModal, {\n      mapW: 500,\n      mapH: 500,\n      exportImage: exportImage,\n      onUpdateImageSetting: onUpdateImageSetting,\n      cleanupExportImage: cleanupExportImage\n    })));\n  }, 'Show not fail with exportImage.imageDataUri');\n  t.equal(wrapper.find('.preview-image-placeholder').html(), '<img class=\"preview-image-placeholder\" src=\"data:image/png;base64,2i3u\">', 'should render image with src');\n  t.equal(wrapper.find('.preview-image').html(), '<div class=\"preview-image\" style=\"width: 400px; height: 400px;\"><img class=\"preview-image-placeholder\" src=\"data:image/png;base64,2i3u\"></div>', 'should render preview image with src');\n  t.end();\n});","file":"browser/components/modals/export-image-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ExportImageModal.unmount","suites":[],"updatePoint":{"line":91,"column":44,"index":4690},"line":91,"code":"test('Components -> ExportImageModal.unmount', t => {\n  const onUpdateImageSetting = () => {};\n  const cleanupExportImage = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ExportImageModal, {\n      mapW: 500,\n      mapH: 500,\n      exportImage: INITIAL_UI_STATE.exportImage,\n      onUpdateImageSetting: onUpdateImageSetting,\n      cleanupExportImage: cleanupExportImage\n    })));\n  }, 'Show not fail with props');\n  t.ok(cleanupExportImage.notCalled, 'should not call cleanupExportImage when mount');\n  wrapper.unmount();\n  t.ok(cleanupExportImage.calledOnce, 'should call cleanupExportImage when unmount');\n  t.end();\n});","file":"browser/components/modals/export-image-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> LoadDataModal.mount","suites":[],"updatePoint":{"line":27,"column":39,"index":1526},"line":27,"code":"test('Components -> LoadDataModal.mount', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LoadDataModal, null)));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find('.file-uploader').length, 3, 'should render FileUpload');\n  t.equal(wrapper.find('.load-data-modal__tab').length, 3, 'should render ModalTabs');\n  t.equal(wrapper.find(LoadStorageMap).length, 0, 'should not render LoadStorageMap');\n  t.end();\n});","file":"browser/components/modals/load-data-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> LoadDataModal -> custom loading method","suites":[],"updatePoint":{"line":38,"column":58,"index":2091},"line":38,"code":"test('Components -> LoadDataModal -> custom loading method', t => {\n  // mount\n  const MockComp = () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"taro\"\n  });\n  const MockTabComp = () => /*#__PURE__*/React.createElement(\"div\", {\n    className: \"taro's tab\"\n  });\n  const loadingMethods = [{\n    id: 'taro',\n    label: 'Taro and Blue',\n    elementType: MockComp,\n    tabElementType: MockTabComp\n  }];\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LoadDataModal, {\n      loadingMethods: loadingMethods\n    })));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find(ModalTabItem).length, 1, 'should render 1 ModalTabItem');\n  t.equal(wrapper.find(MockComp).length, 1, 'should render MockComp by default');\n  t.equal(wrapper.find(MockTabComp).length, 1, 'should render MockTabComp');\n  t.end();\n});","file":"browser/components/modals/load-data-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> LoadStorageMap.mount","suites":[],"updatePoint":{"line":29,"column":40,"index":1540},"line":29,"code":"test('Components -> LoadStorageMap.mount', t => {\n  // mount\n  const getSavedMaps = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(LoadStorageMap, {\n      getSavedMaps: getSavedMaps,\n      cloudProviders: [mockProvider],\n      currentProvider: null,\n      onSetCloudProvider: () => {}\n    }));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find('.provider-selection').length, 1, 'should render ProviderSelect');\n  t.end();\n});","file":"browser/components/modals/load-storage-map-test.js","skipped":false,"dir":"test"},{"name":"Components -> LoadStorageMap.mount","suites":[],"updatePoint":{"line":44,"column":40,"index":2045},"line":44,"code":"test('Components -> LoadStorageMap.mount', t => {\n  // mount\n  const getSavedMaps = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(LoadStorageMap, {\n      getSavedMaps: getSavedMaps,\n      cloudProviders: [mockProvider],\n      currentProvider: \"taro\",\n      onSetCloudProvider: () => {}\n    }));\n  }, 'Show not fail without props');\n  t.equal(wrapper.find('.provider-selection').length, 0, 'should not render ProviderSelect');\n  t.deepEqual(getSavedMaps.args, [[mockProvider]], 'should call getSavedMaps when mount with mockProvider');\n  t.end();\n});","file":"browser/components/modals/load-storage-map-test.js","skipped":false,"dir":"test"},{"name":"Components -> SaveMapModal.mount","suites":[],"updatePoint":{"line":29,"column":38,"index":1542},"line":29,"code":"test('Components -> SaveMapModal.mount', t => {\n  const onUpdateImageSetting = sinon.spy();\n  const onSetCloudProvider = sinon.spy();\n\n  // mount\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n      onUpdateImageSetting: onUpdateImageSetting,\n      onSetCloudProvider: onSetCloudProvider,\n      cloudProviders: [mockProvider],\n      currentProvider: \"taro\"\n    })));\n  }, 'Show not fail without props');\n  t.ok(onUpdateImageSetting.calledTwice, 'should call onUpdateImageSetting twice when mount');\n  t.deepEqual(onUpdateImageSetting.args, [[{\n    exporting: true\n  }], [{\n    mapW: 100,\n    mapH: 60,\n    ratio: 'CUSTOM',\n    legend: false\n  }]], 'should call onUpdateImageSetting when mount');\n  t.ok(onSetCloudProvider.notCalled, 'should not call onSetCloudProvider when mount');\n  t.end();\n});","file":"browser/components/modals/save-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> SaveMapModal.mount with providers","suites":[],"updatePoint":{"line":54,"column":53,"index":2454},"line":54,"code":"test('Components -> SaveMapModal.mount with providers', t => {\n  const onSetCloudProvider = sinon.spy();\n\n  // mount\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n      onUpdateSetting: () => {},\n      onSetCloudProvider: onSetCloudProvider,\n      cloudProviders: [mockProvider]\n    })));\n  }, 'Show not fail mount props');\n  t.ok(onSetCloudProvider.calledWithExactly('taro'), 'should set default provider when mount');\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n    onUpdateSetting: () => {},\n    onSetCloudProvider: onSetCloudProvider,\n    cloudProviders: [mockProvider],\n    currentProvider: \"hello\"\n  })));\n  t.ok(onSetCloudProvider.calledOnce, 'should not set default provider if it is already set');\n  t.ok(wrapper.find(CloudTile).length === 1, 'should render 1 cloud provider');\n  t.ok(wrapper.find(ImagePreview).length === 1, 'should render 1 ImagePreview');\n  t.end();\n});","file":"browser/components/modals/save-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> SaveMapModal on change input","suites":[],"updatePoint":{"line":77,"column":48,"index":3523},"line":77,"code":"test('Components -> SaveMapModal on change input', t => {\n  const onSetMapInfo = sinon.spy();\n  const eventObj = {\n    target: {\n      value: 'taro'\n    }\n  };\n  let wrapper;\n  // mount\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n      onUpdateSetting: () => {},\n      onSetMapInfo: onSetMapInfo\n    })));\n  }, 'Show not fail mount props');\n  wrapper.find('input#map-title').simulate('change', eventObj);\n  t.ok(onSetMapInfo.calledWithExactly({\n    title: 'taro'\n  }), 'should set map title');\n  wrapper.find('textarea#map-description').simulate('change', eventObj);\n  t.ok(onSetMapInfo.calledWithExactly({\n    description: 'taro'\n  }), 'should set map description');\n  t.end();\n});","file":"browser/components/modals/save-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> SaveMapModal on click provider","suites":[],"updatePoint":{"line":102,"column":50,"index":4320},"line":102,"code":"test('Components -> SaveMapModal on click provider', t => {\n  const onSetCloudProvider = sinon.spy();\n  const login = sinon.spy();\n  const logout = sinon.spy();\n  mockProvider.logout = logout;\n  const mockProvider2 = {\n    getAccessToken: () => false,\n    name: 'blue',\n    login\n  };\n  let wrapper;\n  // mount\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n      cloudProviders: [mockProvider, mockProvider2],\n      currentProvider: \"taro\",\n      onSetCloudProvider: onSetCloudProvider,\n      onUpdateSetting: () => {},\n      onUpdateImageSetting: () => {}\n    })));\n  }, 'Show not fail mount props');\n  t.equal(wrapper.find('.provider-tile__wrapper').length, 2, 'should render 1 provider tile');\n\n  // click taro to select\n  wrapper.find('.provider-tile__wrapper').at(0).simulate('click');\n  t.ok(onSetCloudProvider.calledWithExactly('taro'), 'should call onSetCloudProvider with taro');\n\n  // click blue to login\n  wrapper.find('.provider-tile__wrapper').at(1).simulate('click');\n  t.ok(login.calledOnce, 'should call login');\n\n  // call onSuccess after login to set current provider\n  const onSuccess = login.args[0][0];\n  onSuccess();\n  t.ok(onSetCloudProvider.calledWithExactly('blue'), 'should call onSetCloudProvider with blue');\n\n  // click taro to logout\n  wrapper.find('.logout-button').at(0).simulate('click');\n  t.ok(logout.calledOnce, 'should call logout');\n\n  // call onSuccess after login to set current provider\n  const onSuccessLogout = logout.args[0][0];\n  onSuccessLogout();\n  t.ok(onSetCloudProvider.calledWithExactly(null), 'should call onSetCloudProvider with null');\n  t.end();\n});","file":"browser/components/modals/save-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> SaveMapModal.intl","suites":[],"updatePoint":{"line":148,"column":37,"index":6022},"line":148,"code":"test('Components -> SaveMapModal.intl', t => {\n  let wrapper;\n  // mount English version\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveMapModal, {\n      onUpdateSetting: () => {},\n      onSetMapInfo: () => {}\n    })));\n  }, 'Show not fail mount props');\n  t.equal(wrapper.find('.title').text(), 'Cloud storage');\n\n  // mount Finnish version\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, {\n      locale: 'fi'\n    }, /*#__PURE__*/React.createElement(SaveMapModal, {\n      onUpdateSetting: () => {},\n      onSetMapInfo: () => {}\n    })));\n  }, 'Show not fail mount props');\n  t.equal(wrapper.find('.title').text(), 'Pilvitallennus');\n  t.end();\n});","file":"browser/components/modals/save-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ShareMapUrlModal.mount","suites":[],"updatePoint":{"line":27,"column":42,"index":1473},"line":27,"code":"test('Components -> ShareMapUrlModal.mount', t => {\n  const onSetCloudProvider = sinon.spy();\n\n  // mount\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n      onSetCloudProvider: onSetCloudProvider\n    })));\n  }, 'Show not fail without props');\n  t.ok(onSetCloudProvider.notCalled, 'should not call onSetCloudProvider when mount');\n  t.end();\n});","file":"browser/components/modals/share-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ShareMapUrlModal.mount with providers","suites":[],"updatePoint":{"line":39,"column":57,"index":1938},"line":39,"code":"test('Components -> ShareMapUrlModal.mount with providers', t => {\n  const onSetCloudProvider = sinon.spy();\n  const mockProvider = {\n    getAccessToken: () => true,\n    name: 'taro'\n  };\n  // mount\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n      onSetCloudProvider: onSetCloudProvider,\n      cloudProviders: [mockProvider]\n    })));\n  }, 'Show not fail mount props');\n  t.ok(onSetCloudProvider.calledWithExactly('taro'), 'should set default provider when mount');\n  const wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n    onSetCloudProvider: onSetCloudProvider,\n    cloudProviders: [mockProvider],\n    currentProvider: \"hello\"\n  })));\n  t.ok(onSetCloudProvider.calledOnce, 'should not set default provider if it is already set');\n  t.ok(wrapper.find(CloudTile).length === 1, 'should render 1 cloud provider');\n  t.ok(wrapper.find(StatusPanel).length === 0, 'should not render StatusPanel');\n  t.end();\n});","file":"browser/components/modals/share-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ShareMapUrlModal.mount with isLoading","suites":[],"updatePoint":{"line":63,"column":57,"index":3038},"line":63,"code":"test('Components -> ShareMapUrlModal.mount with isLoading', t => {\n  const mockProvider = {\n    getAccessToken: () => true,\n    name: 'taro'\n  };\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n      isProviderLoading: true,\n      onSetCloudProvider: () => {},\n      cloudProviders: [mockProvider]\n    })));\n  }, 'Show not fail mount with isProviderLoading');\n  t.ok(wrapper.find(StatusPanel).length === 1, 'should render StatusPanel when isProviderLoading=true');\n  wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n    providerError: \"something is wrong\",\n    onSetCloudProvider: () => {},\n    cloudProviders: [mockProvider]\n  })));\n  t.ok(wrapper.find(StatusPanel).length === 1, 'should render StatusPanel when error');\n  t.equal(wrapper.find('.notification-item--message').length, 1, 'should render 1 message');\n  t.equal(wrapper.find('.notification-item--message').find('p').text(), 'something is wrong', 'should render error msg');\n  t.end();\n});","file":"browser/components/modals/share-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Components -> ShareMapUrlModal.mount with SharingUrl","suites":[],"updatePoint":{"line":88,"column":58,"index":4211},"line":88,"code":"test('Components -> ShareMapUrlModal.mount with SharingUrl', t => {\n  const shareUrl = 'http://taro-and-blue';\n  const mockProvider = {\n    getAccessToken: () => true,\n    name: 'taro'\n  };\n\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ShareMapUrlModal, {\n      successInfo: {\n        shareUrl\n      },\n      cloudProviders: [mockProvider],\n      currentProvider: \"taro\",\n      onSetCloudProvider: () => {}\n    })));\n  }, 'Show not fail mount with successInfo');\n  t.ok(wrapper.find(SharingUrl).length === 1, 'should render SharingUrl when loading');\n  t.equal(wrapper.find(SharingUrl).find('input').props().value, shareUrl, 'should render with successInfo.shareUrl');\n  t.end();\n});","file":"browser/components/modals/share-map-modal-test.js","skipped":false,"dir":"test"},{"name":"Notification item -> display SUCCESS notification","suites":[],"updatePoint":{"line":28,"column":55,"index":1479},"line":28,"code":"test('Notification item -> display SUCCESS notification', t => {\n  const notification = createNotification({\n    message: 'success',\n    type: 'success'\n  });\n  const $ = shallow( /*#__PURE__*/React.createElement(NotificationItem, {\n    theme: theme,\n    notification: notification\n  }));\n\n  // validate the icon\n  t.equal($.find('Checkmark').length, 1, 'Should display info icon');\n  // validate notification is not expanded\n  t.equal($.state('isExpanded'), false, 'Notification should be not expanded');\n  // click on notification\n  $.find('.notification-item').simulate('click');\n  // validate notification is expanded\n  t.equal($.state('isExpanded'), true, 'Notification should be expanded');\n  t.end();\n});","file":"browser/components/notifications/notification-item-test.js","skipped":false,"dir":"test"},{"name":"Notification item -> display ERROR notification","suites":[],"updatePoint":{"line":48,"column":53,"index":2189},"line":48,"code":"test('Notification item -> display ERROR notification', t => {\n  const notification = createNotification({\n    message: 'error',\n    type: 'error'\n  });\n  const $ = shallow( /*#__PURE__*/React.createElement(NotificationItem, {\n    notification: notification,\n    theme: theme\n  }));\n\n  // validate the icon\n  t.equal($.find('Warning').length, 1, 'Should display warning icon');\n  // validate notification is not expanded\n  t.equal($.state('isExpanded'), false, 'Notification should be not expanded');\n  // click on notification\n  $.find('.notification-item').simulate('click');\n  // validate notification is expanded\n  t.equal($.state('isExpanded'), true, 'Notification should be expanded');\n  t.end();\n});","file":"browser/components/notifications/notification-item-test.js","skipped":false,"dir":"test"},{"name":"Notification Panel - Show notifications","suites":[],"updatePoint":{"line":43,"column":45,"index":1845},"line":43,"code":"test('Notification Panel - Show notifications', t => {\n  const removeNotification = sinon.spy();\n  const $ = shallow( /*#__PURE__*/React.createElement(NotificationPanel, {\n    notifications: notifications,\n    removeNotification: removeNotification,\n    theme: theme\n  }));\n\n  // Check notifications\n  t.equal($.find('NotificationItem').length, 3, 'Should display only 3 Notifications');\n  t.end();\n});","file":"browser/components/notifications/notification-panel-test.js","skipped":false,"dir":"test"},{"name":"PlotContainer -> mount","suites":[],"updatePoint":{"line":29,"column":28,"index":1899},"line":29,"code":"test('PlotContainer -> mount', t => {\n  t.doesNotThrow(() => {\n    mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(PlotContainer, initialProps)));\n  }, 'PlotContainer should not fail without props');\n  t.end();\n});","file":"browser/components/plot-container-test.js","skipped":false,"dir":"test"},{"name":"PlotContainer -> mount -> imageSize","suites":[],"updatePoint":{"line":35,"column":41,"index":2180},"line":35,"code":"test('PlotContainer -> mount -> imageSize', t => {\n  let wrapper;\n  const exportImageSetting = {\n    ...initialProps.exportImageSetting,\n    imageSize: {\n      ...initialProps.exportImageSetting.imageSize,\n      imageW: 800,\n      imageH: 600\n    }\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(PlotContainer, _extends({}, initialProps, {\n      exportImageSetting: exportImageSetting\n    }))));\n  }, 'PlotContainer should not fail without props');\n  let map = wrapper.find('MapContainer').instance();\n  t.equal(map.props.mapState.width, 800, 'should send imageW to mapState');\n  t.equal(map.props.mapState.height, 600, 'should send imageH to mapState');\n\n  // set center to be true\n  exportImageSetting.center = true;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(PlotContainer, _extends({}, initialProps, {\n      exportImageSetting: exportImageSetting\n    }))));\n  }, 'PlotContainer should not fail without props');\n  map = wrapper.find('MapContainer').instance();\n  t.equal(map.props.mapState.latitude, 33.89064297228446, 'should set latitude when center: true');\n  t.equal(map.props.mapState.longitude, -45.57105275929253, 'should set longitude when center: true');\n  t.equal(map.props.mapState.zoom, 1, 'should set zoom when center: true');\n  t.end();\n});","file":"browser/components/plot-container-test.js","skipped":false,"dir":"test"},{"name":"Components -> ColorSelector.render","suites":[],"updatePoint":{"line":31,"column":40,"index":1963},"line":31,"code":"test('Components -> ColorSelector.render', t => {\n  t.doesNotThrow(() => {\n    mount( /*#__PURE__*/React.createElement(ColorSelector, null));\n  }, 'Should not fail without props');\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorSelector.render -> render layer color","suites":[],"updatePoint":{"line":37,"column":67,"index":2186},"line":37,"code":"test('Components -> LayerColorSelector.render -> render layer color', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor.visState);\n  const {\n    layers\n  } = initialState;\n  const pointLayer = layers[0];\n  let wrapper;\n\n  // create spies\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const layerConfiguratorProps = getLayerConfiguratorProps(mockProps);\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorSelector, layerConfiguratorProps)));\n  }, 'Should not fail with layers');\n  const CSInstance = wrapper.find(ColorSelector);\n  t.equal(CSInstance.length, 1, 'should render 1 ColorSelector');\n  const cSProps = CSInstance.at(0).props();\n  const expectedColorSets = [{\n    selectedColor: pointLayer.config.color,\n    setColor: () => {}\n  }];\n  t.equal(cSProps.colorSets.length, expectedColorSets.length, 'should pass correct colorSets');\n  t.deepEqual(Object.keys(cSProps.colorSets[0]), Object.keys(expectedColorSets[0]), 'should pass correct colorSets[0]');\n  t.equal(cSProps.colorSets[0].selectedColor, expectedColorSets[0].selectedColor, 'should pass correct colorSets.selectedColor');\n\n  // color block\n  const cblk = wrapper.find(ColorBlock);\n  t.equal(cblk.length, 1, 'should render 1 ColorBlock');\n  const csInput = wrapper.find(ColorSelectorInput);\n  t.equal(csInput.length, 1, 'should render 1 ColorSelectorInput');\n  csInput.simulate('mousedown');\n  t.ok(updateLayerColorUI.calledOnce, 'should call updateLayerColorUI');\n  t.ok(updateLayerVisConfig.notCalled, 'should not call updateLayerColorUI');\n  t.ok(updateLayerConfig.notCalled, 'should not call updateLayerConfig');\n\n  // should open dropdown\n  t.ok(updateLayerColorUI.calledWith('color', {\n    showDropdown: 0\n  }));\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorSelector.render -> render single color click","suites":[],"updatePoint":{"line":87,"column":74,"index":4253},"line":87,"code":"test('Components -> LayerColorSelector.render -> render single color click', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor.visState);\n  const {\n    layers\n  } = initialState;\n  // should dropdown for layer color select\n  const pointLayer = layers[0].updateLayerColorUI('color', {\n    showDropdown: 0\n  });\n  let wrapper;\n\n  // create spies\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const layerConfiguratorProps = getLayerConfiguratorProps(mockProps);\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorSelector, layerConfiguratorProps)));\n  }, 'Should not fail render color select');\n  const CSInstance = wrapper.find(ColorSelector);\n  t.equal(CSInstance.length, 1, 'should render 1 ColorSelector');\n\n  // open color dropdown\n  const scp = wrapper.find(SingleColorPalette);\n  t.equal(scp.length, 1, 'should render 1 SingleColorPalette');\n  t.ok(wrapper.find('.single-color-palette__block'), 'should render color blocks');\n\n  // click color block\n  wrapper.find('.single-color-palette__block').at(0).simulate('click');\n  t.ok(updateLayerConfig.calledOnce, 'should call updateLayerConfig');\n  t.ok(updateLayerConfig.calledWith({\n    color: [255, 254, 230]\n  }));\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> ArcLayerColorSelector.render -> render single color","suites":[],"updatePoint":{"line":129,"column":71,"index":5794},"line":129,"code":"test('Components -> ArcLayerColorSelector.render -> render single color', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n  const arcLayer = layers.find(l => l.type === 'arc');\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: arcLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const layerConfiguratorProps = getLayerConfiguratorProps(mockProps);\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ArcLayerColorSelector, {\n      layer: arcLayer,\n      setColorUI: layerConfiguratorProps.setColorUI,\n      onChangeConfig: layerConfiguratorProps.onChange,\n      onChangeVisConfig: visConfiguratorProps.onChange\n    })));\n  }, 'Should not fail render arc color select');\n  const CSInstance = wrapper.find(ColorSelector);\n  t.equal(CSInstance.length, 1, 'should render 1 ColorSelector');\n  const cSProps = CSInstance.at(0).props();\n  const expectedColorSets = [{\n    selectedColor: arcLayer.config.color,\n    setColor: () => {},\n    label: 'Source'\n  }, {\n    selectedColor: arcLayer.config.color,\n    setColor: () => {},\n    label: 'Target'\n  }];\n  t.equal(cSProps.colorSets.length, expectedColorSets.length, 'should pass correct colorSets');\n  t.deepEqual(Object.keys(cSProps.colorSets[0]), Object.keys(expectedColorSets[0]), 'should pass correct colorSets[0]');\n  t.equal(cSProps.colorSets[0].selectedColor, expectedColorSets[0].selectedColor, 'should pass correct colorSets.selectedColor');\n\n  // color block\n  const cblk = wrapper.find(ColorBlock);\n  t.equal(cblk.length, 2, 'should render 2 ColorBlocks');\n  const csInput = wrapper.find(ColorSelectorInput);\n  t.equal(csInput.length, 2, 'should render 2 ColorSelectorInput');\n  csInput.at(1).simulate('mousedown');\n  t.ok(updateLayerColorUI.calledOnce, 'should call updateLayerColorUI when mousedown 2nd block');\n  t.ok(updateLayerVisConfig.notCalled, 'should not call updateLayerColorUI when mousedown 2nd block');\n  t.ok(updateLayerConfig.notCalled, 'should not call updateLayerConfig when mousedown 2nd block');\n\n  // should open dropdown\n  t.ok(updateLayerColorUI.calledWith('color', {\n    showDropdown: 1\n  }));\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> ArcLayerColorSelector.render -> render single color click","suites":[],"updatePoint":{"line":188,"column":77,"index":8285},"line":188,"code":"test('Components -> ArcLayerColorSelector.render -> render single color click', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor.visState);\n  const {\n    layers\n  } = initialState;\n  // should dropdown for arc layer target color select\n  const arcLayer = layers[1].updateLayerColorUI('color', {\n    showDropdown: 1\n  });\n\n  // create spies\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: arcLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const layerConfiguratorProps = getLayerConfiguratorProps(mockProps);\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(ArcLayerColorSelector, {\n      layer: arcLayer,\n      setColorUI: layerConfiguratorProps.setColorUI,\n      onChangeConfig: layerConfiguratorProps.onChange,\n      onChangeVisConfig: visConfiguratorProps.onChange\n    })));\n  }, 'Should not fail render arc color select');\n  const CSInstance = wrapper.find(ColorSelector);\n  t.equal(CSInstance.length, 1, 'should render 1 ColorSelector');\n\n  // open color dropdown\n  const scp = wrapper.find(SingleColorPalette);\n  t.equal(scp.length, 1, 'should render 1 SingleColorPalette');\n  t.ok(wrapper.find('.single-color-palette__block'), 'should render color blocks');\n\n  // click color block\n  wrapper.find('.single-color-palette__block').at(0).simulate('click');\n  t.ok(updateLayerVisConfig.calledOnce, 'should call updateLayerVisConfig');\n  t.ok(updateLayerVisConfig.calledWith({\n    targetColor: [255, 254, 230]\n  }));\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorRangeSelector.render -> ColorSelector","suites":[],"updatePoint":{"line":236,"column":67,"index":10089},"line":236,"code":"test('Components -> LayerColorRangeSelector.render -> ColorSelector', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n  const pointLayer = layers.find(l => l.type === 'point');\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorRangeSelector, visConfiguratorProps)));\n  }, 'Should not fail render color range select');\n  const CPInstance = wrapper.find(ColorPalette);\n  t.equal(CPInstance.length, 1, 'should render 1 ColorPalette');\n\n  // render color blocks\n  const cblks = CPInstance.at(0).find('.color-range-palette__block');\n  t.equal(cblks.length, 8, 'should render 8 ColorBlocks');\n  const expectedColor = `rgb(${hexToRgb('#7F1941').join(', ')})`;\n  const firstColor = cblks.at(0).getDOMNode().style.getPropertyValue('background-color');\n  t.equal(firstColor, expectedColor, 'should render correct background color');\n\n  // simulate click\n  const csInput = wrapper.find(ColorSelectorInput);\n  t.equal(csInput.length, 1, 'should render 2 ColorSelectorInput');\n  csInput.at(0).simulate('mousedown');\n  t.ok(updateLayerColorUI.calledOnce, 'should call updateLayerColorUI when mousedown 2nd block');\n  t.ok(updateLayerVisConfig.notCalled, 'should not call updateLayerColorUI when mousedown 2nd block');\n  t.ok(updateLayerConfig.notCalled, 'should not call updateLayerConfig when mousedown 2nd block');\n\n  // should open dropdown\n  t.ok(updateLayerColorUI.calledWith('colorRange', {\n    showDropdown: 0\n  }));\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> select type","suites":[],"updatePoint":{"line":281,"column":104,"index":12064},"line":281,"code":"test('Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> select type', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n\n  // set showDropdown to true\n  const pointLayer = layers.find(l => l.type === 'point').updateLayerColorUI('colorRange', {\n    showDropdown: 0\n  });\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorRangeSelector, visConfiguratorProps)));\n  }, 'Should not fail render color range select');\n\n  // open color dropdown\n  t.equal(wrapper.find('.color-range-selector').length, 1, 'should render 1 color-range-selector');\n  const crs = wrapper.find(ColorRangeSelector);\n  t.equal(crs.length, 1, 'should render 1 ColorRangeSelector');\n  const pc = crs.find(PaletteConfig);\n  t.equal(pc.length, 4, 'should render 4 PaletteConfig');\n  const cpg = crs.find(ColorPaletteGroup);\n  t.equal(cpg.length, 1, 'should render 1 ColorPaletteGroup');\n  const expectedGroups = COLOR_RANGES.filter(cr => cr.colors.length === 6).length + 1;\n  t.equal(wrapper.find(ColorPalette).length, expectedGroups, `should render ${expectedGroups} ColorPalette`);\n  const typeSelect = crs.find(PaletteConfig).at(0);\n  t.equal(typeSelect.find('.side-panel-panel__label').text(), 'type', 'should render type');\n\n  // click on type select\n  t.equal(typeSelect.find('.item-selector__dropdown').length, 1, 'should render item selector dropdown input');\n  typeSelect.find('.item-selector__dropdown').at(0).simulate('click');\n  wrapper.update();\n  const listItem = wrapper.find('.list__item');\n  t.equal(listItem.length, 6, 'should render item selector typeahead');\n  t.deepEqual(listItem.map(nd => nd.at(0).find('.list__item__anchor').at(0).text()), ALL_TYPES, 'should render all types');\n\n  // click on 1 type\n  listItem.at(2).simulate('click');\n  t.ok(updateLayerColorUI.calledOnce, 'updateLayerColorUI should be called');\n  const expectedArgs = ['colorRange', {\n    colorRangeConfig: {\n      type: 'qualitative'\n    }\n  }];\n  t.deepEqual(updateLayerColorUI.args[0], expectedArgs, 'should call updateLayerColorUI with correct args');\n  const reverseSwitch = crs.find(PaletteConfig).at(2);\n  t.equal(reverseSwitch.find('.side-panel-panel__label').text(), 'reversed', 'should render reversed switch');\n  const switchInput = reverseSwitch.find('input').at(0);\n  switchInput.simulate('change');\n  t.ok(updateLayerColorUI.calledTwice, 'updateLayerColorUI should be called when click reserved switch');\n  const expectedArgs1 = ['colorRange', {\n    colorRangeConfig: {\n      reversed: false\n    }\n  }];\n  t.deepEqual(updateLayerColorUI.args[1], expectedArgs1, 'should call updateLayerColorUI with reversed: true');\n  const customSwitch = crs.find(PaletteConfig).at(3);\n  t.equal(customSwitch.find('.side-panel-panel__label').text(), 'Custom Palette', 'should render custom switch');\n  customSwitch.find('input').at(0).simulate('change');\n  t.ok(updateLayerColorUI.callCount === 3, 'updateLayerColorUI should be called when click custom switch');\n  const expectedArgs3 = ['colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  }];\n  t.deepEqual(updateLayerColorUI.args[2], expectedArgs3, 'should call updateLayerColorUI with custom: true');\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette.render","suites":[],"updatePoint":{"line":360,"column":113,"index":15761},"line":360,"code":"test('Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette.render', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n\n  // set showDropdown to true\n  const pointLayer = layers.find(l => l.type === 'point').updateLayerColorUI('colorRange', {\n    showDropdown: 0\n  }).updateLayerColorUI('colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  });\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorRangeSelector, visConfiguratorProps)));\n  }, 'Should not fail render color range select');\n\n  // open color dropdown\n  t.equal(wrapper.find('.color-range-selector').length, 1, 'should render 1 color-range-selector');\n  const crs = wrapper.find(ColorRangeSelector);\n  t.equal(crs.length, 1, 'should render 1 ColorRangeSelector');\n  const pc = crs.find(PaletteConfig);\n  t.equal(pc.length, 1, 'should render 1 PaletteConfig');\n  const cp = crs.find(CustomPalette);\n  t.equal(cp.length, 1, 'should render 1 CustomPalette');\n  t.equal(cp.find('.custom-palette__sortable-items').length, pointLayer.config.colorUI.colorRange.customPalette.colors.length * 3, 'should render same number of custom palette swatch');\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette.update","suites":[],"updatePoint":{"line":401,"column":113,"index":17449},"line":401,"code":"test('Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette.update', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n\n  // set showDropdown to true\n  const pointLayer = layers.find(l => l.type === 'point').updateLayerColorUI('colorRange', {\n    showDropdown: 0\n  }).updateLayerColorUI('colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  });\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorRangeSelector, visConfiguratorProps)));\n  }, 'Should not fail render color range select');\n  // current colorRange\n  // { name: 'Ice And Fire 8',\n  // type: 'diverging',\n  // category: 'Uber',\n  // colors:\n  //  [ '#7F1941',\n  //    '#D50255',\n  //    '#FEAD54',\n  //    '#FEEDB1',\n  //    '#E8FEB5',\n  //    '#49E3CE',\n  //    '#0198BD',\n  //    '#007A99' ],\n  // reversed: true }\n  const cp = wrapper.find(CustomPalette);\n  t.equal(cp.length, 1, 'should render 1 CustomPalette');\n\n  // add step\n  t.equal(cp.find(Button).length, 3, 'should render 3 buttons');\n\n  // click add step\n  cp.find(Button).at(0).simulate('click');\n  t.deepEqual(updateLayerColorUI.args[0], ['colorRange', {\n    customPalette: {\n      colors: ['#7F1941', '#D50255', '#FEAD54', '#FEEDB1', '#E8FEB5', '#49E3CE', '#0198BD', '#007A99', '#007A99']\n    }\n  }], 'should add color to custom palette when click add step');\n\n  // click cancel\n  cp.find(Button).at(1).simulate('click');\n  t.deepEqual(updateLayerColorUI.args[1], ['colorRange', {\n    colorRangeConfig: {\n      custom: false\n    },\n    showSketcher: false\n  }], 'should set custom: false when cancel');\n\n  // click apply\n  cp.find(Button).at(2).simulate('click');\n  t.deepEqual(updateLayerColorUI.args[2], ['colorRange', {\n    colorRangeConfig: {\n      custom: false\n    },\n    showSketcher: false\n  }], 'should set custom to false when click apply');\n  t.deepEqual(updateLayerVisConfig.args[0], [{\n    colorRange: {\n      name: 'Custom Palette',\n      type: 'custom',\n      category: 'Custom',\n      colors: ['#7F1941', '#D50255', '#FEAD54', '#FEEDB1', '#E8FEB5', '#49E3CE', '#0198BD', '#007A99']\n    }\n  }], 'should set colorRange to custom');\n\n  // click swatch\n  wrapper.find('.custom-palette__swatch').at(3).simulate('click');\n  t.ok(updateLayerColorUI.calledWith('colorRange', {\n    showSketcher: 3\n  }), 'should set showSketcher to swatch index');\n  wrapper.update();\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette -> CustomPicker","suites":[],"updatePoint":{"line":492,"column":122,"index":20345},"line":492,"code":"test('Components -> LayerColorRangeSelector.render -> ColorSelector -> ColorRangeSelector -> CustomPalette -> CustomPicker', t => {\n  const initialState = StateWTrips.visState;\n  const {\n    layers\n  } = initialState;\n\n  // set showSketcher to true\n  const pointLayer = layers.find(l => l.type === 'point').updateLayerColorUI('colorRange', {\n    showDropdown: 0\n  }).updateLayerColorUI('colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  }).updateLayerColorUI('colorRange', {\n    showSketcher: 2\n  });\n  const updateLayerConfig = sinon.spy();\n  const updateLayerVisConfig = sinon.spy();\n  const updateLayerColorUI = sinon.spy();\n  const mockProps = {\n    layer: pointLayer,\n    datasets: initialState.datasets,\n    updateLayerConfig,\n    updateLayerVisConfig,\n    updateLayerColorUI\n  };\n  const visConfiguratorProps = getVisConfiguratorProps(mockProps);\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerColorRangeSelector, visConfiguratorProps)));\n  }, 'Should not fail render color range select');\n  const cp = wrapper.find(CustomPalette);\n  t.equal(cp.length, 1, 'should render 1 CustomPalette');\n  const picker = cp.find(CustomPicker);\n  t.equal(picker.length, 1, 'should render 1 CustomPicker');\n\n  // SecurityError (e.g. cross-origin error) should be handled in Portaled component\n  t.doesNotThrow(() => {\n    picker.simulateError({\n      name: 'SecurityError',\n      message: '',\n      stack: []\n    });\n    t.equal(wrapper.find(Portaled).length, 1);\n  }, 'Should not fail with SecurityError when close CustomPicker');\n  t.end();\n});","file":"browser/components/side-panel/color-selector-test.js","skipped":false,"dir":"test"},{"name":"Components -> FilterManager.mount -> no prop","suites":[],"updatePoint":{"line":78,"column":50,"index":3251},"line":78,"code":"test('Components -> FilterManager.mount -> no prop', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FilterManager, defaultProps)));\n  }, 'FilterManager should not fail without props');\n  t.ok(wrapper.find('.filter-manager').length === 1, 'should render Filter Manager');\n  t.ok(wrapper.find(SourceDataCatalog).length === 1, 'should render SourceDataCatalog');\n  t.equal(wrapper.find(AddFilterButton).length, 1, 'should render add filter button');\n  t.end();\n});","file":"browser/components/side-panel/filter-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> FilterManager.mount -> with prop","suites":[],"updatePoint":{"line":89,"column":52,"index":3841},"line":89,"code":"test('Components -> FilterManager.mount -> with prop', t => {\n  // mount\n  const addFilter = sinon.spy();\n  const newProps = {\n    ...filterManagerProps,\n    visStateActions: {\n      ...filterManagerProps.visStateActions,\n      addFilter\n    }\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FilterManager, newProps)));\n  }, 'FilterManager should not fail w/ props');\n  t.ok(wrapper.find('.filter-manager').length === 1, 'should render Filter Manager');\n  t.ok(wrapper.find(SourceDataCatalog).length === 1, 'should render SourceDataCatalog');\n  t.equal(wrapper.find(Button).length, 2, 'should render 2 buttons');\n  t.ok(wrapper.find(FilterPanel).length === 2, 'should render 2 FilterPanel');\n\n  // stateless component don't have a instance()\n  const filter1Props = wrapper.find(FilterPanel).at(0).props();\n  t.equal(filter1Props.filter, filterManagerProps.filters[1], 'should render last filter first');\n  t.equal(filter1Props.isAnyFilterAnimating, false, 'isAnyFilterAnimating is false');\n  t.equal(wrapper.find('.list__item').length, 2, 'should render 2 options');\n  clickItemSelectList(wrapper, 1);\n  t.deepEqual(addFilter.args, [[Object.keys(StateWFilters.visState.datasets)[1]]], 'Should call addFilter with 1st dataset');\n  t.end();\n});","file":"browser/components/side-panel/filter-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> FilterManager.mount -> order by dataset view","suites":[],"updatePoint":{"line":117,"column":64,"index":5208},"line":117,"code":"test('Components -> FilterManager.mount -> order by dataset view', t => {\n  const newProps = {\n    ...filterManagerProps,\n    panelListView: 'byDataset'\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FilterManager, newProps)));\n  }, 'FilterManager should not fail w/ props');\n  t.equal(wrapper.find('DatasetFilterSection').length, 2, 'should render 2 DatasetFilterSection');\n  t.end();\n});","file":"browser/components/side-panel/filter-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> FilterManager.mount -> with supportedFilterTypes","suites":[],"updatePoint":{"line":129,"column":68,"index":5715},"line":129,"code":"test('Components -> FilterManager.mount -> with supportedFilterTypes', t => {\n  // load csv and geojson\n  const updatedState = applyActions(keplerGlReducer, InitialState, [{\n    action: VisStateActions.updateVisData,\n    payload: [[{\n      info: csvInfo,\n      data: {\n        fields: testFields,\n        rows: testAllData\n      },\n      supportedFilterTypes: [ALL_FIELD_TYPES.real, ALL_FIELD_TYPES.integer]\n    }]]\n  }]);\n  const {\n    visState\n  } = updatedState;\n  // test dataset is table\n  assertDatasetIsTable(t, visState.datasets[csvInfo.id]);\n  t.deepEqual(visState.datasets[csvInfo.id].supportedFilterTypes, [ALL_FIELD_TYPES.real, ALL_FIELD_TYPES.integer], 'supportedFilterTypes should be correct');\n\n  // call addFilter\n  const stateWithEmptyFilter = keplerGlReducer(updatedState, VisStateActions.addFilter(csvInfo.id));\n  // mount filter panel\n  // components\n  const props = {\n    filters: stateWithEmptyFilter.visState.filters,\n    datasets: stateWithEmptyFilter.visState.datasets,\n    layers: stateWithEmptyFilter.visState.layers,\n    showDatasetTable: nop,\n    panelMetadata: {\n      label: 'sidebar.panels.filter'\n    },\n    visStateActions: {\n      addFilter: nop,\n      setFilter: nop,\n      removeFilter: nop,\n      enlargeFilter: nop,\n      toggleAnimation: nop,\n      toggleFilterFeature: nop\n    },\n    uiStateActions: {\n      togglePanelListView: nop\n    }\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(FilterManager, props)));\n  }, 'FilterManager should not fail when mount with dataset.supportedFilterTypes');\n  t.ok(wrapper.find(FilterPanel).length === 1, 'should render 1 FilterPanel');\n  t.ok(wrapper.find(NewFilterPanel).length === 1, 'should render 1 NewFilterPanel');\n  t.ok(wrapper.find(FilterPanelHeader).length === 1, 'should render 1 FilterPanelHeader');\n  t.ok(wrapper.find(FieldSelector).length === 1, 'should render FieldSelector');\n\n  // check field options\n  const fieldOptions = wrapper.find(FieldSelector).at(0).props().fields;\n  t.deepEqual(fieldOptions.map(f => f.name), ['gps_data.lat', 'gps_data.lng', 'uid'], 'should only pass real / integer fields');\n  t.end();\n});","file":"browser/components/side-panel/filter-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerConfigurator.mount -> defaut prop 1","suites":[],"updatePoint":{"line":58,"column":60,"index":2955},"line":58,"code":"test('Components -> LayerConfigurator.mount -> defaut prop 1', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerConfigurator, defaultProps)));\n  }, 'LayerConfigurator should not fail without props');\n  const component = wrapper.find(LayerConfigurator).instance();\n  const spy = sinon.spy(component, '_renderScatterplotLayerConfig');\n  component.forceUpdate();\n  wrapper.update();\n  t.ok(spy.calledOnce, 'should call _renderScatterplotLayerConfig');\n  const expectedDataset = StateWFiles.visState.datasets[testCsvDataId];\n  const expectedLayer = StateWFiles.visState.layers[0];\n  const expectedArgs = {\n    layer: expectedLayer,\n    dataset: expectedDataset,\n    visConfiguratorProps: {\n      layer: expectedLayer,\n      fields: expectedDataset.fields,\n      onChange: updateLayerVisConfig,\n      setColorUI: updateLayerColorUI\n    },\n    layerConfiguratorProps: {\n      layer: expectedLayer,\n      fields: expectedDataset.fields,\n      onChange: updateLayerConfig,\n      setColorUI: updateLayerColorUI\n    },\n    layerChannelConfigProps: {\n      layer: expectedLayer,\n      fields: expectedDataset.fields,\n      onChange: updateLayerVisualChannelConfig\n    }\n  };\n  const args = spy.args[0][0];\n  t.deepEqual(Object.keys(args).sort(), Object.keys(expectedArgs).sort(), 'render layer method should receive 5 arguments');\n  t.equal(args.layer, expectedArgs.layer, 'render layer method should receive corrent layer arg');\n  t.equal(args.dataset, expectedArgs.dataset, 'render layer method should receive corrent dataset arg');\n  t.deepEqual(args.visConfiguratorProps, expectedArgs.visConfiguratorProps, 'render layer method should receive corrent visConfiguratorProps arg');\n  t.deepEqual(args.layerConfiguratorProps, expectedArgs.layerConfiguratorProps, 'render layer method should receive corrent layerConfiguratorProps arg');\n  t.deepEqual(args.layerChannelConfigProps, expectedArgs.layerChannelConfigProps, 'render layer method should receive corrent layerChannelConfigProps arg');\n  t.end();\n});","file":"browser/components/side-panel/layer-configurator-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerConfigurator.mount -> defaut prop 2","suites":[],"updatePoint":{"line":101,"column":60,"index":5082},"line":101,"code":"test('Components -> LayerConfigurator.mount -> defaut prop 2', t => {\n  // mount\n  const updateLayerConfigSpy = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerConfigurator, _extends({}, defaultProps, {\n      updateLayerConfig: updateLayerConfigSpy\n    }))));\n  }, 'LayerConfigurator should not fail without props');\n  const baseConfigGroup = wrapper.find(LayerConfigGroup).at(0);\n  t.equal(baseConfigGroup.find(LayerColumnConfig).length, 1, 'should render 1 LayerColumnConfig');\n  t.equal(baseConfigGroup.find(LayerColumnConfig).at(0).find(ColumnSelector).length, 3, 'Should render 3 ColumnSelector');\n\n  // open fieldSelector\n  // t.equal(\n  const fieldSelector = baseConfigGroup.find(LayerColumnConfig).at(0).find(ColumnSelector).at(0).find(FieldSelector).at(0);\n\n  // open dropdown\n  clickItemSelector(fieldSelector);\n  const fieldSelector2 = wrapper.find(LayerColumnConfig).at(0).find(ColumnSelector).at(0).find(FieldSelector).at(0);\n  t.equal(fieldSelector2.find('.list__item.fixed').length, 1, 'should render 1 fixed item');\n  t.equal(getItemSelectorListText(fieldSelector2, 0), 'gps_data', 'should render correct field pair name');\n\n  // click list item suggested field pair\n  clickItemSelectList(fieldSelector2, 0);\n  t.ok(updateLayerConfigSpy.calledOnce, 'should call updateLayerConfigSpy');\n  t.deepEqual(updateLayerConfigSpy.args[0], [{\n    columns: {\n      lat: {\n        value: 'gps_data.lat',\n        fieldIdx: 1\n      },\n      lng: {\n        value: 'gps_data.lng',\n        fieldIdx: 2\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }], 'should update field pairs');\n  t.equal(getItemSelectorListText(fieldSelector2, 2), 'gps_data.lng', 'should render correct field pair name');\n\n  // click single column\n  clickItemSelectList(fieldSelector2, 2);\n  t.ok(updateLayerConfigSpy.calledTwice, 'should call updateLayerConfigSpy');\n  t.deepEqual(updateLayerConfigSpy.args[1], [{\n    columns: {\n      lat: {\n        value: 'gps_data.lng',\n        fieldIdx: 2\n      },\n      lng: {\n        value: 'gps_data.lng',\n        fieldIdx: 2\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }], 'should update single column');\n  t.end();\n});","file":"browser/components/side-panel/layer-configurator-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerConfigurator.mount -> collapsed / expand config group ","suites":[],"updatePoint":{"line":168,"column":79,"index":7487},"line":168,"code":"test('Components -> LayerConfigurator.mount -> collapsed / expand config group ', t => {\n  const propsWithTripLayer = {\n    ...defaultProps,\n    layer: StateWTripGeojson.visState.layers[0],\n    datasets: StateWTripGeojson.visState.datasets\n  };\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerConfigurator, propsWithTripLayer)));\n  }, 'LayerConfigurator should not fail without props');\n  const component = wrapper.find(LayerConfigurator).instance();\n  t.equal(wrapper.find(LayerConfigGroup).at(0).find('.layer-config-group.collapsed').length, 3, 'LayerConfigGroup should be collapsed');\n  const spy = sinon.spy(component, '_renderScatterplotLayerConfig');\n  const spy2 = sinon.spy(component, '_renderTripLayerConfig');\n  component.forceUpdate();\n  wrapper.update();\n  t.ok(spy.notCalled, 'should not call _renderScatterplotLayerConfig');\n  t.ok(spy2.calledOnce, 'should call _renderTripLayerConfig');\n\n  // click layer config group header\n  wrapper.find('.layer-config-group__header').at(0).simulate('click');\n  t.equal(wrapper.find(LayerConfigGroup).at(0).find('.layer-config-group.collapsed').length, 0, 'LayerConfigGroup should be expanded');\n  t.end();\n});","file":"browser/components/side-panel/layer-configurator-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> LayerPanel -> LayerList -> render sortable list","suites":[],"updatePoint":{"line":38,"column":80,"index":2262},"line":38,"code":"test('Components -> SidePanel -> LayerPanel -> LayerList -> render sortable list', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerList, _extends({}, defaultProps, {\n      isSortable: true\n    }))));\n  }, 'LayerList should render');\n  t.equal(wrapper.find('.sortable-layer-items').length, 6, 'should render 6 sortable items');\n  const titles = [];\n  const expectedTitles = ['H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 2', 'H3 Hexagon 2', 'H3 Hexagon 2'];\n  wrapper.find('.layer__title__editor').forEach(item => titles.push(item.getDOMNode().value));\n  t.deepEqual(titles, expectedTitles, 'should render panels in correct order');\n  const layers = wrapper.find('.layer-panel');\n  t.equal(layers.length, 6, 'should render 6 layer panels');\n  t.end();\n});","file":"browser/components/side-panel/layer-list-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> LayerPanel -> LayerList -> render non-sortable list","suites":[],"updatePoint":{"line":54,"column":84,"index":3154},"line":54,"code":"test('Components -> SidePanel -> LayerPanel -> LayerList -> render non-sortable list', t => {\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerList, _extends({}, defaultProps, {\n      isSortable: false\n    }))));\n  }, 'LayerList should render');\n  t.equal(wrapper.find('.sortable-layer-items').length, 0, 'should not render sortable items');\n  const titles = [];\n  const expectedTitles = ['H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 2', 'H3 Hexagon 2', 'H3 Hexagon 2'];\n  wrapper.find('.layer__title__editor').forEach(item => titles.push(item.getDOMNode().value));\n  t.deepEqual(titles, expectedTitles, 'should render panels in correct order');\n  const layers = wrapper.find('.layer-panel');\n  t.equal(layers.length, 6, 'should render 6 layer panels');\n  t.end();\n});","file":"browser/components/side-panel/layer-list-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> LayerPanel -> LayerList -> pass null entries as layers","suites":[],"updatePoint":{"line":70,"column":87,"index":4052},"line":70,"code":"test('Components -> SidePanel -> LayerPanel -> LayerList -> pass null entries as layers', t => {\n  let wrapper;\n  const layers = [...defaultProps.layers];\n  layers[0] = null;\n  const removeLayerSpy = sinon.spy();\n  const visStateActions = {\n    ...defaultProps.visStateActions\n  };\n  visStateActions.removeLayer = removeLayerSpy;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerList, _extends({}, defaultProps, {\n      isSortable: false,\n      layers: layers,\n      visStateActions: visStateActions\n    }))));\n  }, 'LayerList should render');\n  t.equal(wrapper.find('LayerPanel').length, 1, 'should render 1 LayerPanel');\n  const removeLayer = wrapper.find('div.panel--header__action.layer__remove-layer svg.data-ex-icons-trash');\n  removeLayer.simulate('click');\n  t.equal(removeLayerSpy.called, true, 'Should have called remove layer when clicked');\n  t.end();\n});","file":"browser/components/side-panel/layer-list-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerManager -> render -> list view","suites":[],"updatePoint":{"line":59,"column":55,"index":3106},"line":59,"code":"test('Components -> LayerManager -> render -> list view', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerManager, defaultProps)));\n  }, 'LayerManager should not fail');\n  t.ok(wrapper.find(DatasetLayerGroup).length === 0, 'should not render DatasetLayerGroup');\n  t.ok(wrapper.find(LayerList).length === 1, 'should render LayerList');\n  t.ok(wrapper.find(AddLayerButton).length === 1, 'should render AddLayerButton');\n  t.ok(wrapper.find(DatasetSection).length === 1, 'should render DatasetSection');\n  t.ok(wrapper.find(PanelViewListToggle).length === 1, 'should render PanelViewListToggle');\n  t.ok(wrapper.find(PanelTitle).length === 1, 'should render PanelTitle');\n  const titles = [];\n  const expectedTitles = ['H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 2', 'H3 Hexagon 2', 'H3 Hexagon 2'];\n  wrapper.find('.layer__title__editor').forEach(item => titles.push(item.getDOMNode().value));\n  t.deepEqual(titles, expectedTitles, 'should render panels in correct order');\n  const layers = wrapper.find('.layer-panel');\n  t.equal(layers.length, 6, 'should render 6 layer panels');\n  t.end();\n});","file":"browser/components/side-panel/layer-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerManager -> render -> order by dataset view","suites":[],"updatePoint":{"line":79,"column":67,"index":4360},"line":79,"code":"test('Components -> LayerManager -> render -> order by dataset view', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerManager, _extends({}, defaultProps, {\n      panelListView: \"byDataset\"\n    }))));\n  }, 'LayerManager should not fail');\n  t.ok(wrapper.find(DatasetLayerGroup).length === 1, 'should render DatasetLayerGroup');\n  t.ok(wrapper.find(LayerList).length === 1, 'should render LayerList');\n  t.ok(wrapper.find(AddLayerButton).length === 1, 'should render AddLayerButton');\n  t.ok(wrapper.find(DatasetSection).length === 1, 'should render DatasetSection');\n  t.ok(wrapper.find(PanelViewListToggle).length === 1, 'should render PanelViewListToggle');\n  t.ok(wrapper.find(PanelTitle).length === 1, 'should render PanelTitle');\n  const titles = [];\n  const expectedTitles = ['H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 1', 'H3 Hexagon 2', 'H3 Hexagon 2', 'H3 Hexagon 2'];\n  wrapper.find('.layer__title__editor').forEach(item => titles.push(item.getDOMNode().value));\n  t.deepEqual(titles, expectedTitles, 'should render panels in correct order');\n  const layers = wrapper.find('.layer-panel');\n  t.equal(layers.length, 6, 'should render 6 layer panels');\n  t.end();\n});","file":"browser/components/side-panel/layer-manager-test.js","skipped":false,"dir":"test"},{"name":"Components -> LayerPanelHeader.mount -> no prop","suites":[],"updatePoint":{"line":40,"column":53,"index":1678},"line":40,"code":"test('Components -> LayerPanelHeader.mount -> no prop', t => {\n  const LayerPanelHeader = appInjector.get(LayerPanelHeaderFactory);\n\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerPanelHeader, defaultProps)));\n  }, 'LayerPanelHeader should not fail without props');\n  t.ok(wrapper.find('.layer-panel__header').length, 'should render layer-panel__header');\n  t.ok(wrapper.find(DragHandle).length, 'should render drag handle');\n  t.ok(wrapper.find('.layer__title__editor').length, 'should render title eidtor');\n  t.ok(wrapper.find('.layer__visibility-toggle').length, 'should render visibility toggle');\n  t.ok(wrapper.find('.layer__enable-config').length, 'should render enable config toggle');\n\n  // mount\n  const layerAfterErrorProps = {\n    ...defaultProps,\n    ...{\n      isValid: false\n    }\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(LayerPanelHeader, layerAfterErrorProps)));\n  }, 'LayerPanelHeader should not fail without props');\n  t.ok(!wrapper.find('.layer__visibility-toggle').length, \"shouldn't render visibility toggle\");\n  t.ok(wrapper.find('.layer__is-valid-refresh').length, 'should render validity refresh icon');\n  t.end();\n});","file":"browser/components/side-panel/layer-panel-header-test.js","skipped":false,"dir":"test"},{"name":"SaveExportDropdown","suites":[],"updatePoint":{"line":27,"column":24,"index":1426},"line":27,"code":"test('SaveExportDropdown', t => {\n  const PanelHeaderDropdown = PanelHeaderDropdownFactory();\n  const SaveExportDropdown = SaveExportDropdownFactory(PanelHeaderDropdown);\n  const onExportImage = sinon.spy();\n  const onExportData = sinon.spy();\n  const onExportConfig = sinon.spy();\n  const onExportMap = sinon.spy();\n  const onSaveMap = sinon.spy();\n  const onClose = sinon.spy();\n  const wrapper = mount( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SaveExportDropdown, {\n    onExportImage: onExportImage,\n    onExportData: onExportData,\n    onExportConfig: onExportConfig,\n    onExportMap: onExportMap,\n    onSaveMap: onSaveMap,\n    show: true,\n    onClose: onClose\n  })));\n  t.equal(wrapper.find(PanelHeaderDropdown).length, 1, 'We should display 1 PanelHeaderDropdown');\n  t.equal(wrapper.find(ToolbarItem).length, 4, 'We should display 4 ToolbarItems');\n  wrapper.find('.toolbar-item').at(0).simulate('click');\n  t.equal(onExportImage.called, true, 'Should have called export image callback');\n  wrapper.find('.toolbar-item').at(1).simulate('click');\n  t.equal(onExportData.called, true, 'Should have called export data callback');\n  wrapper.find('.toolbar-item').at(2).simulate('click');\n  t.equal(onExportMap.called, true, 'Should have called export map callback');\n  wrapper.find('.toolbar-item').at(3).simulate('click');\n  t.equal(onSaveMap.called, true, 'Should have called save map callback');\n  t.end();\n});","file":"browser/components/side-panel/save-export-dropdown-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel.mount -> no prop","suites":[],"updatePoint":{"line":65,"column":46,"index":3514},"line":65,"code":"test('Components -> SidePanel.mount -> no prop', t => {\n  // mount\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, defaultProps)));\n  }, 'SidePanel should not fail without props');\n  t.ok(wrapper.find(PanelHeader).length === 1, 'should render PanelHeader');\n  t.ok(wrapper.find(PanelToggle).length === 1, 'should render PanelToggle');\n  t.ok(wrapper.find(Sidebar).length === 1, 'should render Sidebar');\n\n  // side bar close button\n  t.ok(wrapper.find(SidebarCloseButton).length === 1, 'should render SideBarCollapseButton');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel.mount -> hide CollapseButton","suites":[],"updatePoint":{"line":79,"column":58,"index":4185},"line":79,"code":"test('Components -> SidePanel.mount -> hide CollapseButton', t => {\n  // mount\n  let wrapper;\n  const uiState = {\n    ...defaultProps.uiState,\n    isSidePanelCloseButtonVisible: false\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail without props');\n  t.ok(wrapper.find(PanelHeader).length === 1, 'should render PanelHeader');\n  t.ok(wrapper.find(PanelToggle).length === 1, 'should render PanelToggle');\n  t.ok(wrapper.find(Sidebar).length === 1, 'should render Sidebar');\n\n  // side bar close button\n  t.ok(wrapper.find(SidebarCloseButton).length === 0, 'should not render SideBarCollapseButton');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> toggle panel","suites":[],"updatePoint":{"line":99,"column":45,"index":4988},"line":99,"code":"test('Components -> SidePanel -> toggle panel', t => {\n  const toggleSidePanel = sinon.spy();\n  const uiStateActions = {\n    ...UIStateActions,\n    toggleSidePanel\n  };\n  let wrapper;\n  // mount\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiStateActions: uiStateActions\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(PanelToggle).length === 1, 'should render PanelToggle');\n  t.equal(wrapper.find('.side-panel__tab').length, 4, 'should render 4 panel tabs');\n  const layerTab = wrapper.find('.side-panel__tab').at(0);\n\n  // click layer tab\n  layerTab.simulate('click');\n  t.ok(toggleSidePanel.calledWith('layer'), 'should call toggleSidePanel with layer');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> render panel","suites":[],"updatePoint":{"line":121,"column":45,"index":5821},"line":121,"code":"test('Components -> SidePanel -> render panel', t => {\n  let wrapper;\n  let uiState = {\n    ...defaultProps.uiState,\n    activeSidePanel: 'layer'\n  };\n  // mount LayerManager\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(LayerManager).length === 1, 'should render LayerManager');\n\n  // mount FilterManager\n  uiState = {\n    ...defaultProps.uiState,\n    activeSidePanel: 'filter'\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(FilterManager).length === 1, 'should render FilterManager');\n\n  // mount InteractionManager\n  uiState = {\n    ...defaultProps.uiState,\n    activeSidePanel: 'interaction'\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(InteractionManager).length === 1, 'should render InteractionManager');\n\n  // mount MapManager\n  uiState = {\n    ...defaultProps.uiState,\n    activeSidePanel: 'map'\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(MapManager).length === 1, 'should render MapManager');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> render custom panel","suites":[],"updatePoint":{"line":172,"column":52,"index":7656},"line":172,"code":"test('Components -> SidePanel -> render custom panel', t => {\n  const RocketIcon = () => /*#__PURE__*/React.createElement(\"div\", {\n    id: \"rocket-icon\"\n  });\n  const ChartIcon = () => /*#__PURE__*/React.createElement(\"div\", {\n    id: \"chart-icon\"\n  });\n  const MyPanels = props => {\n    if (props.activeSidePanel === 'rocket') {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: \"rocket-panel\"\n      }, \"Rocket\");\n    } else if (props.activeSidePanel === 'chart') {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: \"chart-panel\"\n      }, \"Charts?\");\n    }\n    return null;\n  };\n  MyPanels.defaultProps = {\n    getProps: props => ({\n      layers: props.layers\n    })\n  };\n  function CustomSidePanelsFactory() {\n    return MyPanels;\n  }\n  function CustomSidePanelFactory(...deps) {\n    const CustomSidePanel = SidePanelFactory(...deps);\n    CustomSidePanel.defaultProps = {\n      ...CustomSidePanel.defaultProps,\n      panels: [...CustomSidePanel.defaultProps.panels, {\n        id: 'rocket',\n        label: 'Rocket',\n        iconComponent: RocketIcon\n      }, {\n        id: 'chart',\n        label: 'Chart',\n        iconComponent: ChartIcon\n      }]\n    };\n    return CustomSidePanel;\n  }\n  CustomSidePanelFactory.deps = SidePanelFactory.deps;\n  let wrapper;\n  const CustomSidePanel = appInjector.provide(SidePanelFactory, CustomSidePanelFactory).provide(CustomPanelsFactory, CustomSidePanelsFactory).get(SidePanelFactory);\n\n  // mount CustomSidePanel\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(CustomSidePanel, defaultProps)));\n  }, 'SidePanel should not fail');\n  t.equal(wrapper.find('.side-panel__tab').length, 6, 'should render 6 panel tabs');\n  t.equal(wrapper.find(RocketIcon).length, 1, 'should render RocketIcon');\n  t.equal(wrapper.find(ChartIcon).length, 1, 'should render RocketIcon');\n\n  // // mount CustomSidePanel with 1 of the custom panel\n  const uiState = {\n    ...defaultProps.uiState,\n    activeSidePanel: 'rocket'\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(CustomSidePanel, _extends({}, defaultProps, {\n      uiState: uiState\n    }))));\n  }, 'SidePanel should not fail when mount with custom side panel activated');\n  t.equal(wrapper.find(MyPanels).length, 1, 'should render MyPanels');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> PanelHeader","suites":[],"updatePoint":{"line":240,"column":44,"index":10117},"line":240,"code":"test('Components -> SidePanel -> PanelHeader', t => {\n  const showExportDropdown = sinon.spy();\n  const uiStateActions = {\n    ...UIStateActions,\n    showExportDropdown\n  };\n  let wrapper;\n  // mount\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiStateActions: uiStateActions\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(PanelHeader).length === 1, 'should render PanelHeader');\n  const header = wrapper.find(PanelHeader);\n\n  // action item\n  t.equal(header.find('.side-panel__panel-header__action').length, 1, 'should render 1 header action item');\n\n  // Share\n  t.equal(header.find('.side-panel__panel-header__action').at(0).find('p').text(), 'Share', 'should only render Save action');\n  header.find('.side-panel__panel-header__action').at(0).simulate('click');\n  t.ok(showExportDropdown.calledWith('save'), 'should call toggleSidePanel with share');\n\n  // mound with exportDropdown\n  const uiState = {\n    ...defaultProps.uiState,\n    visibleDropdown: 'save'\n  };\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState,\n      uiStateActions: uiStateActions\n    }))));\n  }, 'SidePanel should not fail');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"Components -> SidePanel -> PanelHeader -> ExportDropDown","suites":[],"updatePoint":{"line":277,"column":62,"index":11566},"line":277,"code":"test('Components -> SidePanel -> PanelHeader -> ExportDropDown', t => {\n  const toggleModal = sinon.spy();\n  const startExportingImage = sinon.spy();\n  const uiStateActions = {\n    ...UIStateActions,\n    toggleModal,\n    startExportingImage\n  };\n\n  // mound with exportDropdown\n  const uiState = {\n    ...defaultProps.uiState,\n    visibleDropdown: 'save'\n  };\n  let wrapper;\n  // mount\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(SidePanel, _extends({}, defaultProps, {\n      uiState: uiState,\n      uiStateActions: uiStateActions\n    }))));\n  }, 'SidePanel should not fail');\n  t.ok(wrapper.find(SaveExportDropdown).length === 1, 'should render SaveExportDropdown');\n  t.equal(wrapper.find(ToolbarItem).length, 3, 'should render 3 ToolbarItem');\n\n  // export image\n  t.equal(wrapper.find(ToolbarItem).at(0).find('.toolbar-item__title').text(), 'Export Image', 'Should render Export Image');\n  wrapper.find(ToolbarItem).at(0).find('.toolbar-item').simulate('click');\n  t.ok(toggleModal.calledWith(EXPORT_IMAGE_ID), 'Should call toggleModal with EXPORT_IMAGE_ID');\n\n  // export data\n  t.equal(wrapper.find(ToolbarItem).at(1).find('.toolbar-item__title').text(), 'Export Data', 'Should render Export Data');\n  wrapper.find(ToolbarItem).at(1).find('.toolbar-item').simulate('click');\n  t.ok(toggleModal.calledWith(EXPORT_DATA_ID), 'Should call toggleModal with EXPORT_DATA_ID');\n\n  // export map\n  t.equal(wrapper.find(ToolbarItem).at(2).find('.toolbar-item__title').text(), 'Export Map', 'Should render Export Map');\n  wrapper.find(ToolbarItem).at(2).find('.toolbar-item').simulate('click');\n  t.ok(toggleModal.calledWith(EXPORT_MAP_ID), 'Should call toggleModal with EXPORT_MAP_ID');\n  t.end();\n});","file":"browser/components/side-panel/side-panel-test.js","skipped":false,"dir":"test"},{"name":"TooltipConfig - render","suites":[],"updatePoint":{"line":56,"column":28,"index":2359},"line":56,"code":"test('TooltipConfig - render', t => {\n  const datasets = StateWFiles.visState.datasets;\n  const tooltipConfig = StateWFiles.visState.interactionConfig.tooltip.config;\n  const FieldSelector = appInjector.get(FieldSelectorFactory);\n  const onChange = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TooltipConfig, {\n      onChange: onChange,\n      config: tooltipConfig,\n      datasets: datasets\n    })));\n  }, 'Should render');\n  t.equal(wrapper.find(TooltipConfig).length, 1, 'Should render 1 TooltipConfig');\n  t.equal(wrapper.find(DatasetTag).length, 2, 'Should render 2 DatasetTag');\n  t.equal(wrapper.find(FieldSelector).length, 2, 'Should render 2 FieldSelector');\n  t.equal(wrapper.find(ChickletedInput).length, 2, 'Should render 2 ChickletedInput');\n\n  // tooltip chicklets\n  const tooltipButtons = wrapper.find(ChickletedInput).at(0).find(ChickletButton);\n  t.equal(tooltipButtons.length, 5, 'should render 6 tooltip buttons');\n  t.equal(tooltipButtons.at(0).find('span').at(0).text(), 'gps_data.utc_timestamp');\n  t.end();\n});","file":"browser/components/tooltip-config-test.js","skipped":false,"dir":"test"},{"name":"TooltipConfig - render -> onSelect","suites":[],"updatePoint":{"line":80,"column":40,"index":3527},"line":80,"code":"test('TooltipConfig - render -> onSelect', t => {\n  const datasets = StateWFiles.visState.datasets;\n  const tooltipConfig = StateWFiles.visState.interactionConfig.tooltip.config;\n  const onChange = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TooltipConfig, {\n      onChange: onChange,\n      config: tooltipConfig,\n      datasets: datasets\n    })));\n  }, 'Should render');\n  t.equal(wrapper.find(ChickletedInput).length, 2, 'Should render 2 ChickletedInput');\n\n  // click chicklet input to open dropdown\n  wrapper.find(ChickletedInput).at(0).simulate('click');\n  const dropdownSelect = wrapper.find(Typeahead);\n  t.equal(dropdownSelect.length, 1, 'should render 1 Typeahead');\n  const listItems = dropdownSelect.find('.field-selector_list-item');\n  t.deepEqual(dropdownSelect.find('.list__item__anchor').map(item => item.text()), ['gps_data.lat', 'gps_data.lng', 'time', 'begintrip_ts_utc', 'begintrip_ts_local', 'date'], 'should filter out selected tooltip items');\n\n  // click 1 item to add\n  listItems.at(0).simulate('click');\n  const expectedArgs0 = {\n    ...tooltipConfig,\n    fieldsToShow: {\n      ...tooltipConfig.fieldsToShow,\n      '190vdll3di': [...tooltipConfig.fieldsToShow['190vdll3di'], {\n        name: 'gps_data.lat',\n        format: null\n      }]\n    }\n  };\n  t.deepEqual(onChange.args[0], [expectedArgs0], 'should call onchange with new tooltip appended');\n\n  // delete 1 item\n  const tooltipButtons = wrapper.find(ChickletedInput).at(0).find(ChickletButton);\n  tooltipButtons.at(0).find(Delete).simulate('click');\n  const expectedArgs1 = {\n    ...tooltipConfig,\n    fieldsToShow: {\n      ...tooltipConfig.fieldsToShow,\n      '190vdll3di': tooltipConfig.fieldsToShow['190vdll3di'].slice(1, tooltipConfig.fieldsToShow['190vdll3di'].length)\n    }\n  };\n  t.deepEqual(onChange.args[1], [expectedArgs1], 'should call onchange with 1 item removed');\n\n  // clear All\n  t.equal(wrapper.find('.button.clear-all').length, 2, 'should render 2 clea all buttons');\n\n  // click to clear all\n  wrapper.find('.button.clear-all').at(0).simulate('click');\n  const expectedArgs2 = {\n    ...tooltipConfig,\n    fieldsToShow: {\n      ...tooltipConfig.fieldsToShow,\n      '190vdll3di': []\n    }\n  };\n  t.deepEqual(onChange.args[2], [expectedArgs2], 'should call onchange to clear all tooltips');\n  t.end();\n});","file":"browser/components/tooltip-config-test.js","skipped":false,"dir":"test"},{"name":"TooltipConfig - render -> tooltip format","suites":[],"updatePoint":{"line":142,"column":46,"index":5961},"line":142,"code":"test('TooltipConfig - render -> tooltip format', t => {\n  const datasets = StateWFiles.visState.datasets;\n  const tooltipConfig = StateWFiles.visState.interactionConfig.tooltip.config;\n  const onChange = sinon.spy();\n  const onDisplayFormatChange = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TooltipConfig, {\n      onChange: onChange,\n      onDisplayFormatChange: onDisplayFormatChange,\n      config: tooltipConfig,\n      datasets: datasets\n    })));\n  }, 'Should render');\n  const tooltipButtons = wrapper.find(ChickletedInput).at(0).find(ChickletButton);\n\n  // click on hash\n  tooltipButtons.at(0).find(Hash).simulate('click');\n  const formatDropdown = wrapper.find(DropdownList);\n  t.equal(formatDropdown.length, 1, 'should render 1 format dropdown');\n  const options = formatDropdown.at(0).props().options;\n  t.deepEqual(uniq(options.map(op => op.type)), ['none', 'date', 'date_time'], 'should render date type formats');\n  const option1 = options[1].format;\n\n  // click option1\n  formatDropdown.find('.list__item').at(1).simulate('click');\n  const expectedArgs0 = {\n    ...tooltipConfig,\n    fieldsToShow: {\n      ...tooltipConfig.fieldsToShow,\n      '190vdll3di': [{\n        name: 'gps_data.utc_timestamp',\n        format: option1\n      }, ...tooltipConfig.fieldsToShow['190vdll3di'].slice(1, tooltipConfig.fieldsToShow['190vdll3di'].length)]\n    }\n  };\n  t.deepEqual(onChange.args[0], [expectedArgs0], 'should call onchange to set format');\n  t.end();\n});","file":"browser/components/tooltip-config-test.js","skipped":false,"dir":"test"},{"name":"TooltipConfig -> render -> do not display Geocoder dataset fields","suites":[],"updatePoint":{"line":181,"column":71,"index":7574},"line":181,"code":"test('TooltipConfig -> render -> do not display Geocoder dataset fields', t => {\n  // Contains only a single dataset which is the geocoder_dataset\n  const datasets = StateWithGeocoderDataset.visState.datasets;\n  const tooltipConfig = StateWithGeocoderDataset.visState.interactionConfig.tooltip.config;\n  const FieldSelector = appInjector.get(FieldSelectorFactory);\n  const onChange = sinon.spy();\n  let wrapper;\n  t.doesNotThrow(() => {\n    wrapper = mountWithTheme( /*#__PURE__*/React.createElement(IntlWrapper, null, /*#__PURE__*/React.createElement(TooltipConfig, {\n      onChange: onChange,\n      config: tooltipConfig,\n      datasets: datasets\n    })));\n  }, 'Should render');\n\n  // Since only the geocoder_dataset is present, nothing should be rendered except the TooltipConfig\n  t.equal(wrapper.find(TooltipConfig).length, 1, 'Should render 1 TooltipConfig');\n  t.equal(wrapper.find(DatasetTag).length, 0, 'Should render 1 DatasetTag');\n  t.equal(wrapper.find(FieldSelector).length, 0, 'Should render 1 FieldSelector');\n  t.equal(wrapper.find(ChickletedInput).length, 0, 'Should render 1 ChickletedInput');\n  t.end();\n});","file":"browser/components/tooltip-config-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> readFileInBatches.csv -> processFileData","suites":[],"updatePoint":{"line":33,"column":63,"index":2044},"line":33,"code":"test('#file-handler -> readFileInBatches.csv -> processFileData', async t => {\n  const csvFile = new File([dataWithNulls], 'text-data.csv', {\n    type: 'text/csv'\n  });\n  let gen = null;\n  try {\n    gen = await readFileInBatches({\n      file: csvFile,\n      fileList: []\n    });\n  } catch (e) {\n    t.equal(true, false, 'Should read file correctly');\n    t.end();\n    return;\n  }\n\n  // metadata batch\n  const batch1 = await gen.next();\n  const expected1 = {\n    value: {\n      batchType: 'metadata',\n      metadata: {\n        _loader: {},\n        _context: {}\n      },\n      data: [],\n      bytesUsed: 0,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName: 'text-data.csv'\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch1.value).sort(), Object.keys(expected1.value).sort(), 'value should have same keys');\n  t.equal(batch1.value.batchType, expected1.value.batchType, 'batch1.batchType should be the same');\n  t.equal(batch1.value.fileName, expected1.value.fileName, 'batch1.fileName should be the same');\n  t.deepEqual(batch1.value.data, expected1.value.data, 'batch1.data should be the same');\n  t.deepEqual(batch1.value.progress, expected1.value.progress, 'batch1.progress should be the same');\n\n  // data batch\n  const batch2 = await gen.next();\n  const expected2 = {\n    value: {\n      batchType: 'metadata',\n      bytesUsed: undefined,\n      count: 0,\n      cursor: 0,\n      data: csvWithNull,\n      fileName: 'text-data.csv',\n      headers: ['gps_data.utc_timestamp', 'gps_data.lat', 'gps_data.lng', 'gps_data.types', 'epoch', 'has_result', 'uid', 'time', 'begintrip_ts_utc', 'begintrip_ts_local', 'date'],\n      length: 13,\n      progress: {\n        rowCount: 13,\n        rowCountInBatch: 13\n      },\n      schema: {},\n      shape: 'object-row-table'\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch2.value).sort(), Object.keys(expected2.value).sort(), 'value should have same keys');\n  t.equal(batch2.value.fileName, expected2.value.fileName, 'batch2.fileName should be the same');\n  // t.deepEqual(batch2.value.data, expected2.value.data, 'batch2.data should be the same');\n  t.deepEqual(batch2.value.headers, expected2.value.headers, 'batch2.headers should be the same');\n  t.deepEqual(batch2.value.progress, expected2.value.progress, 'batch2.progress should be the same');\n  const batch3 = await gen.next();\n  const expected3 = {\n    value: undefined,\n    done: true\n  };\n  t.deepEqual(batch3, expected3, 'batch3 should be the final batch');\n\n  // go on to run processFileData\n  const processed = await processFileData({\n    content: batch2.value,\n    fileCache: []\n  });\n  const expectedInfo = {\n    label: 'text-data.csv',\n    format: 'row'\n  };\n  t.equal(processed.length, 1, 'processFileData should return 1 result');\n  t.ok(processed[0].info, 'processFileData should have info');\n  t.ok(processed[0].data, 'processFileData should have data');\n  t.deepEqual(processed[0].info, expectedInfo, 'info should be correct');\n  const {\n    fields,\n    rows\n  } = processed[0].data;\n  fields.forEach((f, i) => cmpField(t, testFields[i], f, `should process correct field ${testFields[i].name}`));\n  rows.forEach((r, i) => {\n    t.deepEqual(r, parsedDataWithNulls[i], `should process row ${i} correctly`);\n  });\n  t.end();\n});","file":"browser/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> readFileInBatches.GeoJSON FeatureCollection -> processFileData","suites":[],"updatePoint":{"line":131,"column":85,"index":5379},"line":131,"code":"test('#file-handler -> readFileInBatches.GeoJSON FeatureCollection -> processFileData', async t => {\n  const geojsonFile = new File([geojsonString], 'text-data-1.geojson', {\n    type: ''\n  });\n  let gen = null;\n  try {\n    gen = await readFileInBatches({\n      file: geojsonFile,\n      fileList: []\n    });\n  } catch (e) {\n    t.equal(true, false, 'Should read file correctly');\n    t.end();\n    return;\n  }\n\n  // metadata batch\n  const batch1 = await gen.next();\n  const expected1 = {\n    value: {\n      batchType: 'metadata',\n      metadata: {\n        _loader: {},\n        _context: {}\n      },\n      data: [],\n      bytesUsed: 0,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch1.value).sort(), Object.keys(expected1.value).sort(), 'value should have same keys');\n  t.equal(batch1.value.batchType, expected1.value.batchType, 'batch1.batchType should be the same');\n  t.equal(batch1.value.fileName, expected1.value.fileName, 'batch1.fileName should be the same');\n  t.deepEqual(batch1.value.data, expected1.value.data, 'batch1.data should be the same');\n  t.deepEqual(batch1.value.progress, expected1.value.progress, 'batch1.progress should be the same');\n\n  // partial result batch\n  const batch2 = await gen.next();\n  const expected2 = {\n    value: {\n      shape: 'object-row-table',\n      batchType: 'partial-result',\n      container: {\n        type: 'FeatureCollection',\n        features: []\n      },\n      data: [],\n      length: 0,\n      bytesUsed: 0,\n      jsonpath: '$.features',\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.deepEqual(batch2, expected2, 'batch2 should be partial-result');\n  // data batch\n  const batch3 = await gen.next();\n  const expected3 = {\n    value: {\n      data: [],\n      // 13 features\n      schema: null,\n      length: 26,\n      cursor: 0,\n      count: 0,\n      bytesUsed: 4890,\n      jsonpath: '$.features',\n      progress: {\n        rowCount: 26,\n        rowCountInBatch: 26,\n        percent: 1\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.equal(batch3.value.data.length, 26, 'batch3 should data length 26');\n  t.equal(batch3.value.jsonpath, expected3.value.jsonpath, 'batch3 should have jsonpath');\n  t.deepEqual(batch3.value.progress, expected3.value.progress, 'batch3 should have progress');\n  t.equal(batch3.value.fileName, expected3.value.fileName, 'batch3 should have fileName');\n  t.equal(batch3.value.length, expected3.value.length, 'batch3 should have length');\n  const batch4 = await gen.next();\n  const expected4 = {\n    value: {\n      batchType: 'final-result',\n      container: {\n        type: 'FeatureCollection',\n        features: []\n      },\n      jsonpath: '$.features',\n      data: {\n        type: 'FeatureCollection',\n        features: []\n      },\n      // feature should be length 26\n      schema: null,\n      progress: {\n        rowCount: 26,\n        rowCountInBatch: 0\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.equal(batch4.value.data.type, 'FeatureCollection', 'batch4 should data be a geojson feature collection');\n  t.deepEqual(batch4.value.progress, expected4.value.progress, 'batch4 should have progress');\n  t.equal(batch4.value.fileName, expected4.value.fileName, 'batch4 should have fileName');\n  t.equal(batch4.value.data.features.length, 26, 'batch4 return 26 features');\n  const batch5 = await gen.next();\n  t.deepEqual(batch5, {\n    value: undefined,\n    done: true\n  }, 'batch5 should be done');\n\n  // process geojson data received\n  const processed = await processFileData({\n    content: batch4.value,\n    fileCache: []\n  });\n  const expectedInfo = {\n    label: 'text-data-1.geojson',\n    format: 'geojson'\n  };\n  t.equal(processed.length, 1, 'processFileData should return 1 result');\n  t.ok(processed[0].info, 'processFileData should have info');\n  t.ok(processed[0].data, 'processFileData should have data');\n  t.deepEqual(processed[0].info, expectedInfo, 'info should be correct');\n  const {\n    fields,\n    rows\n  } = processed[0].data;\n  fields.forEach((f, i) => cmpField(t, geojsonFields[i], f, `should process correct geojson field ${geojsonFields[i].name}`));\n  rows.forEach((r, i) => {\n    t.deepEqual(r, geojsonRows[i], `should process geojson row ${i} correctly`);\n  });\n  t.end();\n});","file":"browser/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> readFileInBatches.GeoJSON Single Feature -> processFileData","suites":[],"updatePoint":{"line":279,"column":82,"index":9885},"line":279,"code":"test('#file-handler -> readFileInBatches.GeoJSON Single Feature -> processFileData', async t => {\n  const geojsonFile = new File([featureString], 'text-data-1.geojson', {\n    type: ''\n  });\n  let gen = null;\n  try {\n    gen = await readFileInBatches({\n      file: geojsonFile,\n      fileList: []\n    });\n  } catch (e) {\n    t.equal(true, false, 'Should read file correctly');\n    t.end();\n    return;\n  }\n\n  // metadata batch\n  const batch1 = await gen.next();\n  const expected1 = {\n    value: {\n      batchType: 'metadata',\n      metadata: {\n        _loader: {},\n        _context: {}\n      },\n      data: [],\n      bytesUsed: 0,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch1.value).sort(), Object.keys(expected1.value).sort(), 'value should have same keys');\n  t.equal(batch1.value.batchType, expected1.value.batchType, 'batch1.batchType should be the same');\n  t.equal(batch1.value.fileName, expected1.value.fileName, 'batch1.fileName should be the same');\n  t.deepEqual(batch1.value.data, expected1.value.data, 'batch1.data should be the same');\n  t.deepEqual(batch1.value.progress, expected1.value.progress, 'batch1.progress should be the same');\n\n  // final result batch\n  const batch2 = await gen.next();\n  const expected2 = {\n    value: {\n      batchType: 'final-result',\n      container: processedFeature,\n      jsonpath: null,\n      data: processedFeature,\n      schema: null,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0\n      },\n      fileName: 'text-data-1.geojson'\n    },\n    done: false\n  };\n  t.deepEqual(batch2.value.batchType, expected2.value.batchType, 'batch2 batchType should be a final-result');\n  t.deepEqual(batch2.value.data, expected2.value.data, 'batch2 data should be a single geojson feature');\n  t.deepEqual(batch2.value.container, expected2.value.container, 'batch2 container should be a single geojson feature');\n  t.equal(batch2.value.jsonpath, expected2.value.jsonpath, 'batch2 jsonpath should be null');\n  t.deepEqual(batch2.value.progress, expected2.value.progress, 'batch2 progress should be correct');\n  const batch3 = await gen.next();\n  t.deepEqual(batch3, {\n    value: undefined,\n    done: true\n  }, 'batch3 should be done');\n\n  // process geojson data received\n  const processed = await processFileData({\n    content: batch2.value,\n    fileCache: []\n  });\n  const expectedInfo = {\n    label: 'text-data-1.geojson',\n    format: 'geojson'\n  };\n  t.equal(processed.length, 1, 'processFileData should return 1 result');\n  t.ok(processed[0].info, 'processFileData should have info');\n  t.ok(processed[0].data, 'processFileData should have data');\n  t.deepEqual(processed[0].info, expectedInfo, 'info should be correct');\n  const {\n    fields,\n    rows\n  } = processed[0].data;\n  fields.forEach((f, i) => cmpField(t, processedFeatureFields[i], f, `should process correct geojson field ${processedFeatureFields[i].name}`));\n  rows.forEach((r, i) => {\n    t.deepEqual(r, processedFeatureRows[i], `should process geojson row ${i} correctly`);\n  });\n  t.end();\n});","file":"browser/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> readFileInBatches.row -> processFileData","suites":[],"updatePoint":{"line":372,"column":63,"index":13031},"line":372,"code":"test('#file-handler -> readFileInBatches.row -> processFileData', async t => {\n  const fileName = 'row-data.json';\n  const rowFile = new File([rowDataString], fileName, {\n    type: ''\n  });\n  let gen = null;\n  try {\n    gen = await readFileInBatches({\n      file: rowFile,\n      fileList: []\n    });\n  } catch (e) {\n    t.equal(true, false, 'Should read file correctly');\n    t.end();\n    return;\n  }\n\n  // metadata batch\n  const batch1 = await gen.next();\n  const expected1 = {\n    value: {\n      batchType: 'metadata',\n      metadata: {\n        _loader: {},\n        _context: {}\n      },\n      data: [],\n      bytesUsed: 0,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch1.value).sort(), Object.keys(expected1.value).sort(), 'value should have same keys');\n  t.equal(batch1.value.batchType, expected1.value.batchType, 'batch1.batchType should be the same');\n  t.equal(batch1.value.fileName, expected1.value.fileName, 'batch1.fileName should be the same');\n  t.deepEqual(batch1.value.data, expected1.value.data, 'batch1.data should be the same');\n  t.deepEqual(batch1.value.progress, expected1.value.progress, 'batch1.progress should be the same');\n  const batch2 = await gen.next();\n  const expected2 = {\n    value: {\n      batchType: 'partial-result',\n      container: {},\n      // do not test\n      data: [],\n      bytesUsed: 0,\n      schema: null,\n      jsonpath: '$',\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(batch2.value.batchType, expected2.value.batchType, 'batch2 should be partial-result');\n  t.deepEqual(batch2.value.jsonpath, expected2.value.jsonpath, 'batch2 should be partial-result');\n  t.deepEqual(batch2.value.progress, expected2.value.progress, 'batch2 progress should be correct');\n  const batch3 = await gen.next();\n  const expected3 = {\n    value: {\n      data: [],\n      schema: null,\n      length: 8,\n      cursor: 0,\n      count: 0,\n      bytesUsed: 4552,\n      jsonpath: '$',\n      progress: {\n        rowCount: 8,\n        rowCountInBatch: 8,\n        percent: 1\n      },\n      fileName\n    },\n    done: false\n  };\n  t.equal(batch3.value.data.length, 8, 'batch3 should data length 26');\n  t.deepEqual(batch3.value.progress, expected3.value.progress, 'batch3 should have progress');\n  t.equal(batch3.value.fileName, expected3.value.fileName, 'batch3 should have fileName');\n  t.equal(batch3.value.length, expected3.value.length, 'batch3 should have length');\n  const batch4 = await gen.next();\n  const expected4 = {\n    value: {\n      batchType: 'final-result',\n      container: {},\n      // do not test\n      jsonpath: '$',\n      data: [],\n      // do not test\n      schema: null,\n      progress: {\n        rowCount: 8,\n        rowCountInBatch: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(batch4.value.progress, expected4.value.progress, 'batch4 should have progress');\n  t.equal(batch4.value.fileName, expected4.value.fileName, 'batch4 should have fileName');\n  t.equal(batch4.value.data.length, 8, 'batch4 return 8 rows');\n  const batch5 = await gen.next();\n  t.deepEqual(batch5, {\n    value: undefined,\n    done: true\n  }, 'batch5 should be done');\n  const processed = await processFileData({\n    content: batch4.value,\n    fileCache: []\n  });\n  const expectedFileCache = [{\n    data: {\n      fields: parsedFields,\n      rows: parsedRows\n    },\n    info: {\n      label: fileName,\n      format: 'row'\n    }\n  }];\n  t.equal(processed.length, 1, 'processFileData should return 1 result');\n  t.ok(processed[0].info, 'processFileData should have info');\n  t.ok(processed[0].data, 'processFileData should have data');\n  t.deepEqual(processed[0].info, expectedFileCache[0].info, 'info should be correct');\n  const {\n    fields,\n    rows\n  } = processed[0].data;\n  fields.forEach((f, i) => cmpField(t, expectedFileCache[0].data.fields[i], f, `should process correct row object field ${parsedFields[i].name}`));\n  rows.forEach((r, i) => {\n    t.deepEqual(r, expectedFileCache[0].data.rows[i], `should process row ${i} correctly`);\n  });\n  t.end();\n});","file":"browser/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> readFileInBatches.keplerMap -> processFileData","suites":[],"updatePoint":{"line":513,"column":69,"index":17265},"line":513,"code":"test('#file-handler -> readFileInBatches.keplerMap -> processFileData', async t => {\n  const fileName = 'keplergl.json';\n  const keplerGlMap = new File([JSON.stringify(keplerglMap)], fileName, {\n    type: ''\n  });\n  let gen = null;\n  try {\n    gen = await readFileInBatches({\n      file: keplerGlMap,\n      fileList: []\n    });\n  } catch (e) {\n    t.equal(true, false, 'Should read file correctly');\n    t.end();\n    return;\n  }\n\n  // metadata batch\n  const batch1 = await gen.next();\n  const expected1 = {\n    value: {\n      batchType: 'metadata',\n      metadata: {\n        _loader: {},\n        _context: {}\n      },\n      data: [],\n      bytesUsed: 0,\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(Object.keys(batch1.value).sort(), Object.keys(expected1.value).sort(), 'value should have same keys');\n  t.equal(batch1.value.batchType, expected1.value.batchType, 'batch1.batchType should be the same');\n  t.equal(batch1.value.fileName, expected1.value.fileName, 'batch1.fileName should be the same');\n  t.deepEqual(batch1.value.data, expected1.value.data, 'batch1.data should be the same');\n  t.deepEqual(batch1.value.progress, expected1.value.progress, 'batch1.progress should be the same');\n  const batch2 = await gen.next();\n  const expected2 = {\n    value: {\n      batchType: 'partial-result',\n      container: {},\n      // do not test\n      data: [],\n      bytesUsed: 0,\n      jsonpath: '$.datasets',\n      progress: {\n        rowCount: 0,\n        rowCountInBatch: 0,\n        percent: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(batch2.value.batchType, expected2.value.batchType, 'batch2 should be partial-result');\n  t.deepEqual(batch2.value.jsonpath, expected2.value.jsonpath, 'batch2 jsonapth should be correct');\n  t.deepEqual(batch2.value.schema, expected2.value.schema, 'batch2 schema should be correct');\n  t.deepEqual(batch2.value.progress, expected2.value.progress, 'batch2 progress should be correct');\n  const batch3 = await gen.next();\n  const expected3 = {\n    value: {\n      data: [],\n      length: 1,\n      cursor: 0,\n      count: 0,\n      bytesUsed: 4552,\n      jsonpath: '$.datasets',\n      progress: {\n        rowCount: 1,\n        rowCountInBatch: 1,\n        percent: 1\n      },\n      fileName\n    },\n    done: false\n  };\n  t.equal(batch3.value.data.length, 1, 'batch3 should data length 1');\n  t.deepEqual(batch3.value.progress, expected3.value.progress, 'batch3 should have progress');\n  t.equal(batch3.value.fileName, expected3.value.fileName, 'batch3 should have fileName');\n  t.equal(batch3.value.length, expected3.value.length, 'batch3 should have length');\n  const batch4 = await gen.next();\n  const expected4 = {\n    value: {\n      batchType: 'final-result',\n      container: {},\n      // do not test\n      jsonpath: '$.datasets',\n      data: [],\n      // do not test\n      progress: {\n        rowCount: 1,\n        rowCountInBatch: 0\n      },\n      fileName\n    },\n    done: false\n  };\n  t.deepEqual(batch4.value.progress, expected4.value.progress, 'batch4 should have progress');\n  t.deepEqual(batch4.value.batchType, expected4.value.batchType, 'batch4 should have batchType');\n  t.equal(batch4.value.fileName, expected4.value.fileName, 'batch4 should have fileName');\n  t.deepEqual(batch4.value.data, keplerglMap, 'batch4 should return saved kepler.gl map json');\n  const batch5 = await gen.next();\n  t.deepEqual(batch5, {\n    value: undefined,\n    done: true\n  }, 'batch5 should be done');\n\n  // process file\n  const processed = await processFileData({\n    content: batch4.value,\n    fileCache: []\n  });\n  const expectedInfo = {\n    label: fileName,\n    format: 'keplergl'\n  };\n  const expectedFileCache = [{\n    data: {\n      datasets: [{\n        data: {\n          fields: parsedKeplerMapFields,\n          rows: keplerglMap.datasets[0].data.allData\n        },\n        info: {\n          id: 'a5ybmwl2d',\n          label: 'geojson_as_string_small.csv',\n          color: [53, 92, 125]\n        }\n      }],\n      config: keplerglMap.config\n    },\n    info: expectedInfo\n  }];\n  t.equal(processed.length, 1, 'processFileData should return 1 result');\n  t.ok(processed[0].info, 'processFileData should have info');\n  t.ok(processed[0].data, 'processFileData should have data');\n  t.deepEqual(processed[0].info, expectedInfo, 'info should be correct');\n  t.deepEqual(Object.keys(processed[0].data), ['datasets', 'config'], 'processFileData of keplergl json should have datasets and config');\n  t.deepEqual(Object.keys(processed[0].data.datasets[0].data), ['fields', 'rows'], 'dataset should have fields and rows');\n  t.deepEqual(processed[0].data.datasets[0].data.rows, expectedFileCache[0].data.datasets[0].data.rows, 'should load datasets rows');\n  t.deepEqual(processed[0].data.datasets[0].data.fields, expectedFileCache[0].data.datasets[0].data.fields, 'should load and analyze datasets');\n  t.deepEqual(processed[0].data.datasets[0].info, expectedFileCache[0].data.datasets[0].info, 'should load correct file info');\n  t.deepEqual(Object.keys(processed[0].data.config), ['visState', 'mapStyle', 'mapState'], 'should prepare parsed config');\n  t.end();\n});","file":"browser/file-handler-test.js","skipped":false,"dir":"test"},{"name":"Select earthquakes example","suites":["Load map"],"updatePoint":{"line":34,"column":34,"index":1565},"line":34,"code":"  test('Select earthquakes example', async () => {\n    const selector = '#earthquakes .sample-map__image';\n    await page.waitForSelector('.demo-map-action');\n    await page.click('.demo-map-action');\n    await page.waitForSelector(selector);\n    await page.click(selector);\n    await detectModalClosing(page);\n    await page.waitFor(DEFAULT_WAIT_TIME.SHORT);\n    await testScreenshot(page);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Export Image","suites":["Load map"],"updatePoint":{"line":44,"column":20,"index":1958},"line":44,"code":"  test('Export Image', async () => {\n    const selector = '.save-export-dropdown #image';\n    await page.click(MAP_ACTIONS_CLASS_NAME);\n    await page.waitForSelector(selector);\n    await page.click(selector);\n    await page.waitForSelector('.preview-image-placeholder');\n    await page.waitFor(DEFAULT_WAIT_TIME.LONGER);\n    await testScreenshot(page);\n    await page.click(CONFIRM_BUTTON_CLASS_NAME);\n    await detectModalClosing(page);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Export Data - Filtered","suites":["Load map"],"updatePoint":{"line":55,"column":30,"index":2422},"line":55,"code":"  test('Export Data - Filtered', async () => {\n    const dataSelector = '.save-export-dropdown #data';\n    await page.click(MAP_ACTIONS_CLASS_NAME);\n    await page.waitForSelector(dataSelector);\n    await page.click(dataSelector);\n    await testScreenshot(page);\n    await page.click(CONFIRM_BUTTON_CLASS_NAME);\n    await detectModalClosing(page);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Export Data - Unfiltered","suites":["Load map"],"updatePoint":{"line":64,"column":32,"index":2787},"line":64,"code":"  test('Export Data - Unfiltered', async () => {\n    const dataSelector = '.save-export-dropdown #data';\n    await page.click(MAP_ACTIONS_CLASS_NAME);\n    await page.waitForSelector(dataSelector);\n    await page.click(dataSelector);\n    await page.waitForSelector('.unfiltered-option');\n    await page.click('.unfiltered-option');\n    await testScreenshot(page);\n    await page.click(CONFIRM_BUTTON_CLASS_NAME);\n    await detectModalClosing(page);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Show Legend","suites":["Load map"],"updatePoint":{"line":75,"column":19,"index":3237},"line":75,"code":"  test('Show Legend', async () => {\n    await page.click('.show-legend.map-control-button');\n    await page.waitForSelector('.map-legend');\n    await testScreenshot(page);\n    await page.waitForSelector('.close-map-control-item');\n    await page.click('.close-map-control-item');\n    await page.waitFor(DEFAULT_WAIT_TIME.SHORTER);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Split Map","suites":["Load map"],"updatePoint":{"line":83,"column":17,"index":3581},"line":83,"code":"  test('Split Map', async () => {\n    const splitMapButton = '.split-map.map-control-button';\n    const closeSplitMapButton = '.split-map.close-map.map-control-button';\n    await page.click(splitMapButton);\n    await page.waitFor(DEFAULT_WAIT_TIME.LONGER);\n    await page.waitForSelector(closeSplitMapButton);\n    await testScreenshot(page);\n    await page.click(closeSplitMapButton);\n    await page.waitForSelector(splitMapButton);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"Create Geo-Filter","suites":["Load map"],"updatePoint":{"line":93,"column":25,"index":4037},"line":93,"code":"  test('Create Geo-Filter', async () => {\n    await page.click('div[data-for=\"map-draw\"]');\n    await page.waitForSelector('.map-draw-controls .draw-rectangle');\n    await page.click('.map-draw-controls .draw-rectangle');\n\n    // top-left\n    await page.mouse.click(676, 268, {\n      button: 'left'\n    });\n\n    // bottom-right\n    await page.mouse.click(970, 485, {\n      button: 'left'\n    });\n    await testScreenshot(page);\n\n    // right click\n    await page.mouse.click(850, 350, {\n      button: 'right'\n    });\n\n    // hover layers item\n    await page.hover('.editor-layers-list');\n\n    // hover first layer\n    await page.hover('.editor-layers-list .layer-panel-item');\n\n    // click first layer\n    await page.click('.editor-layers-list .layer-panel-item');\n\n    // click outside polygon\n    await page.mouse.click(600, 485, {\n      button: 'left'\n    });\n    await page.waitFor(DEFAULT_WAIT_TIME.SHORT);\n    await testScreenshot(page);\n  }, TIMEOUT);","file":"e2e/upload-file.test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> isKeplerGlMap","suites":[],"updatePoint":{"line":25,"column":36,"index":1488},"line":25,"code":"test('#file-handler -> isKeplerGlMap', t => {\n  t.equal(isKeplerGlMap('{datasets: [], info: {app: \"kepler.gl\"}, config: {}}'), false, 'Should return false when passing a json string');\n  t.equal(isKeplerGlMap({\n    datasets: [],\n    info: {\n      app: 'kepler.gl'\n    },\n    config: {}\n  }), true, 'Should return true when object is a kepler map');\n  t.equal(isKeplerGlMap({\n    datasets: [],\n    info: {\n      app: 'kepler.gl'\n    }\n  }), false, 'Should return false when object is not a kepler map');\n  t.end();\n});","file":"node/processors/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> makeProgressIterator","suites":[],"updatePoint":{"line":42,"column":43,"index":2013},"line":42,"code":"test('#file-handler -> makeProgressIterator', async t => {\n  // mock AsyncIterator returned by loarder.gl patchInBatches\n  // Ideally should run this in browser-headless\n  async function* mock() {\n    let bytesUsed = 0;\n    let value = 0;\n    let b = 0;\n    await new Promise(resolve => setTimeout(resolve, 100));\n    while (b < 2) {\n      b += 1;\n      bytesUsed += 10;\n      value += 1;\n      yield {\n        data: [{\n          value\n        }],\n        bytesUsed\n      };\n    }\n  }\n  const asyncIterator = mock();\n  const info = {\n    size: 100\n  };\n  const progress = makeProgressIterator(asyncIterator, info);\n  const batch1 = await progress.next();\n  const batch2 = await progress.next();\n  const batch3 = await progress.next();\n  const expected1 = {\n    value: {\n      data: [{\n        value: 1\n      }],\n      bytesUsed: 10,\n      progress: {\n        rowCount: 1,\n        rowCountInBatch: 1,\n        percent: 0.1\n      }\n    },\n    done: false\n  };\n  const expected2 = {\n    value: {\n      data: [{\n        value: 2\n      }],\n      bytesUsed: 20,\n      progress: {\n        rowCount: 2,\n        rowCountInBatch: 1,\n        percent: 0.2\n      }\n    },\n    done: false\n  };\n  const expected3 = {\n    value: undefined,\n    done: true\n  };\n  t.deepEqual(batch1, expected1, 'batch1 should be correct');\n  t.deepEqual(batch2, expected2, 'batch2 should be correct');\n  t.deepEqual(batch3, expected3, 'batch3 should be correct');\n  t.end();\n});","file":"node/processors/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#file-handler -> filesToDataPayload","suites":[],"updatePoint":{"line":107,"column":41,"index":3455},"line":107,"code":"test('#file-handler -> filesToDataPayload', t => {\n  const fileCache = [{\n    data: {\n      fields: parsedFields,\n      rows: parsedRows\n    },\n    info: {\n      label: 'rows-data.json',\n      format: 'row'\n    }\n  }, {\n    data: {\n      datasets: [{\n        data: {\n          fields: parsedKeplerMapFields,\n          rows: keplerglMap.datasets[0].data.allData\n        },\n        info: {\n          id: 'a5ybmwl2d',\n          label: 'geojson_as_string_small.csv',\n          color: [53, 92, 125]\n        }\n      }],\n      config: keplerglMap.config\n    },\n    info: {\n      label: 'keplergl-map.json',\n      format: 'keplergl'\n    }\n  }];\n  const result = filesToDataPayload(fileCache);\n\n  // const expectedResults = [\n  //   {\n  //     datasets: [{data, info}],\n  //     config: {\n  //       version: 'v1',\n  //       config: {}\n  //     },\n  //     options: {centerMap: true}\n  //   },\n  //   {datasets: [{data, info}]}\n  // ];\n\n  t.equal(result.length, 2, 'result shoud have 2 entries');\n  t.deepEqual(Object.keys(result[0]), ['datasets', 'config', 'options'], 'result[0] should have 3 keys');\n  t.equal(result[0].datasets, fileCache[1].data.datasets, 'should save keplergl map datasets');\n  t.equal(result[0].config, fileCache[1].data.config, 'should save keplergl map config');\n  t.deepEqual(result[0].options, {\n    centerMap: true\n  }, 'should save keplergl map set {centerMap: true}');\n  t.deepEqual(Object.keys(result[1]), ['datasets'], 'result[0] should have 1 key');\n  t.deepEqual(result[1].datasets[0].data, fileCache[0].data, 'should pass file data to datasets only');\n  t.deepEqual(Object.keys(result[1].datasets[0].info), ['id', 'label', 'format'], 'result[0] datasets[0].info should have 3 key');\n  t.end();\n});","file":"node/processors/file-handler-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: mapStyle","suites":[],"updatePoint":{"line":58,"column":59,"index":2491},"line":58,"code":"test('#composerStateReducer - addDataToMapUpdater: mapStyle', t => {\n  // init kepler.gl root and instance\n  const state = keplerGlReducer(undefined, registerEntry({\n    id: 'test'\n  })).test;\n  const newState = addDataToMapUpdater(state, {\n    payload: {\n      datasets: {\n        data: mockRawData,\n        info: {\n          id: 'foo'\n        }\n      },\n      options: null,\n      config: {\n        mapStyle: {\n          styleType: 'light'\n        }\n      }\n    }\n  });\n  t.equal(newState.mapStyle.styleType, 'light', 'Map style is set correctly');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: mapState should be centered","suites":[],"updatePoint":{"line":82,"column":78,"index":3076},"line":82,"code":"test('#composerStateReducer - addDataToMapUpdater: mapState should be centered', t => {\n  // init kepler.gl root and instance\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n  const mapStateProperties = {\n    latitude: 33.88608913680742,\n    longitude: -84.43459130456425\n  };\n  const newState = addDataToMapUpdater(state, {\n    payload: {\n      datasets: {\n        data: mockRawData,\n        info: {\n          id: 'foo'\n        }\n      },\n      options: {\n        centerMap: true\n      },\n      config: {\n        mapState: mapStateProperties\n      }\n    }\n  });\n  t.equal(newState.mapState.latitude, 29.23, 'centerMap: true should override mapState config');\n  t.equal(newState.mapState.longitude, 60.71, 'centerMap: true should override mapState config');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: uiState","suites":[],"updatePoint":{"line":111,"column":58,"index":3860},"line":111,"code":"test('#composerStateReducer - addDataToMapUpdater: uiState', t => {\n  // init kepler.gl root and instance\n  const state = keplerGlReducer(undefined, registerEntry({\n    id: 'test'\n  })).test;\n  const newState = addDataToMapUpdater(state, {\n    payload: {\n      datasets: {\n        data: mockRawData,\n        info: {\n          id: 'foo'\n        }\n      }\n    }\n  });\n  const expectedUIState = {\n    ...INITIAL_UI_STATE,\n    initialState: {},\n    readOnly: false,\n    currentModal: null\n  };\n  t.deepEqual(newState.uiState, expectedUIState, 'ui state should be set readOnly:false,currentModal: null');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: keepExistingConfig","suites":[],"updatePoint":{"line":135,"column":69,"index":4486},"line":135,"code":"test('#composerStateReducer - addDataToMapUpdater: keepExistingConfig', t => {\n  const data = processCsvData(testCsvData);\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n\n  // old state contain splitMaps\n  const oldState = addDataToMapUpdater(state, {\n    payload: {\n      datasets: {\n        data,\n        info: {\n          id: sampleConfig.dataId\n        }\n      },\n      config: sampleConfig.config\n    }\n  });\n  const {\n    layers: oldLayers,\n    filters: oldFilters,\n    datasets: oldDatasets,\n    interactionConfig: oldInteractionConfig,\n    splitMaps: oldSplitMaps\n  } = oldState.visState;\n  const hexData = processCsvData(testHexIdData);\n  const hexDataId = hexIdDataConfig.dataId;\n\n  // keepExistingConfig is not defined, default to false\n  const nextState1 = addDataToMapUpdater(oldState, {\n    payload: {\n      datasets: {\n        data: hexData,\n        info: {\n          id: hexDataId\n        }\n      },\n      config: hexIdDataConfig.config\n    }\n  });\n  t.deepEqual(nextState1.visState.layerOrder, ['avlgol'], 'Should contain nextState1 layer order');\n  cmpDataset(t, expectedMergedDataset, nextState1.visState.datasets[hexDataId]);\n  t.deepEqual(nextState1.visState.splitMaps, [], 'should clear out splitMaps');\n  cmpLayers(t, [mergedH3Layer], nextState1.visState.layers);\n  cmpFilters(t, mergedFilters, nextState1.visState.filters);\n\n  // add data and config keep existing data and config\n  const nextState2 = addDataToMapUpdater(oldState, {\n    payload: {\n      datasets: {\n        data: hexData,\n        info: {\n          id: hexDataId\n        }\n      },\n      config: hexIdDataConfig.config,\n      options: {\n        keepExistingConfig: true\n      }\n    }\n  });\n  const actualVisState = nextState2.visState;\n  const newLayers = [...oldLayers, mergedH3Layer];\n  const expectedVisState = {\n    layers: newLayers,\n    filters: [...oldFilters, ...mergedFilters],\n    datasets: 'test seperate',\n    interactionConfig: {\n      ...oldInteractionConfig,\n      tooltip: {\n        ...oldInteractionConfig.tooltip,\n        config: {\n          compareMode: false,\n          compareType: 'absolute',\n          fieldsToShow: {\n            ...oldInteractionConfig.tooltip.config.fieldsToShow,\n            [hexDataId]: [{\n              name: 'hex_id',\n              format: null\n            }, {\n              name: 'value',\n              format: null\n            }]\n          }\n        }\n      }\n    },\n    splitMaps: [{\n      layers: {\n        ...oldSplitMaps[0].layers,\n        avlgol: true\n      }\n    }, {\n      layers: {\n        ...oldSplitMaps[1].layers,\n        avlgol: true\n      }\n    }],\n    layerOrder: [newLayers[2].id, newLayers[0].id, newLayers[1].id]\n  };\n  cmpLayers(t, expectedVisState.layers, actualVisState.layers);\n  cmpFilters(t, expectedVisState.filters, actualVisState.filters);\n  // test datasets\n  t.deepEqual(Object.keys(actualVisState.datasets), [sampleConfig.dataId, hexDataId], 'should save 2 datasets to state');\n  t.equal(actualVisState.datasets[sampleConfig.dataId], oldDatasets[sampleConfig.dataId], 'should keep oldDataset same');\n  cmpDataset(t, expectedMergedDataset, actualVisState.datasets[hexDataId], 'should merge and filter hexdata');\n  cmpInteraction(t, expectedVisState.interactionConfig, actualVisState.interactionConfig);\n  t.deepEqual(expectedVisState.layerOrder, actualVisState.layerOrder, 'Should create new layer, move it to the top');\n  t.deepEqual(expectedVisState.splitMaps, actualVisState.splitMaps, 'Should keep existing splitMaps, add new layers to splitMaps');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: readOnly","suites":[],"updatePoint":{"line":246,"column":59,"index":8043},"line":246,"code":"test('#composerStateReducer - addDataToMapUpdater: readOnly', t => {\n  const datasets = {\n    data: processCsvData(testCsvData),\n    info: {\n      id: sampleConfig.dataId\n    }\n  };\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n\n  // old state contain splitMaps\n  const nextState = addDataToMapUpdater(state, {\n    payload: {\n      datasets,\n      options: {\n        readOnly: true\n      }\n    }\n  });\n  t.equal(nextState.uiState.readOnly, true, 'should set readonly to be true');\n  const nextState1 = addDataToMapUpdater(state, {\n    payload: {\n      datasets\n    }\n  });\n  t.equal(nextState1.uiState.readOnly, false, 'should set readonly to be false');\n  const nextState2 = addDataToMapUpdater(state, {\n    payload: {\n      datasets,\n      options: {\n        readOnly: false\n      }\n    }\n  });\n  t.equal(nextState2.uiState.readOnly, false, 'should set readonly to be false');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - addDataToMapUpdater: autoCreateLayers","suites":[],"updatePoint":{"line":284,"column":67,"index":8978},"line":284,"code":"test('#composerStateReducer - addDataToMapUpdater: autoCreateLayers', t => {\n  const datasets = {\n    data: processCsvData(testCsvData),\n    info: {\n      id: sampleConfig.dataId\n    }\n  };\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n\n  // old state contain splitMaps\n  const nextState = addDataToMapUpdater(state, {\n    payload: {\n      datasets,\n      options: {\n        autoCreateLayers: false\n      }\n    }\n  });\n  t.equal(nextState.visState.layers.length, 0, 'should not create layers');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - replaceDataInMapUpdater","suites":[],"updatePoint":{"line":307,"column":53,"index":9507},"line":307,"code":"test('#composerStateReducer - replaceDataInMapUpdater', t => {\n  const dataIdToReplace = 'dataset_to_replace';\n  const datasets = {\n    data: processCsvData(testCsvData),\n    info: {\n      id: sampleConfig.dataId\n    }\n  };\n  const datasetToUse = {\n    data: processCsvData(dataWithNulls),\n    info: {\n      id: dataIdToReplace\n    }\n  };\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n\n  // old state contain splitMaps\n  const oldState = addDataToMapUpdater(state, {\n    payload: {\n      datasets,\n      config: sampleConfig.config\n    }\n  });\n  const oldSavedConfig = state.visState.schema.getConfigToSave(oldState).config;\n  const nextState = replaceDataInMapUpdater(oldState, {\n    payload: {\n      datasetToReplaceId: sampleConfig.dataId,\n      datasetToUse\n    }\n  });\n  const nextSavedConfig = nextState.visState.schema.getConfigToSave(nextState).config;\n  const expectedLayers = oldSavedConfig.visState.layers.map(l => ({\n    ...l,\n    config: {\n      ...l.config,\n      dataId: dataIdToReplace\n    }\n  }));\n  const bounds = nextState.visState.layers[0].meta.bounds;\n  const expectedMapState = fitBoundsUpdater(oldState.mapState, {\n    payload: bounds\n  });\n  const expectedInteractionConfig = {\n    ...oldSavedConfig.visState.interactionConfig,\n    tooltip: {\n      ...oldSavedConfig.visState.interactionConfig.tooltip,\n      fieldsToShow: {\n        [dataIdToReplace]: oldSavedConfig.visState.interactionConfig.tooltip.fieldsToShow[sampleConfig.dataId]\n      }\n    }\n  };\n\n  // dataWithNulls gps_data.utc_timestamp domain\n  const expectedFilterDomain = [1474071056000, 1474071677000];\n  const expectedFilter = {\n    ...oldSavedConfig.visState.filters[0],\n    dataId: [dataIdToReplace],\n    // reset vaue to bonded by domain\n    value: expectedFilterDomain\n  };\n  t.deepEqual(nextState.visState.filters[0].domain, expectedFilterDomain, 'Should set corect filter domain');\n  // compare replaced state with old state\n  Object.keys(oldSavedConfig).forEach(key => {\n    if (key === 'mapState') {\n      // should center map\n      t.deepEqual(nextState.mapState, expectedMapState, 'should center map to new layer;');\n    } else if (key === 'visState') {\n      Object.keys(oldSavedConfig.visState).forEach(prop => {\n        if (prop === 'layers') {\n          t.deepEqual(nextSavedConfig.visState.layers, expectedLayers, 'should replace layer dataId');\n        } else if (prop === 'filters') {\n          t.deepEqual(nextSavedConfig.visState.filters, [expectedFilter], 'should replace filter dataId and reset value');\n        } else if (prop === 'interactionConfig') {\n          t.deepEqual(nextSavedConfig.visState.interactionConfig, expectedInteractionConfig, 'should replace interactionConfig dataId');\n        } else {\n          t.deepEqual(nextSavedConfig.visState[prop], oldSavedConfig.visState[prop], `visState.${prop} should not change`);\n        }\n      });\n    } else {\n      // mapStyle\n      t.deepEqual(nextSavedConfig[key], oldSavedConfig[key], 'mapStyle should not change');\n    }\n  });\n  t.deepEqual(nextState.visState.layerToBeMerged, [], 'should reset layerToBeMerged');\n  t.deepEqual(nextState.visState.filterToBeMerged, [], 'should reset filterToBeMerged');\n  t.deepEqual(nextState.visState.interactionToBeMerged, {}, 'should reset interactionToBeMerged');\n  t.deepEqual(nextState.visState.splitMapsToBeMerged, [], 'should reset splitMapsToBeMerged');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#composerStateReducer - replaceDataInMapUpdater: same dataId","suites":[],"updatePoint":{"line":398,"column":66,"index":12938},"line":398,"code":"test('#composerStateReducer - replaceDataInMapUpdater: same dataId', t => {\n  const datasets = {\n    data: processCsvData(testCsvData),\n    info: {\n      id: sampleConfig.dataId\n    }\n  };\n  const datasetToUse = {\n    data: processCsvData(dataWithNulls),\n    info: {\n      id: sampleConfig.dataId\n    }\n  };\n  const state = keplerGlReducer({}, registerEntry({\n    id: 'test'\n  })).test;\n\n  // old state contain splitMaps\n  const oldState = addDataToMapUpdater(state, {\n    payload: {\n      datasets,\n      config: sampleConfig.config\n    }\n  });\n  const oldSavedConfig = state.visState.schema.getConfigToSave(oldState).config;\n  const nextState = replaceDataInMapUpdater(oldState, {\n    payload: {\n      datasetToReplaceId: sampleConfig.dataId,\n      datasetToUse\n    }\n  });\n\n  // dataset should be replaced\n  t.ok(nextState.visState.datasets[sampleConfig.dataId], ' dataset should be replaced');\n  const nextSavedConfig = nextState.visState.schema.getConfigToSave(nextState).config;\n  const expectedLayers = oldSavedConfig.visState.layers.map(l => ({\n    ...l,\n    config: {\n      ...l.config,\n      dataId: sampleConfig.dataId\n    }\n  }));\n  t.deepEqual(nextSavedConfig.visState.layers, expectedLayers, 'should replace layer dataId');\n  t.end();\n});","file":"node/reducers/composer-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer","suites":[],"updatePoint":{"line":25,"column":22,"index":1463},"line":25,"code":"test('#mapStateReducer', t => {\n  const newState = reducer(undefined, {});\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STATE,\n    initialState: {}\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducerFactory","suites":[],"updatePoint":{"line":33,"column":29,"index":1674},"line":33,"code":"test('#mapStateReducerFactory', t => {\n  const mapStateReducer = mapStateReducerFactory({\n    dragRotate: true\n  });\n  const newState = mapStateReducer(undefined, {});\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STATE,\n    dragRotate: true,\n    initialState: {\n      dragRotate: true\n    }\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> UPDATE_MAP","suites":[],"updatePoint":{"line":47,"column":36,"index":2028},"line":47,"code":"test('#mapStateReducer -> UPDATE_MAP', t => {\n  const mapUpdate = {\n    latitude: 24.123,\n    longitude: 120.839,\n    zoom: 2.3\n  };\n  const expectedState = {\n    ...InitialMapState,\n    ...mapUpdate\n  };\n  const newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'should update map longitude and latitude');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> UPDATE_MAP - minZoom/maxZoom","suites":[],"updatePoint":{"line":63,"column":54,"index":2458},"line":63,"code":"test('#mapStateReducer -> UPDATE_MAP - minZoom/maxZoom', t => {\n  let mapUpdate = {\n    zoom: 9,\n    maxZoom: 12\n  };\n  let expectedState = {\n    ...InitialMapState,\n    ...mapUpdate\n  };\n  let newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If zoom < maxZoom - zoom should stay the same');\n  mapUpdate = {\n    zoom: 14,\n    maxZoom: 12\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate,\n    ...{\n      zoom: mapUpdate.maxZoom\n    }\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If zoom > maxZoom - zoom should be equal to maxZoom');\n  mapUpdate = {\n    zoom: 15,\n    minZoom: 12\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If zoom > minZoom - zoom should stay the same');\n  mapUpdate = {\n    zoom: 9,\n    minZoom: 12\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate,\n    ...{\n      zoom: mapUpdate.minZoom\n    }\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If zoom < minZoom - zoom should be equal to minZoom');\n  mapUpdate = {\n    zoom: 9,\n    minZoom: 3,\n    maxZoom: 15\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If minZoom < zoom < maxZoom - zoom should stay the same');\n  mapUpdate = {\n    zoom: 9,\n    minZoom: 9,\n    maxZoom: 9\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If minZoom === zoom === maxZoom - zoom should stay the same');\n  mapUpdate = {\n    zoom: 15,\n    minZoom: 3,\n    maxZoom: 12\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate,\n    ...{\n      zoom: mapUpdate.maxZoom\n    }\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If minZoom < maxZoom < zoom - zoom should be equal to maxZoom');\n  mapUpdate = {\n    zoom: 3,\n    minZoom: 6,\n    maxZoom: 12\n  };\n  expectedState = {\n    ...InitialMapState,\n    ...mapUpdate,\n    ...{\n      zoom: mapUpdate.minZoom\n    }\n  };\n  newState = reducer(undefined, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'If zoom < minZoom < maxZoom - zoom should be equal to minZoom');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> UPDATE_MAP - maxBounds","suites":[],"updatePoint":{"line":162,"column":48,"index":4965},"line":162,"code":"test('#mapStateReducer -> UPDATE_MAP - maxBounds', t => {\n  let state = {\n    ...InitialMapState,\n    latitude: 37.685430657228906,\n    longitude: -122.20643775128097,\n    zoom: 5,\n    width: 640,\n    height: 480\n  };\n  let mapUpdate = {\n    maxBounds: [-122.47705311445556, 37.52481163037179, -121.93582238810639, 37.846049684086026]\n  };\n  let expectedState = {\n    ...state,\n    ...mapUpdate,\n    ...{\n      latitude: 37.68560457001023,\n      longitude: -122.20643775128097,\n      zoom: 9.699465540852673\n    }\n  };\n  let newState = reducer(state, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'maxBounds is snapped to the viewport');\n  state = {\n    ...InitialMapState,\n    latitude: 37.685430657228906,\n    longitude: -122.20643775128097,\n    zoom: 9,\n    width: 640,\n    height: 480,\n    maxBounds: [-122.47705311445556, 37.52481163037179, -121.93582238810639, 37.846049684086026]\n  };\n  mapUpdate = {\n    zoom: 12\n  };\n  expectedState = {\n    ...state,\n    ...mapUpdate\n  };\n  newState = reducer(state, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'Viewport is within maxBounds - zoomed in');\n  state = {\n    ...InitialMapState,\n    latitude: 37.685430657228906,\n    longitude: -122.20643775128097,\n    zoom: 9,\n    width: 640,\n    height: 480,\n    maxBounds: [-122.47705311445556, 37.52481163037179, -121.93582238810639, 37.846049684086026]\n  };\n  mapUpdate = {\n    zoom: 8\n  };\n  expectedState = {\n    ...state\n  };\n  newState = reducer(state, updateMap(mapUpdate, 0));\n  t.deepEqual(newState, expectedState, 'Viewport is outside the maxBounds - zoomed out');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> UPDATE_MAP - split map and unsynced viewports","suites":[],"updatePoint":{"line":222,"column":71,"index":6611},"line":222,"code":"test('#mapStateReducer -> UPDATE_MAP - split map and unsynced viewports', t => {\n  // toggle to split mode\n  let newState = reducer(INITIAL_MAP_STATE, toggleSplitMap());\n  // change to unsynced viewports and retain default isZoomLocked\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: false\n  }));\n  // and then update map for unsynced viewport of mapIndex 0\n  let mapUpdate = {\n    latitude: 24.123,\n    longitude: 120.839,\n    zoom: 2.3\n  };\n  const firstUnsyncedSplitMapViewportBeforeUpdatingMapState = {\n    ...newState.splitMapViewports[0]\n  };\n  newState = reducer(newState, updateMap(mapUpdate, 0));\n  t.notDeepEqual(newState.splitMapViewports[0], firstUnsyncedSplitMapViewportBeforeUpdatingMapState, 'unlocked zoom: updating mapIndex 0 should change the same split map viewport');\n  t.deepEqual(newState.splitMapViewports[1], firstUnsyncedSplitMapViewportBeforeUpdatingMapState, 'unlocked zoom: updating mapIndex 0 should not change the other split map viewport');\n  t.notEqual(newState.splitMapViewports[0].zoom, newState.splitMapViewports[1].zoom, 'unlocked zoom: should not set both viewports to the same zoom prop');\n\n  // retain unsycned viewports and change to isZoomLocked true\n  newState = reducer(newState, toggleSplitMapViewport({\n    isZoomLocked: true\n  }));\n  // and then update map for unsynced viewport and locked zoom of mapIndex 1\n  mapUpdate = {\n    latitude: 25,\n    longitude: 123,\n    zoom: 10\n  };\n  const expectedFistUnsyncedSplitMapViewportWithLockedZoom = {\n    ...newState.splitMapViewports[0],\n    zoom: mapUpdate.zoom\n  };\n  const secondUnsyncedSplitMapViewportBeforeUpdatingMapState = {\n    ...newState.splitMapViewports[1]\n  };\n  newState = reducer(newState, updateMap(mapUpdate, 1));\n  t.notDeepEqual(newState.splitMapViewports[1], secondUnsyncedSplitMapViewportBeforeUpdatingMapState, 'locked zoom: updating mapIndex 1 should change the same split map viewport');\n  t.deepEqual(newState.splitMapViewports[0], expectedFistUnsyncedSplitMapViewportWithLockedZoom, 'locked zoom: updating mapIndex 1 should only change the zoom property of the other split map viewport but not other properties');\n  t.equal(newState.splitMapViewports[0].zoom, newState.splitMapViewports[1].zoom, 'locked zoom: should set both viewports to the same zoom');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> TOGGLE_PERSPECTIVE","suites":[],"updatePoint":{"line":266,"column":44,"index":8902},"line":266,"code":"test('#mapStateReducer -> TOGGLE_PERSPECTIVE', t => {\n  const newState = reducer(undefined, {});\n  t.equal(newState.dragRotate, false, 'dragRotate should default to false');\n  const newState2 = reducer(undefined, togglePerspective());\n  t.equal(newState2.dragRotate, true, 'dragRotate toggle should set it to true');\n  t.equal(newState2.pitch, 50, 'pitch should set to default');\n  t.equal(newState2.bearing, 24, 'bearing should set to default');\n  const newState3 = reducer(newState2, togglePerspective());\n  t.equal(newState3.dragRotate, false, 'dragRotate 2nd toggle should set it to false');\n  t.equal(newState3.pitch, 0, 'pitch should set to zero');\n  t.equal(newState3.bearing, 0, 'bearing should set to zero');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> TOGGLE_PERSPECTIVE - split map and unsynced viewports","suites":[],"updatePoint":{"line":279,"column":79,"index":9670},"line":279,"code":"test('#mapStateReducer -> TOGGLE_PERSPECTIVE - split map and unsynced viewports', t => {\n  // toggle to split mode\n  let newState = reducer(INITIAL_MAP_STATE, toggleSplitMap());\n  // change to unsynced viewports\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: false,\n    isZoomLocked: false\n  }));\n  // and then toggle perspective\n  newState = reducer(newState, togglePerspective());\n  t.equal(newState.dragRotate, newState.splitMapViewports[0].dragRotate, 'split map with unsynced viewports: dragRotate should be copied to the first split viewport');\n  t.equal(newState.dragRotate, newState.splitMapViewports[1].dragRotate, 'split map with unsynced viewports: dragRotate should be copied to the second split viewport');\n  t.equal(newState.pitch, newState.splitMapViewports[0].pitch, 'split map with unsynced viewports: pitch should be copied to the first split viewport');\n  t.equal(newState.pitch, newState.splitMapViewports[1].pitch, 'split map with unsynced viewports: pitch should be copied to the second split viewport');\n  t.equal(newState.bearing, newState.splitMapViewports[0].bearing, 'split map with unsynced viewports: bearing should be copied to the first split viewport');\n  t.equal(newState.bearing, newState.splitMapViewports[1].bearing, 'split map with unsynced viewports: bearing should be copied to the second split viewport');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> FIT_BOUNDS","suites":[],"updatePoint":{"line":297,"column":36,"index":11019},"line":297,"code":"test('#mapStateReducer -> FIT_BOUNDS', t => {\n  // default input and output in @mapbox/geo-viewport\n  // https://github.com/mapbox/geo-viewport\n\n  const bounds = [5.668343999999995, 45.111511000000014, 5.852471999999996, 45.26800200000002];\n  const mapUpdate = {\n    width: 640,\n    height: 480\n  };\n  const expected = {\n    center: [5.7604079999999955, 45.189756500000016],\n    zoom: 10\n  };\n  const stateWidthMapDimension = reducer(undefined, updateMap(mapUpdate, 0));\n  const updatedState = reducer(stateWidthMapDimension, fitBounds(bounds));\n  t.equal(updatedState.latitude, expected.center[1], 'should fit latitude');\n  t.equal(updatedState.longitude, expected.center[0], 'should fit longitude');\n  t.equal(updatedState.zoom, expected.zoom, 'should fit zoom');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> FIT_BOUNDS - split map and unsynced viewports","suites":[],"updatePoint":{"line":317,"column":71,"index":11835},"line":317,"code":"test('#mapStateReducer -> FIT_BOUNDS - split map and unsynced viewports', t => {\n  // default input and output in @mapbox/geo-viewport\n  // https://github.com/mapbox/geo-viewport\n\n  const bounds = [5.668343999999995, 45.111511000000014, 5.852471999999996, 45.26800200000002];\n\n  // toggle to split mode\n  let newState = reducer(INITIAL_MAP_STATE, toggleSplitMap());\n  // change to unsynced viewports\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: false,\n    isZoomLocked: false\n  }));\n  // and then fit bounds\n  newState = reducer(newState, fitBounds(bounds));\n  t.equal(newState.latitude, newState.splitMapViewports[0].latitude, 'split map with unsynced viewports: latitude should be copied to the first split viewport');\n  t.equal(newState.latitude, newState.splitMapViewports[1].latitude, 'split map with unsynced viewports: latitude should be copied to the second split viewport');\n  t.equal(newState.longitude, newState.splitMapViewports[0].longitude, 'split map with unsynced viewports: longitude should be copied to the first split viewport');\n  t.equal(newState.longitude, newState.splitMapViewports[1].longitude, 'split map with unsynced viewports: longitude should be copied to the second split viewport');\n  t.equal(newState.zoom, newState.splitMapViewports[0].zoom, 'split map with unsynced viewports: zoom should be copied to the first split viewport');\n  t.equal(newState.zoom, newState.splitMapViewports[1].zoom, 'split map with unsynced viewports: zoom should be copied to the second split viewport');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> FIT_BOUNDS.invalid","suites":[],"updatePoint":{"line":340,"column":44,"index":13372},"line":340,"code":"test('#mapStateReducer -> FIT_BOUNDS.invalid', t => {\n  // default input and output in @mapbox/geo-viewport\n  // https://github.com/mapbox/geo-viewport\n\n  const mapUpdate = {\n    width: 640,\n    height: 480\n  };\n  const stateWidthMapDimension = reducer(undefined, updateMap(mapUpdate, 0));\n  const updatedState = reducer(stateWidthMapDimension, fitBounds(null));\n  t.equal(updatedState, stateWidthMapDimension, 'should not update state when bounds is invalid');\n  const updatedState2 = reducer(stateWidthMapDimension, fitBounds([500, -100, 322, 9]));\n  t.equal(updatedState2, stateWidthMapDimension, 'should not update state when bounds is invalid');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> SPLIT_MAP: toggle","suites":[],"updatePoint":{"line":355,"column":43,"index":14037},"line":355,"code":"test('#mapStateReducer -> SPLIT_MAP: toggle', t => {\n  let newState = reducer(INITIAL_MAP_STATE, toggleSplitMap());\n  const expectedState = {\n    ...INITIAL_MAP_STATE,\n    isSplit: true,\n    width: 400\n  };\n\n  // validate the first split\n  t.deepEqual(newState, expectedState, 'should validate toggle split view');\n\n  // go back to single view\n  newState = reducer(newState, toggleSplitMap());\n  t.deepEqual(newState, INITIAL_MAP_STATE, 'should validate toggle back from split view');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> SPLIT_MAP: upload mapState config to update split map state","suites":[],"updatePoint":{"line":371,"column":85,"index":14579},"line":371,"code":"test('#mapStateReducer -> SPLIT_MAP: upload mapState config to update split map state', t => {\n  let state = {\n    ...INITIAL_MAP_STATE,\n    isSplit: true,\n    width: 400\n  };\n\n  // cases:\n\n  // 1. state split: true - isSplit: true\n  // do nothing\n  let newState = reducer(state, receiveMapConfig({\n    mapState: {\n      isSplit: true\n    }\n  }));\n  t.deepEqual(newState, state, 'setting isSplit to true when state is already split should not change the state');\n\n  // 2. state split: false - isSplit: false\n  // do nothing\n  state = {\n    ...state,\n    isSplit: false,\n    width: 800\n  };\n  newState = reducer(state, receiveMapConfig({\n    mapState: {\n      isSplit: false\n    }\n  }));\n  t.deepEqual(newState, state, 'setting isSplit to false when state is not split should not change the state');\n\n  // 3. state split: true - isSplit: false\n  // double width\n  state = {\n    ...state,\n    isSplit: true,\n    width: 400\n  };\n  newState = reducer(state, receiveMapConfig({\n    mapState: {\n      isSplit: false\n    }\n  }));\n  t.deepEqual(newState, {\n    ...state,\n    width: 800,\n    isSplit: false\n  }, 'setting isSplit to false when state is already split should double width');\n\n  // 4. state split: false - isSplit: true\n  // split width\n  state = {\n    ...state,\n    isSplit: false,\n    width: 800\n  };\n  newState = reducer(state, receiveMapConfig({\n    mapState: {\n      isSplit: true\n    }\n  }));\n  t.deepEqual(newState, {\n    ...state,\n    width: 400,\n    isSplit: true\n  }, 'setting isSplit to true when state is already split should reduce width by half');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> SPLIT_MAP: close map at specific point","suites":[],"updatePoint":{"line":440,"column":64,"index":16139},"line":440,"code":"test('#mapStateReducer -> SPLIT_MAP: close map at specific point', t => {\n  let newState = reducer(INITIAL_MAP_STATE, toggleSplitMap());\n  const expectedState = {\n    ...INITIAL_MAP_STATE,\n    isSplit: true,\n    width: 400\n  };\n\n  // validate the first split\n  t.deepEqual(newState, expectedState, 'should validate toggle split view');\n\n  // go back to single view\n  newState = reducer(newState, toggleSplitMap(1));\n  t.deepEqual(newState, INITIAL_MAP_STATE, 'should validate toggle back from split view');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStateReducer -> TOGGLE_SPLIT_MAP_VIEWPORT","suites":[],"updatePoint":{"line":456,"column":51,"index":16648},"line":456,"code":"test('#mapStateReducer -> TOGGLE_SPLIT_MAP_VIEWPORT', t => {\n  let newState = reducer(INITIAL_MAP_STATE, {});\n  let expectedState = {\n    ...INITIAL_MAP_STATE,\n    isSplit: false,\n    isViewportSynced: true,\n    isZoomLocked: false,\n    splitMapViewports: []\n  };\n\n  // validate defaults before making state changes\n  t.deepEqual(newState, expectedState, 'should retain default initial state values for isSplit, isViewportSynced, isZoomLocked, and splitMapViewports');\n\n  // toggle to split mode and retain defaults of synced viewports and unlocked zoom\n  newState = reducer(newState, toggleSplitMap());\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: true,\n    isZoomLocked: false\n  }));\n  expectedState = {\n    ...newState,\n    isSplit: true,\n    isViewportSynced: true,\n    isZoomLocked: false,\n    splitMapViewports: []\n  };\n  t.deepEqual(newState, expectedState, 'toggling isSplit to true and setting isViewportSynced to true and isZoomLocked to false should retain default related initial state values');\n\n  // keep split mode and change synced viewports, but keep zoom lock as false\n  const splitMapViewportsBeforeOnlyChangingIsViewportSyncedFalse = [...newState.splitMapViewports];\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: false\n  }));\n  t.equal(newState.isViewportSynced, false, 'changing isViewportSynced to false should update the same prop in next state');\n  t.notDeepEqual(newState.splitMapViewports, splitMapViewportsBeforeOnlyChangingIsViewportSyncedFalse, 'changing isViewportSynced to false while retaining isZoomLocked as false should modify the splitMapViewports array');\n\n  // change one of the split viewports' zoom levels\n  // then switch on locked zoom while retaining unsynced\n  newState = reducer(newState, updateMap({\n    zoom: 5\n  }, 1));\n  newState = reducer(newState, toggleSplitMapViewport({\n    isZoomLocked: true\n  }));\n  t.equal(newState.isZoomLocked, true, 'changing isZoomLocked to true should update the same prop in next state');\n\n  // and test if they both now have the same zoom\n  t.equal(newState.splitMapViewports[0].zoom, newState.splitMapViewports[1].zoom, 'while isViewportSynced is false, changing isZoomLocked to true should modify the splitMapViewports array to have matching zoom values');\n\n  // switch off locked zoom while retaining unsynced\n  const splitMapViewportsBeforeOnlyChangingIsZoomLockedFalse = [...newState.splitMapViewports];\n  newState = reducer(newState, toggleSplitMapViewport({\n    isZoomLocked: false\n  }));\n  t.equal(newState.isZoomLocked, false, 'changing isZoomLocked to false should update the same prop in next state');\n  t.deepEqual(newState.splitMapViewports, splitMapViewportsBeforeOnlyChangingIsZoomLockedFalse, 'while isViewportSynced is false, changing isZoomLocked to false should not modify the splitMapViewports array');\n\n  // toggle from unsynced to synced viewports while retaining zoom lock as false\n  newState = reducer(newState, toggleSplitMapViewport({\n    isViewportSynced: true\n  }));\n  t.deepEqual(newState.splitMapViewports, [], 'changing isViewportSynced to false should change the splitMapViewports array to be empty');\n  t.equal(newState.isZoomLocked, false, 'changing isViewportSynced to false should also retain isZoomLocked as false');\n  t.end();\n});","file":"node/reducers/map-state-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer","suites":[],"updatePoint":{"line":32,"column":22,"index":1864},"line":32,"code":"test('#mapStyleReducer', t => {\n  const newState = reducer(undefined, {});\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STYLE,\n    initialState: {}\n  }, 'should return the initial map style');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> INIT","suites":[],"updatePoint":{"line":40,"column":30,"index":2080},"line":40,"code":"test('#mapStyleReducer -> INIT', t => {\n  const initialState = reducer(InitialMapStyle, keplerGlInit());\n  t.deepEqual(initialState, {\n    ...INITIAL_MAP_STYLE,\n    initialState: {}\n  }, 'initialize map style with no argument');\n  const newState = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: 'http://mydomain.com'\n  }));\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STYLE,\n    initialState: {},\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: 'http://mydomain.com'\n  }, 'initialize map style with mapboxApiAccessToken');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> INIT & LOAD_MAP_STYLES","suites":[],"updatePoint":{"line":58,"column":48,"index":2722},"line":58,"code":"test('#mapStyleReducer -> INIT & LOAD_MAP_STYLES', t => {\n  const newState = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token'\n  }));\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STYLE,\n    initialState: {},\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: DEFAULT_MAPBOX_API_URL\n  }, 'initialize map style with mapboxApiAccessToken and mapStylesReplaceDefault; mapStyles empty');\n  const finalState = loadMapStylesUpdater(newState, {\n    payload: {\n      newStyles: INITIAL_MAP_STYLE.mapStyles\n    }\n  });\n\n  // should start loading default dark style\n  t.deepEqual(finalState, {\n    ...newState,\n    isLoading: {\n      dark: true\n    }\n  }, 'user provided mapStyles are populated, defaults ignored');\n  const tasks = drainTasksForTesting();\n  t.equal(tasks.length, 1, 'should dispatch request map style task');\n  const expectedTask = {\n    payload: [{\n      id: 'dark',\n      url: 'https://api.mapbox.com/styles/v1/uberdata/cjoqbbf6l9k302sl96tyvka09?pluginName=Keplergl&access_token=smoothies_secret_token'\n    }]\n  };\n  t.deepEqual(tasks[0].payload, expectedTask.payload, 'should have correct load map style task');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> INIT & LOAD_MAP_STYLES ->  mapStylesReplaceDefault: true","suites":[],"updatePoint":{"line":92,"column":82,"index":3952},"line":92,"code":"test('#mapStyleReducer -> INIT & LOAD_MAP_STYLES ->  mapStylesReplaceDefault: true', t => {\n  const myMapStyle = {\n    id: 'default dark v9',\n    label: 'default dark v9',\n    url: 'mapbox://styles/mapbox/dark-v9',\n    icon: `images/light.png`,\n    layerGroups: []\n  };\n  const newState = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapStylesReplaceDefault: true\n  }));\n  t.deepEqual(newState, {\n    ...INITIAL_MAP_STYLE,\n    mapStyles: {},\n    initialState: {},\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: DEFAULT_MAPBOX_API_URL,\n    mapStylesReplaceDefault: true\n  }, 'initialize map style with mapboxApiAccessToken and mapStylesReplaceDefault; mapStyles empty');\n  const mapStyles = {\n    [myMapStyle.id]: myMapStyle\n  };\n  const finalState = loadMapStylesUpdater(newState, {\n    payload: {\n      newStyles: mapStyles\n    }\n  });\n  t.deepEqual(finalState, {\n    ...newState,\n    mapStyles\n  }, 'user provided mapStyles are populated, defaults ignored');\n  const tasks = drainTasksForTesting();\n  t.equal(tasks.length, 0, 'should not dispatch request map style task');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> RECEIVE_MAP_CONFIG","suites":[],"updatePoint":{"line":128,"column":44,"index":5078},"line":128,"code":"test('#mapStyleReducer -> RECEIVE_MAP_CONFIG', t => {\n  const stateWithToken = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token'\n  }));\n  const stateToSave = StateWCustomMapStyle;\n\n  // save state\n  const savedState = SchemaManager.getConfigToSave(stateToSave);\n\n  // load state\n  const stateLoaded = SchemaManager.parseSavedConfig(savedState);\n  const stateWithConfig = reducer(stateWithToken, receiveMapConfig(stateLoaded));\n  const defaultMapStyles = DEFAULT_MAP_STYLES.reduce((accu, st) => ({\n    ...accu,\n    [st.id]: st\n  }), {});\n  const expectedStateWithConfig = {\n    styleType: 'smoothie_the_cat',\n    visibleLayerGroups: {\n      label: true,\n      road: true\n    },\n    topLayerGroups: {},\n    mapStyles: {\n      smoothie_the_cat: {\n        accessToken: 'secret_token',\n        custom: true,\n        icon: 'https://api.mapbox.com/styles/v1/shanhe/smoothie.the.cat/static/-122.3391,37.7922,9,0,0/400x300?access_token=secret_token&logo=false&attribution=false',\n        id: 'smoothie_the_cat',\n        label: 'Smoothie the Cat',\n        url: 'mapbox://styles/shanhe/smoothie.the.cat'\n      },\n      ...defaultMapStyles\n    },\n    isLoading: {\n      smoothie_the_cat: true\n    },\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: DEFAULT_MAPBOX_API_URL,\n    mapStylesReplaceDefault: false,\n    inputStyle: getInitialInputStyle(),\n    threeDBuildingColor: [1, 2, 3],\n    custom3DBuildingColor: true,\n    backgroundColor: [255, 255, 255],\n    bottomMapStyle: undefined,\n    topMapStyle: undefined,\n    initialState: {}\n  };\n  t.deepEqual(stateWithConfig, expectedStateWithConfig, 'should load saved map style config');\n  Object.keys(stateWithConfig).forEach(key => {\n    t.deepEqual(stateWithConfig[key], expectedStateWithConfig[key], 'should load saved map style config');\n  });\n  const [task1, ...more1] = drainTasksForTesting();\n  t.equal(more1.length, 0, 'should return 1 tasks');\n  const expectedTask = {\n    payload: [{\n      id: 'smoothie_the_cat',\n      url: 'https://api.mapbox.com/styles/v1/shanhe/smoothie.the.cat?pluginName=Keplergl&access_token=secret_token'\n    }]\n  };\n  t.deepEqual(task1.payload, expectedTask.payload, 'should create task to load map styles');\n  const resultState1 = reducer(stateWithConfig, succeedTaskWithValues(task1, [{\n    id: 'smoothie_the_cat',\n    style: {\n      layers: [],\n      name: 'smoothie_the_cat'\n    }\n  }]));\n  const expectedMapStyles = {\n    smoothie_the_cat: {\n      accessToken: 'secret_token',\n      custom: true,\n      icon: 'https://api.mapbox.com/styles/v1/shanhe/smoothie.the.cat/static/-122.3391,37.7922,9,0,0/400x300?access_token=secret_token&logo=false&attribution=false',\n      id: 'smoothie_the_cat',\n      label: 'Smoothie the Cat',\n      url: 'mapbox://styles/shanhe/smoothie.the.cat',\n      style: {\n        layers: [],\n        name: 'smoothie_the_cat'\n      },\n      layerGroups: []\n    },\n    ...defaultMapStyles\n  };\n  const expectedMapStyleState = {\n    styleType: 'smoothie_the_cat',\n    visibleLayerGroups: {},\n    topLayerGroups: {},\n    mapStyles: expectedMapStyles,\n    mapboxApiAccessToken: 'smoothies_secret_token',\n    mapboxApiUrl: DEFAULT_MAPBOX_API_URL,\n    mapStylesReplaceDefault: false,\n    inputStyle: getInitialInputStyle(),\n    threeDBuildingColor: [1, 2, 3],\n    custom3DBuildingColor: true,\n    backgroundColor: [255, 255, 255],\n    initialState: {},\n    bottomMapStyle: {\n      layers: [],\n      name: 'smoothie_the_cat'\n    },\n    topMapStyle: null,\n    editable: 0,\n    isLoading: {\n      smoothie_the_cat: false\n    }\n  };\n  t.deepEqual(Object.keys(resultState1).sort(), Object.keys(expectedMapStyleState).sort(), 'mapStyle state should have same keys');\n  Object.keys(resultState1).forEach(key => {\n    t.deepEqual(resultState1[key], expectedMapStyleState[key], `should update state,${key} with loaded map styles`);\n  });\n  const savedConfig = SchemaManager.getConfigToSave({\n    mapStyle: resultState1\n  });\n  const expectedSaved = {\n    version: 'v1',\n    config: {\n      mapStyle: {\n        styleType: 'smoothie_the_cat',\n        topLayerGroups: {},\n        visibleLayerGroups: {},\n        threeDBuildingColor: [1, 2, 3],\n        backgroundColor: [255, 255, 255],\n        mapStyles: {\n          smoothie_the_cat: {\n            accessToken: 'secret_token',\n            custom: true,\n            icon: 'https://api.mapbox.com/styles/v1/shanhe/smoothie.the.cat/static/-122.3391,37.7922,9,0,0/400x300?access_token=secret_token&logo=false&attribution=false',\n            id: 'smoothie_the_cat',\n            label: 'Smoothie the Cat',\n            url: 'mapbox://styles/shanhe/smoothie.the.cat'\n          }\n        }\n      }\n    }\n  };\n  t.deepEqual(Object.keys(savedConfig).sort(), Object.keys(expectedSaved).sort(), 'mapStyle state saved should have same keys');\n  Object.keys(savedConfig).forEach(key => {\n    t.deepEqual(savedConfig[key], expectedSaved[key], `should save state.${key} with correctly`);\n  });\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> MAP_STYLE_CHANGE","suites":[],"updatePoint":{"line":272,"column":42,"index":10107},"line":272,"code":"test('#mapStyleReducer -> MAP_STYLE_CHANGE', t => {\n  const initialState = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token'\n  }));\n\n  // loadMapStyles\n  const nextState = reducer(initialState, loadMapStyles({\n    dark: MOCK_MAP_STYLE\n  }));\n  t.deepEqual(nextState.mapStyles.dark, MOCK_MAP_STYLE, 'should load map style');\n  t.deepEqual(nextState.bottomMapStyle, MOCK_MAP_STYLE.style, 'bottomMapStyle should be set');\n  t.equal(nextState.topMapStyle, null, 'topMapStyle should be set');\n  t.equal(nextState.editable, 7, 'editable should be set');\n  t.deepEqual(nextState.visibleLayerGroups, {\n    label: true,\n    road: true,\n    border: false,\n    building: true,\n    water: true,\n    land: true,\n    '3d building': false\n  }, 'should set visibleLayerGroups');\n\n  // move label to be on top\n  const nextState1 = reducer(nextState, mapConfigChange({\n    topLayerGroups: {\n      label: true,\n      road: true\n    }\n  }));\n  const expectedTopStyle = {\n    ...MOCK_MAP_STYLE.style,\n    layers: [{\n      id: 'road-path-rough',\n      type: 'line',\n      source: 'composite',\n      'source-layer': 'road'\n    }, {\n      minzoom: 13,\n      type: 'line',\n      source: 'composite',\n      id: 'bridge-rail',\n      'source-layer': 'road'\n    }, {\n      type: 'symbol',\n      source: 'composite',\n      id: 'country-label-sm',\n      'source-layer': 'country_label'\n    }]\n  };\n  t.deepEqual(nextState1.topMapStyle, expectedTopStyle, 'topMapStyle should be set correctly');\n\n  // hide road layer\n  const nextState2 = reducer(nextState1, mapConfigChange({\n    visibleLayerGroups: {\n      ...nextState1.visibleLayerGroups,\n      road: false\n    }\n  }));\n  const expectedTopStyle2 = {\n    ...MOCK_MAP_STYLE.style,\n    layers: [{\n      type: 'symbol',\n      source: 'composite',\n      id: 'country-label-sm',\n      'source-layer': 'country_label'\n    }]\n  };\n  t.deepEqual(nextState2.topMapStyle, expectedTopStyle2, 'topMapStyle should be set correctly');\n\n  // set style type to light\n  const nextState3 = reducer(nextState2, mapStyleChange('light'));\n  const tasks = drainTasksForTesting();\n  t.equal(tasks.length, 1, 'should dispatch 1 request map style task');\n  const expectedNextState3 = {\n    ...nextState2,\n    styleType: 'light',\n    isLoading: {\n      light: true\n    }\n  };\n  const expectedTaskPayload = [{\n    id: 'light',\n    url: 'https://api.mapbox.com/styles/v1/uberdata/cjoqb9j339k1f2sl9t5ic5bn4?pluginName=Keplergl&access_token=smoothies_secret_token'\n  }];\n  t.deepEqual(nextState3, expectedNextState3, 'state should be correct');\n  t.deepEqual(tasks[0].payload, expectedTaskPayload, 'should dispatch load light map style task');\n\n  // successfully load light map style\n  const succeedState = reducer(nextState3, succeedTaskWithValues(tasks[0], [{\n    id: 'light',\n    style: MOCK_MAP_STYLE_LIGHT.style\n  }]));\n  const expectedMapStyles = {\n    ...nextState3.mapStyles,\n    light: {\n      ...nextState3.mapStyles.light,\n      style: MOCK_MAP_STYLE_LIGHT.style\n    }\n  };\n  t.deepEqual(succeedState.mapStyles, expectedMapStyles, 'should save map styles');\n  const expectedTopStyle3 = {\n    ...MOCK_MAP_STYLE_LIGHT.style,\n    layers: [{\n      type: 'symbol',\n      source: 'composite',\n      id: 'admin-label-lg',\n      'source-layer': 'country_label'\n    }]\n  };\n  t.deepEqual(succeedState.topMapStyle, expectedTopStyle3, 'topMapStyle should be set correctly');\n  t.deepEqual(succeedState.isLoading, {\n    light: false\n  }, 'should set isLoading correctly');\n  t.deepEqual(succeedState.threeDBuildingColor, [237.4432283491836, 237.4432283491836, 237.4432283491836], 'should set threeDBuildingColor correctly');\n\n  // error load light map style\n  const erroredState = reducer(nextState3, errorTaskInTest(tasks[0], new Error('hello')));\n  t.deepEqual(erroredState.isLoading, {\n    light: false\n  }, 'should set isLoading correctly');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleReducer -> MAP_STYLE_CHANGE -> dark basemap to no basemap","suites":[],"updatePoint":{"line":395,"column":72,"index":14028},"line":395,"code":"test('#mapStyleReducer -> MAP_STYLE_CHANGE -> dark basemap to no basemap', t => {\n  const initialState = reducer(InitialMapStyle, keplerGlInit({\n    mapboxApiAccessToken: 'smoothies_secret_token'\n  }));\n\n  // loadMapStyles\n  const nextState = reducer(initialState, loadMapStyles({\n    dark: MOCK_MAP_STYLE\n  }));\n  t.deepEqual(initialState.backgroundColor, nextState.backgroundColor, 'backgroundColor should remain the same when NOT switching to the no basemap option');\n\n  // set style type to no basemap\n  const nextState2 = reducer(nextState, mapStyleChange(NO_MAP_ID));\n  const expectedNextState2 = {\n    ...nextState2,\n    styleType: NO_MAP_ID\n  };\n  t.deepEqual(nextState2, expectedNextState2, 'state should be correct when switching to no basemap option');\n  t.notDeepEqual(nextState.backgroundColor, nextState2.backgroundColor, 'backgroundColor should be changed when switching to no basemap option (map-style-updates.js: getBackgroundColorFromStyleBaseLayer())');\n  t.end();\n});","file":"node/reducers/map-style-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducer","suites":[],"updatePoint":{"line":28,"column":27,"index":1630},"line":28,"code":"test('#providerStateReducer', t => {\n  t.deepEqual(reducer(undefined, {}), {\n    ...INITIAL_PROVIDER_STATE,\n    initialState: {}\n  }, 'should return the initial provider state');\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducerFactory","suites":[],"updatePoint":{"line":35,"column":34,"index":1831},"line":35,"code":"test('#providerStateReducerFactory', t => {\n  const providerStateReducer = providerStateReducerFactory({\n    currentProvider: 'taro'\n  });\n  t.deepEqual(providerStateReducer(undefined, {}), {\n    ...INITIAL_PROVIDER_STATE,\n    currentProvider: 'taro',\n    initialState: {\n      currentProvider: 'taro'\n    }\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducer -> EXPORT_FILE_TO_CLOUD","suites":[],"updatePoint":{"line":48,"column":51,"index":2212},"line":48,"code":"test('#providerStateReducer -> EXPORT_FILE_TO_CLOUD', t => {\n  const errSpy = sinon.spy(Console, 'error');\n  drainTasksForTesting();\n  // null\n  reducer(undefined, exportFileToCloud({\n    provider: null\n  }));\n  t.ok(errSpy.calledOnce, 'should call console.error if provider is undefined');\n  t.equal(errSpy.getCall(0).args[0], 'provider is not defined', 'should warn when cannot find kepler.gl state');\n  reducer(undefined, exportFileToCloud({\n    provider: {\n      name: 'taro',\n      hello: true\n    }\n  }));\n\n  // uploadFile\n  t.ok(errSpy.calledTwice, 'should call console.error if provider does not have uploadFile');\n  t.equal(errSpy.getCall(1).args[0], 'uploadMap is not a function of Cloud provider: taro', 'should warn when cannot find uploadMap function');\n\n  // mapData\n  const mockProvider = new MockProvider();\n  const nextState = reducer(undefined, exportFileToCloud({\n    mapData: {\n      data: []\n    },\n    provider: mockProvider,\n    options: {\n      isPublic: false\n    }\n  }));\n  const [task1, ...more] = drainTasksForTesting();\n  t.ok(more.length === 0, 'should create 1 task');\n  t.comment(JSON.stringify(nextState));\n  t.deepEqual(nextState, {\n    isProviderLoading: true,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    successInfo: {},\n    initialState: {},\n    mapSaved: null,\n    visualizations: []\n  }, 'Should set isProviderLoading and current provider');\n  t.equal(task1.type, 'EXPORT_FILE_TO_CLOUD_TASK', 'should create export file tasks');\n  t.deepEqual(task1.payload, {\n    provider: mockProvider,\n    payload: {\n      mapData: {\n        data: []\n      },\n      options: {\n        isPublic: false\n      }\n    }\n  }, 'should call upload file with correct payload');\n\n  // success\n  const resultState1 = reducer(nextState, succeedTaskInTest(task1, {\n    url: 'taro_and_blue'\n  }));\n  t.deepEqual(resultState1, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    initialState: {},\n    mapSaved: 'taro',\n    successInfo: {\n      url: 'taro_and_blue'\n    },\n    visualizations: []\n  }, 'Should set isProviderLoading to false and successInfo, mapSaved to taro');\n  const task2 = drainTasksForTesting();\n  t.ok(task2.length === 0, 'should create 0 task');\n\n  // error\n  const resultState2 = reducer(nextState, errorTaskInTest(task1, new Error('hello')));\n  t.deepEqual(resultState2, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: 'hello',\n    currentProvider: 'taro',\n    initialState: {},\n    mapSaved: null,\n    successInfo: {},\n    visualizations: []\n  }, 'Should set isLoading to false and error');\n  errSpy.restore();\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducer -> EXPORT_FILE_TO_CLOUD -> onSuccess : onError","suites":[],"updatePoint":{"line":141,"column":74,"index":4985},"line":141,"code":"test('#providerStateReducer -> EXPORT_FILE_TO_CLOUD -> onSuccess : onError', t => {\n  const mockResponse = {\n    url: 'taro_and_blue'\n  };\n  const mockProvider = new MockProvider();\n  const mockError = new Error('ooops');\n  const testUpdaters = {\n    [ActionTypes.TOGGLE_MODAL]: (state, action) => ({\n      ...state,\n      modalId: action.payload\n    }),\n    [ActionTypes.ADD_NOTIFICATION]: (state, action) => ({\n      ...state,\n      notification: action.payload\n    }),\n    [ActionTypes.REMOVE_NOTIFICATION]: (state, action) => ({\n      ...state,\n      remove: true\n    })\n  };\n  const composedReducer = (state, action) => {\n    if (testUpdaters[action.type]) {\n      return testUpdaters[action.type](state, action);\n    }\n    return reducer(state, action);\n  };\n  const onSuccess = args => {\n    t.deepEqual(args, {\n      response: mockResponse,\n      provider: mockProvider,\n      options: {\n        isPublic: false\n      }\n    }, 'should call onSuccess with arguments');\n    return {};\n  };\n  const onError = args => {\n    t.deepEqual(args, mockError, 'should call onError with arguments');\n    return {};\n  };\n\n  // mapData\n  const state = reducer(undefined, exportFileToCloud({\n    mapData: {\n      data: []\n    },\n    provider: mockProvider,\n    onSuccess,\n    onError,\n    closeModal: true,\n    options: {\n      isPublic: false\n    }\n  }));\n  const [task1, ...more] = drainTasksForTesting();\n  t.ok(more.length === 0, 'should create 1 task');\n  t.equal(task1.type, 'EXPORT_FILE_TO_CLOUD_TASK', 'should create export file tasks');\n\n  // success\n  const nextState = reducer(state, succeedTaskInTest(task1, mockResponse));\n  const [task2, task3, ...more2] = drainTasksForTesting();\n  t.ok(more2.length === 0, 'should create 1 task');\n  t.ok(task2.type === 'ACTION_TASK', 'should create 2 ACTION_TASK');\n  t.ok(task3.type === 'ACTION_TASK', 'should create 2 ACTION_TASK');\n  t.deepEqual(nextState, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    mapSaved: 'taro',\n    initialState: {},\n    successInfo: {\n      url: 'taro_and_blue'\n    },\n    visualizations: []\n  }, 'Should set isProviderLoading to false and successInfo');\n  const resultState1 = reducer(nextState, succeedTaskInTest(task2, undefined));\n  const resultState2 = reducer(resultState1, succeedTaskInTest(task3, undefined));\n\n  // saveToCloudSuccess\n  const [task4, task5, task6, task7, ...more3] = drainTasksForTesting();\n  t.ok(more3.length === 0, 'should create 4 tasks');\n  t.ok(task4.type === 'ACTION_TASK', 'should create 3 ACTION_TASKS');\n  t.ok(task5.type === 'ACTION_TASK', 'should create 3 ACTION_TASKS');\n  t.ok(task6.type === 'ACTION_TASK', 'should create 3 ACTION_TASKS');\n  t.ok(task7.type === 'DELAY_TASK', 'should create 1 DELAY_TASK');\n\n  // toggleModal(null),\n  const resultState3 = composedReducer(resultState2, succeedTaskInTest(task4, undefined));\n  t.deepEqual(resultState3, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    mapSaved: 'taro',\n    initialState: {},\n    successInfo: {\n      url: 'taro_and_blue'\n    },\n    modalId: null,\n    visualizations: []\n  }, 'Should call toggleModal(null');\n  const resultState4 = composedReducer(resultState3, succeedTaskInTest(task5, undefined));\n  t.deepEqual(resultState4, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    mapSaved: 'taro',\n    initialState: {},\n    successInfo: {},\n    modalId: null,\n    visualizations: []\n  }, 'Should call resetProviderStatus');\n  const resultState5 = composedReducer(resultState4, succeedTaskInTest(task6, undefined));\n  t.equal(resultState5.notification.type, 'success', 'Should call addNotification with successNote');\n  const resultState6 = composedReducer(resultState5, succeedTaskInTest(task7, undefined));\n  t.equal(resultState6.remove, true, 'Should call removeNotification');\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducer -> RESET_PROVIDER_STATUS","suites":[],"updatePoint":{"line":261,"column":52,"index":8947},"line":261,"code":"test('#providerStateReducer -> RESET_PROVIDER_STATUS', t => {\n  const mockProvider = new MockProvider();\n  const nextState = reducer(undefined, exportFileToCloud({\n    mapData: {\n      data: []\n    },\n    provider: mockProvider,\n    options: {\n      isPublic: false\n    }\n  }));\n  const nextState1 = reducer(nextState, resetProviderStatus());\n  t.deepEqual(nextState1, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'taro',\n    successInfo: {},\n    initialState: {},\n    mapSaved: null,\n    visualizations: []\n  }, 'Should resetProviderStatus');\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"#providerStateReducer -> SET_CLOUD_PROVIDER","suites":[],"updatePoint":{"line":285,"column":49,"index":9566},"line":285,"code":"test('#providerStateReducer -> SET_CLOUD_PROVIDER', t => {\n  const nextState = reducer(undefined, setCloudProvider('blue'));\n  t.deepEqual(nextState, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null,\n    currentProvider: 'blue',\n    successInfo: {},\n    mapSaved: null,\n    initialState: {},\n    visualizations: []\n  }, 'Should setCloudProvider');\n  t.end();\n});","file":"node/reducers/provider-state-test.js","skipped":false,"dir":"test"},{"name":"keplerGlReducer.initialState","suites":[],"updatePoint":{"line":25,"column":34,"index":1458},"line":25,"code":"test('keplerGlReducer.initialState', t => {\n  const test1Reducer = keplerGlReducer.initialState({\n    visState: {\n      layerClasses: []\n    },\n    mapStyle: {\n      styleType: 'light'\n    }\n  });\n  const test1ReducerInitialState = test1Reducer(undefined, registerEntry({\n    id: 'test'\n  }));\n  t.deepEqual(test1ReducerInitialState.test.visState.layerClasses, [], 'should override initialState');\n  t.equal(test1ReducerInitialState.test.mapStyle.styleType, 'light', 'should override initialState');\n  t.deepEqual(test1ReducerInitialState.test.visState.initialState, {\n    layerClasses: []\n  }, 'should save initialState');\n  t.deepEqual(test1ReducerInitialState.test.mapStyle.initialState, {\n    styleType: 'light'\n  }, 'should save initialState');\n\n  // change it\n  const newConfig = {\n    visState: {\n      layerBlending: 'additive'\n    },\n    mapStyle: {\n      styleType: 'beautiful'\n    }\n  };\n  const modifiedReducer = test1Reducer(test1ReducerInitialState, receiveMapConfig(newConfig));\n  t.deepEqual(modifiedReducer.test.visState.layerBlending, 'additive', 'should apply config');\n  t.equal(modifiedReducer.test.mapStyle.styleType, 'beautiful', 'should apply config');\n  t.deepEqual(modifiedReducer.test.visState.initialState, {\n    layerClasses: []\n  }, 'should save initialState');\n\n  // reset reducer\n  const restTestReducer = test1Reducer(modifiedReducer, resetMapConfig());\n  t.deepEqual(restTestReducer.test.visState.layerClasses, [], 'should override initialState');\n  t.equal(restTestReducer.test.mapStyle.styleType, 'light', 'should override initialState');\n  t.deepEqual(restTestReducer.test.visState.initialState, {\n    layerClasses: []\n  }, 'should save initialState');\n  t.deepEqual(restTestReducer.test.mapStyle.initialState, {\n    styleType: 'light'\n  }, 'should save initialState');\n  t.end();\n});","file":"node/reducers/root-test.js","skipped":false,"dir":"test"},{"name":"keplerGlReducer.initialState.2","suites":[],"updatePoint":{"line":74,"column":36,"index":3282},"line":74,"code":"test('keplerGlReducer.initialState.2', t => {\n  const test1Reducer = keplerGlReducer.initialState({\n    visState: {\n      layerClasses: []\n    },\n    mapStyle: {\n      styleType: 'light'\n    }\n  });\n\n  // call initialState one more time\n  const test2Reducer = test1Reducer.initialState({\n    mapStyle: {\n      styleType: 'smoothie',\n      hello: 'kitty'\n    },\n    mapState: {\n      dragRotate: true\n    }\n  });\n  const test2InitialState = test2Reducer(undefined, registerEntry({\n    id: 'test2'\n  }));\n  t.deepEqual(test2InitialState.test2.visState.layerClasses, [], 'should keep previous initialState');\n  t.equal(test2InitialState.test2.mapStyle.styleType, 'smoothie', 'should overide initialState');\n  t.equal(test2InitialState.test2.mapStyle.hello, 'kitty', 'should provide initialState');\n  t.equal(test2InitialState.test2.mapState.dragRotate, true, 'should provide initialState');\n\n  // change it\n  const newConfig2 = {\n    visState: {\n      layerBlending: 'subtractive'\n    },\n    mapStyle: {\n      styleType: 'earth'\n    }\n  };\n  const modifiedReducer2 = test2Reducer(test2InitialState, receiveMapConfig(newConfig2));\n  t.deepEqual(modifiedReducer2.test2.visState.layerBlending, 'subtractive', 'should apply config');\n  t.equal(modifiedReducer2.test2.mapStyle.styleType, 'earth', 'should apply config');\n  t.deepEqual(modifiedReducer2.test2.visState.initialState, {\n    layerClasses: []\n  }, 'should save initialState');\n\n  // reset reducer\n  const restTestReducer2 = test2Reducer(modifiedReducer2, resetMapConfig());\n  t.deepEqual(restTestReducer2.test2.visState.layerClasses, [], 'should reset initialState');\n  t.equal(restTestReducer2.test2.mapStyle.styleType, 'smoothie', 'should reset initialState');\n  t.equal(restTestReducer2.test2.mapState.dragRotate, true, 'should reset initialState');\n  t.deepEqual(restTestReducer2.test2.visState.initialState, {\n    layerClasses: []\n  }, 'should save initialState');\n  t.deepEqual(restTestReducer2.test2.mapStyle.initialState, {\n    styleType: 'smoothie',\n    hello: 'kitty'\n  }, 'should save initialState');\n  t.end();\n});","file":"node/reducers/root-test.js","skipped":false,"dir":"test"},{"name":"keplerGlReducer.plugin","suites":[],"updatePoint":{"line":132,"column":28,"index":5354},"line":132,"code":"test('keplerGlReducer.plugin', t => {\n  // custom actions\n  const hideAndShowSidePanel = createAction('HIDE_AND_SHOW_SIDE_PANEL');\n  const hideMapControls = createAction('HIDE_MAP_CONTROLS');\n  const hiddenMapControl = {\n    visibleLayers: {\n      show: false,\n      active: false\n    },\n    mapLegend: {\n      show: false,\n      active: false\n    },\n    toggle3d: {\n      show: false\n    },\n    splitMap: {\n      show: false\n    }\n  };\n\n  // plugin 2 actions\n  const testReducer = keplerGlReducer\n  // 1. as reducer map\n  .plugin({\n    HIDE_AND_SHOW_SIDE_PANEL: state => ({\n      ...state,\n      uiState: {\n        ...state.uiState,\n        readOnly: !state.uiState.readOnly\n      }\n    })\n  }).plugin(handleActions({\n    // 2. as reducer\n    HIDE_MAP_CONTROLS: state => ({\n      ...state,\n      uiState: {\n        ...state.uiState,\n        mapControls: hiddenMapControl\n      }\n    })\n  }, {}));\n  const testInitialState = testReducer(undefined, registerEntry({\n    id: 'test3'\n  }));\n  const previousValue = testInitialState.test3.uiState.readOnly;\n\n  // dispatch action\n  const updatedState = testReducer(testInitialState, hideAndShowSidePanel());\n  t.equal(updatedState.test3.uiState.readOnly, !previousValue, 'should call hideAndShowSidePanel');\n\n  // dispatch action 2\n  const updatedState2 = testReducer(testInitialState, hideMapControls());\n  t.equal(updatedState2.test3.uiState.mapControls, hiddenMapControl, 'should call hideMapControls');\n  t.end();\n});","file":"node/reducers/root-test.js","skipped":false,"dir":"test"},{"name":"keplerGlReducer.plugin override","suites":[],"updatePoint":{"line":188,"column":37,"index":6829},"line":188,"code":"test('keplerGlReducer.plugin override', t => {\n  // custom actions\n  const mockRawData = {\n    fields: [{\n      name: 'start_point_lat',\n      id: 'start_point_lat',\n      displayName: 'start_point_lat',\n      type: 'real',\n      fieldIdx: 0\n    }, {\n      name: 'start_point_lng',\n      id: 'start_point_lng',\n      displayName: 'start_point_lng',\n      type: 'real',\n      fieldIdx: 2\n    }, {\n      name: 'end_point_lat',\n      id: 'end_point_lat',\n      displayName: 'end_point_lat',\n      type: 'real',\n      fieldIdx: 3\n    }, {\n      name: 'end_point_lng',\n      id: 'end_point_lng',\n      displayName: 'end_point_lng',\n      type: 'real',\n      fieldIdx: 4\n    }],\n    rows: [[12.25, 37.75, 45.21, 100.12], [null, 35.2, 45.0, 21.3], [12.29, 37.64, 46.21, 99.127], [null, null, 33.1, 29.34]]\n  };\n  const testReducer = keplerGlReducer\n  // 1. as reducer map\n  .plugin({\n    [ActionTypes.LAYER_TYPE_CHANGE]: (state, action) => {\n      return {\n        ...state,\n        visState: {\n          ...state.visState,\n          // do the default behavior and update layerOrder to empty\n          layerOrder: []\n        }\n      };\n    }\n  }, {\n    override: {\n      [ActionTypes.LAYER_TYPE_CHANGE]: true\n    }\n  });\n  let nextState = testReducer(undefined, registerEntry({\n    id: 'test3'\n  }));\n  nextState = testReducer(nextState, addDataToMap({\n    datasets: {\n      data: mockRawData,\n      info: {\n        id: 'foo'\n      }\n    }\n  }));\n  t.equal(nextState.test3.visState.layers.length, 4, 'Should have 4 layer');\n  nextState = testReducer(nextState, layerTypeChange(nextState.test3.visState.layers[0], 'arc'));\n  t.equal(nextState.test3.visState.layers[0].type, 'point', 'Should have not changed layer type to arc');\n  t.deepEqual(nextState.test3.visState.layerOrder, [], 'Should have changed layerOrder to empty');\n  t.end();\n});","file":"node/reducers/root-test.js","skipped":false,"dir":"test"},{"name":"keplerGlReducer - splitMap and mapControl interaction","suites":[],"updatePoint":{"line":253,"column":59,"index":8686},"line":253,"code":"test('keplerGlReducer - splitMap and mapControl interaction', t => {\n  // init kepler.gl root and instance\n  let state = keplerGlReducer(undefined, registerEntry({\n    id: 'test'\n  }));\n  state = keplerGlReducer(state, toggleMapControl('mapDraw'));\n  t.equal(state.test.uiState.mapControls.mapDraw.active, true, 'Map draw should now be active');\n  t.equal(state.test.uiState.mapControls.mapDraw.activeMapIndex, 0, 'Map draw split index should be 0');\n  state = keplerGlReducer(state, toggleMapControl('mapDraw'));\n  t.equal(state.test.uiState.mapControls.mapDraw.active, false, 'Map draw should now be non active');\n  state = keplerGlReducer(state, toggleSplitMap());\n  t.equal(state.test.mapState.isSplit, true, 'Should have split map');\n  t.equal(state.test.uiState.mapControls.mapLegend.active, true, 'Should open map legend');\n  state = keplerGlReducer(state, toggleMapControl('mapDraw', 1));\n  t.equal(state.test.uiState.mapControls.mapDraw.active, true, 'Split View - Map draw should now be active');\n  t.equal(state.test.uiState.mapControls.mapDraw.activeMapIndex, 1, 'Split View - Map draw split index should be 1');\n  t.end();\n});","file":"node/reducers/root-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer","suites":[],"updatePoint":{"line":25,"column":21,"index":1741},"line":25,"code":"test('#uiStateReducer', t => {\n  t.deepEqual(reducer(undefined, {}), {\n    ...INITIAL_UI_STATE,\n    initialState: {}\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> INIT","suites":[],"updatePoint":{"line":32,"column":29,"index":1922},"line":32,"code":"test('#uiStateReducer -> INIT', t => {\n  const uiStateReducer = uiStateReducerFactory();\n  const newState = reducer(uiStateReducer(undefined, {}), keplerGlInit({\n    initialUiState: {\n      readOnly: true\n    }\n  }));\n  t.deepEqual(newState, {\n    ...INITIAL_UI_STATE,\n    readOnly: true,\n    initialState: {}\n  }, 'should apply initialUiState');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducerFactory","suites":[],"updatePoint":{"line":46,"column":28,"index":2283},"line":46,"code":"test('#uiStateReducerFactory', t => {\n  const uiStateReducer = uiStateReducerFactory({\n    readOnly: true\n  });\n  t.deepEqual(uiStateReducer(undefined, {}), {\n    ...INITIAL_UI_STATE,\n    readOnly: true,\n    initialState: {\n      readOnly: true\n    }\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> TOGGLE_SIDE_PANEL","suites":[],"updatePoint":{"line":59,"column":42,"index":2604},"line":59,"code":"test('#uiStateReducer -> TOGGLE_SIDE_PANEL', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, toggleSidePanel('foo'));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    activeSidePanel: 'foo'\n  };\n  t.deepEqual(newReducer, expectedState, 'should update side panel');\n  const nextState2 = reducer(expectedState, toggleModal(null));\n  const expectedNextState2 = {\n    ...expectedState,\n    currentModal: null\n  };\n  t.deepEqual(nextState2, expectedNextState2, 'should close modal');\n  const nextState3 = reducer(expectedState, toggleSidePanel(null));\n  const expectedNextState3 = {\n    ...expectedState,\n    activeSidePanel: null\n  };\n  t.deepEqual(nextState3, expectedNextState3, 'should close panel');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> TOGGLE_SIDE_PANEL_CLOSE_BUTTON","suites":[],"updatePoint":{"line":80,"column":55,"index":3344},"line":80,"code":"test('#uiStateReducer -> TOGGLE_SIDE_PANEL_CLOSE_BUTTON', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, toggleSidePanelCloseButton(false));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    isSidePanelCloseButtonVisible: false\n  };\n  t.deepEqual(newReducer, expectedState, 'should hide side panel close button');\n  const nextState2 = reducer(expectedState, toggleSidePanelCloseButton(true));\n  const expectedNextState2 = {\n    ...expectedState,\n    isSidePanelCloseButtonVisible: true\n  };\n  t.deepEqual(nextState2, expectedNextState2, 'should show side panel close button');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> OPEN_DELETE_MODAL","suites":[],"updatePoint":{"line":95,"column":42,"index":3935},"line":95,"code":"test('#uiStateReducer -> OPEN_DELETE_MODAL', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, openDeleteModal('chai'));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    currentModal: 'deleteData',\n    datasetKeyToRemove: 'chai'\n  };\n  t.deepEqual(newReducer, expectedState, 'should open delete data modal and save key to remove');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_EXPORT_IMAGE_SETTING","suites":[],"updatePoint":{"line":105,"column":49,"index":4299},"line":105,"code":"test('#uiStateReducer -> SET_EXPORT_IMAGE_SETTING', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, setExportImageSetting({\n    resolution: RESOLUTIONS.TWO_X\n  }));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    exportImage: {\n      ...INITIAL_UI_STATE.exportImage,\n      resolution: RESOLUTIONS.TWO_X\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set the resolution to TWO_X');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> START_EXPORTING_IMAGE","suites":[],"updatePoint":{"line":119,"column":46,"index":4718},"line":119,"code":"test('#uiStateReducer -> START_EXPORTING_IMAGE', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, startExportingImage());\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    exportImage: {\n      ...INITIAL_UI_STATE.exportImage,\n      exporting: true\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set exporting to true and modal to export image');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> TOGGLE_MAP_CONTROL","suites":[],"updatePoint":{"line":131,"column":43,"index":5099},"line":131,"code":"test('#uiStateReducer -> TOGGLE_MAP_CONTROL', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, toggleMapControl('mapLegend'));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    mapControls: {\n      ...INITIAL_UI_STATE.mapControls,\n      mapLegend: {\n        ...INITIAL_UI_STATE.mapControls.mapLegend,\n        active: !INITIAL_UI_STATE.mapControls.mapLegend.active,\n        activeMapIndex: 0\n      }\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set map legend to be seen');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_MAP_CONTROL_VISIBILITY","suites":[],"updatePoint":{"line":147,"column":51,"index":5620},"line":147,"code":"test('#uiStateReducer -> SET_MAP_CONTROL_VISIBILITY', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, setMapControlVisibility('mapLegend', false));\n  const expectedMapControl = {\n    ...INITIAL_UI_STATE.mapControls,\n    mapLegend: {\n      ...INITIAL_UI_STATE.mapControls.mapLegend,\n      show: false\n    }\n  };\n  t.deepEqual(newReducer.mapControls, expectedMapControl, 'should set map legend show to be false');\n  const newReducer1 = reducer(newReducer, setMapControlVisibility('mapLegend', true));\n  const expectedMapControl1 = {\n    ...INITIAL_UI_STATE.mapControls,\n    mapLegend: {\n      ...INITIAL_UI_STATE.mapControls.mapLegend,\n      show: true\n    }\n  };\n  t.deepEqual(newReducer1.mapControls, expectedMapControl1, 'should set map legend show to true');\n  const newReducer2 = reducer(newReducer1, setMapControlVisibility('something', true));\n  t.equal(newReducer1, newReducer2, 'should note update state');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_EXPORT_SELECTED_DATASET","suites":[],"updatePoint":{"line":170,"column":52,"index":6556},"line":170,"code":"test('#uiStateReducer -> SET_EXPORT_SELECTED_DATASET', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, setExportSelectedDataset('a'));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    exportData: {\n      ...INITIAL_UI_STATE.exportData,\n      selectedDataset: 'a'\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set the selectedDataset to a');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_EXPORT_DATA_TYPE","suites":[],"updatePoint":{"line":182,"column":45,"index":6931},"line":182,"code":"test('#uiStateReducer -> SET_EXPORT_DATA_TYPE', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, setExportDataType(EXPORT_DATA_TYPE.JSON));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    exportData: {\n      ...INITIAL_UI_STATE.exportData,\n      dataType: EXPORT_DATA_TYPE.JSON\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set the dataType to json');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_EXPORT_FILTERED","suites":[],"updatePoint":{"line":194,"column":44,"index":7323},"line":194,"code":"test('#uiStateReducer -> SET_EXPORT_FILTERED', t => {\n  const newReducer = reducer(INITIAL_UI_STATE, setExportFiltered(false));\n  const expectedState = {\n    ...INITIAL_UI_STATE,\n    exportData: {\n      ...INITIAL_UI_STATE.exportData,\n      filtered: false\n    }\n  };\n  t.deepEqual(newReducer, expectedState, 'should set the filtered to false');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> ADD_NOTIFICATION","suites":[],"updatePoint":{"line":206,"column":41,"index":7681},"line":206,"code":"test('#uiStateReducer -> ADD_NOTIFICATION', t => {\n  const sharedNotificationId = 'test-notification-id';\n  const notification1 = {\n    type: DEFAULT_NOTIFICATION_TYPES.error,\n    message: 'TEST',\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    id: 'test-1',\n    count: 1\n  };\n  const state0 = reducer(INITIAL_UI_STATE, addNotification(notification1));\n  t.equal(state0.notifications.length, 1, 'AddNotification should add one new notification');\n  t.deepEqual(state0.notifications[0], notification1, 'AddNotification should have propagated data correctly');\n  const notification2 = {\n    type: DEFAULT_NOTIFICATION_TYPES.info,\n    message: 'TEST',\n    topic: DEFAULT_NOTIFICATION_TOPICS.file,\n    id: sharedNotificationId,\n    count: 1\n  };\n  const state1 = reducer(state0, addNotification(notification2));\n  t.equal(state1.notifications.length, 2, 'AddNotification should add second notification');\n  t.deepEqual(state1.notifications[1], notification2, 'AddNotification should have propagated data correctly ');\n  const updatedNotification = {\n    type: DEFAULT_NOTIFICATION_TYPES.error,\n    message: 'TEST-updated-message',\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    id: sharedNotificationId,\n    count: 2\n  };\n  const state2 = reducer(state1, addNotification(updatedNotification));\n  t.equal(state2.notifications.length, 2, \"addNotification shouldn't add new notification with same id\");\n  t.deepEqual(state2.notifications[1], updatedNotification, 'AddNotification should have propagated data correctly ');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> REMOVE_NOTIFICATION","suites":[],"updatePoint":{"line":240,"column":44,"index":9221},"line":240,"code":"test('#uiStateReducer -> REMOVE_NOTIFICATION', t => {\n  const newState = reducer(INITIAL_UI_STATE, addNotification({\n    type: DEFAULT_NOTIFICATION_TYPES.error,\n    message: 'TEST',\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    id: 'test-1'\n  }));\n  t.equal(newState.notifications.length, 1, 'AddNotification should add one new notification');\n  t.deepEqual(newState.notifications[0], {\n    type: DEFAULT_NOTIFICATION_TYPES.error,\n    message: 'TEST',\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    id: 'test-1',\n    count: 1\n  }, 'AddNotification should have propagated data correctly ');\n  const nextState = reducer(newState, removeNotification('test-1'));\n  t.equal(nextState.notifications.length, 0, 'RemoveNotification removed one notification');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> LOAD_FILES_ERR","suites":[],"updatePoint":{"line":259,"column":39,"index":9992},"line":259,"code":"test('#uiStateReducer -> LOAD_FILES_ERR', t => {\n  const newState = reducer(INITIAL_UI_STATE, loadFiles());\n  t.equal(newState.loadFiles.fileLoading, true, 'should set fileLoading to true');\n  const newState1 = reducer(newState, loadFilesErr('file.csv', new Error('this is an error')));\n  const expectedId = newState1.notifications.length ? newState1.notifications[0].id : 'error';\n  t.equal(newState1.loadFiles.fileLoading, false, 'should set fileLoading to false when loadFilesErr');\n  t.deepEqual(newState1.notifications, [{\n    type: 'error',\n    topic: 'global',\n    message: 'this is an error',\n    id: expectedId,\n    count: 1\n  }], 'should add an error notification');\n  t.end();\n});","file":"node/reducers/ui-state-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v0 -> mergeFilters -> toEmptyState","suites":[],"updatePoint":{"line":49,"column":55,"index":3757},"line":49,"code":"test('VisStateMerger.v0 -> mergeFilters -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV0);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpFilters(t, mergedFiltersV0, stateWData.filters);\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeFilters -> toEmptyState","suites":[],"updatePoint":{"line":72,"column":55,"index":4765},"line":72,"code":"test('VisStateMerger.v1 -> mergeFilters -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const expectedMergedFilterV1 = mergedFiltersV1;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpFilters(t, expectedMergedFilterV1, stateWData.filters);\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v0 -> mergeFilters -> toWorkingState","suites":[],"updatePoint":{"line":96,"column":57,"index":5832},"line":96,"code":"test('VisStateMerger.v0 -> mergeFilters -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV0);\n  const oldState = cloneDeep(StateWFilters);\n  const oldVisState = oldState.visState;\n  const oldFilters = [...oldState.visState.filters];\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpFilters(t, [...oldFilters, ...mergedFiltersV0], stateWData.filters);\n  t.deepEqual(stateWData.filterToBeMerged, [], 'should clear up filterToBeMerged');\n\n  // should filter data\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeFilters -> toWorkingState","suites":[],"updatePoint":{"line":123,"column":57,"index":7025},"line":123,"code":"test('VisStateMerger.v1 -> mergeFilters -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const oldState = cloneDeep(StateWFilters);\n  const oldVisState = oldState.visState;\n  const oldFilters = [...oldState.visState.filters];\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpFilters(t, [...oldFilters, ...mergedFiltersV1], stateWData.filters);\n  t.deepEqual(stateWData.filterToBeMerged, [], 'should clear up filterToBeMerged');\n\n  // should filter data\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeFilters -> empty filter","suites":[],"updatePoint":{"line":150,"column":55,"index":8216},"line":150,"code":"test('VisStateMerger.v1 -> mergeFilters -> empty filter', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  // set an empty filter\n  savedConfig.config.config.visState.filters[0].name = [];\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const oldFilters = [...oldState.visState.filters];\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpFilters(t, oldFilters, stateWData.filters);\n  t.deepEqual(stateWData.filterToBeMerged, parsedFilters, 'should save filters failed to merge to filterToBeMerged');\n\n  // should filter data\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> mergeLayers -> invalid layer config","suites":[],"updatePoint":{"line":179,"column":59,"index":9503},"line":179,"code":"test('VisStateMerger -> mergeLayers -> invalid layer config', t => {\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const layers = [{\n    id: 'abc'\n  }, {\n    type: 'taro'\n  },\n  // no type\n  {\n    type: 'point',\n    id: 'yes'\n  } // no config\n  ];\n\n  const mergedState = mergeLayers(oldVisState, layers, true);\n  t.equal(mergedState.layers, oldVisState.layers, 'merge invalid layer should not error');\n  t.deepEqual(mergedState.layerToBeMerged, layers, 'layerToBeMerged should contain invalid layers');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.current -> mergeLayers -> toEmptyState","suites":[],"updatePoint":{"line":199,"column":59,"index":10062},"line":199,"code":"test('VisStateMerger.current -> mergeLayers -> toEmptyState', t => {\n  const stateToSave = cloneDeep(StateWFilesFiltersLayerColor);\n  const appStateToSave = SchemaManager.save(stateToSave);\n  const configToSave = appStateToSave.config;\n  const configParsed = SchemaManager.parseSavedConfig(configToSave);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedLayers = configParsed.visState.layers;\n  // mergeLayers\n  const mergedState = mergeLayers(oldState.visState, parsedLayers, true);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(appStateToSave.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed layers\n  const genericLayersByOrder = stateToSave.visState.layerOrder.map(id => findById(id)(stateToSave.visState.layers));\n  cmpLayers(t, genericLayersByOrder, stateWData.layers, {\n    id: true\n  });\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"visStateMerger -> mergeLayer -> incremental load","suites":[],"updatePoint":{"line":228,"column":54,"index":11329},"line":228,"code":"test('visStateMerger -> mergeLayer -> incremental load', t => {\n  const stateToSave = cloneDeep(StateWFilesFiltersLayerColor);\n  const appStateToSave = SchemaManager.save(stateToSave);\n  const {\n    datasets,\n    config\n  } = appStateToSave;\n  const [dataset1, dataset2] = datasets;\n  // load config first\n  const stateWithConfig = coreReducer(stateToSave, addDataToMap({\n    config\n  }));\n  t.deepEqual(stateWithConfig.visState.preserveLayerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'shoud preserve layer order');\n  t.deepEqual(stateWithConfig.visState.layerToBeMerged.map(l => l.id), ['hexagon-2', 'point-0', 'geojson-1'], 'should save to layerToBeMerged');\n\n  // load dataset2\n  const parsedData2 = SchemaManager.parseSavedData([dataset2]);\n  const stateWithData2 = coreReducer(stateWithConfig, addDataToMap({\n    datasets: parsedData2\n  }));\n  t.deepEqual(stateWithData2.visState.preserveLayerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'shoud preserve layer order');\n  t.deepEqual(stateWithData2.visState.layers.map(l => l.id), ['geojson-1'], 'shoud load geojeon layer');\n  t.deepEqual(stateWithData2.visState.layerOrder, [stateWithData2.visState.layers[0].id], 'layerOrder should be correct');\n  t.deepEqual(stateWithData2.visState.layerToBeMerged.map(l => l.id), ['hexagon-2', 'point-0'], 'should save to layerToBeMerged');\n\n  // load dataset1\n  const parsedData1 = SchemaManager.parseSavedData([dataset1]);\n  const stateWithData1 = coreReducer(stateWithData2, addDataToMap({\n    datasets: parsedData1\n  }));\n  t.deepEqual(stateWithData1.visState.preserveLayerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'shoud preserve layer order');\n  t.deepEqual(stateWithData1.visState.layers.map(l => l.id), ['geojson-1', 'hexagon-2', 'point-0'], 'shoud load 2 layers');\n  t.deepEqual(stateWithData1.visState.layerOrder, [stateWithData1.visState.layers[1].id, stateWithData1.visState.layers[2].id, stateWithData1.visState.layers[0].id], 'layerOrder should be correct');\n  t.deepEqual(stateWithData1.visState.layerToBeMerged.map(l => l.id), [], 'layerToBeMerged should be empty');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeLayers -> toEmptyState","suites":[],"updatePoint":{"line":264,"column":54,"index":13427},"line":264,"code":"test('VisStateMerger.v1 -> mergeLayers -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedLayers = parsedConfig.visState.layers;\n\n  // mergeLayers\n  const mergedState = mergeLayers(oldState.visState, parsedLayers, true);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedStateV1.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed layers\n  cmpLayers(t, mergedLayersV1, stateWData.layers, {\n    id: true,\n    color: true\n  });\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1.label -> mergeLayers -> toEmptyState","suites":[],"updatePoint":{"line":292,"column":60,"index":14479},"line":292,"code":"test('VisStateMerger.v1.label -> mergeLayers -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV1Label);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedLayers = parsedConfig.visState.layers;\n\n  // mergeLayers\n  const mergedState = mergeLayers(oldState.visState, parsedLayers, true);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedStateV1Label.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed layers\n  cmpLayers(t, mergedLayersV1Label, stateWData.layers, {\n    id: true\n  });\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1.split -> mergeLayers -> toEmptyState","suites":[],"updatePoint":{"line":319,"column":60,"index":15529},"line":319,"code":"test('VisStateMerger.v1.split -> mergeLayers -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV1Split);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n  const expectedConfig = mergedSplitMapsV1;\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedLayers = parsedConfig.visState.layers;\n\n  // merge State\n  const mergedState = visStateReducer(oldVisState, receiveMapConfig(parsedConfig));\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else if (key === 'splitMaps') {\n      t.deepEqual(mergedState.splitMaps, [], 'Should wait to merge splitMaps');\n    } else if (key === 'splitMapsToBeMerged') {\n      t.deepEqual(mergedState.splitMapsToBeMerged, expectedConfig, 'Should save to splitMapsToBeMerged');\n    } else if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, {\n        tooltip: parsedConfig.visState.interactionConfig.tooltip\n      }, 'Should save interactionConfig to interactionToBeMerged');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], `Should keep ${key} the same`);\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test split Maps\n  t.deepEqual(stateWData.splitMaps, expectedConfig, 'should merge splitMaps');\n\n  // test parsed layers\n  cmpLayers(t, mergedLayersV1Split, stateWData.layers, {\n    id: true\n  });\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v0 -> mergeLayers -> toWorkingState","suites":[],"updatePoint":{"line":358,"column":56,"index":17227},"line":358,"code":"test('VisStateMerger.v0 -> mergeLayers -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV0);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n  const oldState = cloneDeep(StateWFilesFiltersLayerColor);\n  const oldVisState = oldState.visState;\n  t.deepEqual(oldVisState.layerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'layer order should be correct');\n  const oldLayers = [...oldVisState.layers];\n  const parsedLayers = parsedConfig.visState.layers;\n\n  // mergeLayers\n  const mergedState = mergeLayers(oldState.visState, parsedLayers, true);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  t.deepEqual(mergedState.layerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'layer order should not change');\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed layers\n  cmpLayers(t, [...oldLayers, ...mergedLayersV0], stateWData.layers);\n  t.deepEqual(stateWData.layerOrder, [...getLayerOrderFromLayers(mergedLayersV0), 'hexagon-2', 'point-0', 'geojson-1'], 'should put new layers on top of old ones');\n  t.deepEqual(stateWData.layerToBeMerged, [], 'should clean up layer to be merged');\n  t.equal(stateWData.layerData.length, 8, 'should calculate layer data');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeLayers -> toWorkingState","suites":[],"updatePoint":{"line":389,"column":56,"index":18863},"line":389,"code":"test('VisStateMerger.v1 -> mergeLayers -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n  const oldState = cloneDeep(StateWFilesFiltersLayerColor);\n  const oldVisState = oldState.visState;\n  t.deepEqual(oldVisState.layerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'layer order should be correct');\n  const oldLayers = [...oldVisState.layers];\n  const parsedLayers = parsedConfig.visState.layers;\n\n  // mergeLayers\n  const mergedState = mergeLayers(oldState.visState, parsedLayers, true);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'layerToBeMerged') {\n      t.deepEqual(mergedState.layerToBeMerged, parsedLayers, 'Should save layers to layerToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  t.deepEqual(mergedState.layerOrder, ['hexagon-2', 'point-0', 'geojson-1'], 'layer order should not change');\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed filters\n  cmpLayers(t, [...oldLayers, ...mergedLayersV1], stateWData.layers);\n  t.deepEqual(stateWData.layerOrder, [stateWData.layers[3].id, stateWData.layers[4].id, stateWData.layers[2].id, stateWData.layers[0].id, stateWData.layers[1].id], 'should put new layers on top of old ones');\n  t.deepEqual(stateWData.layerToBeMerged, [], 'should clean up layer to be merged');\n  t.equal(stateWData.layerData.length, 5, 'should calculate layer data');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v0 -> mergeInteractions -> toEmptyState","suites":[],"updatePoint":{"line":420,"column":60,"index":20548},"line":420,"code":"test('VisStateMerger.v0 -> mergeInteractions -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV0);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedInteraction = parsedConfig.visState.interactionConfig;\n\n  // merge interactions\n  const mergedState = mergeInteractions(oldState.visState, parsedInteraction);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, {\n        tooltip: {\n          fieldsToShow: {\n            '9h10t7fyb': [{\n              name: 'int_range',\n              format: null\n            }, {\n              name: 'detail',\n              format: null\n            }, {\n              name: 'type_boolean',\n              format: null\n            }],\n            v79816te8: [{\n              name: 'ID',\n              format: null\n            }, {\n              name: 'ZIP_CODE',\n              format: null\n            }]\n          },\n          enabled: true\n        }\n      }, 'Should save interactions to interactionToBeMerged before data loaded');\n    } else if (key === 'interactionConfig') {\n      t.deepEqual(mergedState.interactionConfig, oldState.visState.interactionConfig, 'Should disable interaction: null');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed interactions\n  t.deepEqual(stateWData.interactionConfig, mergedInteractionsV0, 'should merge interactionConfig');\n  t.deepEqual(stateWData.interactionToBeMerged, {}, 'should clear interaction');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v0 -> mergeInteractions -> toWorkingState","suites":[],"updatePoint":{"line":471,"column":62,"index":22449},"line":471,"code":"test('VisStateMerger.v0 -> mergeInteractions -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV0);\n  const oldState = cloneDeep(StateWFilesFiltersLayerColor);\n  const oldVisState = oldState.visState;\n  const milkShake = [{\n    name: 'have',\n    format: null\n  }, {\n    name: 'a',\n    format: null\n  }, {\n    name: 'good',\n    format: null\n  }, {\n    name: 'day',\n    format: null\n  }];\n  // add random items to interactionToBeMerged\n  oldVisState.interactionToBeMerged = {\n    ...oldVisState.interactionToBeMerged,\n    tooltip: {\n      fieldsToShow: {\n        milkShake\n      }\n    }\n  };\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedInteraction = parsedConfig.visState.interactionConfig;\n\n  // merge interactions\n  const mergedState = mergeInteractions(oldState.visState, parsedInteraction);\n  const expectedInteractionToBeMerged = {\n    tooltip: {\n      fieldsToShow: {\n        milkShake,\n        '9h10t7fyb': [{\n          name: 'int_range',\n          format: null\n        }, {\n          name: 'detail',\n          format: null\n        }, {\n          name: 'type_boolean',\n          format: null\n        }],\n        v79816te8: [{\n          name: 'ID',\n          format: null\n        }, {\n          name: 'ZIP_CODE',\n          format: null\n        }]\n      },\n      enabled: true\n    }\n  };\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, expectedInteractionToBeMerged, 'Should save interactions to interactionToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n  const expectedInteractions = {\n    ...defaultInteractionConfig,\n    tooltip: {\n      ...defaultInteractionConfig.tooltip,\n      enabled: true,\n      config: {\n        compareMode: false,\n        compareType: 'absolute',\n        fieldsToShow: {\n          [testCsvDataId]: [{\n            name: 'gps_data.utc_timestamp',\n            format: null\n          }, {\n            name: 'gps_data.types',\n            format: null\n          }, {\n            name: 'epoch',\n            format: null\n          }, {\n            name: 'has_result',\n            format: null\n          }, {\n            name: 'uid',\n            format: null\n          }],\n          [testGeoJsonDataId]: [{\n            name: 'OBJECTID',\n            format: null\n          }, {\n            name: 'ZIP_CODE',\n            format: null\n          }, {\n            name: 'ID',\n            format: null\n          }, {\n            name: 'TRIPS',\n            format: null\n          }, {\n            name: 'RATE',\n            format: null\n          }],\n          '9h10t7fyb': [{\n            name: 'int_range',\n            format: null\n          }, {\n            name: 'detail',\n            format: null\n          }, {\n            name: 'type_boolean',\n            format: null\n          }],\n          v79816te8: [{\n            name: 'ID',\n            format: null\n          }, {\n            name: 'ZIP_CODE',\n            format: null\n          }]\n        }\n      }\n    }\n  };\n\n  // test parsed interactions\n  t.deepEqual(stateWData.interactionConfig, expectedInteractions, 'should merge interactionconfig');\n  t.deepEqual(stateWData.interactionToBeMerged, {\n    tooltip: {\n      fieldsToShow: {\n        milkShake\n      },\n      enabled: true\n    }\n  }, 'should clear interaction');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeInteractions -> toEmptyState","suites":[],"updatePoint":{"line":613,"column":60,"index":26107},"line":613,"code":"test('VisStateMerger.v1 -> mergeInteractions -> toEmptyState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedInteraction = parsedConfig.visState.interactionConfig;\n\n  // merge interactions\n  const mergedState = mergeInteractions(oldState.visState, parsedInteraction);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, {\n        tooltip: {\n          fieldsToShow: {\n            a5ybmwl2d: [{\n              name: 'a_zip',\n              format: null\n            }, {\n              name: 'str_type',\n              format: null\n            }, {\n              name: 'int_type',\n              format: null\n            }]\n          },\n          enabled: false\n        }\n      }, 'Should save nothing interactions to interactionToBeMerged before data loaded');\n    } else if (key === 'interactionConfig') {\n      t.deepEqual(mergedState.interactionConfig, {\n        ...defaultInteractionConfig,\n        tooltip: {\n          ...defaultInteractionConfig.tooltip,\n          enabled: false,\n          config: {\n            fieldsToShow: {},\n            compareMode: false,\n            compareType: 'absolute'\n          }\n        },\n        brush: {\n          ...defaultInteractionConfig.brush,\n          enabled: false,\n          config: {\n            size: 1\n          }\n        }\n      }, 'Should disable tooltip');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // test parsed interactions\n  t.deepEqual(stateWData.interactionConfig, MergedInteractionV1, 'should merge interactionConfig');\n  t.deepEqual(stateWData.interactionToBeMerged, {}, 'should clear interaction');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeInteractions -> toWorkingState","suites":[],"updatePoint":{"line":675,"column":62,"index":28221},"line":675,"code":"test('VisStateMerger.v1 -> mergeInteractions -> toWorkingState', t => {\n  const savedConfig = cloneDeep(savedStateV1);\n  const oldState = cloneDeep(StateWFilesFiltersLayerColor);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedInteraction = parsedConfig.visState.interactionConfig;\n\n  // merge interactions\n  const mergedState = mergeInteractions(oldState.visState, parsedInteraction);\n  const expectedInteractionToBeMerged = {\n    tooltip: {\n      fieldsToShow: {\n        a5ybmwl2d: [{\n          name: 'a_zip',\n          format: null\n        }, {\n          name: 'str_type',\n          format: null\n        }, {\n          name: 'int_type',\n          format: null\n        }]\n      },\n      enabled: false\n    }\n  };\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, expectedInteractionToBeMerged, 'Should save interactions to interactionToBeMerged before data loaded');\n    } else if (key === 'interactionConfig') {\n      t.deepEqual(mergedState.interactionConfig, {\n        ...defaultInteractionConfig,\n        tooltip: {\n          ...defaultInteractionConfig.tooltip,\n          enabled: false,\n          config: {\n            compareMode: false,\n            compareType: 'absolute',\n            fieldsToShow: {\n              [testCsvDataId]: [{\n                name: 'gps_data.utc_timestamp',\n                format: null\n              }, {\n                name: 'gps_data.types',\n                format: null\n              }, {\n                name: 'epoch',\n                format: null\n              }, {\n                name: 'has_result',\n                format: null\n              }, {\n                name: 'uid',\n                format: null\n              }],\n              [testGeoJsonDataId]: [{\n                name: 'OBJECTID',\n                format: null\n              }, {\n                name: 'ZIP_CODE',\n                format: null\n              }, {\n                name: 'ID',\n                format: null\n              }, {\n                name: 'TRIPS',\n                format: null\n              }, {\n                name: 'RATE',\n                format: null\n              }]\n            }\n          }\n        },\n        brush: {\n          ...defaultInteractionConfig.brush,\n          enabled: false,\n          config: {\n            size: 1\n          }\n        },\n        coordinate: {\n          ...defaultInteractionConfig.coordinate,\n          enabled: false\n        }\n      }, 'Should disable interaction: null');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n  const expectedInteractions = {\n    ...defaultInteractionConfig,\n    tooltip: {\n      ...defaultInteractionConfig.tooltip,\n      enabled: false,\n      config: {\n        compareMode: false,\n        compareType: 'absolute',\n        fieldsToShow: {\n          [testCsvDataId]: [{\n            name: 'gps_data.utc_timestamp',\n            format: null\n          }, {\n            name: 'gps_data.types',\n            format: null\n          }, {\n            name: 'epoch',\n            format: null\n          }, {\n            name: 'has_result',\n            format: null\n          }, {\n            name: 'uid',\n            format: null\n          }],\n          [testGeoJsonDataId]: [{\n            name: 'OBJECTID',\n            format: null\n          }, {\n            name: 'ZIP_CODE',\n            format: null\n          }, {\n            name: 'ID',\n            format: null\n          }, {\n            name: 'TRIPS',\n            format: null\n          }, {\n            name: 'RATE',\n            format: null\n          }],\n          a5ybmwl2d: [{\n            name: 'a_zip',\n            format: null\n          }, {\n            name: 'str_type',\n            format: null\n          }, {\n            name: 'int_type',\n            format: null\n          }]\n        }\n      }\n    },\n    brush: {\n      ...defaultInteractionConfig.brush,\n      enabled: false,\n      config: {\n        size: 1\n      }\n    }\n  };\n\n  // test parsed interactions\n  t.deepEqual(stateWData.interactionConfig, expectedInteractions, 'should merge interactionConfig');\n  t.deepEqual(stateWData.interactionToBeMerged, {}, 'should clear interaction');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeInteractions -> coordinate","suites":[],"updatePoint":{"line":837,"column":58,"index":32759},"line":837,"code":"test('VisStateMerger.v1 -> mergeInteractions -> coordinate', t => {\n  const savedConfig = cloneDeep(savedStateV1InteractionCoordinate);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedInteraction = parsedConfig.visState.interactionConfig;\n\n  // merge interactions\n  const mergedState = mergeInteractions(oldState.visState, parsedInteraction);\n  const expectedInteractionToBeMerged = {};\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'interactionToBeMerged') {\n      t.deepEqual(mergedState.interactionToBeMerged, expectedInteractionToBeMerged, 'Should save interactions to interactionToBeMerged before data loaded');\n    } else if (key === 'interactionConfig') {\n      t.deepEqual(mergedState.interactionConfig, {\n        ...defaultInteractionConfig,\n        tooltip: {\n          ...defaultInteractionConfig.tooltip,\n          enabled: false\n        },\n        brush: {\n          ...defaultInteractionConfig.brush,\n          config: {\n            size: 1\n          }\n        },\n        coordinate: {\n          ...defaultInteractionConfig.coordinate,\n          enabled: true\n        }\n      }, 'Should disable interaction: null');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n  const expectedInteractions = {\n    ...defaultInteractionConfig,\n    tooltip: {\n      ...defaultInteractionConfig.tooltip,\n      enabled: false,\n      config: {\n        compareMode: false,\n        compareType: 'absolute',\n        fieldsToShow: {\n          a5ybmwl2d: [{\n            name: 'a_zip',\n            format: null\n          }, {\n            name: 'zip_area',\n            format: null\n          }, {\n            name: 'avg_number',\n            format: null\n          }, {\n            name: 'str_type',\n            format: null\n          }, {\n            name: 'int_type',\n            format: null\n          }]\n        }\n      }\n    },\n    brush: {\n      ...defaultInteractionConfig.brush,\n      enabled: false,\n      config: {\n        size: 1\n      }\n    },\n    coordinate: {\n      ...defaultInteractionConfig.coordinate,\n      enabled: true\n    }\n  };\n\n  // test parsed interactions\n  t.deepEqual(stateWData.interactionConfig, expectedInteractions, 'should merge interactionConfig');\n  t.deepEqual(stateWData.interactionToBeMerged, {}, 'should clear interaction');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger - mergeLayerBlending","suites":[],"updatePoint":{"line":922,"column":41,"index":35409},"line":922,"code":"test('VisStateMerger - mergeLayerBlending', t => {\n  const preState = {\n    layerBlending: 'additive'\n  };\n  t.deepEqual(mergeLayerBlending(preState, 'normal'), {\n    layerBlending: 'normal'\n  }, 'should merge layerBlending');\n  t.deepEqual(mergeLayerBlending(preState, undefined), {\n    layerBlending: 'additive'\n  }, 'should merge layerBlending');\n  t.deepEqual(mergeLayerBlending(preState, 'not_exist'), {\n    layerBlending: 'additive'\n  }, 'should merge layerBlending');\n  t.deepEqual(mergeLayerBlending(preState, null), {\n    layerBlending: 'additive'\n  }, 'should merge layerBlending');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger - mergeSplitMaps -> split to split","suites":[],"updatePoint":{"line":940,"column":55,"index":36031},"line":940,"code":"test('VisStateMerger - mergeSplitMaps -> split to split', t => {\n  // state with splitMaps\n  const oldState = cloneDeep(StateWSplitMaps).visState;\n  // saved config with splitMaps\n  const savedConfig = cloneDeep(savedStateV1Split);\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config);\n\n  // 1. merge State reset current splitMaps\n  const mergedState = visStateReducer(oldState, receiveMapConfig(parsedConfig));\n  const expectedToMerge = [{\n    layers: {\n      f24uw1: false,\n      '9x77w7h': true\n    }\n  }, {\n    layers: {\n      f24uw1: true,\n      '9x77w7h': false\n    }\n  }];\n  const expectedToMergeAll = [{\n    layers: {\n      f24uw1: false,\n      '9x77w7h': true,\n      'point-0': false,\n      'geojson-1': true\n    }\n  }, {\n    layers: {\n      f24uw1: true,\n      '9x77w7h': false,\n      'point-0': true,\n      'geojson-1': true\n    }\n  }];\n  t.deepEqual(mergedState.splitMaps, [], 'Should reset splitMaps');\n  t.deepEqual(mergedState.splitMapsToBeMerged, expectedToMerge);\n\n  // 2. merge State keep current splitMaps\n  const mergedState2 = visStateReducer(oldState, receiveMapConfig(parsedConfig, {\n    keepExistingConfig: true\n  }));\n  t.deepEqual(mergedState2.splitMaps, oldState.splitMaps, 'Should keep current splitMaps');\n  t.deepEqual(mergedState2.splitMapsToBeMerged, expectedToMerge, 'Should save unmerged to splitMapsToBeMerged');\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n  // 3. load data into reducer\n  const mergedState3 = visStateReducer(mergedState2, updateVisData(parsedData));\n  t.deepEqual(mergedState3.splitMaps, expectedToMergeAll, 'Should merge all splitMaps');\n  t.deepEqual(mergedState3.splitMapsToBeMerged, [], 'Should empty splitMapsToBeMerged');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger - mergeSplitMaps","suites":[],"updatePoint":{"line":991,"column":37,"index":37760},"line":991,"code":"test('VisStateMerger - mergeSplitMaps', t => {\n  const testState1 = {\n    layers: [],\n    splitMaps: [{\n      layers: {\n        a: true\n      }\n    }, {\n      layers: {\n        a: false\n      }\n    }],\n    splitMapsToBeMerged: []\n  };\n  t.deepEqual(mergeSplitMaps(testState1, []), {\n    ...testState1,\n    splitMapsToBeMerged: []\n  }, 'should return empty');\n  const testSM = [{\n    layers: {\n      c: true\n    }\n  }, {\n    layers: {\n      c: false\n    }\n  }];\n  t.deepEqual(mergeSplitMaps(testState1, testSM), {\n    ...testState1,\n    splitMapsToBeMerged: testSM\n  }, 'should save non-exist layers to splitMapsToBeMerged');\n  const testState2 = {\n    layers: [{\n      id: 'c',\n      config: {\n        isVisible: true\n      }\n    }],\n    splitMaps: [{\n      layers: {\n        a: true\n      }\n    }, {\n      layers: {\n        a: false\n      }\n    }],\n    splitMapsToBeMerged: []\n  };\n  t.deepEqual(mergeSplitMaps(testState2, testSM), {\n    ...testState2,\n    splitMaps: [{\n      layers: {\n        a: true,\n        c: true\n      }\n    }, {\n      layers: {\n        a: false,\n        c: false\n      }\n    }],\n    splitMapsToBeMerged: []\n  }, 'should merge split maps');\n  const testState3 = {\n    layers: [{\n      id: 'c',\n      config: {\n        isVisible: true\n      }\n    }],\n    splitMaps: [],\n    splitMapsToBeMerged: []\n  };\n  t.deepEqual(mergeSplitMaps(testState3, testSM), {\n    ...testState3,\n    splitMaps: [{\n      layers: {\n        c: true\n      }\n    }, {\n      layers: {\n        c: false\n      }\n    }],\n    splitMapsToBeMerged: []\n  }, 'should create split maps panel and merge split maps');\n  const testState4 = {\n    layers: [{\n      id: 'a',\n      config: {\n        isVisible: true\n      }\n    }, {\n      id: 'b',\n      config: {\n        isVisible: false\n      }\n    }, {\n      id: 'c',\n      config: {\n        isVisible: true\n      }\n    }],\n    splitMaps: [],\n    splitMapsToBeMerged: []\n  };\n  t.deepEqual(mergeSplitMaps(testState4, testSM), {\n    ...testState4,\n    splitMaps: [{\n      layers: {\n        a: true,\n        c: true\n      }\n    }, {\n      layers: {\n        a: true,\n        c: false\n      }\n    }],\n    splitMapsToBeMerged: []\n  }, 'should create split maps panel, add current layer to splitMaps and merge split maps');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger - mergeTripGeojson","suites":[],"updatePoint":{"line":1115,"column":39,"index":40028},"line":1115,"code":"test('VisStateMerger - mergeTripGeojson', t => {\n  const initialState = cloneDeep(InitialState);\n\n  // processKeplerglJSON\n  const result = processKeplerglJSON(savedStateV1TripGeoJson);\n  const updatedCore = coreReducer(initialState, addDataToMap(result));\n  const mergedVieState = updatedCore.visState;\n  t.equal(mergedVieState.layers.length, 1, 'should create 1 layer');\n  const tripLayer = mergedVieState.layers[0];\n  t.equal(tripLayer.type, 'trip', 'should create 1 trip layer');\n  cmpLayers(t, tripLayer, mergedTripLayer, {\n    id: true,\n    color: true\n  });\n  t.deepEqual(tripLayer.dataToFeature, mergedTripLayer.dataToFeature, 'dataToFeature should be correct');\n  t.deepEqual(tripLayer.dataToTimeStamp, mergedTripLayer.dataToTimeStamp, 'dataToTimeStamp should be correct');\n  t.deepEqual(tripLayer.meta.bounds, mergedTripLayer.meta.bounds, 'meta.bounds should be correct');\n  t.deepEqual(tripLayer.meta.featureTypes, mergedTripLayer.meta.featureTypes, 'meta.featureTypes should be correct');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeFilters -> nonValidFilter","suites":[],"updatePoint":{"line":1135,"column":57,"index":41062},"line":1135,"code":"test('VisStateMerger.v1 -> mergeFilters -> nonValidFilter', t => {\n  const savedConfig = cloneDeep(NonValidFilterState);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // parsed filters must be empty\n  cmpFilters(t, [], stateWData.filters);\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger.v1 -> mergeFilters -> multiFilters","suites":[],"updatePoint":{"line":1158,"column":55,"index":42073},"line":1158,"code":"test('VisStateMerger.v1 -> mergeFilters -> multiFilters', t => {\n  const stateToSave = cloneDeep(StateWMultiFilters);\n  const oldCsvData = stateToSave.visState.datasets[testCsvDataId];\n  const oldGeoJsonData = stateToSave.visState.datasets[testGeoJsonDataId];\n  const appStateToSave = SchemaManager.save(stateToSave);\n  const stateParsed = SchemaManager.load(appStateToSave);\n  const oldState = cloneDeep(InitialState);\n  const oldVisState = oldState.visState;\n  const mergedState = visStateReducer(oldVisState, updateVisData(stateParsed.datasets, {}, stateParsed.config));\n  // check datasets is filtered\n  // and field has filterProps\n\n  const tFields0 = testFields.map(f => ({\n    ...f,\n    ...(f.name === 'time' ? {\n      filterProps: timeFilterProps\n    } : f.name === 'date' ? {\n      filterProps: dateFilterProps\n    } : f.name === 'epoch' ? {\n      filterProps: epochFilterProps\n    } : {})\n  }));\n  const dc0 = createDataContainer(testAllData, {\n    fields: tFields0\n  });\n  const tFields1 = fields.map(f => ({\n    ...f,\n    ...(f.name === 'TRIPS' ? {\n      filterProps: geoJsonTripFilterProps\n    } : f.name === 'RATE' ? {\n      filterProps: geoJsonRateFilterProps\n    } : {})\n  }));\n  const dc1 = createDataContainer(testGeoJsonAllData, {\n    fields: tFields1\n  });\n  const expectedDatasets = {\n    [testCsvDataId]: {\n      metadata: {\n        id: testCsvDataId,\n        label: 'hello.csv',\n        format: ''\n      },\n      type: '',\n      supportedFilterTypes: null,\n      disableDataOperation: false,\n      fields: tFields0,\n      dataContainer: dc0,\n      allIndexes: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n      id: testCsvDataId,\n      label: 'hello.csv',\n      color: 'donot test me',\n      filteredIndex: [0, 1, 2, 3, 7, 8, 9, 10, 11, 12],\n      filteredIndexForDomain: [0, 1, 2, 3, 7, 8, 9, 10, 11, 12],\n      fieldPairs: oldCsvData.fieldPairs,\n      filterRecord: {\n        dynamicDomain: [mergedDateFilter],\n        fixedDomain: [mergedTimeFilter, mergedEpochFilter],\n        cpu: [mergedDateFilter],\n        gpu: [mergedTimeFilter, mergedEpochFilter]\n      },\n      gpuFilter: {\n        filterRange: [[1474606800000 - 1474588800000, 1474617600000 - 1474588800000], [1472700000000 - 1472688000000, 1472760000000 - 1472688000000], [0, 0], [0, 0]],\n        filterValueUpdateTriggers: {\n          gpuFilter_0: 'time',\n          gpuFilter_1: 'epoch',\n          gpuFilter_2: null,\n          gpuFilter_3: null\n        },\n        filterValueAccessor: {\n          inputs: [{\n            index: 1\n          }],\n          result: [1474588800000 - 1474588800000, 1472688000000 - 1472688000000, 0, 0]\n        }\n      },\n      changedFilters: {\n        dynamicDomain: {\n          'date-2': 'added'\n        },\n        fixedDomain: {\n          'time-0': 'added',\n          'epoch-4': 'added'\n        },\n        cpu: {\n          'date-2': 'added'\n        },\n        gpu: {\n          'time-0': 'added',\n          'epoch-4': 'added'\n        }\n      }\n    },\n    [testGeoJsonDataId]: {\n      metadata: {\n        id: testGeoJsonDataId,\n        label: 'zip.geojson',\n        format: ''\n      },\n      type: '',\n      supportedFilterTypes: null,\n      disableDataOperation: false,\n      fields: tFields1,\n      filterRecord: {\n        dynamicDomain: [mergedRateFilter, mergedTripFilter],\n        fixedDomain: [],\n        cpu: [mergedRateFilter],\n        gpu: [mergedTripFilter]\n      },\n      gpuFilter: {\n        filterRange: [[0, 8], [0, 0], [0, 0], [0, 0]],\n        filterValueUpdateTriggers: {\n          gpuFilter_0: 'TRIPS',\n          gpuFilter_1: null,\n          gpuFilter_2: null,\n          gpuFilter_3: null\n        },\n        filterValueAccessor: {\n          inputs: [{\n            index: 1\n          }],\n          result: [0, 0, 0, 0]\n        }\n      },\n      dataContainer: dc1,\n      allIndexes: [0, 1, 2, 3, 4],\n      id: testGeoJsonDataId,\n      label: 'zip.geojson',\n      color: 'donot test me',\n      filteredIndex: [0],\n      filteredIndexForDomain: [0],\n      fieldPairs: oldGeoJsonData.fieldPairs,\n      changedFilters: {\n        dynamicDomain: {\n          'RATE-1': 'added',\n          'TRIPS-3': 'added'\n        },\n        fixedDomain: null,\n        cpu: {\n          'RATE-1': 'added'\n        },\n        gpu: {\n          'TRIPS-3': 'added'\n        }\n      }\n    }\n  };\n  cmpDatasets(t, expectedDatasets, mergedState.datasets);\n  const expectedFilters = [mergedTimeFilter, mergedRateFilter, mergedDateFilter, mergedTripFilter, mergedEpochFilter];\n  cmpFilters(t, expectedFilters, mergedState.filters);\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> import polygon filter map","suites":[],"updatePoint":{"line":1310,"column":49,"index":46653},"line":1310,"code":"test('VisStateMerger -> import polygon filter map', t => {\n  const oldState = cloneDeep(InitialState);\n  const savedConfig = cloneDeep(polygonFilterMap);\n  const oldVisState = oldState.visState;\n  const parsedConfig = SchemaManager.parseSavedConfig(savedConfig.config, oldState);\n  const parsedFilters = parsedConfig.visState.filters;\n  const mergedState = mergeFilters(oldState.visState, parsedFilters);\n  Object.keys(oldVisState).forEach(key => {\n    if (key === 'filterToBeMerged') {\n      t.deepEqual(mergedState.filterToBeMerged, parsedFilters, 'Should save filters to filterToBeMerged before data loaded');\n    } else {\n      t.deepEqual(mergedState[key], oldVisState[key], 'Should keep the rest of state same');\n    }\n  });\n  const parsedData = SchemaManager.parseSavedData(savedConfig.datasets);\n\n  // load data into reducer\n  const stateWData = visStateReducer(mergedState, updateVisData(parsedData));\n\n  // parsed filters must be empty\n  cmpFilters(t, [], stateWData.filters);\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> insertLayerAtRightOrder -> to empty config","suites":[],"updatePoint":{"line":1333,"column":66,"index":47672},"line":1333,"code":"test('VisStateMerger -> insertLayerAtRightOrder -> to empty config', t => {\n  const testCases = [{\n    preservedOrder: ['a', 'b', 'c', 'd'],\n    batches: [{\n      load: [{\n        id: 'b'\n      }],\n      expectedLayers: [{\n        id: 'b'\n      }],\n      expectedOrder: ['b']\n    }, {\n      load: [{\n        id: 'a'\n      }, {\n        id: 'c'\n      }],\n      expectedLayers: [{\n        id: 'b'\n      }, {\n        id: 'a'\n      }, {\n        id: 'c'\n      }],\n      expectedOrder: ['a', 'b', 'c']\n    }, {\n      load: [{\n        id: 'd'\n      }],\n      expectedLayers: [{\n        id: 'b'\n      }, {\n        id: 'a'\n      }, {\n        id: 'c'\n      }, {\n        id: 'd'\n      }],\n      expectedOrder: ['a', 'b', 'c', 'd']\n    }],\n    expectedLayers: [{\n      id: 'b'\n    }, {\n      id: 'a'\n    }, {\n      id: 'c'\n    }, {\n      id: 'd'\n    }],\n    expectedOrder: ['a', 'b', 'c', 'd']\n  }, {\n    preservedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h'],\n    batches: [{\n      load: [{\n        id: '6'\n      }],\n      expectedLayers: [{\n        id: '6'\n      }],\n      expectedOrder: ['6']\n    }, {\n      load: [{\n        id: 'e'\n      }],\n      expectedLayers: [{\n        id: '6'\n      }, {\n        id: 'e'\n      }],\n      expectedOrder: ['e', '6']\n    }, {\n      load: [{\n        id: 'x'\n      }, {\n        id: 'p'\n      }, {\n        id: 'w'\n      }, {\n        id: 'h'\n      }],\n      expectedLayers: [{\n        id: '6'\n      }, {\n        id: 'e'\n      }, {\n        id: 'x'\n      }, {\n        id: 'p'\n      }, {\n        id: 'w'\n      }, {\n        id: 'h'\n      }],\n      expectedOrder: ['x', 'e', 'p', 'w', '6', 'h']\n    }, {\n      load: [{\n        id: 'm'\n      }],\n      expectedLayers: [{\n        id: '6'\n      }, {\n        id: 'e'\n      }, {\n        id: 'x'\n      }, {\n        id: 'p'\n      }, {\n        id: 'w'\n      }, {\n        id: 'h'\n      }, {\n        id: 'm'\n      }],\n      expectedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h']\n    }],\n    expectedLayers: [{\n      id: '6'\n    }, {\n      id: 'e'\n    }, {\n      id: 'x'\n    }, {\n      id: 'p'\n    }, {\n      id: 'w'\n    }, {\n      id: 'h'\n    }, {\n      id: 'm'\n    }],\n    expectedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h']\n  }, {\n    preservedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h'],\n    batches: [{\n      load: [{\n        id: 'x'\n      }, {\n        id: 'm'\n      }],\n      expectedLayers: [{\n        id: 'x'\n      }, {\n        id: 'm'\n      }],\n      expectedOrder: ['x', 'm']\n    }, {\n      load: [{\n        id: 'w'\n      }],\n      expectedLayers: [{\n        id: 'x'\n      }, {\n        id: 'm'\n      }, {\n        id: 'w'\n      }],\n      expectedOrder: ['x', 'm', 'w']\n    }, {\n      load: [{\n        id: 'p'\n      }],\n      expectedLayers: [{\n        id: 'x'\n      }, {\n        id: 'm'\n      }, {\n        id: 'w'\n      }, {\n        id: 'p'\n      }],\n      expectedOrder: ['x', 'm', 'p', 'w']\n    }, {\n      load: [{\n        id: 'e'\n      }, {\n        id: 'h'\n      }, {\n        id: '6'\n      }],\n      expectedLayers: [{\n        id: 'x'\n      }, {\n        id: 'm'\n      }, {\n        id: 'w'\n      }, {\n        id: 'p'\n      }, {\n        id: 'e'\n      }, {\n        id: 'h'\n      }, {\n        id: '6'\n      }],\n      expectedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h']\n    }],\n    expectedOrder: ['x', 'm', 'e', 'p', 'w', '6', 'h'],\n    expectedLayers: [{\n      id: 'x'\n    }, {\n      id: 'm'\n    }, {\n      id: 'w'\n    }, {\n      id: 'p'\n    }, {\n      id: 'e'\n    }, {\n      id: 'h'\n    }, {\n      id: '6'\n    }]\n  }];\n  testCases.forEach(({\n    preservedOrder,\n    batches,\n    expectedOrder,\n    expectedLayers\n  }) => {\n    let currentLayers = [];\n    let currentOrder = [];\n\n    // add layers in batch\n    for (const batch of batches) {\n      const {\n        newLayerOrder,\n        newLayers\n      } = insertLayerAtRightOrder(currentLayers, batch.load, currentOrder, preservedOrder);\n      currentLayers = newLayers;\n      currentOrder = newLayerOrder;\n      t.deepEqual(currentLayers, batch.expectedLayers, 'Should insert layer at correct Order');\n      t.deepEqual(currentOrder, batch.expectedOrder, 'Should reconstruct layer order');\n    }\n    t.deepEqual(currentLayers, expectedLayers, 'Should insert layer at correct Order');\n    t.deepEqual(currentOrder, expectedOrder, 'Should reconstruct layer order');\n  });\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> insertLayerAtRightOrder -> to empty config","suites":[],"updatePoint":{"line":1571,"column":66,"index":51964},"line":1571,"code":"test('VisStateMerger -> insertLayerAtRightOrder -> to empty config', t => {\n  const preservedOrder = ['a', 'b', 'c', 'd'];\n  const batches = [{\n    load: [{\n      id: 'b'\n    }],\n    expectedLayers: [{\n      id: 'm'\n    }, {\n      id: 'b'\n    }],\n    expectedOrder: ['b', 'm']\n  }, {\n    load: [{\n      id: 'a'\n    }, {\n      id: 'c'\n    }],\n    expectedLayers: [{\n      id: 'm'\n    }, {\n      id: 'b'\n    }, {\n      id: 'a'\n    }, {\n      id: 'c'\n    }],\n    expectedOrder: ['a', 'b', 'c', 'm']\n  }, {\n    load: [{\n      id: 'd'\n    }],\n    expectedLayers: [{\n      id: 'm'\n    }, {\n      id: 'b'\n    }, {\n      id: 'a'\n    }, {\n      id: 'c'\n    }, {\n      id: 'd'\n    }],\n    expectedOrder: ['a', 'b', 'c', 'd', 'm']\n  }];\n  let currentLayers = [{\n    id: 'm'\n  }];\n  let currentOrder = ['m'];\n\n  // add layers in batch\n  for (const batch of batches) {\n    const {\n      newLayerOrder,\n      newLayers\n    } = insertLayerAtRightOrder(currentLayers, batch.load, currentOrder, preservedOrder);\n    currentLayers = newLayers;\n    currentOrder = newLayerOrder;\n    t.deepEqual(currentLayers, batch.expectedLayers, 'Should insert layer at correct Order');\n    t.deepEqual(currentOrder, batch.expectedOrder, 'Should reconstruct layer order');\n  }\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> load polygon filter map","suites":[],"updatePoint":{"line":1634,"column":47,"index":53204},"line":1634,"code":"test('VisStateMerger -> load polygon filter map', t => {\n  const oldState = mockStateWithPolygonFilter();\n  const oldFilter = oldState.visState.filters[0];\n  const appStateToSave = SchemaManager.save(oldState);\n  const stateParsed = SchemaManager.load(appStateToSave);\n  const initialState = cloneDeep(InitialState);\n  const initialVisState = initialState.visState;\n  const visState = visStateReducer(initialVisState, updateVisData(stateParsed.datasets, {}, stateParsed.config));\n  const newFilter = visState.filters[0];\n  t.deepEqual(newFilter, oldFilter, 'Should have loaded the polygon filter correctly');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> createLayerFromConfig with Parsed Layer","suites":[],"updatePoint":{"line":1646,"column":63,"index":53844},"line":1646,"code":"test('VisStateMerger -> createLayerFromConfig with Parsed Layer', t => {\n  const oldState = CloneDeep(StateWFiles);\n  t.equal(oldState.visState.layers.length, 2, 'Should have layers');\n\n  // mock an exported layer config with visual channels\n  const savedLayer = visStateSchema[CURRENT_VERSION].save({\n    layers: [oldState.visState.layers[0]],\n    layerOrder: [oldState.visState.layers[0].id]\n  }).visState.layers[0];\n  t.ok(savedLayer.visualChannels, 'Should have visualChannels');\n  const addedLayer = createLayerFromConfig(oldState.visState, savedLayer);\n  t.ok(addedLayer.visConfigSettings, 'Should have visConfig settings loaded correctly');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"VisStateMerger -> asyne mergers","suites":[],"updatePoint":{"line":1744,"column":37,"index":56440},"line":1744,"code":"test('VisStateMerger -> asyne mergers', t => {\n  // adding mock process to state\n  const stateToSave = cloneDeep(StateWMultiFilters);\n  const appStateToSave = SchemaManager.save(stateToSave);\n  const stateParsed = SchemaManager.load(appStateToSave);\n  const configWithProcess = {\n    ...stateParsed.config,\n    visState: {\n      ...stateParsed.config.visState,\n      process: {\n        dataId: testCsvDataId\n      }\n    }\n  };\n  drainTasksForTesting();\n  const initialState = mockReducer(undefined, registerEntry({\n    id: 'test'\n  }));\n\n  // apply config with process to merge\n  const nextState = mockReducer(initialState,\n  // add csv data first\n  updateVisData(stateParsed.datasets.find(d => d.info.id === testCsvDataId), {}, configWithProcess));\n  t.deepEqual(nextState.test.visState.isMergingDatasets, {\n    [testCsvDataId]: true\n  }, 'should set test dataId to true');\n  t.equal(nextState.test.visState.layers.length, 0, 'should not add any layers');\n  t.equal(nextState.test.visState.filters.length, 0, 'should not add any filters');\n  t.equal(nextState.test.visState.layerToBeMerged.length, 2, 'should have 2 layers waiting to be merged');\n  t.ok(nextState.test.visState.datasets[testCsvDataId], 'should add csv data');\n  const tasks = drainTasksForTesting();\n  t.equal(tasks.length, 1, 'should create 1 task');\n  t.equal(tasks[0].type, 'MOCK_MERGE_TASK', 'should create merger task');\n\n  // add another dataset will async merger is in process\n  const nextState1 = mockReducer(nextState,\n  // add geojson data\n  updateVisData(stateParsed.datasets.find(d => d.info.id === testGeoJsonDataId)));\n  t.ok(nextState1.test.visState.datasets[testGeoJsonDataId], 'should add geojson data');\n  t.deepEqual(nextState1.test.visState.isMergingDatasets, {\n    [testCsvDataId]: true\n  }, 'isMergingDatasets of dataId is still true');\n  t.equal(nextState1.test.visState.layers.length, 1, 'should merge 1 layer');\n  t.equal(nextState1.test.visState.layers[0].config.dataId, testGeoJsonDataId, 'should only merge layer of geojson data');\n  t.equal(nextState1.test.visState.filters.length, 2, 'should merge 2 filters');\n  t.deepEqual(nextState1.test.visState.filters.map(f => f.dataId), [[testGeoJsonDataId], [testGeoJsonDataId]], 'should merge 2 filters of geojson data');\n\n  // async merge succeed\n  const nextState2 = mockReducer(nextState1, succeedTaskInTest(tasks[0], undefined));\n  t.deepEqual(nextState2.test.visState.isMergingDatasets, {\n    [testCsvDataId]: false\n  }, 'should set isMerging data to false');\n  t.equal(nextState2.test.visState.layers.length, 2, 'should merge 2 layers');\n  t.equal(nextState2.test.visState.layers[1].config.dataId, testCsvDataId, 'should merge layer of csv data');\n  t.equal(nextState2.test.visState.filters.length, 5, 'should merge 5 filters');\n  t.end();\n});","file":"node/reducers/vis-state-merger-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer","suites":[],"updatePoint":{"line":169,"column":22,"index":5633},"line":169,"code":"test('#visStateReducer', t => {\n  t.deepEqual(reducer(undefined, {}), {\n    ...INITIAL_VIS_STATE,\n    initialState: {}\n  }, 'should return the initial state');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> ADD_FILTER","suites":[],"updatePoint":{"line":176,"column":36,"index":5822},"line":176,"code":"test('#visStateReducer -> ADD_FILTER', t => {\n  const dataId = 'kitten';\n  const newFilter = getDefaultFilter(dataId);\n  const newReducer = reducer({\n    filters: [mockFilter]\n  }, VisStateActions.addFilter(dataId));\n  const expectedReducer = {\n    filters: [mockFilter, newFilter]\n  };\n  t.equal(newReducer.filters.length, expectedReducer.filters.length, 'should add a default filter');\n  t.deepEqual(newReducer.filters[0], expectedReducer.filters[0], 'should add a default filter');\n  cmpFilters(t, newReducer.filters[1], expectedReducer.filters[1]);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> ADD_LAYER.1","suites":[],"updatePoint":{"line":190,"column":37,"index":6391},"line":190,"code":"test('#visStateReducer -> ADD_LAYER.1', t => {\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    datasets: {\n      puppy: {\n        data: mockData.data,\n        fields: mockData.fields\n      }\n    },\n    layers: [{\n      id: 'existing_layer'\n    }],\n    layerData: [[{\n      data: [1, 2, 3]\n    }, {\n      data: [4, 5, 6]\n    }]],\n    layerOrder: ['existing_layer'],\n    splitMaps: [{\n      layers: {\n        existing_layer: false\n      }\n    }, {\n      layers: {\n        existing_layer: false\n      }\n    }]\n  };\n  const newReducer = reducer(oldState, VisStateActions.addLayer());\n  const newId = newReducer.layers[1].id;\n  const expectedSplitMaps = [{\n    layers: {\n      existing_layer: false,\n      [newId]: true\n    }\n  }, {\n    layers: {\n      existing_layer: false,\n      [newId]: true\n    }\n  }];\n  t.equal(newReducer.layers.length, 2, 'should have 2 layers');\n  t.equal(newReducer.layers[1].config.isVisible, true, 'newLayer visibility should be set to true');\n  t.equal(newReducer.layers[1].config.isConfigActive, true, 'newLayer isConfigActive should be set to true');\n  t.equal(newReducer.layers[1].config.dataId, 'puppy', 'newLayer dataId should be set to default');\n  t.deepEqual(newReducer.layerData, [oldState.layerData[0], {}], 'newState should have empty layer datat');\n  t.deepEqual(newReducer.layerOrder, [newReducer.layers[1].id, newReducer.layers[0].id], 'should add to layerOrder');\n  t.deepEqual(newReducer.splitMaps, expectedSplitMaps, 'should add to SplitMaps');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_TYPE_CHANGE.0","suites":[],"updatePoint":{"line":240,"column":45,"index":7904},"line":240,"code":"test('#visStateReducer -> LAYER_TYPE_CHANGE.0', t => {\n  const layer = new Layer({\n    id: 'blue'\n  });\n  const oldState = {\n    ...INITIAL_VIS_STATE\n  };\n  const nextState = reducer(oldState, VisStateActions.layerTypeChange());\n  t.equal(oldState, nextState, 'should return state when no argument is given');\n  const nextState2 = reducer(oldState, VisStateActions.layerTypeChange(layer, 'no_type'));\n  t.equal(oldState, nextState2, 'should return state when pass a none existing type');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_TYPE_CHANGE.1","suites":[],"updatePoint":{"line":253,"column":45,"index":8407},"line":253,"code":"test('#visStateReducer -> LAYER_TYPE_CHANGE.1', t => {\n  const layer = new Layer({\n    id: 'more_layer'\n  });\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    datasets: {\n      puppy: {\n        data: mockData.data,\n        fields: mockData.fields\n      }\n    },\n    layers: [{\n      id: 'existing_layer'\n    }, layer],\n    layerData: [[{\n      data: [1, 2, 3]\n    }, {\n      data: [4, 5, 6]\n    }]],\n    layerOrder: ['more_layer', 'existing_layer'],\n    hoverInfo: {\n      layer: {\n        props: {\n          id: 'more_layer'\n        }\n      },\n      picked: true\n    },\n    clicked: {\n      layer: {\n        props: {\n          id: 'more_layer'\n        }\n      },\n      picked: true\n    },\n    splitMaps: [{\n      layers: {\n        existing_layer: false,\n        more_layer: true\n      }\n    }, {\n      layers: {\n        existing_layer: false,\n        more_layer: false\n      }\n    }]\n  };\n  const nextState = reducer(oldState, VisStateActions.layerTypeChange(layer, 'point'));\n  const newId = nextState.layers[1].id;\n  const expectedSplitMaps = [{\n    layers: {\n      existing_layer: false,\n      [newId]: true\n    }\n  }, {\n    layers: {\n      existing_layer: false,\n      [newId]: false\n    }\n  }];\n  t.ok(nextState.layers[1].id !== 'more_layer', 'should update layer id');\n  t.equal(nextState.layers[1].type, 'point', 'should update type to point');\n  t.deepEqual(nextState.splitMaps, expectedSplitMaps, 'should add newId to SplitMaps, and replace old id');\n  t.ok(!nextState.clicked, 'should reset clicked');\n  t.ok(!nextState.hoverInfo, 'should reset hoverInfo');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_TYPE_CHANGE.2","suites":[],"updatePoint":{"line":322,"column":45,"index":9993},"line":322,"code":"test('#visStateReducer -> LAYER_TYPE_CHANGE.2', t => {\n  const pointLayer = new PointLayer({\n    id: 'a',\n    dataId: 'smoothie'\n  });\n  const mockColorRange = {\n    name: 'abc',\n    isReversed: true,\n    colors: ['a', 'b', 'c']\n  };\n  const datasets = createNewDataEntry({\n    info: {\n      id: 'smoothie'\n    },\n    data: {\n      rows: testAllData,\n      fields: testFields\n    }\n  });\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    datasets,\n    layers: [pointLayer],\n    layerData: []\n  };\n\n  // set point layer colorField to a string field\n  let stringField = testFields.find(f => f.type === 'string');\n  stringField = {\n    ...stringField,\n    valueAccessor: stringField.valueAccessor(datasets.smoothie.dataContainer)\n  };\n  let nextState = reducer(oldState, VisStateActions.layerVisualChannelConfigChange(pointLayer, {\n    colorField: stringField\n  }, 'color'));\n  nextState = reducer(nextState, VisStateActions.layerVisConfigChange(nextState.layers[0], {\n    colorRange: mockColorRange\n  }));\n  const newLayer = nextState.layers[0];\n  t.equal(newLayer.config.colorField, stringField, 'should update colorField');\n  t.equal(newLayer.config.colorScale, 'ordinal', 'should scale to ordinal');\n  t.deepEqual(newLayer.config.colorDomain, ['driver_analytics', 'driver_analytics_0', 'driver_gps'], 'should calculate color domain');\n  t.equal(newLayer.config.visConfig.colorRange, mockColorRange, 'should update color range');\n\n  // set point layer sizeField to a int field\n  let intField = testFields.find(f => f.type === 'integer');\n  intField = {\n    ...intField,\n    valueAccessor: intField.valueAccessor(datasets.smoothie.dataContainer)\n  };\n  let nextState2 = reducer(nextState, VisStateActions.layerVisualChannelConfigChange(newLayer, {\n    sizeField: intField\n  }, 'size'));\n  nextState2 = reducer(nextState2, VisStateActions.layerVisConfigChange(nextState2.layers[0], {\n    radiusRange: [5, 10]\n  }));\n  const newLayer2 = nextState2.layers[0];\n  t.equal(newLayer2.config.sizeField, intField, 'should update sizeField');\n  t.equal(newLayer2.config.sizeScale, 'sqrt', 'should scale to sqrt');\n  t.deepEqual(newLayer2.config.sizeDomain, [1, 12124], 'should calculate size domain');\n  t.deepEqual(newLayer2.config.visConfig.radiusRange, [5, 10], 'should update size range');\n\n  // change point layer type to hexagon\n  const nextState3 = reducer(nextState2, VisStateActions.layerTypeChange(newLayer2, 'hexagon'));\n  const newLayer3 = nextState3.layers[0];\n  t.equal(newLayer3.type, 'hexagon', 'should change type to hexagon');\n  t.equal(newLayer3.config.colorField, stringField, 'should keep colorField');\n  t.deepEqual(newLayer3.config.colorDomain, [0, 1], 'should set colorDomain to default, it is calculated inside deck.gl layer');\n  t.equal(newLayer3.config.colorScale, 'ordinal', 'should set colorScale to ordinal');\n  t.equal(newLayer3.config.sizeScale, 'sqrt', 'should set sizeScale to default');\n  t.deepEqual(newLayer3.config.sizeDomain, [0, 1], 'should set sizeDomain to default');\n  t.equal(newLayer3.config.sizeField, intField, 'should keep sizeField');\n  t.notEqual(newLayer3.id, newLayer2.id, 'should change id');\n  t.equal(newLayer3.config.visConfig.colorRange, mockColorRange, 'should not deep copy colorRange');\n  t.equal(newLayer3.config.visConfig.sizeRange, LAYER_VIS_CONFIGS.elevationRange.defaultValue, 'should set sizeRange back to default');\n\n  // change point layer type to icon\n  const nextState4 = reducer(nextState2, VisStateActions.layerTypeChange(newLayer2, 'icon'));\n  const newLayer4 = nextState4.layers[0];\n  t.equal(newLayer4.type, 'icon', 'should change type to icon');\n  t.notEqual(newLayer4.id, newLayer2.id, 'should change id');\n  t.equal(newLayer4.config.colorField, stringField, 'should keep colorField');\n  t.deepEqual(newLayer4.config.colorDomain, ['driver_analytics', 'driver_analytics_0', 'driver_gps'], 'should calculate color domain');\n  t.equal(newLayer4.config.colorScale, 'ordinal', 'should keep color scale');\n  t.equal(newLayer4.config.sizeField, intField, 'should keep sizeField');\n  t.equal(newLayer4.config.sizeScale, 'sqrt', 'should scale to linear');\n  t.deepEqual(newLayer4.config.sizeDomain, [1, 12124], 'should keep size domain');\n  t.deepEqual(newLayer4.config.visConfig.radiusRange, [5, 10], 'should keep size range');\n  t.equal(newLayer4.config.visConfig.colorRange, mockColorRange, 'should not deep copy colorRange');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_TYPE_CHANGE.3 -> animationConfig","suites":[],"updatePoint":{"line":413,"column":64,"index":14415},"line":413,"code":"test('#visStateReducer -> LAYER_TYPE_CHANGE.3 -> animationConfig', t => {\n  const layer = new GeojsonLayer({\n    label: 'taro and blue',\n    dataId: 'taro',\n    columns: {\n      geojson: {\n        fieldIdx: 0,\n        value: '_geojson'\n      }\n    },\n    isVisible: true,\n    color: [1, 1, 1],\n    id: 'taro'\n  });\n  const dataset = createNewDataEntry({\n    info: {\n      id: 'taro'\n    },\n    data: processGeojson(tripGeojson)\n  });\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    datasets: dataset,\n    layers: [layer],\n    layerData: [{}],\n    layerOrder: [0]\n  };\n\n  // change GeoJson layer to Trip layer\n  const nextState = reducer(oldState, VisStateActions.layerTypeChange(layer, 'trip'));\n  const foundLayer = nextState.layers[0];\n  const foundLayerId = foundLayer.id;\n  t.ok(foundLayerId !== 'taro', 'should update layer id');\n  t.equal(foundLayer.type, 'trip', 'should update type to trip');\n  t.deepEqual(foundLayer.config.animation, {\n    enabled: true,\n    domain: timeStampDomain\n  }, 'should set correct animation domain');\n  t.deepEqual(nextState.animationConfig, {\n    ...DEFAULT_ANIMATION_CONFIG,\n    domain: timeStampDomain,\n    currentTime: timeStampDomain[0],\n    defaultTimeFormat: 'L LTS'\n  }, 'should update visState.animationConfig');\n\n  // change Trip layer to Geojson layer\n  const nextState2 = reducer(oldState, VisStateActions.layerTypeChange(foundLayer, 'geojson'));\n  const foundLayer2 = nextState2.layers[0];\n  t.ok(foundLayer2.id !== foundLayerId, 'should update layer id');\n  t.equal(foundLayer2.type, 'geojson', 'should update type to trip');\n  t.deepEqual(foundLayer2.config.animation, {\n    enabled: false\n  }, 'should set correct animation domain fro Geojson layer');\n  t.deepEqual(nextState2.animationConfig, DEFAULT_ANIMATION_CONFIG, 'should set animationConfig to default');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_CONFIG_CHANGE -> isVisible -> animationConfig","suites":[],"updatePoint":{"line":469,"column":77,"index":16261},"line":469,"code":"test('#visStateReducer -> LAYER_CONFIG_CHANGE -> isVisible -> animationConfig', t => {\n  const initialState = StateWTripGeojson;\n  const layer = initialState.visState.layers[0];\n\n  // change Trip layer isVisible\n  const nextState = reducer(StateWTripGeojson.visState, VisStateActions.layerConfigChange(layer, {\n    isVisible: false\n  }));\n  t.deepEqual(nextState.animationConfig, {\n    ...DEFAULT_ANIMATION_CONFIG,\n    domain: null,\n    currentTime: 1565577261000,\n    isAnimating: false\n  }, 'should set animationConfig to default');\n  const nextState2 = reducer(nextState, VisStateActions.layerConfigChange(nextState.layers[0], {\n    isVisible: true\n  }));\n  t.deepEqual(nextState2.animationConfig, {\n    ...nextState2.animationConfig,\n    domain: timeStampDomain,\n    currentTime: timeStampDomain[0],\n    defaultTimeFormat: 'L LTS'\n  }, 'should set animationConfig domain and currentTime');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_CONFIG_CHANGE -> isVisible -> splitMaps","suites":[],"updatePoint":{"line":494,"column":71,"index":17164},"line":494,"code":"test('#visStateReducer -> LAYER_CONFIG_CHANGE -> isVisible -> splitMaps', t => {\n  const initialState = StateWSplitMaps.visState;\n  const layer = initialState.layers[0];\n  const initialSplitMaps = [{\n    layers: {\n      'point-0': false,\n      'geojson-1': true\n    }\n  }, {\n    layers: {\n      'point-0': true,\n      'geojson-1': true\n    }\n  }];\n  const expectedSplitMaps = [{\n    layers: {\n      'geojson-1': true\n    }\n  }, {\n    layers: {\n      'geojson-1': true\n    }\n  }];\n  t.deepEqual(initialState.splitMaps, initialSplitMaps, 'should has the same initial splitMaps');\n  const nextState = reducer(initialState, VisStateActions.layerConfigChange(layer, {\n    isVisible: false\n  }));\n  t.equal(nextState.layers[0].config.isVisible, false, 'should set layer 0 visibility to false');\n  t.equal(initialState.layerData[0], nextState.layerData[0], 'should not update layerData');\n  t.deepEqual(nextState.splitMaps, expectedSplitMaps, 'should remove layer from splitMaps');\n  const nextState2 = reducer(nextState, VisStateActions.layerConfigChange(layer, {\n    isVisible: true\n  }));\n  const initialSplitMaps2 = [{\n    layers: {\n      'point-0': true,\n      'geojson-1': true\n    }\n  }, {\n    layers: {\n      'point-0': true,\n      'geojson-1': true\n    }\n  }];\n  t.deepEqual(nextState2.splitMaps, initialSplitMaps2, 'should add layer to splitMaps');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"visStateReducer -> layerDataIdChangeUpdater","suites":[],"updatePoint":{"line":541,"column":49,"index":18509},"line":541,"code":"test('visStateReducer -> layerDataIdChangeUpdater', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor).visState;\n  const pointLayer = initialState.layers[0];\n  const nextState = reducer(initialState, VisStateActions.layerConfigChange(pointLayer, {\n    dataId: testGeoJsonDataId\n  }));\n  const updatedLayer = nextState.layers[0];\n  t.equal(updatedLayer.config.dataId, testGeoJsonDataId, 'should update point layer dataId');\n  t.deepEqual(updatedLayer.config.columns, {\n    altitude: {\n      value: null,\n      fieldIdx: -1,\n      optional: true\n    },\n    lat: {\n      value: null,\n      fieldIdx: -1\n    },\n    lng: {\n      value: null,\n      fieldIdx: -1\n    }\n  }, 'should not update point layer column');\n  t.equal(updatedLayer.config.colorField, null, 'should not update point layer colorField');\n\n  // add layer\n  const nextState1 = reducer(nextState, VisStateActions.addLayer());\n  const newLayer = nextState1.layers[nextState1.layers.length - 1];\n  const nextState2 = reducer(nextState1, VisStateActions.layerConfigChange(newLayer, {\n    dataId: testGeoJsonDataId,\n    color: [1, 2, 3]\n  }));\n  t.equal(nextState2.layers[nextState1.layers.length - 1].config.dataId, testGeoJsonDataId, 'should update new layer dataId');\n  t.deepEqual(nextState2.layers[nextState1.layers.length - 1].config.color, [1, 2, 3], 'should update new layer color');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"visStateReducer -> layerDataIdChangeUpdater -> geojson","suites":[],"updatePoint":{"line":577,"column":60,"index":19902},"line":577,"code":"test('visStateReducer -> layerDataIdChangeUpdater -> geojson', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor).visState;\n  const nextState = reducer(initialState,\n  // add another geojson\n  VisStateActions.updateVisData([{\n    info: {\n      id: 'geojson2',\n      label: 'Some Geojson'\n    },\n    data: {\n      fields: geojsonFields,\n      rows: geojsonRows.slice(0, 3)\n    }\n  }]));\n\n  // find geojson layer\n  const index = nextState.layers.findIndex(l => l.type === 'geojson');\n  const geojsonLayer = nextState.layers[index];\n  const id = geojsonLayer.id;\n  // change dataId\n  const nextState1 = reducer(nextState, VisStateActions.layerConfigChange(geojsonLayer, {\n    dataId: 'geojson2'\n  }));\n  const neextGeojsonLayer = nextState1.layers.find(l => l.id === id);\n  t.equal(neextGeojsonLayer.config.dataId, 'geojson2', 'should update layer dataId');\n  t.equal(neextGeojsonLayer.dataToFeature.length, 3, 'should calculate dataToFeature');\n  t.equal(nextState1.layerData[index].data.length, 3, 'should calculate layerData');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"visStateReducer -> layerDataIdChangeUpdater -> validation","suites":[],"updatePoint":{"line":606,"column":63,"index":20967},"line":606,"code":"test('visStateReducer -> layerDataIdChangeUpdater -> validation', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor).visState;\n  const pointLayer = initialState.layers[0];\n  const textField = pointLayer.config.textLabel[0].field;\n  const newDataInfo = {\n    id: 'new-data-csv',\n    label: 'new Data'\n  };\n  const fieldIdx = testFields.findIndex(f => f.name === textField.name);\n\n  // remove 1 field from sample data\n  const fields = testFields.filter(f => f.name !== textField.name);\n  const rows = testAllData.map(row => [...row.slice(0, fieldIdx), ...row.slice(fieldIdx + 1, row.length)]);\n  // add another dataset\n  const nextState = reducer(initialState, VisStateActions.updateVisData([{\n    info: newDataInfo,\n    data: {\n      fields,\n      rows\n    }\n  }]));\n  const nextState1 = reducer(nextState, VisStateActions.layerConfigChange(pointLayer, {\n    dataId: 'new-data-csv'\n  }));\n  const updatedLayer = nextState1.layers[0];\n  t.equal(updatedLayer.config.dataId, 'new-data-csv', 'should update point layer dataId');\n  t.equal(updatedLayer.config.colorField.name, 'gps_data.types', 'should update point layer colorField');\n  t.deepEqual(updatedLayer.config.columns, {\n    altitude: {\n      value: null,\n      fieldIdx: -1,\n      optional: true\n    },\n    lat: {\n      value: 'gps_data.lat',\n      fieldIdx: 1\n    },\n    lng: {\n      value: 'gps_data.lng',\n      fieldIdx: 2\n    }\n  }, 'should update point layer column');\n  t.equal(updatedLayer.config.textLabel[0].field, undefined, 'should assign fields not exists to undefined');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_VIS_CONFIG_CHANGE -> opacity","suites":[],"updatePoint":{"line":651,"column":60,"index":22537},"line":651,"code":"test('#visStateReducer -> LAYER_VIS_CONFIG_CHANGE -> opacity', t => {\n  const initialState = StateWFiles.visState;\n  const layer = initialState.layers[0];\n  const nextState = reducer(initialState, VisStateActions.layerVisConfigChange(layer, {\n    opacity: 0.3\n  }));\n  t.equal(nextState.layers[0].config.visConfig.opacity, 0.3, 'should update layer opacity');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_TEXT_LABEL_CHANGE","suites":[],"updatePoint":{"line":660,"column":49,"index":22901},"line":660,"code":"test('#visStateReducer -> LAYER_TEXT_LABEL_CHANGE', t => {\n  const initialState = StateWFiles.visState;\n  // point layer\n  const layer = initialState.layers[0];\n  t.deepEqual(layer.config.textLabel, [DEFAULT_TEXT_LABEL], 'should set initial textLabel');\n  const nextState = reducer(initialState, VisStateActions.layerTextLabelChange(layer, 0, 'random', 1));\n  t.equal(nextState.layers[0].config.textLabel, layer.config.textLabel, 'should not update textLabel if prop is not in textLabel');\n  const nextState2 = reducer(nextState, VisStateActions.layerTextLabelChange(nextState.layers[0], 0, 'anchor', 'start'));\n  t.deepEqual(nextState2.layers[0].config.textLabel[0], {\n    ...DEFAULT_TEXT_LABEL,\n    anchor: 'start'\n  }, 'should start text label prop');\n  const valueAccessor = () => 1;\n  const expectedField = {\n    name: 'taro',\n    valueAccessor\n  };\n\n  // set text label field\n  const nextState3 = reducer(nextState2, VisStateActions.layerTextLabelChange(nextState2.layers[0], 0, 'field', expectedField));\n  const expectedTextLabel1 = {\n    ...DEFAULT_TEXT_LABEL,\n    anchor: 'start',\n    field: expectedField\n  };\n  t.deepEqual(nextState3.layers[0].config.textLabel[0], expectedTextLabel1, 'should set text field');\n\n  // add empty field\n  const nextState4 = reducer(nextState3, VisStateActions.layerTextLabelChange(nextState3.layers[0], 1));\n  t.deepEqual(nextState4.layers[0].config.textLabel, [expectedTextLabel1, DEFAULT_TEXT_LABEL], 'should add text label');\n\n  // add or remove labels\n  const nextState5 = reducer(nextState4, VisStateActions.layerTextLabelChange(nextState4.layers[0], 'all', 'fields', [{\n    name: 'blue',\n    valueAccessor\n  }, {\n    name: 'taro',\n    valueAccessor\n  }]));\n  const expected5 = [expectedTextLabel1, {\n    ...DEFAULT_TEXT_LABEL,\n    field: {\n      name: 'blue',\n      valueAccessor\n    }\n  }];\n  t.deepEqual(nextState5.layers[0].config.textLabel, expected5, 'should add text label taro');\n\n  // // add 1 more label\n  const nextState6 = reducer(nextState5, VisStateActions.layerTextLabelChange(nextState5.layers[0], 2, 'field', {\n    name: 'cat',\n    valueAccessor\n  }));\n  const expected6 = [expectedTextLabel1, {\n    ...DEFAULT_TEXT_LABEL,\n    field: {\n      name: 'blue',\n      valueAccessor\n    }\n  }, {\n    ...DEFAULT_TEXT_LABEL,\n    field: {\n      name: 'cat',\n      valueAccessor\n    }\n  }];\n  t.deepEqual(nextState6.layers[0].config.textLabel, expected6, 'should add text label cat');\n\n  // remove label\n  const nextState7 = reducer(nextState6, VisStateActions.layerTextLabelChange(nextState6.layers[0], 2, 'field', null));\n  const expected7 = [expectedTextLabel1, {\n    ...DEFAULT_TEXT_LABEL,\n    field: {\n      name: 'blue',\n      valueAccessor\n    }\n  }];\n  t.deepEqual(nextState7.layers[0].config.textLabel, expected7, 'should remove text label cat');\n\n  // remove label with all\n  const nextState8 = reducer(nextState7, VisStateActions.layerTextLabelChange(nextState7.layers[0], 'all', 'fields', [{\n    name: 'blue',\n    valueAccessor\n  }]));\n  const expected8 = [{\n    ...DEFAULT_TEXT_LABEL,\n    field: {\n      name: 'blue',\n      valueAccessor\n    }\n  }];\n  t.deepEqual(nextState8.layers[0].config.textLabel, expected8, 'should remove text label blue');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> REORDER_LAYER","suites":[],"updatePoint":{"line":754,"column":39,"index":26119},"line":754,"code":"test('#visStateReducer -> REORDER_LAYER', t => {\n  const newReducer = reducer({\n    layers: [],\n    layerOrder: [0, 1, 2]\n  }, VisStateActions.reorderLayer([0, 2, 1]));\n  t.deepEqual(newReducer, {\n    layers: [],\n    layerOrder: [0, 2, 1]\n  }, 'should re order layers');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_LAYER_BLENDING","suites":[],"updatePoint":{"line":765,"column":47,"index":26413},"line":765,"code":"test('#visStateReducer -> UPDATE_LAYER_BLENDING', t => {\n  const newReducer = reducer({\n    layerBlending: 'none'\n  }, VisStateActions.updateLayerBlending('additive'));\n  t.deepEqual(newReducer, {\n    layerBlending: 'additive'\n  }, 'should update layerBlending');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> REMOVE_FILTER","suites":[],"updatePoint":{"line":774,"column":39,"index":26684},"line":774,"code":"test('#visStateReducer -> REMOVE_FILTER', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  // filter[0]: 'time' testCsvData\n  // filter[1]: 'RATE' testGeoJsonData\n\n  const dataset0 = initialState.datasets[testCsvDataId];\n  const dataset1 = initialState.datasets[testGeoJsonDataId];\n  const expectedData0 = {\n    ...dataset0,\n    gpuFilter: {\n      filterRange: [[1474606800000 - 1474588800000, 1474617600000 - 1474588800000], [0, 0], [0, 0], [0, 0]],\n      filterValueUpdateTriggers: {\n        gpuFilter_0: 'time',\n        gpuFilter_1: null,\n        gpuFilter_2: null,\n        gpuFilter_3: null\n      },\n      filterValueAccessor: {\n        inputs: [{\n          index: 0\n        }],\n        result: [0, 0, 0, 0]\n      }\n    },\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [initialState.filters[0]],\n      cpu: [],\n      gpu: [initialState.filters[0]]\n    }\n  };\n  const expectedData1 = {\n    ...dataset1,\n    filteredIndex: dataset1.allIndexes,\n    filteredIndexForDomain: dataset1.allIndexes,\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    }\n  };\n  const expectedFilters = [mergedTimeFilter];\n\n  // remove smoothie filter - gpu: true, fixedDomain: false\n  const newReducer = reducer(initialState, VisStateActions.removeFilter(1));\n  const expectedLayerData1 = {\n    data: dataset1.dataContainer.mapIndex(d => d)\n  };\n  const expectedState = {\n    ...initialState,\n    filters: expectedFilters,\n    datasets: {\n      [testCsvDataId]: expectedData0,\n      [testGeoJsonDataId]: expectedData1\n    },\n    layerData: [initialState.layerData[0], expectedLayerData1]\n  };\n  cmpObjectKeys(t, expectedState, newReducer, 'After removing filter, visState');\n  Object.keys(newReducer).forEach(key => {\n    switch (key) {\n      case 'datasets':\n        cmpDatasets(t, expectedState.datasets, newReducer.datasets);\n        break;\n      case 'filters':\n        cmpFilters(t, expectedState.filters, newReducer.filters);\n        break;\n      case 'layers':\n        cmpLayers(t, expectedState.layers, newReducer.layers);\n        break;\n      case 'layerData':\n        // only compare length\n\n        t.equal(expectedState.layerData.length, newReducer.layerData.length, 'should have same number of layerData');\n        newReducer.layerData.forEach((ld, i) => {\n          t.equal(expectedState.layerData[i].data.length, newReducer.layerData[i].data.length, 'layerData.data should have same length');\n        });\n        break;\n      default:\n        t.deepEqual(newReducer[key], expectedState[key], `visState.${key} should be correct after removing filter`);\n        break;\n    }\n  });\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> REMOVE_LAYER","suites":[],"updatePoint":{"line":859,"column":38,"index":29355},"line":859,"code":"test('#visStateReducer -> REMOVE_LAYER', t => {\n  const layer1 = new PointLayer({\n    id: 'a'\n  });\n  const layer2 = new PointLayer({\n    id: 'b'\n  });\n  const oldState = {\n    layers: [layer1, layer2],\n    layerData: [{\n      data: 1\n    }, {\n      data: 2\n    }],\n    layerOrder: ['b', 'a'],\n    hoverInfo: {\n      layer: {\n        props: {\n          id: 'b'\n        }\n      },\n      picked: true\n    },\n    clicked: {\n      layer: {\n        props: {\n          id: 'a'\n        }\n      },\n      picked: true\n    },\n    splitMaps: [],\n    animationConfig: DEFAULT_ANIMATION_CONFIG\n  };\n  const newReducer = reducer(oldState, VisStateActions.removeLayer('b'));\n  t.deepEqual(newReducer, {\n    layers: [layer1],\n    layerData: [{\n      data: 1\n    }],\n    layerOrder: ['a'],\n    hoverInfo: undefined,\n    clicked: {\n      layer: {\n        props: {\n          id: 'a'\n        }\n      },\n      picked: true\n    },\n    splitMaps: [],\n    animationConfig: DEFAULT_ANIMATION_CONFIG\n  }, 'should remove layer and layerData');\n\n  // test remove\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> DUPLICATE_LAYER","suites":[],"updatePoint":{"line":916,"column":41,"index":30408},"line":916,"code":"test('#visStateReducer -> DUPLICATE_LAYER', t => {\n  const oldState = CloneDeep(StateWFilesFiltersLayerColor.visState);\n  // layers: ['point-0', 'geojson-1', 'hexagon-2'],\n  const layerToCopy = serializeLayer(oldState.layers[0], oldState.schema);\n  t.equal(oldState.layers.length, 3, 'should have 3 layers to begin');\n  t.deepEqual(oldState.layerOrder, [oldState.layers[2].id, oldState.layers[0].id, oldState.layers[1].id], 'should have 3 layers to begin');\n  const nextState = reducer(oldState, VisStateActions.duplicateLayer(0));\n  t.equal(nextState.layers.length, 4, 'should add 1 layer');\n  const layerCopied = serializeLayer(nextState.layers[3], nextState.schema);\n  const expectedLayer = {\n    ...layerToCopy,\n    id: layerCopied.id,\n    config: {\n      ...layerToCopy.config,\n      label: 'Copy of gps_data'\n    }\n  };\n  t.deepEqual(layerCopied, expectedLayer, 'should copy layer config correctly');\n  t.deepEqual(nextState.layerData[3].data, nextState.layerData[0].data, 'should copy layer data correctly');\n  t.deepEqual(nextState.layerOrder, [nextState.layers[2].id, nextState.layers[3].id, nextState.layers[0].id, nextState.layers[1].id], 'should insert copied layer in front of older layer');\n\n  // copy again\n  const nextState1 = reducer(nextState, VisStateActions.duplicateLayer(0));\n  t.equal(nextState1.layers.length, 5, 'should add 1 layer');\n  const layerCopied1 = serializeLayer(nextState1.layers[4], nextState1.schema);\n  const expectedLayer1 = {\n    ...layerToCopy,\n    id: layerCopied1.id,\n    config: {\n      ...layerToCopy.config,\n      label: 'Copy of gps_data 1'\n    }\n  };\n  t.deepEqual(layerCopied1, expectedLayer1, 'should copy layer config correctly');\n  t.deepEqual(nextState1.layerData[4].data, nextState1.layerData[0].data, 'should copy layer data correctly');\n  t.deepEqual(nextState1.layerOrder, [nextState1.layers[2].id, nextState1.layers[3].id, nextState1.layers[4].id, nextState1.layers[0].id, nextState1.layers[1].id], 'should insert copied layer in front of older layer');\n\n  // copy again\n  const nextState2 = reducer(nextState1, VisStateActions.duplicateLayer(0));\n  t.equal(nextState2.layers.length, 6, 'should add 1 layer');\n  const layerCopied2 = serializeLayer(nextState2.layers[5], nextState2.schema);\n  const expectedLayer2 = {\n    ...layerToCopy,\n    id: layerCopied2.id,\n    config: {\n      ...layerToCopy.config,\n      label: 'Copy of gps_data 2'\n    }\n  };\n  t.deepEqual(layerCopied2, expectedLayer2, 'should copy layer config correctly');\n\n  // test remove\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.1 -> No data","suites":[],"updatePoint":{"line":970,"column":54,"index":32946},"line":970,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.1 -> No data', t => {\n  const oldState = CloneDeep(InitialState).visState;\n  const nextState1 = reducer(oldState, VisStateActions.updateVisData([{\n    info: null,\n    data: null\n  }]));\n  t.deepEqual(nextState1, oldState, 'should return current state if no data');\n  const nextState2 = reducer(oldState, VisStateActions.updateVisData([{\n    data: {\n      fields: null,\n      rows: [1, 2]\n    }\n  }]));\n  t.deepEqual(nextState2, oldState, 'should return current state if no fields');\n  Object.keys(oldState).forEach(prop => {\n    t.deepEqual(nextState2[prop], oldState[prop], `${prop} should be the same`);\n  });\n  t.deepEqual(reducer(oldState, VisStateActions.updateVisData([{\n    data: {\n      fields: [{\n        name: 'a'\n      }],\n      rows: null\n    }\n  }])), oldState, 'should return current state if no rows');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.2 -> to empty state","suites":[],"updatePoint":{"line":997,"column":61,"index":33828},"line":997,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.2 -> to empty state', t => {\n  const oldState = INITIAL_VIS_STATE;\n  const newState = reducer(oldState, VisStateActions.updateVisData([{\n    data: mockRawData,\n    info: {\n      id: 'smoothie',\n      label: 'exciting dataset'\n    },\n    metadata: {\n      album: 'taro_and_blue'\n    }\n  }]));\n  const expectedDatasets = {\n    smoothie: {\n      fields: expectedFields,\n      filteredIndex: mockRawData.rows.map((_, i) => i),\n      filteredIndexForDomain: mockRawData.rows.map((_, i) => i),\n      allIndexes: mockRawData.rows.map((_, i) => i),\n      dataContainer: createDataContainer(mockRawData.rows, {\n        fields: mockRawData.fields\n      }),\n      gpuFilter: {\n        filterRange: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        filterValueUpdateTriggers: {\n          gpuFilter_0: null,\n          gpuFilter_1: null,\n          gpuFilter_2: null,\n          gpuFilter_3: null\n        },\n        filterValueAccessor: {\n          inputs: ['a', 'b', 'c', 'd', 'e'],\n          result: [0, 0, 0, 0]\n        }\n      },\n      color: 'donnot test me',\n      id: 'smoothie',\n      label: 'exciting dataset',\n      fieldPairs: expectedFieldParis,\n      metadata: {\n        id: 'smoothie',\n        label: 'exciting dataset',\n        album: 'taro_and_blue',\n        format: ''\n      },\n      type: '',\n      supportedFilterTypes: null,\n      disableDataOperation: false\n    }\n  };\n  t.deepEqual(Object.keys(newState.datasets), ['smoothie'], 'should save data to smoothie');\n  cmpDatasets(t, expectedDatasets, newState.datasets);\n  const expectedArcLayer = new ArcLayer({\n    dataId: 'smoothie',\n    label: 'start_point -> end_point arc',\n    columns: {\n      lat0: {\n        fieldIdx: 0,\n        value: 'start_point_lat'\n      },\n      lng0: {\n        fieldIdx: 1,\n        value: 'start_point_lng'\n      },\n      lat1: {\n        fieldIdx: 2,\n        value: 'end_point_lat'\n      },\n      lng1: {\n        fieldIdx: 3,\n        value: 'end_point_lng'\n      }\n    }\n  });\n  const expectedLineLayer = new LineLayer({\n    dataId: 'smoothie',\n    label: 'start_point -> end_point line',\n    columns: {\n      lat0: {\n        fieldIdx: 0,\n        value: 'start_point_lat'\n      },\n      lng0: {\n        fieldIdx: 1,\n        value: 'start_point_lng'\n      },\n      lat1: {\n        fieldIdx: 2,\n        value: 'end_point_lat'\n      },\n      lng1: {\n        fieldIdx: 3,\n        value: 'end_point_lng'\n      },\n      alt0: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      },\n      alt1: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  });\n  const expectedPointLayer1 = new PointLayer({\n    dataId: 'smoothie',\n    label: 'start_point',\n    columns: {\n      lat: {\n        fieldIdx: 0,\n        value: 'start_point_lat'\n      },\n      lng: {\n        fieldIdx: 1,\n        value: 'start_point_lng'\n      },\n      altitude: {\n        fieldIdx: -1,\n        value: null,\n        optional: true\n      }\n    },\n    isVisible: true\n  });\n  expectedPointLayer1.meta = {\n    bounds: [35.2, 12.25, 37.75, 12.29]\n  };\n  const expectedPointLayer2 = new PointLayer({\n    dataId: 'smoothie',\n    label: 'end_point',\n    columns: {\n      lat: {\n        fieldIdx: 2,\n        value: 'end_point_lat'\n      },\n      lng: {\n        fieldIdx: 3,\n        value: 'end_point_lng'\n      },\n      altitude: {\n        fieldIdx: -1,\n        value: null,\n        optional: true\n      }\n    }\n  });\n  expectedPointLayer2.meta = {\n    bounds: [21.3, 33.1, 100.12, 46.21]\n  };\n  const expectedLayers = [expectedPointLayer1, expectedPointLayer2, expectedArcLayer, expectedLineLayer];\n  const newStateLayers = CloneDeep(newState.layers);\n  cmpLayers(t, expectedLayers, newStateLayers);\n  t.equal(newState.layerData.length, expectedLayers.length, 'should calculate layerdata');\n  t.deepEqual(newState.layerOrder, [newStateLayers[0].id, newStateLayers[1].id, newStateLayers[2].id, newStateLayers[3].id], 'should calculate layerOrder');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.3 -> merge w/ existing state","suites":[],"updatePoint":{"line":1154,"column":70,"index":37825},"line":1154,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.3 -> merge w/ existing state', t => {\n  const mockLayer = new PointLayer({\n    dataId: 'snowflake',\n    columns: {\n      lat: {\n        value: 'start_point_lat',\n        fieldIdx: 0\n      },\n      lng: {\n        value: 'start_point_lng',\n        fieldIdx: 1\n      }\n    }\n  });\n  const snowflake = new KeplerTable({\n    data: {\n      fields: [{\n        name: 'a'\n      }, {\n        name: 'b'\n      }],\n      rows: [['something'], ['something_else']]\n    },\n    info: {\n      id: 'snowflake'\n    }\n  });\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    layers: [mockLayer],\n    layerData: [[1, 2], [3, 4], [5, 6], [7, 8]],\n    datasets: {\n      snowflake\n    },\n    filters: [{\n      name: 'hello',\n      dataId: ['a']\n    }, {\n      name: 'world',\n      dataId: ['b']\n    }],\n    interactionConfig: {\n      tooltip: {\n        id: 'tooltip',\n        enabled: true,\n        icon: 'messages',\n        config: {\n          fieldsToShow: {\n            snowflake: ['a']\n          }\n        }\n      }\n    },\n    layerOrder: [mockLayer.id],\n    layerBlending: 'additive',\n    splitMaps: []\n  };\n  const expectedDatasets = {\n    snowflake,\n    smoothie: {\n      metadata: {\n        id: 'smoothie',\n        label: 'smoothie and milkshake',\n        format: ''\n      },\n      type: '',\n      supportedFilterTypes: null,\n      disableDataOperation: false,\n      fields: expectedFields,\n      dataContainer: createDataContainer(mockRawData.rows, {\n        fields: mockRawData.fields\n      }),\n      color: 'donnot test me',\n      filteredIndex: mockRawData.rows.map((_, i) => i),\n      filteredIndexForDomain: mockRawData.rows.map((_, i) => i),\n      allIndexes: mockRawData.rows.map((_, i) => i),\n      gpuFilter: {\n        filterRange: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        filterValueUpdateTriggers: {\n          gpuFilter_0: null,\n          gpuFilter_1: null,\n          gpuFilter_2: null,\n          gpuFilter_3: null\n        },\n        filterValueAccessor: {\n          inputs: [{\n            data: mockData.data[0],\n            index: 0\n          }],\n          result: [0, 0, 0, 0]\n        }\n      },\n      id: 'smoothie',\n      label: 'smoothie and milkshake',\n      fieldPairs: expectedFieldParis\n    }\n  };\n  const expectedInteractionTooltip = {\n    fieldsToShow: {\n      snowflake: ['a'],\n      smoothie: []\n    }\n  };\n  const newState = reducer(oldState, VisStateActions.updateVisData([{\n    data: mockRawData,\n    info: {\n      id: 'smoothie',\n      label: 'smoothie and milkshake'\n    }\n  }]));\n  Object.keys(expectedDatasets).forEach(key => cmpDataset(t, expectedDatasets[key], newState.datasets[key]));\n  t.equal(newState.layers.length, 5, 'should find 1 arc aline and 2 point layers');\n  t.deepEqual(newState.layerOrder, [newState.layers[1].id, newState.layers[2].id, newState.layers[3].id, newState.layers[4].id, newState.layers[0].id], 'should add new layer index to layer order, put them on top');\n  t.equal(newState.layers[1].config.dataId, 'smoothie', 'should save dataId to layer');\n  t.equal(newState.layers[2].config.dataId, 'smoothie', 'should save dataId to layer');\n  t.equal(newState.layers[3].config.dataId, 'smoothie', 'should save dataId to layer');\n  t.equal(newState.layerData.length, 5, 'should calculate layerData');\n  t.equal(newState.filters.length, 2, 'should keep original filters');\n  t.deepEqual(newState.interactionConfig.tooltip.config, expectedInteractionTooltip, 'should set interaction config back to default');\n  t.equal(newState.layerBlending, 'additive', 'should keep layerBlending');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.4.Geojson -> geojson data","suites":[],"updatePoint":{"line":1276,"column":67,"index":41401},"line":1276,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.4.Geojson -> geojson data', t => {\n  const initialVisState = CloneDeep(INITIAL_VIS_STATE);\n  const {\n    fields,\n    rows\n  } = processGeojson(CloneDeep(geojsonData));\n  const payload = [{\n    info: {\n      id: 'milkshake',\n      label: 'king milkshake'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n  const [layer1Color, layer1StrokeColor] = getNextColorMakerValue(2);\n\n  // receive data\n  const initialState = reducer(initialVisState, VisStateActions.updateVisData(payload));\n  const expectedDatasets = {\n    metadata: {\n      id: 'milkshake',\n      label: 'king milkshake',\n      format: ''\n    },\n    type: '',\n    supportedFilterTypes: null,\n    disableDataOperation: false,\n    id: 'milkshake',\n    label: 'king milkshake',\n    color: 'donnot test me',\n    dataContainer: createDataContainer(rows, {\n      fields\n    }),\n    filteredIndex: rows.map((_, i) => i),\n    filteredIndexForDomain: rows.map((_, i) => i),\n    allIndexes: rows.map((_, i) => i),\n    fields,\n    fieldPairs: [],\n    gpuFilter: {\n      filterRange: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      filterValueUpdateTriggers: {\n        gpuFilter_0: null,\n        gpuFilter_1: null,\n        gpuFilter_2: null,\n        gpuFilter_3: null\n      },\n      filterValueAccessor: {\n        inputs: [{\n          data: mockData.data[0],\n          index: 0\n        }],\n        result: [0, 0, 0, 0]\n      }\n    }\n  };\n  const expectedLayer = new GeojsonLayer({\n    label: 'king milkshake',\n    dataId: 'milkshake',\n    columns: {\n      geojson: {\n        fieldIdx: 0,\n        value: '_geojson'\n      }\n    },\n    isVisible: true,\n    color: layer1Color\n  });\n  expectedLayer.updateLayerVisConfig({\n    stroked: true,\n    filled: true,\n    strokeColor: layer1StrokeColor\n  });\n  expectedLayer.dataToFeature = expectedDataToFeature;\n  expectedLayer.meta = updatedGeoJsonLayer.meta;\n  const expectedLayerData = {\n    data: geojsonData.features.map((f, i) => ({\n      ...f,\n      properties: {\n        ...f.properties,\n        TRIPS: f.properties.TRIPS || null,\n        index: i\n      }\n    }))\n  };\n  t.deepEqual(Object.keys(initialState.datasets), ['milkshake'], 'should save geojson to datasets');\n  cmpDataset(t, expectedDatasets, initialState.datasets.milkshake, 'should save correct geojson to datasets');\n  t.equal(initialState.layers.length, 1, 'should find 1 geojson layer');\n  cmpLayers(t, expectedLayer, initialState.layers[0], 'should save dataFeature to geojson layer');\n  t.deepEqual(initialState.layerData[0].data, expectedLayerData.data, 'should save geojson to layer data');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.4.Geojson -> with config","suites":[],"updatePoint":{"line":1369,"column":66,"index":44010},"line":1369,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.4.Geojson -> with config', t => {\n  const initialVisState = CloneDeep(INITIAL_VIS_STATE);\n  const {\n    fields,\n    rows\n  } = processGeojson(CloneDeep(geojsonData));\n  const payload = [{\n    info: {\n      id: 'milkshake',\n      label: 'king milkshake'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n\n  // receive data\n  const initialState = reducer(initialVisState, VisStateActions.updateVisData(payload));\n  t.equal(initialState.layers.length, 1, 'should create 1 layer');\n\n  // add data and config again\n\n  // data\n  const datasets = [{\n    info: {\n      id: 'milkshake2',\n      label: 'king milkshake'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n  const config = {\n    visState: {\n      layers: [{\n        id: 'test_layer_2',\n        type: 'geojson',\n        config: {\n          dataId: 'milkshake2',\n          columns: {\n            geojson: '_geojson'\n          }\n        }\n      }]\n    }\n  };\n  const testState = reducer(initialState, VisStateActions.updateVisData(datasets, {}, config));\n  t.deepEqual(Object.keys(testState.datasets), ['milkshake2'], 'should reset state, and load dataset');\n  t.equal(testState.layers.length, 1, 'should create 1 layer');\n  t.equal(testState.layers[0].id, 'test_layer_2', 'should merge 1 layer from config');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA -> mergeFilters","suites":[],"updatePoint":{"line":1423,"column":57,"index":45330},"line":1423,"code":"test('#visStateReducer -> UPDATE_VIS_DATA -> mergeFilters', t => {\n  const oldState = CloneDeep(INITIAL_VIS_STATE);\n  oldState.filterToBeMerged = [{\n    dataId: 'smoothie',\n    id: '38chejr',\n    view: FILTER_VIEW_TYPES.enlarged,\n    name: mockFilter.name,\n    type: mockFilter.type,\n    value: mockFilter.value\n  }, {\n    dataId: 'nothing_here',\n    id: 'vuey55d',\n    view: FILTER_VIEW_TYPES.enlarged,\n    name: 'test_test',\n    type: 'select',\n    value: true\n  }];\n  const expectedFilterProps = {\n    domain: [12.249990000000002, 12.290000000000001],\n    step: 0.00001,\n    histogram: [1],\n    // test not empty\n    enlargedHistogram: [2],\n    // test not empty\n    fieldType: 'real',\n    view: FILTER_VIEW_TYPES.side,\n    type: mockFilter.type,\n    gpu: true,\n    typeOptions: ['range'],\n    value: [12.249990000000002, 12.290000000000001]\n  };\n  const expectedFilter = {\n    ...expectedFilterProps,\n    animationWindow: 'free',\n    dataId: ['smoothie'],\n    fieldIdx: [0],\n    id: '38chejr',\n    freeze: true,\n    fixedDomain: false,\n    view: FILTER_VIEW_TYPES.enlarged,\n    plotType: 'histogram',\n    yAxis: null,\n    gpu: true,\n    gpuChannel: [0],\n    interval: null,\n    name: [mockFilter.name],\n    speed: 1,\n    isAnimating: false,\n    typeOptions: ['range'],\n    value: mockFilter.value\n  };\n  const newState = reducer(oldState, VisStateActions.updateVisData([{\n    data: mockRawData,\n    info: {\n      id: 'smoothie',\n      label: 'smoothie and milkshake'\n    }\n  }]));\n  const dc = createDataContainer(mockRawData.rows, {\n    fields: mockRawData.fields\n  });\n  const allIndexes = dc.getPlainIndex();\n  const expectedDatasets = {\n    smoothie: {\n      metadata: {\n        id: 'smoothie',\n        label: 'smoothie and milkshake',\n        format: ''\n      },\n      type: '',\n      supportedFilterTypes: null,\n      disableDataOperation: false,\n      fields: expectedFields.map(f => f.name === mockFilter.name ? {\n        ...f,\n        filterProps: expectedFilterProps\n      } : f),\n      // gpu filter in place, filteredIndex should not be updated\n      filteredIndex: allIndexes,\n      filteredIndexForDomain: [0],\n      filterRecord: {\n        dynamicDomain: [newState.filters.find(f => f.id === '38chejr')],\n        fixedDomain: [],\n        cpu: [],\n        gpu: [newState.filters.find(f => f.id === '38chejr')]\n      },\n      gpuFilter: {\n        filterRange: [[mockFilter.value[0] - expectedFilter.domain[0], mockFilter.value[1] - expectedFilter.domain[0]], [0, 0], [0, 0], [0, 0]],\n        filterValueUpdateTriggers: {\n          gpuFilter_0: mockFilter.name,\n          gpuFilter_1: null,\n          gpuFilter_2: null,\n          gpuFilter_3: null\n        },\n        filterValueAccessor: {\n          inputs: [{\n            index: 0\n          }],\n          result: [12.25 - expectedFilter.domain[0], 0, 0, 0]\n        }\n      },\n      allIndexes,\n      dataContainer: dc,\n      color: 'donot test me',\n      id: 'smoothie',\n      label: 'smoothie and milkshake',\n      fieldPairs: expectedFieldParis,\n      changedFilters: {\n        dynamicDomain: {\n          '38chejr': 'added'\n        },\n        fixedDomain: null,\n        cpu: null,\n        gpu: {\n          '38chejr': 'added'\n        }\n      }\n    }\n  };\n  const expectedState = {\n    filterToBeMerged: [oldState.filterToBeMerged[1]],\n    filters: [expectedFilter],\n    datasets: expectedDatasets\n  };\n  cmpDatasets(t, expectedState.datasets, newState.datasets);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_VIS_DATA.SPLIT_MAPS","suites":[],"updatePoint":{"line":1549,"column":52,"index":48771},"line":1549,"code":"test('#visStateReducer -> UPDATE_VIS_DATA.SPLIT_MAPS', t => {\n  const layer0 = new PointLayer({\n    dataId: 'snowflake',\n    id: 'a',\n    isVisible: true\n  });\n  const layer1 = new PointLayer({\n    dataId: 'milkshake',\n    id: 'b',\n    isVisible: true\n  });\n  const layer2 = new PointLayer({\n    dataId: 'milkshake',\n    id: 'c',\n    isVisible: false\n  });\n  const layer3 = new PointLayer({\n    dataId: 'milkshake',\n    id: 'd',\n    isVisible: false\n  });\n  const layers = [layer0, layer1, layer2, layer3];\n  const oldState = {\n    ...INITIAL_VIS_STATE,\n    layers: [layer0, layer1, layer2, layer3],\n    splitMaps: [{\n      layers: {\n        a: true,\n        b: false\n      }\n    }, {\n      layers: {\n        a: false,\n        b: true\n      }\n    }],\n    interactionConfig: {\n      tooltip: {\n        config: {\n          fieldsToShow: {\n            milkshake: []\n          }\n        }\n      }\n    },\n    layerData: [],\n    layerOrder: [layers[2].id, layers[1].id, layers[0].id, layers[3].id]\n  };\n  const newState = reducer(oldState, VisStateActions.updateVisData([{\n    data: mockRawData,\n    info: {\n      id: 'smoothie',\n      label: 'smoothie and milkshake'\n    }\n  }]));\n\n  // first visible layer should be point\n  const id1 = newState.layers[4].id;\n  const expectedSplitMaps = [{\n    layers: {\n      a: true,\n      b: false,\n      [id1]: true\n    }\n  }, {\n    layers: {\n      a: false,\n      b: true,\n      [id1]: true\n    }\n  }];\n  t.equal(newState.layers.length, 8, 'should create 1 arc 1 line and 2 point layers');\n  t.deepEqual(newState.layerOrder, [newState.layers[4].id, newState.layers[5].id, newState.layers[6].id, newState.layers[7].id, newState.layers[2].id, newState.layers[1].id, newState.layers[0].id, newState.layers[3].id], 'should move new layers to front');\n  t.deepEqual(newState.splitMaps, expectedSplitMaps, 'should add new layers to split maps');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setFilter.dynamicDomain & cpu","suites":[],"updatePoint":{"line":1625,"column":55,"index":50663},"line":1625,"code":"test('#visStateReducer -> setFilter.dynamicDomain & cpu', t => {\n  // get test data\n  const {\n    fields,\n    rows\n  } = processCsvData(testData);\n  const payload = [{\n    info: {\n      id: 'smoothie',\n      label: 'queen smoothie'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n\n  // receive data\n  const initialState = reducer(INITIAL_VIS_STATE, VisStateActions.updateVisData(payload));\n  const expectedLayer1 = new PointLayer({\n    isVisible: true,\n    dataId: 'smoothie',\n    label: 'gps_data',\n    columns: {\n      lat: {\n        value: 'gps_data.lat',\n        fieldIdx: 1\n      },\n      lng: {\n        value: 'gps_data.lng',\n        fieldIdx: 2\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  });\n  expectedLayer1.meta = {\n    bounds: [31.2148748, 29.9870074, 31.2590542, 30.0614122]\n  };\n  const expectedLayers = [expectedLayer1];\n  // test default layer\n  t.equal(initialState.layers.length, 1, 'should find one layer');\n  cmpLayers(t, expectedLayers, initialState.layers);\n\n  // add filter\n  const stateWithFilter = reducer(initialState, VisStateActions.addFilter('smoothie'));\n  const expectedFilter = {\n    dataId: ['smoothie'],\n    freeze: false,\n    id: 'donnot test me yet',\n    enabled: true,\n    name: [],\n    type: null,\n    fixedDomain: false,\n    domain: null,\n    value: null,\n    view: FILTER_VIEW_TYPES.side,\n    isAnimating: false,\n    animationWindow: 'free',\n    plotType: 'histogram',\n    yAxis: null,\n    speed: 1,\n    interval: null,\n    gpu: false,\n    fieldIdx: []\n  };\n  cmpFilters(t, expectedFilter, stateWithFilter.filters[0]);\n  const filterId = stateWithFilter.filters[0].id;\n\n  // set filter 'name'\n  const stateWithFilterName = reducer(stateWithFilter, VisStateActions.setFilter(0, 'name', 'date'));\n  const expectedFilterWName = {\n    dataId: ['smoothie'],\n    freeze: true,\n    id: filterId,\n    enabled: true,\n    name: ['date'],\n    type: 'multiSelect',\n    fieldIdx: [10],\n    fixedDomain: false,\n    domain: ['2016-09-23', '2016-09-24', '2016-10-10'],\n    value: [],\n    view: FILTER_VIEW_TYPES.side,\n    isAnimating: false,\n    animationWindow: 'free',\n    fieldType: 'date',\n    plotType: 'histogram',\n    yAxis: null,\n    speed: 1,\n    interval: null,\n    gpu: false\n  };\n\n  // test filter\n  cmpFilters(t, expectedFilterWName, stateWithFilterName.filters[0]);\n  const updatedField = {\n    ...initialState.datasets.smoothie.fields[10],\n    filterProps: {\n      type: 'multiSelect',\n      value: [],\n      fieldType: 'date',\n      domain: ['2016-09-23', '2016-09-24', '2016-10-10'],\n      gpu: false,\n      view: FILTER_VIEW_TYPES.side\n    }\n  };\n  const fieldsEx = [...initialState.datasets.smoothie.fields.slice(0, 10), updatedField];\n  const {\n    dataContainer\n  } = initialState.datasets.smoothie;\n\n  // test dataset\n  const expectedDataset = {\n    metadata: {\n      id: 'smoothie',\n      label: 'queen smoothie',\n      format: ''\n    },\n    type: '',\n    supportedFilterTypes: null,\n    disableDataOperation: false,\n    id: 'smoothie',\n    label: 'queen smoothie',\n    color: 'donnot test me',\n    dataContainer,\n    fields: fieldsEx,\n    filteredIndex: dataContainer.getPlainIndex(),\n    filteredIndexForDomain: dataContainer.getPlainIndex(),\n    allIndexes: dataContainer.getPlainIndex(),\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    },\n    gpuFilter: {\n      filterRange: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      filterValueUpdateTriggers: {\n        gpuFilter_0: null,\n        gpuFilter_1: null,\n        gpuFilter_2: null,\n        gpuFilter_3: null\n      },\n      filterValueAccessor: {\n        inputs: [{\n          index: 0\n        }],\n        result: [0, 0, 0, 0]\n      }\n    },\n    fieldPairs: testCsvFieldPairs,\n    changedFilters: {\n      dynamicDomain: null,\n      fixedDomain: null,\n      cpu: null,\n      gpu: null\n    }\n  };\n  cmpDataset(t, expectedDataset, stateWithFilterName.datasets.smoothie);\n\n  // set filter value\n  const stateWithFilterValue = reducer(stateWithFilterName, VisStateActions.setFilter(0, 'value', ['2016-10-10']));\n  const expectedFilterWValue = {\n    ...expectedFilterWName,\n    value: ['2016-10-10']\n  };\n\n  // test filter\n  cmpFilters(t, expectedFilterWValue, stateWithFilterValue.filters[0]);\n  const updatedFilterWValue = stateWithFilterValue.filters[0];\n  const expectedFilteredDataset = {\n    ...expectedDataset,\n    filterRecord: {\n      dynamicDomain: [updatedFilterWValue],\n      fixedDomain: [],\n      cpu: [updatedFilterWValue],\n      gpu: []\n    },\n    dataContainer,\n    filteredIndex: [17, 18, 19, 20, 21, 22],\n    filteredIndexForDomain: [17, 18, 19, 20, 21, 22],\n    changedFilters: {\n      dynamicDomain: {\n        [updatedFilterWValue.id]: 'added'\n      },\n      fixedDomain: null,\n      cpu: {\n        [updatedFilterWValue.id]: 'added'\n      },\n      gpu: null\n    },\n    type: '',\n    supportedFilterTypes: null,\n    disableDataOperation: false\n  };\n  cmpDataset(t, expectedFilteredDataset, stateWithFilterValue.datasets.smoothie);\n  const expectedLayerData1 = {\n    data: [{\n      index: 17,\n      position: [31.2165983, 30.0538936, 0]\n    }, {\n      index: 18,\n      position: [31.2148748, 30.060911, 0]\n    }, {\n      index: 19,\n      position: [31.2212278, 30.060334, 0]\n    }, {\n      index: 20,\n      position: [31.2288985, 30.0554663, 0]\n    }, {\n      index: 21,\n      position: [31.2187021, 30.0614122, 0]\n    }, {\n      index: 22,\n      position: [31.2191059, 30.0612697, 0]\n    }],\n    getPosition: () => {},\n    getColor: () => {},\n    getRadius: () => {}\n  };\n  t.deepEqual(stateWithFilterValue.layerData[0].data, expectedLayerData1.data, 'should format layer data correctly');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> RENAME_DATASET","suites":[],"updatePoint":{"line":1851,"column":40,"index":56384},"line":1851,"code":"test('#visStateReducer -> RENAME_DATASET', t => {\n  const initialState = StateWTripGeojson.visState;\n  t.equal(initialState.datasets[tripDataInfo.id].label, tripDataInfo.label, 'Initial label as expected');\n  const newLabel = 'New label!!!11';\n  const updated = reducer(initialState, VisStateActions.renameDataset(tripDataInfo.id, newLabel));\n  assertDatasetIsTable(t, updated.datasets[tripDataInfo.id]);\n  t.equal(updated.datasets[tripDataInfo.id].label, newLabel, 'Updated label as expected');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_COLOR_TABLE","suites":[],"updatePoint":{"line":1860,"column":44,"index":56899},"line":1860,"code":"test('#visStateReducer -> UPDATE_COLOR_TABLE', t => {\n  const initialState = StateWTripGeojson.visState;\n  t.deepEqual(initialState.datasets[tripDataInfo.id].color, [192, 108, 132], 'Initial color as expected');\n  const newColor = [255, 255, 255];\n  const updated = reducer(initialState, VisStateActions.updateTableColor(tripDataInfo.id, newColor));\n  assertDatasetIsTable(t, updated.datasets[tripDataInfo.id]);\n  t.equal(updated.datasets[tripDataInfo.id].color, newColor, 'Updated color as expected');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_TABLE_PROPS","suites":[],"updatePoint":{"line":1869,"column":44,"index":57417},"line":1869,"code":"test('#visStateReducer -> UPDATE_TABLE_PROPS', t => {\n  const initialState = StateWTripGeojson.visState;\n\n  // update label\n  t.equal(initialState.datasets[tripDataInfo.id].label, tripDataInfo.label, 'Initial label as expected');\n  const newLabel = 'New label!!!11';\n  let updated = reducer(initialState, VisStateActions.updateDatasetProps(tripDataInfo.id, {\n    label: newLabel\n  }));\n  assertDatasetIsTable(t, updated.datasets[tripDataInfo.id]);\n  t.equal(updated.datasets[tripDataInfo.id].label, newLabel, 'Updated label as expected');\n\n  // update color\n  t.deepEqual(updated.datasets[tripDataInfo.id].color, [192, 108, 132], 'Initial color as expected');\n  const newColor = [255, 255, 255];\n  updated = reducer(updated, VisStateActions.updateDatasetProps(tripDataInfo.id, {\n    color: newColor\n  }));\n  assertDatasetIsTable(t, updated.datasets[tripDataInfo.id]);\n  t.equal(updated.datasets[tripDataInfo.id].label, newLabel, 'Updated color as expected');\n\n  // update meta\n  updated = reducer(updated, VisStateActions.updateDatasetProps(tripDataInfo.id, {\n    metadata: {\n      test: true\n    }\n  }));\n  assertDatasetIsTable(t, updated.datasets[tripDataInfo.id]);\n  t.deepEqual(updated.datasets[tripDataInfo.id].metadata, {\n    ...updated.datasets[tripDataInfo.id].metadata,\n    test: true\n  }, 'Updated color as expected');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER.name","suites":[],"updatePoint":{"line":1903,"column":41,"index":58758},"line":1903,"code":"test('#visStateReducer -> SET_FILTER.name', t => {\n  const oldState = CloneDeep(StateWFilters.visState);\n  const oldFilter0 = oldState.filters[0];\n  // change filter name from RATE to ZIP_CODE\n  const updated = reducer(oldState, VisStateActions.setFilter(1, 'name', 'ZIP_CODE', 0));\n  const expectedFilter0 = oldFilter0;\n  const expectedFilter1 = {\n    dataId: [testGeoJsonDataId],\n    freeze: true,\n    id: 'RATE-1',\n    enabled: true,\n    fixedDomain: false,\n    view: FILTER_VIEW_TYPES.side,\n    isAnimating: false,\n    animationWindow: 'free',\n    speed: 1,\n    name: ['ZIP_CODE'],\n    type: 'range',\n    fieldIdx: [2],\n    domain: [94105, 94111],\n    value: [94105, 94111],\n    plotType: 'histogram',\n    yAxis: null,\n    interval: null,\n    fieldType: 'integer',\n    step: 0.01,\n    histogram: [],\n    enlargedHistogram: 'dont test me',\n    typeOptions: ['range'],\n    gpu: true,\n    gpuChannel: [0]\n  };\n  cmpFilters(t, [expectedFilter0, expectedFilter1], updated.filters);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER.dataId","suites":[],"updatePoint":{"line":1938,"column":43,"index":59756},"line":1938,"code":"test('#visStateReducer -> SET_FILTER.dataId', t => {\n  const oldState = CloneDeep(StateWFilters.visState);\n  let newState = reducer(oldState, VisStateActions.setFilter(1, 'dataId', testCsvDataId));\n  let newFilter = newState.filters[1];\n  let expectedFilter = {\n    ...getDefaultFilter(testCsvDataId),\n    id: newFilter.id\n  };\n  t.deepEqual(newFilter, expectedFilter, 'Should create a new filter using the provided dataId');\n\n  // Using an array of dataId\n  newState = reducer(newState, VisStateActions.setFilter(1, 'dataId', [testCsvDataId]));\n  newFilter = newState.filters[1];\n  expectedFilter = {\n    ...getDefaultFilter(testCsvDataId),\n    id: newFilter.id\n  };\n  t.deepEqual(newFilter, expectedFilter, 'Should create a new filter using the provided list of dataId');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setFilter.dynamicDomain & gpu","suites":[],"updatePoint":{"line":2078,"column":55,"index":63898},"line":2078,"code":"test('#visStateReducer -> setFilter.dynamicDomain & gpu', t => {\n  testSetFilterDynamicDomainGPU(t, VisStateActions.setFilter);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER_ANIMATION_TIME","suites":[],"updatePoint":{"line":2082,"column":51,"index":64037},"line":2082,"code":"test('#visStateReducer -> SET_FILTER_ANIMATION_TIME', t => {\n  testSetFilterDynamicDomainGPU(t, VisStateActions.setFilterAnimationTime);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER_ANIMATION_WINDOW","suites":[],"updatePoint":{"line":2086,"column":53,"index":64191},"line":2086,"code":"test('#visStateReducer -> SET_FILTER_ANIMATION_WINDOW', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const nextState = reducer(initialState, VisStateActions.setFilterAnimationWindow({\n    id: initialState.filters[0].id,\n    animationWindow: 'incremental'\n  }));\n  t.equal(nextState.filters[0].animationWindow, 'incremental', 'should update ANIMATIONWINDOW');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_FILTER_ANIMATION_SPEED","suites":[],"updatePoint":{"line":2095,"column":55,"index":64589},"line":2095,"code":"test('#visStateReducer -> UPDATE_FILTER_ANIMATION_SPEED', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const nextState = reducer(initialState, VisStateActions.updateFilterAnimationSpeed(0, 4));\n  t.equal(nextState.filters[0].speed, 4, 'should update filter animation speed');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setFilter.fixedDomain & DynamicDomain & gpu & cpu","suites":[],"updatePoint":{"line":2101,"column":75,"index":64922},"line":2101,"code":"test('#visStateReducer -> setFilter.fixedDomain & DynamicDomain & gpu & cpu', t => {\n  // get test data\n  const {\n    fields,\n    rows\n  } = processCsvData(testData);\n  const payload = [{\n    info: {\n      id: 'smoothie',\n      label: 'queen smoothie'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n  const datasetSmoothie = createNewDataEntry({\n    info: {\n      id: 'smoothie',\n      label: 'queen smoothie'\n    },\n    data: {\n      rows: testAllData,\n      fields: testFields\n    }\n  }).smoothie;\n\n  // add fixedDomain & gpu filter\n  const stateWidthTsFilter = applyActions(reducer, INITIAL_VIS_STATE, [\n  // receive data\n  {\n    action: VisStateActions.updateVisData,\n    payload: [payload]\n  },\n  // add ts filter\n  {\n    action: VisStateActions.addFilter,\n    payload: ['smoothie']\n  },\n  // set ts filter name\n  {\n    action: VisStateActions.setFilter,\n    payload: [0, 'name', 'gps_data.utc_timestamp']\n  },\n  // set ts filter value\n  {\n    action: VisStateActions.setFilter,\n    payload: [0, 'value', [1474071425000, 1474071740000]]\n  }]);\n  const filterId = stateWidthTsFilter.filters[0].id;\n  const expectedFilterTs = {\n    dataId: ['smoothie'],\n    freeze: true,\n    fixedDomain: true,\n    id: filterId,\n    name: ['gps_data.utc_timestamp'],\n    type: 'timeRange',\n    fieldIdx: [0],\n    domain: [1474070995000, 1474072208000],\n    value: [1474071425000, 1474071740000],\n    step: 1000,\n    plotType: 'histogram',\n    yAxis: null,\n    interval: null,\n    speed: 1,\n    mappedValue: [1474070995000, 1474071056000, 1474071116000, 1474071178000, 1474071240000, 1474071301000, 1474071363000, 1474071425000, 1474071489000, 1474071552000, 1474071567000, 1474071614000, 1474071677000, 1474071740000, 1474071802000, 1474071864000, 1474071928000, 1474071989000, 1474072051000, 1474072115000, 1474072180000, 1474072203000, 1474072203000, 1474072208000],\n    histogram: [],\n    enlargedHistogram: [],\n    view: FILTER_VIEW_TYPES.enlarged,\n    isAnimating: false,\n    animationWindow: 'free',\n    fieldType: 'timestamp',\n    gpu: true,\n    gpuChannel: [0],\n    defaultTimeFormat: 'L LTS'\n  };\n\n  // cmpFilters(t, expectedFilterTs, stateWidthTsFilter.filters[0]);\n\n  const expectedDatasetSmoothie = {\n    ...datasetSmoothie,\n    // add filter prop to fields\n    fields: datasetSmoothie.fields.map(f => f.name === 'gps_data.utc_timestamp' ? {\n      ...f,\n      filterProps: {\n        domain: [1474070995000, 1474072208000],\n        step: 1000,\n        mappedValue: expectedFilterTs.mappedValue,\n        histogram: stateWidthTsFilter.filters[0].histogram,\n        enlargedHistogram: stateWidthTsFilter.filters[0].enlargedHistogram,\n        fieldType: 'timestamp',\n        type: 'timeRange',\n        view: FILTER_VIEW_TYPES.enlarged,\n        fixedDomain: true,\n        value: [1474070995000, 1474072208000],\n        gpu: true,\n        defaultTimeFormat: 'L LTS'\n      }\n    } : f),\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [stateWidthTsFilter.filters[0]],\n      cpu: [],\n      gpu: [stateWidthTsFilter.filters[0]]\n    },\n    gpuFilter: {\n      filterRange: [[1474071425000 - 1474070995000, 1474071740000 - 1474070995000], [0, 0], [0, 0], [0, 0]],\n      filterValueUpdateTriggers: {\n        gpuFilter_0: 'gps_data.utc_timestamp',\n        gpuFilter_1: null,\n        gpuFilter_2: null,\n        gpuFilter_3: null\n      },\n      filterValueAccessor: {\n        inputs: [{\n          index: 1\n        }],\n        result: [61000, 0, 0, 0]\n      }\n    },\n    // copy everything\n    filteredIndex: datasetSmoothie.dataContainer.getPlainIndex(),\n    filteredIndexForDomain: datasetSmoothie.dataContainer.getPlainIndex(),\n    changedFilters: {\n      dynamicDomain: null,\n      fixedDomain: {\n        [filterId]: 'value_changed'\n      },\n      cpu: null,\n      gpu: {\n        [filterId]: 'value_changed'\n      }\n    },\n    type: '',\n    supportedFilterTypes: null,\n    disableDataOperation: false\n  };\n\n  // check filter by ts\n  cmpDataset(t, expectedDatasetSmoothie, stateWidthTsFilter.datasets.smoothie);\n  const stateWidthTsAndNameFilter = applyActions(reducer, stateWidthTsFilter, [\n  // add ordinal filter\n  {\n    action: VisStateActions.addFilter,\n    payload: ['smoothie']\n  },\n  // set ordinal filter name\n  {\n    action: VisStateActions.setFilter,\n    payload: [1, 'name', 'date']\n  },\n  // set ordinal filter value\n  {\n    action: VisStateActions.setFilter,\n    payload: [1, 'value', ['2016-09-24', '2016-10-10']]\n  }]);\n  const filterId1 = stateWidthTsAndNameFilter.filters[1].id;\n  const expectedFilteredDataset = {\n    ...stateWidthTsFilter.datasets.smoothie,\n    fields: stateWidthTsFilter.datasets.smoothie.fields.map(f => f.name === 'date' ? {\n      ...f,\n      filterProps: {\n        domain: ['2016-09-23', '2016-09-24', '2016-10-10'],\n        fieldType: 'date',\n        type: 'multiSelect',\n        value: [],\n        gpu: false,\n        view: FILTER_VIEW_TYPES.side\n      }\n    } : f),\n    gpuFilter: {\n      filterRange: [[1474071425000 - 1474070995000, 1474071740000 - 1474070995000], [0, 0], [0, 0], [0, 0]],\n      filterValueUpdateTriggers: {\n        gpuFilter_0: 'gps_data.utc_timestamp',\n        gpuFilter_1: null,\n        gpuFilter_2: null,\n        gpuFilter_3: null\n      },\n      filterValueAccessor: {\n        inputs: [{\n          index: 1\n        }],\n        result: [61000, 0, 0, 0]\n      }\n    },\n    filterRecord: {\n      dynamicDomain: [stateWidthTsAndNameFilter.filters[1]],\n      fixedDomain: [stateWidthTsAndNameFilter.filters[0]],\n      cpu: [stateWidthTsAndNameFilter.filters[1]],\n      gpu: [stateWidthTsAndNameFilter.filters[0]]\n    },\n    filteredIndex: [7, 8, 9, 10, 11, 12, 17, 18, 19, 20, 21, 22],\n    filteredIndexForDomain: [7, 8, 9, 10, 11, 12, 17, 18, 19, 20, 21, 22],\n    changedFilters: {\n      dynamicDomain: {\n        [filterId1]: 'added'\n      },\n      fixedDomain: null,\n      cpu: {\n        [filterId1]: 'added'\n      },\n      gpu: null\n    },\n    type: '',\n    supportedFilterTypes: null,\n    disableDataOperation: false\n  };\n  cmpDataset(t, expectedFilteredDataset, stateWidthTsAndNameFilter.datasets.smoothie);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER_PLOT","suites":[],"updatePoint":{"line":2311,"column":41,"index":70987},"line":2311,"code":"test('#visStateReducer -> SET_FILTER_PLOT', t => {\n  // get test data\n  const {\n    fields,\n    rows\n  } = processCsvData(testData);\n  const payload = [{\n    info: {\n      id: 'smoothie',\n      label: 'queen smoothie'\n    },\n    data: {\n      fields,\n      rows\n    }\n  }];\n\n  // receive data\n  const initialState = reducer(INITIAL_VIS_STATE, VisStateActions.updateVisData(payload));\n\n  // add filter\n  const stateWithFilter = reducer(initialState, VisStateActions.addFilter('smoothie'));\n  const filterId = stateWithFilter.filters[0].id;\n\n  // set filter 'name' to timestamp field\n  const stateWithFilterName = reducer(stateWithFilter, VisStateActions.setFilter(0, 'name', 'gps_data.utc_timestamp'));\n\n  // find id which is an integer field\n  const yAxisField = stateWithFilterName.datasets.smoothie.fields.find(f => f.name === 'uid');\n\n  // set filterPlot yAxis\n  const stateWithFilterPlot = reducer(stateWithFilterName, VisStateActions.setFilterPlot(0, {\n    yAxis: yAxisField\n  }));\n  const expectedFilterWName = {\n    ...getDefaultFilter('smoothie'),\n    freeze: true,\n    fixedDomain: true,\n    id: filterId,\n    name: ['gps_data.utc_timestamp'],\n    type: 'timeRange',\n    fieldIdx: [0],\n    domain: [1474070995000, 1474072208000],\n    value: [1474070995000, 1474072208000],\n    step: 1000,\n    plotType: 'lineChart',\n    yAxis: yAxisField,\n    interval: null,\n    lineChart: {\n      series: [{\n        x: 1474070995000,\n        y: 1\n      }, {\n        x: 1474071056000,\n        y: 2\n      }, {\n        x: 1474071116000,\n        y: 3\n      }, {\n        x: 1474071178000,\n        y: 4\n      }, {\n        x: 1474071240000,\n        y: 5\n      }, {\n        x: 1474071301000,\n        y: 12124\n      }, {\n        x: 1474071363000,\n        y: 222\n      }, {\n        x: 1474071425000,\n        y: 345\n      }, {\n        x: 1474071864000,\n        y: 1\n      }, {\n        x: 1474071989000,\n        y: 43\n      }, {\n        x: 1474072051000,\n        y: 4\n      }, {\n        x: 1474072115000,\n        y: 5\n      }, {\n        x: 1474072203000,\n        y: 6\n      }, {\n        x: 1474072203000,\n        y: 7\n      }],\n      yDomain: [1, 12124],\n      xDomain: [1474070995000, 1474072203000]\n    },\n    speed: 1,\n    mappedValue: [1474070995000, 1474071056000, 1474071116000, 1474071178000, 1474071240000, 1474071301000, 1474071363000, 1474071425000, 1474071489000, 1474071552000, 1474071567000, 1474071614000, 1474071677000, 1474071740000, 1474071802000, 1474071864000, 1474071928000, 1474071989000, 1474072051000, 1474072115000, 1474072180000, 1474072203000, 1474072203000, 1474072208000],\n    histogram: [],\n    enlargedHistogram: [],\n    view: FILTER_VIEW_TYPES.enlarged,\n    isAnimating: false,\n    animationWindow: 'free',\n    fieldType: 'timestamp',\n    gpu: true,\n    gpuChannel: [0],\n    defaultTimeFormat: 'L LTS'\n  };\n\n  // test filter\n  cmpFilters(t, expectedFilterWName, stateWithFilterPlot.filters[0]);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> TOGGLE_FILTER_ANIMATION","suites":[],"updatePoint":{"line":2423,"column":49,"index":73918},"line":2423,"code":"test('#visStateReducer -> TOGGLE_FILTER_ANIMATION', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const nextState = reducer(initialState, VisStateActions.toggleFilterAnimation(0));\n  t.equal(nextState.filters[0].isAnimating, true, 'should set filter to isAnimating: true');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_FILTER_VIEW","suites":[],"updatePoint":{"line":2429,"column":41,"index":74220},"line":2429,"code":"test('#visStateReducer -> SET_FILTER_VIEW', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const nextState = reducer(initialState, VisStateActions.setFilterView(0, FILTER_VIEW_TYPES.side));\n  t.equal(nextState.filters[0].view, FILTER_VIEW_TYPES.side, 'should toggle time filter view to be side');\n  const nextState2 = reducer(nextState, VisStateActions.setFilterView(0, FILTER_VIEW_TYPES.enlarged));\n  t.equal(nextState2.filters[0].view, FILTER_VIEW_TYPES.enlarged, 'should toggle time filter view to be bottom');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> REMOVE_DATASET","suites":[],"updatePoint":{"line":2437,"column":40,"index":74768},"line":2437,"code":"test('#visStateReducer -> REMOVE_DATASET', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const nextState = reducer(initialState, VisStateActions.removeDataset('not_me'));\n  t.equal(initialState, nextState, 'should return state if datasetKey doesnot exist');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> REMOVE_DATASET w filter and layer","suites":[],"updatePoint":{"line":2443,"column":59,"index":75081},"line":2443,"code":"test('#visStateReducer -> REMOVE_DATASET w filter and layer', t => {\n  const oldState = CloneDeep(StateWFilters.visState);\n  const expectedState = {\n    layers: [oldState.layers[1]],\n    filters: [oldState.filters[1]],\n    layerData: [oldState.layerData[1]],\n    layerOrder: [oldState.layers[1].id],\n    datasets: {\n      [testGeoJsonDataId]: oldState.datasets[testGeoJsonDataId]\n    },\n    interactionConfig: {\n      tooltip: {\n        id: 'tooltip',\n        label: 'interactions.tooltip',\n        enabled: true,\n        config: {\n          compareMode: false,\n          compareType: 'absolute',\n          fieldsToShow: {\n            [testGeoJsonDataId]: [{\n              name: 'OBJECTID',\n              format: null\n            }, {\n              name: 'ZIP_CODE',\n              format: null\n            }, {\n              name: 'ID',\n              format: null\n            }, {\n              name: 'TRIPS',\n              format: null\n            }, {\n              name: 'RATE',\n              format: null\n            }]\n          }\n        }\n      },\n      brush: oldState.interactionConfig.brush,\n      coordinate: oldState.interactionConfig.coordinate,\n      geocoder: oldState.interactionConfig.geocoder\n    },\n    editingDataset: oldState.editingDataset,\n    layerBlending: oldState.layerBlending,\n    overlayBlending: oldState.overlayBlending,\n    hoverInfo: oldState.hoverInfo,\n    clicked: oldState.clicked,\n    mousePos: oldState.mousePos,\n    maxDefaultTooltips: oldState.maxDefaultTooltips,\n    splitMaps: oldState.splitMaps,\n    layerClasses: oldState.layerClasses,\n    animationConfig: oldState.animationConfig,\n    initialState: oldState.initialState,\n    layerToBeMerged: [],\n    filterToBeMerged: [],\n    interactionToBeMerged: {},\n    splitMapsToBeMerged: [],\n    editor: oldState.editor,\n    mapInfo: {\n      title: '',\n      description: ''\n    },\n    fileLoading: oldState.fileLoading,\n    fileLoadingProgress: oldState.fileLoadingProgress,\n    loaders: oldState.loaders,\n    loadOptions: oldState.loadOptions,\n    mergers: oldState.mergers,\n    schema: oldState.schema,\n    isMergingDatasets: {}\n  };\n  const newReducer = reducer(oldState, VisStateActions.removeDataset(testCsvDataId));\n  t.deepEqual(Object.keys(newReducer).sort(), Object.keys(expectedState).sort(), `visState should have same keys`);\n  Object.keys(expectedState).forEach(key => {\n    t.deepEqual(newReducer[key], expectedState[key], `newReducer.${key} should be correct`);\n  });\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: TOGGLE","suites":[],"updatePoint":{"line":2520,"column":43,"index":77552},"line":2520,"code":"test('#visStateReducer -> SPLIT_MAP: TOGGLE', t => {\n  const layer0 = new ArcLayer({\n    id: 'a',\n    dataId: 'puppy_0',\n    isVisible: true\n  });\n  const layer1 = new ArcLayer({\n    id: 'b',\n    dataId: 'puppy_0',\n    isVisible: false\n  });\n  const oldState = {\n    layers: [layer0, layer1],\n    splitMaps: []\n  };\n  const newReducer = reducer(oldState, MapStateActions.toggleSplitMap());\n  t.deepEqual(newReducer.splitMaps, [{\n    layers: {\n      a: true\n    }\n  }, {\n    layers: {}\n  }], 'should split map');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: REMOVE_LAYER","suites":[],"updatePoint":{"line":2545,"column":49,"index":78085},"line":2545,"code":"test('#visStateReducer -> SPLIT_MAP: REMOVE_LAYER', t => {\n  const layer1 = new PointLayer({\n    id: 'a'\n  });\n  const layer2 = new PointLayer({\n    id: 'b'\n  });\n  const layers = [layer1, layer2];\n  const oldState = {\n    layers,\n    layerData: [{\n      data: 1\n    }, {\n      data: 2\n    }],\n    layerOrder: [layers[1].id, layers[0].id],\n    hoverInfo: {\n      layer: {\n        props: {\n          id: 'b'\n        }\n      },\n      picked: true\n    },\n    clicked: {\n      layer: {\n        props: {\n          id: 'a'\n        }\n      },\n      picked: true\n    },\n    splitMaps: [{\n      layers: {\n        a: true,\n        b: true\n      }\n    }, {\n      layers: {\n        a: true,\n        b: true\n      }\n    }],\n    animationConfig: DEFAULT_ANIMATION_CONFIG\n  };\n  const newReducer = reducer(oldState, VisStateActions.removeLayer('b'));\n  t.deepEqual(newReducer, {\n    layers: [layer1],\n    layerData: [{\n      data: 1\n    }],\n    layerOrder: [layer1.id],\n    hoverInfo: undefined,\n    clicked: {\n      layer: {\n        props: {\n          id: 'a'\n        }\n      },\n      picked: true\n    },\n    splitMaps: [{\n      layers: {\n        a: true\n      }\n    }, {\n      layers: {\n        a: true\n      }\n    }],\n    animationConfig: DEFAULT_ANIMATION_CONFIG\n  }, 'should remove layer and layerData in split mode');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: REMOVE_LAYER. set animation domain","suites":[],"updatePoint":{"line":2619,"column":71,"index":79431},"line":2619,"code":"test('#visStateReducer -> SPLIT_MAP: REMOVE_LAYER. set animation domain', t => {\n  const layer1 = new PointLayer({\n    id: 'a'\n  });\n  const layer2 = new PointLayer({\n    id: 'b'\n  });\n  const layer3 = new TripLayer({\n    id: 't1',\n    isVisible: true\n  });\n  const layer4 = new TripLayer({\n    id: 't2',\n    isVisible: true\n  });\n  layer3.updateAnimationDomain([1568502710000, 1568502960000]);\n  layer4.updateAnimationDomain([1568502810000, 1568503060000]);\n  const oldState = {\n    layers: [layer1, layer2, layer3, layer4],\n    layerData: [{\n      data: 1\n    }, {\n      data: 2\n    }, {\n      data: 3\n    }, {\n      data: 4\n    }],\n    layerOrder: [1, 0, 2, 3],\n    hoverInfo: null,\n    clicked: null,\n    splitMaps: [],\n    animationConfig: {\n      domain: [1568502710000, 1568503060000],\n      currentTime: 1568502970000\n    }\n  };\n  const newReducer = reducer(oldState, VisStateActions.removeLayer('t1'));\n  const expectedAnimationConfig = {\n    domain: [1568502810000, 1568503060000],\n    currentTime: 1568502970000,\n    defaultTimeFormat: 'L LTS'\n  };\n  t.deepEqual(newReducer.animationConfig, expectedAnimationConfig, 'should remove animation layer and adjust animation domain');\n  const newReducer2 = reducer(oldState, VisStateActions.removeLayer('t2'));\n  const expectedAnimationConfig2 = {\n    domain: [1568502710000, 1568502960000],\n    currentTime: 1568502710000,\n    defaultTimeFormat: 'L LTS'\n  };\n  t.deepEqual(newReducer2.animationConfig, expectedAnimationConfig2, 'should remove animation layer and adjust animation domain');\n  const newReducer3 = reducer(newReducer2, VisStateActions.removeLayer('t1'));\n  t.deepEqual(newReducer3.animationConfig, {\n    domain: null,\n    currentTime: 1568502710000,\n    defaultTimeFormat: null\n  }, 'remove last animation layer and set animation config to default');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: REMOVE_DATASET","suites":[],"updatePoint":{"line":2678,"column":51,"index":81246},"line":2678,"code":"test('#visStateReducer -> SPLIT_MAP: REMOVE_DATASET', t => {\n  const oldState = StateWSplitMaps.visState;\n  const expectedState = {\n    layers: [oldState.layers[0]],\n    layerData: [oldState.layerData[0]],\n    layerOrder: [oldState.layers[0].id],\n    datasets: {\n      [testCsvDataId]: oldState.datasets[testCsvDataId]\n    },\n    filters: [],\n    interactionConfig: {\n      tooltip: {\n        id: 'tooltip',\n        label: 'interactions.tooltip',\n        enabled: true,\n        config: {\n          compareMode: false,\n          compareType: 'absolute',\n          fieldsToShow: {\n            [testCsvDataId]: [{\n              name: 'gps_data.utc_timestamp',\n              format: null\n            }, {\n              name: 'gps_data.types',\n              format: null\n            }, {\n              name: 'epoch',\n              format: null\n            }, {\n              name: 'has_result',\n              format: null\n            }, {\n              name: 'uid',\n              format: null\n            }]\n          }\n        }\n      },\n      brush: oldState.interactionConfig.brush,\n      coordinate: oldState.interactionConfig.coordinate,\n      geocoder: oldState.interactionConfig.geocoder\n    },\n    splitMaps: [{\n      layers: {\n        'point-0': false\n      }\n    }, {\n      layers: {\n        'point-0': true\n      }\n    }],\n    editingDataset: oldState.editingDataset,\n    layerBlending: oldState.layerBlending,\n    overlayBlending: oldState.overlayBlending,\n    hoverInfo: oldState.hoverInfo,\n    clicked: oldState.clicked,\n    mousePos: oldState.mousePos,\n    maxDefaultTooltips: oldState.maxDefaultTooltips,\n    layerClasses: oldState.layerClasses,\n    animationConfig: DEFAULT_ANIMATION_CONFIG,\n    initialState: oldState.initialState,\n    layerToBeMerged: [],\n    filterToBeMerged: [],\n    interactionToBeMerged: {},\n    splitMapsToBeMerged: [],\n    editor: oldState.editor,\n    mapInfo: {\n      title: '',\n      description: ''\n    },\n    fileLoading: oldState.fileLoading,\n    fileLoadingProgress: oldState.fileLoadingProgress,\n    loaders: oldState.loaders,\n    loadOptions: oldState.loadOptions,\n    schema: oldState.schema,\n    mergers: oldState.mergers,\n    isMergingDatasets: {}\n  };\n  const newReducer = reducer(oldState, VisStateActions.removeDataset(testGeoJsonDataId));\n  t.deepEqual(Object.keys(newReducer).sort(), Object.keys(expectedState).sort(), `visState should have same keys`);\n  Object.keys(expectedState).forEach(key => {\n    t.deepEqual(newReducer[key], expectedState[key], `newReducer.${key} should be correct`);\n  });\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: ADD_LAYER","suites":[],"updatePoint":{"line":2763,"column":46,"index":83808},"line":2763,"code":"test('#visStateReducer -> SPLIT_MAP: ADD_LAYER', t => {\n  const oldState = {\n    datasets: {\n      puppy: {\n        data: mockData.data,\n        fields: mockData.fields\n      }\n    },\n    layers: [{\n      id: 'existing_layer'\n    }],\n    layerData: [[{\n      data: [1, 2, 3]\n    }, {\n      data: [4, 5, 6]\n    }]],\n    layerOrder: [0],\n    splitMaps: [{\n      layers: {\n        existing_layer: true\n      }\n    }, {\n      layers: {\n        existing_layer: true\n      }\n    }]\n  };\n  const newReducer = reducer(oldState, VisStateActions.addLayer());\n  t.equal(newReducer.layers[1].config.isVisible, true, 'newLayer visibility should be set to true');\n  t.equal(newReducer.layers[1].config.isConfigActive, true, 'newLayer isConfigActive should be set to true');\n  t.equal(newReducer.layers[1].config.dataId, 'puppy', 'newLayer dataId should be set to default');\n  t.equal(newReducer.splitMaps.length, 2, 'newLayer was added into splitMaps layers');\n  t.deepEqual(newReducer.splitMaps[0], {\n    layers: {\n      existing_layer: true,\n      [newReducer.layers[1].id]: true\n    }\n  }, 'newLayer map meta data settings are correct');\n  t.deepEqual(newReducer.splitMaps[1], {\n    layers: {\n      existing_layer: true,\n      [newReducer.layers[1].id]: true\n    }\n  }, 'newLayer map meta data settings are correct');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: TOGGLE_SPLIT_MAP","suites":[],"updatePoint":{"line":2809,"column":53,"index":85137},"line":2809,"code":"test('#visStateReducer -> SPLIT_MAP: TOGGLE_SPLIT_MAP', t => {\n  const layer0 = new ArcLayer({\n    id: 'a',\n    dataId: 'puppy_0',\n    isVisible: true\n  });\n  const layer1 = new PointLayer({\n    id: 'b',\n    dataId: 'puppy_0',\n    isVisible: true\n  });\n  const oldState = {\n    layers: [layer0, layer1],\n    splitMaps: [{\n      layers: {\n        a: true,\n        b: true\n      }\n    }, {\n      layers: {\n        a: true,\n        b: false\n      }\n    }]\n  };\n  const newReducer = reducer(oldState, MapStateActions.toggleSplitMap(0));\n  t.equal(newReducer.layers.length, 2, 'should have 2 global layers');\n  t.equal(newReducer.layers[0].config.isVisible, true, 'global layer should have changed to reflect specific map meta info');\n  t.equal(newReducer.layers[1].config.isVisible, false, 'global layer should have changed to reflect specific map meta info');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SPLIT_MAP: HIDE LAYER","suites":[],"updatePoint":{"line":2840,"column":47,"index":86003},"line":2840,"code":"test('#visStateReducer -> SPLIT_MAP: HIDE LAYER', t => {\n  const oldState = {\n    splitMaps: [{\n      layers: {\n        a: true,\n        b: true\n      }\n    }, {\n      layers: {\n        a: true,\n        b: false\n      }\n    }]\n  };\n  const newState = reducer(oldState, VisStateActions.toggleLayerForMap(1, 'a'));\n  const expectedState = {\n    splitMaps: [{\n      layers: {\n        a: true,\n        b: true\n      }\n    }, {\n      layers: {\n        a: false,\n        b: false\n      }\n    }]\n  };\n  t.deepEqual(newState.splitMaps, expectedState.splitMaps, 'should hide layer B in split map');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SET_LAYER_ANIMATION_TIME","suites":[],"updatePoint":{"line":2871,"column":50,"index":86611},"line":2871,"code":"test('#visStateReducer -> SET_LAYER_ANIMATION_TIME', t => {\n  const initialState = StateWTripGeojson.visState;\n  const newState = reducer(initialState, VisStateActions.setLayerAnimationTime(1000));\n  t.equal(newState.animationConfig.currentTime, 1000, 'should update animation time');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> UPDATE_LAYER_ANIMATION_SPEED","suites":[],"updatePoint":{"line":2877,"column":54,"index":86915},"line":2877,"code":"test('#visStateReducer -> UPDATE_LAYER_ANIMATION_SPEED', t => {\n  const initialState = StateWTripGeojson.visState;\n  const newState = reducer(initialState, VisStateActions.updateLayerAnimationSpeed(1.23));\n  t.equal(newState.animationConfig.speed, 1.23, 'should update animation speed');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> TOGGLE_LAYER_ANIMATION","suites":[],"updatePoint":{"line":2883,"column":48,"index":87212},"line":2883,"code":"test('#visStateReducer -> TOGGLE_LAYER_ANIMATION', t => {\n  const initialState = StateWTripGeojson.visState;\n  const newState = reducer(initialState, VisStateActions.toggleLayerAnimation());\n  t.equal(newState.animationConfig.isAnimating, true, 'should update animationConfig');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> INTERACTION_CONFIG_CHANGE","suites":[],"updatePoint":{"line":2889,"column":51,"index":87509},"line":2889,"code":"test('#visStateReducer -> INTERACTION_CONFIG_CHANGE', t => {\n  const brushConfig = {\n    ...defaultInteractionConfig.brush,\n    enabled: true\n  };\n  const expectedConfig = {\n    ...defaultInteractionConfig,\n    brush: brushConfig,\n    tooltip: {\n      ...defaultInteractionConfig.tooltip,\n      enabled: false\n    },\n    geocoder: {\n      ...defaultInteractionConfig.geocoder,\n      enabled: false\n    }\n  };\n  const nextState = reducer(INITIAL_VIS_STATE, VisStateActions.interactionConfigChange(brushConfig));\n  t.deepEqual(nextState.interactionConfig, expectedConfig, 'should disable tooltip');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SHOW_DATASET_TABLE","suites":[],"updatePoint":{"line":2910,"column":44,"index":88114},"line":2910,"code":"test('#visStateReducer -> SHOW_DATASET_TABLE', t => {\n  const initialState = StateWFiles.visState;\n  const nextState = reducer(initialState, VisStateActions.showDatasetTable('abc'));\n  t.equal(nextState.editingDataset, 'abc', 'should set editingDataset');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> MAP_CLICK","suites":[],"updatePoint":{"line":2916,"column":35,"index":88376},"line":2916,"code":"test('#visStateReducer -> MAP_CLICK', t => {\n  const initialState = StateWFiles.visState;\n  const nextState = reducer(initialState, VisStateActions.onLayerClick({\n    picked: true,\n    object: 'he'\n  }));\n  t.deepEqual(nextState, {\n    ...nextState,\n    clicked: {\n      picked: true,\n      object: 'he'\n    }\n  }, 'should set clicked');\n  const nextState2 = reducer(nextState, VisStateActions.onMapClick());\n  t.equal(nextState2.clicked, null, 'should unset clicked');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> MOUSE_MOVE","suites":[],"updatePoint":{"line":2933,"column":36,"index":88862},"line":2933,"code":"test('#visStateReducer -> MOUSE_MOVE', t => {\n  const initialState = StateWFiles.visState;\n  const evt = {\n    point: [10, 20],\n    lngLat: [37, -122]\n  };\n  const nextState = reducer(initialState, VisStateActions.onMouseMove(evt));\n  t.deepEqual(nextState.mousePos, {\n    ...initialState.mousePos,\n    mousePosition: [10, 20],\n    coordinate: [37, -122]\n  }, 'should set mousePos');\n\n  // disable tooltip\n  const tooltipConfig = {\n    ...defaultInteractionConfig.tooltip,\n    enabled: false\n  };\n  const nextState1 = reducer(nextState, VisStateActions.interactionConfigChange(tooltipConfig));\n  const nextState2 = reducer(nextState1, VisStateActions.onMouseMove({\n    point: [1, 2],\n    lngLat: [90, 90]\n  }));\n  t.deepEqual(nextState2.mousePos, {\n    ...initialState.mousePos,\n    mousePosition: [10, 20],\n    coordinate: [37, -122]\n  }, 'should not set mousePos');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_COLOR_UI_CHANGE. show dropdown","suites":[],"updatePoint":{"line":2963,"column":62,"index":89771},"line":2963,"code":"test('#visStateReducer -> LAYER_COLOR_UI_CHANGE. show dropdown', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor.visState);\n  const pointLayer = initialState.layers[0];\n  const oldColorRange = CloneDeep(pointLayer.config.visConfig.colorRange);\n  // show dropdown\n  const nextState = reducer(initialState, VisStateActions.layerColorUIChange(pointLayer, 'color', {\n    showDropdown: 0\n  }));\n  const expectedColorUI = {\n    color: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0\n    },\n    colorRange: DEFAULT_COLOR_UI\n  };\n  t.deepEqual(nextState.layers[0].config.colorUI, expectedColorUI, 'should update colorUI.showDropdown');\n  t.deepEqual(nextState.layers[0].config.visConfig.colorRange, oldColorRange, 'should not change colorRange');\n  const nextState1 = reducer(nextState, VisStateActions.layerColorUIChange(pointLayer, 'color', {\n    showDropdown: false\n  }));\n  t.deepEqual(nextState1.layers[0].config.colorUI, {\n    color: DEFAULT_COLOR_UI,\n    colorRange: DEFAULT_COLOR_UI\n  }, 'should update colorUI.showDropdown');\n  const nextState2 = reducer(nextState1, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    showDropdown: 0\n  }));\n  const expectedColorUI2 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: false\n      }\n    }\n  };\n  t.deepEqual(nextState2.layers[0].config.colorUI, expectedColorUI2, 'should update colorUI.showDropdown, set colorRangeConfig step and reversed');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_COLOR_UI_CHANGE. colorRangeConfig.step","suites":[],"updatePoint":{"line":3006,"column":70,"index":91381},"line":3006,"code":"test('#visStateReducer -> LAYER_COLOR_UI_CHANGE. colorRangeConfig.step', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor.visState);\n  const pointLayer = initialState.layers[0];\n  const oldColorRange = CloneDeep(pointLayer.config.visConfig.colorRange);\n  t.equal(oldColorRange.colors.length, 4, 'old color range should have 4 colors');\n  // show dropdown\n  const prepareState = reducer(initialState, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    showDropdown: 0\n  }));\n\n  // set color range steps\n  const nextState = reducer(prepareState, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    colorRangeConfig: {\n      steps: 6\n    }\n  }));\n  const expectedColorUI = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 6,\n        reversed: false,\n        custom: false\n      }\n    }\n  };\n  const expectedColorRange = {\n    name: 'Uber Viz Sequential 4',\n    type: 'sequential',\n    category: 'Uber',\n    colors: ['#E6FAFA', '#C1E5E6', '#9DD0D4', '#75BBC1', '#4BA7AF', '#00939C']\n  };\n  t.deepEqual(nextState.layers[0].config.colorUI, expectedColorUI, 'should update colorUI.colorRangeConfig.steps');\n  t.deepEqual(nextState.layers[0].config.visConfig.colorRange, expectedColorRange, 'should update visConfig.colorRange based on step');\n\n  // set color range reverse\n  const nextState2 = reducer(nextState, VisStateActions.layerColorUIChange(nextState.layers[0], 'colorRange', {\n    colorRangeConfig: {\n      reversed: true\n    }\n  }));\n  const expectedColorUI2 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 6,\n        reversed: true,\n        custom: false\n      }\n    }\n  };\n  const expectedColorRange2 = {\n    name: 'Uber Viz Sequential 4',\n    type: 'sequential',\n    category: 'Uber',\n    colors: ['#00939C', '#4BA7AF', '#75BBC1', '#9DD0D4', '#C1E5E6', '#E6FAFA'],\n    reversed: true\n  };\n  t.deepEqual(nextState2.layers[0].config.colorUI, expectedColorUI2, 'should update colorUI.colorRangeConfig.reversed');\n  t.deepEqual(nextState2.layers[0].config.visConfig.colorRange, expectedColorRange2, 'should update visConfig.colorRange based on reversed');\n\n  // update step when reversed is true\n  const nextState3 = reducer(nextState, VisStateActions.layerColorUIChange(nextState2.layers[0], 'colorRange', {\n    colorRangeConfig: {\n      steps: 8\n    }\n  }));\n  const expectedColorUI3 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 8,\n        reversed: true,\n        custom: false\n      }\n    }\n  };\n  const expectedColorRange3 = {\n    name: 'Uber Viz Sequential 6',\n    type: 'sequential',\n    category: 'Uber',\n    colors: ['#E6FAFA', '#C1E5E6', '#9DD0D4', '#75BBC1', '#4BA7AF', '#00939C', '#108188', '#0E7077'].reverse(),\n    reversed: true\n  };\n  t.deepEqual(nextState3.layers[0].config.colorUI, expectedColorUI3, 'should update colorUI.colorRangeConfig.steps');\n  t.deepEqual(nextState3.layers[0].config.visConfig.colorRange, expectedColorRange3, 'should update visConfig.colorRange based on match and set reversed');\n\n  // set to a step that has no match\n  const nextState4 = reducer(nextState, VisStateActions.layerColorUIChange(nextState3.layers[0], 'colorRange', {\n    colorRangeConfig: {\n      steps: 11\n    }\n  }));\n  const expectedColorUI4 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 11,\n        reversed: true,\n        custom: false\n      }\n    }\n  };\n  t.deepEqual(nextState4.layers[0].config.colorUI, expectedColorUI4, 'should update colorUI.colorRangeConfig to step 11');\n  t.deepEqual(nextState4.layers[0].config.visConfig.colorRange, expectedColorRange3, 'should note update visConfig.colorRange when no match');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LAYER_COLOR_UI_CHANGE. custom Palette","suites":[],"updatePoint":{"line":3125,"column":63,"index":95435},"line":3125,"code":"test('#visStateReducer -> LAYER_COLOR_UI_CHANGE. custom Palette', t => {\n  const initialState = CloneDeep(StateWFilesFiltersLayerColor.visState);\n  const pointLayer = initialState.layers[0];\n  const oldColorRange = CloneDeep(pointLayer.config.visConfig.colorRange);\n  // show dropdown\n  const prepareState = reducer(initialState, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    showDropdown: 0\n  }));\n\n  // enable custom\n  const nextState = reducer(prepareState, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  }));\n  const expectedColorUI = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: oldColorRange.colors\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: true\n      }\n    }\n  };\n  t.deepEqual(nextState.layers[0].config.colorUI, expectedColorUI, 'should update colorUI.customPalette with current colorRange colors');\n  const nextState2 = reducer(prepareState, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    customPalette: {\n      colors: ['aaa', 'bbb', 'ccc']\n    }\n  }));\n  const expectedColorUI2 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      ...DEFAULT_COLOR_UI,\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: ['aaa', 'bbb', 'ccc']\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: true\n      }\n    }\n  };\n  t.deepEqual(nextState2.layers[0].config.colorUI, expectedColorUI2, 'should update colorUI.customPalette colors');\n\n  // show sketcher\n  const nextState3 = reducer(nextState2, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    showSketcher: 1\n  }));\n  const expectedColorUI3 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      showSketcher: 1,\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: ['aaa', 'bbb', 'ccc']\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: true\n      }\n    }\n  };\n  t.deepEqual(nextState3.layers[0].config.colorUI, expectedColorUI3, 'should set showSketcher: 1');\n\n  // edit color\n  const nextState4 = reducer(nextState3, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    customPalette: {\n      colors: ['bbb', 'ccc', 'aaa']\n    }\n  }));\n  const expectedColorUI4 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      showSketcher: 1,\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: ['bbb', 'ccc', 'aaa']\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: true\n      }\n    }\n  };\n  t.deepEqual(nextState4.layers[0].config.colorUI, expectedColorUI4, 'should update colorUI.customPalette colors');\n\n  // apply color\n  const nextState5 = reducer(nextState4, VisStateActions.layerVisConfigChange(nextState4.layers[0], {\n    colorRange: {\n      name: 'Custom Palette',\n      type: 'custom',\n      category: 'Custom',\n      colors: ['bbb', 'ccc', 'aaa']\n    }\n  }));\n\n  // close custom palette\n  const nextState6 = reducer(nextState5, VisStateActions.layerColorUIChange(nextState5.layers[0], 'colorRange', {\n    colorRangeConfig: {\n      custom: false\n    }\n  }));\n  const expectedColorUI6 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      showSketcher: 1,\n      // keep the customPalette\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: ['bbb', 'ccc', 'aaa']\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: false\n      }\n    }\n  };\n  t.deepEqual(nextState6.layers[0].config.colorUI, expectedColorUI6, 'should set colorRangeConfig.custom false');\n  t.deepEqual(nextState6.layers[0].config.visConfig.colorRange, {\n    name: 'Custom Palette',\n    type: 'custom',\n    category: 'Custom',\n    colors: ['bbb', 'ccc', 'aaa']\n  }, 'should set visConfig.colorRange');\n\n  // open it again\n  const nextState7 = reducer(nextState6, VisStateActions.layerColorUIChange(pointLayer, 'colorRange', {\n    colorRangeConfig: {\n      custom: true\n    }\n  }));\n  const expectedColorUI7 = {\n    color: DEFAULT_COLOR_UI,\n    colorRange: {\n      showSketcher: 1,\n      // keep the customPalette\n      customPalette: {\n        name: 'Custom Palette',\n        type: 'custom',\n        category: 'Custom',\n        colors: ['bbb', 'ccc', 'aaa']\n      },\n      showDropdown: 0,\n      colorRangeConfig: {\n        type: 'all',\n        steps: 4,\n        reversed: false,\n        custom: true\n      }\n    }\n  };\n  t.deepEqual(nextState7.layers[0].config.colorUI, expectedColorUI7, 'should set colorRangeConfig.custom true');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setFeatures/delete","suites":[],"updatePoint":{"line":3311,"column":44,"index":100610},"line":3311,"code":"test('#visStateReducer -> setFeatures/delete', t => {\n  const expectedFeatures = [mockPolygonFeature];\n  let newReducer = reducer(INITIAL_VIS_STATE, VisStateActions.setFeatures([mockPolygonFeature]));\n  t.deepEqual(newReducer.editor.features, expectedFeatures, 'should add new feature');\n  newReducer = reducer(newReducer, VisStateActions.deleteFeature(mockPolygonFeature));\n  t.deepEqual(newReducer.editor.features, [], 'Should not have features');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> POLYGON: Add/Remove new polygon feature","suites":[],"updatePoint":{"line":3319,"column":65,"index":101096},"line":3319,"code":"test('#visStateReducer -> POLYGON: Add/Remove new polygon feature', t => {\n  const expectedFeatures = [mockPolygonFeature];\n  let newReducer = reducer(INITIAL_VIS_STATE, VisStateActions.setFeatures([mockPolygonFeature]));\n  t.deepEqual(newReducer.editor.features, expectedFeatures, 'should add new feature');\n  newReducer = reducer(newReducer, VisStateActions.setSelectedFeature(mockPolygonFeature));\n  const updatedFeature = {\n    ...mockPolygonFeature,\n    geometry: {\n      ...mockPolygonFeature.geometry,\n      coordinates: [[[12.0, 30.0], [12.0, 36.0], [12.5, 36.0], [12.0, 30.0]]]\n    }\n  };\n  newReducer = reducer(newReducer, VisStateActions.setFeatures([updatedFeature]));\n  t.deepEqual(newReducer.editor.selectedFeature.id, mockPolygonFeature.id, 'should set selected feature');\n  newReducer = reducer(newReducer, VisStateActions.deleteFeature(mockPolygonFeature));\n  t.deepEqual(newReducer.editor, {\n    features: [],\n    selectedFeature: null,\n    selectionContext: undefined,\n    visible: true,\n    mode: 'EDIT_VERTEX'\n  }, 'Should remove existing feature and set selected feature to null');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> POLYGON: Create polygon filter","suites":[],"updatePoint":{"line":3343,"column":56,"index":102206},"line":3343,"code":"test('#visStateReducer -> POLYGON: Create polygon filter', t => {\n  const state = {\n    ...INITIAL_VIS_STATE\n  };\n  const datasets = [{\n    data: {\n      fields: [{\n        name: 'start_point_lat',\n        format: '',\n        fieldIdx: 0,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'start_point_lng',\n        format: '',\n        fieldIdx: 1,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lat',\n        format: '',\n        fieldIdx: 2,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lng',\n        format: '',\n        fieldIdx: 3,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }],\n      rows: mockPolygonData.data\n    },\n    info: {\n      label: 'test.csv',\n      size: 144\n    }\n  }];\n  const options = {\n    centerMap: true,\n    keepExistingConfig: false\n  };\n\n  // visStateUpdateVisDataUpdater - creates 4 layers\n  let newReducer = reducer(state, VisStateActions.updateVisData(datasets, options, {}));\n\n  // add new polygon feature\n  newReducer = reducer(newReducer, VisStateActions.setFeatures([mockPolygonFeature]));\n\n  // set selected feature\n  newReducer = reducer(newReducer, VisStateActions.setSelectedFeature(mockPolygonFeature));\n\n  // set it as filter\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[0], mockPolygonFeature));\n  const newFilter = newReducer.filters[0];\n  const firstDataset = Object.keys(newReducer.datasets)[0];\n  const expectedFilter = {\n    id: newFilter.id,\n    dataId: [firstDataset],\n    freeze: false,\n    enabled: true,\n    fixedDomain: true,\n    view: FILTER_VIEW_TYPES.side,\n    isAnimating: false,\n    animationWindow: 'free',\n    speed: 1,\n    name: [],\n    type: 'polygon',\n    fieldIdx: [],\n    domain: null,\n    value: {\n      ...mockPolygonFeature,\n      properties: {\n        ...mockPolygonFeature.properties,\n        isVisible: true,\n        filterId: newFilter.id\n      }\n    },\n    plotType: 'histogram',\n    yAxis: null,\n    interval: null,\n    layerId: [newReducer.layers[0].id],\n    gpu: false\n  };\n  t.deepEqual(newFilter, expectedFilter, 'Should have created a polygon filter');\n  t.equal(newReducer.layerData[0].data.length, 2, 'Layer Point 1 should only show 2 points');\n  t.equal(newReducer.layerData[1].data.length, 2, 'Layer Point 2 should only show 2 points');\n  const filterFeature = newReducer.filters[0].value;\n\n  // set polygon filter for the second layer\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[1], filterFeature));\n  t.equal(newReducer.filters.length, 1, 'Should still have 1 polygon filter');\n  t.equal(newReducer.filters[0].layerId.length, 2, 'Should have two values in filter.layerId');\n  t.equal(newReducer.layerData[0].data.length, 0, 'Layer Point 1 should show 0 points');\n  t.equal(newReducer.layerData[1].data.length, 0, 'Layer Point 2 show show 0 points');\n\n  // Adding a new dataset - creates extra 4 layers\n  newReducer = reducer(newReducer, VisStateActions.updateVisData(datasets, options, {}));\n  t.equal(newReducer.layerData[4].data.length, 4, 'Layer Point 5 should full data');\n\n  // Set polygon for a different dataset layer\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[4], filterFeature));\n  t.equal(newReducer.filters[0].layerId.length, 3, 'Should 3 values in filter.layerId');\n  t.equal(newReducer.filters[0].dataId.length, 2, 'Should have two values in filter.dataId');\n  t.equal(newReducer.layerData[4].data.length, 2, 'Layer Point 5 should 2 points because filtered');\n\n  // Remove second layer from filter\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[1], filterFeature));\n  t.equal(newReducer.filters[0].layerId.length, 2, 'Should 3 values in filter.layerId');\n  t.equal(newReducer.filters[0].dataId.length, 2, 'Should have two values in filter.dataId');\n  t.equal(newReducer.layerData[0].data.length, 2, 'Layer Point 1 show 2 points because we removed layer 2');\n  t.equal(newReducer.layerData[4].data.length, 2, 'Layer Point 5 should 2 points because filtered');\n  t.equal(newReducer.layerData[2].data.length, 2, 'Layer Point 2 should still show 2 filters because layer 1 is still filtered');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> POLYGON: Toggle filter feature","suites":[],"updatePoint":{"line":3458,"column":56,"index":106517},"line":3458,"code":"test('#visStateReducer -> POLYGON: Toggle filter feature', t => {\n  const state = {\n    ...INITIAL_VIS_STATE\n  };\n  const datasets = [{\n    data: {\n      fields: [{\n        name: 'start_point_lat',\n        format: '',\n        fieldIdx: 0,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'start_point_lng',\n        format: '',\n        fieldIdx: 1,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lat',\n        format: '',\n        fieldIdx: 2,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lng',\n        format: '',\n        fieldIdx: 3,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }],\n      rows: mockPolygonData.data\n    },\n    info: {\n      label: 'test.csv',\n      size: 144,\n      id: 'puppy'\n    }\n  }, {\n    data: {\n      fields: [{\n        name: 'start_point_lat',\n        format: '',\n        fieldIdx: 0,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'start_point_lng',\n        format: '',\n        fieldIdx: 1,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lat',\n        format: '',\n        fieldIdx: 2,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lng',\n        format: '',\n        fieldIdx: 3,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }],\n      rows: mockPolygonData.data\n    },\n    info: {\n      label: 'test.csv',\n      size: 144,\n      id: 'cat'\n    }\n  }];\n  const options = {\n    centerMap: true,\n    keepExistingConfig: false\n  };\n\n  // visStateUpdateVisDataUpdater - creates 4 layers\n  let newReducer = reducer(state, VisStateActions.updateVisData(datasets, options, {}));\n  newReducer = reducer(newReducer, VisStateActions.addLayer());\n  t.equal(newReducer.layers.length, 9, 'Should have created a new layer');\n\n  // add new polygon feature\n  newReducer = reducer(newReducer, VisStateActions.setFeatures([mockPolygonFeature]));\n\n  // set selected feature\n  newReducer = reducer(newReducer, VisStateActions.setSelectedFeature(mockPolygonFeature));\n\n  // set it as filter\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[0], mockPolygonFeature));\n  const newFilter = newReducer.filters[0];\n  const expectedFilter = {\n    id: newFilter.id,\n    dataId: ['puppy'],\n    freeze: false,\n    enabled: true,\n    fixedDomain: true,\n    view: FILTER_VIEW_TYPES.side,\n    isAnimating: false,\n    animationWindow: 'free',\n    speed: 1,\n    name: [],\n    type: 'polygon',\n    fieldIdx: [],\n    domain: null,\n    value: {\n      ...mockPolygonFeature,\n      properties: {\n        ...mockPolygonFeature.properties,\n        isVisible: true,\n        filterId: newFilter.id\n      }\n    },\n    plotType: 'histogram',\n    yAxis: null,\n    interval: null,\n    layerId: [newReducer.layers[0].id],\n    gpu: false\n  };\n  t.deepEqual(newFilter, expectedFilter, 'Should have created a polygon filter');\n  let filterFeature = newReducer.filters[0].value;\n  t.deepEqual(filterFeature.properties.isVisible, true, 'Should have feature visibility set to true');\n  t.deepEqual(newReducer.datasets.puppy.filteredIndex, [0, 2], 'The polygon filter should be applied');\n  newReducer = reducer(newReducer, VisStateActions.toggleFilterFeature(0));\n  filterFeature = newReducer.filters[0].value;\n  t.deepEqual(filterFeature.properties.isVisible, false, 'Should hide filter feature');\n  t.deepEqual(newReducer.filters[0].enabled, false, 'Should disable the filter');\n  t.deepEqual(newReducer.datasets.puppy.filteredIndex, [0, 1, 2, 3], \"The polygon filter shouldn't be applied\");\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> POLYGON: delete polygon filter","suites":[],"updatePoint":{"line":3589,"column":56,"index":110186},"line":3589,"code":"test('#visStateReducer -> POLYGON: delete polygon filter', t => {\n  const state = {\n    ...INITIAL_VIS_STATE\n  };\n  const datasets = [{\n    data: {\n      fields: [{\n        name: 'start_point_lat',\n        format: '',\n        fieldIdx: 0,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'start_point_lng',\n        format: '',\n        fieldIdx: 1,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lat',\n        format: '',\n        fieldIdx: 2,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lng',\n        format: '',\n        fieldIdx: 3,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }],\n      rows: mockPolygonData.data\n    },\n    info: {\n      label: 'test.csv',\n      size: 144,\n      id: 'puppy'\n    }\n  }, {\n    data: {\n      fields: [{\n        name: 'start_point_lat',\n        format: '',\n        fieldIdx: 0,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'start_point_lng',\n        format: '',\n        fieldIdx: 1,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lat',\n        format: '',\n        fieldIdx: 2,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }, {\n        name: 'end_point_lng',\n        format: '',\n        fieldIdx: 3,\n        type: 'real',\n        analyzerType: 'FLOAT'\n      }],\n      rows: mockPolygonData.data\n    },\n    info: {\n      label: 'test.csv',\n      size: 144,\n      id: 'cat'\n    }\n  }];\n  const options = {\n    centerMap: true,\n    keepExistingConfig: false\n  };\n\n  // visStateUpdateVisDataUpdater - creates 4 layers\n  let newReducer = reducer(state, VisStateActions.updateVisData(datasets, options, {}));\n  newReducer = reducer(newReducer, VisStateActions.addLayer());\n  t.equal(newReducer.layers.length, 9, 'Should have created a new layer');\n\n  // add new polygon feature\n  newReducer = reducer(newReducer, VisStateActions.setFeatures([mockPolygonFeature]));\n\n  // set selected feature\n  newReducer = reducer(newReducer, VisStateActions.setSelectedFeature(mockPolygonFeature));\n\n  // set it as filter\n  newReducer = reducer(newReducer, VisStateActions.setPolygonFilterLayer(newReducer.layers[0], mockPolygonFeature));\n\n  // Update filters using setFilter\n  newReducer = reducer(newReducer, VisStateActions.setFilter(0, 'layerId', []));\n  t.deepEqual(newReducer.filters[0].layerId, [], 'Should have removed layers from filter');\n  t.deepEqual(newReducer.filters[0].dataId, [], 'Should have removed datasets from filter');\n\n  // unset it as filter\n  newReducer = reducer(newReducer, VisStateActions.removeFilter(0));\n  t.deepEqual(newReducer.filters, [], 'Should have removed the created polygon filter');\n\n  // deleting the filter will also delete the feature\n  t.deepEqual(newReducer.editor.features.length, 0, 'Should have removed the feature');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> POLYGON: setPolygonFilterLayer: H3","suites":[],"updatePoint":{"line":3694,"column":60,"index":113095},"line":3694,"code":"test('#visStateReducer -> POLYGON: setPolygonFilterLayer: H3', t => {\n  const initialState = CloneDeep(StateWH3Layer).visState;\n  const newState = reducer(initialState, VisStateActions.setPolygonFilterLayer(initialState.layers[0], mockPolygonFeature2));\n  const expectedFilteredIndex = [1, 3, 5, 8];\n  t.deepEqual(newState.datasets['190vdll3di'].filteredIndex, expectedFilteredIndex, 'should filter data based on h3 layer');\n  t.deepEqual(newState.layerData[0].data.map(d => d.index), [1, 3, 5, 8], 'should filter layer data');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_EDITOR_MODE","suites":[],"updatePoint":{"line":3702,"column":40,"index":113618},"line":3702,"code":"test('#uiStateReducer -> SET_EDITOR_MODE', t => {\n  const newState = reducer(INITIAL_VIS_STATE, VisStateActions.setEditorMode(EDITOR_MODES.EDIT));\n  t.equal(newState.editor.mode, EDITOR_MODES.EDIT, 'Editor mode should be set to vertex');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> TOGGLE_EDITOR_VISIBILITY","suites":[],"updatePoint":{"line":3707,"column":49,"index":113880},"line":3707,"code":"test('#uiStateReducer -> TOGGLE_EDITOR_VISIBILITY', t => {\n  let newState = reducer(INITIAL_VIS_STATE, VisStateActions.toggleEditorVisibility());\n  t.equal(newState.editor.visible, false, 'Should set editor visibility to false');\n  newState = reducer(newState, VisStateActions.toggleEditorVisibility());\n  t.equal(newState.editor.visible, true, 'Should set editor visibility to true');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> APPLY_CPU_FILTER. no filter","suites":[],"updatePoint":{"line":3714,"column":53,"index":114285},"line":3714,"code":"test('#visStateReducer -> APPLY_CPU_FILTER. no filter', t => {\n  const initialState = CloneDeep(StateWFiles.visState);\n  const dataId = testCsvDataId;\n  const previousDataset = initialState.datasets[dataId];\n  const nextState = reducer(initialState, VisStateActions.applyCPUFilter(dataId));\n  const expectedDataset = {\n    ...previousDataset,\n    filteredIdxCPU: previousDataset.allIndexes,\n    filterRecordCPU: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    }\n  };\n  cmpDataset(t, expectedDataset, nextState.datasets[dataId]);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> APPLY_CPU_FILTER has gpu filter","suites":[],"updatePoint":{"line":3732,"column":57,"index":114868},"line":3732,"code":"test('#visStateReducer -> APPLY_CPU_FILTER has gpu filter', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  // dataset has gpu filter\n  const dataId = testCsvDataId;\n  const previousDataset = initialState.datasets[dataId];\n  const gpuFilter = initialState.filters[0];\n  const nextState = reducer(initialState, VisStateActions.applyCPUFilter(dataId));\n  const expectedDataset = {\n    ...previousDataset,\n    filteredIdxCPU: [5, 6, 9, 10, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23],\n    filterRecordCPU: {\n      dynamicDomain: [],\n      fixedDomain: [gpuFilter],\n      cpu: [gpuFilter],\n      gpu: []\n    }\n  };\n  cmpDataset(t, expectedDataset, nextState.datasets[dataId]);\n\n  // calling it again\n  const nextState2 = reducer(nextState, VisStateActions.applyCPUFilter(dataId));\n  t.equal(nextState.datasets[dataId].filteredIdxCPU, nextState2.datasets[dataId].filteredIdxCPU, 'should directly copy filter result when filter has not changed');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> APPLY_CPU_FILTER has cpu filter","suites":[],"updatePoint":{"line":3756,"column":57,"index":115839},"line":3756,"code":"test('#visStateReducer -> APPLY_CPU_FILTER has cpu filter', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  // dataset has gpu filter\n  const dataId = testGeoJsonDataId;\n  const previousDataset2 = initialState.datasets[dataId];\n  const ordinalFilter = initialState.filters[1];\n  const nextState = reducer(initialState, VisStateActions.applyCPUFilter(dataId));\n  const expectedDataset = {\n    ...previousDataset2,\n    filteredIdxCPU: [0],\n    filterRecordCPU: {\n      dynamicDomain: [],\n      fixedDomain: [ordinalFilter],\n      cpu: [ordinalFilter],\n      gpu: []\n    }\n  };\n  cmpDataset(t, expectedDataset, nextState.datasets[dataId]);\n  const nextState2 = reducer(nextState, VisStateActions.applyCPUFilter(dataId));\n  t.equal(nextState.datasets[dataId].filteredIdxCPU, nextState2.datasets[dataId].filteredIdxCPU, 'should directly copy filter result when filter has not changed');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#uiStateReducer -> SET_FEATURES/SET_SELECTED_FEATURE/DELETE_FEATURE","suites":[],"updatePoint":{"line":3778,"column":73,"index":116771},"line":3778,"code":"test('#uiStateReducer -> SET_FEATURES/SET_SELECTED_FEATURE/DELETE_FEATURE', t => {\n  let newState = reducer(INITIAL_VIS_STATE, VisStateActions.setFeatures([]));\n  t.deepEqual(newState, INITIAL_VIS_STATE, 'Editor should not have features and return the same state');\n  newState = reducer(INITIAL_VIS_STATE, VisStateActions.setFeatures([{\n    ...mockPolygonFeature,\n    properties: {\n      ...mockPolygonFeature.properties,\n      isClosed: false\n    }\n  }]));\n  t.equal(newState.editor.mode, INITIAL_VIS_STATE.editor.mode, 'Editor mode should not change because feature is not closed');\n  newState = reducer(newState, VisStateActions.setFeatures([{\n    ...mockPolygonFeature,\n    properties: {\n      ...mockPolygonFeature.properties,\n      isClosed: false\n    }\n  }, mockPolygonFeature]));\n  t.equal(newState.editor.mode, EDITOR_MODES.EDIT, 'Editor mode should be set to edit_vertex');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> APPLY_CPU_FILTER has multi datasets","suites":[],"updatePoint":{"line":3799,"column":61,"index":117658},"line":3799,"code":"test('#visStateReducer -> APPLY_CPU_FILTER has multi datasets', t => {\n  const initialState = CloneDeep(StateWFilters.visState);\n  const previousDataset1 = initialState.datasets[testCsvDataId];\n  const previousDataset2 = initialState.datasets[testGeoJsonDataId];\n  const gpuFilter = initialState.filters[0];\n  const ordinalFilter = initialState.filters[1];\n  const nextState = reducer(initialState, VisStateActions.applyCPUFilter([testCsvDataId, testGeoJsonDataId]));\n  const expectedDataset1 = {\n    ...previousDataset1,\n    filteredIdxCPU: [5, 6, 9, 10, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23],\n    filterRecordCPU: {\n      dynamicDomain: [],\n      fixedDomain: [gpuFilter],\n      cpu: [gpuFilter],\n      gpu: []\n    }\n  };\n  const expectedDataset2 = {\n    ...previousDataset2,\n    filteredIdxCPU: [0],\n    filterRecordCPU: {\n      dynamicDomain: [],\n      fixedDomain: [ordinalFilter],\n      cpu: [ordinalFilter],\n      gpu: []\n    }\n  };\n  const expectedDatasets = {\n    [testCsvDataId]: expectedDataset1,\n    [testGeoJsonDataId]: expectedDataset2\n  };\n  cmpDatasets(t, expectedDatasets, nextState.datasets);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> SORT_TABLE_COLUMN","suites":[],"updatePoint":{"line":3833,"column":43,"index":118768},"line":3833,"code":"test('#visStateReducer -> SORT_TABLE_COLUMN', t => {\n  const initialState = CloneDeep(StateWFiles.visState);\n\n  // sort with default mode\n  const nextState = reducer(initialState, VisStateActions.sortTableColumn());\n  t.equal(nextState, initialState, 'state should not change when input is given');\n\n  // sort with\n  const nextState2 = reducer(initialState, VisStateActions.sortTableColumn(testCsvDataId, 'gps_data.lat'));\n  t.ok(nextState2.datasets[testCsvDataId].sortOrder, 'should create sortOrder');\n  const expectedOrder = [3, 0, 2, 4, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 19, 18, 23, 22, 21];\n  t.deepEqual(nextState2.datasets[testCsvDataId].sortOrder, expectedOrder, 'should sort correctly');\n  t.deepEqual(nextState2.datasets[testCsvDataId].sortColumn, {\n    'gps_data.lat': 'ASCENDING'\n  }, 'should save sortOrder');\n\n  // sort again\n  const nextState3 = reducer(nextState2, VisStateActions.sortTableColumn(testCsvDataId, 'gps_data.lat'));\n  const expectedOrder3 = [...expectedOrder].reverse();\n  t.deepEqual(nextState3.datasets[testCsvDataId].sortOrder, expectedOrder3, 'should sort correctly');\n  t.deepEqual(nextState3.datasets[testCsvDataId].sortColumn, {\n    'gps_data.lat': 'DESCENDING'\n  }, 'should correctly sort');\n\n  // unsort\n  const nextState4 = reducer(nextState3, VisStateActions.sortTableColumn(testCsvDataId, 'gps_data.lat', 'UNSORT'));\n  t.deepEqual(nextState4.datasets[testCsvDataId].sortOrder, null, 'should reset sortOrder');\n  t.deepEqual(nextState4.datasets[testCsvDataId].sortColumn, {}, 'should reset sortColumn');\n\n  // sort with mode\n  const nextState5 = reducer(nextState4, VisStateActions.sortTableColumn(testCsvDataId, 'gps_data.lat', 'DESCENDING'));\n  t.deepEqual(nextState5.datasets[testCsvDataId].sortOrder, expectedOrder3, 'should sort correctly');\n  t.deepEqual(nextState5.datasets[testCsvDataId].sortColumn, {\n    'gps_data.lat': 'DESCENDING'\n  }, 'should correctly sort');\n  assertDatasetIsTable(t, nextState5.datasets[testCsvDataId]);\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> PIN_TABLE_COLUMN","suites":[],"updatePoint":{"line":3871,"column":42,"index":120780},"line":3871,"code":"test('#visStateReducer -> PIN_TABLE_COLUMN', t => {\n  const initialState = CloneDeep(StateWFiles.visState);\n\n  // pin with empty arg\n  const nextState = reducer(initialState, VisStateActions.pinTableColumn());\n  t.equal(nextState, initialState, 'state should not change when input is not given');\n\n  // pin gps_data.lat\n  const nextState1 = reducer(nextState, VisStateActions.pinTableColumn(testCsvDataId, 'gps_data.lat'));\n  assertDatasetIsTable(t, nextState1.datasets[testCsvDataId]);\n  t.deepEqual(nextState1.datasets[testCsvDataId].pinnedColumns, ['gps_data.lat'], 'should add to pinned columns');\n\n  // unpin\n  const nextState2 = reducer(nextState1, VisStateActions.pinTableColumn(testCsvDataId, 'gps_data.lat'));\n  assertDatasetIsTable(t, nextState2.datasets[testCsvDataId]);\n  t.deepEqual(nextState2.datasets[testCsvDataId].pinnedColumns, [], 'should remove from pinned columns');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> LOAD_FILES","suites":[],"updatePoint":{"line":3889,"column":36,"index":121677},"line":3889,"code":"test('#visStateReducer -> LOAD_FILES', async t => {\n  const loadFilesSuccessSpy = sinon.spy(VisStateActions, 'loadFilesSuccess');\n  const loadFileErrSpy = sinon.spy(Console, 'warn');\n  const initialState = CloneDeep(InitialState).visState;\n  const mockResults = {\n    data: [{\n      value1: 'a',\n      value2: 1\n    }, {\n      value1: 'b',\n      value2: 2\n    }]\n  };\n  const mockFiles = [{\n    type: 'text/csv',\n    name: 'test-file.csv'\n  }, {\n    type: 'text/csv',\n    name: 'test-file-2.csv'\n  }];\n  // mock async generator\n  async function* run(fileName) {\n    // Sleep for 100ms, see: https://masteringjs.io/tutorials/fundamentals/sleep\n    let percent = 0;\n    await new Promise(resolve => setTimeout(resolve, 100));\n    while (percent < 1) {\n      percent += 1;\n      yield {\n        progress: {\n          percent\n        },\n        fileName,\n        ...mockResults\n      };\n    }\n  }\n  const nextState = reducer(initialState, VisStateActions.loadFiles(mockFiles));\n  const [task1, ...more] = drainTasksForTesting();\n  t.equal(more.length, 0, 'should ceate 1 task');\n  const expectedTask1 = {\n    type: 'LOAD_FILE_TASK',\n    payload: {\n      file: {\n        type: 'text/csv',\n        name: 'test-file.csv'\n      },\n      fileCache: [],\n      loaders: [],\n      loadOptions: {}\n    }\n  };\n  t.comment(JSON.stringify(task1));\n  t.equal(task1.type, expectedTask1.type, 'should create LOAD_FILE_TASK task');\n  t.deepEqual(task1.payload, expectedTask1.payload, 'should create LOAD_FILE_TASK correct payload');\n  const expectedFileLoading = {\n    fileCache: [],\n    filesToLoad: [{\n      type: 'text/csv',\n      name: 'test-file-2.csv'\n    }],\n    onFinish: VisStateActions.loadFilesSuccess\n  };\n  const expectedFileLoadingProgress = {\n    'test-file.csv': {\n      percent: 0,\n      message: 'loading...',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: '',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(nextState.fileLoading, expectedFileLoading, 'should save fileLoading in state');\n  t.deepEqual(nextState.fileLoadingProgress, expectedFileLoadingProgress, 'should save fileLoadingProgress in state');\n  const asyncIterator = run('test-file.csv');\n\n  // test nextFileBatchUpdater\n  const nextState2 = reducer(nextState, succeedTaskInTest(task1, asyncIterator));\n  // test LOAD_FILE_TASK success\n  const [task2, ...more2] = drainTasksForTesting();\n  t.equal(more2.length, 0, 'should ceate 1 task');\n  t.equal(task2.type, 'UNWRAP', 'should return an UNWRAP task');\n  t.ok(task2.payload instanceof Promise, 'task 2 payload should be a Promise');\n  t.equal(nextState2.fileLoading, nextState.fileLoading, 'fileLoading should not change for the first batch');\n  t.deepEqual(nextState2.fileLoadingProgress, nextState.fileLoadingProgress, 'fileLoadingProgress should not change for the first batch');\n\n  // test LOAD_FILE_TASK error\n  const err1 = {\n    message: 'error 1'\n  };\n  const nextState2Err = reducer(nextState, errorTaskInTest(task1, err1));\n  const [task2Err, ...more2err] = drainTasksForTesting();\n  t.equal(more2err.length, 0, 'should ceate 1 task');\n  const expectedErrProgress = {\n    'test-file.csv': {\n      percent: 0,\n      message: 'loading...',\n      fileName: 'test-file.csv',\n      error: err1\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: '',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(nextState2Err.fileLoadingProgress, expectedErrProgress, 'should save error to fileLoadingProgress');\n  loadFileErrSpy.calledWith(err1);\n  t.equal(task2Err.type, 'DELAY_TASK', 'should create a DELAY_TASK task when loadFileErr is triggered');\n  const nextState3Err = reducer(nextState2Err, succeedTaskInTest(task2Err));\n  const [task3Err, ...more3err] = drainTasksForTesting();\n  t.equal(more3err.length, 0, 'should ceate 1 task');\n  t.equal(task3Err.type, 'LOAD_FILE_TASK', 'should return an LOAD_FILE_TASK');\n  t.deepEqual(task3Err.payload, {\n    file: {\n      type: 'text/csv',\n      name: 'test-file-2.csv'\n    },\n    fileCache: [],\n    loaders: [],\n    loadOptions: {}\n  }, 'should return an LOAD_FILE_TASK with 2nd file to load');\n  const expectedErrFileLoadingProgress = {\n    'test-file.csv': {\n      percent: 0,\n      message: 'loading...',\n      fileName: 'test-file.csv',\n      error: err1\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: 'loading...',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(nextState3Err.fileLoadingProgress, expectedErrFileLoadingProgress, 'fileLoadingProgress should update whe calling loadNextfileUpdater');\n  t.deepEqual(nextState3Err.fileLoading, {\n    fileCache: [],\n    filesToLoad: [],\n    onFinish: VisStateActions.loadFilesSuccess\n  }, 'fileLoading should not add result to fileCache when error');\n\n  // UNWRAP Task success\n  const unwrapSuccess = await task2.payload;\n  const resultState3 = reducer(nextState2, succeedTaskInTest(task2, unwrapSuccess));\n\n  // should return another unwrap task\n  const [task3, ...more3] = drainTasksForTesting();\n  t.equal(more3.length, 0, 'should ceate 1 task');\n  t.equal(task3.type, 'UNWRAP', 'should return an UNWRAP task');\n  t.ok(task3.payload instanceof Promise, 'task 3 payload should be a Promise');\n  const expectedFileLoadingProgress3 = {\n    'test-file.csv': {\n      percent: 1,\n      message: 'loading...',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: '',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.equal(resultState3.fileLoading, nextState2.fileLoading, 'fileLoading should not change when loadingis not finished');\n  t.deepEqual(resultState3.fileLoadingProgress, expectedFileLoadingProgress3, 'fileLoadingProgress should update with percent');\n\n  // calling UNWRAP_TASK sucess to create File Process task\n  const unwrapSuccess3 = await task3.payload;\n  const resultState4 = reducer(resultState3, succeedTaskInTest(task3, unwrapSuccess3));\n  const [task4, ...more4] = drainTasksForTesting();\n  const expectedFileLoadingProgress4 = {\n    'test-file.csv': {\n      percent: 1,\n      message: 'processing...',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: '',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.equal(resultState3.fileLoading, resultState4.fileLoading, 'fileLoading should be the same');\n  t.deepEqual(resultState4.fileLoadingProgress, expectedFileLoadingProgress4, 'fileLoadingProgress should update to reflect processing');\n  t.equal(more4.length, 0, 'should ceate 1 task');\n  const expectedpayload = {\n    content: {\n      progress: {\n        percent: 1\n      },\n      fileName: 'test-file.csv',\n      ...mockResults\n    },\n    fileCache: []\n  };\n  t.equal(task4.type, 'PROCESS_FILE_CONTENT', 'should return an PROCESS_FILE_CONTENT task');\n  t.deepEqual(task4.payload, expectedpayload, 'PROCESS_FILE_CONTENT task payload should be correct');\n  const fileProcessResult = [{\n    data: [],\n    info: {\n      label: 'test_data.csv',\n      format: 'csv'\n    }\n  }];\n\n  // calling loadFileStepSuccess with file process result\n  const resultState5 = reducer(resultState4, succeedTaskInTest(task4, fileProcessResult));\n  const expectedFileLoadingProgress5 = {\n    'test-file.csv': {\n      percent: 1,\n      message: 'Done',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: '',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(resultState5.fileLoadingProgress, expectedFileLoadingProgress5, 'fileLoadingProgress should update to show finish');\n  t.deepEqual(resultState5.fileLoading, {\n    fileCache: fileProcessResult,\n    filesToLoad: [{\n      type: 'text/csv',\n      name: 'test-file-2.csv'\n    }],\n    onFinish: VisStateActions.loadFilesSuccess\n  }, 'fileLoading should update to add result to fileCache 1');\n  const [task5, ...more5] = drainTasksForTesting();\n  t.equal(more5.length, 0, 'should ceate 1 task');\n  t.equal(task5.type, 'DELAY_TASK', 'should return an DELAY_TASK');\n\n  // calling delayed task succeed to trigger load next file\n  const resultState6 = reducer(resultState5, succeedTaskInTest(task5));\n  const [task6, ...more6] = drainTasksForTesting();\n  t.equal(more6.length, 0, 'should ceate 1 task');\n  t.equal(task6.type, 'LOAD_FILE_TASK', 'should return an LOAD_FILE_TASK');\n  t.deepEqual(task6.payload, {\n    file: {\n      type: 'text/csv',\n      name: 'test-file-2.csv'\n    },\n    fileCache: fileProcessResult,\n    loaders: [],\n    loadOptions: {}\n  }, 'should return an LOAD_FILE_TASK with 2nd file to load 2');\n  const expectedFileLoadingProgress6 = {\n    'test-file.csv': {\n      percent: 1,\n      message: 'Done',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 0,\n      message: 'loading...',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(resultState6.fileLoadingProgress, expectedFileLoadingProgress6, 'fileLoadingProgress should update whe calling loadNextfileUpdater');\n  t.deepEqual(resultState6.fileLoading, {\n    fileCache: fileProcessResult,\n    filesToLoad: [],\n    onFinish: VisStateActions.loadFilesSuccess\n  }, 'fileLoading should update to add result to fileCache 3');\n  // fast forward so we can test final result\n  const asyncIterator2 = run('test-file-2.csv');\n  const resultState7 = reducer(resultState6, succeedTaskInTest(task6, asyncIterator2));\n  const [task7] = drainTasksForTesting();\n  const unwrapSuccess7 = await task7.payload;\n  const resultState8 = reducer(resultState7, succeedTaskInTest(task7, unwrapSuccess7));\n  const [task8] = drainTasksForTesting();\n  const unwrapSuccess8 = await task8.payload;\n  const resultState9 = reducer(resultState8, succeedTaskInTest(task8, unwrapSuccess8));\n  // process task\n  const [task9] = drainTasksForTesting();\n  const file2ProcessResult = [...fileProcessResult, {\n    data: [{\n      value: 1\n    }],\n    info: {\n      label: 'test_data_2.csv',\n      format: 'csv'\n    }\n  }];\n  const resultState10 = reducer(resultState9, succeedTaskInTest(task9, file2ProcessResult));\n  const expectedFileLoadingProgress10 = {\n    'test-file.csv': {\n      percent: 1,\n      message: 'Done',\n      fileName: 'test-file.csv',\n      error: null\n    },\n    'test-file-2.csv': {\n      percent: 1,\n      message: 'Done',\n      fileName: 'test-file-2.csv',\n      error: null\n    }\n  };\n  t.deepEqual(resultState10.fileLoadingProgress, expectedFileLoadingProgress10, 'fileLoadingProgress should update to show finish both files');\n  t.deepEqual(resultState10.fileLoading, {\n    fileCache: file2ProcessResult,\n    filesToLoad: [],\n    onFinish: VisStateActions.loadFilesSuccess\n  }, 'fileLoading should update to add 2nd file result to fileCache');\n  const [task10, ...more10] = drainTasksForTesting();\n  t.equal(more10.length, 0, 'should ceate 1 task');\n  t.equal(task10.type, 'DELAY_TASK', 'should return an DELAY_TASK for onFinish');\n\n  // calling delayed task succeed to trigger load next file\n  /* eslint-disable no-unused-vars */\n  const resultState11 = reducer(resultState10, succeedTaskInTest(task10));\n  t.ok(loadFilesSuccessSpy.calledOnce);\n  const expectedArgs = [{\n    data: [],\n    info: {\n      label: 'test_data.csv',\n      format: 'csv'\n    }\n  }, {\n    data: [{\n      value: 1\n    }],\n    info: {\n      label: 'test_data_2.csv',\n      format: 'csv'\n    }\n  }];\n  t.ok(loadFilesSuccessSpy.calledWith(expectedArgs));\n  loadFilesSuccessSpy.restore();\n  loadFileErrSpy.restore();\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setLayerAnimationTimeConfig","suites":[],"updatePoint":{"line":4236,"column":53,"index":133337},"line":4236,"code":"test('#visStateReducer -> setLayerAnimationTimeConfig', t => {\n  // change Trip layer isVisible\n  const nextState = reducer(StateWTripGeojson.visState, VisStateActions.setLayerAnimationTimeConfig({\n    timezone: 'America/New_York',\n    timeFormat: 'YYYY-MM-DD',\n    random: 1\n  }));\n  t.equal(nextState.animationConfig.timezone, 'America/New_York', 'should set animationConfig timezone');\n  t.equal(nextState.animationConfig.timeFormat, 'YYYY-MM-DD', 'should set animationConfig timeFormat');\n  t.equal(nextState.animationConfig.random, undefined, 'should not set unknown key');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#visStateReducer -> setFilterAnimationTimeConfig","suites":[],"updatePoint":{"line":4248,"column":54,"index":133932},"line":4248,"code":"test('#visStateReducer -> setFilterAnimationTimeConfig', t => {\n  // change Trip layer isVisible\n  const nextState = reducer(StateWFilters.visState, VisStateActions.setFilterAnimationTimeConfig(1, {\n    timezone: 'America/New_York'\n  }));\n  t.equal(nextState, StateWFilters.visState, 'should not change if is not time filter');\n  const nextState1 = reducer(StateWFilters.visState, VisStateActions.setFilterAnimationTimeConfig(0, {\n    timezone: 'America/New_York'\n  }));\n  t.equal(nextState1.filters[0].timezone, 'America/New_York', 'should set filter timeFormat');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"VisStateUpdater -> prepareStateForDatasetReplace","suites":[],"updatePoint":{"line":4260,"column":54,"index":134513},"line":4260,"code":"test('VisStateUpdater -> prepareStateForDatasetReplace', t => {\n  const oldTooltipConfigFields = StateWFilters.visState.interactionConfig.tooltip.config.fieldsToShow;\n  const dataIdToUse = 'taro_and_blue';\n  const nextState = prepareStateForDatasetReplace(StateWFilters.visState, testCsvDataId, dataIdToUse);\n\n  // layers\n  t.equal(nextState.layers.length, 1, 'should keep 1 layer');\n  t.equal(nextState.layers[0], StateWFilters.visState.layers[1], 'should keep 1 layer');\n  t.equal(nextState.layerToBeMerged.length, 1, 'should move 1 layer to layerToBeMerged');\n  t.equal(nextState.layerToBeMerged[0].id, StateWFilters.visState.layers[0].id, 'should move 1 layer to layerToBeMerged');\n  t.equal(nextState.layerToBeMerged[0].config.dataId, dataIdToUse, 'should replace layer dataId');\n\n  // filers\n  t.equal(nextState.filters.length, 1, 'should keep 1 filter');\n  t.equal(nextState.filters[0], StateWFilters.visState.filters[1], 'should keep 1 filter');\n  t.equal(nextState.filterToBeMerged.length, 1, 'should move 1 filter to filterToBeMerged');\n  t.equal(nextState.filterToBeMerged[0].id, StateWFilters.visState.filters[0].id, 'should move 1 filter to filterToBeMerged');\n  t.deepEqual(nextState.filterToBeMerged[0].dataId, [dataIdToUse], 'should replace filter dataId');\n\n  // preserveLayerOrder\n  t.deepEqual(nextState.layerOrder, ['geojson-1', 'point-0'], 'should not remove layer from layer order');\n  t.deepEqual(nextState.preserveLayerOrder, ['geojson-1', 'point-0'], 'should save preserved layer order');\n\n  // interactionConfig\n  t.deepEqual(nextState.interactionConfig.tooltip.config.fieldsToShow, {\n    [testGeoJsonDataId]: oldTooltipConfigFields[testGeoJsonDataId]\n  }, 'Should only keep geojson dataset tooltip');\n  t.deepEqual(nextState.interactionToBeMerged, {\n    tooltip: {\n      enabled: true,\n      fieldsToShow: {\n        [dataIdToUse]: oldTooltipConfigFields[testCsvDataId]\n      }\n    }\n  }, 'should move tooltip config to interactionToBeMerged');\n\n  // preserveDatasetOrder\n  t.deepEqual(nextState.preserveDatasetOrder, [dataIdToUse, testGeoJsonDataId], 'should save dataset id to preserveDatasetOrder');\n\n  // preserveFilterOrder\n  t.deepEqual(nextState.preserveFilterOrder, ['time-0', 'RATE-1'], 'should save filter id to preserveFilterOrder');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"VisStateUpdater -> addLayer with empty column","suites":[],"updatePoint":{"line":4303,"column":51,"index":136796},"line":4303,"code":"test('VisStateUpdater -> addLayer with empty column', t => {\n  const initialState = StateWFiles.visState;\n  const oldLayers = initialState.layers;\n  let nextState;\n  t.doesNotThrow(() => {\n    nextState = reducer(initialState, VisStateActions.addLayer({\n      type: 'point',\n      id: 'taro-xxx',\n      config: {\n        dataId: testCsvDataId\n        // no column\n      }\n    }));\n  }, 'should not throw error when add layer with empty column');\n  t.equal(nextState.layers.length, oldLayers.length + 1, 'should create 1 layer');\n  const newLayer = nextState.layers[nextState.layers.length - 1];\n  t.equal(newLayer.id, 'taro-xxx', 'newlayer should have correct id');\n  t.equal(newLayer.type, 'point', 'newlayer should have correct type');\n  t.deepEqual(newLayer.config.columns.lat, {\n    value: null,\n    fieldIdx: -1\n  }, 'newlayer column should be value: null');\n  t.deepEqual(nextState.layerData[nextState.layerData.length - 1], {}, 'newlayer layerData should be empty');\n  t.end();\n});","file":"node/reducers/vis-state-test.js","skipped":false,"dir":"test"},{"name":"#DatasetSchema -> SchemaManager.parseSavedData","suites":[],"updatePoint":{"line":31,"column":52,"index":1665},"line":31,"code":"test('#DatasetSchema -> SchemaManager.parseSavedData', t => {\n  const dataSaved = cloneDeep(savedStateV0).datasets;\n  const parsedValid = SchemaManager.parseSavedData(dataSaved);\n  const expectedRows0 = dataSaved[0].data.allData;\n  const expectedDataset0 = {\n    info: expectedInfo0,\n    data: {\n      fields: expectedFields0,\n      rows: expectedRows0\n    }\n  };\n  const expectedRows1 = dataSaved[1].data.allData;\n  const expectedDataset1 = {\n    info: expectedInfo1,\n    data: {\n      fields: expectedFields1,\n      rows: expectedRows1\n    }\n  };\n  t.equal(parsedValid.length, 2, 'should have 2 datasets');\n  t.deepEqual(parsedValid[0], expectedDataset0, 'should parse dataset correctly');\n  t.deepEqual(parsedValid[0].info, expectedInfo0, 'should parse info correctly');\n  t.deepEqual(parsedValid[0].data.fields, expectedFields0, 'should parse fields correctly');\n  t.deepEqual(parsedValid[0].data.rows, expectedRows0, 'should parse rows correctly');\n  t.deepEqual(parsedValid[1], expectedDataset1, 'should parse dataset correctly');\n  t.deepEqual(parsedValid[1].info, expectedInfo1, 'should parse info correctly');\n  t.deepEqual(parsedValid[1].data.fields, expectedFields1, 'should parse fields correctly');\n  t.deepEqual(parsedValid[1].data.rows, expectedRows1, 'should parse rows correctly');\n  t.end();\n});","file":"node/schemas/dataset-schema-test.js","skipped":false,"dir":"test"},{"name":"#DatasetSchema -> SchemaManager.parseSavedData.v1","suites":[],"updatePoint":{"line":63,"column":55,"index":3018},"line":63,"code":"test('#DatasetSchema -> SchemaManager.parseSavedData.v1', t => {\n  const dataSaved = cloneDeep(savedStateV1).datasets;\n  const parsedValid = SchemaManager.parseSavedData(dataSaved);\n  const expectedRows = dataSaved[0].data.allData;\n  const expectedDataset = {\n    info: v0ExpectedInfo,\n    data: {\n      fields: v0ExpectedFields,\n      rows: expectedRows\n    }\n  };\n  t.equal(parsedValid.length, 1, 'should have 1 dataset');\n  t.deepEqual(parsedValid[0], expectedDataset, 'should parse dataset correctly');\n  t.deepEqual(parsedValid[0].info, v0ExpectedInfo, 'should parse info correctly');\n  t.deepEqual(parsedValid[0].data.fields, v0ExpectedFields, 'should parse fields correctly');\n  t.deepEqual(parsedValid[0].data.rows, expectedRows, 'should parse rows correctly');\n  t.end();\n});","file":"node/schemas/dataset-schema-test.js","skipped":false,"dir":"test"},{"name":"#DatasetSchema -> SchemaManager.parseSavedData.v1 with ts","suites":[],"updatePoint":{"line":81,"column":63,"index":3811},"line":81,"code":"test('#DatasetSchema -> SchemaManager.parseSavedData.v1 with ts', t => {\n  const dataSaved = cloneDeep(stateSavedV1_2).datasets;\n  const parsedValid = SchemaManager.parseSavedData(dataSaved);\n  const expectedRows = dataSaved[0].data.allData;\n  const expectedDataset = {\n    info: v1expectedInfo_2,\n    data: {\n      fields: v1expectedFields_2,\n      rows: expectedRows\n    }\n  };\n  t.equal(parsedValid.length, 1, 'should have 1 dataset');\n  t.deepEqual(parsedValid[0], expectedDataset, 'should parse dataset correctly');\n  t.deepEqual(parsedValid[0].info, v1expectedInfo_2, 'should parse info correctly');\n  t.equal(parsedValid[0].data.fields.length, v1expectedFields_2.length, 'should have same number of fields');\n  parsedValid[0].data.fields.forEach((actualField, i) => {\n    t.deepEqual(actualField, v1expectedFields_2[i], `fields ${actualField.name} should be the same`);\n  });\n  t.deepEqual(parsedValid[0].data.rows, expectedRows, 'should parse rows correctly');\n  t.end();\n});","file":"node/schemas/dataset-schema-test.js","skipped":false,"dir":"test"},{"name":"#mapStateSchema -> v1 -> save load mapState","suites":[],"updatePoint":{"line":25,"column":49,"index":1343},"line":25,"code":"test('#mapStateSchema -> v1 -> save load mapState', t => {\n  const initialState = cloneDeep(InitialState);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const msToSave = savedState.config.mapState;\n  const msLoaded = SchemaManager.parseSavedConfig(savedState).mapState;\n  t.deepEqual(Object.keys(msToSave), ['bearing', 'dragRotate', 'latitude', 'longitude', 'pitch', 'zoom', 'isSplit', 'isViewportSynced', 'isZoomLocked', 'splitMapViewports'], 'mapState should have all 6 entries');\n  const expected = {\n    pitch: 0,\n    bearing: 0,\n    latitude: 37.75043,\n    longitude: -122.34679,\n    zoom: 9,\n    dragRotate: false,\n    isSplit: false,\n    isViewportSynced: true,\n    isZoomLocked: false,\n    splitMapViewports: []\n  };\n  t.deepEqual(msToSave, expected, 'save mapState should be current');\n  t.deepEqual(msLoaded, expected, 'load mapState should be current');\n  t.end();\n});","file":"node/schemas/map-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleSchema -> v1 -> save load mapStyle","suites":[],"updatePoint":{"line":25,"column":49,"index":1365},"line":25,"code":"test('#mapStyleSchema -> v1 -> save load mapStyle', t => {\n  const initialState = cloneDeep(InitialState);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const msToSave = savedState.config.mapStyle;\n  const msLoaded = SchemaManager.parseSavedConfig(savedState).mapStyle;\n  t.deepEqual(Object.keys(msToSave), ['styleType', 'topLayerGroups', 'visibleLayerGroups', 'threeDBuildingColor', 'backgroundColor', 'mapStyles'], 'mapStyle should have all 6 entries');\n  const expectedSaved = {\n    styleType: 'dark',\n    topLayerGroups: {},\n    visibleLayerGroups: {},\n    mapStyles: {},\n    threeDBuildingColor: [209, 206, 199],\n    backgroundColor: [255, 255, 255]\n  };\n  const expectedLoaded = {\n    styleType: 'dark',\n    topLayerGroups: {},\n    visibleLayerGroups: {},\n    threeDBuildingColor: [209, 206, 199],\n    backgroundColor: [255, 255, 255]\n  };\n  t.deepEqual(msToSave, expectedSaved, 'saved mapStyle should be current');\n  t.deepEqual(msLoaded, expectedLoaded, 'loaded mapStyle should be current');\n  t.end();\n});","file":"node/schemas/map-style-schema-test.js","skipped":false,"dir":"test"},{"name":"#mapStyleSchema -> v1 -> save load mapStyle with custom style","suites":[],"updatePoint":{"line":52,"column":67,"index":2437},"line":52,"code":"test('#mapStyleSchema -> v1 -> save load mapStyle with custom style', t => {\n  const initialState = cloneDeep(StateWCustomMapStyle);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const msToSave = savedState.config.mapStyle;\n  const msLoaded = SchemaManager.parseSavedConfig(savedState).mapStyle;\n  const expectedSaved = {\n    styleType: 'smoothie_the_cat',\n    topLayerGroups: {},\n    visibleLayerGroups: {\n      label: true,\n      road: true\n    },\n    threeDBuildingColor: [1, 2, 3],\n    backgroundColor: [255, 255, 255],\n    mapStyles: {\n      smoothie_the_cat: {\n        id: 'smoothie_the_cat',\n        accessToken: 'secret_token',\n        label: 'Smoothie the Cat',\n        icon: 'https://api.mapbox.com/styles/v1/shanhe/smoothie.the.cat/static/-122.3391,37.7922,9,0,0/400x300?access_token=secret_token&logo=false&attribution=false',\n        custom: true,\n        url: 'mapbox://styles/shanhe/smoothie.the.cat'\n      }\n    }\n  };\n  t.deepEqual(msToSave, expectedSaved, 'saved mapStyle should be current');\n  t.deepEqual(msLoaded, expectedSaved, 'loaded mapStyle should be current');\n  t.end();\n});","file":"node/schemas/map-style-schema-test.js","skipped":false,"dir":"test"},{"name":"#appSchema -> Convert Saved Configs","suites":[],"updatePoint":{"line":49,"column":41,"index":2358},"line":49,"code":"test('#appSchema -> Convert Saved Configs', t => {\n  TEST_CASES.forEach(({\n    name,\n    cases\n  }) => {\n    logStep(`---> test: ${name}`);\n    cases.forEach(cs => {\n      logStep(`------> test: ${cs.name}`);\n      const parsed = SchemaManager.parseSavedConfig(cs.saved);\n      cmpParsedAppConfigs(t, cs.parsed, parsed, {\n        name: cs.name\n      });\n    });\n  });\n  t.end();\n});","file":"node/schemas/schema-conversion-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save layers","suites":[],"updatePoint":{"line":29,"column":42,"index":1991},"line":29,"code":"test('#visStateSchema -> v1 -> save layers', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n\n  // save state\n  const vsToSave = SchemaManager.getConfigToSave(initialState).config.visState;\n  t.deepEqual(Object.keys(vsToSave), expectedVisStateEntries, `visState should have all ${expectedVisStateEntries.length} entries`);\n  const exptectedSavedLayers = [expectedSavedLayer0, expectedSavedLayer1, expectedSavedLayer2];\n  const layersToSave = vsToSave.layers;\n  cmpSavedLayers(t, exptectedSavedLayers, layersToSave);\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> load layers","suites":[],"updatePoint":{"line":40,"column":42,"index":2545},"line":40,"code":"test('#visStateSchema -> v1 -> load layers', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n\n  // save state\n  const savedState = SchemaManager.getConfigToSave(initialState);\n  const vsLoaded = SchemaManager.parseSavedConfig(savedState).visState;\n  t.deepEqual(Object.keys(vsLoaded), expectedVisStateEntries, `visState should have all ${expectedVisStateEntries.length} entries`);\n  const loadedLayers = vsLoaded.layers;\n  const expectedLoadedLayers = [expectedLoadedLayer0, expectedLoadedLayer1, expectedLoadedLayer2];\n  cmpSavedLayers(t, expectedLoadedLayers, loadedLayers, {\n    id: true\n  });\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save load filters","suites":[],"updatePoint":{"line":54,"column":48,"index":3186},"line":54,"code":"test('#visStateSchema -> v1 -> save load filters', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const vsToSave = savedState.config.visState;\n  const vsLoaded = SchemaManager.parseSavedConfig(savedState).visState;\n  const loadedFilters = vsLoaded.filters;\n\n  // test saved filters\n  const filtersToSave = vsToSave.filters;\n  const expectedSavedFilters = [{\n    dataId: [testCsvDataId],\n    id: 'hjpn8frza',\n    enabled: true,\n    name: ['time'],\n    type: 'timeRange',\n    value: [1474606800000, 1474617600000],\n    view: 'enlarged',\n    plotType: 'histogram',\n    yAxis: null,\n    animationWindow: 'free',\n    speed: 4\n  }, {\n    dataId: [testGeoJsonDataId],\n    id: 'vpk2466o',\n    enabled: true,\n    name: ['RATE'],\n    type: 'multiSelect',\n    value: ['a'],\n    view: 'side',\n    plotType: 'histogram',\n    yAxis: null,\n    animationWindow: 'free',\n    speed: 1\n  }];\n  cmpFilters(t, expectedSavedFilters, filtersToSave);\n  cmpFilters(t, expectedSavedFilters, loadedFilters);\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save and validate filters","suites":[],"updatePoint":{"line":94,"column":56,"index":4299},"line":94,"code":"test('#visStateSchema -> v1 -> save and validate filters', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n\n  // add empty filter\n  const nextStte = keplerGlReducer(initialState, VisStateActions.addFilter(testCsvDataId));\n  const savedState = SchemaManager.getConfigToSave(nextStte);\n  t.equal(nextStte.visState.filters.length, 3, 'should have 3 filters');\n  t.equal(savedState.config.visState.filters.length, 2, 'should only save 2 filters');\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save load interaction","suites":[],"updatePoint":{"line":104,"column":52,"index":4777},"line":104,"code":"test('#visStateSchema -> v1 -> save load interaction', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const interactionToSave = savedState.config.visState.interactionConfig;\n  const interactionLoaded = SchemaManager.parseSavedConfig(savedState).visState.interactionConfig;\n  const expectedSaved = {\n    tooltip: {\n      enabled: true,\n      compareMode: false,\n      compareType: 'absolute',\n      fieldsToShow: {\n        [testCsvDataId]: [{\n          name: 'gps_data.utc_timestamp',\n          format: null\n        }, {\n          name: 'gps_data.types',\n          format: null\n        }, {\n          name: 'epoch',\n          format: null\n        }, {\n          name: 'has_result',\n          format: null\n        }, {\n          name: 'uid',\n          format: null\n        }],\n        [testGeoJsonDataId]: [{\n          name: 'OBJECTID',\n          format: null\n        }, {\n          name: 'ZIP_CODE',\n          format: null\n        }, {\n          name: 'ID',\n          format: null\n        }, {\n          name: 'TRIPS',\n          format: null\n        }, {\n          name: 'RATE',\n          format: null\n        }]\n      }\n    },\n    brush: {\n      enabled: false,\n      size: 0.5\n    },\n    coordinate: {\n      enabled: false\n    },\n    geocoder: {\n      enabled: false\n    }\n  };\n  t.deepEqual(interactionToSave, expectedSaved);\n  t.deepEqual(interactionLoaded, expectedSaved);\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save load interaction -> tooltip format","suites":[],"updatePoint":{"line":166,"column":70,"index":6296},"line":166,"code":"test('#visStateSchema -> v1 -> save load interaction -> tooltip format', t => {\n  const initialState = cloneDeep(StateWTooltipFormat);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const interactionToSave = savedState.config.visState.interactionConfig;\n  const interactionLoaded = SchemaManager.parseSavedConfig(savedState).visState.interactionConfig;\n  const expectedSaved = {\n    tooltip: {\n      enabled: true,\n      compareMode: true,\n      compareType: 'relative',\n      fieldsToShow: {\n        [testCsvDataId]: [{\n          name: 'gps_data.utc_timestamp',\n          format: 'LL'\n        }],\n        [testGeoJsonDataId]: [{\n          name: 'OBJECTID',\n          format: null\n        }, {\n          name: 'ZIP_CODE',\n          format: null\n        }, {\n          name: 'ID',\n          format: null\n        }, {\n          name: 'TRIPS',\n          format: '.3f'\n        }, {\n          name: 'RATE',\n          format: null\n        }]\n      }\n    },\n    brush: {\n      enabled: false,\n      size: 0.5\n    },\n    coordinate: {\n      enabled: false\n    },\n    geocoder: {\n      enabled: false\n    }\n  };\n  t.deepEqual(interactionToSave, expectedSaved);\n  t.deepEqual(interactionLoaded, expectedSaved);\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save load layerBlending","suites":[],"updatePoint":{"line":216,"column":54,"index":7534},"line":216,"code":"test('#visStateSchema -> v1 -> save load layerBlending', t => {\n  const initialState = cloneDeep(StateWFilesFiltersLayerColor);\n  const savedState = SchemaManager.getConfigToSave(initialState);\n\n  // save state\n  const layerBlendingToSave = savedState.config.visState.layerBlending;\n  const layerBlendingLoaded = SchemaManager.parseSavedConfig(savedState).visState.layerBlending;\n  const expectedSaved = 'normal';\n  t.deepEqual(layerBlendingToSave, expectedSaved);\n  t.deepEqual(layerBlendingLoaded, expectedSaved);\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"#visStateSchema -> v1 -> save animation","suites":[],"updatePoint":{"line":228,"column":45,"index":8056},"line":228,"code":"test('#visStateSchema -> v1 -> save animation', t => {\n  const initialState = cloneDeep(StateWTripGeojson);\n\n  // save state\n  const vsToSave = SchemaManager.getConfigToSave(initialState).config.visState;\n  t.deepEqual(Object.keys(vsToSave), expectedVisStateEntries, `visState should have all ${expectedVisStateEntries.length} entries`);\n  const expectedSavedLayers = [expectedSavedTripLayer];\n  const expectedAnimationConfig = {\n    currentTime: 1565577261000,\n    speed: 1\n  };\n  cmpSavedLayers(t, expectedSavedLayers, vsToSave.layers);\n  t.deepEqual(vsToSave.animationConfig, expectedAnimationConfig, 'should save animationConfig');\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"visStateSchema -> saving with a null column value does not throw an error","suites":[],"updatePoint":{"line":243,"column":79,"index":8741},"line":243,"code":"test('visStateSchema -> saving with a null column value does not throw an error', t => {\n  const testLayer = cloneDeep(StateWFiles).visState.layers[0];\n\n  // set a column to null\n  testLayer.config.columns.altitude = null;\n\n  // test that it doesn't fail ColumnSchemaV1.save\n  t.doesNotThrow(() => {\n    visStateSchema[CURRENT_VERSION].save({\n      layers: [testLayer],\n      layerOrder: [testLayer.id]\n    });\n  }, 'saving with a null column value should not fail');\n  t.end();\n});","file":"node/schemas/vis-state-schema-test.js","skipped":false,"dir":"test"},{"name":"AggregateUtils - GetFrequency","suites":[],"updatePoint":{"line":24,"column":35,"index":1310},"line":24,"code":"test('AggregateUtils - GetFrequency', t => {\n  t.deepEqual(getFrequency([2, 1, 2, 1]), {\n    1: 2,\n    2: 2\n  }, 'Should compute frequency corerctly');\n  t.deepEqual(getFrequency([]), {}, 'Should return an empty object');\n  t.end();\n});","file":"node/utils/aggregate-utils-test.js","skipped":false,"dir":"test"},{"name":"AggregateUtils - GetMode","suites":[],"updatePoint":{"line":32,"column":30,"index":1542},"line":32,"code":"test('AggregateUtils - GetMode', t => {\n  t.deepEqual(getMode([2, 1, 2, 1]), '1', 'should return 1 as Mode');\n  t.end();\n});","file":"node/utils/aggregate-utils-test.js","skipped":false,"dir":"test"},{"name":"AggregateUtils - aggregate","suites":[],"updatePoint":{"line":36,"column":32,"index":1669},"line":36,"code":"test('AggregateUtils - aggregate', t => {\n  const data = [1, 2, 3, 1, 2, 3, 4, 3];\n  const results = [8, 2.375, 4, 1, 2.5, 1.0606601717798212, 19, 1.125, '3', 8];\n  Object.keys(AGGREGATION_TYPES).map((technique, index) => {\n    t.equal(aggregate(data, technique), results[index], `Should compute the right aggregation using ${technique} - ${index}`);\n  });\n  t.end();\n});","file":"node/utils/aggregate-utils-test.js","skipped":false,"dir":"test"},{"name":"createLinearGradient","suites":[],"updatePoint":{"line":23,"column":26,"index":1231},"line":23,"code":"test('createLinearGradient', t => {\n  let colors = [[100, 100, 100]];\n  t.deepEqual(createLinearGradient('bottom', colors), 'linear-gradient(to bottom, rgba(100,100,100, 1) 0%, rgba(100,100,100, 1) 100%)', 'Should create a solid gradient with 1 color');\n  colors = [[100, 100, 100], [200, 200, 200], [300, 300, 300]];\n  t.deepEqual(createLinearGradient('bottom', colors), 'linear-gradient(to bottom, rgba(100,100,100, 1) 0%, rgba(100,100,100, 1) 33.33%,rgba(200,200,200, 1) 33.33%, rgba(200,200,200, 1) 66.66%,rgba(300,300,300, 1) 66.66%, rgba(300,300,300, 1) 99.99%)', 'Should create a linear gradient');\n  colors = [[10, 10, 10], [20, 20, 20], [30, 30, 30], [40, 40, 40]];\n  t.deepEqual(createLinearGradient('bottom', colors), 'linear-gradient(to bottom, rgba(10,10,10, 1) 0%, rgba(10,10,10, 1) 25%,rgba(20,20,20, 1) 25%, rgba(20,20,20, 1) 50%,rgba(30,30,30, 1) 50%, rgba(30,30,30, 1) 75%,rgba(40,40,40, 1) 75%, rgba(40,40,40, 1) 100%)', 'Should create a linear gradient');\n  t.end();\n});","file":"node/utils/color-util-test.js","skipped":false,"dir":"test"},{"name":"#composeHelpers -> RemoveElementAtIndex","suites":[],"updatePoint":{"line":23,"column":45,"index":1268},"line":23,"code":"test('#composeHelpers -> RemoveElementAtIndex', t => {\n  const list = [1, 2, 3, 4, 5];\n  t.deepEqual(removeElementAtIndex(1)(list), [1, 3, 4, 5], 'Should remove element at index');\n  t.end();\n});","file":"node/utils/composer-helpers-test.js","skipped":false,"dir":"test"},{"name":"#composeHelpers -> filterOutById","suites":[],"updatePoint":{"line":28,"column":38,"index":1457},"line":28,"code":"test('#composeHelpers -> filterOutById', t => {\n  const list = [{\n    id: 1\n  }, {\n    id: 2\n  }, {\n    id: 3\n  }];\n  t.deepEqual(filterOutById(1)(list), [{\n    id: 2\n  }, {\n    id: 3\n  }], 'Should remove element with specific id');\n  t.end();\n});","file":"node/utils/composer-helpers-test.js","skipped":false,"dir":"test"},{"name":"RowDataContainer","suites":[],"updatePoint":{"line":37,"column":22,"index":1392},"line":37,"code":"test('RowDataContainer', t => {\n  const dc = createDataContainer(data);\n  t.deepEqual(dc.numRows(), 6, `RowDataContainer should have expected number of rows`);\n  t.deepEqual(dc.numColumns(), 2, `RowDataContainer should have expected number of columns`);\n  t.deepEqual(dc.valueAt(2, 1), 60, `RowDataContainer.valueAt should return expected value`);\n  t.deepEqual(dc.row(2).valueAt(1), 60, `RowDataContainer.row should return expected value`);\n  t.deepEqual(dc.rowAsArray(2), [50, 60], `RowDataContainer.rowAsArray should return expected value`);\n  t.deepEqual(dc.flattenData(), data, `RowDataContainer.flattenData should return expected data`);\n  t.deepEqual(dc.getPlainIndex(), [0, 1, 2, 3, 4, 5], `RowDataContainer.getPlainIndex should return expected indices`);\n  t.deepEqual(dc.map((row, rowIndex) => row.valueAt(1)), [20, 40, 60, 90, 110, 130], `RowDataContainer.map should return expected array`);\n  t.deepEqual(dc.mapIndex(d => d), [{\n    index: 0\n  }, {\n    index: 1\n  }, {\n    index: 2\n  }, {\n    index: 3\n  }, {\n    index: 4\n  }, {\n    index: 5\n  }], `RowDataContainer.mapIndex should return expected array`);\n  t.deepEqual(dc.find((row, rowIndex) => {\n    return row.valueAt(1) === 60;\n  }), dc.row(2), `RowDataContainer.find should return expected row`);\n  t.deepEqual(dc.reduce((acc, row, index) => {\n    return acc + row.valueAt(1);\n  }, 10), 460, `RowDataContainer.reduce should return expected value`);\n  t.end();\n});","file":"node/utils/data-container-test.js","skipped":false,"dir":"test"},{"name":"IndexedDataContainer","suites":[],"updatePoint":{"line":68,"column":26,"index":2829},"line":68,"code":"test('IndexedDataContainer', t => {\n  const dc = createIndexedDataContainer(createDataContainer(data), indices);\n  t.deepEqual(dc.numRows(), 3, `IndexedDataContainer should have expected number of rows`);\n  t.deepEqual(dc.numColumns(), 2, `IndexedDataContainer should have expected number of columns`);\n  t.deepEqual(dc.valueAt(2, 1), 130, `IndexedDataContainer.valueAt should return expected value`);\n  t.deepEqual(dc.row(2).valueAt(1), 130, `IndexedDataContainer.row should return expected value`);\n  t.deepEqual(dc.rowAsArray(2), [120, 130], `IndexedDataContainer.rowAsArray should return expected value`);\n  t.deepEqual(dc.flattenData(), [data[indices[0]], data[indices[1]], data[indices[2]]], `IndexedDataContainer.flattenData should return expected data`);\n  t.deepEqual(dc.getPlainIndex(), [0, 1, 2], `IndexedDataContainer.getPlainIndex should return expected indices`);\n  t.deepEqual(dc.map((row, rowIndex) => row.valueAt(1)), [40, 90, 130], `IndexedDataContainer.map should return expected array`);\n  t.deepEqual(dc.mapIndex(d => d), [{\n    index: 1\n  }, {\n    index: 3\n  }, {\n    index: 5\n  }], `IndexedDataContainer.mapIndex should return expected array`);\n  t.deepEqual(dc.find((row, rowIndex) => {\n    return row.valueAt(1) === 90;\n  }), dc.row(1), `IndexedDataContainer.find should return expected row`);\n  t.deepEqual(dc.reduce((acc, row, index) => {\n    return acc + row.valueAt(1);\n  }, 10), 270, `RowDataContainer.reduce should return expected value`);\n  t.end();\n});","file":"node/utils/data-container-test.js","skipped":false,"dir":"test"},{"name":"Processor -> getFieldsFromData","suites":[],"updatePoint":{"line":34,"column":36,"index":2189},"line":34,"code":"test('Processor -> getFieldsFromData', t => {\n  const data = [{\n    time: '2016-09-17 00:09:55',\n    trip_epoch: '1472688000000',\n    time_str: 'January 1st 2017 11:00pm ',\n    value: '4',\n    surge: '1.2',\n    isTrip: 'true',\n    zeroOnes: '0'\n  }, {\n    time: '2016-09-17 00:30:08',\n    trip_epoch: '1472860800000',\n    time_str: 'January 1st 2017 11:01pm ',\n    value: '3',\n    surge: null,\n    isTrip: 'false',\n    zeroOnes: '1'\n  }, {\n    time: null,\n    trip_epoch: null,\n    time_str: 'January 1st, 2017 11:02pm ',\n    value: '2',\n    surge: '1.3',\n    isTrip: null,\n    zeroOnes: '1'\n  }, {\n    time: null,\n    trip_epoch: null,\n    time_str: 'January 1st, 2017 11:02pm ',\n    value: '0',\n    surge: '1.4',\n    isTrip: null,\n    zeroOnes: '0'\n  }];\n  const headerRow = Object.keys(data[0]);\n  const fields = getFieldsFromData(data, headerRow);\n  const expectedFieldTypes = ['timestamp', 'timestamp', 'timestamp', 'integer', 'real', 'boolean', 'integer'];\n  fields.forEach((f, i) => t.equal(f.type, expectedFieldTypes[i], `should find field type as ${expectedFieldTypes[i]}`));\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processCsvData","suites":[],"updatePoint":{"line":74,"column":33,"index":3286},"line":74,"code":"test('Processor -> processCsvData', t => {\n  t.throws(() => processCsvData(''), 'should throw if csv is empty');\n\n  // load sample dataset csv as text\n  const {\n    fields,\n    rows\n  } = processCsvData(cloneDeep(testData));\n  t.equal(rows.length, testAllData.length, `should return ${testAllData.length} rows`);\n  cmpFields(t, testFields, fields, 'should parse rows correctly');\n  t.deepEqual(rows, testAllData, 'should parse rows correctly');\n  rows.forEach((r, i) => {\n    t.deepEqual(r, testAllData[i], `should parse row ${i} correctly`);\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processCsvData -> duplicated field name","suites":[],"updatePoint":{"line":90,"column":58,"index":3875},"line":90,"code":"test('Processor -> processCsvData -> duplicated field name', t => {\n  const testData1 = `column1,column1,column1,column2\\na,b,c,d\\nc,d,e,f`;\n\n  // load sample dataset csv as text\n  const result = processCsvData(testData1);\n  const expectedResult = {\n    fields: [{\n      name: 'column1',\n      id: 'column1',\n      format: '',\n      fieldIdx: 0,\n      displayName: 'column1',\n      type: 'string',\n      analyzerType: 'STRING',\n      valueAccessor: values => values[0]\n    }, {\n      name: 'column1-0',\n      id: 'column1-0',\n      format: '',\n      fieldIdx: 1,\n      displayName: 'column1-0',\n      type: 'string',\n      analyzerType: 'STRING',\n      valueAccessor: values => values[1]\n    }, {\n      name: 'column1-1',\n      id: 'column1-1',\n      format: '',\n      fieldIdx: 2,\n      displayName: 'column1-1',\n      type: 'string',\n      analyzerType: 'STRING',\n      valueAccessor: values => values[2]\n    }, {\n      name: 'column2',\n      id: 'column2',\n      format: '',\n      fieldIdx: 3,\n      displayName: 'column2',\n      type: 'string',\n      analyzerType: 'STRING',\n      valueAccessor: values => values[3]\n    }],\n    rows: [['a', 'b', 'c', 'd'], ['c', 'd', 'e', 'f']]\n  };\n  cmpFields(t, result.fields, expectedResult.fields, 'should have created non duplicated fields');\n  t.deepEqual(result.rows, expectedResult.rows, 'should have computed rows with non duplicated fields');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processCsvData -> with nulls","suites":[],"updatePoint":{"line":139,"column":47,"index":5271},"line":139,"code":"test('Processor -> processCsvData -> with nulls', t => {\n  const {\n    fields,\n    rows\n  } = processCsvData(dataWithNulls);\n  cmpFields(t, fields, testFields, 'should parse fields correctly');\n  t.deepEqual(rows, parsedDataWithNulls, 'should parse rows correctly');\n  rows.forEach((r, i) => {\n    t.deepEqual(r, parsedDataWithNulls[i], `should parse row ${i} correctly`);\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processCsvData -> wkt","suites":[],"updatePoint":{"line":151,"column":40,"index":5658},"line":151,"code":"test('Processor -> processCsvData -> wkt', t => {\n  const {\n    fields,\n    rows\n  } = processCsvData(wktCsv);\n  cmpFields(t, fields, wktCsvFields, 'should find geometry fields as type:geojson');\n  rows.forEach((r, i) => {\n    t.deepEqual(r, wktCsvRows[i], `should process wkt rows[${i}] correctly`);\n  });\n  t.deepEqual(rows, wktCsvRows, 'should process wkt rows correctly');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processCsvData -> w/ array and object","suites":[],"updatePoint":{"line":163,"column":56,"index":6066},"line":163,"code":"test('Processor -> processCsvData -> w/ array and object', t => {\n  const {\n    fields,\n    rows\n  } = processCsvData(testCsvObjectData);\n  cmpFields(t, fields, objCsvFields, 'should find csv object fields as type:object');\n  t.equal(rows.length, objCsvRows.length, 'should have same row length');\n  rows.forEach((r, i) => {\n    t.deepEqual(r, objCsvRows[i], 'should format correct csv object rows');\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor => processGeojson","suites":[],"updatePoint":{"line":175,"column":33,"index":6465},"line":175,"code":"test('Processor => processGeojson', t => {\n  const {\n    fields,\n    rows\n  } = processGeojson(cloneDeep(geojsonData));\n  cmpFields(t, fields, geojsonFields, 'should have same field length');\n  t.equal(rows.length, geojsonRows.length, 'should have same row length');\n  rows.forEach((r, i) => {\n    t.deepEqual(r, geojsonRows[i], 'should format correct geojson rows');\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor => processGeojson: with style property","suites":[],"updatePoint":{"line":187,"column":54,"index":6875},"line":187,"code":"test('Processor => processGeojson: with style property', t => {\n  const {\n    fields,\n    rows\n  } = processGeojson(cloneDeep(geoJsonWithStyle));\n  cmpFields(t, fields, geoStyleFields, 'should preserve objects in geojson properties');\n  t.deepEqual(rows, geoStyleRows, 'should preserve objects in geojson properties');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor => processGeojson:invalid geojson","suites":[],"updatePoint":{"line":196,"column":49,"index":7204},"line":196,"code":"test('Processor => processGeojson:invalid geojson', t => {\n  t.throws(() => processGeojson({\n    fields: [],\n    rows: []\n  }), 'Should throw error with invalid geojson type');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor => processGeojson: parse rows","suites":[],"updatePoint":{"line":203,"column":45,"index":7392},"line":203,"code":"test('Processor => processGeojson: parse rows', t => {\n  const testGeoData = {\n    type: 'FeatureCollection',\n    features: [{\n      type: 'Feature',\n      properties: {\n        TRIPS: '11',\n        RATE: 'a',\n        TIME: '1570749707'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }, {\n      type: 'Feature',\n      properties: {\n        TRIPS: '10',\n        RATE: 'b',\n        TIME: '1570749707'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }, {\n      type: 'Feature',\n      properties: {\n        TRIPS: '9',\n        RATE: 'b',\n        TIME: '1570749707'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }]\n  };\n  const expectedFields = [{\n    name: '_geojson',\n    id: '_geojson',\n    displayName: '_geojson',\n    format: '',\n    fieldIdx: 0,\n    type: 'geojson',\n    analyzerType: 'GEOMETRY',\n    valueAccessor: values => values[0]\n  }, {\n    name: 'TRIPS',\n    id: 'TRIPS',\n    displayName: 'TRIPS',\n    format: '',\n    fieldIdx: 1,\n    type: 'integer',\n    analyzerType: 'INT',\n    valueAccessor: values => values[1]\n  }, {\n    name: 'RATE',\n    id: 'RATE',\n    displayName: 'RATE',\n    format: '',\n    fieldIdx: 2,\n    type: 'string',\n    analyzerType: 'STRING',\n    valueAccessor: values => values[2]\n  }, {\n    name: 'TIME',\n    id: 'TIME',\n    displayName: 'TIME',\n    format: 'x',\n    fieldIdx: 3,\n    type: 'timestamp',\n    analyzerType: 'TIME',\n    valueAccessor: values => values[3]\n  }];\n  const expectedRows = [[{\n    type: 'Feature',\n    properties: {\n      TRIPS: 11,\n      RATE: 'a',\n      TIME: 1570749707\n    },\n    geometry: {\n      type: 'Point',\n      coordinates: [[-122, 37]]\n    }\n  }, 11, 'a', 1570749707], [{\n    type: 'Feature',\n    properties: {\n      TRIPS: 10,\n      RATE: 'b',\n      TIME: 1570749707\n    },\n    geometry: {\n      type: 'Point',\n      coordinates: [[-122, 37]]\n    }\n  }, 10, 'b', 1570749707], [{\n    type: 'Feature',\n    properties: {\n      TRIPS: 9,\n      RATE: 'b',\n      TIME: 1570749707\n    },\n    geometry: {\n      type: 'Point',\n      coordinates: [[-122, 37]]\n    }\n  }, 9, 'b', 1570749707]];\n  const result = processGeojson(testGeoData);\n  t.deepEqual(Object.keys(result), ['fields', 'rows'], 'should contain fields and rows');\n  cmpFields(t, result.fields, expectedFields, 'should parse correct fields when geojson input contain string');\n  t.deepEqual(result.rows, expectedRows, 'should parse correct rows when geojson input contain string');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> parseCsvRowsByFieldType -> real","suites":[],"updatePoint":{"line":318,"column":50,"index":9963},"line":318,"code":"test('Processor -> parseCsvRowsByFieldType -> real', t => {\n  const field = {\n    type: ALL_FIELD_TYPES.real\n  };\n  const rows = [['0.0'], ['1.0'], ['-1.0'], ['155.0'], ['1.55e3'], ['1.55e-3'], [' 1.55e-3 '], [' 1.55e+3 xyz']];\n  const expected = [[0.0], [1.0], [-1.0], [155.0], [1550.0], [0.00155], [0.00155], [1550.0]];\n  parseCsvRowsByFieldType(rows, -1, field, 0);\n  t.same(rows, expected, 'should parsed reals properly');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> parseCsvRowsByFieldType -> integer","suites":[],"updatePoint":{"line":328,"column":53,"index":10408},"line":328,"code":"test('Processor -> parseCsvRowsByFieldType -> integer', t => {\n  const field = {\n    type: ALL_FIELD_TYPES.integer\n  };\n  const rows = [['0'], ['1'], ['-1'], ['155'], [' 155 '], [' 155 xyz']];\n  const expected = [[0], [1], [-1], [155], [155], [155]];\n  parseCsvRowsByFieldType(rows, -1, field, 0);\n  t.same(rows, expected, 'should parsed ints properly');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> parseCsvRowsByFieldType -> boolean","suites":[],"updatePoint":{"line":338,"column":53,"index":10778},"line":338,"code":"test('Processor -> parseCsvRowsByFieldType -> boolean', t => {\n  const field = {\n    type: ALL_FIELD_TYPES.boolean\n  };\n  const rows = [[null], ['0'], ['1'], ['True'], ['False'], ['0'], ['1'], ['true']];\n\n  // is parsing '' meaningful, why not false\n  const expected = [[null], [false], [true], [true], [false], [false], [true], [true]];\n  parseCsvRowsByFieldType(rows, -1, field, 0);\n  t.same(rows, expected, 'should parsed boolean properly');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> getSampleForTypeAnalyze","suites":[],"updatePoint":{"line":350,"column":42,"index":11227},"line":350,"code":"test('Processor -> getSampleForTypeAnalyze', t => {\n  const fields = ['string', 'int', 'bool', 'time'];\n  const rows = [['a', 0, true, null], ['b', 2, false, null], ['c', 3, true, '2017-01-01'], [null, 1, false, '2017-01-02'], ['d', 6, false, '2017-01-03'], ['e', 4, true, null], ['f', 5, true, undefined], ['g', null, true, null], ['h', undefined, true, '2017-01-04']];\n  const sample = getSampleForTypeAnalyze({\n    fields,\n    rows,\n    sampleCount: 5\n  });\n  const expected = [{\n    string: 'a',\n    int: 0,\n    bool: true,\n    time: '2017-01-01'\n  }, {\n    string: 'b',\n    int: 2,\n    bool: false,\n    time: '2017-01-02'\n  }, {\n    string: 'c',\n    int: 3,\n    bool: true,\n    time: '2017-01-03'\n  }, {\n    string: 'd',\n    int: 1,\n    bool: false,\n    time: '2017-01-04'\n  }, {\n    string: 'e',\n    int: 6,\n    bool: false,\n    time: null\n  }];\n  t.deepEqual(sample, expected, 'Should find correct sample for type analyzer');\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> validateInputData","suites":[],"updatePoint":{"line":387,"column":36,"index":12169},"line":387,"code":"test('Processor -> validateInputData', t => {\n  t.equal(validateInputData(null), null, 'Should throw error if data is null');\n  t.equal(validateInputData({\n    rows: 'hello'\n  }), null, 'Should throw error if data.rows is null');\n  t.equal(validateInputData({\n    rows: [],\n    fields: null\n  }), null, 'Should throw error if data.fields is null');\n  const cases = [{\n    input: {\n      rows: [[1], [2], [3]],\n      fields: ['a']\n    },\n    expected: {\n      rows: [[1], [2], [3]],\n      fields: [{\n        type: ALL_FIELD_TYPES.integer,\n        format: '',\n        name: 'column_0',\n        analyzerType: 'INT'\n      }]\n    },\n    msg: 'should re generate field if not an object'\n  }, {\n    input: {\n      rows: [[1], [2], [3]],\n      fields: [{\n        type: ALL_FIELD_TYPES.integer,\n        format: ''\n      }]\n    },\n    expected: {\n      rows: [[1], [2], [3]],\n      fields: [{\n        type: ALL_FIELD_TYPES.integer,\n        format: '',\n        name: 'column_0',\n        analyzerType: 'INT'\n      }]\n    },\n    msg: 'should reassign field name'\n  }, {\n    input: {\n      rows: [[1], [2], [3]],\n      fields: [{\n        type: 'hello',\n        format: '',\n        name: 'taro'\n      }]\n    },\n    expected: {\n      rows: [[1], [2], [3]],\n      fields: [{\n        type: ALL_FIELD_TYPES.integer,\n        format: '',\n        name: 'taro',\n        analyzerType: 'INT'\n      }]\n    },\n    msg: 'should reassign field type'\n  }, {\n    input: {\n      rows: [['2018-09-01 00:00'], ['2018-09-01 01:00'], ['2018-09-01 02:00']],\n      fields: [{\n        type: ALL_FIELD_TYPES.timestamp,\n        format: '',\n        name: 'taro'\n      }]\n    },\n    expected: {\n      rows: [['2018-09-01 00:00'], ['2018-09-01 01:00'], ['2018-09-01 02:00']],\n      fields: [{\n        type: ALL_FIELD_TYPES.timestamp,\n        format: 'YYYY-M-D H:m',\n        name: 'taro',\n        analyzerType: 'DATETIME'\n      }]\n    },\n    msg: 'should reassign field type'\n  }];\n  cases.forEach(({\n    input,\n    expected,\n    msg\n  }) => {\n    t.deepEqual(validateInputData(input), expected, msg);\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> processRowObject","suites":[],"updatePoint":{"line":477,"column":35,"index":14246},"line":477,"code":"test('Processor -> processRowObject', t => {\n  t.equal(processRowObject({}), null, 'Should return null when rawData is empty');\n  const cases = [{\n    input: [{\n      a: 1,\n      b: 'c',\n      c: true,\n      d: '1.2'\n    }, {\n      a: 2,\n      b: 'c',\n      c: false,\n      d: '1.3'\n    }, {\n      a: 3,\n      b: 'd',\n      c: true,\n      d: '1.4'\n    }],\n    expected: {\n      rows: [[1, 'c', true, 1.2], [2, 'c', false, 1.3], [3, 'd', true, 1.4]],\n      fields: [{\n        name: 'a',\n        id: 'a',\n        displayName: 'a',\n        type: 'integer',\n        format: '',\n        fieldIdx: 0,\n        analyzerType: 'INT',\n        valueAccessor: values => values[0]\n      }, {\n        name: 'b',\n        id: 'b',\n        displayName: 'b',\n        type: 'string',\n        format: '',\n        fieldIdx: 1,\n        analyzerType: 'STRING',\n        valueAccessor: values => values[1]\n      }, {\n        name: 'c',\n        id: 'c',\n        displayName: 'c',\n        type: 'boolean',\n        format: '',\n        fieldIdx: 2,\n        analyzerType: 'BOOLEAN',\n        valueAccessor: values => values[2]\n      }, {\n        name: 'd',\n        id: 'd',\n        displayName: 'd',\n        type: 'real',\n        format: '',\n        fieldIdx: 3,\n        analyzerType: 'FLOAT',\n        valueAccessor: values => values[3]\n      }]\n    },\n    msg: 'should parse correct row objects'\n  }];\n  cases.forEach(({\n    input,\n    expected,\n    msg\n  }) => {\n    const {\n      fields,\n      rows\n    } = processRowObject(input);\n    cmpFields(t, fields, expected.fields, `${msg} fields`);\n    t.deepEqual(rows, expected.rows, msg);\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> formatCsv","suites":[],"updatePoint":{"line":552,"column":28,"index":15866},"line":552,"code":"test('Processor -> formatCsv', t => {\n  const geojsonFc = {\n    type: 'FeatureCollection',\n    features: [{\n      type: 'Feature',\n      properties: {\n        TRIPS: '11'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }, {\n      type: 'Feature',\n      properties: {\n        TRIPS: '10'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }, {\n      type: 'Feature',\n      properties: {\n        TRIPS: '9'\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: [[-122, 37]]\n      }\n    }]\n  };\n  const cases = [{\n    input: `gps_data.lat,gps_data.types,epoch,has_result,id,begintrip_ts_local,date\\n` + `29.9900937,driver_analytics,1472688000000,False,1,2016-10-01 09:41:39+00:00,2016-09-23\\n` + `29.9927699,driver_analytics,1472688000000,False,2,2016-10-01 16:46:37+00:00,2016-09-23\\n` + `29.9907261,driver_analytics,1472688000000,False,3,,2016-09-23`,\n    expected: `gps_data.lat,gps_data.types,epoch,has_result,id,begintrip_ts_local,date\\n` + `29.9900937,driver_analytics,1472688000000,false,1,2016-10-01 09:41:39+00:00,2016-09-23\\n` + `29.9927699,driver_analytics,1472688000000,false,2,2016-10-01 16:46:37+00:00,2016-09-23\\n` + `29.9907261,driver_analytics,1472688000000,false,3,,2016-09-23`,\n    processor: processCsvData,\n    msg: 'should format correct csv'\n  }, {\n    input: geojsonFc,\n    expected: '_geojson,TRIPS\\n\"{\"\"type\"\":\"\"Feature\"\",\"\"properties\"\":{\"\"TRIPS\"\":11},\"\"geometry\"\":{\"\"type\"\":\"\"Point\"\",\"\"coordinates\"\":[[-122,37]]}}\",11\\n\"{\"\"type\"\":\"\"Feature\"\",\"\"properties\"\":{\"\"TRIPS\"\":10},\"\"geometry\"\":{\"\"type\"\":\"\"Point\"\",\"\"coordinates\"\":[[-122,37]]}}\",10\\n\"{\"\"type\"\":\"\"Feature\"\",\"\"properties\"\":{\"\"TRIPS\"\":9},\"\"geometry\"\":{\"\"type\"\":\"\"Point\"\",\"\"coordinates\"\":[[-122,37]]}}\",9',\n    processor: processGeojson,\n    msg: 'should format correct csv from geojsonInput'\n  }];\n  cases.forEach(({\n    input,\n    expected,\n    msg,\n    processor\n  }) => {\n    const {\n      fields,\n      rows\n    } = processor(input);\n    const dataContainer = createDataContainer(rows, {\n      fields\n    });\n    t.deepEqual(formatCsv(dataContainer, fields), expected, msg);\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"Processor -> analyzerTypeToFieldType","suites":[],"updatePoint":{"line":612,"column":42,"index":18068},"line":612,"code":"test('Processor -> analyzerTypeToFieldType', t => {\n  Object.keys(DATA_TYPES).forEach(atype => {\n    const spy = sinon.spy(Console, 'warn');\n    if (!ACCEPTED_ANALYZER_TYPES.includes(atype)) {\n      t.equal(analyzerTypeToFieldType(atype), 'string', 'should return string if type not recognized');\n      t.ok(spy.calledOnce, `should warn when pass unrecognized type ${atype}`);\n    } else {\n      const fieldType = analyzerTypeToFieldType(atype);\n      t.ok(ALL_FIELD_TYPES[fieldType], `should assign ${atype} to one of ALL_FIELD_TYPES`);\n    }\n    spy.restore();\n  });\n  t.end();\n});","file":"node/utils/data-processor-test.js","skipped":false,"dir":"test"},{"name":"DataScaleUtils -> getOrdinalDomain","suites":[],"updatePoint":{"line":26,"column":40,"index":1358},"line":26,"code":"test('DataScaleUtils -> getOrdinalDomain', t => {\n  const data = [['a'], ['a'], ['b'], [undefined], [null], [0], null];\n  function valueAccessor(d, dc) {\n    return dc.valueAt(d.index, 0);\n  }\n  t.deepEqual(getOrdinalDomain(createDataContainer(data), valueAccessor), [0, 'a', 'b'], 'should get correct ordinal domain');\n  t.end();\n});","file":"node/utils/data-scale-utils-test.js","skipped":false,"dir":"test"},{"name":"DataScaleUtils -> getQuantileDomain","suites":[],"updatePoint":{"line":34,"column":41,"index":1694},"line":34,"code":"test('DataScaleUtils -> getQuantileDomain', t => {\n  const data = ['a', 'b', 'c', 'b', undefined, null];\n  const quanData = [1, 4, 2, 3, 1, undefined, null, 0];\n  function valueAccessor(d) {\n    return d.value;\n  }\n  const values = [{\n    value: 'a'\n  }, {\n    value: 'b'\n  }, {\n    value: 'b'\n  }];\n  t.deepEqual(getQuantileDomain(data, undefined, undefined), ['a', 'b', 'b', 'c'], 'should get correct quantile domain');\n  t.deepEqual(getQuantileDomain(quanData, undefined, numberSort), [0, 1, 1, 2, 3, 4], 'should get correct quantile domain');\n  t.deepEqual(getQuantileDomain(values, valueAccessor), ['a', 'b', 'b'], 'should get correct quantile domain');\n  t.end();\n});","file":"node/utils/data-scale-utils-test.js","skipped":false,"dir":"test"},{"name":"DataScaleUtils -> getLinearDomain","suites":[],"updatePoint":{"line":52,"column":39,"index":2366},"line":52,"code":"test('DataScaleUtils -> getLinearDomain', t => {\n  const quanData = [1, 4, 2, 3, 1, undefined, null, 0];\n  function valueAccessor(d) {\n    return d.value;\n  }\n  const values = [{\n    value: 1\n  }, {\n    value: 0\n  }, {\n    value: -3\n  }];\n  t.deepEqual(getLinearDomain(quanData, undefined), [0, 4], 'should get correct Linear domain');\n  t.deepEqual(getLinearDomain([10, 10]), [10, 10], 'should get correct Linear domain');\n  t.deepEqual(getLinearDomain([10, undefined]), [10, 10], 'should get correct Linear domain');\n  t.deepEqual(getLinearDomain([undefined, undefined, null]), [0, 1], 'should get correct Linear domain');\n  t.deepEqual(getLinearDomain(values, valueAccessor), [-3, 1], 'should get correct Linear domain');\n  t.end();\n});","file":"node/utils/data-scale-utils-test.js","skipped":false,"dir":"test"},{"name":"DataScaleUtils -> getLogDomain","suites":[],"updatePoint":{"line":71,"column":36,"index":3103},"line":71,"code":"test('DataScaleUtils -> getLogDomain', t => {\n  function valueAccessor(d) {\n    return d.value;\n  }\n  t.deepEqual(getLogDomain([{\n    value: 1\n  }, {\n    value: 0\n  }, {\n    value: -3\n  }], valueAccessor), [-3, 1], 'should get correct Log domain with negative numbers');\n  t.deepEqual(getLogDomain([{\n    value: 1\n  }, {\n    value: 0\n  }, {\n    value: 3\n  }], valueAccessor), [0.00001, 3], 'should not contain a 0 in domain');\n  t.deepEqual(getLogDomain([], valueAccessor), [0.00001, 1], 'should have undefined domain for empty set');\n  t.end();\n});","file":"node/utils/data-scale-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> clamp","suites":[],"updatePoint":{"line":24,"column":24,"index":1433},"line":24,"code":"test('dataUtils -> clamp', t => {\n  t.equal(clamp([0, 1], 2), 1, 'should clamp 2 to 1 for [0,1]');\n  t.equal(clamp([0, 1], 0.5), 0.5, 'should not clamp 0.5 for [0,1]');\n  t.equal(clamp([-1, 1], -2), -1, 'should clamp -2 to -1 for [-1,1]');\n  t.equal(clamp([0, 10], 11), 10, 'should clamp 11 to 10 for [0,10]');\n  t.equal(clamp([0, 0], 1), 0, 'should clamp 1 to 0 for [0,0]');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> preciseRound","suites":[],"updatePoint":{"line":32,"column":31,"index":1831},"line":32,"code":"test('dataUtils -> preciseRound', t => {\n  t.equal(preciseRound(1.234, 2), '1.23', 'should round 1.234 correctly');\n  t.equal(preciseRound(13.234, 0), '13', 'should round 13.234 correctly');\n  t.equal(preciseRound(13, 2), '13.00', 'should round 13 correctly');\n  t.equal(preciseRound(1.437, 2), '1.44', 'should round 1.437 correctly');\n  t.equal(preciseRound(0.09999999999999987, 8), '0.10000000', 'should round 0.10000000 correctly');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> roundToFour","suites":[],"updatePoint":{"line":40,"column":30,"index":2281},"line":40,"code":"test('dataUtils -> roundToFour', t => {\n  t.equal(roundToFour(1.2344), 1.2344, 'should round 1.2344 to 4 decimals correctly');\n  t.equal(roundToFour(13.23445), 13.2345, 'should round 13.23445 to 4 decimals correctly');\n  t.equal(roundToFour(13), 13, 'should round 13 to 4 decimals correctly');\n  t.equal(roundToFour(1.437), 1.437, 'should round 1.437 to 4 decimals correctly');\n  t.equal(roundToFour(0.09999999999999987), 0.1, 'should round 0.09999999999999987 to 4 decimals correctly');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> getRoundingDecimalFromStep","suites":[],"updatePoint":{"line":48,"column":45,"index":2799},"line":48,"code":"test('dataUtils -> getRoundingDecimalFromStep', t => {\n  t.equal(getRoundingDecimalFromStep(1), 0, 'decimal of step=int should be 0');\n  t.equal(getRoundingDecimalFromStep(0.1), 1, 'decimal of step=0.1 should be 1');\n  t.equal(getRoundingDecimalFromStep(0.01), 2, 'decimal of step=0.01 should be 2');\n  t.equal(getRoundingDecimalFromStep(0.2), 1, 'decimal of step=0.2 should be 1');\n  t.equal(getRoundingDecimalFromStep(0.001), 3, 'decimal of step=0.001 should be 3');\n  t.equal(getRoundingDecimalFromStep(10), 0, 'decimal of step=10 should be 0');\n  t.equal(getRoundingDecimalFromStep(0.5), 1, 'decimal of step=0.5 should be 0');\n  t.equal(getRoundingDecimalFromStep(1.5), 1, 'decimal of step=1.5 should be 1');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> getRoundingDecimalFromStep","suites":[],"updatePoint":{"line":59,"column":45,"index":3527},"line":59,"code":"test('dataUtils -> getRoundingDecimalFromStep', t => {\n  t.equal(roundValToStep(0, 0.1, 0.11), 0.1, 'should round 0.11 to 0.1');\n  t.equal(roundValToStep(0, 0.1, 0.1), 0.1, 'should round 0.1 to 0.1');\n  t.equal(roundValToStep(1, 0.1, 1.16), 1.2, 'should round 1.16 to 1.2');\n  t.equal(roundValToStep(1, 1, 1.6), 2, 'should round 1.6 to 2');\n  t.equal(roundValToStep(1, 1, 1.32), 1, 'should round 1.32 to 1');\n  t.equal(roundValToStep(1, 0.01, 1.435), 1.44, 'should round 1.435 to 1.44');\n  t.equal(roundValToStep(1, 0.001, 1.4357), 1.436, 'should round 1.4357 to 1.436');\n  t.equal(roundValToStep(0, 0.2, 1.5), 1.6, 'should round 1.5 to 1.6');\n  t.equal(roundValToStep(0, 0.5, 20.25), 20.5, 'should round 20.25 to 20.5');\n  t.equal(roundValToStep(0.3, 0.3, 12.77), 12.9, 'should round 12.77 to 12.9');\n  t.equal(roundValToStep(-13, 0.1, -10.77), -10.8, 'should round -10.77 to -10.8');\n  t.equal(roundValToStep(-30, 1, -14.5), -14, 'should round -14.5 to -14');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> snapToMarks","suites":[],"updatePoint":{"line":74,"column":30,"index":4489},"line":74,"code":"test('dataUtils -> snapToMarks', t => {\n  const marks = [0, 1, 3, 4.7, 5, 6.4, 10];\n  t.equal(snapToMarks(0, marks), 0, 'should snap to nearest mark');\n  t.equal(snapToMarks(-1, marks), 0, 'should snap to nearest mark');\n  t.equal(snapToMarks(2.2, marks), 3, 'should snap to nearest mark');\n  t.equal(snapToMarks(10, marks), 10, 'should snap to nearest mark');\n  t.equal(snapToMarks(11, marks), 10, 'should snap to nearest mark');\n  t.equal(snapToMarks(5, marks), 5, 'should snap to nearest mark');\n  t.equal(snapToMarks(2, marks), 1, 'should snap to nearest mark');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> normalizeSliderValue","suites":[],"updatePoint":{"line":85,"column":39,"index":5080},"line":85,"code":"test('dataUtils -> normalizeSliderValue', t => {\n  t.equal(normalizeSliderValue(-1.1, 0, 1), -1, 'should normalize slider value based on step');\n  t.equal(normalizeSliderValue(4.4, 0, 1), 4, 'should round Val To Step');\n  t.equal(normalizeSliderValue(4.4, 0, 1, [1, 2, 3, 4.1, 5]), 4.1, 'should snap To Marks');\n  t.equal(normalizeSliderValue(4.4, 0, undefined), 4.4, 'is step is not defined return value');\n  t.equal(normalizeSliderValue(4.4, undefined, 1), 4.4, 'is minValue is not defined return value');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> arrayMove","suites":[],"updatePoint":{"line":93,"column":28,"index":5592},"line":93,"code":"test('dataUtils -> arrayMove', t => {\n  const arr = [4, 1, 9, 3, 11];\n  t.deepEqual(arrayMove(arr, 2, 1), [4, 9, 1, 3, 11], 'should move array');\n  t.deepEqual(arrayMove(arr, 2, 5), [4, 1, 3, 11, 9], 'should move array');\n  t.deepEqual(arrayMove(arr, 2, -1), [4, 1, 3, 11, 9], 'should move array');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> defaultFormatter","suites":[],"updatePoint":{"line":100,"column":35,"index":5913},"line":100,"code":"test('dataUtils -> defaultFormatter', t => {\n  t.equal(defaultFormatter(1), '1', 'defaultFormatter should be correct');\n  t.equal(defaultFormatter('a'), 'a', 'defaultFormatter should be correct');\n  t.equal(defaultFormatter(undefined), '', 'defaultFormatter should be correct');\n  t.equal(defaultFormatter(NaN), 'NaN', 'defaultFormatter should be correct');\n  t.equal(defaultFormatter(null), '', 'defaultFormatter should be correct');\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> getFormatter","suites":[],"updatePoint":{"line":108,"column":31,"index":6359},"line":108,"code":"test('dataUtils -> getFormatter', t => {\n  const TEST_CASES = [{\n    input: [undefined],\n    assert: formatter => {\n      t.equal(formatter, defaultFormatter, 'should return defaultformatter');\n    }\n  }, {\n    input: ['.1s'],\n    assert: [134, '100']\n  }, {\n    input: ['~%'],\n    assert: ['12.345', '12.35%']\n  }, {\n    input: ['none exist'],\n    assert: formatter => {\n      t.equal(formatter, defaultFormatter, 'should return defaultformatter');\n    }\n  }, {\n    // custom format\n    input: ['YYYY-MM-DD', {\n      type: ALL_FIELD_TYPES.timestamp\n    }],\n    assert: [1593724860289, '2020-07-02']\n  }, {\n    // custom format\n    input: [',.2r', {\n      type: ALL_FIELD_TYPES.integer\n    }],\n    assert: [4223, '4,200']\n  }, {\n    input: ['01'],\n    assert: [true, '1']\n  }, {\n    input: ['01'],\n    assert: [false, '0']\n  }, {\n    input: ['yn'],\n    assert: [false, 'no']\n  }, {\n    input: ['yn'],\n    assert: [true, 'yes']\n  }, {\n    input: ['L LT'],\n    assert: ['2011-04-10 00:00', '04/10/2011 12:00 AM']\n  }, {\n    input: ['L LT'],\n    assert: [null, '']\n  }, {\n    input: ['L LT'],\n    assert: [undefined, '']\n  }, {\n    input: ['L LT'],\n    assert: ['', '']\n  }, {\n    input: ['L'],\n    assert: ['2011-04-10', '04/10/2011']\n  }, {\n    input: ['L'],\n    assert: [null, '']\n  }];\n  TEST_CASES.forEach(tc => {\n    const formatter = getFormatter(...tc.input);\n    if (typeof tc.assert === 'function') {\n      tc.assert(formatter);\n    } else {\n      t.equal(formatter(tc.assert[0]), tc.assert[1], 'should return correct formatter');\n    }\n  });\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"dataUtils -> formatNumber","suites":[],"updatePoint":{"line":178,"column":31,"index":7924},"line":178,"code":"test('dataUtils -> formatNumber', t => {\n  const TEST_CASES = [{\n    input: ['3.14'],\n    output: '3.14',\n    message: 'field type is not given'\n  }, {\n    input: ['3.14123'],\n    output: '3.141',\n    message: 'field type is not given'\n  }, {\n    input: ['3'],\n    output: '3',\n    message: 'field type is not given'\n  }, {\n    input: ['331', 'integer'],\n    output: '331',\n    message: 'format integer'\n  }, {\n    input: ['-33.1', 'integer'],\n    output: '-33',\n    message: 'format integer'\n  }, {\n    input: ['1234', 'integer'],\n    output: '1,234',\n    message: 'format integer'\n  }, {\n    input: ['123456', 'integer'],\n    output: '123.5k',\n    message: 'format integer'\n  }, {\n    input: ['123456.2', 'real'],\n    output: '123.5k',\n    message: 'format real'\n  }, {\n    input: ['123.23', 'real'],\n    output: '123.2',\n    message: 'format real'\n  }, {\n    input: ['12.3', 'real'],\n    output: '12.3',\n    message: 'format real'\n  }, {\n    input: ['12.345', 'real'],\n    output: '12.35',\n    message: 'format real'\n  }];\n  TEST_CASES.forEach(tc => {\n    const output = formatNumber(...tc.input);\n    t.equal(output, tc.output, `formatNumber should be correct when ${tc.message}`);\n  });\n  t.end();\n});","file":"node/utils/data-utils-test.js","skipped":false,"dir":"test"},{"name":"datasetUtils.findDefaultColorField","suites":[],"updatePoint":{"line":54,"column":40,"index":2029},"line":54,"code":"test('datasetUtils.findDefaultColorField', t => {\n  for (const tc of DEFAULT_FIELD_TEST_CASES) {\n    const dataset = createNewDataEntry({\n      info: {\n        id: 'taro'\n      },\n      data: processCsvData(tc.csv)\n    }).taro;\n    const defaultField = findDefaultColorField(dataset);\n    if (!tc.expected) {\n      t.notOk(defaultField, `${tc.name}: default field is null`);\n    } else {\n      t.equals(defaultField.name, tc.expected, `${tc.name}: default field name is OK`);\n    }\n  }\n  t.end();\n});","file":"node/utils/dataset-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> isDrawingActive","suites":[],"updatePoint":{"line":27,"column":41,"index":1498},"line":27,"code":"test('editorLayerUtils -> isDrawingActive', t => {\n  t.equal(EditorLayerUtils.isDrawingActive(true, EDITOR_MODES.EDIT), false, 'Should return false for non-drawing mode');\n  t.equal(EditorLayerUtils.isDrawingActive(false, EDITOR_MODES.DRAW_POLYGON), false, 'Should return false as editor UI is disactivated');\n  t.equal(EditorLayerUtils.isDrawingActive(true, EDITOR_MODES.DRAW_POLYGON), true, 'Should return true for activated editor UI and draw mode');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> getCursor","suites":[],"updatePoint":{"line":33,"column":35,"index":1961},"line":33,"code":"test('editorLayerUtils -> getCursor', t => {\n  const {\n    editor\n  } = INITIAL_VIS_STATE;\n  const mockSettings = {\n    editorMenuActive: true,\n    editor\n  };\n  t.equal(EditorLayerUtils.getCursor(mockSettings), 'crosshair', 'Should return crosshair for active drawing mode');\n  mockSettings.editorMenuActive = false;\n  t.equal(EditorLayerUtils.getCursor(mockSettings), null, 'Should return null as editor has no suggestions about cursor');\n  mockSettings.hoverInfo = {\n    layer: {\n      id: EDITOR_LAYER_ID\n    }\n  };\n  mockSettings.editor = {\n    ...mockSettings.editor,\n    selectedFeature: {}\n  };\n  t.equal(EditorLayerUtils.getCursor(mockSettings), 'move', 'Should return move cursor');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> getTooltip","suites":[],"updatePoint":{"line":56,"column":36,"index":2670},"line":56,"code":"test('editorLayerUtils -> getTooltip', t => {\n  const {\n    editor\n  } = INITIAL_VIS_STATE;\n  const info = {\n    layer: {\n      state: {\n        mode: {\n          _clickSequence: null\n        }\n      }\n    },\n    object: {}\n  };\n  t.equal(EditorLayerUtils.getTooltip(info, {\n    editor: {\n      ...editor,\n      selectionContext: {\n        rightClick: true\n      }\n    },\n    theme: {},\n    editorMenuActive: true\n  }), null, 'Should return null when the feature menu is visible');\n  info.layer.state.mode._clickSequence = [1];\n  t.equal(EditorLayerUtils.getTooltip(info, {\n    editor,\n    theme: {},\n    editorMenuActive: true\n  }), null, 'Should return null as drawing is active and started');\n  info.layer.state.mode._clickSequence = [];\n  t.equal(EditorLayerUtils.getTooltip(info, {\n    editor,\n    theme: {},\n    editorMenuActive: true\n  })?.text, 'Click to start new feature', 'Should return a tooltip as drawing is active and started');\n  info.layer.id = EDITOR_LAYER_ID;\n  t.deepEqual(EditorLayerUtils.getTooltip({\n    ...info,\n    object: {\n      id: 1\n    }\n  }, {\n    editor: {\n      ...editor,\n      selectedFeature: {\n        id: 1\n      }\n    },\n    theme: {},\n    editorMenuActive: false\n  })?.text, 'Right click to view options\\nDrag to move the feature', 'Should return a tooltip for selected feature');\n  t.equal(EditorLayerUtils.getTooltip({\n    ...info,\n    object: {\n      geometry: {\n        type: 'Point'\n      }\n    }\n  }, {\n    editor,\n    theme: {},\n    editorMenuActive: false\n  })?.text, 'Drag to move the point', 'Should return a tooltip for hovered point');\n  t.equal(EditorLayerUtils.getTooltip({\n    ...info,\n    object: {\n      properties: {\n        guideType: 'tentative'\n      }\n    }\n  }, {\n    editor,\n    theme: {},\n    editorMenuActive: false\n  })?.text, 'Drag to move the point', 'Should return a tooltip for hovered tentative point');\n  t.equal(EditorLayerUtils.getTooltip({\n    ...info,\n    object: {\n      properties: {\n        editHandleType: 'intermediate'\n      }\n    }\n  }, {\n    editor,\n    theme: {},\n    editorMenuActive: false\n  })?.text, 'Click to insert a point', 'Should return a tooltip for hovered lines');\n  t.equal(EditorLayerUtils.getTooltip(info, {\n    editor,\n    theme: {},\n    editorMenuActive: false\n  })?.text, 'Click to select the feature\\nRight click to view options', 'Should return a tooltip for not selected feature');\n  info.layer.id = 'any';\n  t.equal(EditorLayerUtils.getTooltip(info, {\n    editor,\n    theme: {},\n    editorMenuActive: false\n  }), null, 'Shouldnt return tooltip');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> onHover","suites":[],"updatePoint":{"line":157,"column":33,"index":5237},"line":157,"code":"test('editorLayerUtils -> onHover', t => {\n  const {\n    editor\n  } = INITIAL_VIS_STATE;\n  const info = {\n    layer: {},\n    object: {}\n  };\n  const hoverInfo = {\n    layer: {}\n  };\n  t.equal(EditorLayerUtils.onHover(info, {\n    editor,\n    editorMenuActive: true,\n    hoverInfo\n  }), true, 'Should return true as drawing is active');\n  t.equal(EditorLayerUtils.onHover(info, {\n    editor,\n    editorMenuActive: false,\n    hoverInfo\n  }), false, \"Should return false as drawing isn't active\");\n  info.layer.id = EDITOR_LAYER_ID;\n  t.equal(EditorLayerUtils.onHover(info, {\n    editor,\n    editorMenuActive: false,\n    hoverInfo\n  }), false, \"Should return false as info and hoverInfo aren't yet synced\");\n  hoverInfo.layer.id = EDITOR_LAYER_ID;\n  t.equal(EditorLayerUtils.onHover(info, {\n    editor,\n    editorMenuActive: false,\n    hoverInfo\n  }), true, 'Should return true for editor layer');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> onClick","suites":[],"updatePoint":{"line":192,"column":33,"index":6146},"line":192,"code":"test('editorLayerUtils -> onClick', t => {\n  const {\n    editor\n  } = INITIAL_VIS_STATE;\n  const info = {\n    layer: {},\n    object: {}\n  };\n  const event = {};\n  const {\n    onLayerClick,\n    setSelectedFeature\n  } = VisStateActions;\n  t.equal(EditorLayerUtils.onClick(info, event, {\n    editor,\n    editorMenuActive: true,\n    onLayerClick,\n    setSelectedFeature\n  }), true, 'Should return true - onClick is handled as drawing is active');\n  t.equal(EditorLayerUtils.onClick(info, event, {\n    editor,\n    editorMenuActive: false,\n    onLayerClick,\n    setSelectedFeature\n  }), false, \"Should return false - onClick isn't handled\");\n  info.layer.id = EDITOR_LAYER_ID;\n  t.equal(EditorLayerUtils.onClick(info, event, {\n    editor,\n    editorMenuActive: false,\n    onLayerClick,\n    setSelectedFeature\n  }), true, 'Should return true - onClick is handled');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"editorLayerUtils -> getEditorLayer","suites":[],"updatePoint":{"line":226,"column":40,"index":7027},"line":226,"code":"test('editorLayerUtils -> getEditorLayer', t => {\n  const {\n    editor\n  } = INITIAL_VIS_STATE;\n  const editorLayer = getEditorLayer({\n    editorMenuActive: false,\n    editor,\n    onSetFeatures: VisStateActions.setFeatures,\n    setSelectedFeature: VisStateActions.setSelectedFeature,\n    featureCollection: {\n      features: [],\n      type: 'FeatureCollection'\n    },\n    selectedFeatureIndexes: [],\n    viewport: null\n  });\n  t.ok(editorLayer instanceof EditableGeoJsonLayer, 'Should return an editable layer');\n  t.end();\n});","file":"node/utils/editor-utils-test.js","skipped":false,"dir":"test"},{"name":"exportUtils -> ExportJson","suites":[],"updatePoint":{"line":26,"column":31,"index":1479},"line":26,"code":"test('exportUtils -> ExportJson', t => {\n  const state = keplerGlReducer(undefined, registerEntry({\n    id: 'test'\n  })).test;\n  const body = exportToJsonString(getMapJSON(state));\n  getScaleFromImageSize;\n  t.equal(typeof body, 'string', 'Should validate the type of body to be a string');\n  t.doesNotThrow(() => {\n    JSON.parse(body);\n  }, 'Should not throw when trying to parse body');\n  t.end();\n});","file":"node/utils/export-utils-test.js","skipped":false,"dir":"test"},{"name":"exportUtils -> getScaleFromImageSize","suites":[],"updatePoint":{"line":38,"column":42,"index":1895},"line":38,"code":"test('exportUtils -> getScaleFromImageSize', t => {\n  t.equal(getScaleFromImageSize(800, 600, 1400, 990), 0.5714285714285714, 'Should compute the right scale');\n  t.equal(getScaleFromImageSize(800, 600, 1400), 1, 'Should return 1 because we are not passing mapH');\n  t.equal(getScaleFromImageSize(800, 600, 1400, -1), 1, 'Should return 1 because mapH is negative');\n  t.equal(getScaleFromImageSize(800, 600, 1400, 0), 1, 'Should return 1 because mapH is 0');\n  t.end();\n});","file":"node/utils/export-utils-test.js","skipped":false,"dir":"test"},{"name":"exportUtils -> calculateExportImageSize","suites":[],"updatePoint":{"line":45,"column":45,"index":2372},"line":45,"code":"test('exportUtils -> calculateExportImageSize', t => {\n  t.deepEqual(calculateExportImageSize({\n    mapW: 1400,\n    mapH: 990,\n    ratio: EXPORT_IMG_RATIOS.SCREEN,\n    resolution: RESOLUTIONS.ONE_X\n  }), {\n    scale: 1,\n    imageW: 1400,\n    imageH: 990\n  }, 'Should calculate the correct export image size');\n  t.equal(calculateExportImageSize({\n    mapW: -1,\n    mapH: 990,\n    ratio: EXPORT_IMG_RATIOS.SCREEN,\n    resolution: RESOLUTIONS.ONE_X\n  }), null, 'Should return null because mapW is negative');\n  t.equal(calculateExportImageSize({\n    mapW: 1440,\n    mapH: -1,\n    ratio: EXPORT_IMG_RATIOS.SCREEN,\n    resolution: RESOLUTIONS.ONE_X\n  }), null, 'Should return null because mapH is negative');\n  t.deepEqual(calculateExportImageSize({\n    mapW: 1440,\n    mapH: 990,\n    ratio: EXPORT_IMG_RATIOS.CUSTOM,\n    resolution: RESOLUTIONS.ONE_X\n  }), {\n    scale: undefined,\n    imageW: 1440,\n    imageH: 990\n  }, 'Should return scale null because of custom ratio');\n  t.deepEqual(calculateExportImageSize({\n    mapW: 1440,\n    mapH: 990,\n    ratio: 'not-valid',\n    resolution: RESOLUTIONS.ONE_X\n  }), {\n    scale: 1,\n    imageW: 1440,\n    imageH: 1080\n  }, 'Should return a correct valid with a non valid ratio param');\n  t.deepEqual(calculateExportImageSize({\n    mapW: 1440,\n    mapH: 990,\n    ratio: EXPORT_IMG_RATIOS.SCREEN,\n    resolution: 'not-valid'\n  }), {\n    scale: 1,\n    imageW: 1440,\n    imageH: 990\n  }, 'Should return a correct valid with a non valid resolution param');\n  t.end();\n});","file":"node/utils/export-utils-test.js","skipped":false,"dir":"test"},{"name":"exportUtils -> isMSEdge","suites":[],"updatePoint":{"line":100,"column":29,"index":3862},"line":100,"code":"test('exportUtils -> isMSEdge', t => {\n  t.equal(isMSEdge({}), false, 'Should return false because no navigator is defined');\n  t.equal(isMSEdge({\n    navigator: {}\n  }), false, 'Should return false because msSaveOrOpenBlob is not defined');\n  t.equal(isMSEdge({\n    navigator: {\n      msSaveOrOpenBlob: () => {}\n    }\n  }), true, 'Should return true because both navigator and msSaveOrOpenBlob are defined');\n  t.end();\n});","file":"node/utils/export-utils-test.js","skipped":false,"dir":"test"},{"name":"exportUtils -> exportToJsonString","suites":[],"updatePoint":{"line":112,"column":39,"index":4297},"line":112,"code":"test('exportUtils -> exportToJsonString', t => {\n  t.equal(exportToJsonString({\n    test: 1\n  }), '{\"test\":1}', 'Should convert object to string');\n  t.end();\n});","file":"node/utils/export-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> adjustValueToFilterDomain","suites":[],"updatePoint":{"line":29,"column":46,"index":1708},"line":29,"code":"test('filterUtils -> adjustValueToFilterDomain', t => {\n  // TODO: needs id\n  const rangeFilter = getDefaultFilter();\n  rangeFilter.type = FILTER_TYPES.range;\n  rangeFilter.domain = [0, 1];\n  t.deepEqual(adjustValueToFilterDomain([0, 0.5], rangeFilter), [0, 0.5], 'should return value matched to range filter');\n  t.deepEqual(adjustValueToFilterDomain([-1, 0.5], rangeFilter), [0, 0.5], 'should return value adjust to range filter');\n  t.deepEqual(adjustValueToFilterDomain([0.1, 1.5], rangeFilter), [0.1, 1], 'should return value adjust to range filter');\n  t.deepEqual(adjustValueToFilterDomain([1.1, 2], rangeFilter), [0, 1], 'should return value adjust to range filter');\n  t.deepEqual(adjustValueToFilterDomain(null, rangeFilter), [0, 1], 'should return value adjust to range filter');\n  t.deepEqual(adjustValueToFilterDomain([undefined, 0.5], rangeFilter), [0, 0.5], 'should return value adjust to range filter');\n\n  // TODO needs id\n  const multiSelectFilter = getDefaultFilter();\n  multiSelectFilter.type = FILTER_TYPES.multiSelect;\n  multiSelectFilter.domain = ['a', 'b', 'c'];\n  t.deepEqual(adjustValueToFilterDomain(['a', 'b'], multiSelectFilter), ['a', 'b'], 'should return value matched to multiSelect filter');\n  t.deepEqual(adjustValueToFilterDomain(['a', 'b', 'd'], multiSelectFilter), ['a', 'b'], 'should return value matched to multiSelect filter');\n  t.deepEqual(adjustValueToFilterDomain(['a', 'b', null], multiSelectFilter), ['a', 'b'], 'should return value matched to multiSelect filter');\n  t.deepEqual(adjustValueToFilterDomain(null, multiSelectFilter), [], 'should return [] if nothing matched to multiSelect filter');\n  t.deepEqual(adjustValueToFilterDomain([1, 2], multiSelectFilter), [], 'should return [] if nothing matched to multiSelect filter');\n\n  // TODO needs id\n  const selectFilter = getDefaultFilter();\n  selectFilter.type = FILTER_TYPES.select;\n  selectFilter.domain = ['a', 'b', 'c'];\n  t.equal(adjustValueToFilterDomain('a', selectFilter), 'a', 'should return value matched to select filter');\n  t.equal(adjustValueToFilterDomain(['a', 'b'], selectFilter), true, 'should return true if nothing matched to select filter');\n  t.equal(adjustValueToFilterDomain(null, selectFilter), true, 'should return true if nothing matched to select filter');\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> getDatasetFieldIndexForFilter","suites":[],"updatePoint":{"line":60,"column":50,"index":4012},"line":60,"code":"test('filterUtils -> getDatasetFieldIndexForFilter', t => {\n  const dataId = 'test-this-id';\n  let fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: [dataId],\n    fieldIdx: [3]\n  });\n  t.equal(fieldIndex, 3, 'FieldIndex should be 3');\n  fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: ['different-id', dataId],\n    fieldIdx: [3, 5]\n  });\n  t.equal(fieldIndex, 5, 'FieldIndex should be 5');\n  fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: ['different-id']\n  });\n  t.equal(fieldIndex, -1, 'FieldIndex should be -1');\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> isValidFilterValue","suites":[],"updatePoint":{"line":78,"column":39,"index":4582},"line":78,"code":"test('filterUtils -> isValidFilterValue', t => {\n  t.equal(isValidFilterValue(null, true), false, 'Should return false because type is null');\n  t.equal(isValidFilterValue(FILTER_TYPES.select, true), true, 'Should return true because type is select and value is true');\n  t.equal(isValidFilterValue(FILTER_TYPES.select, false), true, 'Should return true because type is select and value is true');\n  t.equal(isValidFilterValue(FILTER_TYPES.timeRange, false), false, 'Should return false because type is timeRange and value is not an array');\n  t.equal(isValidFilterValue(FILTER_TYPES.timeRange, []), true, 'Should return true because type is timeRange and value is an empty array');\n  t.equal(isValidFilterValue(FILTER_TYPES.timeRange, [1]), true, 'Should return false because type is timeRange and value is an array');\n  t.equal(isValidFilterValue(FILTER_TYPES.multiSelect, true), false, 'Should return false because type is multiSelect and value is not an array');\n  t.equal(isValidFilterValue(FILTER_TYPES.multiSelect, []), false, 'Should return false because type is multiSelect and value is an empty array');\n  t.equal(isValidFilterValue(FILTER_TYPES.multiSelect, [1]), true, 'Should return false because type is multiSelect and value is an array');\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> isInPolygon","suites":[],"updatePoint":{"line":90,"column":32,"index":5845},"line":90,"code":"test('filterUtils -> isInPolygon', t => {\n  t.equal(isInPolygon([120.47448, 23.667604], {\n    type: 'Feature',\n    geometry: {\n      type: 'Polygon',\n      coordinates: [[[120.21949418752885, 23.755486652156186], [120.21949418752885, 23.221461105318184], [121.05994828909135, 23.221461105318184], [121.05994828909135, 23.755486652156186], [120.21949418752885, 23.755486652156186]]]\n    },\n    properties: {\n      renderType: 'Rectangle',\n      isClosed: true,\n      bbox: {\n        xmin: 120.21949418752885,\n        xmax: null,\n        ymin: 23.755486652156186,\n        ymax: null\n      },\n      isVisible: true,\n      filterId: 'z1ilfjv6'\n    },\n    id: '036d9e21-af6b-4350-aab9-f1ce37c35cce'\n  }), true, 'Should return true because the point is within the polygon');\n  t.equal(isInPolygon([119.47448, 23.667604], {\n    type: 'Feature',\n    geometry: {\n      type: 'Polygon',\n      coordinates: [[[120.21949418752885, 23.755486652156186], [120.21949418752885, 23.221461105318184], [121.05994828909135, 23.221461105318184], [121.05994828909135, 23.755486652156186], [120.21949418752885, 23.755486652156186]]]\n    },\n    properties: {\n      renderType: 'Rectangle',\n      isClosed: true,\n      bbox: {\n        xmin: 120.21949418752885,\n        xmax: null,\n        ymin: 23.755486652156186,\n        ymax: null\n      },\n      isVisible: true,\n      filterId: 'z1ilfjv6'\n    },\n    id: '036d9e21-af6b-4350-aab9-f1ce37c35cce'\n  }), false, 'Should return false because the point is not within the polygon');\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> validatePolygonFilter","suites":[],"updatePoint":{"line":133,"column":42,"index":7372},"line":133,"code":"test('filterUtils -> validatePolygonFilter', t => {\n  const filter = {\n    layerId: ['layer1'],\n    dataId: ['puppy'],\n    value: {\n      id: 'feature_1',\n      geometry: {\n        coordinates: []\n      }\n    },\n    type: 'polygon'\n  };\n  const dataset = {\n    id: 'puppy'\n  };\n  const layers = [{\n    id: 'layer1'\n  }];\n  t.deepEqual(validatePolygonFilter(dataset, filter, layers).filter, {\n    ...filter,\n    fieldIdx: [],\n    freeze: true\n  }, 'Should positively validate filter');\n  t.equal(validatePolygonFilter(dataset, filter, [{\n    id: 'layer2'\n  }]).filter, null, 'Should not validate the filter since layers are not matched');\n  t.equal(validatePolygonFilter(dataset, {}, layers).filter, null, 'Should not validate empty filter');\n  t.deepEqual(validatePolygonFilter(dataset, {\n    ...filter,\n    dataId: ['non_valid']\n  }, layers).filter, null, 'Should not validate filter with non existing dataId');\n  t.deepEqual(validatePolygonFilter(dataset, {\n    ...filter,\n    value: {\n      id: 'wrong-value-for-polygon-type'\n    }\n  }, layers).filter, null, 'Should not validate filter given type and value without corresponding layer');\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> Polygon getFilterFunction ","suites":[],"updatePoint":{"line":172,"column":47,"index":8534},"line":172,"code":"test('filterUtils -> Polygon getFilterFunction ', t => {\n  const dataset = {\n    id: 'puppy',\n    data: mockPolygonData.data,\n    fields: mockPolygonData.fields\n  };\n  const dataContainer = createDataContainer(dataset.data);\n  const {\n    layers,\n    data\n  } = mockPolygonData;\n  const polygonFilter = generatePolygonFilter(layers, mockPolygonFeature);\n  let filterFunction = getFilterFunction(null, dataset.id, polygonFilter, [], dataContainer);\n  t.equal(filterFunction(data[0], 0), true, `Should return true because layer list is empty`);\n  filterFunction = getFilterFunction(null, 'puppy-2', polygonFilter, layers, dataContainer);\n  t.equal(filterFunction(data[0], 0), true, `${data[0][0]} - ${data[0][1]} should be inside the range`);\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> diffFilters","suites":[],"updatePoint":{"line":193,"column":32,"index":9312},"line":193,"code":"test('filterUtils -> diffFilters', t => {\n  const testCases = [{\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    },\n    oldFilterRecord: undefined,\n    result: {\n      dynamicDomain: null,\n      fixedDomain: null,\n      cpu: null,\n      gpu: null\n    }\n  }, {\n    filterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    },\n    oldFilterRecord: {\n      dynamicDomain: [],\n      fixedDomain: [],\n      cpu: [],\n      gpu: []\n    },\n    result: {\n      dynamicDomain: null,\n      fixedDomain: null,\n      cpu: null,\n      gpu: null\n    }\n  }, {\n    filterRecord: {\n      dynamicDomain: [{\n        id: 'aa',\n        name: 'hello',\n        value: 'bb'\n      }],\n      fixedDomain: [{\n        id: 'bb',\n        name: 'ab',\n        value: 'ab'\n      }],\n      cpu: [{\n        id: 'dd',\n        name: 'hey',\n        value: 'ee'\n      }, {\n        id: 'ee',\n        name: 'ee',\n        value: 'ff'\n      }],\n      gpu: []\n    },\n    oldFilterRecord: {\n      dynamicDomain: [{\n        id: 'aa',\n        name: 'hello',\n        value: 'bb'\n      }],\n      fixedDomain: [{\n        id: 'bb',\n        name: 'cd',\n        value: 'ab'\n      }, {\n        id: 'cc',\n        name: 'world',\n        value: 'dd'\n      }],\n      cpu: [{\n        id: 'ee',\n        name: 'ee',\n        value: 'gg'\n      }],\n      gpu: []\n    },\n    result: {\n      dynamicDomain: null,\n      fixedDomain: {\n        bb: 'name_changed',\n        cc: 'deleted'\n      },\n      cpu: {\n        dd: 'added',\n        ee: 'value_changed'\n      },\n      gpu: null\n    }\n  }];\n  testCases.forEach(({\n    filterRecord,\n    oldFilterRecord,\n    result\n  }) => {\n    t.deepEqual(diffFilters(filterRecord, oldFilterRecord), result, 'diff filters should be correct');\n  });\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"filterUtils -> getTimestampFieldDomain","suites":[],"updatePoint":{"line":294,"column":44,"index":11148},"line":294,"code":"test('filterUtils -> getTimestampFieldDomain', t => {\n  const timeData = {\n    zero: {\n      input: ['2016-10-01 09:45:39', '2016-10-01 09:45:39'],\n      expect: {\n        domain: [1475315139000, 1475315140000],\n        mappedValue: [1475315139000, 1475315139000],\n        histogram: [{\n          count: 2,\n          x0: 1475315139000,\n          x1: 1475315139000\n        }],\n        enlargedHistogram: [{\n          count: 2,\n          x0: 1475315139000,\n          x1: 1475315139000\n        }],\n        step: 0.05,\n        defaultTimeFormat: 'L LTS'\n      }\n    },\n    tiny: {\n      input: ['2016-10-01 09:45:39.001', '2016-10-01 09:45:39.002', '2016-10-01 09:45:39.003'],\n      expect: {\n        domain: [1475315139001, 1475315139003],\n        mappedValue: [1475315139001, 1475315139002, 1475315139003],\n        ...getHistogram([1475315139001, 1475315139003], [1475315139001, 1475315139002, 1475315139003]),\n        step: 0.1,\n        defaultTimeFormat: 'L LTS'\n      }\n    },\n    small: {\n      input: ['2016-10-01 09:45:39.010', '2016-10-01 09:45:39.020', '2016-10-01 09:45:39.030'],\n      expect: {\n        domain: [1475315139010, 1475315139030],\n        mappedValue: [1475315139010, 1475315139020, 1475315139030],\n        histogram: [],\n        enlargedHistogram: [],\n        step: 1,\n        defaultTimeFormat: 'L LTS'\n      }\n    },\n    medium: {\n      input: ['2016-10-01 09:45:39.100', '2016-10-01 09:45:39.200', '2016-10-01 09:45:39.300'],\n      expect: {\n        domain: [1475315139100, 1475315139300],\n        mappedValue: [1475315139100, 1475315139200, 1475315139300],\n        histogram: [],\n        enlargedHistogram: [],\n        step: 5,\n        defaultTimeFormat: 'L LTS'\n      }\n    },\n    large: {\n      input: ['2016-10-01 09:45:39', '2016-10-01 09:45:45'],\n      expect: {\n        domain: [1475315139000, 1475315145000],\n        mappedValue: [1475315139000, 1475315145000],\n        histogram: [],\n        enlargedHistogram: [],\n        step: 1000,\n        defaultTimeFormat: 'L LTS'\n      }\n    }\n  };\n  Object.keys(timeData).forEach(key => {\n    const dataContainer = createDataContainer(timeData[key].input.map(d => [d]));\n    const valueAccessor = dc => d => moment.utc(dc.valueAt(d.index, 0)).valueOf();\n    const tsFieldDomain = getTimestampFieldDomain(dataContainer, valueAccessor(dataContainer));\n    t.deepEqual(Object.keys(tsFieldDomain).sort(), Object.keys(timeData[key].expect).sort(), 'domain should have same keys');\n    Object.keys(timeData[key].expect).forEach(k => {\n      // histogram is created by d3, only need to test they exist\n      if (k === 'histogram' || k === 'enlargedHistogram') {\n        t.ok(tsFieldDomain[k].length, `should create ${k}`);\n      } else {\n        t.deepEqual(tsFieldDomain[k], timeData[key].expect[k], `time domain ${k} should be the same`);\n      }\n    });\n  });\n  t.end();\n});","file":"node/utils/filter-utils-test.js","skipped":false,"dir":"test"},{"name":"gpuFilterUtils -> resetFilterGpuMode","suites":[],"updatePoint":{"line":23,"column":42,"index":1313},"line":23,"code":"test('gpuFilterUtils -> resetFilterGpuMode', t => {\n  const testFilters = [{\n    id: '1',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '2',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '3',\n    dataId: ['smoothie'],\n    gpu: false\n  }, {\n    id: '4',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '5',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '6',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '7',\n    dataId: ['milkshake'],\n    gpu: true\n  }, {\n    id: '8',\n    dataId: ['milkshake'],\n    gpu: false\n  }];\n  const expectedFilters = [{\n    id: '1',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '2',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '3',\n    dataId: ['smoothie'],\n    gpu: false\n  }, {\n    id: '4',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '5',\n    dataId: ['smoothie'],\n    gpu: true\n  }, {\n    id: '6',\n    dataId: ['smoothie'],\n    gpu: false\n  }, {\n    id: '7',\n    dataId: ['milkshake'],\n    gpu: true\n  }, {\n    id: '8',\n    dataId: ['milkshake'],\n    gpu: false\n  }];\n  const result = resetFilterGpuMode(testFilters);\n  t.deepEqual(result, expectedFilters, 'should reset gpu mode');\n  t.end();\n});","file":"node/utils/gpu-filter-utils-test.js","skipped":false,"dir":"test"},{"name":"gpuFilterUtils -> assignGpuChannel","suites":[],"updatePoint":{"line":94,"column":40,"index":2514},"line":94,"code":"test('gpuFilterUtils -> assignGpuChannel', t => {\n  const testCases = [{\n    gpuFilter: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true\n    },\n    filters: [{\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }],\n    result: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }\n  }, {\n    gpuFilter: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    },\n    filters: [{\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }],\n    result: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }\n  }, {\n    gpuFilter: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true\n    },\n    filters: [{\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }],\n    result: {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }\n  }, {\n    gpuFilter: {\n      id: '5',\n      dataId: ['a', 'b'],\n      gpu: true\n    },\n    filters: [{\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [3]\n    }, {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '4',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [2]\n    }],\n    result: {\n      id: '5',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [1, 1]\n    }\n  }, {\n    gpuFilter: {\n      id: '5',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [1]\n    },\n    filters: [{\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [3]\n    }, {\n      id: '3',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [0, 2]\n    }, {\n      id: '4',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [2]\n    }],\n    result: {\n      id: '5',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [1, 1]\n    }\n  }, {\n    gpuFilter: {\n      id: '6',\n      dataId: ['a'],\n      gpu: true\n    },\n    filters: [{\n      id: '1',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [3]\n    }, {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [2]\n    }, {\n      id: '4',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '5',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }],\n    result: {\n      id: '6',\n      dataId: ['a'],\n      gpu: false\n    }\n  }];\n  testCases.forEach(tc => {\n    t.deepEqual(assignGpuChannel(tc.gpuFilter, tc.filters), tc.result, 'should assign correct channel');\n  });\n  t.end();\n});","file":"node/utils/gpu-filter-utils-test.js","skipped":false,"dir":"test"},{"name":"gpuFilterUtils -> assignGpuChannels","suites":[],"updatePoint":{"line":280,"column":41,"index":5637},"line":280,"code":"test('gpuFilterUtils -> assignGpuChannels', t => {\n  const testCases = [{\n    filters: [{\n      id: '1',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true\n    }, {\n      id: '3',\n      dataId: ['b'],\n      gpu: true\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: false\n    }],\n    result: [{\n      id: '1',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '3',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: false\n    }]\n  }, {\n    filters: [{\n      id: '1',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '2',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [2]\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: false\n    }, {\n      id: '5',\n      dataId: ['a'],\n      gpu: true\n    }, {\n      id: '6',\n      dataId: ['b'],\n      gpu: true\n    }, {\n      id: '7',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }],\n    result: [{\n      id: '1',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '2',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '3',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [2]\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: false\n    }, {\n      id: '5',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [0]\n    }, {\n      id: '6',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [2]\n    }, {\n      id: '7',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [0]\n    }]\n  }, {\n    filters: [{\n      id: '1',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [1, 0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '3',\n      dataId: ['b', 'a'],\n      gpu: true\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: true\n    }],\n    result: [{\n      id: '1',\n      dataId: ['a', 'b'],\n      gpu: true,\n      gpuChannel: [0, 0]\n    }, {\n      id: '2',\n      dataId: ['a'],\n      gpu: true,\n      gpuChannel: [1]\n    }, {\n      id: '3',\n      dataId: ['b', 'a'],\n      gpu: true,\n      gpuChannel: [1, 2]\n    }, {\n      id: '4',\n      dataId: ['b'],\n      gpu: true,\n      gpuChannel: [2]\n    }]\n  }];\n  testCases.forEach(tc => {\n    t.deepEqual(assignGpuChannels(tc.filters), tc.result, 'should assign correct channel');\n  });\n  t.end();\n});","file":"node/utils/gpu-filter-utils-test.js","skipped":false,"dir":"test"},{"name":"gpuFilterUtils -> getDatasetFieldIndexForFilter","suites":[],"updatePoint":{"line":436,"column":53,"index":8291},"line":436,"code":"test('gpuFilterUtils -> getDatasetFieldIndexForFilter', t => {\n  const dataId = 'test-this-id';\n  let fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: [dataId],\n    fieldIdx: [3]\n  });\n  t.equal(fieldIndex, 3, 'FieldIndex should be 3');\n  fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: ['different-id', dataId],\n    fieldIdx: [3, 5]\n  });\n  t.equal(fieldIndex, 5, 'FieldIndex should be 5');\n  fieldIndex = getDatasetFieldIndexForFilter(dataId, {\n    dataId: ['different-id']\n  });\n  t.equal(fieldIndex, -1, 'FieldIndex should be -1');\n  t.end();\n});","file":"node/utils/gpu-filter-utils-test.js","skipped":false,"dir":"test"},{"name":"interactionUtil -> findFieldsToShow","suites":[],"updatePoint":{"line":51,"column":41,"index":1758},"line":51,"code":"test('interactionUtil -> findFieldsToShow', t => {\n  const dataId = 'random_stuff';\n  const someFields = [...DEFAULT_TOOLTIP_FIELDS.slice(0, 2).map(d => ({\n    name: d\n  })), ...[{\n    name: 'random'\n  }, {\n    name: 'something_else'\n  }]];\n  const expectedFields = [{\n    name: 'random',\n    format: null\n  }, {\n    name: 'something_else',\n    format: null\n  }];\n  t.deepEqual(findFieldsToShow({\n    fields: someFields,\n    id: dataId\n  }), {\n    random_stuff: expectedFields\n  }, 'should find 2 default trip layers');\n  t.end();\n});","file":"node/utils/interaction-utils-test.js","skipped":false,"dir":"test"},{"name":"interactionUtil -> autoFindTooltipFields","suites":[],"updatePoint":{"line":75,"column":46,"index":2298},"line":75,"code":"test('interactionUtil -> autoFindTooltipFields', t => {\n  const expectedFields = {\n    test: [{\n      name: 'hex_id',\n      format: null\n    }, {\n      name: 'a',\n      format: null\n    }, {\n      name: 'b',\n      format: null\n    }]\n  };\n  t.deepEqual(findFieldsToShow({\n    fields,\n    id: 'test',\n    maxDefaultTooltips: 3\n  }), expectedFields, 'should filter out all default geometry fields and return first 3');\n  t.end();\n});","file":"node/utils/interaction-utils-test.js","skipped":false,"dir":"test"},{"name":"interactionUtil -> getTooltipDisplayDeltaValue","suites":[],"updatePoint":{"line":95,"column":52,"index":2736},"line":95,"code":"test('interactionUtil -> getTooltipDisplayDeltaValue', t => {\n  const tooltipConfig = StateWTooltipFormat.visState.interactionConfig.tooltip.config;\n  const dataset = StateWTooltipFormat.visState.datasets[testGeoJsonDataId];\n  const testFieldIdx = dataset.fields.findIndex(f => f.name === 'TRIPS');\n  const item = tooltipConfig.fieldsToShow[testGeoJsonDataId].find(fs => fs.name === 'TRIPS');\n  const TEST_CASES = [{\n    input: {\n      primaryData: dataset.dataContainer.row(0),\n      // field.displayFormat has been used to replace tooltipConfig.format\n      field: {\n        ...dataset.fields[testFieldIdx],\n        displayFormat: item.format\n      },\n      compareType: COMPARE_TYPES.ABSOLUTE,\n      data: dataset.dataContainer.row(1),\n      fieldIdx: testFieldIdx,\n      item\n    },\n    output: `${TOOLTIP_MINUS_SIGN}7.000`,\n    message: 'should display absolute delta value'\n  }, {\n    input: {\n      primaryData: dataset.dataContainer.row(0),\n      field: {\n        ...dataset.fields[testFieldIdx],\n        displayFormat: item.format\n      },\n      compareType: COMPARE_TYPES.RELATIVE,\n      data: dataset.dataContainer.row(1),\n      fieldIdx: testFieldIdx,\n      item\n    },\n    output: `${TOOLTIP_MINUS_SIGN}63.64%`,\n    message: 'should display relative delta value'\n  }, {\n    input: {\n      primaryData: dataset.dataContainer.row(3),\n      field: {\n        ...dataset.fields[testFieldIdx],\n        displayFormat: item.format\n      },\n      compareType: COMPARE_TYPES.ABSOLUTE,\n      data: dataset.dataContainer.row(1),\n      fieldIdx: testFieldIdx,\n      item\n    },\n    output: TOOLTIP_MINUS_SIGN,\n    message: 'should display - when primary is null'\n  }, {\n    input: {\n      primaryData: dataset.dataContainer.row(0),\n      field: {\n        ...dataset.fields[testFieldIdx],\n        displayFormat: item.format\n      },\n      compareType: COMPARE_TYPES.ABSOLUTE,\n      data: dataset.dataContainer.row(3),\n      fieldIdx: testFieldIdx,\n      item\n    },\n    output: TOOLTIP_MINUS_SIGN,\n    message: 'should display - when data is null'\n  }, {\n    input: {\n      primaryData: dataset.dataContainer.row(4),\n      field: {\n        ...dataset.fields[testFieldIdx],\n        displayFormat: item.format\n      },\n      compareType: COMPARE_TYPES.ABSOLUTE,\n      data: dataset.dataContainer.row(3),\n      fieldIdx: testFieldIdx,\n      item\n    },\n    output: TOOLTIP_MINUS_SIGN,\n    message: 'should display - when both are null'\n  }];\n  TEST_CASES.forEach(tc => {\n    t.equal(getTooltipDisplayDeltaValue(tc.input), tc.output, tc.message);\n  });\n  t.end();\n});","file":"node/utils/interaction-utils-test.js","skipped":false,"dir":"test"},{"name":"interactionUtil -> getTooltipDisplayValue","suites":[],"updatePoint":{"line":177,"column":47,"index":5294},"line":177,"code":"test('interactionUtil -> getTooltipDisplayValue', t => {\n  const tooltipConfig = StateWTooltipFormat.visState.interactionConfig.tooltip.config;\n  const dataset = StateWTooltipFormat.visState.datasets[testGeoJsonDataId];\n  const items = tooltipConfig.fieldsToShow[testGeoJsonDataId];\n  const TEST_CASES = [{\n    input: items[0],\n    // OBJECTID\n    output: ['1', '2', '3', '4', '5'],\n    message: `should display correct tooltip value for ${items[0].name}`\n  }, {\n    input: items[3],\n    // ID\n    output: ['11.000', '4.000', '20.000', '', ''],\n    message: `should display correct tooltip value for ${items[3].name}`\n  }, {\n    input: {\n      name: 'OBJ',\n      format: null\n    },\n    // ID\n    output: ['{\"id\":1}', '{\"id\":2}', '{\"id\":3}', '{\"id\":4}', '{\"id\":5}'],\n    message: 'should display correct tooltip value for OBJ'\n  }];\n  TEST_CASES.forEach(tc => {\n    // field.displayFormat has been used to replace tooltipConfig.format\n    const field = {\n      ...dataset.fields.find(f => f.name === tc.input.name),\n      displayFormat: tc.input.format\n    };\n    const fieldIdx = dataset.fields.findIndex(f => f.name === tc.input.name);\n    t.deepEqual(dataset.dataContainer.map(data => getTooltipDisplayValue({\n      field,\n      value: data.valueAt(fieldIdx),\n      item: tc.input\n    })), tc.output, tc.message);\n  });\n  t.end();\n});","file":"node/utils/interaction-utils-test.js","skipped":false,"dir":"test"},{"name":"kepler-gl utils -> getVisibleDatasets","suites":[],"updatePoint":{"line":24,"column":43,"index":1313},"line":24,"code":"test('kepler-gl utils -> getVisibleDatasets', t => {\n  // Geocoder dataset mock can be an empty object since the filter function only cares about the key\n  // in the 'datasets' object and filters by it\n  const datasets = {\n    first: {},\n    second: {},\n    geocoder_dataset: {}\n  };\n  t.true(datasets[GEOCODER_DATASET_NAME], `${GEOCODER_DATASET_NAME} key should exist before being filtered`);\n  const filteredResults = getVisibleDatasets(datasets);\n  t.isEqual(filteredResults[GEOCODER_DATASET_NAME], undefined, `Should not exist after filtering out ${GEOCODER_DATASET_NAME} key`);\n  t.end();\n});","file":"node/utils/kepler-gl-utils-test.js","skipped":false,"dir":"test"},{"name":"KeplerTable -> getColumnFilterDomain -> time","suites":[],"updatePoint":{"line":151,"column":50,"index":6290},"line":151,"code":"test('KeplerTable -> getColumnFilterDomain -> time', t => {\n  const expectedFields = testFields;\n  const data = processCsvData(testData);\n  const newDataEntry = createNewDataEntry({\n    info: {\n      id: 'test'\n    },\n    data\n  });\n  const dataset = newDataEntry.test;\n  cmpFields(t, expectedFields, dataset.fields, dataset.id);\n  testGetTimeFieldDomain(dataset, t);\n  testGetFilterFunction(dataset, t);\n  t.end();\n});","file":"node/utils/kepler-table-test.js","skipped":false,"dir":"test"},{"name":"KeplerTable -> getColumnFilterDomain -> numeric","suites":[],"updatePoint":{"line":166,"column":53,"index":6713},"line":166,"code":"test('KeplerTable -> getColumnFilterDomain -> numeric', async t => {\n  const data = processCsvData(numericRangesCsv);\n  const newDataEntry = createNewDataEntry({\n    info: {\n      id: 'test'\n    },\n    data\n  });\n  const dataset = newDataEntry.test;\n  testGetNumericFieldStep(dataset, t);\n  t.end();\n});","file":"node/utils/kepler-table-test.js","skipped":false,"dir":"test"},{"name":"KeplerTable -> findPointFieldPairs","suites":[],"updatePoint":{"line":178,"column":40,"index":7004},"line":178,"code":"test('KeplerTable -> findPointFieldPairs', t => {\n  const TASE_CASE = [{\n    fields: ['point-lat', 'point-lng', 'long', 'lat', 'poi_latitude', 'poi_longitude', 'latino', 'lngtino', 'lat.1', 'lng.1'],\n    expected: [{\n      defaultName: 'point',\n      pair: {\n        lat: {\n          fieldIdx: 0,\n          value: 'point-lat'\n        },\n        lng: {\n          fieldIdx: 1,\n          value: 'point-lng'\n        }\n      },\n      suffix: ['lat', 'lng']\n    }, {\n      defaultName: 'point',\n      pair: {\n        lat: {\n          fieldIdx: 3,\n          value: 'lat'\n        },\n        lng: {\n          fieldIdx: 2,\n          value: 'long'\n        }\n      },\n      suffix: ['lat', 'long']\n    }, {\n      defaultName: 'poi',\n      pair: {\n        lat: {\n          fieldIdx: 4,\n          value: 'poi_latitude'\n        },\n        lng: {\n          fieldIdx: 5,\n          value: 'poi_longitude'\n        }\n      },\n      suffix: ['latitude', 'longitude']\n    }, {\n      defaultName: '1',\n      pair: {\n        lat: {\n          fieldIdx: 8,\n          value: 'lat.1'\n        },\n        lng: {\n          fieldIdx: 9,\n          value: 'lng.1'\n        }\n      },\n      suffix: ['lat', 'lng']\n    }]\n  }, {\n    fields: ['point.lat', 'point.long', 'point.altitude', 'latitude', 'longitude'],\n    expected: [{\n      defaultName: 'point',\n      pair: {\n        lat: {\n          fieldIdx: 0,\n          value: 'point.lat'\n        },\n        lng: {\n          fieldIdx: 1,\n          value: 'point.long'\n        },\n        alt: {\n          fieldIdx: 2,\n          value: 'point.altitude'\n        }\n      },\n      suffix: ['lat', 'long']\n    }, {\n      defaultName: 'point',\n      pair: {\n        lat: {\n          fieldIdx: 3,\n          value: 'latitude'\n        },\n        lng: {\n          fieldIdx: 4,\n          value: 'longitude'\n        }\n      },\n      suffix: ['latitude', 'longitude']\n    }]\n  }];\n  TASE_CASE.forEach(({\n    fields,\n    expected\n  }) => {\n    const found = findPointFieldPairs(fields.map(f => ({\n      name: f\n    })));\n    t.equal(expected.length, found.length, `should found ${expected.length} pairs`);\n    expected.forEach((pair, index) => {\n      t.deepEqual(found[index], pair, 'should found correct point pair');\n    });\n  });\n  t.end();\n});","file":"node/utils/kepler-table-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer.1","suites":[],"updatePoint":{"line":41,"column":38,"index":2147},"line":41,"code":"test('layerUtils -> findDefaultLayer.1', t => {\n  const inputFields = [\n  // layer 1\n  {\n    name: 'one_lat',\n    fieldIdx: 0\n  }, {\n    name: 'one_lng',\n    fieldIdx: 1\n  },\n  // layer 2\n  {\n    name: 'two_two.lng',\n    fieldIdx: 2\n  }, {\n    name: 'two_two.lat',\n    fieldIdx: 3\n  },\n  // layer 3\n  {\n    name: 'three longitude',\n    fieldIdx: 4\n  }, {\n    name: 'three latitude',\n    fieldIdx: 5\n  },\n  // layer 4\n  {\n    name: 'four._.lon',\n    fieldIdx: 6\n  }, {\n    name: 'four._.lat',\n    fieldIdx: 7\n  },\n  // layer 5\n  {\n    name: 'lat',\n    fieldIdx: 8\n  }, {\n    name: 'lon',\n    fieldIdx: 9\n  },\n  // non layer\n  //\n\n  {\n    name: 'non_layer_longitude.alt',\n    fieldIdx: 10\n  }, {\n    name: 'non_layer_latitude.alt',\n    fieldIdx: 11\n  }, {\n    name: 'non_layer_altitude.alt',\n    fieldIdx: 12\n  }];\n  const dataId = 'testtest';\n  const outputLayers = [new PointLayer({\n    label: 'one',\n    dataId,\n    isVisible: true,\n    columns: {\n      lat: {\n        value: 'one_lat',\n        fieldIdx: 0\n      },\n      lng: {\n        value: 'one_lng',\n        fieldIdx: 1\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'two_two',\n    dataId,\n    columns: {\n      lat: {\n        value: 'two_two.lat',\n        fieldIdx: 3\n      },\n      lng: {\n        value: 'two_two.lng',\n        fieldIdx: 2\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'three',\n    dataId,\n    columns: {\n      lat: {\n        value: 'three latitude',\n        fieldIdx: 5\n      },\n      lng: {\n        value: 'three longitude',\n        fieldIdx: 4\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'four._',\n    dataId,\n    columns: {\n      lat: {\n        value: 'four._.lat',\n        fieldIdx: 7\n      },\n      lng: {\n        value: 'four._.lon',\n        fieldIdx: 6\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'point',\n    dataId,\n    columns: {\n      lat: {\n        value: 'lat',\n        fieldIdx: 8\n      },\n      lng: {\n        value: 'lon',\n        fieldIdx: 9\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'non_layeralt',\n    dataId,\n    columns: {\n      lat: {\n        value: 'non_layer_latitude.alt',\n        fieldIdx: 11\n      },\n      lng: {\n        value: 'non_layer_longitude.alt',\n        fieldIdx: 10\n      },\n      altitude: {\n        value: 'non_layer_altitude.alt',\n        fieldIdx: 12,\n        optional: true\n      }\n    }\n  }), new ArcLayer({\n    label: 'one -> two_two arc',\n    dataId,\n    columns: {\n      lat0: {\n        value: 'one_lat',\n        fieldIdx: 0\n      },\n      lng0: {\n        value: 'one_lng',\n        fieldIdx: 1\n      },\n      lat1: {\n        value: 'two_two.lat',\n        fieldIdx: 3\n      },\n      lng1: {\n        value: 'two_two.lng',\n        fieldIdx: 2\n      }\n    }\n  }), new LineLayer({\n    label: 'one -> two_two line',\n    dataId,\n    columns: {\n      lat0: {\n        value: 'one_lat',\n        fieldIdx: 0\n      },\n      lng0: {\n        value: 'one_lng',\n        fieldIdx: 1\n      },\n      lat1: {\n        value: 'two_two.lat',\n        fieldIdx: 3\n      },\n      lng1: {\n        value: 'two_two.lng',\n        fieldIdx: 2\n      },\n      alt0: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      },\n      alt1: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  })];\n  const fieldPairs = findPointFieldPairs(inputFields);\n  const layers = findDefaultLayer({\n    fields: inputFields,\n    fieldPairs,\n    id: dataId\n  }, LayerClasses);\n  t.equal(layers.length, outputLayers.length, 'number of layers found');\n  layers.forEach((l, i) => cmpLayers(t, outputLayers[i], l));\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer.2","suites":[],"updatePoint":{"line":269,"column":38,"index":6178},"line":269,"code":"test('layerUtils -> findDefaultLayer.2', t => {\n  const inputFields = [\n  // layer 1\n  {\n    name: 'all_points',\n    fieldIdx: 0\n  }];\n  const dataId = 'milkshake';\n  const dataset = new KeplerTable({\n    info: {\n      id: dataId,\n      label: 'sf_zip_geo'\n    },\n    data: {\n      rows: [[{\n        type: 'Feature',\n        properties: {\n          index: 0\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: []\n        }\n      }], [{\n        type: 'Feature',\n        properties: {\n          index: 1\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: []\n        }\n      }]],\n      fields: inputFields\n    }\n  });\n  const expected = new GeojsonLayer({\n    label: 'sf_zip_geo',\n    isVisible: true,\n    dataId,\n    columns: {\n      geojson: {\n        value: 'all_points',\n        fieldIdx: 0\n      }\n    }\n  });\n  expected.updateLayerVisConfig({\n    filled: true,\n    stroked: false\n  });\n  const layers = findDefaultLayer(dataset, KeplerGlLayers);\n  t.equal(layers.length, 1, 'number of layers found');\n  cmpLayers(t, expected, layers[0]);\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer.3","suites":[],"updatePoint":{"line":325,"column":38,"index":7289},"line":325,"code":"test('layerUtils -> findDefaultLayer.3', t => {\n  const dataId = 'cool';\n  const inputFields = [\n  // layer 1 & 2\n  {\n    name: 'begintrip_lat',\n    fieldIdx: 0\n  }, {\n    name: 'begintrip_lng',\n    fieldIdx: 1\n  }];\n  const outputLayers = [new PointLayer({\n    label: 'begintrip',\n    dataId,\n    isVisible: true,\n    columns: {\n      lat: {\n        value: 'begintrip_lat',\n        fieldIdx: 0\n      },\n      lng: {\n        value: 'begintrip_lng',\n        fieldIdx: 1\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  })];\n  const fieldPairs = findPointFieldPairs(inputFields);\n  const layers = findDefaultLayer({\n    fields: inputFields,\n    fieldPairs,\n    id: dataId\n  }, KeplerGlLayers);\n  t.equal(layers.length, 1, 'number of layers found');\n  layers.forEach((l, i) => cmpLayers(t, outputLayers[i], l));\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer.4","suites":[],"updatePoint":{"line":366,"column":38,"index":8173},"line":366,"code":"test('layerUtils -> findDefaultLayer.4', t => {\n  // Since all defaults layers are scanned and they\n  // share field names or patterns.  This set produces\n  // multiple layers.\n  // Order determined by the order\n  // the defaults are scanned inside the function under test.\n  const inputFields = [\n  // layer 1 (grid), 2 (arc), 3 (point)\n  {\n    name: 'begintrip_lat',\n    fieldIdx: 0\n  }, {\n    name: 'begintrip_lng',\n    fieldIdx: 1\n  },\n  // layer 2 (arc), 4 (point)\n  {\n    name: 'dropoff_lat',\n    fieldIdx: 2\n  }, {\n    name: 'dropoff_lng',\n    fieldIdx: 3\n  }];\n  const dataId = 'yololo';\n  const outputLayers = [new PointLayer({\n    label: 'begintrip',\n    dataId,\n    isVisible: true,\n    columns: {\n      lat: {\n        value: 'begintrip_lat',\n        fieldIdx: 0\n      },\n      lng: {\n        value: 'begintrip_lng',\n        fieldIdx: 1\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new PointLayer({\n    label: 'dropoff',\n    dataId,\n    columns: {\n      lat: {\n        value: 'dropoff_lat',\n        fieldIdx: 2\n      },\n      lng: {\n        value: 'dropoff_lng',\n        fieldIdx: 3\n      },\n      altitude: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  }), new ArcLayer({\n    label: 'begintrip -> dropoff arc',\n    dataId,\n    columns: {\n      lat0: {\n        value: 'begintrip_lat',\n        fieldIdx: 0\n      },\n      lng0: {\n        value: 'begintrip_lng',\n        fieldIdx: 1\n      },\n      lat1: {\n        value: 'dropoff_lat',\n        fieldIdx: 2\n      },\n      lng1: {\n        value: 'dropoff_lng',\n        fieldIdx: 3\n      }\n    }\n  }), new LineLayer({\n    label: 'begintrip -> dropoff line',\n    dataId,\n    columns: {\n      lat0: {\n        value: 'begintrip_lat',\n        fieldIdx: 0\n      },\n      lng0: {\n        value: 'begintrip_lng',\n        fieldIdx: 1\n      },\n      lat1: {\n        value: 'dropoff_lat',\n        fieldIdx: 2\n      },\n      lng1: {\n        value: 'dropoff_lng',\n        fieldIdx: 3\n      },\n      alt0: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      },\n      alt1: {\n        value: null,\n        fieldIdx: -1,\n        optional: true\n      }\n    }\n  })];\n  const fieldPairs = findPointFieldPairs(inputFields);\n  const layers = findDefaultLayer({\n    fields: inputFields,\n    fieldPairs,\n    id: dataId\n  }, KeplerGlLayers);\n  t.equal(layers.length, outputLayers.length, 'number of layers found');\n  layers.forEach((l, i) => cmpLayers(t, outputLayers[i], l));\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer.5","suites":[],"updatePoint":{"line":490,"column":38,"index":10724},"line":490,"code":"test('layerUtils -> findDefaultLayer.5', t => {\n  const inputFields = [\n  // layer 1\n  {\n    name: 'one_late',\n    fieldIdx: 0\n  }, {\n    name: 'one_lng',\n    fieldIdx: 1\n  }];\n  const fieldPairs = findPointFieldPairs(inputFields);\n  const layers = findDefaultLayer({\n    fields: inputFields,\n    fieldPairs,\n    id: 'yo'\n  }, KeplerGlLayers);\n  t.equal(layers.length, 0, 'number of layers found');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer:GeojsonLayer","suites":[],"updatePoint":{"line":509,"column":49,"index":11149},"line":509,"code":"test('layerUtils -> findDefaultLayer:GeojsonLayer', t => {\n  const dataset = new KeplerTable({\n    info: {\n      label: 'sf_zip_geo'\n    },\n    data: {\n      rows: [[{\n        type: 'Feature',\n        properties: {\n          index: 0\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: []\n        }\n      }], [{\n        type: 'Feature',\n        properties: {\n          index: 1\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: []\n        }\n      }]],\n      fields: [{\n        name: 'random'\n      }, {\n        name: 'begintrip_lng'\n      }, {\n        name: 'cool'\n      }, {\n        name: 'dropoff_lng'\n      }, {\n        name: GEOJSON_FIELDS.geojson[0]\n      }, {\n        name: GEOJSON_FIELDS.geojson[1]\n      }]\n    }\n  });\n  const expected1 = new GeojsonLayer({\n    label: 'what',\n    dataId: 'smoothie',\n    isVisible: true,\n    columns: {\n      geojson: {\n        value: GEOJSON_FIELDS.geojson[0],\n        fieldIdx: 4\n      }\n    }\n  });\n  const expected2 = new GeojsonLayer({\n    label: 'what',\n    dataId: 'smoothie',\n    isVisible: true,\n    columns: {\n      geojson: {\n        value: GEOJSON_FIELDS.geojson[1],\n        fieldIdx: 5\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-unused-vars\n  const [layer1Color, layer2Color, layer2Stroke] = getNextColorMakerValue(3);\n  expected1.updateLayerVisConfig({\n    filled: true,\n    stroked: false\n  });\n  expected2.updateLayerVisConfig({\n    filled: true,\n    stroked: true,\n    strokeColor: layer2Stroke\n  });\n  const {\n    fields\n  } = dataset;\n  const dataContainer = createDataContainer([[0, 1, 2, 3, {\n    type: 'Feature',\n    properties: {\n      index: 0\n    },\n    geometry: {\n      type: 'Point',\n      coordinates: []\n    }\n  }, {\n    type: 'Feature',\n    properties: {\n      index: 0\n    },\n    geometry: {\n      type: 'Polygon',\n      coordinates: []\n    }\n  }], {\n    fields\n  }]);\n  const geojsonLayers = findDefaultLayer({\n    fields,\n    label: 'what',\n    id: 'smoothie',\n    fieldPairs: [],\n    dataContainer\n  }, KeplerGlLayers);\n  cmpLayers(t, [expected1, expected2], geojsonLayers);\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer:GeojsonLayer.wkt","suites":[],"updatePoint":{"line":617,"column":53,"index":13287},"line":617,"code":"test('layerUtils -> findDefaultLayer:GeojsonLayer.wkt', t => {\n  const {\n    fields,\n    rows\n  } = processCsvData(wktCsv);\n  const dataId = '0dj3h';\n  const label = 'some geometry file';\n  const expected1 = new GeojsonLayer({\n    dataId: '0dj3h',\n    label: 'some geometry file',\n    isVisible: true,\n    columns: {\n      geojson: {\n        value: 'simplified_shape_v2',\n        fieldIdx: 1\n      }\n    }\n  });\n  const expected2 = new GeojsonLayer({\n    dataId: '0dj3h',\n    label: 'some geometry file',\n    isVisible: true,\n    columns: {\n      geojson: {\n        value: 'simplified_shape',\n        fieldIdx: 2\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-unused-vars\n  const [layer1Color, strokeColor1, layer2Color, strokeColor2] = getNextColorMakerValue(4);\n  expected1.updateLayerVisConfig({\n    filled: true,\n    stroked: true,\n    strokeColor: strokeColor1\n  });\n  expected2.updateLayerVisConfig({\n    filled: true,\n    stroked: true,\n    strokeColor: strokeColor2\n  });\n  const dataContainer = createDataContainer(rows, {\n    fields\n  });\n  const geojsonLayers = findDefaultLayer({\n    fields,\n    id: dataId,\n    label,\n    fieldPairs: [],\n    dataContainer\n  }, KeplerGlLayers);\n  cmpLayers(t, [expected1, expected2], geojsonLayers);\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer:GeojsonWithStyle","suites":[],"updatePoint":{"line":672,"column":53,"index":14555},"line":672,"code":"test('layerUtils -> findDefaultLayer:GeojsonWithStyle', t => {\n  const {\n    fields,\n    rows\n  } = processGeojson(geoJsonWithStyle);\n  const dataContainer = createDataContainer(rows, {\n    fields\n  });\n  const geojsonLayers = findDefaultLayer({\n    fields,\n    id: 'test',\n    dataId: 'taro',\n    label: 'chubby prince',\n    fieldPairs: [],\n    dataContainer\n  }, KeplerGlLayers);\n  t.equal(geojsonLayers.length, 1, 'should find 1 layer');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer:IconLayer","suites":[],"updatePoint":{"line":691,"column":46,"index":15004},"line":691,"code":"test('layerUtils -> findDefaultLayer:IconLayer', t => {\n  const inputFields = [{\n    name: 'begintrip_lat',\n    fieldIdx: 0\n  }, {\n    name: 'begintrip_lng',\n    fieldIdx: 1\n  }, {\n    name: 'dropoff_lat',\n    fieldIdx: 2\n  }, {\n    name: 'dropoff_lng',\n    fieldIdx: 3\n  }];\n  const fieldPairs = findPointFieldPairs(inputFields);\n  const eventIcon = [{\n    name: 'event_icon',\n    fieldIdx: 4\n  }];\n  const nameIcon = [{\n    name: 'name.icon',\n    fieldIdx: 4\n  }];\n  t.equal(findDefaultLayer({\n    fields: inputFields,\n    fieldPairs,\n    id: 'meow',\n    allData: []\n  }, KeplerGlLayers).filter(l => l.type === 'icon').length, 0, 'should find no icon layer');\n  const fieldsWithIcon = [...inputFields, ...eventIcon];\n  const fieldPairsWIcon = findPointFieldPairs(fieldsWithIcon);\n  let iconLayers = findDefaultLayer({\n    fields: fieldsWithIcon,\n    fieldPairs: fieldPairsWIcon,\n    id: 'meow'\n  }, KeplerGlLayers).filter(l => l.type === 'icon');\n  t.equal(iconLayers.length, 1, 'should find 1 icon layer');\n  t.equal(iconLayers[0].config.label, 'event icon', 'should find 1 icon layer');\n  const fieldsWith2Icon = [...inputFields, ...nameIcon, ...eventIcon];\n  const fieldPairsW2Icon = findPointFieldPairs(fieldsWith2Icon);\n  iconLayers = findDefaultLayer({\n    fields: fieldsWith2Icon,\n    fieldPairs: fieldPairsW2Icon,\n    id: 'meow'\n  }, KeplerGlLayers).filter(l => l.type === 'icon');\n  t.equal(iconLayers.length, 2, 'should find 2 icon layers');\n  t.equal(iconLayers[0].config.label, 'name icon', 'should find 2 icon layer');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer: TripLayer","suites":[],"updatePoint":{"line":740,"column":47,"index":16554},"line":740,"code":"test('layerUtils -> findDefaultLayer: TripLayer', t => {\n  const stateWTrip = StateWTripGeojson;\n  t.equal(stateWTrip.visState.layers.length, 1, 'should find one layer');\n  const foundLayer = stateWTrip.visState.layers[0];\n  t.equal(foundLayer.type, 'trip', 'should find a trip layer');\n  t.deepEqual(foundLayer.config.animation, {\n    enabled: true,\n    domain: timeStampDomain\n  }, 'should set correct animation domain');\n  t.deepEqual(foundLayer.meta.bounds, tripBounds, 'should set correct bounds');\n  t.deepEqual(foundLayer.meta.featureTypes, {\n    line: true\n  }, 'should set correct bounds');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer: TripLayer.1 -> no ts","suites":[],"updatePoint":{"line":755,"column":58,"index":17180},"line":755,"code":"test('layerUtils -> findDefaultLayer: TripLayer.1 -> no ts', t => {\n  // change 3rd coordinate to string\n  const modified = tripGeojson.features.map(f => ({\n    ...f,\n    geometry: {\n      ...f.geometry,\n      coordinates: f.geometry.coordinates.map(coord => [...coord.slice(0, 3), 'hello'])\n    }\n  }));\n  const noTripGeojson = {\n    type: 'FeatureCollection',\n    features: modified\n  };\n  const dataset = createNewDataEntry({\n    info: {\n      id: 'taro'\n    },\n    data: processGeojson(noTripGeojson)\n  });\n  const layers = findDefaultLayer(dataset.taro, LayerClasses);\n  t.equal(layers.length, 1, 'should find 1 layer');\n  const foundLayer = layers[0];\n  t.equal(foundLayer.type, 'geojson', 'should find a geojson layer');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> findDefaultLayer: TripLayer.1 -> ts as string","suites":[],"updatePoint":{"line":780,"column":65,"index":17930},"line":780,"code":"test('layerUtils -> findDefaultLayer: TripLayer.1 -> ts as string', t => {\n  const tripData = {\n    type: 'FeatureCollection',\n    features: [{\n      type: 'Feature',\n      geometry: {\n        type: 'LineString',\n        coordinates: [[-73.78966, 40.6429, 0, '2018-09-01 11:00'], [-73.7895, 40.64267, 0, '2018-09-01 11:01'], [-73.78923, 40.6424, 0, '2018-09-01 11:02'], [-73.78905, 40.64222, 0, '2018-09-01 11:03']]\n      }\n    }]\n  };\n  const dataset = createNewDataEntry({\n    info: {\n      id: 'taro'\n    },\n    data: processGeojson(tripData)\n  });\n  const layers = findDefaultLayer(dataset.taro, LayerClasses);\n  t.equal(layers.length, 1, 'should find 1 layer');\n  const foundLayer = layers[0];\n  t.equal(foundLayer.type, 'trip', 'should find a geojson layer');\n  t.deepEqual(foundLayer.config.animation, {\n    enabled: true,\n    domain: [1535799600000, 1535799780000]\n  }, 'should set correct animation domain');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> getLayerHoverProp","suites":[],"updatePoint":{"line":807,"column":37,"index":18835},"line":807,"code":"test('layerUtils -> getLayerHoverProp', t => {\n  const visState = cloneDeep(StateWFiles).visState;\n  const layer = visState.layers[0];\n  const layerData = visState.layerData[0];\n  const layersToRender = {\n    [layer.id]: layer\n  };\n  const obj = layerData.data[0];\n  const mockHoverInfo = {\n    object: obj,\n    picked: true,\n    layer: {\n      props: {\n        idx: 0\n      }\n    }\n  };\n  const mockHoverInfoNotHovered = {\n    picked: false,\n    object: null\n  };\n  const args = {\n    interactionConfig: visState.interactionConfig,\n    hoverInfo: mockHoverInfo,\n    layers: visState.layers,\n    layersToRender,\n    datasets: visState.datasets\n  };\n  const expectedDataset = visState.datasets[layer.config.dataId];\n  const expected = {\n    data: expectedDataset.dataContainer.row(obj.index),\n    fields: expectedDataset.fields,\n    fieldsToShow: visState.interactionConfig.tooltip.config.fieldsToShow[layer.config.dataId],\n    layer\n  };\n  t.deepEqual(getLayerHoverProp(args), expected, 'should get correct layerHoverProp');\n  args.hoverInfo = mockHoverInfoNotHovered;\n  t.deepEqual(getLayerHoverProp(args), null, 'should get correct layerHoverProp');\n  visState.interactionConfig.tooltip.enabled = false;\n  args.hoverInfo = mockHoverInfo;\n  t.deepEqual(getLayerHoverProp(args), null, 'should get correct layerHoverProp');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"layerUtils -> getLayerOrderFromLayers","suites":[],"updatePoint":{"line":850,"column":43,"index":20179},"line":850,"code":"test('layerUtils -> getLayerOrderFromLayers', t => {\n  const visState = cloneDeep(StateWFiles).visState;\n  const layerOrder = getLayerOrderFromLayers(visState.layers);\n  t.deepEqual(layerOrder, ['point-0', 'geojson-1'], 'Should generate layerOrder correctly');\n  t.end();\n});","file":"node/utils/layer-utils-test.js","skipped":false,"dir":"test"},{"name":"mapInfoUtils -> isValidMapInfo","suites":[],"updatePoint":{"line":23,"column":36,"index":1235},"line":23,"code":"test('mapInfoUtils -> isValidMapInfo', t => {\n  t.equal(isValidMapInfo({\n    title: 'example',\n    description: ''\n  }), true, 'Should validate map info with no description');\n  t.equal(isValidMapInfo({\n    title: 'example',\n    description: 'this is a map'\n  }), true, 'Should validate map info with description');\n  t.equal(isValidMapInfo({\n    title: 'this is a really long title for a map that is not going to work because i really do not like this kind of long title',\n    description: 'this is a map'\n  }), false, 'Should validate map with a really long title');\n  t.equal(isValidMapInfo({\n    description: 'this is a really long description for a map that is not going to work because i really do not like this kind of long title',\n    title: 'this is a map'\n  }), false, 'Should validate map with a really long description');\n  t.end();\n});","file":"node/utils/map-info-utils-test.js","skipped":false,"dir":"test"},{"name":"mapbox.gl Style Editor -> mergeLayerGroupVisibility","suites":[],"updatePoint":{"line":23,"column":57,"index":1267},"line":23,"code":"test('mapbox.gl Style Editor -> mergeLayerGroupVisibility', t => {\n  const defaultLG = {\n    label: true,\n    road: true,\n    border: false,\n    building: true,\n    water: true,\n    land: true\n  };\n  const currentLG = {\n    label: false,\n    road: false,\n    border: true\n  };\n  const expected = {\n    label: false,\n    road: false,\n    border: true,\n    building: true,\n    water: true,\n    land: true\n  };\n  t.deepEqual(mergeLayerGroupVisibility(defaultLG, currentLG), expected, 'Should override default layer group visibility');\n  t.end();\n});","file":"node/utils/mapbox-gl-style-editor-test.js","skipped":false,"dir":"test"},{"name":"mapbox-utils -> isStyleUsingMapboxTiles","suites":[],"updatePoint":{"line":23,"column":45,"index":1253},"line":23,"code":"test('mapbox-utils -> isStyleUsingMapboxTiles', t => {\n  t.notOk(isStyleUsingMapboxTiles({}), 'Empty style does not reference Mapbox');\n  t.notOk(isStyleUsingMapboxTiles({\n    stylesheet: {\n      sources: {\n        a: {}\n      }\n    }\n  }), 'Source does not reference Mapbox');\n  t.ok(isStyleUsingMapboxTiles({\n    stylesheet: {\n      sources: {\n        a: {\n          url: 'some/url'\n        },\n        b: {\n          url: 'mapbox://mapbox-style.json'\n        }\n      }\n    }\n  }), 'Source references Mapbox tiles using \"url\"');\n  t.ok(isStyleUsingMapboxTiles({\n    stylesheet: {\n      sources: {\n        a: {\n          url: 'some/url'\n        },\n        b: {\n          tiles: ['mapbox://mapbox-style.json']\n        }\n      }\n    }\n  }), 'Source references Mapbox tiles using \"tiles\"');\n  t.end();\n});","file":"node/utils/mapbox-utils-test.js","skipped":false,"dir":"test"},{"name":"#notificationsUtils -> errorNotification","suites":[],"updatePoint":{"line":23,"column":46,"index":1269},"line":23,"code":"test('#notificationsUtils -> errorNotification', t => {\n  const notification = errorNotification({\n    message: 'test',\n    id: 'test-1'\n  });\n  t.deepEqual(notification, {\n    id: 'test-1',\n    message: 'test',\n    type: 'error',\n    topic: 'global',\n    count: 1\n  }, 'ErrorNotification creates an error notification');\n  t.end();\n});","file":"node/utils/notifications-utils-test.js","skipped":false,"dir":"test"},{"name":"#notificationsUtils -> successNotification","suites":[],"updatePoint":{"line":37,"column":48,"index":1608},"line":37,"code":"test('#notificationsUtils -> successNotification', t => {\n  const notification = successNotification({\n    message: 'test',\n    id: 'test-1'\n  });\n  t.deepEqual(notification, {\n    id: 'test-1',\n    message: 'test',\n    type: 'success',\n    topic: 'global',\n    count: 1\n  }, 'SuccessNotification creates an error notification');\n  t.end();\n});","file":"node/utils/notifications-utils-test.js","skipped":false,"dir":"test"},{"name":"Utils -> getS2Center","suites":[],"updatePoint":{"line":23,"column":26,"index":1223},"line":23,"code":"test('Utils -> getS2Center', t => {\n  const s2Toekn = '8085873c';\n  t.deepEqual(getS2Center(s2Toekn), [-122.4637079795235, 37.78228912269449]);\n  t.end();\n});","file":"node/utils/s2-utils-test.js","skipped":false,"dir":"test"},{"name":"#timeline -> getTimelineFromFilter","suites":[],"updatePoint":{"line":23,"column":40,"index":1278},"line":23,"code":"test('#timeline -> getTimelineFromFilter', t => {\n  const filter = {\n    dataId: ['test_trip_data'],\n    id: 'lojgttzht',\n    fixedDomain: true,\n    enlarged: true,\n    isAnimating: false,\n    animationWindow: 'free',\n    speed: 1,\n    name: ['tpep_pickup_datetime'],\n    type: 'timeRange',\n    fieldIdx: [0],\n    domain: [1421315219000, 1421348744000],\n    value: [1421315219000, 1421348744000],\n    plotType: {\n      interval: '5-minute',\n      defaultTimeFormat: 'L  LT',\n      type: 'histogram',\n      aggregation: 'sum'\n    },\n    yAxis: null,\n    gpu: true,\n    step: 1000,\n    mappedValue: [null, null, 1421348740000, null, 1421348741000, 1421348741000, 1421348741000, 1421348741000, 1421348741000, 1421348741000, 1421348741000, 1421348741000, 1421320174000],\n    defaultTimeFormat: 'L LTS',\n    fieldType: 'timestamp',\n    gpuChannel: [0]\n  };\n  const timeline = getTimelineFromFilter(filter);\n  t.deepEqual(Object.keys(timeline), ['value', 'enableInteraction', 'domain', 'speed', 'isAnimating', 'step', 'timeSteps', 'defaultTimeFormat', 'timeFormat', 'timezone', 'animationWindow', 'marks'], 'Should generate the correct keys for filter timeline');\n  t.end();\n});","file":"node/utils/timeline-test.js","skipped":false,"dir":"test"},{"name":"#timeline -> getTimelineFromAnimationConfig","suites":[],"updatePoint":{"line":55,"column":49,"index":2460},"line":55,"code":"test('#timeline -> getTimelineFromAnimationConfig', t => {\n  const animationConfig = {\n    domain: [1565577697000, 1565578881000],\n    currentTime: 1565577697000,\n    speed: 1,\n    isAnimating: false,\n    timeSteps: null,\n    timeFormat: null,\n    timezone: null,\n    defaultTimeFormat: 'L LTS',\n    duration: null\n  };\n  const timeline = getTimelineFromAnimationConfig(animationConfig);\n  t.deepEqual(Object.keys(timeline), ['value', 'enableInteraction', 'domain', 'speed', 'isAnimating', 'timeSteps', 'defaultTimeFormat', 'timeFormat', 'timezone', 'marks'], 'Should generate the correct keys for animationConfig timeline');\n  t.deepEqual(getTimelineFromAnimationConfig(animationConfig).value, [animationConfig.currentTime], 'Should have converted animationConfig currentTime to value and array shaped');\n  t.end();\n});","file":"node/utils/timeline-test.js","skipped":false,"dir":"test"},{"name":"Utils -> set","suites":[],"updatePoint":{"line":23,"column":18,"index":1285},"line":23,"code":"test('Utils -> set', t => {\n  const obj1 = {\n    map: {\n      map1: 'world'\n    }\n  };\n  const obj2 = set(['map', 'map1'], 'hello', obj1);\n  t.notLooseEqual(obj1, obj2, 'set should create a new object');\n  t.equal(set(['map'], 'hello', null), null, 'set null should return null');\n  t.equal(set(['map'], 'hello', undefined), undefined, 'set undefined should return undefined');\n  t.deepEqual(set(['map', 'map1'], 'hello', {\n    map: {\n      map1: 'world'\n    }\n  }), {\n    map: {\n      map1: 'hello'\n    }\n  }, 'set should set value');\n  t.deepEqual(set(['map'], 'hello', {}), {\n    map: 'hello'\n  }, 'set should create leave node');\n  t.deepEqual(set(['map', 1], 'hello', {\n    map: ['hello', 'world']\n  }), {\n    map: ['hello', 'hello']\n  }, 'set should work with array');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> toArray","suites":[],"updatePoint":{"line":52,"column":22,"index":2079},"line":52,"code":"test('Utils -> toArray', t => {\n  t.deepEqual(toArray(), [], 'Should return an empty array for undefined value');\n  t.deepEqual(toArray([1, 2]), [1, 2], 'Should not change an existing array');\n  t.deepEqual(toArray(null), [], 'Should return an empty array for a null value');\n  t.deepEqual(toArray('test'), ['test'], 'Should return an array with one element for a string');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> getError","suites":[],"updatePoint":{"line":59,"column":23,"index":2469},"line":59,"code":"test('Utils -> getError', t => {\n  t.equal(getError(new Error('oops')), 'oops', 'should find error message from Error object');\n  t.equal(getError('sorry'), 'sorry', 'should find error message from string');\n  t.equal(getError(), 'Something went wrong', 'should find error message from empty');\n  t.equal(getError({\n    error: {\n      message: 'not good'\n    }\n  }), 'not good', 'should find error message from object');\n  t.equal(getError({\n    err: {\n      error: 'not good'\n    }\n  }), 'not good', 'should find error message from object');\n  t.equal(getError({\n    status: 400\n  }), '{\"status\":400}', 'should find error message from object');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> camelToTitle","suites":[],"updatePoint":{"line":78,"column":27,"index":3134},"line":78,"code":"test('Utils -> camelToTitle', t => {\n  t.equal(camelToTitle('camelToTitle'), 'Camel To Title', 'should return titled string');\n  t.equal(camelToTitle('strokeColor'), 'Stroke Color', 'should return titled string');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> camelize","suites":[],"updatePoint":{"line":83,"column":23,"index":3359},"line":83,"code":"test('Utils -> camelize', t => {\n  t.equal(camelize('hello world test string'), 'helloWorldTestString', 'should camelize string');\n  t.equal(camelize('Hello World test String'), 'helloWorldTestString', 'should camelize string');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> capitalizeFirstLetter","suites":[],"updatePoint":{"line":88,"column":36,"index":3616},"line":88,"code":"test('Utils -> capitalizeFirstLetter', t => {\n  t.equal(capitalizeFirstLetter('hello world'), 'Hello world', 'should capitalize string');\n  t.equal(capitalizeFirstLetter(1), 1, 'should ignore other types than string');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"},{"name":"Utils -> arrayInsert","suites":[],"updatePoint":{"line":93,"column":26,"index":3840},"line":93,"code":"test('Utils -> arrayInsert', t => {\n  t.deepEqual(arrayInsert([], 1, 0), [0], 'should insert val at index');\n  t.deepEqual(arrayInsert([1, 2, 3, 4], 1, 5), [1, 5, 2, 3, 4], 'should insert val at index');\n  t.deepEqual(arrayInsert([1, 2, 3], 0, 6), [6, 1, 2, 3], 'should insert val at index');\n  t.deepEqual(arrayInsert(null, 1, 0), null, 'should insert val at index');\n  t.deepEqual(arrayInsert([1, 2, 3], 3, 4), [1, 2, 3, 4], 'should insert val at index');\n  t.end();\n});","file":"node/utils/util-test.js","skipped":false,"dir":"test"}]}