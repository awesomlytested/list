{"repo":"pnpm/pnpm","url":"https://github.com/pnpm/pnpm","branch":"main","configs":[{"package":"@pnpm/audit","lang":"ts","dir":"packages/audit/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/cafs","lang":"ts","dir":"packages/cafs/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/client","lang":"ts","dir":"packages/client/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/config","lang":"ts","dir":"packages/config/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/core","lang":"ts","dir":"packages/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/default-reporter","lang":"ts","dir":"packages/default-reporter/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/default-resolver","lang":"ts","dir":"packages/default-resolver/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"dependencies-hierarchy","lang":"ts","dir":"packages/dependencies-hierarchy/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"dependency-path","lang":"ts","dir":"packages/dependency-path/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/directory-fetcher","lang":"ts","dir":"packages/directory-fetcher/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/exportable-manifest","lang":"ts","dir":"packages/exportable-manifest/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/fetch","lang":"ts","dir":"packages/fetch/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/file-reporter","lang":"ts","dir":"packages/file-reporter/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/filter-lockfile","lang":"ts","dir":"packages/filter-lockfile/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/filter-workspace-packages","lang":"ts","dir":"packages/filter-workspace-packages/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"find-packages","lang":"ts","dir":"packages/find-packages/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/find-workspace-dir","lang":"ts","dir":"packages/find-workspace-dir/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/find-workspace-packages","lang":"ts","dir":"packages/find-workspace-packages/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/git-fetcher","lang":"ts","dir":"packages/git-fetcher/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/git-resolver","lang":"ts","dir":"packages/git-resolver/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/global-bin-dir","lang":"ts","dir":"packages/global-bin-dir/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/headless","lang":"ts","dir":"packages/headless/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/lifecycle","lang":"ts","dir":"packages/lifecycle/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/link-bins","lang":"ts","dir":"packages/link-bins/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/list","lang":"ts","dir":"packages/list/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/local-resolver","lang":"ts","dir":"packages/local-resolver/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/lockfile-file","lang":"ts","dir":"packages/lockfile-file/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/lockfile-to-pnp","lang":"ts","dir":"packages/lockfile-to-pnp/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/lockfile-utils","lang":"ts","dir":"packages/lockfile-utils/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/make-dedicated-lockfile","lang":"ts","dir":"packages/make-dedicated-lockfile/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/manifest-utils","lang":"ts","dir":"packages/manifest-utils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/matcher","lang":"ts","dir":"packages/matcher/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/merge-lockfile-changes","lang":"ts","dir":"packages/merge-lockfile-changes/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/modules-yaml","lang":"ts","dir":"packages/modules-yaml/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/mount-modules","lang":"ts","dir":"packages/mount-modules/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/npm-registry-agent","lang":"ts","dir":"packages/npm-registry-agent/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/npm-resolver","lang":"ts","dir":"packages/npm-resolver/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/outdated","lang":"ts","dir":"packages/outdated/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/package-bins","lang":"ts","dir":"packages/package-bins/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/package-is-installable","lang":"ts","dir":"packages/package-is-installable/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/package-requester","lang":"ts","dir":"packages/package-requester/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/package-store","lang":"ts","dir":"packages/package-store/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/parse-cli-args","lang":"ts","dir":"packages/parse-cli-args/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/parse-overrides","lang":"ts","dir":"packages/parse-overrides/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/pick-registry-for-package","lang":"ts","dir":"packages/pick-registry-for-package/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"pkgs-graph","lang":"ts","dir":"packages/pkgs-graph/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-audit","lang":"ts","dir":"packages/plugin-commands-audit/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-env","lang":"ts","dir":"packages/plugin-commands-env/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/plugin-commands-installation","lang":"ts","dir":"packages/plugin-commands-installation/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/plugin-commands-listing","lang":"ts","dir":"packages/plugin-commands-listing/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-outdated","lang":"ts","dir":"packages/plugin-commands-outdated/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-publishing","lang":"ts","dir":"packages/plugin-commands-publishing/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-rebuild","lang":"ts","dir":"packages/plugin-commands-rebuild/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-script-runners","lang":"ts","dir":"packages/plugin-commands-script-runners/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/plugin-commands-setup","lang":"ts","dir":"packages/plugin-commands-setup/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/plugin-commands-store","lang":"ts","dir":"packages/plugin-commands-store/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"pnpm","lang":"ts","dir":"packages/pnpm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/pnpmfile","lang":"ts","dir":"packages/pnpmfile/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/prune-lockfile","lang":"ts","dir":"packages/prune-lockfile/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/read-package-json","lang":"ts","dir":"packages/read-package-json/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/read-project-manifest","lang":"ts","dir":"packages/read-project-manifest/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/render-peer-issues","lang":"ts","dir":"packages/render-peer-issues/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/resolve-dependencies","lang":"ts","dir":"packages/resolve-dependencies/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@pnpm/server","lang":"ts","dir":"packages/server/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/tarball-fetcher","lang":"ts","dir":"packages/tarball-fetcher/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/tarball-resolver","lang":"ts","dir":"packages/tarball-resolver/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/which-version-is-pinned","lang":"ts","dir":"packages/which-version-is-pinned/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/write-project-manifest","lang":"ts","dir":"packages/write-project-manifest/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/assert-project","lang":"ts","dir":"privatePackages/assert-project/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@pnpm/assert-store","lang":"ts","dir":"privatePackages/assert-store/test","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"lockfileToAuditTree()","suites":["audit"],"updatePoint":{"line":8,"column":29},"line":8,"code":"  test('lockfileToAuditTree()', () => {\n    expect(lockfileToAuditTree({\n      importers: {\n        '.': {\n          dependencies: {\n            foo: '1.0.0',\n          },\n          specifiers: {\n            foo: '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/bar/1.0.0': {\n          resolution: {\n            integrity: 'bar-integrity',\n          },\n        },\n        '/foo/1.0.0': {\n          dependencies: {\n            bar: '1.0.0',\n          },\n          resolution: {\n            integrity: 'foo-integrity',\n          },\n        },\n      },\n    })).toEqual({\n      name: undefined,\n      version: undefined,\n\n      dependencies: {\n        '.': {\n          dependencies: {\n            foo: {\n              dependencies: {\n                bar: {\n                  dev: false,\n                  integrity: 'bar-integrity',\n                  version: '1.0.0',\n                },\n              },\n              dev: false,\n              integrity: 'foo-integrity',\n              requires: {\n                bar: '1.0.0',\n              },\n              version: '1.0.0',\n            },\n          },\n          requires: {\n            foo: '1.0.0',\n          },\n          version: '0.0.0',\n        },\n      },\n      dev: false,\n      install: [],\n      integrity: undefined,\n      metadata: {},\n      remove: [],\n      requires: { '.': '0.0.0' },\n    })\n  })","file":"index.ts","skipped":false,"dir":"packages/audit/test"},{"name":"an error is thrown if the audit endpoint responds with a non-OK code","suites":["audit"],"updatePoint":{"line":74,"column":76},"line":74,"code":"  test('an error is thrown if the audit endpoint responds with a non-OK code', async () => {\n    const registry = 'http://registry.registry/'\n    nock(registry)\n      .post('/-/npm/v1/security/audits')\n      .reply(500, { message: 'Something bad happened' })\n\n    let err!: PnpmError\n    try {\n      await audit({\n        importers: {},\n        lockfileVersion: 5,\n      }, {\n        registry,\n        retry: {\n          retries: 0,\n        },\n      })\n    } catch (_err: any) { // eslint-disable-line\n      err = _err\n    }\n\n    expect(err).toBeDefined()\n    expect(err.code).toEqual('ERR_PNPM_AUDIT_BAD_RESPONSE')\n    expect(err.message).toEqual('The audit endpoint (at http://registry.registry/-/npm/v1/security/audits) responded with 500: {\"message\":\"Something bad happened\"}')\n  })","file":"index.ts","skipped":false,"dir":"packages/audit/test"},{"name":"unpack","suites":["cafs"],"updatePoint":{"line":10,"column":12},"line":10,"code":"  it('unpack', async () => {\n    const dest = tempy.directory()\n    const cafs = createCafs(dest)\n    const filesIndex = await cafs.addFilesFromTarball(\n      createReadStream(path.join(__dirname, '../__fixtures__/node-gyp-6.1.0.tgz'))\n    )\n    expect(Object.keys(filesIndex)).toHaveLength(121)\n    const pkgFile = filesIndex['package.json']\n    expect(pkgFile.size).toBe(1121)\n    expect(pkgFile.mode).toBe(420)\n    const { checkedAt, integrity } = await pkgFile.writeResult\n    expect(typeof checkedAt).toBe('number')\n    expect(integrity.toString()).toBe('sha512-8xCvrlC7W3TlwXxetv5CZTi53szYhmT7tmpXF/ttNthtTR9TC7Y7WJFPmJToHaSQ4uObuZyOARdOJYNYuTSbXA==')\n  })","file":"index.ts","skipped":false,"dir":"packages/cafs/test"},{"name":"replaces an already existing file, if the integrity of it was broken","suites":["cafs"],"updatePoint":{"line":25,"column":74},"line":25,"code":"  it('replaces an already existing file, if the integrity of it was broken', async () => {\n    const storeDir = tempy.directory()\n    const srcDir = path.join(__dirname, 'fixtures/one-file')\n    const addFiles = async () => createCafs(storeDir).addFilesFromDir(srcDir)\n\n    let filesIndex = await addFiles()\n    const { integrity } = await filesIndex['foo.txt'].writeResult\n\n    // Modifying the file in the store\n    const filePath = getFilePathInCafs(storeDir, integrity, 'nonexec')\n    await fs.appendFile(filePath, 'bar')\n\n    filesIndex = await addFiles()\n    await filesIndex['foo.txt'].writeResult\n    expect(await fs.readFile(filePath, 'utf8')).toBe('foo\\n')\n  })","file":"index.ts","skipped":false,"dir":"packages/cafs/test"},{"name":"doesn't fail if file was removed from the store","suites":["checkFilesIntegrity()"],"updatePoint":{"line":44,"column":53},"line":44,"code":"  it(\"doesn't fail if file was removed from the store\", async () => {\n    const storeDir = tempy.directory()\n    expect(await checkFilesIntegrity(storeDir, {\n      foo: {\n        integrity: 'sha512-8xCvrlC7W3TlwXxetv5CZTi53szYhmT7tmpXF/ttNthtTR9TC7Y7WJFPmJToHaSQ4uObuZyOARdOJYNYuTSbXA==',\n        mode: 420,\n        size: 10,\n      },\n    })).toBeFalsy()\n  })","file":"index.ts","skipped":false,"dir":"packages/cafs/test"},{"name":"file names are normalized when unpacking a tarball","suites":["checkFilesIntegrity()"],"updatePoint":{"line":56,"column":56},"line":56,"code":"test('file names are normalized when unpacking a tarball', async () => {\n  const dest = tempy.directory()\n  const cafs = createCafs(dest)\n  const filesIndex = await cafs.addFilesFromTarball(\n    createReadStream(path.join(__dirname, 'fixtures/colorize-semver-diff.tgz'))\n  )\n  expect(Object.keys(filesIndex).sort()).toStrictEqual([\n    'LICENSE',\n    'README.md',\n    'lib/index.d.ts',\n    'lib/index.js',\n    'package.json',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/cafs/test"},{"name":"createClient()","suites":[],"updatePoint":{"line":4,"column":20},"line":4,"code":"test('createClient()', () => {\n  const client = createClient({\n    authConfig: { registry: 'https://registry.npmjs.org/' },\n    cacheDir: '',\n  })\n  expect(typeof client === 'object').toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/client/test"},{"name":"createResolver()","suites":[],"updatePoint":{"line":12,"column":22},"line":12,"code":"test('createResolver()', () => {\n  const resolver = createResolver({\n    authConfig: { registry: 'https://registry.npmjs.org/' },\n    cacheDir: '',\n  })\n  expect(typeof resolver === 'function').toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/client/test"},{"name":"default workspace concurrency","suites":[],"updatePoint":{"line":6,"column":35},"line":6,"code":"test('default workspace concurrency', () => {\n  const n = getWorkspaceConcurrency(undefined)\n\n  expect(n).toBe(4)\n})","file":"concurrency.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"get back positive amount","suites":[],"updatePoint":{"line":12,"column":30},"line":12,"code":"test('get back positive amount', () => {\n  expect(getWorkspaceConcurrency(5)).toBe(5)\n})","file":"concurrency.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"match host cores amount","suites":[],"updatePoint":{"line":16,"column":29},"line":16,"code":"test('match host cores amount', () => {\n  const n = getWorkspaceConcurrency(0)\n\n  expect(n).toBe(hostCores)\n})","file":"concurrency.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"host cores minus X","suites":[],"updatePoint":{"line":22,"column":24},"line":22,"code":"test('host cores minus X', () => {\n  const n1 = getWorkspaceConcurrency(-1)\n\n  expect(n1).toBe(Math.max(1, hostCores - 1))\n\n  const n2 = getWorkspaceConcurrency(-9999)\n\n  expect(n2).toBe(1)\n})","file":"concurrency.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"getCacheDir()","suites":[],"updatePoint":{"line":5,"column":19},"line":5,"code":"test('getCacheDir()', () => {\n  expect(getCacheDir({\n    env: {\n      XDG_CACHE_HOME: '/home/foo/cache',\n    },\n    platform: 'linux',\n  })).toBe(path.join('/home/foo/cache', 'pnpm'))\n  expect(getCacheDir({\n    env: {},\n    platform: 'linux',\n  })).toBe(path.join(os.homedir(), '.cache/pnpm'))\n  expect(getCacheDir({\n    env: {},\n    platform: 'darwin',\n  })).toBe(path.join(os.homedir(), 'Library/Caches/pnpm'))\n  expect(getCacheDir({\n    env: {\n      LOCALAPPDATA: '/localappdata',\n    },\n    platform: 'win32',\n  })).toBe(path.join('/localappdata', 'pnpm-cache'))\n  expect(getCacheDir({\n    env: {},\n    platform: 'win32',\n  })).toBe(path.join(os.homedir(), '.pnpm-cache'))\n})","file":"dirs.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"getStateDir()","suites":[],"updatePoint":{"line":32,"column":19},"line":32,"code":"test('getStateDir()', () => {\n  expect(getStateDir({\n    env: {\n      XDG_STATE_HOME: '/home/foo/state',\n    },\n    platform: 'linux',\n  })).toBe(path.join('/home/foo/state', 'pnpm'))\n  expect(getStateDir({\n    env: {},\n    platform: 'linux',\n  })).toBe(path.join(os.homedir(), '.local/state/pnpm'))\n  expect(getStateDir({\n    env: {},\n    platform: 'darwin',\n  })).toBe(path.join(os.homedir(), '.pnpm-state'))\n  expect(getStateDir({\n    env: {\n      LOCALAPPDATA: '/localappdata',\n    },\n    platform: 'win32',\n  })).toBe(path.join('/localappdata', 'pnpm-state'))\n  expect(getStateDir({\n    env: {},\n    platform: 'win32',\n  })).toBe(path.join(os.homedir(), '.pnpm-state'))\n})","file":"dirs.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"getDataDir()","suites":[],"updatePoint":{"line":59,"column":18},"line":59,"code":"test('getDataDir()', () => {\n  expect(getDataDir({\n    env: {\n      XDG_DATA_HOME: '/home/foo/data',\n    },\n    platform: 'linux',\n  })).toBe(path.join('/home/foo/data', 'pnpm'))\n  expect(getDataDir({\n    env: {},\n    platform: 'linux',\n  })).toBe(path.join(os.homedir(), '.local/share/pnpm'))\n  expect(getDataDir({\n    env: {},\n    platform: 'darwin',\n  })).toBe(path.join(os.homedir(), 'Library/pnpm'))\n  expect(getDataDir({\n    env: {\n      LOCALAPPDATA: '/localappdata',\n    },\n    platform: 'win32',\n  })).toBe(path.join('/localappdata', 'pnpm'))\n  expect(getDataDir({\n    env: {},\n    platform: 'win32',\n  })).toBe(path.join(os.homedir(), '.pnpm'))\n})","file":"dirs.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"getConfigDir()","suites":[],"updatePoint":{"line":86,"column":20},"line":86,"code":"test('getConfigDir()', () => {\n  expect(getConfigDir({\n    env: {\n      XDG_CONFIG_HOME: '/home/foo/config',\n    },\n    platform: 'linux',\n  })).toBe(path.join('/home/foo/config', 'pnpm'))\n  expect(getConfigDir({\n    env: {},\n    platform: 'linux',\n  })).toBe(path.join(os.homedir(), '.config/pnpm'))\n  expect(getConfigDir({\n    env: {},\n    platform: 'darwin',\n  })).toBe(path.join(os.homedir(), 'Library/Preferences/pnpm'))\n  expect(getConfigDir({\n    env: {\n      LOCALAPPDATA: '/localappdata',\n    },\n    platform: 'win32',\n  })).toBe(path.join('/localappdata', 'pnpm/config'))\n  expect(getConfigDir({\n    env: {},\n    platform: 'win32',\n  })).toBe(path.join(os.homedir(), '.config/pnpm'))\n})","file":"dirs.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"respects global-bin-dir in npmrc","suites":[],"updatePoint":{"line":34,"column":38},"line":34,"code":"test('respects global-bin-dir in npmrc', async () => {\n  const { config } = await getConfig({\n    cliOptions: {\n      global: true,\n    },\n    env: {\n      [pathName]: `${globalBinDir}${path.delimiter}${process.env[pathName]!}`,\n    },\n    packageManager: {\n      name: 'pnpm',\n      version: '1.0.0',\n    },\n  })\n  expect(config.bin).toBe(globalBinDir)\n})","file":"globalBinDir.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"respects global-bin-dir rather than dir","suites":[],"updatePoint":{"line":50,"column":45},"line":50,"code":"test('respects global-bin-dir rather than dir', async () => {\n  const { config } = await getConfig({\n    cliOptions: {\n      global: true,\n      dir: __dirname,\n    },\n    env: {\n      [pathName]: `${globalBinDir}${path.delimiter}${process.env[pathName]!}`,\n    },\n    packageManager: {\n      name: 'pnpm',\n      version: '1.0.0',\n    },\n  })\n  expect(config.bin).toBe(globalBinDir)\n})","file":"globalBinDir.test.ts","skipped":false,"dir":"packages/config/test"},{"name":"allProjectsAreUpToDate(): works with packages linked through the workspace protocol using relative path","suites":[],"updatePoint":{"line":16,"column":109},"line":16,"code":"test('allProjectsAreUpToDate(): works with packages linked through the workspace protocol using relative path', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          foo: 'workspace:../foo',\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            foo: 'link:../foo',\n          },\n          specifiers: {\n            foo: 'workspace:../foo',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeTruthy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): works with aliased local dependencies","suites":[],"updatePoint":{"line":54,"column":69},"line":54,"code":"test('allProjectsAreUpToDate(): works with aliased local dependencies', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          alias: 'npm:foo',\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            alias: 'link:../foo',\n          },\n          specifiers: {\n            alias: 'npm:foo',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeTruthy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): works with aliased local dependencies that specify versions","suites":[],"updatePoint":{"line":92,"column":91},"line":92,"code":"test('allProjectsAreUpToDate(): works with aliased local dependencies that specify versions', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          alias: 'npm:foo@1',\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            alias: 'link:../foo',\n          },\n          specifiers: {\n            alias: 'npm:foo@1',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeTruthy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): returns false if the aliased dependency version is out of date","suites":[],"updatePoint":{"line":130,"column":94},"line":130,"code":"test('allProjectsAreUpToDate(): returns false if the aliased dependency version is out of date', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          alias: 'npm:foo@0',\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            alias: 'link:../foo',\n          },\n          specifiers: {\n            alias: 'npm:foo@0',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeFalsy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): use link and registry version if linkWorkspacePackages = false","suites":[],"updatePoint":{"line":168,"column":94},"line":168,"code":"test('allProjectsAreUpToDate(): use link and registry version if linkWorkspacePackages = false', async () => {\n  expect(\n    await allProjectsAreUpToDate(\n      [\n        {\n          id: 'bar',\n          manifest: {\n            dependencies: {\n              foo: 'workspace:*',\n            },\n          },\n          rootDir: 'bar',\n        },\n        {\n          id: 'bar2',\n          manifest: {\n            dependencies: {\n              foo: '1.0.0',\n            },\n          },\n          rootDir: 'bar2',\n        },\n        {\n          id: 'foo',\n          manifest: fooManifest,\n          rootDir: 'foo',\n        },\n      ],\n      {\n        linkWorkspacePackages: false,\n        wantedLockfile: {\n          importers: {\n            bar: {\n              dependencies: {\n                foo: 'link:../foo',\n              },\n              specifiers: {\n                foo: 'workspace:*',\n              },\n            },\n            bar2: {\n              dependencies: {\n                foo: '1.0.0',\n              },\n              specifiers: {\n                foo: '1.0.0',\n              },\n            },\n            foo: {\n              specifiers: {},\n            },\n          },\n          lockfileVersion: 5,\n        },\n        workspacePackages,\n      }\n    )\n  ).toBeTruthy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): returns false if dependenciesMeta differs","suites":[],"updatePoint":{"line":228,"column":73},"line":228,"code":"test('allProjectsAreUpToDate(): returns false if dependenciesMeta differs', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          foo: 'workspace:../foo',\n        },\n        dependenciesMeta: {\n          foo: {\n            injected: true,\n          },\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            foo: 'link:../foo',\n          },\n          specifiers: {\n            foo: 'workspace:../foo',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeFalsy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"allProjectsAreUpToDate(): returns true if dependenciesMeta matches","suites":[],"updatePoint":{"line":271,"column":72},"line":271,"code":"test('allProjectsAreUpToDate(): returns true if dependenciesMeta matches', async () => {\n  expect(await allProjectsAreUpToDate([\n    {\n      id: 'bar',\n      manifest: {\n        dependencies: {\n          foo: 'workspace:../foo',\n        },\n        dependenciesMeta: {\n          foo: {\n            injected: true,\n          },\n        },\n      },\n      rootDir: 'bar',\n    },\n    {\n      id: 'foo',\n      manifest: fooManifest,\n      rootDir: 'foo',\n    },\n  ], {\n    linkWorkspacePackages: true,\n    wantedLockfile: {\n      importers: {\n        bar: {\n          dependencies: {\n            foo: 'link:../foo',\n          },\n          dependenciesMeta: {\n            foo: {\n              injected: true,\n            },\n          },\n          specifiers: {\n            foo: 'workspace:../foo',\n          },\n        },\n        foo: {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: 5,\n    },\n    workspacePackages,\n  })).toBeTruthy()\n})","file":"allProjectsAreUpToDate.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"cannot resolve peer dependency for top-level dependency","suites":[],"updatePoint":{"line":5,"column":61},"line":5,"code":"test('cannot resolve peer dependency for top-level dependency', async () => {\n  prepareEmpty()\n\n  const peerDependencyIssues = await getPeerDependencyIssues([\n    {\n      manifest: {\n        dependencies: {\n          'ajv-keywords': '1.5.0',\n        },\n      },\n      rootDir: process.cwd(),\n    },\n  ], await testDefaults())\n\n  expect(peerDependencyIssues['.'].missing).toHaveProperty('ajv')\n})","file":"getPeerDependencyIssues.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"a conflict is detected when the same peer is required with ranges that do not overlap","suites":[],"updatePoint":{"line":22,"column":91},"line":22,"code":"test('a conflict is detected when the same peer is required with ranges that do not overlap', async () => {\n  prepareEmpty()\n\n  const peerDependencyIssues = await getPeerDependencyIssues([\n    {\n      manifest: {\n        dependencies: {\n          'has-foo100-peer': '1.0.0',\n          'has-foo101-peer': '1.0.0',\n        },\n      },\n      rootDir: process.cwd(),\n    },\n  ], await testDefaults())\n\n  expect(peerDependencyIssues['.'].conflicts.length).toBe(1)\n})","file":"getPeerDependencyIssues.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPackageExtender() extends the supported fields","suites":[],"updatePoint":{"line":33,"column":58},"line":33,"code":"test('createPackageExtender() extends the supported fields', () => {\n  expect(\n    packageExtender({\n      name: 'foo',\n      dependencies: {\n        bar: '^1.0.0',\n      },\n    })\n  ).toStrictEqual({\n    name: 'foo',\n    dependencies: {\n      bar: '^1.0.0',\n      a: '1',\n    },\n    optionalDependencies: {\n      b: '2',\n    },\n    peerDependencies: {\n      c: '3',\n    },\n    peerDependenciesMeta: {\n      c: {\n        optional: true,\n      },\n    },\n  })\n})","file":"install/createPackageExtender.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPackageExtender() does not change packages that should not be extended","suites":[],"updatePoint":{"line":61,"column":82},"line":61,"code":"test('createPackageExtender() does not change packages that should not be extended', () => {\n  const manifest = { name: 'ignore' }\n  expect(packageExtender(manifest)).toStrictEqual(manifest)\n})","file":"install/createPackageExtender.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPackageExtender() matches by version","suites":[],"updatePoint":{"line":66,"column":48},"line":66,"code":"test('createPackageExtender() matches by version', () => {\n  expect(\n    packageExtender({\n      name: 'bar',\n      version: '1.0.0',\n    })\n  ).toStrictEqual({\n    name: 'bar',\n    version: '1.0.0',\n    dependencies: {\n      d: '1',\n    },\n  })\n})","file":"install/createPackageExtender.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPackageExtender() does not override existing fields","suites":[],"updatePoint":{"line":81,"column":63},"line":81,"code":"test('createPackageExtender() does not override existing fields', () => {\n  expect(\n    packageExtender({\n      name: 'qar',\n      version: '1.0.0',\n      dependencies: {\n        e: '100',\n      },\n    })\n  ).toStrictEqual({\n    name: 'qar',\n    version: '1.0.0',\n    dependencies: {\n      e: '100',\n      f: '1',\n    },\n  })\n})","file":"install/createPackageExtender.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPeerDependencyPatcher() ignores missing","suites":[],"updatePoint":{"line":3,"column":51},"line":3,"code":"test('createPeerDependencyPatcher() ignores missing', () => {\n  const patcher = createPeerDependencyPatcher({\n    ignoreMissing: ['foo'],\n  })\n  const patchedPkg = patcher({\n    peerDependencies: {\n      foo: '*',\n      bar: '*',\n    },\n  })\n  expect(patchedPkg['peerDependenciesMeta']).toStrictEqual({\n    foo: {\n      optional: true,\n    },\n  })\n})","file":"install/createPeerDependencyPatcher.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createPeerDependencyPatcher() extends peer ranges","suites":[],"updatePoint":{"line":20,"column":55},"line":20,"code":"test('createPeerDependencyPatcher() extends peer ranges', () => {\n  const patcher = createPeerDependencyPatcher({\n    allowedVersions: {\n      foo: '1',\n      qar: '1',\n      baz: '*',\n    },\n  })\n  const patchedPkg = patcher({\n    peerDependencies: {\n      foo: '0',\n      bar: '0',\n      qar: '*',\n      baz: '1',\n    },\n  })\n  expect(patchedPkg['peerDependencies']).toStrictEqual({\n    foo: '0 || 1',\n    bar: '0',\n    qar: '*',\n    baz: '*',\n  })\n})","file":"install/createPeerDependencyPatcher.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() matches subranges","suites":[],"updatePoint":{"line":4,"column":49},"line":4,"code":"test('createVersionsOverrider() matches subranges', () => {\n  const overrider = createVersionsOverrider({\n    'foo@2': '2.12.0',\n    'qar@>2': '1.0.0',\n  }, process.cwd())\n  expect(\n    overrider({\n      dependencies: { foo: '^2.10.0' },\n      optionalDependencies: { qar: '^4.0.0' },\n    })\n  ).toStrictEqual({\n    dependencies: { foo: '2.12.0' },\n    optionalDependencies: { qar: '1.0.0' },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() does not fail on non-range selectors","suites":[],"updatePoint":{"line":20,"column":68},"line":20,"code":"test('createVersionsOverrider() does not fail on non-range selectors', () => {\n  const overrider = createVersionsOverrider({\n    'foo@2': '2.12.0',\n    'bar@github:org/bar': '2.12.0',\n  }, process.cwd())\n  expect(\n    overrider({\n      dependencies: {\n        foo: 'github:org/foo',\n        bar: 'github:org/bar',\n      },\n    })\n  ).toStrictEqual({\n    dependencies: {\n      foo: 'github:org/foo',\n      bar: '2.12.0',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() overrides dependencies of specified packages only","suites":[],"updatePoint":{"line":40,"column":81},"line":40,"code":"test('createVersionsOverrider() overrides dependencies of specified packages only', () => {\n  const overrider = createVersionsOverrider({\n    'foo@1>bar@^1.2.0': '3.0.0',\n    'qar@1>bar@>4': '3.0.0',\n  }, process.cwd())\n  expect(overrider({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      bar: '^1.2.0',\n    },\n  })).toStrictEqual({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      bar: '3.0.0',\n    },\n  })\n  expect(overrider({\n    name: 'foo',\n    version: '2.0.0',\n    dependencies: {\n      bar: '^1.2.0',\n    },\n  })).toStrictEqual({\n    name: 'foo',\n    version: '2.0.0',\n    dependencies: {\n      bar: '^1.2.0',\n    },\n  })\n  expect(overrider({\n    name: 'qar',\n    version: '1.0.0',\n    dependencies: {\n      bar: '^10.0.0',\n    },\n  })).toStrictEqual({\n    name: 'qar',\n    version: '1.0.0',\n    dependencies: {\n      bar: '3.0.0',\n    },\n  })\n  expect(overrider({\n    name: 'qar',\n    version: '1.0.0',\n    dependencies: {\n      bar: '^4.0.0',\n    },\n  })).toStrictEqual({\n    name: 'qar',\n    version: '1.0.0',\n    dependencies: {\n      bar: '^4.0.0',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() overrides all types of dependencies","suites":[],"updatePoint":{"line":99,"column":67},"line":99,"code":"test('createVersionsOverrider() overrides all types of dependencies', () => {\n  const overrider = createVersionsOverrider({\n    foo: '3.0.0',\n    bar: '3.0.0',\n    qar: '3.0.0',\n  }, process.cwd())\n  expect(overrider({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      foo: '^1.2.0',\n    },\n    optionalDependencies: {\n      bar: '^1.2.0',\n    },\n    devDependencies: {\n      qar: '^1.2.0',\n    },\n  })).toStrictEqual({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      foo: '3.0.0',\n    },\n    optionalDependencies: {\n      bar: '3.0.0',\n    },\n    devDependencies: {\n      qar: '3.0.0',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() overrides dependencies with links","suites":[],"updatePoint":{"line":132,"column":65},"line":132,"code":"test('createVersionsOverrider() overrides dependencies with links', () => {\n  const overrider = createVersionsOverrider({\n    qar: 'link:../qar',\n  }, process.cwd())\n  expect(overrider({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      qar: '3.0.0',\n    },\n  }, path.resolve('pkg'))).toStrictEqual({\n    name: 'foo',\n    version: '1.2.0',\n    dependencies: {\n      qar: 'link:../../qar',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() overrides dependency of pkg matched by name and version","suites":[],"updatePoint":{"line":151,"column":87},"line":151,"code":"test('createVersionsOverrider() overrides dependency of pkg matched by name and version', () => {\n  const overrider = createVersionsOverrider({\n    'yargs@^7.1.0>yargs-parser': '^20.0.0',\n  }, process.cwd())\n  expect(\n    overrider({\n      name: 'yargs',\n      version: '7.1.0',\n      dependencies: {\n        'yargs-parser': '19',\n      },\n    })\n  ).toStrictEqual({\n    name: 'yargs',\n    version: '7.1.0',\n    dependencies: {\n      'yargs-parser': '^20.0.0',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() does not override dependency of pkg matched by name and version","suites":[],"updatePoint":{"line":172,"column":95},"line":172,"code":"test('createVersionsOverrider() does not override dependency of pkg matched by name and version', () => {\n  const overrider = createVersionsOverrider({\n    'yargs@^8.1.0>yargs-parser': '^20.0.0',\n  }, process.cwd())\n  expect(\n    overrider({\n      name: 'yargs',\n      version: '7.1.0',\n      dependencies: {\n        'yargs-parser': '19',\n      },\n    })\n  ).toStrictEqual({\n    name: 'yargs',\n    version: '7.1.0',\n    dependencies: {\n      'yargs-parser': '19',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() should work for scoped parent and unscoped child","suites":[],"updatePoint":{"line":193,"column":80},"line":193,"code":"test('createVersionsOverrider() should work for scoped parent and unscoped child', () => {\n  const overrider = createVersionsOverrider({\n    '@scoped/package>unscoped-package': 'workspace:*',\n  }, process.cwd())\n  expect(\n    overrider({\n      name: '@scoped/package',\n      version: '1.0.0',\n      dependencies: {\n        'unscoped-package': '1.0.0',\n      },\n    })\n  ).toStrictEqual({\n    name: '@scoped/package',\n    version: '1.0.0',\n    dependencies: {\n      'unscoped-package': 'workspace:*',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() should work for unscoped parent and scoped child","suites":[],"updatePoint":{"line":214,"column":80},"line":214,"code":"test('createVersionsOverrider() should work for unscoped parent and scoped child', () => {\n  const overrider = createVersionsOverrider({\n    'unscoped-package>@scoped/package': 'workspace:*',\n  }, process.cwd())\n  expect(\n    overrider({\n      name: 'unscoped-package',\n      version: '1.0.0',\n      dependencies: {\n        '@scoped/package': '1.0.0',\n      },\n    })\n  ).toStrictEqual({\n    name: 'unscoped-package',\n    version: '1.0.0',\n    dependencies: {\n      '@scoped/package': 'workspace:*',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"createVersionsOverrider() should work for scoped parent and scoped child","suites":[],"updatePoint":{"line":235,"column":78},"line":235,"code":"test('createVersionsOverrider() should work for scoped parent and scoped child', () => {\n  const overrider = createVersionsOverrider({\n    '@scoped/package>@scoped/package2': 'workspace:*',\n  }, process.cwd())\n  expect(\n    overrider({\n      name: '@scoped/package',\n      version: '1.0.0',\n      dependencies: {\n        '@scoped/package2': '1.0.0',\n      },\n    })\n  ).toStrictEqual({\n    name: '@scoped/package',\n    version: '1.0.0',\n    dependencies: {\n      '@scoped/package2': 'workspace:*',\n    },\n  })\n})","file":"install/createVersionOverrider.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"logger with filterLog hook","suites":[],"updatePoint":{"line":5,"column":32},"line":5,"code":"test('logger with filterLog hook', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        hooks: {\n          filterLog: (log: Log) => {\n            if (log.level === 'debug') {\n              return false\n            }\n            if (log.level === 'warn') {\n              if (log.message === 'aaa') {\n                return false\n              }\n              if (log.prefix === '/tmp') {\n                return false\n              }\n            }\n            return true\n          },\n        },\n      } as any, // eslint-disable-line\n    },\n    streamParser: createStreamParser(),\n  })\n\n  // debug level is filtered out\n  logger.debug({\n    message: 'debug message',\n  })\n  // message equals to 'aaa' is filtered out\n  logger.warn({\n    message: 'aaa',\n    prefix: '/root',\n  })\n  logger.warn({\n    message: 'bbb',\n    prefix: '/root',\n  })\n  // prefix equals to '/tmp' is filtered out\n  logger.warn({\n    message: 'ccc',\n    prefix: '/tmp',\n  })\n\n  expect.assertions(1)\n\n  const subscription = output$.subscribe({\n    complete: () => done(),\n    error: done,\n    next: (msg) => {\n      expect(msg).toEqual(expect.stringContaining('bbb'))\n    },\n  })\n\n  setTimeout(() => {\n    done()\n    subscription.unsubscribe()\n  }, 10)\n})","file":"filterLogHook.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints summary (of current package only)","suites":[],"updatePoint":{"line":36,"column":46},"line":36,"code":"test('prints summary (of current package only)', (done) => {\n  const prefix = '/home/jane/project'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ added: 5, prefix: `${prefix}/packages/foo` })\n  statsLogger.debug({ removed: 1, prefix: `${prefix}/packages/foo` })\n  packageManifestLogger.debug({\n    initial: {\n      name: 'foo',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-13': '^1.0.0',\n      },\n      devDependencies: {\n        'is-negative': '^1.0.0',\n      },\n    },\n    prefix,\n  })\n  deprecationLogger.debug({\n    deprecated: 'This package was deprecated because bla bla bla',\n    depth: 0,\n    pkgId: 'registry.npmjs.org/bar/2.0.0',\n    pkgName: 'bar',\n    pkgVersion: '2.0.0',\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/foo/1.0.0',\n      latest: '2.0.0',\n      name: 'foo',\n      realName: 'foo',\n      version: '1.0.0',\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/bar/2.0.0',\n      latest: '1.0.0', // this won't be printed in summary because latest is less than current version\n      name: 'bar',\n      realName: 'bar',\n      version: '2.0.0',\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    prefix,\n    removed: {\n      dependencyType: 'prod',\n      name: 'foo',\n      version: '0.1.0',\n    },\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'dev',\n      id: 'registry.npmjs.org/qar/2.0.0',\n      name: 'qar',\n      realName: 'qar',\n      version: '2.0.0',\n    },\n    prefix,\n  })\n  // This log is going to be ignored because it is not in the current prefix\n  rootLogger.debug({\n    added: {\n      dependencyType: 'optional',\n      id: 'registry.npmjs.org/lala/2.0.0',\n      name: 'lala',\n      realName: 'lala',\n      version: '2.0.0',\n    },\n    prefix: `${prefix}/packages/foo`,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'optional',\n      id: 'registry.npmjs.org/lala/1.1.0',\n      name: 'lala',\n      realName: 'lala',\n      version: '1.1.0',\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    prefix,\n    removed: {\n      dependencyType: 'optional',\n      name: 'is-positive',\n    },\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'optional',\n      linkedFrom: '/src/is-linked',\n      name: 'is-linked',\n      realName: 'is-linked',\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/winst0n/2.0.0',\n      latest: '1.0.0',\n      name: 'winston',\n      realName: 'winst0n',\n      version: '1.0.0',\n    },\n    prefix,\n  })\n  packageManifestLogger.debug({\n    prefix,\n    updated: {\n      dependencies: {\n        'is-negative': '^1.0.0',\n      },\n      devDependencies: {\n        'is-13': '^1.0.0',\n      },\n    },\n  })\n  rootLogger.debug({\n    added: {\n      linkedFrom: '/src/is-linked2',\n      name: 'is-linked2',\n      realName: 'is-linked2',\n    },\n    prefix,\n  })\n  summaryLogger.debug({ prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(2), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`packages/foo                             |   ${chalk.green('+5')}   ${chalk.red('-1')} ${ADD + SUB}${EOL}` +\n        `${formatWarn(`${DEPRECATED} bar@2.0.0: This package was deprecated because bla bla bla`)}${EOL}${EOL}` +\n        `\\\n${h1('dependencies:')}\n${ADD} bar ${versionColor('2.0.0')} ${DEPRECATED}\n${SUB} foo ${versionColor('0.1.0')}\n${ADD} foo ${versionColor('1.0.0')} ${versionColor('(2.0.0 is available)')}\n${SUB} is-13 ${versionColor('^1.0.0')}\n${ADD} is-negative ${versionColor('^1.0.0')}\n${ADD} winston <- winst0n ${versionColor('1.0.0')}\n\n${h1('optionalDependencies:')}\n${ADD} is-linked ${chalk.grey(`<- ${path.relative(prefix, '/src/is-linked')}`)}\n${SUB} is-positive\n${ADD} lala ${versionColor('1.1.0')}\n\n${h1('devDependencies:')}\n${ADD} is-13 ${versionColor('^1.0.0')}\n${SUB} is-negative ${versionColor('^1.0.0')}\n${ADD} qar ${versionColor('2.0.0')}\n\n${h1('node_modules:')}\n${ADD} is-linked2 ${chalk.grey(`<- ${path.relative(prefix, '/src/is-linked2')}`)}\n`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints summary for global installation","suites":[],"updatePoint":{"line":213,"column":44},"line":213,"code":"test('prints summary for global installation', (done) => {\n  const prefix = '/home/jane/.nvs/node/10.0.0/x64/pnpm-global/1'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        dir: prefix,\n        global: true,\n      } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/foo/1.0.0',\n      latest: '2.0.0',\n      name: 'foo',\n      realName: 'foo',\n      version: '1.0.0',\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/bar/2.0.0',\n      latest: '1.0.0', // this won't be printed in summary because latest is less than current version\n      name: 'bar',\n      realName: 'bar',\n      version: '2.0.0',\n    },\n    prefix,\n  })\n  packageManifestLogger.debug({\n    prefix,\n    updated: {\n      dependencies: {\n        'is-negative': '^1.0.0',\n      },\n      devDependencies: {\n        'is-13': '^1.0.0',\n      },\n    },\n  })\n  summaryLogger.debug({ prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(EOL + `\\\n${h1(`${prefix}:`)}\n${ADD} bar ${versionColor('2.0.0')}\n${ADD} foo ${versionColor('1.0.0')} ${versionColor('(2.0.0 is available)')}\n`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints added peer dependency","suites":[],"updatePoint":{"line":276,"column":34},"line":276,"code":"test('prints added peer dependency', (done) => {\n  const prefix = '/home/jane/.nvs/node/10.0.0/x64/pnpm-global/1'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        dir: prefix,\n      } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  packageManifestLogger.debug({\n    initial: {},\n    prefix,\n  })\n  packageManifestLogger.debug({\n    prefix,\n    updated: {\n      devDependencies: {\n        'is-negative': '^1.0.0',\n      },\n      peerDependencies: {\n        'is-negative': '^1.0.0',\n      },\n    },\n  })\n  summaryLogger.debug({ prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(EOL + `\\\n${h1('peerDependencies:')}\n${ADD} is-negative ${versionColor('^1.0.0')}\n\n${h1('devDependencies:')}\n${ADD} is-negative ${versionColor('^1.0.0')}\n`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints summary correctly when the same package is specified both in optional and prod dependencies","suites":[],"updatePoint":{"line":322,"column":104},"line":322,"code":"test('prints summary correctly when the same package is specified both in optional and prod dependencies', (done) => {\n  const prefix = '/home/jane/.nvs/node/10.0.0/x64/pnpm-global/1'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        dir: prefix,\n      } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  packageManifestLogger.debug({\n    initial: {\n      name: 'foo',\n      version: '1.0.0',\n\n      dependencies: {\n        bar: '^2.0.0',\n        foo: '^1.0.0',\n      },\n      optionalDependencies: {\n        foo: '^1.0.0',\n      },\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/bar/2.0.0',\n      name: 'bar',\n      realName: 'bar',\n      version: '2.0.0',\n    },\n    prefix,\n  })\n  packageManifestLogger.debug({\n    prefix,\n    updated: {\n      dependencies: {\n        bar: '^2.0.0',\n      },\n      optionalDependencies: {\n        foo: '^1.0.0',\n      },\n    },\n  })\n  summaryLogger.debug({ prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(EOL + `\\\n${h1('dependencies:')}\n${ADD} bar ${versionColor('2.0.0')}\n`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"in the installation summary report which dependency types are skipped","suites":[],"updatePoint":{"line":386,"column":75},"line":386,"code":"test('in the installation summary report which dependency types are skipped', (done) => {\n  const prefix = '/home/jane/.nvs/node/10.0.0/x64/pnpm-global/1'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        dir: prefix,\n        production: true,\n        dev: false,\n        optional: false,\n      } as Config,\n      env: {\n        NODE_ENV: 'production',\n      },\n    },\n    streamParser: createStreamParser(),\n  })\n\n  packageManifestLogger.debug({\n    initial: {\n      name: 'foo',\n      version: '1.0.0',\n\n      dependencies: {\n        bar: '^2.0.0',\n        foo: '^1.0.0',\n      },\n      optionalDependencies: {\n        foo: '^1.0.0',\n      },\n    },\n    prefix,\n  })\n  rootLogger.debug({\n    added: {\n      dependencyType: 'prod',\n      id: 'registry.npmjs.org/bar/2.0.0',\n      name: 'bar',\n      realName: 'bar',\n      version: '2.0.0',\n    },\n    prefix,\n  })\n  packageManifestLogger.debug({\n    prefix,\n    updated: {\n      dependencies: {\n        bar: '^2.0.0',\n      },\n      optionalDependencies: {\n        foo: '^1.0.0',\n      },\n    },\n  })\n  summaryLogger.debug({ prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(EOL + `\\\n${h1('dependencies:')}\n${ADD} bar ${versionColor('2.0.0')}\n\n${h1('optionalDependencies:')} skipped\n\n${h1('devDependencies:')} skipped because NODE_ENV is set to production\n`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints summary when some packages fail","suites":[],"updatePoint":{"line":460,"column":44},"line":460,"code":"test('prints summary when some packages fail', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['run'], config: { recursive: true } as Config },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(EOL + `Summary: ${chalk.red('6 fails')}, 7 passes\n\n/a:\n${formatError('ERROR', 'a failed')}\n\n/b:\n${formatError('ERROR', 'b failed')}\n\n/c:\n${formatError('ERROR', 'c failed')}\n\n/d:\n${formatError('ERROR', 'd failed')}\n\n/e:\n${formatError('ERROR', 'e failed')}\n\n/f:\n${formatError('ERROR', 'f failed')}`)\n    },\n  })\n\n  const err = new PnpmError('RECURSIVE_FAIL', '...')\n  err['fails'] = [\n    {\n      message: 'a failed',\n      prefix: '/a',\n    },\n    {\n      message: 'b failed',\n      prefix: '/b',\n    },\n    {\n      message: 'c failed',\n      prefix: '/c',\n    },\n    {\n      message: 'd failed',\n      prefix: '/d',\n    },\n    {\n      message: 'e failed',\n      prefix: '/e',\n    },\n    {\n      message: 'f failed',\n      prefix: '/f',\n    },\n  ]\n  err['passes'] = 7\n  logger.error(err, err)\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints info","suites":[],"updatePoint":{"line":525,"column":17},"line":525,"code":"test('prints info', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  logger.info({ message: 'info message', prefix: process.cwd() })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('info message')\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints added/removed stats during installation","suites":[],"updatePoint":{"line":544,"column":52},"line":544,"code":"test('prints added/removed stats during installation', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ added: 5, prefix })\n  statsLogger.debug({ removed: 1, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+5')} ${chalk.red('-1')}\n${ADD + ADD + ADD + ADD + ADD + SUB}`\n      )\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints added/removed stats during installation when 0 removed","suites":[],"updatePoint":{"line":567,"column":67},"line":567,"code":"test('prints added/removed stats during installation when 0 removed', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ added: 2, prefix })\n  statsLogger.debug({ removed: 0, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+2')}\n${ADD + ADD}`\n      )\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints only the added stats if nothing was removed","suites":[],"updatePoint":{"line":590,"column":56},"line":590,"code":"test('prints only the added stats if nothing was removed', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 0, prefix })\n  statsLogger.debug({ added: 1, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+1')}\n${ADD}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints only the removed stats if nothing was added","suites":[],"updatePoint":{"line":612,"column":56},"line":612,"code":"test('prints only the removed stats if nothing was added', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 1, prefix })\n  statsLogger.debug({ added: 0, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.red('-1')}\n${SUB}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints only the added stats if nothing was removed and a lot added","suites":[],"updatePoint":{"line":634,"column":72},"line":634,"code":"test('prints only the added stats if nothing was removed and a lot added', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 20 },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 0, prefix })\n  statsLogger.debug({ added: 100, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+100')}\n${repeat(ADD, 20).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints only the removed stats if nothing was added and a lot removed","suites":[],"updatePoint":{"line":657,"column":74},"line":657,"code":"test('prints only the removed stats if nothing was added and a lot removed', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 20 },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 100, prefix })\n  statsLogger.debug({ added: 0, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.red('-100')}\n${repeat(SUB, 20).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints at least one remove sign when removed !== 0","suites":[],"updatePoint":{"line":680,"column":56},"line":680,"code":"test('prints at least one remove sign when removed !== 0', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 20 },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 1, prefix })\n  statsLogger.debug({ added: 100, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+100')} ${chalk.red('-1')}\n${repeat(ADD, 19).join('') + SUB}`\n      )\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints at least one add sign when added !== 0","suites":[],"updatePoint":{"line":704,"column":51},"line":704,"code":"test('prints at least one add sign when added !== 0', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 20 },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 100, prefix })\n  statsLogger.debug({ added: 1, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.green('+1')} ${chalk.red('-100')}\n${ADD + repeat(SUB, 19).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints just removed during uninstallation","suites":[],"updatePoint":{"line":727,"column":47},"line":727,"code":"test('prints just removed during uninstallation', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['remove'] },\n    streamParser: createStreamParser(),\n  })\n  const prefix = process.cwd()\n\n  statsLogger.debug({ removed: 4, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Packages: ${chalk.red('-4')}\n${SUB + SUB + SUB + SUB}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints added/removed stats and warnings during recursive installation","suites":[],"updatePoint":{"line":748,"column":75},"line":748,"code":"test('prints added/removed stats and warnings during recursive installation', (done) => {\n  const rootPrefix = '/home/jane/repo'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: rootPrefix, recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.warn({ message: 'Some issue', prefix: '/home/jane/repo/pkg-5' })\n  logger.warn({ message: 'Some other issue', prefix: rootPrefix })\n  statsLogger.debug({ removed: 1, prefix: '/home/jane/repo' })\n  statsLogger.debug({ added: 0, prefix: '/home/jane/repo' })\n  statsLogger.debug({ removed: 0, prefix: '/home/jane/repo/pkg-5' })\n  statsLogger.debug({ added: 0, prefix: '/home/jane/repo/pkg-5' })\n  statsLogger.debug({ added: 2, prefix: '/home/jane/repo/dir/pkg-2' })\n  statsLogger.debug({ added: 5, prefix: '/home/jane/repo/pkg-1' })\n  statsLogger.debug({ removed: 1, prefix: '/home/jane/repo/pkg-1' })\n  deprecationLogger.debug({\n    deprecated: 'This package was deprecated because bla bla bla',\n    depth: 0,\n    pkgId: 'registry.npmjs.org/bar/2.0.0',\n    pkgName: 'bar',\n    pkgVersion: '2.0.0',\n    prefix: '/home/jane/repo/dir/pkg-2',\n  })\n  statsLogger.debug({ removed: 0, prefix: '/home/jane/repo/dir/pkg-2' })\n  statsLogger.debug({ removed: 0, prefix: '/home/jane/repo/loooooooooooooooooooooooooooooooooong/pkg-3' })\n  statsLogger.debug({ added: 1, prefix: '/home/jane/repo/loooooooooooooooooooooooooooooooooong/pkg-3' })\n  statsLogger.debug({ removed: 1, prefix: '/home/jane/repo/loooooooooooooooooooooooooooooooooong-pkg-4' })\n  statsLogger.debug({ added: 0, prefix: '/home/jane/repo/loooooooooooooooooooooooooooooooooong-pkg-4' })\n  deprecationLogger.debug({\n    deprecated: 'This package was deprecated because bla bla bla',\n    depth: 0,\n    pkgId: 'registry.npmjs.org/foo/1.0.0',\n    pkgName: 'foo',\n    pkgVersion: '1.0.0',\n    prefix: rootPrefix,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(8), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`\\\npkg-5                                    | ${formatWarn('Some issue')}\n.                                        | ${formatWarn('Some other issue')}\n.                                        |   ${chalk.red('-1')} ${SUB}\npkg-1                                    |   ${chalk.green('+5')}   ${chalk.red('-1')} ${ADD + SUB}\ndir/pkg-2                                | ${formatWarn(`${DEPRECATED} bar@2.0.0`)}\ndir/pkg-2                                |   ${chalk.green('+2')} ${ADD}\n.../pkg-3                                |   ${chalk.green('+1')} ${ADD}\n...ooooooooooooooooooooooooooooong-pkg-4 |   ${chalk.red('-1')} ${SUB}\n.                                        | ${formatWarn(`${DEPRECATED} foo@1.0.0`)}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive installation: prints only the added stats if nothing was removed and a lot added","suites":[],"updatePoint":{"line":809,"column":96},"line":809,"code":"test('recursive installation: prints only the added stats if nothing was removed and a lot added', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['recursive'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    reportingOptions: { outputMaxWidth: 60 },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ removed: 0, prefix: '/home/jane/repo/pkg-1' })\n  statsLogger.debug({ added: 190, prefix: '/home/jane/repo/pkg-1' })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    | ${chalk.green('+190')} ${repeat(ADD, 12).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive installation: prints only the removed stats if nothing was added and a lot removed","suites":[],"updatePoint":{"line":833,"column":98},"line":833,"code":"test('recursive installation: prints only the removed stats if nothing was added and a lot removed', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['recursive'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    reportingOptions: { outputMaxWidth: 60 },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ removed: 190, prefix: '/home/jane/repo/pkg-1' })\n  statsLogger.debug({ added: 0, prefix: '/home/jane/repo/pkg-1' })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    | ${chalk.red('-190')} ${repeat(SUB, 12).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive installation: prints at least one remove sign when removed !== 0","suites":[],"updatePoint":{"line":857,"column":80},"line":857,"code":"test('recursive installation: prints at least one remove sign when removed !== 0', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['recursive'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    reportingOptions: { outputMaxWidth: 62 },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ removed: 1, prefix: '/home/jane/repo/pkg-1' })\n  statsLogger.debug({ added: 100, prefix: '/home/jane/repo/pkg-1' })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    | ${chalk.green('+100')}   ${chalk.red('-1')} ${repeat(ADD, 8).join('') + SUB}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive installation: prints at least one add sign when added !== 0","suites":[],"updatePoint":{"line":881,"column":75},"line":881,"code":"test('recursive installation: prints at least one add sign when added !== 0', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['recursive'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    reportingOptions: { outputMaxWidth: 62 },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ removed: 100, prefix: '/home/jane/repo/pkg-1' })\n  statsLogger.debug({ added: 1, prefix: '/home/jane/repo/pkg-1' })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    |   ${chalk.green('+1')} ${chalk.red('-100')} ${ADD + repeat(SUB, 8).join('')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive uninstall: prints removed packages number","suites":[],"updatePoint":{"line":905,"column":57},"line":905,"code":"test('recursive uninstall: prints removed packages number', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['remove'],\n      config: { dir: '/home/jane/repo', recursive: true } as Config,\n    },\n    reportingOptions: { outputMaxWidth: 62 },\n    streamParser: createStreamParser(),\n  })\n\n  statsLogger.debug({ removed: 1, prefix: '/home/jane/repo/pkg-1' })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    |   ${chalk.red('-1')} ${SUB}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"install: print hook message","suites":[],"updatePoint":{"line":928,"column":33},"line":928,"code":"test('install: print hook message', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  hookLogger.debug({\n    from: '/home/jane/repo/.pnpmfile.cjs',\n    hook: 'readPackage',\n    message: 'foo',\n    prefix: '/home/jane/repo',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${chalk.magentaBright('readPackage')}: foo`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"recursive: print hook message","suites":[],"updatePoint":{"line":955,"column":35},"line":955,"code":"test('recursive: print hook message', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['recursive'],\n      config: { dir: '/home/jane/repo' } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  hookLogger.debug({\n    from: '/home/jane/repo/.pnpmfile.cjs',\n    hook: 'readPackage',\n    message: 'foo',\n    prefix: '/home/jane/repo/pkg-1',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`pkg-1                                    | ${chalk.magentaBright('readPackage')}: foo`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints skipped optional dependency info message","suites":[],"updatePoint":{"line":982,"column":53},"line":982,"code":"test('prints skipped optional dependency info message', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  const pkgId = 'registry.npmjs.org/foo/1.0.0'\n\n  skippedOptionalDependencyLogger.debug({\n    package: {\n      id: pkgId,\n      name: 'foo',\n      version: '1.0.0',\n    },\n    parents: [],\n    prefix,\n    reason: 'unsupported_platform',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`info: ${pkgId} is an optional dependency and failed compatibility check. Excluding it from installation.`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"logLevel=default","suites":[],"updatePoint":{"line":1016,"column":22},"line":1016,"code":"test('logLevel=default', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.info({ message: 'Info message', prefix })\n  logger.warn({ message: 'Some issue', prefix })\n  const err = new PnpmError('SOME_CODE', 'some error')\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(skip(2), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Info message\n${formatWarn('Some issue')}\n${formatError('ERROR', 'some error')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"logLevel=warn","suites":[],"updatePoint":{"line":1044,"column":19},"line":1044,"code":"test('logLevel=warn', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    reportingOptions: {\n      logLevel: 'warn',\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.info({ message: 'Info message', prefix })\n  logger.warn({ message: 'Some issue', prefix })\n  const err = new PnpmError('SOME_CODE', 'some error')\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(skip(1), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatWarn('Some issue')}\n${formatError('ERR_PNPM_SOME_CODE', 'some error')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"logLevel=error","suites":[],"updatePoint":{"line":1074,"column":20},"line":1074,"code":"test('logLevel=error', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    reportingOptions: {\n      logLevel: 'error',\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.info({ message: 'Info message', prefix })\n  logger.warn({ message: 'Some issue', prefix })\n  const err = new PnpmError('SOME_CODE', 'some error')\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatError('ERR_PNPM_SOME_CODE', 'some error'))\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"warnings are collapsed","suites":[],"updatePoint":{"line":1103,"column":28},"line":1103,"code":"test('warnings are collapsed', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    reportingOptions: {\n      logLevel: 'warn',\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.warn({ message: 'Some issue 1', prefix })\n  logger.warn({ message: 'Some issue 2', prefix })\n  logger.warn({ message: 'Some issue 3', prefix })\n  logger.warn({ message: 'Some issue 4', prefix })\n  logger.warn({ message: 'Some issue 5', prefix })\n  logger.warn({ message: 'Some issue 6', prefix })\n  logger.warn({ message: 'Some issue 7', prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(6), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatWarn('Some issue 1')}\n${formatWarn('Some issue 2')}\n${formatWarn('Some issue 3')}\n${formatWarn('Some issue 4')}\n${formatWarn('Some issue 5')}\n${formatWarn('2 other warnings')}`)\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"warnings are not collapsed when append-only is true","suites":[],"updatePoint":{"line":1140,"column":57},"line":1140,"code":"test('warnings are not collapsed when append-only is true', (done) => {\n  const prefix = process.cwd()\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    reportingOptions: {\n      appendOnly: true,\n      logLevel: 'warn',\n    },\n    streamParser: createStreamParser(),\n  })\n\n  logger.warn({ message: 'Some issue 1', prefix })\n  logger.warn({ message: 'Some issue 2', prefix })\n  logger.warn({ message: 'Some issue 3', prefix })\n  logger.warn({ message: 'Some issue 4', prefix })\n  logger.warn({ message: 'Some issue 5', prefix })\n  logger.warn({ message: 'Some issue 6', prefix })\n  logger.warn({ message: 'Some issue 7', prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(6), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatWarn('Some issue 7'))\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"print context and import method info","suites":[],"updatePoint":{"line":8,"column":42},"line":8,"code":"test('print context and import method info', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  contextLogger.debug({\n    currentLockfileExists: false,\n    storeDir: '~/.pnpm-store/v3',\n    virtualStoreDir: 'node_modules/.pnpm',\n  })\n  packageImportMethodLogger.debug({\n    method: 'hardlink',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`\\\nPackages are hard linked from the content-addressable store to the virtual store.\n  Content-addressable store is at: ~/.pnpm-store/v3\n  Virtual store is at:             node_modules/.pnpm`)\n    },\n  })\n})","file":"reportingContext.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"do not print info if not fresh install","suites":[],"updatePoint":{"line":39,"column":44},"line":39,"code":"test('do not print info if not fresh install', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  contextLogger.debug({\n    currentLockfileExists: true,\n    storeDir: '~/.pnpm-store/v3',\n    virtualStoreDir: 'node_modules/.pnpm',\n  })\n  packageImportMethodLogger.debug({\n    method: 'hardlink',\n  })\n\n  const subscription = output$.subscribe({\n    complete: () => done(),\n    error: done,\n    next: (msg) => {\n      expect(msg).toBeFalsy()\n    },\n  })\n\n  setTimeout(() => {\n    done()\n    subscription.unsubscribe()\n  }, 10)\n})","file":"reportingContext.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints generic error","suites":[],"updatePoint":{"line":19,"column":26},"line":19,"code":"test('prints generic error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new Error('some error')\n  logger.error(err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERROR', 'some error')}\n${ERROR_PAD}${(new StackTracey(err.stack).asTable() as string).split('\\n').join(`\\n${ERROR_PAD}`)}`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints generic error when recursive install fails","suites":[],"updatePoint":{"line":40,"column":55},"line":40,"code":"test('prints generic error when recursive install fails', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['recursive'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new Error('some error')\n  err['prefix'] = '/home/src/'\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`/home/src/:\n${formatError('ERROR', 'some error')}\n${ERROR_PAD}\n${ERROR_PAD}${(new StackTracey(err.stack).asTable() as string).split('\\n').join(`\\n${ERROR_PAD}`)}`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints no matching version error when many dist-tags exist","suites":[],"updatePoint":{"line":64,"column":64},"line":64,"code":"test('prints no matching version error when many dist-tags exist', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_NO_MATCHING_VERSION', 'No matching version found for pnpm@1000.0.0')}\n${ERROR_PAD}\n${ERROR_PAD}The latest release of pnpm is \"2.4.0\".\n${ERROR_PAD}\n${ERROR_PAD}Other releases are:\n${ERROR_PAD}  * stable: 2.2.2\n${ERROR_PAD}  * next: 2.4.0\n${ERROR_PAD}  * latest-1: 1.43.1\n${ERROR_PAD}\n${ERROR_PAD}If you need the full list of all 281 published versions run \"$ pnpm view pnpm versions\".`)\n    },\n  })\n\n  const err = new PnpmError('NO_MATCHING_VERSION', 'No matching version found for pnpm@1000.0.0')\n  err['packageMeta'] = loadJsonFile.sync(path.join(__dirname, 'pnpm-meta.json'))\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints no matching version error when only the latest dist-tag exists","suites":[],"updatePoint":{"line":94,"column":75},"line":94,"code":"test('prints no matching version error when only the latest dist-tag exists', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_NO_MATCHING_VERSION', 'No matching version found for is-positive@1000.0.0')}\n${ERROR_PAD}\n${ERROR_PAD}The latest release of is-positive is \"3.1.0\".\n${ERROR_PAD}\n${ERROR_PAD}If you need the full list of all 4 published versions run \"$ pnpm view is-positive versions\".`)\n    },\n  })\n\n  const err = new PnpmError('NO_MATCHING_VERSION', 'No matching version found for is-positive@1000.0.0')\n  err['packageMeta'] = loadJsonFile.sync(path.join(__dirname, 'is-positive-meta.json'))\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints suggestions when an internet-connection related error happens","suites":[],"updatePoint":{"line":119,"column":74},"line":119,"code":"test('prints suggestions when an internet-connection related error happens', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_BAD_TARBALL_SIZE', 'Actual size (99) of tarball (https://foo) did not match the one specified in \\'Content-Length\\' header (100)')}\n${ERROR_PAD}\n${ERROR_PAD}Seems like you have internet connection issues.\n${ERROR_PAD}Try running the same command again.\n${ERROR_PAD}If that doesn't help, try one of the following:\n${ERROR_PAD}\n${ERROR_PAD}- Set a bigger value for the \\`fetch-retries\\` config.\n${ERROR_PAD}    To check the current value of \\`fetch-retries\\`, run \\`pnpm get fetch-retries\\`.\n${ERROR_PAD}    To set a new value, run \\`pnpm set fetch-retries <number>\\`.\n${ERROR_PAD}\n${ERROR_PAD}- Set \\`network-concurrency\\` to 1.\n${ERROR_PAD}    This change will slow down installation times, so it is recommended to\n${ERROR_PAD}    delete the config once the internet connection is good again: \\`pnpm config delete network-concurrency\\`\n${ERROR_PAD}\n${ERROR_PAD}NOTE: You may also override configs via flags.\n${ERROR_PAD}For instance, \\`pnpm install --fetch-retries 5 --network-concurrency 1\\``)\n    },\n  })\n\n  const err = new PnpmError('BAD_TARBALL_SIZE', 'Actual size (99) of tarball (https://foo) did not match the one specified in \\'Content-Length\\' header (100)')\n  err['expectedSize'] = 100\n  err['receivedSize'] = 99\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints test error","suites":[],"updatePoint":{"line":156,"column":23},"line":156,"code":"test('prints test error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['run', 'test'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ELIFECYCLE', 'Test failed. See above for more details.')}`)\n    },\n  })\n\n  const err = new Error('Tests failed')\n  err['stage'] = 'test'\n  err['code'] = 'ELIFECYCLE'\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints command error with exit code","suites":[],"updatePoint":{"line":178,"column":41},"line":178,"code":"test('prints command error with exit code', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['run', 'lint'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ELIFECYCLE', 'Command failed with exit code 100.')}`)\n    },\n  })\n\n  const err = new Error('Command failed')\n  err['errno'] = 100\n  err['stage'] = 'lint'\n  err['code'] = 'ELIFECYCLE'\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints command error without exit code","suites":[],"updatePoint":{"line":201,"column":44},"line":201,"code":"test('prints command error without exit code', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['run', 'lint'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ELIFECYCLE', 'Command failed.')}`)\n    },\n  })\n\n  const err = new Error('Command failed')\n  err['stage'] = 'lint'\n  err['code'] = 'ELIFECYCLE'\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints unsupported pnpm version error","suites":[],"updatePoint":{"line":223,"column":43},"line":223,"code":"test('prints unsupported pnpm version error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_UNSUPPORTED_ENGINE', 'Unsupported environment (bad pnpm and/or Node.js version)')}\n${ERROR_PAD}\n${ERROR_PAD}Your pnpm version is incompatible with \"/home/zoltan/project\".\n${ERROR_PAD}\n${ERROR_PAD}Expected version: 2\n${ERROR_PAD}Got: 3.0.0\n${ERROR_PAD}\n${ERROR_PAD}This is happening because the package's manifest has an engines.pnpm field specified.\n${ERROR_PAD}To fix this issue, install the required pnpm version globally.\n${ERROR_PAD}\n${ERROR_PAD}To install the latest version of pnpm, run \"pnpm i -g pnpm\".\n${ERROR_PAD}To check your pnpm version, run \"pnpm -v\".`)\n    },\n  })\n\n  const err = new PnpmError('UNSUPPORTED_ENGINE', 'Unsupported pnpm version')\n  err['packageId'] = '/home/zoltan/project'\n  err['wanted'] = { pnpm: '2' }\n  err['current'] = { pnpm: '3.0.0', node: '10.0.0' }\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints unsupported Node version error","suites":[],"updatePoint":{"line":257,"column":43},"line":257,"code":"test('prints unsupported Node version error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_UNSUPPORTED_ENGINE', 'Unsupported environment (bad pnpm and/or Node.js version)')}\n${ERROR_PAD}\n${ERROR_PAD}Your Node version is incompatible with \"/home/zoltan/project\".\n${ERROR_PAD}\n${ERROR_PAD}Expected version: >=12\n${ERROR_PAD}Got: 10.0.0\n${ERROR_PAD}\n${ERROR_PAD}This is happening because the package's manifest has an engines.node field specified.\n${ERROR_PAD}To fix this issue, install the required Node version.`)\n    },\n  })\n\n  const err = new PnpmError('UNSUPPORTED_ENGINE', 'Unsupported pnpm version')\n  err['packageId'] = '/home/zoltan/project'\n  err['wanted'] = { node: '>=12' }\n  err['current'] = { pnpm: '3.0.0', node: '10.0.0' }\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints unsupported pnpm and Node versions error","suites":[],"updatePoint":{"line":288,"column":53},"line":288,"code":"test('prints unsupported pnpm and Node versions error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_UNSUPPORTED_ENGINE', 'Unsupported environment (bad pnpm and/or Node.js version)')}\n${ERROR_PAD}\n${ERROR_PAD}Your pnpm version is incompatible with \"/home/zoltan/project\".\n${ERROR_PAD}\n${ERROR_PAD}Expected version: 2\n${ERROR_PAD}Got: 3.0.0\n${ERROR_PAD}\n${ERROR_PAD}This is happening because the package's manifest has an engines.pnpm field specified.\n${ERROR_PAD}To fix this issue, install the required pnpm version globally.\n${ERROR_PAD}\n${ERROR_PAD}To install the latest version of pnpm, run \"pnpm i -g pnpm\".\n${ERROR_PAD}To check your pnpm version, run \"pnpm -v\".` + '\\n\\n' + `\\\n${ERROR_PAD}Your Node version is incompatible with \"/home/zoltan/project\".\n${ERROR_PAD}\n${ERROR_PAD}Expected version: >=12\n${ERROR_PAD}Got: 10.0.0\n${ERROR_PAD}\n${ERROR_PAD}This is happening because the package's manifest has an engines.node field specified.\n${ERROR_PAD}To fix this issue, install the required Node version.`)\n    },\n  })\n\n  const err = new PnpmError('UNSUPPORTED_ENGINE', 'Unsupported pnpm version')\n  err['packageId'] = '/home/zoltan/project'\n  err['wanted'] = { pnpm: '2', node: '>=12' }\n  err['current'] = { pnpm: '3.0.0', node: '10.0.0' }\n  logger.error(err, err)\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints error even if the error object not passed in through the message object","suites":[],"updatePoint":{"line":329,"column":84},"line":329,"code":"test('prints error even if the error object not passed in through the message object', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('SOME_ERROR', 'some error')\n  logger.error(err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatError('ERR_PNPM_SOME_ERROR', 'some error'))\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints error without packages stacktrace when pkgsStack is empty","suites":[],"updatePoint":{"line":349,"column":70},"line":349,"code":"test('prints error without packages stacktrace when pkgsStack is empty', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('SOME_ERROR', 'some error')\n  err.pkgsStack = []\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatError('ERR_PNPM_SOME_ERROR', 'some error'))\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints error with packages stacktrace - depth 1 and hint","suites":[],"updatePoint":{"line":370,"column":62},"line":370,"code":"test('prints error with packages stacktrace - depth 1 and hint', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('SOME_ERROR', 'some error', { hint: 'hint' })\n  err.pkgsStack = [\n    {\n      id: 'registry.npmjs.org/foo/1.0.0',\n      name: 'foo',\n      version: '1.0.0',\n    },\n  ]\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_SOME_ERROR', 'some error')}\n${ERROR_PAD}\n${ERROR_PAD}This error happened while installing the dependencies of foo@1.0.0\n${ERROR_PAD}hint`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints error with packages stacktrace - depth 2","suites":[],"updatePoint":{"line":400,"column":53},"line":400,"code":"test('prints error with packages stacktrace - depth 2', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('SOME_ERROR', 'some error')\n  err.pkgsStack = [\n    {\n      id: 'registry.npmjs.org/foo/1.0.0',\n      name: 'foo',\n      version: '1.0.0',\n    },\n    {\n      id: 'registry.npmjs.org/bar/1.0.0',\n      name: 'bar',\n      version: '1.0.0',\n    },\n  ]\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_SOME_ERROR', 'some error')}\n${ERROR_PAD}\n${ERROR_PAD}This error happened while installing the dependencies of foo@1.0.0\n${ERROR_PAD} at bar@1.0.0`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints error and hint","suites":[],"updatePoint":{"line":435,"column":27},"line":435,"code":"test('prints error and hint', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('SOME_ERROR', 'some error', { hint: 'some hint' })\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatErrorCode('ERR_PNPM_SOME_ERROR') + ' ' + `${chalk.red('some error')}\n\nsome hint`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints authorization error with auth settings","suites":[],"updatePoint":{"line":457,"column":51},"line":457,"code":"test('prints authorization error with auth settings', (done) => {\n  const rawConfig = {\n    '//foo.bar:_auth': '9876543219',\n    '//foo.bar:_authToken': '9876543219',\n    '//foo.bar:_password': '9876543219',\n    '//foo.bar:username': 'kiss.reka',\n    '@foo:registry': 'https://foo.bar',\n    _auth: '0123456789',\n    _authToken: '0123456789',\n    _password: '0123456789',\n    'always-auth': false,\n    username: 'nagy.gabor',\n  }\n  const output$ = toOutput$({\n    context: { argv: ['install'], config: { rawConfig } as any }, // eslint-disable-line\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('FETCH_401', 'some error', { hint: 'some hint' })\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_FETCH_401', 'some error')}\n${ERROR_PAD}\n${ERROR_PAD}some hint\n${ERROR_PAD}\n${ERROR_PAD}These authorization settings were found:\n${ERROR_PAD}//foo.bar:_auth=9876[hidden]\n${ERROR_PAD}//foo.bar:_authToken=9876[hidden]\n${ERROR_PAD}//foo.bar:_password=[hidden]\n${ERROR_PAD}//foo.bar:username=kiss.reka\n${ERROR_PAD}@foo:registry=https://foo.bar\n${ERROR_PAD}_auth=0123[hidden]\n${ERROR_PAD}_authToken=0123[hidden]\n${ERROR_PAD}_password=[hidden]\n${ERROR_PAD}always-auth=false\n${ERROR_PAD}username=nagy.gabor`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints authorization error without auth settings, where there are none","suites":[],"updatePoint":{"line":503,"column":76},"line":503,"code":"test('prints authorization error without auth settings, where there are none', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'], config: { rawConfig: {} } as any }, // eslint-disable-line\n    streamParser: createStreamParser(),\n  })\n\n  const err = new PnpmError('FETCH_401', 'some error', { hint: 'some hint' })\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`${formatError('ERR_PNPM_FETCH_401', 'some error')}\n${ERROR_PAD}\n${ERROR_PAD}some hint\n${ERROR_PAD}\n${ERROR_PAD}No authorization settings were found in the configs.\n${ERROR_PAD}Try to log in to the registry by running \"pnpm login\"\n${ERROR_PAD}or add the auth tokens manually to the ~/.npmrc file.`)\n    },\n  })\n})","file":"reportingErrors.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"groups lifecycle output","suites":[],"updatePoint":{"line":31,"column":29},"line":31,"code":"test('groups lifecycle output', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 79 },\n    streamParser: createStreamParser(),\n  })\n\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30',\n    stage: 'preinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    optional: false,\n    script: 'node bar',\n    stage: 'postinstall',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    line: 'bar I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo II',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo III',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    optional: false,\n    script: 'node qar',\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    exitCode: 0,\n    optional: false,\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(9), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(replaceTimeWith1Sec(output)).toBe(`\\\npackages/foo ${PREINSTALL}$ node foo\n${OUTPUT_INDENTATION} foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27\n${STATUS_INDENTATION} ${STATUS_RUNNING}\npackages/foo ${POSTINSTALL}$ node foo\n${OUTPUT_INDENTATION} foo I\n${OUTPUT_INDENTATION} foo II\n${OUTPUT_INDENTATION} foo III\n${STATUS_INDENTATION} ${STATUS_RUNNING}\npackages/bar ${POSTINSTALL}$ node bar\n${OUTPUT_INDENTATION} bar I\n${STATUS_INDENTATION} ${STATUS_RUNNING}\npackages/qar ${INSTALL}$ node qar\n${STATUS_INDENTATION} ${STATUS_DONE}`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"groups lifecycle output when append-only is used","suites":[],"updatePoint":{"line":140,"column":54},"line":140,"code":"test('groups lifecycle output when append-only is used', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: {\n      appendOnly: true,\n      outputMaxWidth: 79,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30',\n    stage: 'preinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 1,\n    optional: true,\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    optional: false,\n    script: 'node bar',\n    stage: 'postinstall',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    line: 'bar I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo II',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo III',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    optional: false,\n    script: 'node qar',\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    exitCode: 0,\n    optional: false,\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n\n  expect.assertions(1)\n\n  const allOutputs = [] as string[]\n\n  output$.pipe(take(11), map(normalizeNewline)).subscribe({\n    complete: () => {\n      expect(allOutputs.join(EOL)).toBe(`\\\n${chalk.cyan('packages/foo')} ${PREINSTALL}$ node foo\n${chalk.cyan('packages/foo')} ${PREINSTALL}: foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n${chalk.cyan('packages/foo')} ${PREINSTALL}: Failed\n${chalk.cyan('packages/foo')} ${POSTINSTALL}$ node foo\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo I\n${chalk.magenta('packages/bar')} ${POSTINSTALL}$ node bar\n${chalk.magenta('packages/bar')} ${POSTINSTALL}: bar I\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo II\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo III\n${chalk.blue('packages/qar')} ${INSTALL}$ node qar\n${chalk.blue('packages/qar')} ${INSTALL}: Done`)\n      done()\n    },\n    error: done,\n    next: (output: string) => {\n      allOutputs.push(output)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"groups lifecycle output when append-only and aggregate-output are used","suites":[],"updatePoint":{"line":262,"column":76},"line":262,"code":"test('groups lifecycle output when append-only and aggregate-output are used', async () => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: {\n      appendOnly: true,\n      aggregateOutput: true,\n      outputMaxWidth: 79,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30',\n    stage: 'preinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 1,\n    optional: true,\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    optional: false,\n    script: 'node bar',\n    stage: 'postinstall',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    line: 'bar I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo II',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo III',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    optional: false,\n    script: 'node qar',\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    exitCode: 0,\n    optional: false,\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: 'packages/bar',\n  })\n\n  await expect(\n    firstValueFrom(\n      output$.pipe(map<string, string>(normalizeNewline), take(8), toArray())\n    )\n  ).resolves.toEqual([\n    `${chalk.cyan('packages/foo')} ${PREINSTALL}$ node foo`,\n    `${chalk.cyan(\n      'packages/foo'\n    )} ${PREINSTALL}: foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30`,\n    `${chalk.cyan('packages/foo')} ${PREINSTALL}: Failed`,\n    `${chalk.magenta('packages/qar')} ${INSTALL}$ node qar`,\n    `${chalk.magenta('packages/qar')} ${INSTALL}: Done`,\n    `${chalk.blue('packages/bar')} ${POSTINSTALL}$ node bar`,\n    `${chalk.blue('packages/bar')} ${POSTINSTALL}: bar I`,\n    `${chalk.blue('packages/bar')} ${POSTINSTALL}: Done`,\n  ])\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"groups lifecycle output when streamLifecycleOutput is used","suites":[],"updatePoint":{"line":376,"column":64},"line":376,"code":"test('groups lifecycle output when streamLifecycleOutput is used', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: {\n      outputMaxWidth: 79,\n      streamLifecycleOutput: true,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30',\n    stage: 'preinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 1,\n    optional: true,\n    stage: 'preinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    optional: false,\n    script: 'node bar',\n    stage: 'postinstall',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/bar',\n    line: 'bar I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/bar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo II',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    line: 'foo III',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: 'packages/foo',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    optional: false,\n    script: 'node qar',\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/qar',\n    exitCode: 0,\n    optional: false,\n    stage: 'install',\n    wd: 'packages/qar',\n  })\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(11), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(output).toBe(`\\\n${chalk.cyan('packages/foo')} ${PREINSTALL}$ node foo\n${chalk.cyan('packages/foo')} ${PREINSTALL}: foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n${chalk.cyan('packages/foo')} ${PREINSTALL}: Failed\n${chalk.cyan('packages/foo')} ${POSTINSTALL}$ node foo\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo I\n${chalk.magenta('packages/bar')} ${POSTINSTALL}$ node bar\n${chalk.magenta('packages/bar')} ${POSTINSTALL}: bar I\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo II\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: foo III\n${chalk.blue('packages/qar')} ${INSTALL}$ node qar\n${chalk.blue('packages/qar')} ${INSTALL}: Done\n${chalk.cyan('packages/foo')} ${POSTINSTALL}: Done`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"collapse lifecycle output when it has too many lines","suites":[],"updatePoint":{"line":494,"column":58},"line":494,"code":"test('collapse lifecycle output when it has too many lines', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 79 },\n    streamParser: createStreamParser(),\n  })\n\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n  for (let i = 0; i < 100; i++) {\n    lifecycleLogger.debug({\n      depPath: 'packages/foo',\n      line: `foo ${i}`,\n      stage: 'postinstall',\n      stdio: 'stdout',\n      wd: 'packages/foo',\n    })\n  }\n  lifecycleLogger.debug({\n    depPath: 'packages/foo',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: 'packages/foo',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(101), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(replaceTimeWith1Sec(output)).toBe(`\\\npackages/foo ${POSTINSTALL}$ node foo\n[90 lines collapsed]\n${OUTPUT_INDENTATION} foo 90\n${OUTPUT_INDENTATION} foo 91\n${OUTPUT_INDENTATION} foo 92\n${OUTPUT_INDENTATION} foo 93\n${OUTPUT_INDENTATION} foo 94\n${OUTPUT_INDENTATION} foo 95\n${OUTPUT_INDENTATION} foo 96\n${OUTPUT_INDENTATION} foo 97\n${OUTPUT_INDENTATION} foo 98\n${OUTPUT_INDENTATION} foo 99\n${STATUS_INDENTATION} ${STATUS_DONE}`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"collapses lifecycle output of packages from node_modules","suites":[],"updatePoint":{"line":549,"column":62},"line":549,"code":"test('collapses lifecycle output of packages from node_modules', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 79 },\n    streamParser: createStreamParser(),\n  })\n\n  const wdOfFoo = path.resolve(process.cwd(), 'node_modules', '.registry.npmjs.org', 'foo', '1.0.0', 'node_modules', 'foo')\n  const wdOfBar = path.resolve(process.cwd(), 'node_modules', '.registry.npmjs.org', 'bar', '1.0.0', 'node_modules', 'bar')\n  const wdOfQar = path.resolve(process.cwd(), 'node_modules', '.registry.npmjs.org', 'qar', '1.0.0', 'node_modules', 'qar')\n\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    optional: false,\n    script: 'node foo',\n    stage: 'preinstall',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20',\n    stage: 'preinstall',\n    stdio: 'stdout',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    optional: false,\n    script: 'node foo',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/bar/1.0.0',\n    optional: false,\n    script: 'node bar',\n    stage: 'postinstall',\n    wd: wdOfBar,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/bar/1.0.0',\n    line: 'bar I',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: wdOfBar,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo II',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo III',\n    stage: 'postinstall',\n    stdio: 'stdout',\n    wd: wdOfFoo,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/qar/1.0.0',\n    optional: false,\n    script: 'node qar',\n    stage: 'install',\n    wd: wdOfQar,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/qar/1.0.0',\n    exitCode: 0,\n    optional: false,\n    stage: 'install',\n    wd: wdOfQar,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    exitCode: 0,\n    optional: false,\n    stage: 'postinstall',\n    wd: wdOfFoo,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(5), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(replaceTimeWith1Sec(output)).toBe(`\\\n${chalk.gray('node_modules/.registry.npmjs.org/foo/1.0.0/node_modules/')}foo: Running preinstall script...\n${chalk.gray('node_modules/.registry.npmjs.org/foo/1.0.0/node_modules/')}foo: Running postinstall script, done in 1s\n${chalk.gray('node_modules/.registry.npmjs.org/bar/1.0.0/node_modules/')}bar: Running postinstall script...\n${chalk.gray('node_modules/.registry.npmjs.org/qar/1.0.0/node_modules/')}qar: Running install script, done in 1s`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"output of failed optional dependency is not shown","suites":[],"updatePoint":{"line":654,"column":55},"line":654,"code":"test('output of failed optional dependency is not shown', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 79 },\n    streamParser: createStreamParser(),\n  })\n\n  const wd = path.resolve(process.cwd(), 'node_modules', '.registry.npmjs.org', 'foo', '1.0.0', 'node_modules', 'foo')\n\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    optional: true,\n    script: 'node foo',\n    stage: 'install',\n    wd: wd,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20',\n    stage: 'install',\n    stdio: 'stdout',\n    wd,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    exitCode: 1,\n    optional: true,\n    stage: 'install',\n    wd,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(1), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(replaceTimeWith1Sec(output)).toBe(`${chalk.gray('node_modules/.registry.npmjs.org/foo/1.0.0/node_modules/')}foo: Running install script, failed in 1s (skipped as optional)`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"output of failed non-optional dependency is printed","suites":[],"updatePoint":{"line":696,"column":57},"line":696,"code":"test('output of failed non-optional dependency is printed', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    reportingOptions: { outputMaxWidth: 79 },\n    streamParser: createStreamParser(),\n  })\n\n  const wd = path.resolve(process.cwd(), 'node_modules', '.registry.npmjs.org', 'foo', '1.0.0', 'node_modules', 'foo')\n\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    optional: false,\n    script: 'node foo',\n    stage: 'install',\n    wd: wd,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    line: 'foo 0 1 2 3 4 5 6 7 8 9',\n    stage: 'install',\n    stdio: 'stdout',\n    wd,\n  })\n  lifecycleLogger.debug({\n    depPath: 'registry.npmjs.org/foo/1.0.0',\n    exitCode: 1,\n    optional: false,\n    stage: 'install',\n    wd,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(1), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: (output: string) => {\n      expect(replaceTimeWith1Sec(output)).toBe(`\\\n${chalk.gray('node_modules/.registry.npmjs.org/foo/1.0.0/node_modules/')}foo: Running install script, failed in 1s\n.../foo/1.0.0/node_modules/foo ${INSTALL}$ node foo\n${OUTPUT_INDENTATION} foo 0 1 2 3 4 5 6 7 8 9\n${STATUS_INDENTATION} ${STATUS_FAILED}`)\n    },\n  })\n})","file":"reportingLifecycleScripts.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"print peer dependency issues warning","suites":[],"updatePoint":{"line":8,"column":42},"line":8,"code":"test('print peer dependency issues warning', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  peerDependencyIssuesLogger.debug({\n    issuesByProjects: {\n      '.': {\n        missing: {},\n        bad: {\n          a: [\n            {\n              parents: [\n                {\n                  name: 'b',\n                  version: '1.0.0',\n                },\n              ],\n              foundVersion: '2',\n              resolvedFrom: [],\n              optional: false,\n              wantedRange: '3',\n            },\n          ],\n        },\n        conflicts: [],\n        intersections: {},\n      },\n    },\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toContain('.')\n    },\n  })\n})","file":"reportingPeerDependencyIssues.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"print peer dependency issues error","suites":[],"updatePoint":{"line":53,"column":40},"line":53,"code":"test('print peer dependency issues error', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const err = new Error('some error')\n  err['code'] = 'ERR_PNPM_PEER_DEP_ISSUES'\n  err['issuesByProjects'] = {\n    '.': {\n      missing: {},\n      bad: {\n        a: [\n          {\n            foundVersion: '2',\n            parents: [\n              {\n                name: 'b',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            resolvedFrom: [],\n            wantedRange: '3',\n          },\n        ],\n      },\n      conflicts: [],\n      intersections: {},\n    },\n  }\n  logger.error(err, err)\n\n  expect.assertions(1)\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toContain('.')\n    },\n  })\n})","file":"reportingPeerDependencyIssues.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress beginning","suites":[],"updatePoint":{"line":22,"column":31},"line":22,"code":"test('prints progress beginning', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/project' } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}`)\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints all progress stats","suites":[],"updatePoint":{"line":52,"column":31},"line":52,"code":"test('prints all progress stats', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/project' } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/project',\n    status: 'resolved',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/project',\n    status: 'fetched',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/bar/1.0.0',\n    requester: '/src/project',\n    status: 'found_in_store',\n  })\n  progressLogger.debug({\n    method: 'hardlink',\n    requester: '/src/project',\n    status: 'imported',\n    to: '/node_modules/.pnpm/foo@1.0.0',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(skip(3), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('1')}, downloaded ${hlValue('1')}, added ${hlValue('1')}`)\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress beginning of node_modules from not cwd","suites":[],"updatePoint":{"line":98,"column":60},"line":98,"code":"test('prints progress beginning of node_modules from not cwd', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/projects' } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  stageLogger.debug({\n    prefix: '/src/projects/foo',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/projects/foo',\n    status: 'resolved',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`foo                                      | Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}`)\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress beginning when appendOnly is true","suites":[],"updatePoint":{"line":128,"column":55},"line":128,"code":"test('prints progress beginning when appendOnly is true', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/project' } as Config,\n    },\n    reportingOptions: {\n      appendOnly: true,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}`)\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress beginning during recursive install","suites":[],"updatePoint":{"line":161,"column":56},"line":161,"code":"test('prints progress beginning during recursive install', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: {\n        dir: '/src/project',\n        recursive: true,\n      } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId: 'registry.npmjs.org/foo/1.0.0',\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}`)\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress on first download","suites":[],"updatePoint":{"line":194,"column":39},"line":194,"code":"test('prints progress on first download', (done) => {\n  expect.assertions(1)\n\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/project' } as Config,\n    },\n    reportingOptions: { throttleProgress: 0 },\n    streamParser: createStreamParser(),\n  })\n\n  output$.pipe(skip(1), take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('1')}, added ${hlValue('0')}`)\n    },\n  })\n\n  const packageId = 'registry.npmjs.org/foo/1.0.0'\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId,\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  progressLogger.debug({\n    packageId,\n    requester: '/src/project',\n    status: 'fetched',\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"moves fixed line to the end","suites":[],"updatePoint":{"line":233,"column":33},"line":233,"code":"test('moves fixed line to the end', (done) => {\n  expect.assertions(1)\n  const prefix = '/src/project'\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: prefix } as Config,\n    },\n    reportingOptions: { throttleProgress: 0 },\n    streamParser: createStreamParser(),\n  })\n\n  output$.pipe(skip(3), take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatWarn('foo') + EOL +\n        `Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('1')}, added ${hlValue('0')}, done`)\n    },\n  })\n\n  const packageId = 'registry.npmjs.org/foo/1.0.0'\n\n  stageLogger.debug({\n    prefix,\n    stage: 'resolution_started',\n  })\n  progressLogger.debug({\n    packageId,\n    requester: prefix,\n    status: 'resolved',\n  })\n\n  progressLogger.debug({\n    packageId,\n    requester: prefix,\n    status: 'fetched',\n  })\n  logger.warn({ message: 'foo', prefix })\n\n  stageLogger.debug({\n    prefix: prefix,\n    stage: 'resolution_done',\n  })\n  stageLogger.debug({\n    prefix: prefix,\n    stage: 'importing_done',\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints \"Already up-to-date\"","suites":[],"updatePoint":{"line":283,"column":33},"line":283,"code":"test('prints \"Already up-to-date\"', (done) => {\n  const output$ = toOutput$({\n    context: { argv: ['install'] },\n    streamParser: createStreamParser(),\n  })\n\n  const prefix = process.cwd()\n\n  statsLogger.debug({ added: 0, prefix })\n  statsLogger.debug({ removed: 0, prefix })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1), map(normalizeNewline)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('Already up-to-date')\n    },\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints progress of big files download","suites":[],"updatePoint":{"line":305,"column":43},"line":305,"code":"test('prints progress of big files download', (done) => {\n  expect.assertions(6)\n\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { dir: '/src/project' } as Config,\n    },\n    reportingOptions: { throttleProgress: 0 },\n    streamParser: createStreamParser(),\n  })\n\n  const pkgId1 = 'registry.npmjs.org/foo/1.0.0'\n  const pkgId2 = 'registry.npmjs.org/bar/2.0.0'\n  const pkgId3 = 'registry.npmjs.org/qar/3.0.0'\n\n  output$.pipe(\n    take(9),\n    map(normalizeNewline),\n    map((output, index) => {\n      switch (index) {\n      case 0:\n        expect(output).toBe(`Progress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}`)\n        return\n      case 1:\n        expect(output).toBe(`\\\nProgress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}\nDownloading ${hlPkgId(pkgId1)}: ${hlValue('0 B')}/${hlValue('10.5 MB')}`)\n        return\n      case 2:\n        expect(output).toBe(`\\\nProgress: resolved ${hlValue('1')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}\nDownloading ${hlPkgId(pkgId1)}: ${hlValue('5.77 MB')}/${hlValue('10.5 MB')}`)\n        return\n      case 4:\n        expect(output).toBe(`\\\nProgress: resolved ${hlValue('2')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}\nDownloading ${hlPkgId(pkgId1)}: ${hlValue('7.34 MB')}/${hlValue('10.5 MB')}`)\n        return\n      case 7:\n        expect(output).toBe(`\\\nProgress: resolved ${hlValue('3')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}\nDownloading ${hlPkgId(pkgId1)}: ${hlValue('7.34 MB')}/${hlValue('10.5 MB')}\nDownloading ${hlPkgId(pkgId3)}: ${hlValue('19.9 MB')}/${hlValue('21 MB')}`)\n        return\n      case 8:\n        expect(output).toBe(`\\\nDownloading ${hlPkgId(pkgId1)}: ${hlValue('10.5 MB')}/${hlValue('10.5 MB')}, done\nProgress: resolved ${hlValue('3')}, reused ${hlValue('0')}, downloaded ${hlValue('0')}, added ${hlValue('0')}\nDownloading ${hlPkgId(pkgId3)}: ${hlValue('19.9 MB')}/${hlValue('21 MB')}`)\n        return // eslint-disable-line\n      }\n    })\n  )\n    .subscribe({\n      complete: () => done(),\n      error: done,\n      next: () => undefined,\n    })\n\n  stageLogger.debug({\n    prefix: '/src/project',\n    stage: 'resolution_started',\n  })\n\n  progressLogger.debug({\n    packageId: pkgId1,\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  fetchingProgressLogger.debug({\n    attempt: 1,\n    packageId: pkgId1,\n    size: 1024 * 1024 * 10, // 10 MB\n    status: 'started',\n  })\n\n  fetchingProgressLogger.debug({\n    downloaded: 1024 * 1024 * 5.5, // 5.5 MB\n    packageId: pkgId1,\n    status: 'in_progress',\n  })\n\n  progressLogger.debug({\n    packageId: pkgId2,\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  fetchingProgressLogger.debug({\n    attempt: 1,\n    packageId: pkgId1,\n    size: 10, // 10 B\n    status: 'started',\n  })\n\n  fetchingProgressLogger.debug({\n    downloaded: 1024 * 1024 * 7,\n    packageId: pkgId1,\n    status: 'in_progress',\n  })\n\n  progressLogger.debug({\n    packageId: pkgId3,\n    requester: '/src/project',\n    status: 'resolved',\n  })\n\n  fetchingProgressLogger.debug({\n    attempt: 1,\n    packageId: pkgId3,\n    size: 1024 * 1024 * 20, // 20 MB\n    status: 'started',\n  })\n\n  fetchingProgressLogger.debug({\n    downloaded: 1024 * 1024 * 19, // 19 MB\n    packageId: pkgId3,\n    status: 'in_progress',\n  })\n\n  fetchingProgressLogger.debug({\n    downloaded: 1024 * 1024 * 10, // 10 MB\n    packageId: pkgId1,\n    status: 'in_progress',\n  })\n})","file":"reportingProgress.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"print warning about request retry","suites":[],"updatePoint":{"line":9,"column":39},"line":9,"code":"test('print warning about request retry', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  requestRetryLogger.debug({\n    attempt: 2,\n    error: new Error(),\n    maxRetries: 5,\n    method: 'GET',\n    timeout: 12500,\n    url: 'https://foo.bar/qar',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe(formatWarn('GET https://foo.bar/qar error (undefined). Will retry in 12.5 seconds. 4 retries left.'))\n    },\n  })\n})","file":"reportingRequestRetry.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"does not print scope of non-recursive install in a workspace","suites":[],"updatePoint":{"line":7,"column":66},"line":7,"code":"test('does not print scope of non-recursive install in a workspace', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  scopeLogger.debug({\n    selected: 1,\n    workspacePrefix: '/home/src',\n  })\n\n  const subscription = output$.subscribe({\n    complete: () => done(),\n    error: done,\n    next: () => {\n      done('should not log anything')\n    },\n  })\n\n  setTimeout(() => {\n    done()\n    subscription.unsubscribe()\n  }, 10)\n})","file":"reportingScope.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints scope of recursive install in a workspace when not all packages are selected","suites":[],"updatePoint":{"line":34,"column":89},"line":34,"code":"test('prints scope of recursive install in a workspace when not all packages are selected', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  scopeLogger.debug({\n    selected: 2,\n    total: 10,\n    workspacePrefix: '/home/src',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('Scope: 2 of 10 workspace projects')\n    },\n  })\n})","file":"reportingScope.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints scope of recursive install in a workspace when all packages are selected","suites":[],"updatePoint":{"line":60,"column":85},"line":60,"code":"test('prints scope of recursive install in a workspace when all packages are selected', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  scopeLogger.debug({\n    selected: 10,\n    total: 10,\n    workspacePrefix: '/home/src',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('Scope: all 10 workspace projects')\n    },\n  })\n})","file":"reportingScope.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints scope of recursive install not in a workspace when not all packages are selected","suites":[],"updatePoint":{"line":86,"column":93},"line":86,"code":"test('prints scope of recursive install not in a workspace when not all packages are selected', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  scopeLogger.debug({\n    selected: 2,\n    total: 10,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('Scope: 2 of 10 projects')\n    },\n  })\n})","file":"reportingScope.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"prints scope of recursive install not in a workspace when all packages are selected","suites":[],"updatePoint":{"line":111,"column":89},"line":111,"code":"test('prints scope of recursive install not in a workspace when all packages are selected', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  scopeLogger.debug({\n    selected: 10,\n    total: 10,\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(output).toBe('Scope: all 10 projects')\n    },\n  })\n})","file":"reportingScope.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"does not print update if latest is less than current","suites":[],"updatePoint":{"line":8,"column":58},"line":8,"code":"test('does not print update if latest is less than current', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n    },\n    streamParser: createStreamParser(),\n  })\n\n  updateCheckLogger.debug({\n    currentVersion: '10.0.0',\n    latestVersion: '9.0.0',\n  })\n\n  const subscription = output$.subscribe({\n    complete: () => done(),\n    error: done,\n    next: () => {\n      done('should not log anything')\n    },\n  })\n\n  setTimeout(() => {\n    done()\n    subscription.unsubscribe()\n  }, 10)\n})","file":"reportingUpdateCheck.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"print update notification if the latest version is greater than the current","suites":[],"updatePoint":{"line":35,"column":81},"line":35,"code":"test('print update notification if the latest version is greater than the current', (done) => {\n  const output$ = toOutput$({\n    context: {\n      argv: ['install'],\n      config: { recursive: true } as Config,\n    },\n    streamParser: createStreamParser(),\n  })\n\n  updateCheckLogger.debug({\n    currentVersion: '10.0.0',\n    latestVersion: '11.0.0',\n  })\n\n  expect.assertions(1)\n\n  output$.pipe(take(1)).subscribe({\n    complete: () => done(),\n    error: done,\n    next: output => {\n      expect(stripAnsi(output)).toMatchSnapshot()\n    },\n  })\n})","file":"reportingUpdateCheck.ts","skipped":false,"dir":"packages/default-reporter/test"},{"name":"createResolver()","suites":[],"updatePoint":{"line":5,"column":22},"line":5,"code":"test('createResolver()', () => {\n  const getCredentials = () => ({ authHeaderValue: '', alwaysAuth: false })\n  const resolve = createResolver(createFetchFromRegistry({}), getCredentials, {\n    cacheDir: '.cache',\n  })\n  expect(typeof resolve).toEqual('function')\n})","file":"index.ts","skipped":false,"dir":"packages/default-resolver/test"},{"name":"one package depth 0","suites":[],"updatePoint":{"line":17,"column":25},"line":17,"code":"test('one package depth 0', async () => {\n  const tree = await dh([generalFixture], { depth: 0, lockfileDir: generalFixture })\n  const modulesDir = path.join(generalFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      dependencies: [\n        {\n          alias: 'minimatch',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'minimatch',\n          path: path.join(modulesDir, '.pnpm/minimatch@3.0.4'),\n          resolved: 'https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz',\n          version: '3.0.4',\n        },\n        {\n          alias: 'rimraf',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'rimraf',\n          path: path.join(modulesDir, '.pnpm/rimraf@2.5.1'),\n          resolved: 'https://registry.npmjs.org/rimraf/-/rimraf-2.5.1.tgz',\n          version: '2.5.1',\n        },\n      ],\n      devDependencies: [\n        {\n          alias: 'is-positive',\n          dev: true,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-positive',\n          path: path.join(modulesDir, '.pnpm/is-positive@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-positive/-/is-positive-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n      optionalDependencies: [\n        {\n          alias: 'is-negative',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-negative',\n          optional: true,\n          path: path.join(modulesDir, '.pnpm/is-negative@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-negative/-/is-negative-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"one package depth 1","suites":[],"updatePoint":{"line":78,"column":25},"line":78,"code":"test('one package depth 1', async () => {\n  const tree = await dh([generalFixture], { depth: 1, lockfileDir: generalFixture })\n  const modulesDir = path.join(generalFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      dependencies: [\n        {\n          alias: 'minimatch',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'minimatch',\n          path: path.join(modulesDir, '.pnpm/minimatch@3.0.4'),\n          resolved: 'https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz',\n          version: '3.0.4',\n\n          dependencies: [\n            {\n              alias: 'brace-expansion',\n              dev: false,\n              isMissing: false,\n              isPeer: false,\n              isSkipped: false,\n              name: 'brace-expansion',\n              path: path.join(modulesDir, '.pnpm/brace-expansion@1.1.8'),\n              resolved: 'https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.8.tgz',\n              version: '1.1.8',\n            },\n          ],\n        },\n        {\n          alias: 'rimraf',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'rimraf',\n          path: path.join(modulesDir, '.pnpm/rimraf@2.5.1'),\n          resolved: 'https://registry.npmjs.org/rimraf/-/rimraf-2.5.1.tgz',\n          version: '2.5.1',\n\n          dependencies: [\n            {\n              alias: 'glob',\n              dev: false,\n              isMissing: false,\n              isPeer: false,\n              isSkipped: false,\n              name: 'glob',\n              path: path.join(modulesDir, '.pnpm/glob@6.0.4'),\n              resolved: 'https://registry.npmjs.org/glob/-/glob-6.0.4.tgz',\n              version: '6.0.4',\n            },\n          ],\n        },\n      ],\n      devDependencies: [\n        {\n          alias: 'is-positive',\n          dev: true,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-positive',\n          path: path.join(modulesDir, '.pnpm/is-positive@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-positive/-/is-positive-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n      optionalDependencies: [\n        {\n          alias: 'is-negative',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-negative',\n          optional: true,\n          path: path.join(modulesDir, '.pnpm/is-negative@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-negative/-/is-negative-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"only prod depth 0","suites":[],"updatePoint":{"line":167,"column":23},"line":167,"code":"test('only prod depth 0', async () => {\n  const tree = await dh(\n    [generalFixture],\n    {\n      depth: 0,\n      include: {\n        dependencies: true,\n        devDependencies: false,\n        optionalDependencies: false,\n      },\n      lockfileDir: generalFixture,\n    }\n  )\n  const modulesDir = path.join(generalFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      dependencies: [\n        {\n          alias: 'minimatch',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'minimatch',\n          path: path.join(modulesDir, '.pnpm/minimatch@3.0.4'),\n          resolved: 'https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz',\n          version: '3.0.4',\n        },\n        {\n          alias: 'rimraf',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'rimraf',\n          path: path.join(modulesDir, '.pnpm/rimraf@2.5.1'),\n          resolved: 'https://registry.npmjs.org/rimraf/-/rimraf-2.5.1.tgz',\n          version: '2.5.1',\n        },\n      ],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"only dev depth 0","suites":[],"updatePoint":{"line":212,"column":22},"line":212,"code":"test('only dev depth 0', async () => {\n  const tree = await dh(\n    [generalFixture],\n    {\n      depth: 0,\n      include: {\n        dependencies: false,\n        devDependencies: true,\n        optionalDependencies: false,\n      },\n      lockfileDir: generalFixture,\n    }\n  )\n  const modulesDir = path.join(generalFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      devDependencies: [\n        {\n          alias: 'is-positive',\n          dev: true,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-positive',\n          path: path.join(modulesDir, '.pnpm/is-positive@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-positive/-/is-positive-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"hierarchy for no packages","suites":[],"updatePoint":{"line":246,"column":31},"line":246,"code":"test('hierarchy for no packages', async () => {\n  const tree = await dh([generalFixture], {\n    depth: 100,\n    lockfileDir: generalFixture,\n    search: () => false,\n  })\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      dependencies: [],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"filter 1 package with depth 0","suites":[],"updatePoint":{"line":262,"column":35},"line":262,"code":"test('filter 1 package with depth 0', async () => {\n  const tree = await dh(\n    [generalFixture],\n    {\n      depth: 0,\n      lockfileDir: generalFixture,\n      search: ({ name }) => name === 'rimraf',\n    }\n  )\n  const modulesDir = path.join(generalFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [generalFixture]: {\n      dependencies: [\n        {\n          alias: 'rimraf',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'rimraf',\n          path: path.join(modulesDir, '.pnpm/rimraf@2.5.1'),\n          resolved: 'https://registry.npmjs.org/rimraf/-/rimraf-2.5.1.tgz',\n          searched: true,\n          version: '2.5.1',\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"circular dependency","suites":[],"updatePoint":{"line":295,"column":25},"line":295,"code":"test('circular dependency', async () => {\n  const tree = await dh([circularFixture], { depth: 1000, lockfileDir: circularFixture })\n  const modulesDir = path.join(circularFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [circularFixture]: {\n      dependencies: require('./circularTree.json') // eslint-disable-line\n        .dependencies\n        .map((dep: PackageNode) => resolvePaths(modulesDir, dep)),\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"local package depth 0","suites":[],"updatePoint":{"line":327,"column":27},"line":327,"code":"test('local package depth 0', async () => {\n  const tree = await dh([withFileDepFixture], { depth: 1, lockfileDir: withFileDepFixture })\n  const modulesDir = path.join(withFileDepFixture, 'node_modules')\n\n  expect(tree).toStrictEqual({\n    [withFileDepFixture]: {\n      dependencies: [\n        {\n          alias: 'general',\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'general',\n          path: generalFixture,\n          version: 'link:../general',\n        },\n        {\n          alias: 'is-positive',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-positive',\n          path: path.join(modulesDir, '.pnpm/is-positive@3.1.0'),\n          resolved: 'https://registry.npmjs.org/is-positive/-/is-positive-3.1.0.tgz',\n          version: '3.1.0',\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"on a package that has only links","suites":[],"updatePoint":{"line":361,"column":38},"line":361,"code":"test('on a package that has only links', async () => {\n  const tree = await dh([withLinksOnlyFixture], { depth: 1000, lockfileDir: withLinksOnlyFixture })\n\n  expect(tree).toStrictEqual({\n    [withLinksOnlyFixture]: {\n      dependencies: [\n        {\n          alias: 'general',\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'general',\n          path: path.join(fixtures, 'fixtureWithLinks/general'),\n          version: 'link:../general',\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"unsaved dependencies are listed","suites":[],"updatePoint":{"line":383,"column":37},"line":383,"code":"test('unsaved dependencies are listed', async () => {\n  const modulesDir = path.join(withUnsavedDepsFixture, 'node_modules')\n  expect(await dh([withUnsavedDepsFixture], { depth: 0, lockfileDir: withUnsavedDepsFixture }))\n    .toStrictEqual({\n      [withUnsavedDepsFixture]: {\n        dependencies: [\n          {\n            alias: 'symlink-dir',\n            dev: false,\n            isMissing: false,\n            isPeer: false,\n            isSkipped: false,\n            name: 'symlink-dir',\n            path: path.join(modulesDir, '.pnpm/symlink-dir@2.0.2'),\n            resolved: 'https://registry.npmjs.org/symlink-dir/-/symlink-dir-2.0.2.tgz',\n            version: '2.0.2',\n          },\n        ],\n        devDependencies: [],\n        optionalDependencies: [],\n        unsavedDependencies: [\n          {\n            alias: 'general',\n            isMissing: false,\n            isPeer: false,\n            isSkipped: false,\n            name: 'general',\n            path: generalFixture,\n            version: 'link:../general',\n          },\n        ],\n      },\n    })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"unsaved dependencies are listed and filtered","suites":[],"updatePoint":{"line":418,"column":50},"line":418,"code":"test('unsaved dependencies are listed and filtered', async () => {\n  const modulesDir = path.join(withUnsavedDepsFixture, 'node_modules')\n  expect(\n    await dh(\n      [withUnsavedDepsFixture],\n      {\n        depth: 0,\n        lockfileDir: withUnsavedDepsFixture,\n        search: ({ name }) => name === 'symlink-dir',\n      }\n    )\n  ).toStrictEqual({\n    [withUnsavedDepsFixture]: {\n      dependencies: [\n        {\n          alias: 'symlink-dir',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'symlink-dir',\n          path: path.join(modulesDir, '.pnpm/symlink-dir@2.0.2'),\n          resolved: 'https://registry.npmjs.org/symlink-dir/-/symlink-dir-2.0.2.tgz',\n          searched: true,\n          version: '2.0.2',\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"do not fail on importers that are not in current ","suites":[],"updatePoint":{"line":452,"column":73},"line":452,"code":"test(`do not fail on importers that are not in current ${WANTED_LOCKFILE}`, async () => {\n  expect(await dh([fixtureMonorepo], { depth: 0, lockfileDir: fixtureMonorepo })).toStrictEqual({ [fixtureMonorepo]: {} })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"dependency with an alias","suites":[],"updatePoint":{"line":456,"column":30},"line":456,"code":"test('dependency with an alias', async () => {\n  const modulesDir = path.join(withAliasedDepFixture, 'node_modules')\n  expect(\n    await dh([withAliasedDepFixture], { depth: 0, lockfileDir: withAliasedDepFixture })\n  ).toStrictEqual({\n    [withAliasedDepFixture]: {\n      dependencies: [\n        {\n          alias: 'positive',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'is-positive',\n          path: path.join(modulesDir, '.pnpm/is-positive@1.0.0'),\n          resolved: 'https://registry.npmjs.org/is-positive/-/is-positive-1.0.0.tgz',\n          version: '1.0.0',\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"peer dependencies","suites":[],"updatePoint":{"line":481,"column":23},"line":481,"code":"test('peer dependencies', async () => {\n  const hierarchy = await dh([withPeerFixture], { depth: 1, lockfileDir: withPeerFixture })\n  expect(hierarchy[withPeerFixture].dependencies![1].dependencies![0].name).toEqual('ajv')\n  expect(hierarchy[withPeerFixture].dependencies![1].dependencies![0].isPeer).toEqual(true)\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"dependency without a package.json","suites":[],"updatePoint":{"line":488,"column":39},"line":488,"code":"test('dependency without a package.json', async () => {\n  const org = 'denolib'\n  const pkg = 'camelcase'\n  const commit = 'aeb6b15f9c9957c8fa56f9731e914c4d8a6d2f2b'\n  const tree = await dh([withNonPackageDepFixture], { depth: 0, lockfileDir: withNonPackageDepFixture })\n  expect(tree).toStrictEqual({\n    [withNonPackageDepFixture]: {\n      dependencies: [\n        {\n          alias: 'camelcase',\n          dev: false,\n          isMissing: false,\n          isPeer: false,\n          isSkipped: false,\n          name: 'camelcase',\n          path: path.join(withNonPackageDepFixture, 'node_modules', '.pnpm', `github.com+${org}+${pkg}@${commit}`),\n          resolved: `https://codeload.github.com/${org}/${pkg}/tar.gz/${commit}`,\n          version: `${org}/${pkg}#${commit}`,\n        },\n      ],\n      devDependencies: [],\n      optionalDependencies: [],\n    },\n  })\n  // verify dependency without a package.json\n  expect(tree[withNonPackageDepFixture].dependencies).toBeDefined()\n  expect(Array.isArray(tree[withNonPackageDepFixture].dependencies)).toBeTruthy()\n  expect(tree[withNonPackageDepFixture].dependencies!.length).toBeGreaterThan(0)\n  expect(tree[withNonPackageDepFixture].dependencies![0]).toBeDefined()\n  // verify that dependency without a package.json has no further dependencies\n  expect(tree[withNonPackageDepFixture].dependencies![0]['dependencies']).toBeUndefined()\n  expect(tree[withNonPackageDepFixture].dependencies![0]['devDependencies']).toBeUndefined()\n  expect(tree[withNonPackageDepFixture].dependencies![0]['optionalDependencies']).toBeUndefined()\n})","file":"index.ts","skipped":false,"dir":"packages/dependencies-hierarchy/test"},{"name":"isAbsolute()","suites":[],"updatePoint":{"line":13,"column":18},"line":13,"code":"test('isAbsolute()', () => {\n  expect(isAbsolute('/foo/1.0.0')).toBeFalsy()\n  expect(isAbsolute('registry.npmjs.org/foo/1.0.0')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"parse()","suites":[],"updatePoint":{"line":18,"column":13},"line":18,"code":"test('parse()', () => {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  expect(() => parse(undefined as any)).toThrow(/got `undefined`/)\n  expect(() => parse({} as any)).toThrow(/got `object`/)\n  expect(() => parse(1 as any)).toThrow(/got `number`/)\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  expect(parse('/foo/1.0.0')).toStrictEqual({\n    host: undefined,\n    isAbsolute: false,\n    name: 'foo',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(parse('/@foo/bar/1.0.0')).toStrictEqual({\n    host: undefined,\n    isAbsolute: false,\n    name: '@foo/bar',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(parse('registry.npmjs.org/foo/1.0.0')).toStrictEqual({\n    host: 'registry.npmjs.org',\n    isAbsolute: true,\n    name: 'foo',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(parse('registry.npmjs.org/@foo/bar/1.0.0')).toStrictEqual({\n    host: 'registry.npmjs.org',\n    isAbsolute: true,\n    name: '@foo/bar',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(parse('github.com/kevva/is-positive')).toStrictEqual({\n    host: 'github.com',\n    isAbsolute: true,\n  })\n\n  expect(parse('example.com/foo/1.0.0')).toStrictEqual({\n    host: 'example.com',\n    isAbsolute: true,\n    name: 'foo',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(parse('example.com/foo/1.0.0_bar@2.0.0')).toStrictEqual({\n    host: 'example.com',\n    isAbsolute: true,\n    name: 'foo',\n    peersSuffix: 'bar@2.0.0',\n    version: '1.0.0',\n  })\n\n  expect(parse('/foo/1.0.0_@types+babel__core@7.1.14')).toStrictEqual({\n    host: undefined,\n    isAbsolute: false,\n    name: 'foo',\n    peersSuffix: '@types+babel__core@7.1.14',\n    version: '1.0.0',\n  })\n\n  expect(() => parse('/foo/bar')).toThrow(/\\/foo\\/bar is an invalid relative dependency path/)\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"refToAbsolute()","suites":[],"updatePoint":{"line":88,"column":21},"line":88,"code":"test('refToAbsolute()', () => {\n  const registries = {\n    '@foo': 'http://foo.com/',\n    default: 'https://registry.npmjs.org/',\n  }\n  expect(refToAbsolute('1.0.0', 'foo', registries)).toEqual('registry.npmjs.org/foo/1.0.0')\n  expect(refToAbsolute('1.0.0', '@foo/foo', registries)).toEqual('foo.com/@foo/foo/1.0.0')\n  expect(refToAbsolute('registry.npmjs.org/foo/1.0.0', 'foo', registries)).toEqual('registry.npmjs.org/foo/1.0.0')\n  expect(refToAbsolute('/foo/1.0.0', 'foo', registries)).toEqual('registry.npmjs.org/foo/1.0.0')\n  expect(refToAbsolute('/@foo/foo/1.0.0', '@foo/foo', registries)).toEqual('foo.com/@foo/foo/1.0.0')\n  // linked dependencies don't have an absolute path\n  expect(refToAbsolute('link:../foo', 'foo', registries)).toBeNull()\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"refToRelative()","suites":[],"updatePoint":{"line":102,"column":21},"line":102,"code":"test('refToRelative()', () => {\n  expect(refToRelative('/@most/multicast/1.3.0/most@1.7.3', '@most/multicast')).toEqual('/@most/multicast/1.3.0/most@1.7.3')\n  // linked dependencies don't have a relative path\n  expect(refToRelative('link:../foo', 'foo')).toBeNull()\n  expect(refToRelative('file:../tarball.tgz', 'foo')).toEqual('file:../tarball.tgz')\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"relative()","suites":[],"updatePoint":{"line":109,"column":16},"line":109,"code":"test('relative()', () => {\n  const registries = {\n    '@foo': 'http://localhost:4873/',\n    default: 'https://registry.npmjs.org/',\n  }\n  expect(relative(registries, 'foo', 'registry.npmjs.org/foo/1.0.0')).toEqual('/foo/1.0.0')\n  expect(relative(registries, '@foo/foo', 'localhost+4873/@foo/foo/1.0.0')).toEqual('/@foo/foo/1.0.0')\n  expect(relative(registries, 'foo', 'registry.npmjs.org/foo/1.0.0/PeLdniYiO858gXNY39o5wISKyw')).toEqual('/foo/1.0.0/PeLdniYiO858gXNY39o5wISKyw')\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"resolve()","suites":[],"updatePoint":{"line":119,"column":15},"line":119,"code":"test('resolve()', () => {\n  const registries = {\n    '@bar': 'https://bar.com/',\n    default: 'https://foo.com/',\n  }\n  expect(resolve(registries, '/foo/1.0.0')).toEqual('foo.com/foo/1.0.0')\n  expect(resolve(registries, '/@bar/bar/1.0.0')).toEqual('bar.com/@bar/bar/1.0.0')\n  expect(resolve(registries, '/@qar/qar/1.0.0')).toEqual('foo.com/@qar/qar/1.0.0')\n  expect(resolve(registries, 'qar.com/foo/1.0.0')).toEqual('qar.com/foo/1.0.0')\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"depPathToFilename()","suites":[],"updatePoint":{"line":130,"column":25},"line":130,"code":"test('depPathToFilename()', () => {\n  expect(depPathToFilename('/foo/1.0.0')).toBe('foo@1.0.0')\n  expect(depPathToFilename('/@foo/bar/1.0.0')).toBe('@foo+bar@1.0.0')\n  expect(depPathToFilename('github.com/something/foo/0000')).toBe('github.com+something+foo@0000')\n\n  const filename = depPathToFilename('file:test/foo-1.0.0.tgz_foo@2.0.0')\n  expect(filename).toBe('file+test+foo-1.0.0.tgz_foo@2.0.0')\n  expect(filename).not.toContain(':')\n\n  expect(depPathToFilename('abcd/'.repeat(200))).toBe('abcd+abcd+abcd+abcd+abcd+abcd+abcd+abcd+abcd+abcd+_e5jega7r3xmarw3h6f277a3any')\n  expect(depPathToFilename('/JSONSteam/1.0.0')).toBe('JSONSteam@1.0.0_jmswpk4sf667aelr6wp2xd3p54')\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"tryGetPackageId","suites":[],"updatePoint":{"line":143,"column":21},"line":143,"code":"test('tryGetPackageId', () => {\n  expect(tryGetPackageId({ default: 'https://registry.npmjs.org/' }, '/foo/1.0.0_@types+babel__core@7.1.14')).toEqual('registry.npmjs.org/foo/1.0.0')\n})","file":"index.ts","skipped":false,"dir":"packages/dependency-path/test"},{"name":"fetch including only package files","suites":[],"updatePoint":{"line":8,"column":40},"line":8,"code":"test('fetch including only package files', async () => {\n  process.chdir(f.find('simple-pkg'))\n  const fetcher = createFetcher({ includeOnlyPackageFiles: true })\n\n  // eslint-disable-next-line\n  const fetchResult = await fetcher.directory({} as any, {\n    directory: '.',\n    type: 'directory',\n  }, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(fetchResult.local).toBe(true)\n  expect(fetchResult.packageImportMethod).toBe('hardlink')\n  expect(fetchResult.filesIndex['package.json']).toBe(path.resolve('package.json'))\n\n  // Only those files are included which would get published\n  expect(Object.keys(fetchResult.filesIndex).sort()).toStrictEqual([\n    'index.js',\n    'package.json',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/directory-fetcher/test"},{"name":"fetch including all files","suites":[],"updatePoint":{"line":31,"column":31},"line":31,"code":"test('fetch including all files', async () => {\n  process.chdir(f.find('simple-pkg'))\n  const fetcher = createFetcher()\n\n  // eslint-disable-next-line\n  const fetchResult = await fetcher.directory({} as any, {\n    directory: '.',\n    type: 'directory',\n  }, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(fetchResult.local).toBe(true)\n  expect(fetchResult.packageImportMethod).toBe('hardlink')\n  expect(fetchResult.filesIndex['package.json']).toBe(path.resolve('package.json'))\n\n  // Only those files are included which would get published\n  expect(Object.keys(fetchResult.filesIndex).sort()).toStrictEqual([\n    'index.js',\n    'package.json',\n    'test.js',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/directory-fetcher/test"},{"name":"fetch a directory that has no package.json","suites":[],"updatePoint":{"line":55,"column":48},"line":55,"code":"test('fetch a directory that has no package.json', async () => {\n  process.chdir(f.find('no-manifest'))\n  const fetcher = createFetcher()\n  const manifest = {\n    resolve: jest.fn(),\n    reject: jest.fn(),\n  }\n\n  // eslint-disable-next-line\n  const fetchResult = await fetcher.directory({} as any, {\n    directory: '.',\n    type: 'directory',\n  }, {\n    lockfileDir: process.cwd(),\n    manifest,\n  })\n\n  expect(manifest.resolve).toBeCalledWith({})\n  expect(fetchResult.local).toBe(true)\n  expect(fetchResult.packageImportMethod).toBe('hardlink')\n  expect(fetchResult.filesIndex['index.js']).toBe(path.resolve('index.js'))\n\n  // Only those files are included which would get published\n  expect(Object.keys(fetchResult.filesIndex).sort()).toStrictEqual([\n    'index.js',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/directory-fetcher/test"},{"name":"the pnpm options are removed","suites":[],"updatePoint":{"line":4,"column":34},"line":4,"code":"test('the pnpm options are removed', async () => {\n  expect(await exportableManifest(process.cwd(), {\n    name: 'foo',\n    version: '1.0.0',\n    dependencies: {\n      qar: '2',\n    },\n    pnpm: {\n      overrides: {\n        bar: '1',\n      },\n    },\n  })).toStrictEqual({\n    name: 'foo',\n    version: '1.0.0',\n    dependencies: {\n      qar: '2',\n    },\n  })\n})","file":"index.test.ts","skipped":false,"dir":"packages/exportable-manifest/test"},{"name":"publish lifecycle scripts are removed","suites":[],"updatePoint":{"line":25,"column":43},"line":25,"code":"test('publish lifecycle scripts are removed', async () => {\n  expect(await exportableManifest(process.cwd(), {\n    name: 'foo',\n    version: '1.0.0',\n    scripts: {\n      prepublishOnly: 'echo',\n      prepack: 'echo',\n      prepare: 'echo',\n      postpack: 'echo',\n      publish: 'echo',\n      postpublish: 'echo',\n      postinstall: 'echo',\n      test: 'echo',\n    },\n  })).toStrictEqual({\n    name: 'foo',\n    version: '1.0.0',\n    scripts: {\n      postinstall: 'echo',\n      test: 'echo',\n    },\n  })\n})","file":"index.test.ts","skipped":false,"dir":"packages/exportable-manifest/test"},{"name":"readme added to published manifest","suites":[],"updatePoint":{"line":49,"column":40},"line":49,"code":"test('readme added to published manifest', async () => {\n  expect(await exportableManifest(process.cwd(), {\n    name: 'foo',\n    version: '1.0.0',\n  }, { readmeFile: 'readme content' })).toStrictEqual({\n    name: 'foo',\n    version: '1.0.0',\n    readme: 'readme content',\n  })\n})","file":"index.test.ts","skipped":false,"dir":"packages/exportable-manifest/test"},{"name":"fetchFromRegistry","suites":[],"updatePoint":{"line":5,"column":23},"line":5,"code":"test('fetchFromRegistry', async () => {\n  const fetchFromRegistry = createFetchFromRegistry({})\n  const res = await fetchFromRegistry('https://registry.npmjs.org/is-positive')\n  const metadata = await res.json() as any // eslint-disable-line\n  expect(metadata.name).toEqual('is-positive')\n  expect(metadata.versions['1.0.0'].scripts).not.toBeTruthy()\n})","file":"fetchFromRegistry.test.ts","skipped":false,"dir":"packages/fetch/test"},{"name":"fetchFromRegistry fullMetadata","suites":[],"updatePoint":{"line":13,"column":36},"line":13,"code":"test('fetchFromRegistry fullMetadata', async () => {\n  const fetchFromRegistry = createFetchFromRegistry({ fullMetadata: true })\n  const res = await fetchFromRegistry('https://registry.npmjs.org/is-positive')\n  const metadata = await res.json() as any // eslint-disable-line\n  expect(metadata.name).toEqual('is-positive')\n  expect(metadata.versions['1.0.0'].scripts).toBeTruthy()\n})","file":"fetchFromRegistry.test.ts","skipped":false,"dir":"packages/fetch/test"},{"name":"authorization headers are removed before redirection if the target is on a different host","suites":[],"updatePoint":{"line":21,"column":95},"line":21,"code":"test('authorization headers are removed before redirection if the target is on a different host', async () => {\n  nock('http://registry.pnpm.io/', {\n    reqheaders: { authorization: 'Bearer 123' },\n  })\n    .get('/is-positive')\n    .reply(302, '', { location: 'http://registry.other.org/is-positive' })\n  nock('http://registry.other.org/', { badheaders: ['authorization'] })\n    .get('/is-positive')\n    .reply(200, { ok: true })\n\n  const fetchFromRegistry = createFetchFromRegistry({ fullMetadata: true })\n  const res = await fetchFromRegistry(\n    'http://registry.pnpm.io/is-positive',\n    { authHeaderValue: 'Bearer 123' }\n  )\n\n  expect(await res.json()).toStrictEqual({ ok: true })\n  expect(nock.isDone()).toBeTruthy()\n})","file":"fetchFromRegistry.test.ts","skipped":false,"dir":"packages/fetch/test"},{"name":"authorization headers are not removed before redirection if the target is on the same host","suites":[],"updatePoint":{"line":41,"column":96},"line":41,"code":"test('authorization headers are not removed before redirection if the target is on the same host', async () => {\n  nock('http://registry.pnpm.io/', {\n    reqheaders: { authorization: 'Bearer 123' },\n  })\n    .get('/is-positive')\n    .reply(302, '', { location: 'http://registry.pnpm.io/is-positive-new' })\n  nock('http://registry.pnpm.io/', {\n    reqheaders: { authorization: 'Bearer 123' },\n  })\n    .get('/is-positive-new')\n    .reply(200, { ok: true })\n\n  const fetchFromRegistry = createFetchFromRegistry({ fullMetadata: true })\n  const res = await fetchFromRegistry(\n    'http://registry.pnpm.io/is-positive',\n    { authHeaderValue: 'Bearer 123' }\n  )\n\n  expect(await res.json()).toStrictEqual({ ok: true })\n  expect(nock.isDone()).toBeTruthy()\n})","file":"fetchFromRegistry.test.ts","skipped":false,"dir":"packages/fetch/test"},{"name":"switch to the correct agent for requests on redirect from http: to https:","suites":[],"updatePoint":{"line":63,"column":79},"line":63,"code":"test('switch to the correct agent for requests on redirect from http: to https:', async () => {\n  const fetchFromRegistry = createFetchFromRegistry({ fullMetadata: true })\n\n  // We can test this on any endpoint that redirects from http: to https:\n  const { status } = await fetchFromRegistry('http://pnpm.io/pnpm.js')\n\n  expect(status).toEqual(200)\n})","file":"fetchFromRegistry.test.ts","skipped":false,"dir":"packages/fetch/test"},{"name":"pnpm-log is created on fail","suites":[],"updatePoint":{"line":8,"column":33},"line":8,"code":"test('pnpm-log is created on fail', () => {\n  const fixture = path.join(fixtures, '1')\n  child.spawnSync('node', [path.join(fixture, 'index.js')], { cwd: fixture })\n  const actual = fs.readFileSync(path.join(fixture, 'node_modules/.pnpm-debug.log'), 'utf-8')\n  const expected = fs.readFileSync(path.join(fixture, 'stdout'), 'utf-8')\n  expect(actual).toBe(expected)\n})","file":"index.ts","skipped":false,"dir":"packages/file-reporter/test"},{"name":"pnpm-log is not created on fail if the writeDebugLogFile global variable is set to false","suites":[],"updatePoint":{"line":16,"column":94},"line":16,"code":"test('pnpm-log is not created on fail if the writeDebugLogFile global variable is set to false', async () => {\n  const fixture = path.join(fixtures, '3')\n  child.spawnSync('node', [path.join(fixture, 'index.js')], { cwd: fixture })\n  expect(!await exists(path.join(fixture, 'node_modules/.pnpm-debug.log'))).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/file-reporter/test"},{"name":"pnpm-log is not created on success","suites":[],"updatePoint":{"line":22,"column":40},"line":22,"code":"test('pnpm-log is not created on success', async () => {\n  const fixture = path.join(fixtures, '2')\n  child.spawnSync('node', [path.join(fixture, 'index.js')], { cwd: fixture })\n  expect(!await exists(path.join(fixture, 'node_modules/.pnpm-debug.log'))).toBeTruthy() // log file is not created when 0 exit code\n})","file":"index.ts","skipped":false,"dir":"packages/file-reporter/test"},{"name":"filterByImporters(): only prod dependencies of one importer","suites":[],"updatePoint":{"line":4,"column":65},"line":4,"code":"test('filterByImporters(): only prod dependencies of one importer', () => {\n  const filteredLockfile = filterLockfileByImporters(\n    {\n      importers: {\n        'project-1': {\n          dependencies: {\n            'prod-dep': '1.0.0',\n          },\n          devDependencies: {\n            'dev-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'optional-dep': '1.0.0',\n          },\n          specifiers: {\n            'dev-dep': '^1.0.0',\n            'optional-dep': '^1.0.0',\n            'prod-dep': '^1.0.0',\n          },\n        },\n        'project-2': {\n          dependencies: {\n            'project-2-prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'project-2-prod-dep': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/dev-dep/1.0.0': {\n          dev: true,\n          resolution: { integrity: '' },\n        },\n        '/optional-dep/1.0.0': {\n          optional: true,\n          resolution: { integrity: '' },\n        },\n        '/prod-dep-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/prod-dep/1.0.0': {\n          dependencies: {\n            'prod-dep-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'optional-dep': '1.0.0',\n          },\n          resolution: { integrity: '' },\n        },\n        '/project-2-prod-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n      },\n    },\n    ['project-1'],\n    {\n      failOnMissingDependencies: true,\n      include: {\n        dependencies: true,\n        devDependencies: false,\n        optionalDependencies: false,\n      },\n      skipped: new Set<string>(),\n    }\n  )\n\n  expect(filteredLockfile).toStrictEqual({\n    importers: {\n      'project-1': {\n        dependencies: {\n          'prod-dep': '1.0.0',\n        },\n        devDependencies: {},\n        optionalDependencies: {},\n        specifiers: {\n          'dev-dep': '^1.0.0',\n          'optional-dep': '^1.0.0',\n          'prod-dep': '^1.0.0',\n        },\n      },\n      'project-2': {\n        dependencies: {\n          'project-2-prod-dep': '1.0.0',\n        },\n        specifiers: {\n          'project-2-prod-dep': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/prod-dep-dep/1.0.0': {\n        resolution: { integrity: '' },\n      },\n      '/prod-dep/1.0.0': {\n        dependencies: {\n          'prod-dep-dep': '1.0.0',\n        },\n        optionalDependencies: {\n          'optional-dep': '1.0.0',\n        },\n        resolution: { integrity: '' },\n      },\n    },\n  })\n})","file":"filterByImporters.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"filterByImporters(): fail on missing packages when failOnMissingDependencies is true","suites":[],"updatePoint":{"line":114,"column":90},"line":114,"code":"test('filterByImporters(): fail on missing packages when failOnMissingDependencies is true', () => {\n  let err!: Error\n  try {\n    filterLockfileByImporters(\n      {\n        importers: {\n          'project-1': {\n            dependencies: {\n              'prod-dep': '1.0.0',\n            },\n            specifiers: {\n              'prod-dep': '^1.0.0',\n            },\n          },\n          'project-2': {\n            specifiers: {},\n          },\n        },\n        lockfileVersion: LOCKFILE_VERSION,\n        packages: {\n          '/prod-dep/1.0.0': {\n            dependencies: {\n              'prod-dep-dep': '1.0.0',\n            },\n            resolution: {\n              integrity: '',\n            },\n          },\n        },\n      },\n      ['project-1'],\n      {\n        failOnMissingDependencies: true,\n        include: {\n          dependencies: true,\n          devDependencies: false,\n          optionalDependencies: false,\n        },\n        skipped: new Set<string>(),\n      }\n    )\n  } catch (_: any) { // eslint-disable-line\n    err = _\n  }\n  expect(err).not.toBeNull()\n  expect(err.message).toEqual(`Broken lockfile: no entry for '/prod-dep-dep/1.0.0' in ${WANTED_LOCKFILE}`)\n})","file":"filterByImporters.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"filterByImporters(): do not fail on missing packages when failOnMissingDependencies is false","suites":[],"updatePoint":{"line":162,"column":98},"line":162,"code":"test('filterByImporters(): do not fail on missing packages when failOnMissingDependencies is false', () => {\n  const filteredLockfile = filterLockfileByImporters(\n    {\n      importers: {\n        'project-1': {\n          dependencies: {\n            'prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'prod-dep': '^1.0.0',\n          },\n        },\n        'project-2': {\n          specifiers: {},\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/prod-dep/1.0.0': {\n          dependencies: {\n            'prod-dep-dep': '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n      },\n    },\n    ['project-1'],\n    {\n      failOnMissingDependencies: false,\n      include: {\n        dependencies: true,\n        devDependencies: false,\n        optionalDependencies: false,\n      },\n      skipped: new Set<string>(),\n    }\n  )\n\n  expect(filteredLockfile).toStrictEqual({\n    importers: {\n      'project-1': {\n        dependencies: {\n          'prod-dep': '1.0.0',\n        },\n        devDependencies: {},\n        optionalDependencies: {},\n        specifiers: {\n          'prod-dep': '^1.0.0',\n        },\n      },\n      'project-2': {\n        specifiers: {},\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/prod-dep/1.0.0': {\n        dependencies: {\n          'prod-dep-dep': '1.0.0',\n        },\n        resolution: { integrity: '' },\n      },\n    },\n  })\n})","file":"filterByImporters.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"filterByImporters(): do not include skipped packages","suites":[],"updatePoint":{"line":230,"column":58},"line":230,"code":"test('filterByImporters(): do not include skipped packages', () => {\n  const filteredLockfile = filterLockfileByImporters(\n    {\n      importers: {\n        'project-1': {\n          dependencies: {\n            'prod-dep': '1.0.0',\n          },\n          devDependencies: {\n            'dev-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'optional-dep': '1.0.0',\n          },\n          specifiers: {\n            'dev-dep': '^1.0.0',\n            'optional-dep': '^1.0.0',\n            'prod-dep': '^1.0.0',\n          },\n        },\n        'project-2': {\n          dependencies: {\n            'project-2-prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'project-2-prod-dep': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/dev-dep/1.0.0': {\n          dev: true,\n          resolution: { integrity: '' },\n        },\n        '/optional-dep/1.0.0': {\n          optional: true,\n          resolution: { integrity: '' },\n        },\n        '/prod-dep-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/prod-dep/1.0.0': {\n          dependencies: {\n            'prod-dep-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'optional-dep': '1.0.0',\n          },\n          resolution: { integrity: '' },\n        },\n        '/project-2-prod-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n      },\n    },\n    ['project-1'],\n    {\n      failOnMissingDependencies: true,\n      include: {\n        dependencies: true,\n        devDependencies: true,\n        optionalDependencies: true,\n      },\n      skipped: new Set<string>(['/optional-dep/1.0.0']),\n    }\n  )\n\n  expect(filteredLockfile).toStrictEqual({\n    importers: {\n      'project-1': {\n        dependencies: {\n          'prod-dep': '1.0.0',\n        },\n        devDependencies: {\n          'dev-dep': '1.0.0',\n        },\n        optionalDependencies: {\n          'optional-dep': '1.0.0',\n        },\n        specifiers: {\n          'dev-dep': '^1.0.0',\n          'optional-dep': '^1.0.0',\n          'prod-dep': '^1.0.0',\n        },\n      },\n      'project-2': {\n        dependencies: {\n          'project-2-prod-dep': '1.0.0',\n        },\n        specifiers: {\n          'project-2-prod-dep': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/dev-dep/1.0.0': {\n        dev: true,\n        resolution: { integrity: '' },\n      },\n      '/prod-dep-dep/1.0.0': {\n        resolution: { integrity: '' },\n      },\n      '/prod-dep/1.0.0': {\n        dependencies: {\n          'prod-dep-dep': '1.0.0',\n        },\n        optionalDependencies: {\n          'optional-dep': '1.0.0',\n        },\n        resolution: { integrity: '' },\n      },\n    },\n  })\n})","file":"filterByImporters.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"filterByImporters(): exclude orphan packages","suites":[],"updatePoint":{"line":347,"column":50},"line":347,"code":"test('filterByImporters(): exclude orphan packages', () => {\n  const filteredLockfile = filterLockfileByImporters(\n    {\n      importers: {\n        'project-1': {\n          dependencies: {\n            'prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'prod-dep': '^1.0.0',\n          },\n        },\n        'project-2': {\n          dependencies: {\n            'project-2-prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'project-2-prod-dep': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/orphan/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/prod-dep-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/prod-dep/1.0.0': {\n          dependencies: {\n            'prod-dep-dep': '1.0.0',\n          },\n          resolution: { integrity: '' },\n        },\n        '/project-2-prod-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n      },\n    },\n    ['project-1', 'project-2'],\n    {\n      failOnMissingDependencies: true,\n      include: {\n        dependencies: true,\n        devDependencies: true,\n        optionalDependencies: true,\n      },\n      skipped: new Set<string>(),\n    }\n  )\n\n  expect(filteredLockfile).toStrictEqual({\n    importers: {\n      'project-1': {\n        dependencies: {\n          'prod-dep': '1.0.0',\n        },\n        devDependencies: {},\n        optionalDependencies: {},\n        specifiers: {\n          'prod-dep': '^1.0.0',\n        },\n      },\n      'project-2': {\n        dependencies: {\n          'project-2-prod-dep': '1.0.0',\n        },\n        devDependencies: {},\n        optionalDependencies: {},\n        specifiers: {\n          'project-2-prod-dep': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/prod-dep-dep/1.0.0': {\n        resolution: { integrity: '' },\n      },\n      '/prod-dep/1.0.0': {\n        dependencies: {\n          'prod-dep-dep': '1.0.0',\n        },\n        resolution: { integrity: '' },\n      },\n      '/project-2-prod-dep/1.0.0': {\n        resolution: { integrity: '' },\n      },\n    },\n  })\n})","file":"filterByImporters.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"filterByImportersAndEngine(): skip packages that are not installable","suites":[],"updatePoint":{"line":4,"column":74},"line":4,"code":"test('filterByImportersAndEngine(): skip packages that are not installable', () => {\n  const skippedPackages = new Set<string>(['/preserve-existing-skipped/1.0.0'])\n  const filteredLockfile = filterLockfileByImportersAndEngine(\n    {\n      importers: {\n        'project-1': {\n          dependencies: {\n            'prod-dep': '1.0.0',\n          },\n          devDependencies: {\n            'dev-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'not-skipped-optional': '1.0.0',\n            'optional-dep': '1.0.0',\n          },\n          specifiers: {\n            'dev-dep': '^1.0.0',\n            'not-skipped-optional': '^1.0.0',\n            'optional-dep': '^1.0.0',\n            'prod-dep': '^1.0.0',\n          },\n        },\n        'project-2': {\n          dependencies: {\n            'project-2-prod-dep': '1.0.0',\n          },\n          specifiers: {\n            'project-2-prod-dep': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: LOCKFILE_VERSION,\n      packages: {\n        '/bar/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/dev-dep/1.0.0': {\n          dev: true,\n          resolution: { integrity: '' },\n        },\n        '/foo/1.0.0': {\n          optional: true,\n          resolution: { integrity: '' },\n        },\n        '/not-skipped-optional/1.0.0': {\n          optional: true,\n          resolution: { integrity: '' },\n        },\n        '/optional-dep/1.0.0': {\n          dependencies: {\n            bar: '1.0.0',\n            foo: '1.0.0',\n          },\n          engines: {\n            node: '1000',\n          },\n          optional: true,\n          resolution: { integrity: '' },\n        },\n        '/prod-dep-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n        '/prod-dep/1.0.0': {\n          dependencies: {\n            bar: '1.0.0',\n            'prod-dep-dep': '1.0.0',\n          },\n          optionalDependencies: {\n            'optional-dep': '1.0.0',\n          },\n          resolution: { integrity: '' },\n        },\n        '/project-2-prod-dep/1.0.0': {\n          resolution: { integrity: '' },\n        },\n      },\n    },\n    ['project-1'],\n    {\n      currentEngine: {\n        nodeVersion: '10.0.0',\n        pnpmVersion: '2.0.0',\n      },\n      engineStrict: true,\n      failOnMissingDependencies: true,\n      include: {\n        dependencies: true,\n        devDependencies: true,\n        optionalDependencies: true,\n      },\n      lockfileDir: process.cwd(),\n      skipped: skippedPackages,\n    }\n  )\n\n  expect(filteredLockfile).toStrictEqual({\n    importers: {\n      'project-1': {\n        dependencies: {\n          'prod-dep': '1.0.0',\n        },\n        devDependencies: {\n          'dev-dep': '1.0.0',\n        },\n        optionalDependencies: {\n          'not-skipped-optional': '1.0.0',\n          'optional-dep': '1.0.0',\n        },\n        specifiers: {\n          'dev-dep': '^1.0.0',\n          'not-skipped-optional': '^1.0.0',\n          'optional-dep': '^1.0.0',\n          'prod-dep': '^1.0.0',\n        },\n      },\n      'project-2': {\n        dependencies: {\n          'project-2-prod-dep': '1.0.0',\n        },\n        specifiers: {\n          'project-2-prod-dep': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/bar/1.0.0': {\n        resolution: { integrity: '' },\n      },\n      '/dev-dep/1.0.0': {\n        dev: true,\n        resolution: { integrity: '' },\n      },\n      '/foo/1.0.0': {\n        optional: true,\n        resolution: { integrity: '' },\n      },\n      '/not-skipped-optional/1.0.0': {\n        optional: true,\n        resolution: { integrity: '' },\n      },\n      '/optional-dep/1.0.0': {\n        dependencies: {\n          bar: '1.0.0',\n          foo: '1.0.0',\n        },\n        engines: {\n          node: '1000',\n        },\n        optional: true,\n        resolution: { integrity: '' },\n      },\n      '/prod-dep-dep/1.0.0': {\n        resolution: { integrity: '' },\n      },\n      '/prod-dep/1.0.0': {\n        dependencies: {\n          bar: '1.0.0',\n          'prod-dep-dep': '1.0.0',\n        },\n        optionalDependencies: {\n          'optional-dep': '1.0.0',\n        },\n        resolution: { integrity: '' },\n      },\n    },\n  })\n  expect(Array.from(skippedPackages)).toStrictEqual(['/preserve-existing-skipped/1.0.0', '/optional-dep/1.0.0', '/foo/1.0.0'])\n})","file":"filterByImportersAndEngine.ts","skipped":false,"dir":"packages/filter-lockfile/test"},{"name":"select only package dependencies (excluding the package itself)","suites":[],"updatePoint":{"line":121,"column":69},"line":121,"code":"test('select only package dependencies (excluding the package itself)', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: true,\n      includeDependencies: true,\n      namePattern: 'project-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-2', '/project-4'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select package with dependencies","suites":[],"updatePoint":{"line":133,"column":38},"line":133,"code":"test('select package with dependencies', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      includeDependencies: true,\n      namePattern: 'project-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-1', '/project-2', '/project-4'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select package with dependencies and dependents, including dependent dependencies","suites":[],"updatePoint":{"line":145,"column":87},"line":145,"code":"test('select package with dependencies and dependents, including dependent dependencies', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: true,\n      includeDependencies: true,\n      includeDependents: true,\n      namePattern: 'project-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-2', '/project-4', '/packages/project-0', '/packages/project-1', '/project-5'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select package with dependents","suites":[],"updatePoint":{"line":158,"column":36},"line":158,"code":"test('select package with dependents', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      includeDependents: true,\n      namePattern: 'project-2',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-2', '/packages/project-1', '/packages/project-0'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select dependents excluding package itself","suites":[],"updatePoint":{"line":170,"column":48},"line":170,"code":"test('select dependents excluding package itself', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: true,\n      includeDependents: true,\n      namePattern: 'project-2',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-1', '/packages/project-0'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"filter using two selectors: one selects dependencies another selects dependents","suites":[],"updatePoint":{"line":182,"column":85},"line":182,"code":"test('filter using two selectors: one selects dependencies another selects dependents', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: true,\n      includeDependents: true,\n      namePattern: 'project-2',\n    },\n    {\n      excludeSelf: true,\n      includeDependencies: true,\n      namePattern: 'project-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-2', '/project-4', '/packages/project-1', '/packages/project-0'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select just a package by name","suites":[],"updatePoint":{"line":199,"column":35},"line":199,"code":"test('select just a package by name', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      namePattern: 'project-2',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-2'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select package without specifying its scope","suites":[],"updatePoint":{"line":210,"column":49},"line":210,"code":"test('select package without specifying its scope', async () => {\n  const PKGS_GRAPH: PackageGraph<{}> = {\n    '/packages/bar': {\n      dependencies: [],\n      package: {\n        dir: '/packages/bar',\n        manifest: {\n          name: '@foo/bar',\n          version: '1.0.0',\n        },\n      },\n    },\n  }\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      namePattern: 'bar',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/bar'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"when a scoped package with the same name exists, only pick the exact match","suites":[],"updatePoint":{"line":233,"column":80},"line":233,"code":"test('when a scoped package with the same name exists, only pick the exact match', async () => {\n  const PKGS_GRAPH: PackageGraph<{}> = {\n    '/packages/@foo/bar': {\n      dependencies: [],\n      package: {\n        dir: '/packages/@foo/bar',\n        manifest: {\n          name: '@foo/bar',\n          version: '1.0.0',\n        },\n      },\n    },\n    '/packages/bar': {\n      dependencies: [],\n      package: {\n        dir: '/packages/bar',\n        manifest: {\n          name: 'bar',\n          version: '1.0.0',\n        },\n      },\n    },\n  }\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      namePattern: 'bar',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/bar'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"when two scoped packages match the searched name, don't select any","suites":[],"updatePoint":{"line":266,"column":73},"line":266,"code":"test('when two scoped packages match the searched name, don\\'t select any', async () => {\n  const PKGS_GRAPH: PackageGraph<{}> = {\n    '/packages/@foo/bar': {\n      dependencies: [],\n      package: {\n        dir: '/packages/@foo/bar',\n        manifest: {\n          name: '@foo/bar',\n          version: '1.0.0',\n        },\n      },\n    },\n    '/packages/@types/bar': {\n      dependencies: [],\n      package: {\n        dir: '/packages/@types/bar',\n        manifest: {\n          name: '@types/bar',\n          version: '1.0.0',\n        },\n      },\n    },\n  }\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      namePattern: 'bar',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual([])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir","suites":[],"updatePoint":{"line":299,"column":25},"line":299,"code":"test('select by parentDir', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/packages',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-0', '/packages/project-1'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir using glob","suites":[],"updatePoint":{"line":310,"column":36},"line":310,"code":"test('select by parentDir using glob', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/packages/*',\n    },\n  ], { workspaceDir: process.cwd(), useGlobDirFiltering: true })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-0', '/packages/project-1'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir using globstar","suites":[],"updatePoint":{"line":321,"column":40},"line":321,"code":"test('select by parentDir using globstar', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/project-5/**',\n    },\n  ], { workspaceDir: process.cwd(), useGlobDirFiltering: true })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-5', '/project-5/packages/project-6'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir with no glob","suites":[],"updatePoint":{"line":332,"column":38},"line":332,"code":"test('select by parentDir with no glob', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/project-5',\n    },\n  ], { workspaceDir: process.cwd(), useGlobDirFiltering: true })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/project-5'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select changed packages","suites":[],"updatePoint":{"line":343,"column":29},"line":343,"code":"test('select changed packages', async () => {\n  // This test fails on Appveyor due to environmental issues\n  if (isCI && isWindows()) {\n    return\n  }\n\n  const workspaceDir = tempy.directory()\n  await execa('git', ['init'], { cwd: workspaceDir })\n  await execa('git', ['config', 'user.email', 'x@y.z'], { cwd: workspaceDir })\n  await execa('git', ['config', 'user.name', 'xyz'], { cwd: workspaceDir })\n  await execa('git', ['commit', '--allow-empty', '--allow-empty-message', '-m', '', '--no-gpg-sign'], { cwd: workspaceDir })\n\n  const pkg1Dir = path.join(workspaceDir, 'package-1')\n\n  await mkdir(pkg1Dir)\n  await touch(path.join(pkg1Dir, 'file1.js'))\n\n  const pkg2Dir = path.join(workspaceDir, 'package-2')\n\n  await mkdir(pkg2Dir)\n  await touch(path.join(pkg2Dir, 'file2.js'))\n\n  const pkg3Dir = path.join(workspaceDir, 'package-3')\n\n  await mkdir(pkg3Dir)\n\n  await execa('git', ['add', '.'], { cwd: workspaceDir })\n  await execa('git', ['commit', '--allow-empty-message', '-m', '', '--no-gpg-sign'], { cwd: workspaceDir })\n\n  const pkg20Dir = path.join(workspaceDir, 'package-20')\n\n  const pkgsGraph = {\n    [workspaceDir]: {\n      dependencies: [],\n      package: {\n        dir: workspaceDir,\n        manifest: {\n          name: 'root',\n          version: '0.0.0',\n        },\n      },\n    },\n    [pkg1Dir]: {\n      dependencies: [],\n      package: {\n        dir: pkg1Dir,\n        manifest: {\n          name: 'package-1',\n          version: '0.0.0',\n        },\n      },\n    },\n    [pkg2Dir]: {\n      dependencies: [],\n      package: {\n        dir: pkg2Dir,\n        manifest: {\n          name: 'package-2',\n          version: '0.0.0',\n        },\n      },\n    },\n    [pkg3Dir]: {\n      dependencies: [pkg2Dir],\n      package: {\n        dir: pkg3Dir,\n        manifest: {\n          name: 'package-3',\n          version: '0.0.0',\n        },\n      },\n    },\n    [pkg20Dir]: {\n      dependencies: [],\n      package: {\n        dir: pkg20Dir,\n        manifest: {\n          name: 'package-20',\n          version: '0.0.0',\n        },\n      },\n    },\n  }\n\n  {\n    const { selectedProjectsGraph } = await filterWorkspacePackages(pkgsGraph, [{\n      diff: 'HEAD~1',\n    }], { workspaceDir })\n\n    expect(Object.keys(selectedProjectsGraph)).toStrictEqual([pkg1Dir, pkg2Dir])\n  }\n  {\n    const { selectedProjectsGraph } = await filterWorkspacePackages(pkgsGraph, [{\n      diff: 'HEAD~1',\n      parentDir: pkg2Dir,\n    }], { workspaceDir })\n\n    expect(Object.keys(selectedProjectsGraph)).toStrictEqual([pkg2Dir])\n  }\n  {\n    const { selectedProjectsGraph } = await filterWorkspacePackages(pkgsGraph, [{\n      diff: 'HEAD~1',\n      namePattern: 'package-2*',\n    }], { workspaceDir })\n\n    expect(Object.keys(selectedProjectsGraph)).toStrictEqual([pkg2Dir])\n  }\n  {\n    const { selectedProjectsGraph } = await filterWorkspacePackages(pkgsGraph, [{\n      diff: 'HEAD~1',\n      includeDependents: true,\n    }], { workspaceDir, testPattern: ['*/file2.js'] })\n\n    expect(Object.keys(selectedProjectsGraph)).toStrictEqual([pkg1Dir, pkg2Dir])\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"selection should fail when diffing to a branch that does not exist","suites":[],"updatePoint":{"line":460,"column":72},"line":460,"code":"test('selection should fail when diffing to a branch that does not exist', async () => {\n  let err!: PnpmError\n  try {\n    await filterWorkspacePackages(PKGS_GRAPH, [{ diff: 'branch-does-no-exist' }], { workspaceDir: process.cwd() })\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err).toBeDefined()\n  expect(err.code).toEqual('ERR_PNPM_FILTER_CHANGED')\n  expect(err.message).toEqual(\"Filtering by changed packages failed. fatal: bad revision 'branch-does-no-exist'\")\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"should return unmatched filters","suites":[],"updatePoint":{"line":472,"column":37},"line":472,"code":"test('should return unmatched filters', async () => {\n  const { unmatchedFilters } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: true,\n      includeDependencies: true,\n      namePattern: 'project-7',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(unmatchedFilters).toStrictEqual(['project-7'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select all packages except one","suites":[],"updatePoint":{"line":484,"column":36},"line":484,"code":"test('select all packages except one', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      exclude: true,\n      excludeSelf: false,\n      includeDependencies: false,\n      namePattern: 'project-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph))\n    .toStrictEqual(Object.keys(omit(['/packages/project-1'], PKGS_GRAPH)))\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir and exclude one package by pattern","suites":[],"updatePoint":{"line":498,"column":60},"line":498,"code":"test('select by parentDir and exclude one package by pattern', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/packages',\n    },\n    {\n      exclude: true,\n      excludeSelf: false,\n      includeDependents: false,\n      namePattern: '*-1',\n    },\n  ], { workspaceDir: process.cwd() })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-0'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"select by parentDir with glob and exclude one package by pattern","suites":[],"updatePoint":{"line":515,"column":70},"line":515,"code":"test('select by parentDir with glob and exclude one package by pattern', async () => {\n  const { selectedProjectsGraph } = await filterWorkspacePackages(PKGS_GRAPH, [\n    {\n      excludeSelf: false,\n      parentDir: '/packages/*',\n    },\n    {\n      exclude: true,\n      excludeSelf: false,\n      includeDependents: false,\n      namePattern: '*-1',\n    },\n  ], { workspaceDir: process.cwd(), useGlobDirFiltering: true })\n\n  expect(Object.keys(selectedProjectsGraph)).toStrictEqual(['/packages/project-0'])\n})","file":"index.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"parsePackageSelector()","suites":[],"updatePoint":{"line":196,"column":28},"line":196,"code":"test('parsePackageSelector()', () => {\n  for (const fixture of fixtures) {\n    expect(\n      parsePackageSelector(fixture[0], process.cwd())).toStrictEqual(fixture[1])\n  }\n  if (isWindows()) {\n    expect(\n      parsePackageSelector('.\\\\foo', process.cwd())).toStrictEqual(\n      { exclude: false, excludeSelf: false, parentDir: path.resolve('foo') }\n    )\n    expect(\n      parsePackageSelector('..\\\\foo', process.cwd())).toStrictEqual(\n      { exclude: false, excludeSelf: false, parentDir: path.resolve('../foo') }\n    )\n  }\n})","file":"parsePackageSelector.ts","skipped":false,"dir":"packages/filter-workspace-packages/test"},{"name":"finds package","suites":[],"updatePoint":{"line":7,"column":19},"line":7,"code":"test('finds package', async () => {\n  const root = path.join(fixtures, 'one-pkg')\n  const pkgs = await findPackages(root)\n\n  expect(pkgs).toHaveLength(1)\n  expect(pkgs[0].dir).toBeDefined()\n  expect(pkgs[0].manifest).toBeDefined()\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"finds packages by patterns","suites":[],"updatePoint":{"line":16,"column":32},"line":16,"code":"test('finds packages by patterns', async () => {\n  const root = path.join(fixtures, 'many-pkgs')\n  const pkgs = await findPackages(root, { patterns: ['components/**'] })\n\n  expect(pkgs).toHaveLength(2)\n  expect(pkgs[0].dir).toBeDefined()\n  expect(pkgs[0].manifest).toBeDefined()\n  expect(pkgs[1].dir).toBeDefined()\n  expect(pkgs[1].manifest).toBeDefined()\n  expect([pkgs[0].manifest.name, pkgs[1].manifest.name].sort()).toStrictEqual(['component-1', 'component-2'])\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"finds packages by * pattern","suites":[],"updatePoint":{"line":28,"column":33},"line":28,"code":"test('finds packages by * pattern', async () => {\n  const root = path.join(fixtures, 'many-pkgs-2')\n  const pkgs = await findPackages(root, { patterns: ['.', 'components/*'] })\n\n  expect(pkgs).toHaveLength(3)\n  expect([pkgs[0].manifest.name, pkgs[1].manifest.name, pkgs[2].manifest.name].sort()).toStrictEqual(['component-1', 'component-2', 'many-pkgs-2'])\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"finds packages by default pattern","suites":[],"updatePoint":{"line":36,"column":39},"line":36,"code":"test('finds packages by default pattern', async () => {\n  const root = path.join(fixtures, 'many-pkgs-2')\n  const pkgs = await findPackages(root)\n\n  expect(pkgs).toHaveLength(4)\n  expect(pkgs.map(({ manifest }) => manifest.name).sort()).toStrictEqual(['component-1', 'component-2', 'foo', 'many-pkgs-2'])\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"ignore packages by patterns","suites":[],"updatePoint":{"line":44,"column":33},"line":44,"code":"test('ignore packages by patterns', async () => {\n  const root = path.join(fixtures, 'many-pkgs')\n  const pkgs = await findPackages(root, { patterns: ['**', '!libs/**'] })\n\n  expect(pkgs).toHaveLength(2)\n  expect(pkgs[0].dir).toBeDefined()\n  expect(pkgs[0].manifest).toBeDefined()\n  expect(pkgs[1].dir).toBeDefined()\n  expect(pkgs[1].manifest).toBeDefined()\n  expect([pkgs[0].manifest.name, pkgs[1].manifest.name].sort()).toStrictEqual(['component-1', 'component-2'])\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"json and yaml manifests are also found","suites":[],"updatePoint":{"line":56,"column":44},"line":56,"code":"test('json and yaml manifests are also found', async () => {\n  const root = path.join(fixtures, 'many-pkgs-with-different-manifest-types')\n  const pkgs = await findPackages(root)\n\n  expect(pkgs).toHaveLength(3)\n  expect(pkgs[0].dir).toBeDefined()\n  expect(pkgs[0].manifest.name).toEqual('component-1')\n  expect(pkgs[1].dir).toBeDefined()\n  expect(pkgs[1].manifest.name).toEqual('component-2')\n  expect(pkgs[2].dir).toBeDefined()\n  expect(pkgs[2].manifest.name).toEqual('foo')\n})","file":"index.ts","skipped":false,"dir":"packages/find-packages/test"},{"name":"finds actual workspace dir","suites":[],"updatePoint":{"line":8,"column":32},"line":8,"code":"test('finds actual workspace dir', async () => {\n  const workspaceDir = await findWorkspaceDir(process.cwd())\n\n  expect(workspaceDir).toBe(path.resolve(__dirname, '..', '..', '..'))\n})","file":"index.ts","skipped":false,"dir":"packages/find-workspace-dir/test"},{"name":"finds overriden workspace dir","suites":[],"updatePoint":{"line":14,"column":35},"line":14,"code":"test('finds overriden workspace dir', async () => {\n  const oldValue = process.env[NPM_CONFIG_WORKSPACE_DIR_ENV_VAR]\n  process.env[NPM_CONFIG_WORKSPACE_DIR_ENV_VAR] = FAKE_PATH\n  const workspaceDir = await findWorkspaceDir(process.cwd())\n  process.env[NPM_CONFIG_WORKSPACE_DIR_ENV_VAR] = oldValue\n\n  expect(workspaceDir).toBe(FAKE_PATH)\n})","file":"index.ts","skipped":false,"dir":"packages/find-workspace-dir/test"},{"name":"arrayOfWorkspacePackagesToMap() treats private packages with no version as packages with 0.0.0 version","suites":[],"updatePoint":{"line":6,"column":108},"line":6,"code":"test('arrayOfWorkspacePackagesToMap() treats private packages with no version as packages with 0.0.0 version', () => {\n  const privateProject = {\n    manifest: {\n      name: 'private-pkg',\n    },\n  }\n  expect(arrayOfWorkspacePackagesToMap([privateProject])).toStrictEqual({\n    'private-pkg': {\n      '0.0.0': privateProject,\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/find-workspace-packages/test"},{"name":"findWorkspacePackagesNoCheck() skips engine checks","suites":[],"updatePoint":{"line":19,"column":56},"line":19,"code":"test('findWorkspacePackagesNoCheck() skips engine checks', async () => {\n  const pkgs = await findWorkspacePackagesNoCheck(path.join(__dirname, '__fixtures__/bad-engine'))\n  expect(pkgs.length).toBe(1)\n  expect(pkgs[0].manifest.name).toBe('pkg')\n})","file":"index.ts","skipped":false,"dir":"packages/find-workspace-packages/test"},{"name":"fetch","suites":[],"updatePoint":{"line":23,"column":11},"line":23,"code":"test('fetch', async () => {\n  const cafsDir = tempy.directory()\n  const fetch = createFetcher().git\n  const manifest = pDefer<DependencyManifest>()\n  const { filesIndex } = await fetch(\n    createCafsStore(cafsDir),\n    {\n      commit: 'c9b30e71d704cd30fa71f2edd1ecc7dcc4985493',\n      repo: 'https://github.com/kevva/is-positive.git',\n      type: 'git',\n    },\n    {\n      manifest,\n    }\n  )\n  expect(filesIndex['package.json']).toBeTruthy()\n  expect(filesIndex['package.json'].writeResult).toBeTruthy()\n  const name = (await manifest.promise).name\n  expect(name).toEqual('is-positive')\n})","file":"index.ts","skipped":false,"dir":"packages/git-fetcher/test"},{"name":"fetch a package from Git that has a prepare script","suites":[],"updatePoint":{"line":44,"column":56},"line":44,"code":"test('fetch a package from Git that has a prepare script', async () => {\n  const cafsDir = tempy.directory()\n  const fetch = createFetcher().git\n  const manifest = pDefer<DependencyManifest>()\n  const { filesIndex } = await fetch(\n    createCafsStore(cafsDir),\n    {\n      commit: 'd2916cab494f6cddc85c921ffa3befb600e00e0e',\n      repo: 'https://github.com/pnpm/test-git-fetch.git',\n      type: 'git',\n    },\n    {\n      manifest,\n    }\n  )\n  expect(filesIndex[`dist${path.sep}index.js`]).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/git-fetcher/test"},{"name":"fetch a package without a package.json","suites":[],"updatePoint":{"line":63,"column":44},"line":63,"code":"test('fetch a package without a package.json', async () => {\n  const cafsDir = tempy.directory()\n  const fetch = createFetcher().git\n  const manifest = pDefer<DependencyManifest>()\n  const { filesIndex } = await fetch(\n    createCafsStore(cafsDir),\n    {\n      // a small Deno library with a 'denolib.json' instead of a 'package.json'\n      commit: 'aeb6b15f9c9957c8fa56f9731e914c4d8a6d2f2b',\n      repo: 'https://github.com/denolib/camelcase.git',\n      type: 'git',\n    },\n    {\n      manifest,\n    }\n  )\n  expect(filesIndex['denolib.json']).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/git-fetcher/test"},{"name":"fetch a big repository","suites":[],"updatePoint":{"line":83,"column":28},"line":83,"code":"test('fetch a big repository', async () => {\n  const cafsDir = tempy.directory()\n  const fetch = createFetcher().git\n  const manifest = pDefer<DependencyManifest>()\n  const { filesIndex } = await fetch(createCafsStore(cafsDir),\n    {\n      commit: 'a65fbf5a90f53c9d72fed4daaca59da50f074355',\n      repo: 'https://github.com/sveltejs/action-deploy-docs.git',\n      type: 'git',\n    }, { manifest })\n  await Promise.all(Object.values(filesIndex).map(({ writeResult }) => writeResult))\n})","file":"index.ts","skipped":false,"dir":"packages/git-fetcher/test"},{"name":"still able to shallow fetch for allowed hosts","suites":[],"updatePoint":{"line":96,"column":51},"line":96,"code":"test('still able to shallow fetch for allowed hosts', async () => {\n  const cafsDir = tempy.directory()\n  const fetch = createFetcher({ gitShallowHosts: ['github.com'] }).git\n  const manifest = pDefer<DependencyManifest>()\n  const resolution = {\n    commit: 'c9b30e71d704cd30fa71f2edd1ecc7dcc4985493',\n    repo: 'https://github.com/kevva/is-positive.git',\n    type: 'git' as const,\n  }\n  const { filesIndex } = await fetch(createCafsStore(cafsDir), resolution, {\n    manifest,\n  })\n  const calls = (execa as jest.Mock).mock.calls\n  const expectedCalls = [\n    ['git', [...prefixGitArgs(), 'init']],\n    ['git', [...prefixGitArgs(), 'remote', 'add', 'origin', resolution.repo]],\n    [\n      'git',\n      [...prefixGitArgs(), 'fetch', '--depth', '1', 'origin', resolution.commit],\n    ],\n  ]\n  for (let i = 1; i < expectedCalls.length; i++) {\n    // Discard final argument as it passes temporary directory\n    expect(calls[i].slice(0, -1)).toEqual(expectedCalls[i])\n  }\n  expect(filesIndex['package.json']).toBeTruthy()\n  expect(filesIndex['package.json'].writeResult).toBeTruthy()\n  const name = (await manifest.promise).name\n  expect(name).toEqual('is-positive')\n})","file":"index.ts","skipped":false,"dir":"packages/git-fetcher/test"},{"name":"the right colon is escaped in %s","suites":[],"line":3,"code":"test.each([\n  ['ssh://username:password@example.com:repo.git', 'ssh://username:password@example.com/repo.git'],\n  ['ssh://username:password@example.com:repo/@foo.git', 'ssh://username:password@example.com/repo/@foo.git'],\n  ['ssh://username:password@example.com:22/repo/@foo.git', 'ssh://username:password@example.com:22/repo/@foo.git'],\n  ['ssh://username:password@example.com:22repo/@foo.git', 'ssh://username:password@example.com/22repo/@foo.git'],\n  ['git+ssh://username:password@example.com:repo.git', 'ssh://username:password@example.com/repo.git'],\n  ['git+ssh://username:password@example.com:repo/@foo.git', 'ssh://username:password@example.com/repo/@foo.git'],\n  ['git+ssh://username:password@example.com:22/repo/@foo.git', 'ssh://username:password@example.com:22/repo/@foo.git'],\n])('the right colon is escaped in %s', async (input, output) => {\n  const parsed = await parsePref(input)\n  expect(parsed?.fetchSpec).toBe(output)\n})","file":"parsePref.test.ts","skipped":false,"dir":"packages/git-resolver/test"},{"name":"installing a simple project","suites":[],"updatePoint":{"line":29,"column":33},"line":29,"code":"test('installing a simple project', async () => {\n  const prefix = f.prepare('simple')\n  const reporter = sinon.spy()\n\n  await headless(await testDefaults({\n    lockfileDir: prefix,\n    reporter,\n  }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('is-positive')).toBeTruthy()\n  expect(project.requireModule('rimraf')).toBeTruthy()\n  expect(project.requireModule('is-negative')).toBeTruthy()\n  expect(project.requireModule('colors')).toBeTruthy()\n\n  await project.has('.pnpm/colors@1.2.0')\n\n  await project.isExecutable('.bin/rimraf')\n\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:package-manifest',\n    updated: await loadJsonFile(path.join(prefix, 'package.json')),\n  } as PackageManifestLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    added: 15,\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n  } as StatsLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n    removed: 0,\n  } as StatsLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:stage',\n    prefix,\n    stage: 'importing_done',\n  } as StageLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/is-negative/2.1.0`,\n    requester: prefix,\n    status: 'resolved',\n  })).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing only prod deps","suites":[],"updatePoint":{"line":82,"column":31},"line":82,"code":"test('installing only prod deps', async () => {\n  const prefix = f.prepare('simple')\n\n  await headless(await testDefaults({\n    include: {\n      dependencies: true,\n      devDependencies: false,\n      optionalDependencies: false,\n    },\n    lockfileDir: prefix,\n  }))\n\n  const project = assertProject(prefix)\n  await project.has('is-positive')\n  await project.has('rimraf')\n  await project.hasNot('is-negative')\n  await project.hasNot('colors')\n\n  await project.isExecutable('.bin/rimraf')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing only dev deps","suites":[],"updatePoint":{"line":103,"column":30},"line":103,"code":"test('installing only dev deps', async () => {\n  const prefix = f.prepare('simple')\n\n  await headless(await testDefaults({\n    include: {\n      dependencies: false,\n      devDependencies: true,\n      optionalDependencies: false,\n    },\n    lockfileDir: prefix,\n  }))\n\n  const project = assertProject(prefix)\n  await project.hasNot('is-positive')\n  await project.hasNot('rimraf')\n  await project.has('is-negative')\n  await project.hasNot('colors')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with package manifest ignored","suites":[],"updatePoint":{"line":122,"column":46},"line":122,"code":"test('installing with package manifest ignored', async () => {\n  const prefix = f.prepare('ignore-package-manifest')\n  const opt = await testDefaults({\n    projects: [],\n    include: {\n      dependencies: true,\n      devDependencies: true,\n      optionalDependencies: true,\n    },\n    lockfileDir: prefix,\n  })\n\n  await headless({ ...opt, ignorePackageManifest: true })\n\n  const project = assertProject(prefix)\n  const currentLockfile = await project.readCurrentLockfile()\n  expect(currentLockfile.packages).toHaveProperty(['/is-positive/1.0.0'])\n  expect(currentLockfile.packages).toHaveProperty(['/is-negative/2.1.0'])\n  await project.storeHas('is-negative')\n  await project.storeHas('is-positive')\n  await project.hasNot('is-negative')\n  await project.hasNot('is-positive')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing only prod package with package manifest ignored","suites":[],"updatePoint":{"line":146,"column":64},"line":146,"code":"test('installing only prod package with package manifest ignored', async () => {\n  const prefix = f.prepare('ignore-package-manifest')\n  const opt = await testDefaults({\n    projects: [],\n    include: {\n      dependencies: true,\n      devDependencies: false,\n      optionalDependencies: true,\n    },\n    lockfileDir: prefix,\n  })\n\n  await headless({ ...opt, ignorePackageManifest: true })\n\n  const project = assertProject(prefix)\n  const currentLockfile = await project.readCurrentLockfile()\n  expect(currentLockfile.packages).not.toHaveProperty(['/is-negative/2.1.0'])\n  expect(currentLockfile.packages).toHaveProperty(['/is-positive/1.0.0'])\n  await project.storeHasNot('is-negative')\n  await project.storeHas('is-positive')\n  await project.hasNot('is-negative')\n  await project.hasNot('is-positive')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing only dev package with package manifest ignored","suites":[],"updatePoint":{"line":170,"column":63},"line":170,"code":"test('installing only dev package with package manifest ignored', async () => {\n  const prefix = f.prepare('ignore-package-manifest')\n  const opt = await testDefaults({\n    projects: [],\n    include: {\n      dependencies: false,\n      devDependencies: true,\n      optionalDependencies: false,\n    },\n    lockfileDir: prefix,\n  })\n\n  await headless({ ...opt, ignorePackageManifest: true })\n\n  const project = assertProject(prefix)\n  const currentLockfile = await project.readCurrentLockfile()\n  expect(currentLockfile.packages).toHaveProperty(['/is-negative/2.1.0'])\n  expect(currentLockfile.packages).not.toHaveProperty(['/is-positive/1.0.0'])\n  await project.storeHasNot('is-negative')\n  await project.storeHas('is-positive')\n  await project.hasNot('is-negative')\n  await project.hasNot('is-positive')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing non-prod deps then all deps","suites":[],"updatePoint":{"line":194,"column":44},"line":194,"code":"test('installing non-prod deps then all deps', async () => {\n  const prefix = f.prepare('prod-dep-is-dev-subdep')\n\n  await headless(await testDefaults({\n    include: {\n      dependencies: false,\n      devDependencies: true,\n      optionalDependencies: true,\n    },\n    lockfileDir: prefix,\n  }))\n\n  const project = assertProject(prefix)\n  const inflight = project.requireModule('inflight')\n  expect(typeof inflight).toBe('function')\n\n  await project.hasNot('once')\n\n  {\n    const lockfile = await project.readLockfile()\n    expect(lockfile.packages['/is-positive/1.0.0'].dev === false).toBeTruthy()\n  }\n\n  {\n    const currentLockfile = await project.readCurrentLockfile()\n    expect(currentLockfile.packages).not.toHaveProperty(['/is-positive/1.0.0'])\n  }\n\n  const reporter = sinon.spy()\n\n  // Repeat normal installation adds missing deps to node_modules\n  await headless(await testDefaults({\n    include: {\n      dependencies: true,\n      devDependencies: true,\n      optionalDependencies: true,\n    },\n    lockfileDir: prefix,\n    reporter,\n  }))\n\n  expect(reporter.calledWithMatch({\n    added: {\n      dependencyType: 'prod',\n      name: 'once',\n      realName: 'once',\n    },\n    level: 'debug',\n    name: 'pnpm:root',\n  } as RootLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    added: {\n      dependencyType: 'dev',\n      name: 'inflight',\n      realName: 'inflight',\n    },\n    level: 'debug',\n    name: 'pnpm:root',\n  } as RootLog)).toBeFalsy()\n\n  await project.has('once')\n\n  {\n    const currentLockfile = await project.readCurrentLockfile()\n    expect(currentLockfile.packages).toHaveProperty(['/is-positive/1.0.0'])\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing only optional deps","suites":[],"updatePoint":{"line":262,"column":35},"line":262,"code":"test('installing only optional deps', async () => {\n  const prefix = f.prepare('simple')\n\n  await headless(await testDefaults({\n    development: false,\n    include: {\n      dependencies: false,\n      devDependencies: false,\n      optionalDependencies: true,\n    },\n    lockfileDir: prefix,\n    optional: true,\n    production: false,\n  }))\n\n  const project = assertProject(prefix)\n  await project.hasNot('is-positive')\n  await project.hasNot('rimraf')\n  await project.hasNot('is-negative')\n  await project.has('colors')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"not installing optional deps","suites":[],"updatePoint":{"line":285,"column":34},"line":285,"code":"test('not installing optional deps', async () => {\n  const prefix = f.prepare('simple-with-optional-dep')\n\n  await headless(await testDefaults({\n    include: {\n      dependencies: true,\n      devDependencies: true,\n      optionalDependencies: false,\n    },\n    lockfileDir: prefix,\n  }))\n\n  const project = assertProject(prefix)\n  await project.hasNot('is-positive')\n  await project.has('pkg-with-good-optional')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"skipping optional dependency if it cannot be fetched","suites":[],"updatePoint":{"line":302,"column":58},"line":302,"code":"test('skipping optional dependency if it cannot be fetched', async () => {\n  const prefix = f.prepare('has-nonexistent-optional-dep')\n  const reporter = sinon.spy()\n\n  await headless(await testDefaults({\n    lockfileDir: prefix,\n    reporter,\n  }, {\n    retry: {\n      retries: 0,\n    },\n  }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('is-positive')).toBeTruthy()\n  expect(project.requireModule('rimraf')).toBeTruthy()\n  expect(project.requireModule('is-negative')).toBeTruthy()\n\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"run pre/postinstall scripts","suites":[],"updatePoint":{"line":324,"column":33},"line":324,"code":"test('run pre/postinstall scripts', async () => {\n  let prefix = f.prepare('deps-have-lifecycle-scripts')\n\n  await headless(await testDefaults({ lockfileDir: prefix }))\n\n  const project = assertProject(prefix)\n  const generatedByPreinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-preinstall')\n  expect(typeof generatedByPreinstall).toBe('function')\n\n  const generatedByPostinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-postinstall')\n  expect(typeof generatedByPostinstall).toBe('function')\n\n  expect(require(path.join(prefix, 'output.json'))).toStrictEqual(['install', 'postinstall']) // eslint-disable-line\n\n  prefix = f.prepare('deps-have-lifecycle-scripts')\n\n  await headless(await testDefaults({ lockfileDir: prefix, ignoreScripts: true }))\n\n  expect(await exists(path.join(prefix, 'output.json'))).toBeFalsy()\n\n  const nmPath = path.join(prefix, 'node_modules')\n  const modulesYaml = await readModulesYaml(nmPath)\n  expect(modulesYaml).toBeTruthy()\n  expect(modulesYaml!.pendingBuilds).toStrictEqual(['.', '/pre-and-postinstall-scripts-example/1.0.0'])\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"orphan packages are removed","suites":[],"updatePoint":{"line":350,"column":33},"line":350,"code":"test('orphan packages are removed', async () => {\n  const projectDir = f.prepare('simple-with-more-deps')\n\n  await headless(await testDefaults({\n    lockfileDir: projectDir,\n  }))\n\n  const simpleDir = f.find('simple')\n  await fs.copyFile(\n    path.join(simpleDir, 'package.json'),\n    path.join(projectDir, 'package.json')\n  )\n  await fs.copyFile(\n    path.join(simpleDir, WANTED_LOCKFILE),\n    path.join(projectDir, WANTED_LOCKFILE)\n  )\n\n  const reporter = sinon.spy()\n  await headless(await testDefaults({\n    lockfileDir: projectDir,\n    reporter,\n  }))\n\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix: projectDir,\n    removed: 1,\n  } as StatsLog)).toBeTruthy()\n\n  const project = assertProject(projectDir)\n  await project.hasNot('resolve-from')\n  await project.has('rimraf')\n  await project.has('is-negative')\n  await project.has('colors')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"available packages are used when node_modules is not clean","suites":[],"updatePoint":{"line":387,"column":64},"line":387,"code":"test('available packages are used when node_modules is not clean', async () => {\n  const projectDir = tempDir()\n\n  const destPackageJsonPath = path.join(projectDir, 'package.json')\n  const destLockfileYamlPath = path.join(projectDir, WANTED_LOCKFILE)\n\n  const hasGlobDir = f.find('has-glob')\n  await fs.copyFile(path.join(hasGlobDir, 'package.json'), destPackageJsonPath)\n  await fs.copyFile(path.join(hasGlobDir, WANTED_LOCKFILE), destLockfileYamlPath)\n\n  await headless(await testDefaults({ lockfileDir: projectDir }))\n\n  const hasGlobAndRimrafDir = f.find('has-glob-and-rimraf')\n  await fs.copyFile(path.join(hasGlobAndRimrafDir, 'package.json'), destPackageJsonPath)\n  await fs.copyFile(path.join(hasGlobAndRimrafDir, WANTED_LOCKFILE), destLockfileYamlPath)\n\n  const reporter = sinon.spy()\n  await headless(await testDefaults({ lockfileDir: projectDir, reporter }))\n\n  const project = assertProject(projectDir)\n  await project.has('rimraf')\n  await project.has('glob')\n\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/balanced-match/1.0.2`,\n    requester: projectDir,\n    status: 'resolved',\n  })).toBeFalsy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/rimraf/2.7.1`,\n    requester: projectDir,\n    status: 'resolved',\n  })).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"available packages are relinked during forced install","suites":[],"updatePoint":{"line":424,"column":59},"line":424,"code":"test('available packages are relinked during forced install', async () => {\n  const projectDir = tempDir()\n\n  const destPackageJsonPath = path.join(projectDir, 'package.json')\n  const destLockfileYamlPath = path.join(projectDir, WANTED_LOCKFILE)\n\n  const hasGlobDir = f.find('has-glob')\n  await fs.copyFile(path.join(hasGlobDir, 'package.json'), destPackageJsonPath)\n  await fs.copyFile(path.join(hasGlobDir, WANTED_LOCKFILE), destLockfileYamlPath)\n\n  await headless(await testDefaults({ lockfileDir: projectDir }))\n\n  const hasGlobAndRimrafDir = f.find('has-glob-and-rimraf')\n  await fs.copyFile(path.join(hasGlobAndRimrafDir, 'package.json'), destPackageJsonPath)\n  await fs.copyFile(path.join(hasGlobAndRimrafDir, WANTED_LOCKFILE), destLockfileYamlPath)\n\n  const reporter = sinon.spy()\n  await headless(await testDefaults({ lockfileDir: projectDir, reporter, force: true }))\n\n  const project = assertProject(projectDir)\n  await project.has('rimraf')\n  await project.has('glob')\n\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/balanced-match/1.0.2`,\n    requester: projectDir,\n    status: 'resolved',\n  })).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/rimraf/2.7.1`,\n    requester: projectDir,\n    status: 'resolved',\n  })).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"fail when  is not up-to-date with package.json","suites":[],"updatePoint":{"line":461,"column":70},"line":461,"code":"test(`fail when ${WANTED_LOCKFILE} is not up-to-date with package.json`, async () => {\n  const projectDir = tempDir()\n\n  const simpleDir = f.find('simple')\n  await fs.copyFile(path.join(simpleDir, 'package.json'), path.join(projectDir, 'package.json'))\n\n  const simpleWithMoreDepsDir = f.find('simple-with-more-deps')\n  await fs.copyFile(path.join(simpleWithMoreDepsDir, WANTED_LOCKFILE), path.join(projectDir, WANTED_LOCKFILE))\n\n  try {\n    await headless(await testDefaults({ lockfileDir: projectDir }))\n    throw new Error()\n  } catch (err: any) { // eslint-disable-line\n    expect(err.message).toBe(`Cannot install with \"frozen-lockfile\" because ${WANTED_LOCKFILE} is not up-to-date with package.json`)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing local dependency","suites":[],"updatePoint":{"line":478,"column":33},"line":478,"code":"test('installing local dependency', async () => {\n  let prefix = f.prepare('has-local-dep')\n  prefix = path.join(prefix, 'pkg')\n  const reporter = sinon.spy()\n\n  await headless(await testDefaults({ lockfileDir: prefix, reporter }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('tar-pkg'))\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing local directory dependency","suites":[],"updatePoint":{"line":489,"column":43},"line":489,"code":"test('installing local directory dependency', async () => {\n  const prefix = f.prepare('has-local-dir-dep')\n  const reporter = sinon.spy()\n\n  await headless(await testDefaults({ lockfileDir: prefix, reporter }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('example/package.json')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing using passed in lockfile files","suites":[],"updatePoint":{"line":499,"column":47},"line":499,"code":"test('installing using passed in lockfile files', async () => {\n  const prefix = tempDir()\n\n  const simplePkgPath = f.find('simple')\n  await fs.copyFile(path.join(simplePkgPath, 'package.json'), path.join(prefix, 'package.json'))\n  await fs.copyFile(path.join(simplePkgPath, WANTED_LOCKFILE), path.join(prefix, WANTED_LOCKFILE))\n\n  const wantedLockfile = await readWantedLockfile(simplePkgPath, { ignoreIncompatible: false })\n\n  await headless(await testDefaults({\n    lockfileDir: prefix,\n    wantedLockfile,\n  }))\n\n  const project = assertProject(prefix)\n\n  expect(project.requireModule('is-positive')).toBeTruthy()\n  expect(project.requireModule('rimraf')).toBeTruthy()\n  expect(project.requireModule('is-negative')).toBeTruthy()\n  expect(project.requireModule('colors')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installation of a dependency that has a resolved peer in subdeps","suites":[],"updatePoint":{"line":521,"column":70},"line":521,"code":"test('installation of a dependency that has a resolved peer in subdeps', async () => {\n  const prefix = f.prepare('resolved-peer-deps-in-subdeps')\n\n  await headless(await testDefaults({ lockfileDir: prefix }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('pnpm-default-reporter')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with hoistPattern=*","suites":[],"updatePoint":{"line":530,"column":36},"line":530,"code":"test('installing with hoistPattern=*', async () => {\n  const prefix = f.prepare('simple-shamefully-flatten')\n  const reporter = jest.fn()\n\n  await headless(await testDefaults({ lockfileDir: prefix, reporter, hoistPattern: '*' }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('is-positive')).toBeTruthy()\n  expect(project.requireModule('rimraf')).toBeTruthy()\n  expect(project.requireModule('.pnpm/node_modules/glob')).toBeTruthy()\n  expect(project.requireModule('is-negative')).toBeTruthy()\n  expect(project.requireModule('colors')).toBeTruthy()\n\n  await project.has('.pnpm/colors@1.2.0')\n\n  await project.isExecutable('.bin/rimraf')\n  await project.isExecutable('.pnpm/node_modules/.bin/hello-world-js-bin')\n\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    level: 'debug',\n    name: 'pnpm:package-manifest',\n    updated: expect.objectContaining({\n      name: 'simple-shamefully-flatten',\n      version: '1.0.0',\n    }),\n  } as PackageManifestLog))\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    added: 17,\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n  } as StatsLog))\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n    removed: 0,\n  } as StatsLog))\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    level: 'debug',\n    name: 'pnpm:stage',\n    prefix,\n    stage: 'importing_done',\n  } as StageLog))\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/is-negative/2.1.0`,\n    requester: prefix,\n    status: 'resolved',\n  }))\n\n  const modules = await project.readModulesManifest()\n\n  expect(modules!.hoistedDependencies['/balanced-match/1.0.2']).toStrictEqual({ 'balanced-match': 'private' })\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with publicHoistPattern=*","suites":[],"updatePoint":{"line":589,"column":42},"line":589,"code":"test('installing with publicHoistPattern=*', async () => {\n  const prefix = f.prepare('simple-shamefully-flatten')\n  const reporter = sinon.spy()\n\n  await headless(await testDefaults({ lockfileDir: prefix, reporter, publicHoistPattern: '*' }))\n\n  const project = assertProject(prefix)\n  expect(project.requireModule('is-positive')).toBeTruthy()\n  expect(project.requireModule('rimraf')).toBeTruthy()\n  expect(project.requireModule('glob')).toBeTruthy()\n  expect(project.requireModule('is-negative')).toBeTruthy()\n  expect(project.requireModule('colors')).toBeTruthy()\n\n  await project.has('.pnpm/colors@1.2.0')\n\n  await project.isExecutable('.bin/rimraf')\n  await project.isExecutable('.bin/hello-world-js-bin')\n\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:package-manifest',\n    updated: await loadJsonFile(path.join(prefix, 'package.json')),\n  } as PackageManifestLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    added: 17,\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n  } as StatsLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:stats',\n    prefix,\n    removed: 0,\n  } as StatsLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    name: 'pnpm:stage',\n    prefix,\n    stage: 'importing_done',\n  } as StageLog)).toBeTruthy()\n  expect(reporter.calledWithMatch({\n    level: 'debug',\n    packageId: `localhost+${REGISTRY_MOCK_PORT}/is-negative/2.1.0`,\n    requester: prefix,\n    status: 'resolved',\n  })).toBeTruthy()\n\n  const modules = await project.readModulesManifest()\n\n  expect(modules!.hoistedDependencies['/balanced-match/1.0.2']).toStrictEqual({ 'balanced-match': 'public' })\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with publicHoistPattern=* in a project with external lockfile","suites":[],"updatePoint":{"line":645,"column":78},"line":645,"code":"test('installing with publicHoistPattern=* in a project with external lockfile', async () => {\n  const lockfileDir = f.prepare('pkg-with-external-lockfile')\n  const prefix = path.join(lockfileDir, 'pkg')\n\n  let { projects } = await readprojectsContext(\n    [\n      {\n        rootDir: prefix,\n      },\n    ],\n    { lockfileDir }\n  )\n\n  projects = await Promise.all(\n    projects.map(async (project) => ({ ...project, manifest: await readPackageJsonFromDir(project.rootDir) }))\n  )\n\n  await headless(await testDefaults({\n    lockfileDir,\n    projects,\n    publicHoistPattern: '*',\n  }))\n\n  const project = assertProject(lockfileDir)\n  expect(project.requireModule('accepts')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"using side effects cache with nodeLinker=%s","suites":[],"line":674,"code":"test.each([['isolated'], ['hoisted']])('using side effects cache with nodeLinker=%s', async (nodeLinker) => {\n  let prefix = f.prepare('side-effects')\n\n  // Right now, hardlink does not work with side effects, so we specify copy as the packageImportMethod\n  // We disable verifyStoreIntegrity because we are going to change the cache\n  const opts = await testDefaults({\n    lockfileDir: prefix,\n    nodeLinker,\n    sideEffectsCacheRead: true,\n    sideEffectsCacheWrite: true,\n    verifyStoreIntegrity: false,\n  }, {}, {}, { packageImportMethod: 'copy' })\n  await headless(opts)\n\n  const cacheIntegrityPath = path.join(opts.storeDir, 'files/2e/28a020ed7c488057d208cd705442e275352fcf88a32b32d0d312668308cb87db3a6df9171ce90d501c3de162b2a6dd5cf62ed7ae8c76532f95adfac924b9a8-index.json')\n  const cacheIntegrity = await loadJsonFile(cacheIntegrityPath)\n  expect(cacheIntegrity!['sideEffects']).toBeTruthy()\n  const sideEffectsKey = `${ENGINE_NAME}-${JSON.stringify({ '/hello-world-js-bin/1.0.0': {} })}`\n  expect(cacheIntegrity).toHaveProperty(['sideEffects', sideEffectsKey, 'generated-by-postinstall.js'])\n  delete cacheIntegrity!['sideEffects'][sideEffectsKey]['generated-by-postinstall.js']\n\n  expect(cacheIntegrity).toHaveProperty(['sideEffects', sideEffectsKey, 'generated-by-preinstall.js'])\n  await writeJsonFile(cacheIntegrityPath, cacheIntegrity)\n\n  prefix = f.prepare('side-effects')\n  const opts2 = await testDefaults({\n    lockfileDir: prefix,\n    nodeLinker,\n    sideEffectsCacheRead: true,\n    sideEffectsCacheWrite: true,\n    storeDir: opts.storeDir,\n    verifyStoreIntegrity: false,\n  }, {}, {}, { packageImportMethod: 'copy' })\n  await headless(opts2)\n\n  expect(await exists(path.join(prefix, 'node_modules/pre-and-postinstall-scripts-example/generated-by-postinstall.js'))).toBeFalsy()\n  expect(await exists(path.join(prefix, 'node_modules/pre-and-postinstall-scripts-example/generated-by-preinstall.js'))).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"using side effects cache and hoistPattern=*","suites":[],"line":713,"code":"test.skip('using side effects cache and hoistPattern=*', async () => {","file":"index.ts","skipped":true,"dir":"packages/headless/test"},{"name":"installing in a workspace","suites":[],"updatePoint":{"line":753,"column":31},"line":753,"code":"test('installing in a workspace', async () => {\n  const workspaceFixture = f.prepare('workspace')\n\n  let { projects } = await readprojectsContext(\n    [\n      {\n        rootDir: path.join(workspaceFixture, 'foo'),\n      },\n      {\n        rootDir: path.join(workspaceFixture, 'bar'),\n      },\n    ],\n    { lockfileDir: workspaceFixture }\n  )\n\n  projects = await Promise.all(\n    projects.map(async (project) => ({ ...project, manifest: await readPackageJsonFromDir(project.rootDir) }))\n  )\n\n  await headless(await testDefaults({\n    lockfileDir: workspaceFixture,\n    projects,\n  }))\n\n  const projectBar = assertProject(path.join(workspaceFixture, 'bar'))\n\n  await projectBar.has('foo')\n\n  await headless(await testDefaults({\n    lockfileDir: workspaceFixture,\n    projects: [projects[0]],\n  }))\n\n  const rootModules = assertProject(workspaceFixture)\n  const lockfile = await rootModules.readCurrentLockfile()\n  expect(Object.keys(lockfile.packages)).toStrictEqual([\n    '/is-negative/1.0.0',\n    '/is-positive/1.0.0',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with no symlinks but with PnP","suites":[],"updatePoint":{"line":794,"column":46},"line":794,"code":"test('installing with no symlinks but with PnP', async () => {\n  const prefix = f.prepare('simple')\n\n  await headless(await testDefaults({\n    enablePnp: true,\n    lockfileDir: prefix,\n    symlink: false,\n  }))\n\n  expect([...await fs.readdir(path.join(prefix, 'node_modules'))]).toStrictEqual(['.bin', '.modules.yaml', '.pnpm'])\n  expect([...await fs.readdir(path.join(prefix, 'node_modules/.pnpm/rimraf@2.7.1/node_modules'))]).toStrictEqual(['rimraf'])\n\n  const project = assertProject(prefix)\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n  expect(await exists(path.join(prefix, '.pnp.cjs'))).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with no modules directory","suites":[],"updatePoint":{"line":812,"column":42},"line":812,"code":"test('installing with no modules directory', async () => {\n  const prefix = f.prepare('simple')\n\n  await headless(await testDefaults({\n    enableModulesDir: false,\n    lockfileDir: prefix,\n  }))\n\n  expect(await exists(path.join(prefix, 'node_modules'))).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing with node-linker=hoisted","suites":[],"updatePoint":{"line":823,"column":41},"line":823,"code":"test('installing with node-linker=hoisted', async () => {\n  const prefix = f.prepare('has-several-versions-of-same-pkg')\n\n  await headless(await testDefaults({\n    enableModulesDir: false,\n    lockfileDir: prefix,\n    nodeLinker: 'hoisted',\n  }))\n\n  expect(realpathSync('node_modules/ms')).toBe(path.resolve('node_modules/ms'))\n  expect(realpathSync('node_modules/send')).toBe(path.resolve('node_modules/send'))\n  expect(existsSync('node_modules/send/node_modules/ms')).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"installing in a workspace with node-linker=hoisted","suites":[],"updatePoint":{"line":837,"column":56},"line":837,"code":"test('installing in a workspace with node-linker=hoisted', async () => {\n  const prefix = f.prepare('workspace2')\n\n  let { projects } = await readprojectsContext(\n    [\n      {\n        rootDir: path.join(prefix, 'foo'),\n      },\n      {\n        rootDir: path.join(prefix, 'bar'),\n      },\n    ],\n    { lockfileDir: prefix }\n  )\n\n  projects = await Promise.all(\n    projects.map(async (project) => ({ ...project, manifest: await readPackageJsonFromDir(project.rootDir) }))\n  )\n  await headless(await testDefaults({\n    lockfileDir: prefix,\n    nodeLinker: 'hoisted',\n    projects,\n  }))\n\n  expect(realpathSync('bar/node_modules/foo')).toBe(path.resolve('foo'))\n  expect(readPkgVersion(path.join(prefix, 'foo/node_modules/webpack'))).toBe('2.7.0')\n  expect(realpathSync('foo/node_modules/express')).toBe(path.resolve('foo/node_modules/express'))\n  expect(readPkgVersion(path.join(prefix, 'foo/node_modules/express'))).toBe('4.17.2')\n  expect(readPkgVersion(path.join(prefix, 'node_modules/webpack'))).toBe('5.65.0')\n  expect(readPkgVersion(path.join(prefix, 'node_modules/express'))).toBe('2.5.11')\n})","file":"index.ts","skipped":false,"dir":"packages/headless/test"},{"name":"runLifecycleHook()","suites":[],"updatePoint":{"line":10,"column":24},"line":10,"code":"test('runLifecycleHook()', async () => {\n  const pkgRoot = path.join(fixtures, 'simple')\n  const pkg = await import(path.join(pkgRoot, 'package.json'))\n  await runLifecycleHook('postinstall', pkg, {\n    depPath: '/simple/1.0.0',\n    optional: false,\n    pkgRoot,\n    rawConfig: {},\n    rootModulesDir,\n    unsafePerm: true,\n  })\n\n  expect((await import(path.join(pkgRoot, 'output.json'))).default).toStrictEqual(['install'])\n})","file":"index.ts","skipped":false,"dir":"packages/lifecycle/test"},{"name":"runLifecycleHook() escapes the args passed to the script","suites":[],"updatePoint":{"line":25,"column":62},"line":25,"code":"test('runLifecycleHook() escapes the args passed to the script', async () => {\n  const pkgRoot = path.join(fixtures, 'escape-args')\n  const pkg = await import(path.join(pkgRoot, 'package.json'))\n  await runLifecycleHook('echo', pkg, {\n    depPath: '/escape-args/1.0.0',\n    pkgRoot,\n    rawConfig: {},\n    rootModulesDir,\n    unsafePerm: true,\n    args: ['Revert \"feature (#1)\"'],\n  })\n\n  expect((await import(path.join(pkgRoot, 'output.json'))).default).toStrictEqual(['Revert \"feature (#1)\"'])\n})","file":"index.ts","skipped":false,"dir":"packages/lifecycle/test"},{"name":"runPostinstallHooks()","suites":[],"updatePoint":{"line":40,"column":27},"line":40,"code":"test('runPostinstallHooks()', async () => {\n  const pkgRoot = path.join(fixtures, 'with-many-scripts')\n  await rimraf(path.join(pkgRoot, 'output.json'))\n  await runPostinstallHooks({\n    depPath: '/with-many-scripts/1.0.0',\n    optional: false,\n    pkgRoot,\n    rawConfig: {},\n    rootModulesDir,\n    unsafePerm: true,\n  })\n\n  expect(loadJsonFile.sync(path.join(pkgRoot, 'output.json'))).toStrictEqual(['preinstall', 'install', 'postinstall'])\n})","file":"index.ts","skipped":false,"dir":"packages/lifecycle/test"},{"name":"linkBins()","suites":[],"updatePoint":{"line":50,"column":16},"line":50,"code":"test('linkBins()', async () => {\n  const binTarget = tempy.directory()\n  const warn = jest.fn()\n  const simpleFixture = f.prepare('simple-fixture')\n\n  await linkBins(path.join(simpleFixture, 'node_modules'), binTarget, { warn })\n\n  expect(warn).not.toHaveBeenCalled()\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['simple']))\n  const binLocation = path.join(binTarget, 'simple')\n  expect(await exists(binLocation)).toBe(true)\n  const content = await fs.readFile(binLocation, 'utf8')\n  expect(content).toMatch('node_modules/simple/index.js')\n\n  if (EXECUTABLE_SHEBANG_SUPPORTED) {\n    const binFile = path.join(binTarget, 'simple')\n    const stat = await fs.stat(binFile)\n    expect(stat.mode).toBe(parseInt('100755', 8))\n    expect(stat.isFile()).toBe(true)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() never creates a PowerShell shim for the pnpm CLI","suites":[],"updatePoint":{"line":72,"column":65},"line":72,"code":"test('linkBins() never creates a PowerShell shim for the pnpm CLI', async () => {\n  const binTarget = tempy.directory()\n  const fixture = f.prepare('pnpm-cli')\n  const warn = jest.fn()\n\n  await linkBins(path.join(fixture, 'node_modules'), binTarget, { warn })\n\n  const bins = await fs.readdir(binTarget)\n  expect(bins).toContain('pnpm')\n  expect(bins).not.toContain('pnpm.ps1')\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() finds exotic manifests","suites":[],"updatePoint":{"line":84,"column":39},"line":84,"code":"test('linkBins() finds exotic manifests', async () => {\n  const binTarget = tempy.directory()\n  const exoticManifestFixture = f.prepare('exotic-manifest')\n  const warn = jest.fn()\n\n  await linkBins(path.join(exoticManifestFixture, 'node_modules'), binTarget, {\n    allowExoticManifests: true,\n    warn,\n  })\n\n  expect(warn).not.toHaveBeenCalled()\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['simple']))\n  const binLocation = path.join(binTarget, 'simple')\n  expect(await exists(binLocation)).toBe(true)\n  const content = await fs.readFile(binLocation, 'utf8')\n  expect(content).toMatch('node_modules/simple/index.js')\n\n  if (EXECUTABLE_SHEBANG_SUPPORTED) {\n    const binFile = path.join(binTarget, 'simple')\n    const stat = await fs.stat(binFile)\n    expect(stat.mode).toBe(parseInt('100755', 8))\n    expect(stat.isFile()).toBe(true)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() do not fail on directory w/o manifest file","suites":[],"updatePoint":{"line":109,"column":59},"line":109,"code":"test('linkBins() do not fail on directory w/o manifest file', async () => {\n  const binTarget = tempy.directory()\n  const warn = jest.fn()\n\n  await linkBins(f.find('dir-with-no-manifest/node_modules'), binTarget, {\n    allowExoticManifests: false,\n    warn,\n  })\n\n  expect(warn).not.toHaveBeenCalled()\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() with exotic manifests do not fail on directory w/o manifest file","suites":[],"updatePoint":{"line":121,"column":81},"line":121,"code":"test('linkBins() with exotic manifests do not fail on directory w/o manifest file', async () => {\n  const binTarget = tempy.directory()\n  const warn = jest.fn()\n\n  await linkBins(f.find('dir-with-no-manifest/node_modules'), binTarget, {\n    allowExoticManifests: true,\n    warn,\n  })\n\n  expect(warn).not.toHaveBeenCalled()\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() does not link own bins","suites":[],"updatePoint":{"line":133,"column":39},"line":133,"code":"test('linkBins() does not link own bins', async () => {\n  const target = f.prepare('foobar')\n\n  const warn = jest.fn()\n  const modules = path.join(target, 'node_modules')\n  const binTarget = path.join(target, 'node_modules', 'foo', 'node_modules', '.bin')\n\n  await linkBins(modules, binTarget, { warn })\n\n  expect(warn).not.toHaveBeenCalled()\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['bar']))\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBinsOfPackages()","suites":[],"updatePoint":{"line":146,"column":26},"line":146,"code":"test('linkBinsOfPackages()', async () => {\n  const binTarget = tempy.directory()\n  const simpleFixture = f.prepare('simple-fixture')\n\n  await linkBinsOfPackages(\n    [\n      {\n        location: path.join(simpleFixture, 'node_modules/simple'),\n        manifest: (await import(path.join(simpleFixture, 'node_modules/simple/package.json'))).default,\n      },\n    ],\n    binTarget\n  )\n\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['simple']))\n  const binLocation = path.join(binTarget, 'simple')\n  expect(await exists(binLocation)).toBe(true)\n  const content = await fs.readFile(binLocation, 'utf8')\n  expect(content).toMatch('node_modules/simple/index.js')\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() resolves conflicts. Prefer packages that use their name as bin name","suites":[],"updatePoint":{"line":167,"column":84},"line":167,"code":"test('linkBins() resolves conflicts. Prefer packages that use their name as bin name', async () => {\n  const binTarget = tempy.directory()\n  const binNameConflictsFixture = f.prepare('bin-name-conflicts')\n  const warn = jest.fn()\n\n  await linkBins(path.join(binNameConflictsFixture, 'node_modules'), binTarget, { warn })\n\n  expect(binsConflictLogger.debug).toHaveBeenCalledWith({\n    binaryName: 'bar',\n    binsDir: binTarget,\n    linkedPkgName: 'bar',\n    skippedPkgName: 'foo',\n  })\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['bar', 'foofoo']))\n\n  {\n    const binLocation = path.join(binTarget, 'bar')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/bar/index.js')\n  }\n\n  {\n    const binLocation = path.join(binTarget, 'foofoo')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/foo/index.js')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBinsOfPackages() resolves conflicts. Prefer packages that use their name as bin name","suites":[],"updatePoint":{"line":197,"column":94},"line":197,"code":"test('linkBinsOfPackages() resolves conflicts. Prefer packages that use their name as bin name', async () => {\n  const binTarget = tempy.directory()\n  const binNameConflictsFixture = f.prepare('bin-name-conflicts')\n\n  const modulesPath = path.join(binNameConflictsFixture, 'node_modules')\n\n  await linkBinsOfPackages(\n    [\n      {\n        location: path.join(modulesPath, 'bar'),\n        manifest: (await import(path.join(modulesPath, 'bar', 'package.json'))).default,\n      },\n      {\n        location: path.join(modulesPath, 'foo'),\n        manifest: (await import(path.join(modulesPath, 'foo', 'package.json'))).default,\n      },\n    ],\n    binTarget\n  )\n\n  expect(binsConflictLogger.debug).toHaveBeenCalledWith({\n    binaryName: 'bar',\n    binsDir: binTarget,\n    linkedPkgName: 'bar',\n    skippedPkgName: 'foo',\n  })\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['bar', 'foofoo']))\n\n  {\n    const binLocation = path.join(binTarget, 'bar')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/bar/index.js')\n  }\n\n  {\n    const binLocation = path.join(binTarget, 'foofoo')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/foo/index.js')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() resolves conflicts. Prefer packages are direct dependencies","suites":[],"updatePoint":{"line":240,"column":76},"line":240,"code":"test('linkBins() resolves conflicts. Prefer packages are direct dependencies', async () => {\n  const binTarget = tempy.directory()\n  const binNameConflictsFixture = f.prepare('bin-name-conflicts')\n  const warn = jest.fn()\n\n  await linkBins(path.join(binNameConflictsFixture, 'node_modules'), binTarget, {\n    projectManifest: {\n      dependencies: {\n        foo: '1.0.0',\n      },\n    },\n    warn,\n  })\n\n  expect(warn).not.toHaveBeenCalled() // With(`Cannot link binary 'bar' of 'foo' to '${binTarget}': binary of 'bar' is already linked`, 'BINARIES_CONFLICT')\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['bar', 'foofoo']))\n\n  {\n    const binLocation = path.join(binTarget, 'bar')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/foo/index.js')\n  }\n\n  {\n    const binLocation = path.join(binTarget, 'foofoo')\n    expect(await exists(binLocation)).toBe(true)\n    const content = await fs.readFile(binLocation, 'utf8')\n    expect(content).toMatch('node_modules/foo/index.js')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() would throw error if package has no name field","suites":[],"updatePoint":{"line":272,"column":63},"line":272,"code":"test('linkBins() would throw error if package has no name field', async () => {\n  const binTarget = tempy.directory()\n  const noNameFixture = f.prepare('no-name')\n  const warn = jest.fn()\n\n  try {\n    await linkBins(path.join(noNameFixture, 'node_modules'), binTarget, {\n      allowExoticManifests: true,\n      warn,\n    })\n    fail('linkBins should fail when package has no name')\n  } catch (err: any) { // eslint-disable-line\n    const packagePath = normalizePath(path.join(noNameFixture, 'node_modules/simple'))\n    expect(err.message).toEqual(`Package in ${packagePath} must have a name to get bin linked.`)\n    expect(err.code).toEqual('ERR_PNPM_INVALID_PACKAGE_NAME')\n    expect(warn).not.toHaveBeenCalled()\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() would give warning if package has no bin field","suites":[],"updatePoint":{"line":291,"column":63},"line":291,"code":"test('linkBins() would give warning if package has no bin field', async () => {\n  const binTarget = tempy.directory()\n  const noBinFixture = f.prepare('no-bin')\n  const warn = jest.fn()\n\n  await linkBins(path.join(noBinFixture, 'packages'), binTarget, {\n    allowExoticManifests: true,\n    warn,\n  })\n\n  const packagePath = normalizePath(path.join(noBinFixture, 'packages/simple'))\n  expect(warn).toHaveBeenCalledWith(`Package in ${packagePath} must have a non-empty bin field to get bin linked.`, 'EMPTY_BIN')\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() would not give warning if package has no bin field but inside node_modules","suites":[],"updatePoint":{"line":305,"column":91},"line":305,"code":"test('linkBins() would not give warning if package has no bin field but inside node_modules', async () => {\n  const binTarget = tempy.directory()\n  const noBinFixture = f.prepare('no-bin')\n  const warn = jest.fn()\n\n  await linkBins(path.join(noBinFixture, 'node_modules'), binTarget, {\n    allowExoticManifests: true,\n    warn,\n  })\n\n  expect(warn).not.toHaveBeenCalled()\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() links commands from bin directory with a subdirectory","suites":[],"updatePoint":{"line":318,"column":70},"line":318,"code":"test('linkBins() links commands from bin directory with a subdirectory', async () => {\n  const binTarget = tempy.directory()\n\n  await linkBins(f.find('bin-dir'), binTarget, { warn: () => {} })\n\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['index.js']))\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() fix window shebang line","suites":[],"updatePoint":{"line":326,"column":40},"line":326,"code":"test('linkBins() fix window shebang line', async () => {\n  const binTarget = tempy.directory()\n  const windowShebangFixture = f.prepare('bin-window-shebang')\n  const warn = jest.fn()\n\n  await linkBins(path.join(windowShebangFixture, 'node_modules'), binTarget, { warn })\n\n  expect(warn).not.toHaveBeenCalled()\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins(['crlf', 'lf']))\n\n  const lfBinLoc = path.join(binTarget, 'lf')\n  const crlfBinLoc = path.join(binTarget, 'crlf')\n  for (const binLocation of [lfBinLoc, crlfBinLoc]) {\n    expect(await exists(binLocation)).toBe(true)\n  }\n\n  if (EXECUTABLE_SHEBANG_SUPPORTED) {\n    const lfFilePath = path.join(windowShebangFixture, 'node_modules', 'crlf/bin/lf.js')\n    const crlfFilePath = path.join(windowShebangFixture, 'node_modules', 'crlf/bin/crlf.js')\n\n    for (const filePath of [lfFilePath, crlfFilePath]) {\n      const content = await fs.readFile(filePath, 'utf8')\n      expect(content.startsWith('#!/usr/bin/env node\\n')).toBeTruthy()\n    }\n\n    const lfStat = await fs.stat(lfBinLoc)\n    const crlfStat = await fs.stat(crlfBinLoc)\n    for (const stat of [lfStat, crlfStat]) {\n      expect(stat.mode).toBe(parseInt('100755', 8))\n      expect(stat.isFile()).toBe(true)\n    }\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"linkBins() emits global warning when bin points to path that doesn't exist","suites":[],"updatePoint":{"line":360,"column":80},"line":360,"code":"test(\"linkBins() emits global warning when bin points to path that doesn't exist\", async () => {\n  const binTarget = tempy.directory()\n  const binNotExistFixture = f.prepare('bin-not-exist')\n\n  await linkBins(path.join(binNotExistFixture, 'node_modules'), binTarget, {\n    allowExoticManifests: true,\n    warn: () => {},\n  })\n\n  expect(await fs.readdir(binTarget)).toEqual(getExpectedBins([]))\n  expect(\n    globalWarn\n  ).toHaveBeenCalled()\n})","file":"index.ts","skipped":false,"dir":"packages/link-bins/test"},{"name":"packages searcher","suites":[],"updatePoint":{"line":3,"column":23},"line":3,"code":"test('packages searcher', () => {\n  {\n    const search = createPackagesSearcher(['rimraf@*'])\n    expect(search({ name: 'rimraf', version: '1.0.0' })).toBeTruthy()\n    expect(search({ name: 'express', version: '1.0.0' })).not.toBeTruthy()\n  }\n  {\n    const search = createPackagesSearcher(['rim*'])\n    expect(search({ name: 'rimraf', version: '1.0.0' })).toBeTruthy()\n    expect(search({ name: 'express', version: '1.0.0' })).not.toBeTruthy()\n  }\n  {\n    const search = createPackagesSearcher(['rim*@2'])\n    expect(search({ name: 'rimraf', version: '2.0.0' })).toBeTruthy()\n    expect(search({ name: 'rimraf', version: '1.0.0' })).not.toBeTruthy()\n  }\n  {\n    const search = createPackagesSearcher(['minimatch', 'once@1.4'])\n    expect(search({ name: 'minimatch', version: '2.0.0' })).toBeTruthy()\n    expect(search({ name: 'once', version: '1.4.1' })).toBeTruthy()\n    expect(search({ name: 'rimraf', version: '1.0.0' })).not.toBeTruthy()\n  }\n})","file":"createPackagesSearcher.spec.ts","skipped":false,"dir":"packages/list/test"},{"name":"resolve directory","suites":[],"updatePoint":{"line":6,"column":23},"line":6,"code":"test('resolve directory', async () => {\n  const resolveResult = await resolveFromLocal({ pref: '..' }, { projectDir: __dirname })\n  expect(resolveResult!.id).toEqual('link:..')\n  expect(resolveResult!.normalizedPref).toEqual('link:..')\n  expect(resolveResult!['manifest']!.name).toEqual('@pnpm/local-resolver')\n  expect(resolveResult!.resolution['directory']).toEqual(normalize(path.join(__dirname, '..')))\n  expect(resolveResult!.resolution['type']).toEqual('directory')\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve injected directory","suites":[],"updatePoint":{"line":15,"column":32},"line":15,"code":"test('resolve injected directory', async () => {\n  const resolveResult = await resolveFromLocal({ injected: true, pref: '..' }, { projectDir: __dirname })\n  expect(resolveResult!.id).toEqual('file:..')\n  expect(resolveResult!.normalizedPref).toEqual('file:..')\n  expect(resolveResult!['manifest']!.name).toEqual('@pnpm/local-resolver')\n  expect(resolveResult!.resolution['directory']).toEqual('..')\n  expect(resolveResult!.resolution['type']).toEqual('directory')\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve workspace directory","suites":[],"updatePoint":{"line":24,"column":33},"line":24,"code":"test('resolve workspace directory', async () => {\n  const resolveResult = await resolveFromLocal({ pref: 'workspace:..' }, { projectDir: __dirname })\n  expect(resolveResult!.id).toEqual('link:..')\n  expect(resolveResult!.normalizedPref).toEqual('link:..')\n  expect(resolveResult!['manifest']!.name).toEqual('@pnpm/local-resolver')\n  expect(resolveResult!.resolution['directory']).toEqual(normalize(path.join(__dirname, '..')))\n  expect(resolveResult!.resolution['type']).toEqual('directory')\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve directory specified using the file: protocol","suites":[],"updatePoint":{"line":33,"column":58},"line":33,"code":"test('resolve directory specified using the file: protocol', async () => {\n  const resolveResult = await resolveFromLocal({ pref: 'file:..' }, { projectDir: __dirname })\n  expect(resolveResult!.id).toEqual('file:..')\n  expect(resolveResult!.normalizedPref).toEqual('file:..')\n  expect(resolveResult!['manifest']!.name).toEqual('@pnpm/local-resolver')\n  expect(resolveResult!.resolution['directory']).toEqual('..')\n  expect(resolveResult!.resolution['type']).toEqual('directory')\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve directory specified using the link: protocol","suites":[],"updatePoint":{"line":42,"column":58},"line":42,"code":"test('resolve directory specified using the link: protocol', async () => {\n  const resolveResult = await resolveFromLocal({ pref: 'link:..' }, { projectDir: __dirname })\n  expect(resolveResult!.id).toEqual('link:..')\n  expect(resolveResult!.normalizedPref).toEqual('link:..')\n  expect(resolveResult!['manifest']!.name).toEqual('@pnpm/local-resolver')\n  expect(resolveResult!.resolution['directory']).toEqual(normalize(path.join(__dirname, '..')))\n  expect(resolveResult!.resolution['type']).toEqual('directory')\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve file","suites":[],"updatePoint":{"line":51,"column":18},"line":51,"code":"test('resolve file', async () => {\n  const wantedDependency = { pref: './pnpm-local-resolver-0.1.1.tgz' }\n  const resolveResult = await resolveFromLocal(wantedDependency, { projectDir: __dirname })\n\n  expect(resolveResult).toEqual({\n    id: 'file:pnpm-local-resolver-0.1.1.tgz',\n    normalizedPref: 'file:pnpm-local-resolver-0.1.1.tgz',\n    resolution: {\n      integrity: 'sha512-UHd2zKRT/w70KKzFlj4qcT81A1Q0H7NM9uKxLzIZ/VZqJXzt5Hnnp2PYPb5Ezq/hAamoYKIn5g7fuv69kP258w==',\n      tarball: 'file:pnpm-local-resolver-0.1.1.tgz',\n    },\n    resolvedVia: 'local-filesystem',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve file when lockfile directory differs from the package's dir","suites":[],"updatePoint":{"line":66,"column":73},"line":66,"code":"test(\"resolve file when lockfile directory differs from the package's dir\", async () => {\n  const wantedDependency = { pref: './pnpm-local-resolver-0.1.1.tgz' }\n  const resolveResult = await resolveFromLocal(wantedDependency, {\n    lockfileDir: path.join(__dirname, '..'),\n    projectDir: __dirname,\n  })\n\n  expect(resolveResult).toEqual({\n    id: 'file:test/pnpm-local-resolver-0.1.1.tgz',\n    normalizedPref: 'file:pnpm-local-resolver-0.1.1.tgz',\n    resolution: {\n      integrity: 'sha512-UHd2zKRT/w70KKzFlj4qcT81A1Q0H7NM9uKxLzIZ/VZqJXzt5Hnnp2PYPb5Ezq/hAamoYKIn5g7fuv69kP258w==',\n      tarball: 'file:test/pnpm-local-resolver-0.1.1.tgz',\n    },\n    resolvedVia: 'local-filesystem',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"resolve tarball specified with file: protocol","suites":[],"updatePoint":{"line":84,"column":51},"line":84,"code":"test('resolve tarball specified with file: protocol', async () => {\n  const wantedDependency = { pref: 'file:./pnpm-local-resolver-0.1.1.tgz' }\n  const resolveResult = await resolveFromLocal(wantedDependency, { projectDir: __dirname })\n\n  expect(resolveResult).toEqual({\n    id: 'file:pnpm-local-resolver-0.1.1.tgz',\n    normalizedPref: 'file:pnpm-local-resolver-0.1.1.tgz',\n    resolution: {\n      integrity: 'sha512-UHd2zKRT/w70KKzFlj4qcT81A1Q0H7NM9uKxLzIZ/VZqJXzt5Hnnp2PYPb5Ezq/hAamoYKIn5g7fuv69kP258w==',\n      tarball: 'file:pnpm-local-resolver-0.1.1.tgz',\n    },\n    resolvedVia: 'local-filesystem',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"fail when resolving tarball specified with the link: protocol","suites":[],"updatePoint":{"line":99,"column":67},"line":99,"code":"test('fail when resolving tarball specified with the link: protocol', async () => {\n  try {\n    const wantedDependency = { pref: 'link:./pnpm-local-resolver-0.1.1.tgz' }\n    await resolveFromLocal(wantedDependency, { projectDir: __dirname })\n    fail()\n  } catch (err: any) { // eslint-disable-line\n    expect(err).toBeDefined()\n    expect(err.code).toEqual('ERR_PNPM_NOT_PACKAGE_DIRECTORY')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"fail when resolving from not existing directory an injected dependency","suites":[],"updatePoint":{"line":110,"column":76},"line":110,"code":"test('fail when resolving from not existing directory an injected dependency', async () => {\n  const wantedDependency = { pref: 'file:./dir-does-not-exist' }\n  const projectDir = __dirname\n  await expect(\n    resolveFromLocal(wantedDependency, { projectDir })\n  ).rejects.toThrow(`Could not install from \"${path.join(projectDir, 'dir-does-not-exist')}\" as it does not exist.`)\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"do not fail when resolving from not existing directory","suites":[],"updatePoint":{"line":118,"column":60},"line":118,"code":"test('do not fail when resolving from not existing directory', async () => {\n  const wantedDependency = { pref: 'link:./dir-does-not-exist' }\n  const resolveResult = await resolveFromLocal(wantedDependency, { projectDir: __dirname })\n  expect(resolveResult?.manifest).toStrictEqual({\n    name: 'dir-does-not-exist',\n    version: '0.0.0',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"throw error when the path: protocol is used","suites":[],"updatePoint":{"line":127,"column":49},"line":127,"code":"test('throw error when the path: protocol is used', async () => {\n  try {\n    await resolveFromLocal({ pref: 'path:..' }, { projectDir: __dirname })\n    fail()\n  } catch (err: any) { // eslint-disable-line\n    expect(err).toBeDefined()\n    expect(err.code).toEqual('ERR_PNPM_PATH_IS_UNSUPPORTED_PROTOCOL')\n    expect(err.pref).toEqual('path:..')\n    expect(err.protocol).toEqual('path:')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/local-resolver/test"},{"name":"empty overrides and neverBuiltDependencies are removed during lockfile normalization","suites":[],"updatePoint":{"line":4,"column":90},"line":4,"code":"test('empty overrides and neverBuiltDependencies are removed during lockfile normalization', () => {\n  expect(normalizeLockfile({\n    lockfileVersion: LOCKFILE_VERSION,\n    // but this should be preserved.\n    onlyBuiltDependencies: [],\n    overrides: {},\n    neverBuiltDependencies: [],\n    packages: {},\n    importers: {\n      foo: {\n        dependencies: {\n          bar: 'link:../bar',\n        },\n        specifiers: {\n          bar: 'link:../bar',\n        },\n      },\n    },\n  }, false)).toStrictEqual({\n    lockfileVersion: LOCKFILE_VERSION,\n    onlyBuiltDependencies: [],\n    importers: {\n      foo: {\n        dependencies: {\n          bar: 'link:../bar',\n        },\n        specifiers: {\n          bar: 'link:../bar',\n        },\n      },\n    },\n  })\n})","file":"normalizeLockfile.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"readWantedLockfile()","suites":[],"updatePoint":{"line":13,"column":26},"line":13,"code":"test('readWantedLockfile()', async () => {\n  {\n    const lockfile = await readWantedLockfile(path.join('fixtures', '2'), {\n      ignoreIncompatible: false,\n    })\n    expect(lockfile?.lockfileVersion).toEqual(3)\n    expect(lockfile?.importers).toStrictEqual({\n      '.': {\n        specifiers: {\n          foo: '1',\n        },\n        dependenciesMeta: {\n          foo: { injected: true },\n        },\n      },\n    })\n  }\n\n  try {\n    await readWantedLockfile(path.join('fixtures', '3'), {\n      ignoreIncompatible: false,\n      wantedVersion: 3,\n    })\n    fail()\n  } catch (err: any) { // eslint-disable-line\n    expect(err.code).toEqual('ERR_PNPM_LOCKFILE_BREAKING_CHANGE')\n  }\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"readWantedLockfile() when lockfileVersion is a string","suites":[],"updatePoint":{"line":42,"column":59},"line":42,"code":"test('readWantedLockfile() when lockfileVersion is a string', async () => {\n  {\n    const lockfile = await readWantedLockfile(path.join('fixtures', '4'), {\n      ignoreIncompatible: false,\n      wantedVersion: 3,\n    })\n    expect(lockfile!.lockfileVersion).toEqual('v3')\n  }\n\n  {\n    const lockfile = await readWantedLockfile(path.join('fixtures', '5'), {\n      ignoreIncompatible: false,\n      wantedVersion: 3,\n    })\n    expect(lockfile!.lockfileVersion).toEqual('3')\n  }\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"readCurrentLockfile()","suites":[],"updatePoint":{"line":60,"column":27},"line":60,"code":"test('readCurrentLockfile()', async () => {\n  const lockfile = await readCurrentLockfile('fixtures/2/node_modules/.pnpm', {\n    ignoreIncompatible: false,\n  })\n  expect(lockfile!.lockfileVersion).toEqual(3)\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"writeWantedLockfile()","suites":[],"updatePoint":{"line":67,"column":27},"line":67,"code":"test('writeWantedLockfile()', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 3,\n    packages: {\n      '/is-negative/1.0.0': {\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n    registry: 'https://registry.npmjs.org',\n  }\n  await writeWantedLockfile(projectPath, wantedLockfile)\n  expect(await readCurrentLockfile(projectPath, { ignoreIncompatible: false })).toBeNull()\n  expect(await readWantedLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"writeCurrentLockfile()","suites":[],"updatePoint":{"line":110,"column":28},"line":110,"code":"test('writeCurrentLockfile()', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 3,\n    packages: {\n      '/is-negative/1.0.0': {\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n    registry: 'https://registry.npmjs.org',\n  }\n  await writeCurrentLockfile(projectPath, wantedLockfile)\n  expect(await readWantedLockfile(projectPath, { ignoreIncompatible: false })).toBeNull()\n  expect(await readCurrentLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"existsWantedLockfile()","suites":[],"updatePoint":{"line":153,"column":28},"line":153,"code":"test('existsWantedLockfile()', async () => {\n  const projectPath = tempy.directory()\n  expect(await existsWantedLockfile(projectPath)).toBe(false)\n  await writeWantedLockfile(projectPath, {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 3,\n    packages: {\n      '/is-negative/1.0.0': {\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n  expect(await existsWantedLockfile(projectPath)).toBe(true)\n})","file":"read.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"writeLockfiles()","suites":[],"updatePoint":{"line":12,"column":22},"line":12,"code":"test('writeLockfiles()', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        os: ['darwin'],\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        cpu: ['x86'],\n        engines: {\n          node: '>=10',\n          npm: '\\nfoo\\n',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }\n  await writeLockfiles({\n    currentLockfile: wantedLockfile,\n    currentLockfileDir: projectPath,\n    wantedLockfile,\n    wantedLockfileDir: projectPath,\n  })\n  expect(await readCurrentLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n  expect(await readWantedLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n\n  // Verifying the formatting of the lockfile\n  expect(fs.readFileSync(path.join(projectPath, WANTED_LOCKFILE), 'utf8')).toMatchSnapshot()\n})","file":"write.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"writeLockfiles() when no specifiers but dependencies present","suites":[],"updatePoint":{"line":68,"column":66},"line":68,"code":"test('writeLockfiles() when no specifiers but dependencies present', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': 'link:../is-positive',\n        },\n        specifiers: {},\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n  }\n  await writeLockfiles({\n    currentLockfile: wantedLockfile,\n    currentLockfileDir: projectPath,\n    wantedLockfile,\n    wantedLockfileDir: projectPath,\n  })\n  expect(await readCurrentLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n  expect(await readWantedLockfile(projectPath, { ignoreIncompatible: false })).toEqual(wantedLockfile)\n})","file":"write.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"write does not use yaml anchors/aliases","suites":[],"updatePoint":{"line":91,"column":45},"line":91,"code":"test('write does not use yaml anchors/aliases', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: yaml`\n      /react-dnd/2.5.4/react@15.6.1:\n        dependencies:\n          disposables: 1.0.2\n          dnd-core: 2.5.4\n          hoist-non-react-statics: 2.5.0\n          invariant: 2.2.3\n          lodash: 4.15.0\n          prop-types: 15.6.1\n          react: 15.6.1\n        dev: false\n        id: registry.npmjs.org/react-dnd/2.5.4\n        peerDependencies: &ref_11\n          react: '1'\n        resolution:\n          integrity: sha512-y9YmnusURc+3KPgvhYKvZ9oCucj51MSZWODyaeV0KFU0cquzA7dCD1g/OIYUKtNoZ+MXtacDngkdud2TklMSjw==\n      /react-dnd/2.5.4/react@15.6.2:\n        dependencies:\n          disposables: 1.0.2\n          dnd-core: 2.5.4\n          hoist-non-react-statics: 2.5.0\n          invariant: 2.2.3\n          lodash: 4.15.0\n          prop-types: 15.6.1\n          react: 15.6.2\n        dev: false\n        id: registry.npmjs.org/react-dnd/2.5.4\n        peerDependencies: *ref_11\n        resolution:\n          integrity: sha512-y9YmnusURc+3KPgvhYKvZ9oCucj51MSZWODyaeV0KFU0cquzA7dCD1g/OIYUKtNoZ+MXtacDngkdud2TklMSjw==\n    `,\n  }\n  await writeLockfiles({\n    currentLockfile: wantedLockfile,\n    currentLockfileDir: projectPath,\n    wantedLockfile,\n    wantedLockfileDir: projectPath,\n  })\n\n  const lockfileContent = fs.readFileSync(path.join(projectPath, WANTED_LOCKFILE), 'utf8')\n  expect(lockfileContent).not.toMatch('&')\n  expect(lockfileContent).not.toMatch('*')\n})","file":"write.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"writeLockfiles() does not fail if the lockfile has undefined properties","suites":[],"updatePoint":{"line":151,"column":77},"line":151,"code":"test('writeLockfiles() does not fail if the lockfile has undefined properties', async () => {\n  const projectPath = tempy.directory()\n  const wantedLockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        // eslint-disable-next-line\n        dependencies: undefined as any,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }\n  await writeLockfiles({\n    currentLockfile: wantedLockfile,\n    currentLockfileDir: projectPath,\n    wantedLockfile,\n    wantedLockfileDir: projectPath,\n  })\n})","file":"write.test.ts","skipped":false,"dir":"packages/lockfile-file/test"},{"name":"lockfileToPackageRegistry","suites":[],"updatePoint":{"line":4,"column":31},"line":4,"code":"test('lockfileToPackageRegistry', () => {\n  const packageRegistry = lockfileToPackageRegistry({\n    importers: {\n      importer1: {\n        dependencies: {\n          dep1: '1.0.0',\n          dep2: '/foo/2.0.0',\n        },\n        optionalDependencies: {\n          qar: '2.0.0',\n        },\n        specifiers: {},\n      },\n      importer2: {\n        devDependencies: {\n          importer1: 'link:../importer1',\n        },\n        specifiers: {},\n      },\n    },\n    lockfileVersion: 5,\n    packages: {\n      '/dep1/1.0.0': {\n        dependencies: {\n          dep2: '/foo/2.0.0',\n        },\n        resolution: {\n          integrity: '',\n        },\n      },\n      '/foo/2.0.0': {\n        dependencies: {\n          qar: '3.0.0',\n        },\n        resolution: {\n          integrity: '',\n        },\n      },\n      '/qar/2.0.0': {\n        resolution: {\n          integrity: '',\n        },\n      },\n      '/qar/3.0.0': {\n        resolution: {\n          integrity: '',\n        },\n      },\n    },\n  }, {\n    importerNames: {\n      importer1: 'importer1',\n      importer2: 'importer2',\n    },\n    lockfileDir: process.cwd(),\n    registries: {\n      default: 'https://registry.npmjs.org/',\n    },\n    virtualStoreDir: path.resolve('node_modules/.pnpm'),\n  })\n\n  const actual = Array.from(\n    packageRegistry,\n    ([packageName, packageStoreMap]) => {\n      return [\n        packageName,\n        Array.from(\n          packageStoreMap,\n          ([pkgRef, packageInfo]) => {\n            return [\n              pkgRef,\n              {\n                packageDependencies: Array.from(packageInfo.packageDependencies),\n                packageLocation: packageInfo.packageLocation,\n              },\n            ]\n          }\n        ),\n      ]\n    }\n  )\n\n  expect(actual).toStrictEqual([\n    [\n      'importer1',\n      [\n        [\n          'importer1',\n          {\n            packageDependencies: [\n              ['importer1', 'importer1'],\n              ['dep1', '1.0.0'],\n              ['dep2', ['foo', '2.0.0']],\n              ['qar', '2.0.0'],\n            ],\n            packageLocation: './importer1',\n          },\n        ],\n      ],\n    ],\n    [\n      'importer2',\n      [\n        [\n          'importer2',\n          {\n            packageDependencies: [\n              ['importer2', 'importer2'],\n              ['importer1', 'importer1'],\n            ],\n            packageLocation: './importer2',\n          },\n        ],\n      ],\n    ],\n    [\n      'dep1',\n      [\n        [\n          '1.0.0',\n          {\n            packageDependencies: [\n              ['dep1', '1.0.0'],\n              ['dep2', ['foo', '2.0.0']],\n            ],\n            packageLocation: './node_modules/.pnpm/dep1@1.0.0/node_modules/dep1',\n          },\n        ],\n      ],\n    ],\n    [\n      'foo',\n      [\n        [\n          '2.0.0',\n          {\n            packageDependencies: [\n              ['foo', '2.0.0'],\n              ['qar', '3.0.0'],\n            ],\n            packageLocation: './node_modules/.pnpm/foo@2.0.0/node_modules/foo',\n          },\n        ],\n      ],\n    ],\n    [\n      'qar',\n      [\n        [\n          '2.0.0',\n          {\n            packageDependencies: [\n              ['qar', '2.0.0'],\n            ],\n            packageLocation: './node_modules/.pnpm/qar@2.0.0/node_modules/qar',\n          },\n        ],\n        [\n          '3.0.0',\n          {\n            packageDependencies: [\n              ['qar', '3.0.0'],\n            ],\n            packageLocation: './node_modules/.pnpm/qar@3.0.0/node_modules/qar',\n          },\n        ],\n      ],\n    ],\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/lockfile-to-pnp/test"},{"name":"lockfileToPackageRegistry packages that have peer deps","suites":[],"updatePoint":{"line":175,"column":60},"line":175,"code":"test('lockfileToPackageRegistry packages that have peer deps', () => {\n  const packageRegistry = lockfileToPackageRegistry({\n    importers: {\n      importer: {\n        dependencies: {\n          haspeer: '2.0.0_peer@1.0.0',\n          peer: '1.0.0',\n        },\n        specifiers: {},\n      },\n    },\n    lockfileVersion: 5,\n    packages: {\n      '/haspeer/2.0.0_peer@1.0.0': {\n        dependencies: {\n          peer: '1.0.0',\n        },\n        peerDependencies: {\n          peer: '^1.0.0',\n        },\n        resolution: {\n          integrity: '',\n        },\n      },\n      '/peer/1.0.0': {\n        resolution: {\n          integrity: '',\n        },\n      },\n    },\n  }, {\n    importerNames: {\n      importer: 'importer',\n    },\n    lockfileDir: process.cwd(),\n    registries: {\n      default: 'https://registry.npmjs.org/',\n    },\n    virtualStoreDir: path.resolve('node_modules/.pnpm'),\n  })\n\n  const actual = Array.from(\n    packageRegistry,\n    ([packageName, packageStoreMap]) => {\n      return [\n        packageName,\n        Array.from(\n          packageStoreMap,\n          ([pkgRef, packageInfo]) => {\n            return [\n              pkgRef,\n              {\n                packageDependencies: Array.from(packageInfo.packageDependencies),\n                packageLocation: packageInfo.packageLocation,\n              },\n            ]\n          }\n        ),\n      ]\n    }\n  )\n\n  expect(actual).toStrictEqual([\n    [\n      'importer',\n      [\n        [\n          'importer',\n          {\n            packageDependencies: [\n              ['importer', 'importer'],\n              ['haspeer', 'virtual:2.0.0_peer@1.0.0#2.0.0'],\n              ['peer', '1.0.0'],\n            ],\n            packageLocation: './importer',\n          },\n        ],\n      ],\n    ],\n    [\n      'haspeer',\n      [\n        [\n          'virtual:2.0.0_peer@1.0.0#2.0.0',\n          {\n            packageDependencies: [\n              ['haspeer', 'virtual:2.0.0_peer@1.0.0#2.0.0'],\n              ['peer', '1.0.0'],\n            ],\n            packageLocation: './node_modules/.pnpm/haspeer@2.0.0_peer@1.0.0/node_modules/haspeer',\n          },\n        ],\n      ],\n    ],\n    [\n      'peer',\n      [\n        [\n          '1.0.0',\n          {\n            packageDependencies: [\n              ['peer', '1.0.0'],\n            ],\n            packageLocation: './node_modules/.pnpm/peer@1.0.0/node_modules/peer',\n          },\n        ],\n      ],\n    ],\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/lockfile-to-pnp/test"},{"name":"nameVerFromPkgSnapshot()","suites":[],"updatePoint":{"line":3,"column":30},"line":3,"code":"test('nameVerFromPkgSnapshot()', () => {\n  expect(nameVerFromPkgSnapshot('/some-weird-path', {\n    name: 'foo',\n    version: '1.0.0',\n\n    resolution: {\n      integrity: 'AAA',\n    },\n  })).toEqual({\n    name: 'foo',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(nameVerFromPkgSnapshot('/foo/1.0.0', {\n    resolution: {\n      integrity: 'AAA',\n    },\n  })).toEqual({\n    name: 'foo',\n    peersSuffix: undefined,\n    version: '1.0.0',\n  })\n\n  expect(nameVerFromPkgSnapshot('/foo/1.0.0_bar@2.0.0', {\n    resolution: {\n      integrity: 'AAA',\n    },\n  })).toEqual({\n    name: 'foo',\n    peersSuffix: 'bar@2.0.0',\n    version: '1.0.0',\n  })\n})","file":"nameVerFromPkgSnapshot.ts","skipped":false,"dir":"packages/lockfile-utils/test"},{"name":"pkgSnapshotToResolution()","suites":[],"updatePoint":{"line":3,"column":31},"line":3,"code":"test('pkgSnapshotToResolution()', () => {\n  expect(pkgSnapshotToResolution('/foo/1.0.0', {\n    resolution: {\n      integrity: 'AAAA',\n    },\n  }, { default: 'https://registry.npmjs.org/' })).toEqual({\n    integrity: 'AAAA',\n    registry: 'https://registry.npmjs.org/',\n    tarball: 'https://registry.npmjs.org/foo/-/foo-1.0.0.tgz',\n  })\n\n  expect(pkgSnapshotToResolution('/@mycompany/mypackage/2.0.0', {\n    resolution: {\n      integrity: 'AAAA',\n      tarball: '@mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz',\n    },\n  }, { default: 'https://registry.npmjs.org/', '@mycompany': 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local/' })).toEqual({\n    integrity: 'AAAA',\n    registry: 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local/',\n    tarball: 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local/@mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz',\n  })\n\n  expect(pkgSnapshotToResolution('/@mycompany/mypackage/2.0.0', {\n    resolution: {\n      integrity: 'AAAA',\n      tarball: '@mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz',\n    },\n  }, { default: 'https://registry.npmjs.org/', '@mycompany': 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local' })).toEqual({\n    integrity: 'AAAA',\n    registry: 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local',\n    tarball: 'https://mycompany.jfrog.io/mycompany/api/npm/npm-local/@mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz',\n  })\n\n  expect(pkgSnapshotToResolution('/foo/1.0.0', {\n    resolution: {\n      integrity: 'AAAA',\n      registry: 'https://npm.pkg.github.com/',\n      tarball: 'https://npm.pkg.github.com/download/@foo/bar/1.0.0/aaa',\n    },\n  }, { default: 'https://registry.npmjs.org/' })).toEqual({\n    integrity: 'AAAA',\n    registry: 'https://npm.pkg.github.com/',\n    tarball: 'https://npm.pkg.github.com/download/@foo/bar/1.0.0/aaa',\n  })\n})","file":"pkgSnapshotToResolution.ts","skipped":false,"dir":"packages/lockfile-utils/test"},{"name":"satisfiesPackageManifest()","suites":[],"updatePoint":{"line":12,"column":32},"line":12,"code":"test('satisfiesPackageManifest()', () => {\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(true)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        devDependencies: {},\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(true)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        devDependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    devDependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(true)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        optionalDependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    optionalDependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(true)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    optionalDependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(false)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.1.0' },\n  }, '.')).toBe(false)\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0', bar: '2.0.0' },\n  }, '.')).toBe(false)\n\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0', bar: '2.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0', bar: '2.0.0' },\n  }, '.')).toBe(false)\n\n  {\n    const lockfile = {\n      ...DEFAULT_LOCKFILE_FIELDS,\n      importers: {\n        '.': {\n          dependencies: {\n            foo: '1.0.0',\n          },\n          optionalDependencies: {\n            bar: '2.0.0',\n          },\n          specifiers: {\n            bar: '2.0.0',\n            foo: '^1.0.0',\n          },\n        },\n      },\n    }\n    const pkg = {\n      ...DEFAULT_PKG_FIELDS,\n      dependencies: {\n        bar: '2.0.0',\n        foo: '^1.0.0',\n      },\n      optionalDependencies: {\n        bar: '2.0.0',\n      },\n    }\n    expect(satisfiesPackageManifest(lockfile, pkg, '.')).toBe(true)\n  }\n\n  {\n    const lockfile = {\n      ...DEFAULT_LOCKFILE_FIELDS,\n      importers: {\n        '.': {\n          dependencies: {\n            bar: '2.0.0',\n            qar: '1.0.0',\n          },\n          specifiers: {\n            bar: '2.0.0',\n            qar: '^1.0.0',\n          },\n        },\n      },\n    }\n    const pkg = {\n      ...DEFAULT_PKG_FIELDS,\n      dependencies: {\n        bar: '2.0.0',\n      },\n    }\n    expect(satisfiesPackageManifest(lockfile, pkg, '.')).toBe(false)\n  }\n\n  {\n    const lockfile = {\n      ...DEFAULT_LOCKFILE_FIELDS,\n      importers: {\n        '.': {\n          dependencies: {\n            bar: '2.0.0',\n            qar: '1.0.0',\n          },\n          specifiers: {\n            bar: '2.0.0',\n          },\n        },\n      },\n    }\n    const pkg = {\n      ...DEFAULT_PKG_FIELDS,\n      dependencies: {\n        bar: '2.0.0',\n      },\n    }\n    expect(satisfiesPackageManifest(lockfile, pkg, '.')).toBe(false)\n  }\n\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: { foo: '1.0.0', linked: 'link:../linked' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(true)\n\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      'packages/foo': {\n        dependencies: { foo: '1.0.0' },\n        specifiers: { foo: '^1.0.0' },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: { foo: '^1.0.0' },\n  }, '.')).toBe(false)\n\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: {\n          foo: '1.0.0',\n        },\n        specifiers: {\n          foo: '1.0.0',\n        },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: {\n      foo: '1.0.0',\n    },\n    devDependencies: {\n      foo: '1.0.0',\n    },\n  }, '.')).toBe(true)\n\n  expect(satisfiesPackageManifest({\n    ...DEFAULT_LOCKFILE_FIELDS,\n    importers: {\n      '.': {\n        dependencies: {\n          foo: '1.0.0',\n        },\n        specifiers: {\n          foo: '1.0.0',\n        },\n      },\n    },\n  }, {\n    ...DEFAULT_PKG_FIELDS,\n    dependencies: {\n      foo: '1.0.0',\n    },\n    devDependencies: {\n      foo: '1.0.0',\n    },\n    dependenciesMeta: {},\n  }, '.')).toBe(true)\n})","file":"satisfiesPackageManifest.ts","skipped":false,"dir":"packages/lockfile-utils/test"},{"name":"makeDedicatedLockfile()","suites":[],"updatePoint":{"line":8,"column":29},"line":8,"code":"test('makeDedicatedLockfile()', async () => {\n  const tmp = f.prepare('fixture')\n  const projectDir = path.join(tmp, 'packages/is-negative')\n  await makeDedicatedLockfile(tmp, projectDir)\n\n  const lockfile = await readWantedLockfile(projectDir, { ignoreIncompatible: false })\n  expect(Object.keys(lockfile?.importers ?? {})).toStrictEqual(['.', 'example'])\n  expect(Object.keys(lockfile?.packages ?? {})).toStrictEqual([\n    '/is-positive/1.0.0',\n    '/lodash/1.0.0',\n    '/ramda/0.26.0',\n    '/request/2.0.0',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/make-dedicated-lockfile/test"},{"name":"getPref()","suites":[],"updatePoint":{"line":3,"column":15},"line":3,"code":"test('getPref()', () => {\n  expect(getPref('foo', 'foo', '1.0.0', {})).toEqual('^1.0.0')\n\n  expect(\n    getPref('foo', 'foo', '1.0.0', {\n      pinnedVersion: 'major',\n    })\n  ).toEqual('^1.0.0')\n\n  expect(\n    getPref('foo', 'foo', '2.0.0', {\n      pinnedVersion: 'minor',\n    })\n  ).toEqual('~2.0.0')\n\n  expect(\n    getPref('foo', 'foo', '3.0.0', {\n      pinnedVersion: 'patch',\n    })\n  ).toEqual('3.0.0')\n\n  expect(\n    getPref('foo', 'foo', '4.0.0', {\n      pinnedVersion: 'none',\n    })\n  ).toEqual('*')\n\n  expect(\n    getPref('foo', 'foo', undefined, {\n      pinnedVersion: 'major',\n    })\n  ).toEqual('*')\n})","file":"getPref.test.ts","skipped":false,"dir":"packages/manifest-utils/test"},{"name":"getSpecFromPackageManifest()","suites":[],"updatePoint":{"line":3,"column":34},"line":3,"code":"test('getSpecFromPackageManifest()', () => {\n  expect(\n    getSpecFromPackageManifest({\n      dependencies: {\n        foo: '3.0.0',\n      },\n      devDependencies: {\n        foo: '2.0.0',\n      },\n      optionalDependencies: {\n        foo: '1.0.0',\n      },\n    }, 'foo')).toEqual('1.0.0')\n\n  expect(\n    getSpecFromPackageManifest({\n      dependencies: {\n        foo: '3.0.0',\n      },\n      devDependencies: {\n        foo: '2.0.0',\n      },\n    }, 'foo')).toEqual('3.0.0')\n\n  expect(\n    getSpecFromPackageManifest({\n      devDependencies: {\n        foo: '2.0.0',\n      },\n    }, 'foo')).toEqual('2.0.0')\n})","file":"getSpecFromPackageManifest.test.ts","skipped":false,"dir":"packages/manifest-utils/test"},{"name":"guessDependencyType()","suites":[],"updatePoint":{"line":3,"column":27},"line":3,"code":"test('guessDependencyType()', () => {\n  expect(\n    guessDependencyType('foo', {\n      dependencies: {\n        bar: '1.0.0',\n      },\n      devDependencies: {\n        foo: '',\n      },\n    })\n  ).toEqual('devDependencies')\n\n  expect(\n    guessDependencyType('bar', {\n      dependencies: {\n        bar: '1.0.0',\n      },\n      devDependencies: {\n        foo: '1.0.0',\n      },\n    })\n  ).toEqual('dependencies')\n})","file":"updateProjectManifestObject.test.ts","skipped":false,"dir":"packages/manifest-utils/test"},{"name":"matcher()","suites":[],"updatePoint":{"line":3,"column":15},"line":3,"code":"test('matcher()', () => {\n  {\n    const match = matcher('*')\n    expect(match('@eslint/plugin-foo')).toBe(true)\n    expect(match('express')).toBe(true)\n  }\n  {\n    const match = matcher(['eslint-*'])\n    expect(match('eslint-plugin-foo')).toBe(true)\n    expect(match('express')).toBe(false)\n  }\n  {\n    const match = matcher(['*plugin*'])\n    expect(match('@eslint/plugin-foo')).toBe(true)\n    expect(match('express')).toBe(false)\n  }\n  {\n    const match = matcher(['a*c'])\n    expect(match('abc')).toBe(true)\n  }\n  {\n    const match = matcher(['*-positive'])\n    expect(match('is-positive')).toBe(true)\n  }\n  {\n    const match = matcher(['foo', 'bar'])\n    expect(match('foo')).toBe(true)\n    expect(match('bar')).toBe(true)\n    expect(match('express')).toBe(false)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/matcher/test"},{"name":"picks the newer version when dependencies differ inside importer","suites":[],"updatePoint":{"line":25,"column":70},"line":25,"code":"test('picks the newer version when dependencies differ inside importer', () => {\n  const mergedLockfile = mergeLockfileChanges(\n    {\n      ...simpleLockfile,\n      importers: {\n        '.': {\n          ...simpleLockfile.importers['.'],\n          dependencies: {\n            foo: '1.2.0',\n            bar: '3.0.0_qar@1.0.0',\n            zoo: '4.0.0_qar@1.0.0',\n          },\n        },\n      },\n    },\n    {\n      ...simpleLockfile,\n      importers: {\n        '.': {\n          ...simpleLockfile.importers['.'],\n          dependencies: {\n            foo: '1.1.0',\n            bar: '4.0.0_qar@1.0.0',\n            zoo: '3.0.0_qar@1.0.0',\n          },\n        },\n      },\n    }\n  )\n  expect(mergedLockfile.importers['.'].dependencies?.foo).toBe('1.2.0')\n  expect(mergedLockfile.importers['.'].dependencies?.bar).toBe('4.0.0_qar@1.0.0')\n  expect(mergedLockfile.importers['.'].dependencies?.zoo).toBe('4.0.0_qar@1.0.0')\n})","file":"index.ts","skipped":false,"dir":"packages/merge-lockfile-changes/test"},{"name":"picks the newer version when dependencies differ inside package","suites":[],"updatePoint":{"line":59,"column":69},"line":59,"code":"test('picks the newer version when dependencies differ inside package', () => {\n  const base: Lockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          a: '1.0.0',\n        },\n        specifiers: {},\n      },\n    },\n    lockfileVersion: 5.2,\n    packages: {\n      '/a/1.0.0': {\n        dependencies: {\n          foo: '1.0.0',\n        },\n        resolution: {\n          integrity: '',\n        },\n      },\n      '/foo/1.0.0': {\n        resolution: {\n          integrity: '',\n        },\n      },\n    },\n  }\n  const mergedLockfile = mergeLockfileChanges(\n    {\n      ...base,\n      packages: {\n        ...base.packages,\n        '/a/1.0.0': {\n          dependencies: {\n            linked: 'link:../1',\n            foo: '1.2.0',\n            bar: '3.0.0_qar@1.0.0',\n            zoo: '4.0.0_qar@1.0.0',\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/bar/3.0.0_qar@1.0.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/zoo/4.0.0_qar@1.0.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/foo/1.2.0': {\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/qar/1.0.0': {\n          resolution: {\n            integrity: '',\n          },\n        },\n      },\n    },\n    {\n      ...base,\n      packages: {\n        ...base.packages,\n        '/a/1.0.0': {\n          dependencies: {\n            linked: 'link:../1',\n            foo: '1.1.0',\n            bar: '4.0.0_qar@1.0.0',\n            zoo: '3.0.0_qar@1.0.0',\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/bar/4.0.0_qar@1.0.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/zoo/3.0.0_qar@1.0.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/foo/1.1.0': {\n          resolution: {\n            integrity: '',\n          },\n        },\n        '/qar/1.0.0': {\n          resolution: {\n            integrity: '',\n          },\n        },\n      },\n    }\n  )\n  expect(mergedLockfile.packages?.['/a/1.0.0'].dependencies?.linked).toBe('link:../1')\n  expect(mergedLockfile.packages?.['/a/1.0.0'].dependencies?.foo).toBe('1.2.0')\n  expect(mergedLockfile.packages?.['/a/1.0.0'].dependencies?.bar).toBe('4.0.0_qar@1.0.0')\n  expect(mergedLockfile.packages?.['/a/1.0.0'].dependencies?.zoo).toBe('4.0.0_qar@1.0.0')\n  expect(Object.keys(mergedLockfile.packages ?? {}).sort()).toStrictEqual([\n    '/a/1.0.0',\n    '/bar/3.0.0_qar@1.0.0',\n    '/bar/4.0.0_qar@1.0.0',\n    '/foo/1.0.0',\n    '/foo/1.1.0',\n    '/foo/1.2.0',\n    '/qar/1.0.0',\n    '/zoo/3.0.0_qar@1.0.0',\n    '/zoo/4.0.0_qar@1.0.0',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/merge-lockfile-changes/test"},{"name":"prefers our lockfile resolutions when it has newer packages","suites":[],"updatePoint":{"line":193,"column":65},"line":193,"code":"test('prefers our lockfile resolutions when it has newer packages', () => {\n  const mergedLockfile = mergeLockfileChanges(\n    {\n      ...simpleLockfile,\n      packages: {\n        '/foo/1.0.0': {\n          dependencies: {\n            bar: '1.0.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/bar/1.0.0': {\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n      },\n    },\n    {\n      ...simpleLockfile,\n      packages: {\n        '/foo/1.0.0': {\n          dependencies: {\n            bar: '1.1.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/bar/1.1.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/qar/1.0.0': {\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n      },\n    }\n  )\n\n  expect(mergedLockfile).toStrictEqual({\n    ...simpleLockfile,\n    packages: {\n      '/foo/1.0.0': {\n        dependencies: {\n          bar: '1.1.0',\n        },\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/bar/1.0.0': {\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/bar/1.1.0': {\n        dependencies: {\n          qar: '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/qar/1.0.0': {\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/merge-lockfile-changes/test"},{"name":"prefers our lockfile resolutions when it has newer packages","suites":[],"updatePoint":{"line":274,"column":65},"line":274,"code":"test('prefers our lockfile resolutions when it has newer packages', () => {\n  const mergedLockfile = mergeLockfileChanges(\n    {\n      ...simpleLockfile,\n      packages: {\n        '/foo/1.0.0': {\n          dependencies: {\n            bar: '1.0.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/bar/1.0.0': {\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n      },\n    },\n    {\n      ...simpleLockfile,\n      packages: {\n        '/foo/1.0.0': {\n          dependencies: {\n            bar: '1.1.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/bar/1.1.0': {\n          dependencies: {\n            qar: '1.0.0',\n          },\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n        '/qar/1.0.0': {\n          resolution: {\n            integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n          },\n        },\n      },\n    }\n  )\n\n  expect(mergedLockfile).toStrictEqual({\n    ...simpleLockfile,\n    packages: {\n      '/foo/1.0.0': {\n        dependencies: {\n          bar: '1.1.0',\n        },\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/bar/1.0.0': {\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/bar/1.1.0': {\n        dependencies: {\n          qar: '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n      '/qar/1.0.0': {\n        resolution: {\n          integrity: 'sha512-aBVzCAzfyApU0gg36QgCpJixGtYwuQ4djrn11J+DTB5vE4OmBPuZiulgTCA9ByULgVAyNV2CTpjjvZmxzukSLw==',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/merge-lockfile-changes/test"},{"name":"write() and read()","suites":[],"updatePoint":{"line":8,"column":24},"line":8,"code":"test('write() and read()', async () => {\n  const modulesDir = tempy.directory()\n  const modulesYaml = {\n    hoistedDependencies: {},\n    included: {\n      dependencies: true,\n      devDependencies: true,\n      optionalDependencies: true,\n    },\n    layoutVersion: 1,\n    packageManager: 'pnpm@2',\n    pendingBuilds: [],\n    publicHoistPattern: [],\n    prunedAt: new Date().toUTCString(),\n    registries: {\n      default: 'https://registry.npmjs.org/',\n    },\n    shamefullyHoist: false,\n    skipped: [],\n    storeDir: '/.pnpm-store',\n    virtualStoreDir: path.join(modulesDir, '.pnpm'),\n  }\n  await write(modulesDir, modulesYaml)\n  expect(await read(modulesDir)).toEqual(modulesYaml)\n\n  const raw = await readYamlFile<object>(path.join(modulesDir, '.modules.yaml'))\n  expect(raw['virtualStoreDir']).toBeDefined()\n  expect(path.isAbsolute(raw['virtualStoreDir'])).toEqual(isWindows())\n})","file":"index.ts","skipped":false,"dir":"packages/modules-yaml/test"},{"name":"backward compatible read of .modules.yaml created with shamefully-hoist=true","suites":[],"updatePoint":{"line":38,"column":82},"line":38,"code":"test('backward compatible read of .modules.yaml created with shamefully-hoist=true', async () => {\n  const modulesYaml = await read(path.join(__dirname, 'fixtures/old-shamefully-hoist'))\n  if (modulesYaml == null) {\n    fail('modulesYaml was nullish')\n  }\n  expect(modulesYaml.publicHoistPattern).toEqual(['*'])\n  expect(modulesYaml.hoistedDependencies).toEqual({\n    '/accepts/1.3.7': { accepts: 'public' },\n    '/array-flatten/1.1.1': { 'array-flatten': 'public' },\n    '/body-parser/1.19.0': { 'body-parser': 'public' },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/modules-yaml/test"},{"name":"backward compatible read of .modules.yaml created with shamefully-hoist=false","suites":[],"updatePoint":{"line":51,"column":83},"line":51,"code":"test('backward compatible read of .modules.yaml created with shamefully-hoist=false', async () => {\n  const modulesYaml = await read(path.join(__dirname, 'fixtures/old-no-shamefully-hoist'))\n  if (modulesYaml == null) {\n    fail('modulesYaml was nullish')\n  }\n  expect(modulesYaml.publicHoistPattern).toEqual([])\n  expect(modulesYaml.hoistedDependencies).toEqual({\n    '/accepts/1.3.7': { accepts: 'private' },\n    '/array-flatten/1.1.1': { 'array-flatten': 'private' },\n    '/body-parser/1.19.0': { 'body-parser': 'private' },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/modules-yaml/test"},{"name":"readdir","suites":["FUSE handlers"],"updatePoint":{"line":17,"column":13},"line":17,"code":"  it('readdir', () => {\n    handlers.readdir('/', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files!.sort()).toStrictEqual([\n        '.pnpm',\n        '@zkochan',\n        'is-positive',\n      ].sort())\n    })\n    handlers.readdir('/.pnpm', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files!.sort()).toStrictEqual([\n        '@zkochan+git-config@0.1.0',\n        'ini@1.3.8',\n        'is-positive@1.0.0',\n      ].sort())\n    })\n    handlers.readdir('/.pnpm/is-positive@1.0.0', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files).toStrictEqual(['node_modules'])\n    })\n    handlers.readdir('/.pnpm/is-positive@1.0.0/node_modules', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files).toStrictEqual(['is-positive'])\n    })\n    handlers.readdir('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files).toStrictEqual(['git-config'])\n    })\n    handlers.readdir('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files!.sort()).toStrictEqual([\n        'package.json',\n        '.npmignore',\n        'README.md',\n        'LICENSE',\n        'Gruntfile.js',\n        '.travis.yml',\n        '.jshintrc',\n        'test',\n        'index.js',\n      ].sort())\n    })\n    handlers.readdir('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/test', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files!.sort()).toStrictEqual([\n        'index.js',\n        'fixtures',\n      ].sort())\n    })\n    handlers.readdir('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/does-not-exist', (returnCode, files) => {\n      expect(returnCode).toBe(Fuse.ENOENT)\n    })\n    handlers.readdir('/.pnpm/is-positive@1.0.0/node_modules/is-positive', (returnCode, files) => {\n      expect(returnCode).toBe(0)\n      expect(files!.sort()).toStrictEqual([\n        'package.json',\n        'index.js',\n        'license',\n        'readme.md',\n      ].sort())\n    })\n    handlers.readdir('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@types', (returnCode) => {\n      expect(returnCode).toBe(Fuse.ENOENT)\n    })\n  })","file":"createFuseHandlers.test.ts","skipped":false,"dir":"packages/mount-modules/test"},{"name":"getattr","suites":["FUSE handlers"],"updatePoint":{"line":83,"column":13},"line":83,"code":"  it('getattr', () => {\n    handlers.getattr('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/index.js', (returnCode, stat) => {\n      expect(returnCode).toBe(0)\n      expect(stat.mode).toBe(33188)\n    })\n    handlers.getattr('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/test/fixtures', (returnCode, stat) => {\n      expect(returnCode).toBe(0)\n      expect(stat.mode).toBe(16877)\n    })\n    handlers.getattr('/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/index.jsx', (returnCode, stat) => {\n      expect(returnCode).toBe(Fuse.ENOENT)\n    })\n    handlers.getattr('/.pnpm/is-positive@1.0.0/node_modules/is-positive/package.json', (returnCode, stat) => {\n      expect(returnCode).toBe(0)\n      expect(stat.mode).toBe(33188)\n    })\n  })","file":"createFuseHandlers.test.ts","skipped":false,"dir":"packages/mount-modules/test"},{"name":"open and read","suites":["FUSE handlers"],"updatePoint":{"line":100,"column":19},"line":100,"code":"  it('open and read', (done) => {\n    const p = '/.pnpm/@zkochan+git-config@0.1.0/node_modules/@zkochan/git-config/index.js'\n    handlers.open(p, 0, (exitCode, fd) => {\n      expect(exitCode).toBe(0)\n      expect(fd && fd > 0).toBeTruthy()\n      const buffer = Buffer.alloc(10)\n\n      handlers.read(p, fd!, buffer, 10, 0, (readBytes) => {\n        expect(readBytes).toBe(10)\n        expect(buffer.toString()).toBe('var ini = ')\n\n        handlers.release(p, fd!, (exitCode) => {\n          expect(exitCode).toBe(0)\n          done()\n        })\n      })\n    })\n  })","file":"createFuseHandlers.test.ts","skipped":false,"dir":"packages/mount-modules/test"},{"name":"makeVirtualNodeModules","suites":[],"updatePoint":{"line":5,"column":28},"line":5,"code":"test('makeVirtualNodeModules', async () => {\n  const lockfile = await readWantedLockfile(path.join(__dirname, '__fixtures__/simple'), { ignoreIncompatible: true })\n  expect(makeVirtualNodeModules(lockfile!)).toMatchSnapshot()\n})","file":"makeVirtualNodeModules.test.ts","skipped":false,"dir":"packages/mount-modules/test"},{"name":"all expected options passed down to HttpAgent","suites":[],"updatePoint":{"line":32,"column":51},"line":32,"code":"test('all expected options passed down to HttpAgent', () => {\n  expect(getAgent('http://foo.com/bar', OPTS)).toEqual({\n    __type: 'http',\n    localAddress: 'localAddress',\n    maxSockets: 5,\n    timeout: 6,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/npm-registry-agent/test"},{"name":"all expected options passed down to HttpsAgent","suites":[],"updatePoint":{"line":41,"column":52},"line":41,"code":"test('all expected options passed down to HttpsAgent', () => {\n  expect(getAgent('https://foo.com/bar', OPTS)).toEqual({\n    __type: 'https',\n    ca: 'ca',\n    cert: 'cert',\n    key: 'key',\n    localAddress: 'localAddress',\n    maxSockets: 5,\n    rejectUnauthorized: true,\n    timeout: 6,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/npm-registry-agent/test"},{"name":"all expected options passed down to proxy agent","suites":[],"updatePoint":{"line":54,"column":53},"line":54,"code":"test('all expected options passed down to proxy agent', () => {\n  const opts = {\n    httpsProxy: 'https://user:pass@my.proxy:1234/foo',\n    ...OPTS,\n  }\n  expect(getAgent('https://foo.com/bar', opts)).toEqual({\n    __type: 'https-proxy',\n    auth: 'user:pass',\n    ca: 'ca',\n    cert: 'cert',\n    host: 'my.proxy',\n    key: 'key',\n    localAddress: 'localAddress',\n    maxSockets: 5,\n    path: '/foo',\n    port: '1234',\n    protocol: 'https:',\n    rejectUnauthorized: true,\n    timeout: 6,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/npm-registry-agent/test"},{"name":"a socks proxy","suites":[],"updatePoint":{"line":76,"column":19},"line":76,"code":"test('a socks proxy', () => {\n  const opts = {\n    httpsProxy: 'socks://user:pass@my.proxy:1234/foo',\n    ...OPTS,\n  }\n  const agent = getAgent('https://foo.com/bar', opts)\n  expect(agent instanceof SocksProxyAgent).toBeTruthy()\n  expect(agent.proxy).toEqual({\n    host: 'my.proxy',\n    port: 1234,\n    type: 5,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/npm-registry-agent/test"},{"name":"proxy credentials are decoded","suites":[],"updatePoint":{"line":90,"column":35},"line":90,"code":"test('proxy credentials are decoded', () => {\n  const opts = {\n    httpsProxy: 'https://use%21r:pas%2As@my.proxy:1234/foo',\n    ...OPTS,\n  }\n  expect(getAgent('https://foo.com/bar', opts)).toEqual({\n    __type: 'https-proxy',\n    auth: 'use!r:pas*s',\n    ca: 'ca',\n    cert: 'cert',\n    host: 'my.proxy',\n    key: 'key',\n    localAddress: 'localAddress',\n    maxSockets: 5,\n    path: '/foo',\n    port: '1234',\n    protocol: 'https:',\n    rejectUnauthorized: true,\n    timeout: 6,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/npm-registry-agent/test"},{"name":"resolve workspace only version aliases","suites":["workspacePrefToNpm"],"updatePoint":{"line":4,"column":46},"line":4,"code":"  test('resolve workspace only version aliases', async () => {\n    expect(workspacePrefToNpm('workspace:^')).toStrictEqual('*')\n    expect(workspacePrefToNpm('workspace:~')).toStrictEqual('*')\n  })","file":"workspacePrefToNpm.test.ts","skipped":false,"dir":"packages/npm-resolver/test"},{"name":"resolve package name aliases","suites":["workspacePrefToNpm"],"updatePoint":{"line":9,"column":36},"line":9,"code":"  test('resolve package name aliases', async () => {\n    expect(workspacePrefToNpm('workspace:is-positive@3.0.0')).toStrictEqual('npm:is-positive@3.0.0')\n    expect(workspacePrefToNpm('workspace:is-positive@*')).toStrictEqual('npm:is-positive@*')\n    expect(workspacePrefToNpm('workspace:is-positive@^')).toStrictEqual('npm:is-positive@*')\n  })","file":"workspacePrefToNpm.test.ts","skipped":false,"dir":"packages/npm-resolver/test"},{"name":"resolve scoped package name aliases","suites":["workspacePrefToNpm"],"updatePoint":{"line":15,"column":43},"line":15,"code":"  test('resolve scoped package name aliases', async () => {\n    expect(\n      workspacePrefToNpm('workspace:@scope/is-positive@1.2.3')\n    ).toStrictEqual('npm:@scope/is-positive@1.2.3')\n    expect(\n      workspacePrefToNpm('workspace:@scope/is-positive@^1.2.3')\n    ).toStrictEqual('npm:@scope/is-positive@^1.2.3')\n    expect(\n      workspacePrefToNpm('workspace:@scope/is-positive@*')\n    ).toStrictEqual('npm:@scope/is-positive@*')\n    expect(\n      workspacePrefToNpm('workspace:@scope/is-positive@~')\n    ).toStrictEqual('npm:@scope/is-positive@*')\n  })","file":"workspacePrefToNpm.test.ts","skipped":false,"dir":"packages/npm-resolver/test"},{"name":"getManifest()","suites":[],"updatePoint":{"line":4,"column":19},"line":4,"code":"test('getManifest()', async () => {\n  const opts = {\n    dir: '',\n    lockfileDir: '',\n    rawConfig: {},\n    registries: {\n      '@scope': 'https://pnpm.io/',\n      default: 'https://registry.npmjs.org/',\n    },\n  }\n\n  const resolve: ResolveFunction = async function (wantedPackage, opts) {\n    expect(opts.registry).toEqual('https://registry.npmjs.org/')\n    return {\n      id: 'foo/1.0.0',\n      latest: '1.0.0',\n      manifest: {\n        name: 'foo',\n        version: '1.0.0',\n      },\n      resolution: {\n        type: 'tarball',\n      },\n      resolvedVia: 'npm-registry',\n    }\n  }\n\n  expect(await getManifest(resolve, opts, 'foo', 'latest')).toStrictEqual({\n    name: 'foo',\n    version: '1.0.0',\n  })\n\n  const resolve2: ResolveFunction = async function (wantedPackage, opts) {\n    expect(opts.registry).toEqual('https://pnpm.io/')\n    return {\n      id: 'foo/2.0.0',\n      latest: '2.0.0',\n      manifest: {\n        name: 'foo',\n        version: '2.0.0',\n      },\n      resolution: {\n        type: 'tarball',\n      },\n      resolvedVia: 'npm-registry',\n    }\n  }\n\n  expect(await getManifest(resolve2, opts, '@scope/foo', 'latest')).toStrictEqual({\n    name: 'foo',\n    version: '2.0.0',\n  })\n})","file":"getManifest.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"outdated()","suites":[],"updatePoint":{"line":25,"column":16},"line":25,"code":"test('outdated()', async () => {\n  const outdatedPkgs = await outdated({\n    currentLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            'from-github': 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b4',\n          },\n          devDependencies: {\n            'is-negative': '1.0.0',\n            'is-positive': '1.0.0',\n          },\n          optionalDependencies: {\n            'linked-1': 'link:../linked-1',\n            'linked-2': 'file:../linked-2',\n          },\n          specifiers: {\n            'is-negative': '^2.1.0',\n            'is-positive': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-negative/2.1.0': {\n          dev: true,\n          resolution: {\n            integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n          },\n        },\n        '/is-positive/1.0.0': {\n          dev: true,\n          resolution: {\n            integrity: 'sha1-iACYVrZKLx632LsBeUGEJK4EUss=',\n          },\n        },\n        'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b4': {\n          name: 'from-github',\n          version: '1.1.0',\n\n          dev: false,\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n      },\n    },\n    getLatestManifest,\n    lockfileDir: 'project',\n    manifest: {\n      name: 'wanted-shrinkwrap',\n      version: '1.0.0',\n\n      devDependencies: {\n        'is-negative': '^2.1.0',\n        'is-positive': '^3.1.0',\n      },\n    },\n    prefix: 'project',\n    wantedLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            'from-github': 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n            'from-github-2': 'github.com/blabla/from-github-2/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n          devDependencies: {\n            'is-negative': '1.1.0',\n            'is-positive': '3.1.0',\n          },\n          optionalDependencies: {\n            'linked-1': 'link:../linked-1',\n            'linked-2': 'file:../linked-2',\n          },\n          specifiers: {\n            'is-negative': '^2.1.0',\n            'is-positive': '^3.1.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-negative/1.1.0': {\n          resolution: {\n            integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n          },\n        },\n        '/is-positive/3.1.0': {\n          resolution: {\n            integrity: 'sha1-hX21hKG6XRyymAUn/DtsQ103sP0=',\n          },\n        },\n        'github.com/blabla/from-github-2/d5f8d5500f7faf593d32e134c1b0043ff69151b3': {\n          name: 'from-github-2',\n          version: '1.0.0',\n\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github-2/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n        'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b3': {\n          name: 'from-github',\n          version: '1.0.0',\n\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n      },\n    },\n  })\n  expect(outdatedPkgs).toStrictEqual([\n    {\n      alias: 'from-github',\n      belongsTo: 'dependencies',\n      current: 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b4',\n      latestManifest: undefined,\n      packageName: 'from-github',\n      wanted: 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n    },\n    {\n      alias: 'from-github-2',\n      belongsTo: 'dependencies',\n      current: undefined,\n      latestManifest: undefined,\n      packageName: 'from-github-2',\n      wanted: 'github.com/blabla/from-github-2/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n    },\n    {\n      alias: 'is-negative',\n      belongsTo: 'devDependencies',\n      current: '1.0.0',\n      latestManifest: {\n        name: 'is-negative',\n        version: '2.1.0',\n      },\n      packageName: 'is-negative',\n      wanted: '1.1.0',\n    },\n    {\n      alias: 'is-positive',\n      belongsTo: 'devDependencies',\n      current: '1.0.0',\n      latestManifest: {\n        name: 'is-positive',\n        version: '3.1.0',\n      },\n      packageName: 'is-positive',\n      wanted: '3.1.0',\n    },\n  ])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"outdated() should return deprecated package even if its current version is latest","suites":[],"updatePoint":{"line":178,"column":87},"line":178,"code":"test('outdated() should return deprecated package even if its current version is latest', async () => {\n  const lockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          'deprecated-pkg': '1.0.0',\n        },\n        specifiers: {\n          'deprecated-pkg': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 5,\n    packages: {\n      '/deprecated-pkg/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n        },\n      },\n    },\n  }\n  const outdatedPkgs = await outdated({\n    currentLockfile: lockfile,\n    getLatestManifest,\n    lockfileDir: 'project',\n    manifest: {\n      name: 'wanted-shrinkwrap',\n      version: '1.0.0',\n\n      dependencies: {\n        'deprecated-pkg': '1.0.0',\n      },\n    },\n    prefix: 'project',\n    wantedLockfile: lockfile,\n  })\n  expect(outdatedPkgs).toStrictEqual([\n    {\n      alias: 'deprecated-pkg',\n      belongsTo: 'dependencies',\n      current: '1.0.0',\n      latestManifest: {\n        deprecated: 'This package is deprecated',\n        name: 'deprecated-pkg',\n        version: '1.0.0',\n      },\n      packageName: 'deprecated-pkg',\n      wanted: '1.0.0',\n    },\n  ])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"using a matcher","suites":[],"updatePoint":{"line":231,"column":21},"line":231,"code":"test('using a matcher', async () => {\n  const outdatedPkgs = await outdated({\n    currentLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            'from-github': 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b4',\n            'is-negative': '1.0.0',\n            'is-positive': '1.0.0',\n            'linked-1': 'link:../linked-1',\n            'linked-2': 'file:../linked-2',\n          },\n          specifiers: {\n            'is-negative': '^2.1.0',\n            'is-positive': '^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-negative/2.1.0': {\n          resolution: {\n            integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n          },\n        },\n        '/is-positive/1.0.0': {\n          resolution: {\n            integrity: 'sha1-iACYVrZKLx632LsBeUGEJK4EUss=',\n          },\n        },\n        'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b4': {\n          name: 'from-github',\n          version: '1.1.0',\n\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n      },\n    },\n    getLatestManifest,\n    lockfileDir: 'wanted-shrinkwrap',\n    manifest: {\n      name: 'wanted-shrinkwrap',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '^2.1.0',\n        'is-positive': '^3.1.0',\n      },\n    },\n    match: (dependencyName) => dependencyName === 'is-negative',\n    prefix: 'wanted-shrinkwrap',\n    wantedLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            'from-github': 'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n            'from-github-2': 'github.com/blabla/from-github-2/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n            'is-negative': '1.1.0',\n            'is-positive': '3.1.0',\n            'linked-1': 'link:../linked-1',\n            'linked-2': 'file:../linked-2',\n          },\n          specifiers: {\n            'is-negative': '^2.1.0',\n            'is-positive': '^3.1.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-negative/1.1.0': {\n          resolution: {\n            integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n          },\n        },\n        '/is-positive/3.1.0': {\n          resolution: {\n            integrity: 'sha1-hX21hKG6XRyymAUn/DtsQ103sP0=',\n          },\n        },\n        'github.com/blabla/from-github-2/d5f8d5500f7faf593d32e134c1b0043ff69151b3': {\n          name: 'from-github-2',\n          version: '1.0.0',\n\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github-2/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n        'github.com/blabla/from-github/d5f8d5500f7faf593d32e134c1b0043ff69151b3': {\n          name: 'from-github',\n          version: '1.0.0',\n\n          resolution: {\n            tarball: 'https://codeload.github.com/blabla/from-github/tar.gz/d5f8d5500f7faf593d32e134c1b0043ff69151b3',\n          },\n        },\n      },\n    },\n  })\n  expect(outdatedPkgs).toStrictEqual([\n    {\n      alias: 'is-negative',\n      belongsTo: 'dependencies',\n      current: '1.0.0',\n      latestManifest: {\n        name: 'is-negative',\n        version: '2.1.0',\n      },\n      packageName: 'is-negative',\n      wanted: '1.1.0',\n    },\n  ])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"outdated() aliased dependency","suites":[],"updatePoint":{"line":347,"column":35},"line":347,"code":"test('outdated() aliased dependency', async () => {\n  const outdatedPkgs = await outdated({\n    currentLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            positive: '/is-positive/1.0.0',\n          },\n          specifiers: {\n            positive: 'npm:is-positive@^1.0.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-positive/1.0.0': {\n          resolution: {\n            integrity: 'sha1-iACYVrZKLx632LsBeUGEJK4EUss=',\n          },\n        },\n      },\n    },\n    getLatestManifest,\n    lockfileDir: 'project',\n    manifest: {\n      name: 'wanted-shrinkwrap',\n      version: '1.0.0',\n\n      dependencies: {\n        positive: 'npm:is-positive@^3.1.0',\n      },\n    },\n    prefix: 'project',\n    wantedLockfile: {\n      importers: {\n        '.': {\n          dependencies: {\n            positive: '/is-positive/3.1.0',\n          },\n          specifiers: {\n            positive: 'npm:is-positive@^3.1.0',\n          },\n        },\n      },\n      lockfileVersion: 5,\n      packages: {\n        '/is-positive/3.1.0': {\n          resolution: {\n            integrity: 'sha1-hX21hKG6XRyymAUn/DtsQ103sP0=',\n          },\n        },\n      },\n    },\n  })\n  expect(outdatedPkgs).toStrictEqual([\n    {\n      alias: 'positive',\n      belongsTo: 'dependencies',\n      current: '1.0.0',\n      latestManifest: {\n        name: 'is-positive',\n        version: '3.1.0',\n      },\n      packageName: 'is-positive',\n      wanted: '3.1.0',\n    },\n  ])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"a dependency is not outdated if it is newer than the latest version","suites":[],"updatePoint":{"line":416,"column":73},"line":416,"code":"test('a dependency is not outdated if it is newer than the latest version', async () => {\n  const lockfile = {\n    importers: {\n      '.': {\n        dependencies: {\n          foo: '1.0.0',\n          foo2: '2.0.0-0',\n          foo3: '2.0.0',\n        },\n        specifiers: {\n          foo: '^1.0.0',\n          foo2: '2.0.0-0',\n          foo3: '2.0.0',\n        },\n      },\n    },\n    lockfileVersion: 5,\n    packages: {\n      '/foo/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n        },\n      },\n      '/foo2/2.0.0-0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n        },\n      },\n      '/foo3/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-8Nhjd6oVpkw0lh84rCqb4rQKEYc=',\n        },\n      },\n    },\n  }\n  const outdatedPkgs = await outdated({\n    currentLockfile: lockfile,\n    getLatestManifest: async (packageName) => {\n      switch (packageName) {\n      case 'foo':\n        return {\n          name: 'foo',\n          version: '0.1.0',\n        }\n      case 'foo2':\n        return {\n          name: 'foo2',\n          version: '1.0.0',\n        }\n      case 'foo3':\n        return {\n          name: 'foo3',\n          version: '2.0.0',\n        }\n      }\n      return null\n    },\n    lockfileDir: 'project',\n    manifest: {\n      name: 'pkg',\n      version: '1.0.0',\n\n      dependencies: {\n        foo: '^1.0.0',\n        foo2: '2.0.0-0',\n        foo3: '2.0.0',\n      },\n    },\n    prefix: 'project',\n    wantedLockfile: lockfile,\n  })\n  expect(outdatedPkgs).toStrictEqual([])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"outdated() should [] when there is no dependency","suites":[],"updatePoint":{"line":493,"column":54},"line":493,"code":"test('outdated() should [] when there is no dependency', async () => {\n  const outdatedPkgs = await outdated({\n    currentLockfile: null,\n    getLatestManifest: async () => {\n      return null\n    },\n    lockfileDir: 'project',\n    manifest: {\n      name: 'pkg',\n      version: '1.0.0',\n    },\n    prefix: 'project',\n    wantedLockfile: null,\n  })\n  expect(outdatedPkgs).toStrictEqual([])\n})","file":"outdated.spec.ts","skipped":false,"dir":"packages/outdated/test"},{"name":"getBinsFromPkg()","suites":[],"updatePoint":{"line":4,"column":22},"line":4,"code":"test('getBinsFromPkg()', async () => {\n  expect(\n    await getBinsFromPkg({\n      bin: 'one-bin',\n      name: 'one-bin',\n      version: '1.0.0',\n    }, process.cwd())).toStrictEqual(\n    [{\n      name: 'one-bin',\n      path: path.resolve('one-bin'),\n    }]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"getBinsFromPkg() should allow $ as command name","suites":[],"updatePoint":{"line":18,"column":53},"line":18,"code":"test('getBinsFromPkg() should allow $ as command name', async () => {\n  expect(\n    await getBinsFromPkg({\n      bin: {\n        $: './undollar.js',\n      },\n      name: 'undollar',\n      version: '1.0.0',\n    }, process.cwd())).toStrictEqual(\n    [{\n      name: '$',\n      path: path.resolve('undollar.js'),\n    }]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"find all the bin files from a bin directory","suites":[],"updatePoint":{"line":34,"column":49},"line":34,"code":"test('find all the bin files from a bin directory', async () => {\n  const fixtures = path.join(__dirname, 'fixtures')\n  expect(\n    await getBinsFromPkg({\n      name: 'bin-dir',\n      version: '1.0.0',\n\n      directories: { bin: 'bin-dir' },\n    }, fixtures)).toStrictEqual(\n    [\n      {\n        name: 'rootBin.js',\n        path: path.join(fixtures, 'bin-dir/rootBin.js'),\n      },\n      {\n        name: 'subBin.js',\n        path: path.join(fixtures, 'bin-dir/subdir/subBin.js'),\n      },\n    ]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"get bin of scoped package","suites":[],"updatePoint":{"line":56,"column":31},"line":56,"code":"test('get bin of scoped package', async () => {\n  expect(\n    await getBinsFromPkg({\n      bin: 'bin.js',\n      name: '@foo/bar',\n      version: '1.0.0',\n    }, process.cwd())).toStrictEqual(\n    [{\n      name: 'bar',\n      path: path.resolve('bin.js'),\n    }]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"skip dangerous bin names","suites":[],"updatePoint":{"line":70,"column":30},"line":70,"code":"test('skip dangerous bin names', async () => {\n  expect(\n    await getBinsFromPkg({\n      name: 'foo',\n      version: '1.0.0',\n\n      bin: {\n        '../bad': './bad',\n        '..\\\\bad': './bad',\n        good: './good',\n        '~/bad': './bad',\n      },\n    }, process.cwd())).toStrictEqual(\n    [\n      {\n        name: 'good',\n        path: path.resolve('good'),\n      },\n    ]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"skip dangerous bin locations","suites":[],"updatePoint":{"line":92,"column":34},"line":92,"code":"test('skip dangerous bin locations', async () => {\n  expect(\n    await getBinsFromPkg({\n      name: 'foo',\n      version: '1.0.0',\n\n      bin: {\n        bad: '../bad',\n        good: './good',\n      },\n    }, process.cwd())).toStrictEqual(\n    [\n      {\n        name: 'good',\n        path: path.resolve('good'),\n      },\n    ]\n  )\n})","file":"index.ts","skipped":false,"dir":"packages/package-bins/test"},{"name":"getSystemNodeVersion() executed from an executable pnpm CLI","suites":[],"updatePoint":{"line":10,"column":65},"line":10,"code":"test('getSystemNodeVersion() executed from an executable pnpm CLI', () => {\n  process['pkg'] = {}\n  expect(getSystemNodeVersionNonCached()).toBe('v10.0.0')\n  expect(execa.sync).toHaveBeenCalledWith('node', ['--version'])\n})","file":"getSystemNodeVersion.test.ts","skipped":false,"dir":"packages/package-is-installable/test"},{"name":"getSystemNodeVersion() from a non-executable pnpm CLI","suites":[],"updatePoint":{"line":16,"column":59},"line":16,"code":"test('getSystemNodeVersion() from a non-executable pnpm CLI', () => {\n  delete process['pkg']\n  expect(getSystemNodeVersionNonCached()).toBe(process.version)\n})","file":"getSystemNodeVersion.test.ts","skipped":false,"dir":"packages/package-is-installable/test"},{"name":"equalOrSemverEqual()","suites":[],"updatePoint":{"line":3,"column":26},"line":3,"code":"test('equalOrSemverEqual()', () => {\n  expect(equalOrSemverEqual('a', 'a')).toBeTruthy()\n  expect(equalOrSemverEqual('a', 'b')).toBeFalsy()\n  expect(equalOrSemverEqual('1.0.0', 'v1.0.0')).toBeTruthy()\n})","file":"equalOrSemverEqual.test.ts","skipped":false,"dir":"packages/package-requester/test"},{"name":"packageImportMethod=auto: clone files by default","suites":[],"updatePoint":{"line":24,"column":54},"line":24,"code":"test('packageImportMethod=auto: clone files by default', async () => {\n  const importPackage = createImportPackage('auto')\n  fsMock.promises.copyFile = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('clone')\n  expect(fsMock.promises.copyFile).toBeCalledWith(\n    path.join('hash1'),\n    path.join('project', '_tmp', 'package.json'),\n    fsMock.constants.COPYFILE_FICLONE_FORCE\n  )\n  expect(fsMock.promises.copyFile).toBeCalledWith(\n    path.join('hash2'),\n    path.join('project', '_tmp', 'index.js'),\n    fsMock.constants.COPYFILE_FICLONE_FORCE\n  )\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=auto: link files if cloning fails","suites":[],"updatePoint":{"line":48,"column":59},"line":48,"code":"test('packageImportMethod=auto: link files if cloning fails', async () => {\n  const importPackage = createImportPackage('auto')\n  fsMock.promises.copyFile = jest.fn(() => {\n    throw new Error('This file system does not support cloning')\n  })\n  fsMock.promises.link = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('hardlink')\n  expect(fsMock.promises.link).toBeCalledWith(path.join('hash1'), path.join('project', '_tmp', 'package.json'))\n  expect(fsMock.promises.link).toBeCalledWith(path.join('hash2'), path.join('project', '_tmp', 'index.js'))\n  expect(fsMock.promises.copyFile).toBeCalled()\n  fsMock.promises.copyFile.mockClear()\n\n  // The copy function will not be called again\n  expect(await importPackage('project2/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('hardlink')\n  expect(fsMock.promises.copyFile).not.toBeCalled()\n  expect(fsMock.promises.link).toBeCalledWith(path.join('hash1'), path.join('project2', '_tmp', 'package.json'))\n  expect(fsMock.promises.link).toBeCalledWith(path.join('hash2'), path.join('project2', '_tmp', 'index.js'))\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=auto: link files if cloning fails and even hard linking fails but not with EXDEV error","suites":[],"updatePoint":{"line":82,"column":112},"line":82,"code":"test('packageImportMethod=auto: link files if cloning fails and even hard linking fails but not with EXDEV error', async () => {\n  const importPackage = createImportPackage('auto')\n  fsMock.promises.copyFile = jest.fn(() => {\n    throw new Error('This file system does not support cloning')\n  })\n  let linkFirstCall = true\n  fsMock.promises.link = jest.fn(() => {\n    if (linkFirstCall) {\n      linkFirstCall = false\n      throw new Error()\n    }\n  })\n  fsMock.promises.rename = jest.fn()\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('hardlink')\n  expect(fsMock.promises.link).toBeCalledWith(path.join('hash2'), path.join('project', '_tmp', 'index.js'))\n  expect(fsMock.promises.link).toBeCalledTimes(2)\n  expect(fsMock.promises.copyFile).toBeCalledTimes(1)\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=auto: chooses copying if cloning and hard linking is not possible","suites":[],"updatePoint":{"line":107,"column":91},"line":107,"code":"test('packageImportMethod=auto: chooses copying if cloning and hard linking is not possible', async () => {\n  const importPackage = createImportPackage('auto')\n  fsMock.promises.copyFile = jest.fn((src: string, dest: string, flags?: number) => {\n    if (flags === fsMock.constants.COPYFILE_FICLONE_FORCE) {\n      throw new Error('This file system does not support cloning')\n    }\n  })\n  fsMock.promises.link = jest.fn(() => {\n    throw new Error('EXDEV: cross-device link not permitted')\n  })\n  fsMock.promises.rename = jest.fn()\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('copy')\n  expect(fsMock.promises.copyFile).toBeCalledWith(path.join('hash2'), path.join('project', '_tmp', 'index.js'))\n  expect(fsMock.promises.copyFile).toBeCalledTimes(2)\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=hardlink: fall back to copying if hardlinking fails","suites":[],"updatePoint":{"line":129,"column":77},"line":129,"code":"test('packageImportMethod=hardlink: fall back to copying if hardlinking fails', async () => {\n  const importPackage = createImportPackage('hardlink')\n  fsMock.promises.link = jest.fn((src: string, dest: string) => {\n    if (dest.endsWith('license')) {\n      const err = new Error('')\n      err['code'] = 'EEXIST'\n      throw err\n    }\n    throw new Error('This file system does not support hard linking')\n  })\n  fsMock.promises.copyFile = jest.fn()\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n      license: 'hash3',\n    },\n    force: false,\n    fromStore: false,\n  })).toBe('hardlink')\n  expect(fsMock.promises.link).toBeCalledTimes(3)\n  expect(fsMock.promises.copyFile).toBeCalledTimes(2) // One time the target already exists, so it won't be copied\n  expect(fsMock.promises.copyFile).toBeCalledWith(path.join('hash1'), path.join('project', '_tmp', 'package.json'))\n  expect(fsMock.promises.copyFile).toBeCalledWith(path.join('hash2'), path.join('project', '_tmp', 'index.js'))\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=hardlink does not relink package from store if package.json is linked from the store","suites":[],"updatePoint":{"line":155,"column":110},"line":155,"code":"test('packageImportMethod=hardlink does not relink package from store if package.json is linked from the store', async () => {\n  const importPackage = createImportPackage('hardlink')\n  fsMock.promises.copyFile = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  fsMock.promises.stat = jest.fn(() => ({ ino: 1 }))\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: true,\n  })).toBe(undefined)\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=hardlink relinks package from store if package.json is not linked from the store","suites":[],"updatePoint":{"line":170,"column":106},"line":170,"code":"test('packageImportMethod=hardlink relinks package from store if package.json is not linked from the store', async () => {\n  globalInfo.mockReset()\n  const importPackage = createImportPackage('hardlink')\n  fsMock.promises.copyFile = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  let ino = 0\n  fsMock.promises.stat = jest.fn(() => ({ ino: ++ino }))\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: true,\n  })).toBe('hardlink')\n  expect(globalInfo).toBeCalledWith('Relinking project/package from the store')\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=hardlink does not relink package from store if package.json is not present in the store","suites":[],"updatePoint":{"line":188,"column":113},"line":188,"code":"test('packageImportMethod=hardlink does not relink package from store if package.json is not present in the store', async () => {\n  const importPackage = createImportPackage('hardlink')\n  fsMock.promises.copyFile = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  fsMock.promises.stat = jest.fn((file) => {\n    expect(typeof file).toBe('string')\n    return { ino: 1 }\n  })\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n    },\n    force: false,\n    fromStore: true,\n  })).toBe(undefined)\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"packageImportMethod=hardlink links packages when they are not found","suites":[],"updatePoint":{"line":205,"column":73},"line":205,"code":"test('packageImportMethod=hardlink links packages when they are not found', async () => {\n  globalInfo.mockReset()\n  const importPackage = createImportPackage('hardlink')\n  fsMock.promises.copyFile = jest.fn()\n  fsMock.promises.rename = jest.fn()\n  fsMock.promises.stat = jest.fn((file) => {\n    if (file === path.join('project/package', 'package.json')) {\n      const err = new Error()\n      err['code'] = 'ENOENT'\n      throw err\n    }\n    return { ino: 0 }\n  })\n  expect(await importPackage('project/package', {\n    filesMap: {\n      'index.js': 'hash2',\n      'package.json': 'hash1',\n    },\n    force: false,\n    fromStore: true,\n  })).toBe('hardlink')\n  expect(globalInfo).not.toBeCalledWith('Relinking project/package from the store')\n})","file":"createImportPackage.spec.ts","skipped":false,"dir":"packages/package-store/test"},{"name":"a command is recursive if it has a --filter option","suites":[],"updatePoint":{"line":15,"column":56},"line":15,"code":"test('a command is recursive if it has a --filter option', async () => {\n  const { options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { filter: [String, Array] },\n  }, ['--filter', 'foo', 'update'])\n  expect(cmd).toBe('update')\n  expect(options).toHaveProperty(['recursive'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"a command is recursive if it has a --filter-prod option","suites":[],"updatePoint":{"line":24,"column":61},"line":24,"code":"test('a command is recursive if it has a --filter-prod option', async () => {\n  const { options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { 'filter-prod': [String, Array] },\n  }, ['--filter-prod', 'foo', 'update'])\n  expect(cmd).toBe('update')\n  expect(options).toHaveProperty(['recursive'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"a command is recursive if -r option is used","suites":[],"updatePoint":{"line":33,"column":49},"line":33,"code":"test('a command is recursive if -r option is used', async () => {\n  const { options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { recursive: Boolean },\n    universalShorthands: { r: '--recursive' },\n  }, ['-r', 'update'])\n  expect(cmd).toBe('update')\n  expect(options).toHaveProperty(['recursive'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"a command is recursive if --recursive option is used","suites":[],"updatePoint":{"line":43,"column":58},"line":43,"code":"test('a command is recursive if --recursive option is used', async () => {\n  const { options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { recursive: Boolean },\n  }, ['-r', 'update'])\n  expect(cmd).toBe('update')\n  expect(options).toHaveProperty(['recursive'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"recursive is returned as the command name if no subcommand passed","suites":[],"updatePoint":{"line":52,"column":71},"line":52,"code":"test('recursive is returned as the command name if no subcommand passed', async () => {\n  const { options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { filter: [String, Array] },\n  }, ['recursive'])\n  expect(cmd).toBe('recursive')\n  expect(options).toHaveProperty(['recursive'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"when running a global command inside a workspace, the workspace should be ignored","suites":[],"updatePoint":{"line":61,"column":87},"line":61,"code":"test('when running a global command inside a workspace, the workspace should be ignored', async () => {\n  const { workspaceDir } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { global: Boolean },\n  }, ['--global', 'add', 'foo'])\n  expect(workspaceDir).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"when running with --ignore-workspace option inside a workspace, the workspace should be ignored","suites":[],"updatePoint":{"line":69,"column":101},"line":69,"code":"test('when running with --ignore-workspace option inside a workspace, the workspace should be ignored', async () => {\n  const { workspaceDir } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: { global: Boolean },\n  }, ['--ignore-workspace', 'add', 'foo'])\n  expect(workspaceDir).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"command is used recursively","suites":[],"updatePoint":{"line":77,"column":33},"line":77,"code":"test('command is used recursively', async () => {\n  const { cmd, options } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    universalOptionsTypes: {},\n  }, ['recursive', 'outdated'])\n  expect(cmd).toBe('outdated')\n  expect(options.recursive).toBe(true)\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"the install command is converted to add when called with args","suites":[],"updatePoint":{"line":86,"column":67},"line":86,"code":"test('the install command is converted to add when called with args', async () => {\n  const { params, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n  }, ['install', 'rimraf@1'])\n  expect(cmd).toBe('add')\n  expect(params).toStrictEqual(['rimraf@1'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"the \"i\" command is converted to add when called with args","suites":[],"updatePoint":{"line":94,"column":63},"line":94,"code":"test('the \"i\" command is converted to add when called with args', async () => {\n  const { params, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getCommandLongName: (commandName) => commandName === 'i' ? 'install' : commandName,\n  }, ['i', 'rimraf@1'])\n  expect(cmd).toBe('add')\n  expect(params).toStrictEqual(['rimraf@1'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"detect unknown options","suites":[],"updatePoint":{"line":103,"column":28},"line":103,"code":"test('detect unknown options', async () => {\n  const { unknownOptions } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getTypesByCommandName: (commandName: string) => {\n      if (commandName === 'install') {\n        return {\n          bar: Boolean,\n          recursive: Boolean,\n          registry: String,\n        }\n      }\n      return {}\n    },\n    universalOptionsTypes: { filter: [String, Array] },\n  }, ['install', '--save-dev', '--registry=https://example.com', '--qar', '--filter=packages'])\n  expect(Array.from(unknownOptions.entries())).toStrictEqual([['save-dev', []], ['qar', ['bar']]])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"allow any option that starts with \"config.\"","suites":[],"updatePoint":{"line":121,"column":49},"line":121,"code":"test('allow any option that starts with \"config.\"', async () => {\n  const { options, unknownOptions } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getTypesByCommandName: (commandName: string) => {\n      if (commandName === 'install') {\n        return {\n          bar: Boolean,\n          recursive: Boolean,\n          registry: String,\n        }\n      }\n      return {}\n    },\n    universalOptionsTypes: { filter: [String, Array] },\n  }, ['install', '--config.save-dev', '--registry=https://example.com', '--config.qar', '--filter=packages'])\n  expect(Array.from(unknownOptions.entries())).toStrictEqual([])\n  expect(options.qar).toBe(true)\n  expect(options['save-dev']).toBe(true)\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"do not incorrectly change \"install\" command to \"add\"","suites":[],"updatePoint":{"line":141,"column":58},"line":141,"code":"test('do not incorrectly change \"install\" command to \"add\"', async () => {\n  const { cmd, fallbackCommandUsed } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getTypesByCommandName: (commandName: string) => {\n      switch (commandName) {\n      case 'install': return { 'network-concurrency': Number }\n      default: return {}\n      }\n    },\n    universalOptionsTypes: {\n      prefix: String,\n    },\n    universalShorthands: {\n      C: '--prefix',\n      r: '--recursive',\n    },\n  }, ['install', '-C', os.homedir(), '--network-concurrency', '1'])\n  expect(cmd).toBe('install')\n  expect(fallbackCommandUsed).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"if a help option is used, set cmd to \"help\"","suites":[],"updatePoint":{"line":162,"column":49},"line":162,"code":"test('if a help option is used, set cmd to \"help\"', async () => {\n  const { cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n  }, ['install', '--help'])\n  expect(cmd).toBe('help')\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"if a help option is used with an unknown command, do not set cmd to \"help\"","suites":[],"updatePoint":{"line":169,"column":80},"line":169,"code":"test('if a help option is used with an unknown command, do not set cmd to \"help\"', async () => {\n  const { cmd, fallbackCommandUsed } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getCommandLongName: () => null,\n    fallbackCommand: 'run',\n  }, ['eslint', '--help'])\n  expect(cmd).toBe('run')\n  expect(fallbackCommandUsed).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"no command","suites":[],"updatePoint":{"line":179,"column":16},"line":179,"code":"test('no command', async () => {\n  const { cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n  }, ['--version'])\n  expect(cmd).toBe(null)\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"use command-specific shorthands","suites":[],"updatePoint":{"line":186,"column":37},"line":186,"code":"test('use command-specific shorthands', async () => {\n  const { options } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    getTypesByCommandName: (commandName: string) => {\n      if (commandName === 'install') {\n        return {\n          dev: Boolean,\n        }\n      }\n      return {}\n    },\n    shorthandsByCommandName: {\n      install: { D: '--dev' },\n    },\n  }, ['install', '-D'])\n  expect(options).toHaveProperty(['dev'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"any unknown command is treated as a script","suites":[],"updatePoint":{"line":204,"column":48},"line":204,"code":"test('any unknown command is treated as a script', async () => {\n  const { options, cmd, params, fallbackCommandUsed } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    fallbackCommand: 'run',\n    getCommandLongName: () => null,\n    universalOptionsTypes: { filter: [String, Array] },\n  }, ['--recursive', 'foo'])\n  expect(cmd).toBe('run')\n  expect(params).toStrictEqual(['foo'])\n  expect(options).toHaveProperty(['recursive'])\n  expect(fallbackCommandUsed).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"run script with --help before script name is help command","suites":[],"updatePoint":{"line":217,"column":63},"line":217,"code":"test('run script with --help before script name is help command', async () => {\n  const { cmd, params } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    fallbackCommand: 'run',\n  }, ['run', '--help', 'foo'])\n  expect(cmd).toBe('help')\n  expect(params).toStrictEqual(['run', 'foo'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"run script arguments are correct for: %s","suites":[],"line":226,"code":"test.each([\n  ['foo', { params: 'foo', options: {} }],\n  ['foo --bar baz --qux', { params: 'foo --bar baz --qux', options: {} }],\n  ['-r foo', { params: 'foo', options: { recursive: true } }],\n  ['-r foo --bar baz --qux', { params: 'foo --bar baz --qux', options: { recursive: true } }],\n\n  // Edge case where option value is the script name. Fortunately nopt handles this correctly.\n  ['--test-pattern test test foo', { params: 'test foo', options: { 'test-pattern': ['test'] } }],\n\n  // Ensure even builtin flags are passed to the script.\n  ['foo -r', { params: 'foo -r', options: {} }],\n  ['foo --recursive', { params: 'foo --recursive', options: {} }],\n  ['foo -h', { params: 'foo -h', options: {} }],\n  ['foo --help', { params: 'foo --help', options: {} }],\n  ['foo --filter=bar', { params: 'foo --filter=bar', options: {} }],\n])('run script arguments are correct for: %s', async (testInput, expected) => {\n  for (const testWithCommandFallback of [true, false]) {\n    // Whether or not the leading \"run\" portion of the command is written\n    // shouldn't affect its arg parsing. Test both scenarios for good measure.\n    const input = [...(testWithCommandFallback ? [] : ['run']), ...testInput.split(' ')]\n\n    const { options, cmd, params, fallbackCommandUsed } = await parseCliArgs({\n      ...DEFAULT_OPTS,\n      fallbackCommand: 'run',\n      getCommandLongName: (name) => name === 'run' ? 'run' : null,\n      universalOptionsTypes: { filter: [String, Array], 'test-pattern': [String, Array] },\n    }, input)\n    expect(cmd).toBe('run')\n    expect(params).toStrictEqual(expected.params.split(' '))\n    expect(options).toStrictEqual(expected.options)\n\n    if (testWithCommandFallback) {\n      expect(fallbackCommandUsed).toBeTruthy()\n    }\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"don't use the fallback command if no command is present","suites":[],"updatePoint":{"line":263,"column":61},"line":263,"code":"test(\"don't use the fallback command if no command is present\", async () => {\n  const { cmd, params } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    fallbackCommand: 'run',\n    getCommandLongName: () => null,\n    universalOptionsTypes: { filter: [String, Array] },\n  }, [])\n  expect(cmd).toBe(null)\n  expect(params).toStrictEqual([])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"--workspace-root changes the directory to the workspace root","suites":[],"updatePoint":{"line":274,"column":66},"line":274,"code":"test('--workspace-root changes the directory to the workspace root', async () => {\n  const { options, workspaceDir } = await parseCliArgs({ ...DEFAULT_OPTS }, ['--workspace-root'])\n  expect(workspaceDir).toBeTruthy()\n  expect(options.dir).toBe(workspaceDir)\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"--workspace-root fails if used with --global","suites":[],"updatePoint":{"line":280,"column":50},"line":280,"code":"test('--workspace-root fails if used with --global', async () => {\n  let err!: PnpmError\n  try {\n    await parseCliArgs({ ...DEFAULT_OPTS }, ['--workspace-root', '--global'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err).toBeTruthy()\n  expect(err.code).toBe('ERR_PNPM_OPTIONS_CONFLICT')\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"--workspace-root fails if used outside of a workspace","suites":[],"updatePoint":{"line":291,"column":59},"line":291,"code":"test('--workspace-root fails if used outside of a workspace', async () => {\n  process.chdir(tempy.directory())\n  let err!: PnpmError\n  try {\n    await parseCliArgs({ ...DEFAULT_OPTS }, ['--workspace-root'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err).toBeTruthy()\n  expect(err.code).toBe('ERR_PNPM_NOT_IN_WORKSPACE')\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"everything after an escape arg is a parameter","suites":[],"updatePoint":{"line":303,"column":51},"line":303,"code":"test('everything after an escape arg is a parameter', async () => {\n  const { params, options, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    escapeArgs: ['exec'],\n  }, ['-r', 'exec', 'rm', '-rf', 'node_modules'])\n  expect(cmd).toBe('exec')\n  expect(options).toHaveProperty(['recursive'])\n  expect(params).toStrictEqual(['rm', '-rf', 'node_modules'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"everything after an escape arg is a parameter, even if it has a help option","suites":[],"updatePoint":{"line":313,"column":81},"line":313,"code":"test('everything after an escape arg is a parameter, even if it has a help option', async () => {\n  const { params, cmd } = await parseCliArgs({\n    ...DEFAULT_OPTS,\n    escapeArgs: ['exec'],\n  }, ['exec', 'rm', '--help'])\n  expect(cmd).toBe('exec')\n  expect(params).toStrictEqual(['rm', '--help'])\n})","file":"index.ts","skipped":false,"dir":"packages/parse-cli-args/test"},{"name":"parseOverrides()","suites":[],"line":3,"code":"test.each([\n  [\n    { foo: '1' },\n    [{ newPref: '1', targetPkg: { name: 'foo' } }],\n  ],\n  [\n    { 'foo@2': '1' },\n    [{ newPref: '1', targetPkg: { name: 'foo', pref: '2' } }],\n  ],\n  [\n    {\n      'foo@>2': '1',\n      'foo@3 || >=2': '1',\n    },\n    [\n      { newPref: '1', targetPkg: { name: 'foo', pref: '>2' } },\n      { newPref: '1', targetPkg: { name: 'foo', pref: '3 || >=2' } },\n    ],\n  ],\n  [\n    {\n      'bar>foo': '2',\n      'bar@1>foo': '2',\n      'bar>foo@1': '2',\n      'bar@1>foo@1': '2',\n    },\n    [\n      { newPref: '2', parentPkg: { name: 'bar' }, targetPkg: { name: 'foo' } },\n      { newPref: '2', parentPkg: { name: 'bar', pref: '1' }, targetPkg: { name: 'foo' } },\n      { newPref: '2', parentPkg: { name: 'bar' }, targetPkg: { name: 'foo', pref: '1' } },\n      { newPref: '2', parentPkg: { name: 'bar', pref: '1' }, targetPkg: { name: 'foo', pref: '1' } },\n    ],\n  ],\n  [\n    {\n      'foo@>2>bar@>2': '1',\n      'foo@3 || >=2>bar@3 || >=2': '1',\n    },\n    [\n      { newPref: '1', parentPkg: { name: 'foo', pref: '>2' }, targetPkg: { name: 'bar', pref: '>2' } },\n      { newPref: '1', parentPkg: { name: 'foo', pref: '3 || >=2' }, targetPkg: { name: 'bar', pref: '3 || >=2' } },\n    ],\n  ],\n])('parseOverrides()', (overrides, expectedResult) => {\n  expect(parseOverrides(overrides)).toEqual(expectedResult)\n})","file":"index.ts","skipped":false,"dir":"packages/parse-overrides/test"},{"name":"parseOverrides() throws an exception on invalid selector","suites":[],"updatePoint":{"line":50,"column":62},"line":50,"code":"test('parseOverrides() throws an exception on invalid selector', () => {\n  expect(() => parseOverrides({ '%': '2' })).toThrow('Cannot parse the \"%\" selector in the overrides')\n})","file":"index.ts","skipped":false,"dir":"packages/parse-overrides/test"},{"name":"pick correct scope","suites":[],"updatePoint":{"line":3,"column":24},"line":3,"code":"test('pick correct scope', () => {\n  const registries = {\n    default: 'https://registry.npmjs.org/',\n    '@private': 'https://private.registry.com/',\n  }\n  expect(pickRegistryForPackage(registries, '@private/lodash')).toBe('https://private.registry.com/')\n  expect(pickRegistryForPackage(registries, '@random/lodash')).toBe('https://registry.npmjs.org/')\n  expect(pickRegistryForPackage(registries, '@random/lodash', 'npm:@private/lodash@1')).toBe('https://private.registry.com/')\n})","file":"index.spec.ts","skipped":false,"dir":"packages/pick-registry-for-package/test"},{"name":"create package graph","suites":[],"updatePoint":{"line":13,"column":26},"line":13,"code":"test('create package graph', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        name: 'bar',\n        version: '1.0.0',\n\n        dependencies: {\n          foo: '^1.0.0',\n          'is-positive': '1.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n        version: '1.0.0',\n\n        dependencies: {\n          bar: '^10.0.0',\n        },\n      },\n    },\n    {\n      dir: BAR2_PATH,\n      manifest: {\n        name: 'bar',\n        version: '2.0.0',\n\n        dependencies: {\n          foo: '^2.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO2_PATH,\n      manifest: {\n        name: 'foo',\n        version: '2.0.0',\n      },\n    },\n  ])\n  expect(result.unmatched).toStrictEqual([{ pkgName: 'bar', range: '^10.0.0' }])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          name: 'bar',\n          version: '1.0.0',\n\n          dependencies: {\n            foo: '^1.0.0',\n            'is-positive': '1.0.0',\n          },\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n          version: '1.0.0',\n\n          dependencies: {\n            bar: '^10.0.0',\n          },\n        },\n      },\n    },\n    [BAR2_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR2_PATH,\n        manifest: {\n          name: 'bar',\n          version: '2.0.0',\n\n          dependencies: {\n            foo: '^2.0.0',\n          },\n        },\n      },\n    },\n    [FOO2_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO2_PATH,\n        manifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"create package graph for local directory dependencies","suites":[],"updatePoint":{"line":115,"column":59},"line":115,"code":"test('create package graph for local directory dependencies', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        name: 'bar',\n        version: '1.0.0',\n\n        dependencies: {\n          foo: '../foo',\n          'is-positive': '1.0.0',\n          'weird-dep': ':aaaaa', // weird deps are skipped\n        },\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n        version: '1.0.0',\n\n        dependencies: {\n          bar: '^10.0.0',\n        },\n      },\n    },\n    {\n      dir: BAR2_PATH,\n      manifest: {\n        name: 'bar',\n        version: '2.0.0',\n\n        dependencies: {\n          foo: 'file:../foo@2',\n        },\n      },\n    },\n    {\n      dir: FOO2_PATH,\n      manifest: {\n        name: 'foo',\n        version: '2.0.0',\n      },\n    },\n  ])\n  expect(result.unmatched).toStrictEqual([{ pkgName: 'bar', range: '^10.0.0' }])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          name: 'bar',\n          version: '1.0.0',\n\n          dependencies: {\n            foo: '../foo',\n            'is-positive': '1.0.0',\n            'weird-dep': ':aaaaa',\n          },\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n          version: '1.0.0',\n\n          dependencies: {\n            bar: '^10.0.0',\n          },\n        },\n      },\n    },\n    [BAR2_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR2_PATH,\n        manifest: {\n          name: 'bar',\n          version: '2.0.0',\n\n          dependencies: {\n            foo: 'file:../foo@2',\n          },\n        },\n      },\n    },\n    [FOO2_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO2_PATH,\n        manifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"create package graph ignoring the workspace protocol","suites":[],"updatePoint":{"line":219,"column":58},"line":219,"code":"test('create package graph ignoring the workspace protocol', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        name: 'bar',\n        version: '1.0.0',\n\n        dependencies: {\n          foo: 'workspace:^1.0.0',\n          'is-positive': '1.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n        version: '1.0.0',\n\n        dependencies: {\n          bar: '^10.0.0',\n        },\n      },\n    },\n    {\n      dir: BAR2_PATH,\n      manifest: {\n        name: 'bar',\n        version: '2.0.0',\n\n        dependencies: {\n          foo: 'workspace:^2.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO2_PATH,\n      manifest: {\n        name: 'foo',\n        version: '2.0.0',\n      },\n    },\n    {\n      dir: BAR3_PATH,\n      manifest: {\n        name: 'bar',\n        version: '3.0.0',\n\n        dependencies: {\n          foo: 'workspace:^',\n        },\n      },\n    },\n    {\n      dir: BAR4_PATH,\n      manifest: {\n        name: 'bar',\n        version: '4.0.0',\n\n        dependencies: {\n          foo: 'workspace:~',\n        },\n      },\n    },\n  ])\n  expect(result.unmatched).toStrictEqual([{ pkgName: 'bar', range: '^10.0.0' }])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          name: 'bar',\n          version: '1.0.0',\n\n          dependencies: {\n            foo: 'workspace:^1.0.0',\n            'is-positive': '1.0.0',\n          },\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n          version: '1.0.0',\n\n          dependencies: {\n            bar: '^10.0.0',\n          },\n        },\n      },\n    },\n    [BAR2_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR2_PATH,\n        manifest: {\n          name: 'bar',\n          version: '2.0.0',\n\n          dependencies: {\n            foo: 'workspace:^2.0.0',\n          },\n        },\n      },\n    },\n    [FOO2_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO2_PATH,\n        manifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n      },\n    },\n    [BAR3_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR3_PATH,\n        manifest: {\n          name: 'bar',\n          version: '3.0.0',\n\n          dependencies: {\n            foo: 'workspace:^',\n          },\n        },\n      },\n    },\n    [BAR4_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR4_PATH,\n        manifest: {\n          name: 'bar',\n          version: '4.0.0',\n\n          dependencies: {\n            foo: 'workspace:~',\n          },\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"create package graph respects linked-workspace-packages = false","suites":[],"updatePoint":{"line":371,"column":69},"line":371,"code":"test('create package graph respects linked-workspace-packages = false', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        dependencies: {\n          foo: 'workspace:*',\n        },\n        name: 'bar',\n        version: '1.0.0',\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        dependencies: {\n          bar: '^10.0.0',\n        },\n        name: 'foo',\n        version: '1.0.1',\n      },\n    },\n    {\n      dir: BAR2_PATH,\n      manifest: {\n        dependencies: {\n          foo: '1.0.1',\n        },\n        name: 'bar',\n        version: '2.0.0',\n      },\n    },\n    {\n      dir: BAR3_PATH,\n      manifest: {\n        dependencies: {\n          foo: 'workspace:~1.0.0',\n        },\n        name: 'bar',\n        version: '3.0.0',\n      },\n    },\n    {\n      dir: BAR4_PATH,\n      manifest: {\n        dependencies: {\n          foo: 'workspace:^',\n        },\n        name: 'bar',\n        version: '4.0.0',\n      },\n    },\n    {\n      dir: BAR5_PATH,\n      manifest: {\n        dependencies: {\n          foo: 'workspace:~',\n        },\n        name: 'bar',\n        version: '5.0.0',\n      },\n    },\n  ], { linkWorkspacePackages: false })\n  expect(result.unmatched).toStrictEqual([{ pkgName: 'bar', range: '^10.0.0' }, { pkgName: 'foo', range: '1.0.1' }])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          dependencies: {\n            foo: 'workspace:*',\n          },\n          name: 'bar',\n          version: '1.0.0',\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          dependencies: {\n            bar: '^10.0.0',\n          },\n          name: 'foo',\n          version: '1.0.1',\n        },\n      },\n    },\n    [BAR2_PATH]: {\n      // no workspace range, so this shouldn't have any\n      // workspace dependencies\n      dependencies: [],\n      package: {\n        dir: BAR2_PATH,\n        manifest: {\n          dependencies: {\n            foo: '1.0.1',\n          },\n          name: 'bar',\n          version: '2.0.0',\n        },\n      },\n    },\n    [BAR3_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR3_PATH,\n        manifest: {\n          dependencies: {\n            foo: 'workspace:~1.0.0',\n          },\n          name: 'bar',\n          version: '3.0.0',\n        },\n      },\n    },\n    [BAR4_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR4_PATH,\n        manifest: {\n          dependencies: {\n            foo: 'workspace:^',\n          },\n          name: 'bar',\n          version: '4.0.0',\n        },\n      },\n    },\n    [BAR5_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR5_PATH,\n        manifest: {\n          dependencies: {\n            foo: 'workspace:~',\n          },\n          name: 'bar',\n          version: '5.0.0',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"create package graph respects ignoreDevDeps = true","suites":[],"updatePoint":{"line":519,"column":56},"line":519,"code":"test('create package graph respects ignoreDevDeps = true', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        name: 'bar',\n        version: '1.0.0',\n\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        devDependencies: {\n          foo: '^1.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n        version: '1.0.0',\n\n        dependencies: {\n          bar: '^10.0.0',\n        },\n      },\n    },\n    {\n      dir: BAR2_PATH,\n      manifest: {\n        name: 'bar',\n        version: '2.0.0',\n\n        dependencies: {\n          foo: '^2.0.0',\n        },\n      },\n    },\n    {\n      dir: FOO2_PATH,\n      manifest: {\n        name: 'foo',\n        version: '2.0.0',\n      },\n    },\n  ], { ignoreDevDeps: true })\n  expect(result.unmatched).toStrictEqual([{ pkgName: 'bar', range: '^10.0.0' }])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          name: 'bar',\n          version: '1.0.0',\n\n          dependencies: {\n            'is-positive': '1.0.0',\n          },\n          devDependencies: {\n            foo: '^1.0.0',\n          },\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n          version: '1.0.0',\n\n          dependencies: {\n            bar: '^10.0.0',\n          },\n        },\n      },\n    },\n    [BAR2_PATH]: {\n      dependencies: [FOO2_PATH],\n      package: {\n        dir: BAR2_PATH,\n        manifest: {\n          name: 'bar',\n          version: '2.0.0',\n\n          dependencies: {\n            foo: '^2.0.0',\n          },\n        },\n      },\n    },\n    [FOO2_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO2_PATH,\n        manifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"* matches prerelease versions","suites":[],"updatePoint":{"line":625,"column":35},"line":625,"code":"test('* matches prerelease versions', () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        dependencies: {\n          foo: '*',\n        },\n        name: 'bar',\n        version: '1.0.0',\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n        version: '1.0.0-0',\n      },\n    },\n  ])\n  expect(result.unmatched).toStrictEqual([])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          dependencies: {\n            foo: '*',\n          },\n          name: 'bar',\n          version: '1.0.0',\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n          version: '1.0.0-0',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"successfully create a package graph even when a workspace package has no version","suites":[],"updatePoint":{"line":674,"column":86},"line":674,"code":"test('successfully create a package graph even when a workspace package has no version', async () => {\n  const result = createPkgGraph([\n    {\n      dir: BAR1_PATH,\n      manifest: {\n        dependencies: {\n          foo: 'workspace:*',\n        },\n        name: 'bar',\n        version: '1.0.0',\n      },\n    },\n    {\n      dir: FOO1_PATH,\n      manifest: {\n        name: 'foo',\n      },\n    },\n  ])\n\n  expect(result.unmatched).toStrictEqual([])\n  expect(result.graph).toStrictEqual({\n    [BAR1_PATH]: {\n      dependencies: [FOO1_PATH],\n      package: {\n        dir: BAR1_PATH,\n        manifest: {\n          dependencies: {\n            foo: 'workspace:*',\n          },\n          name: 'bar',\n          version: '1.0.0',\n        },\n      },\n    },\n    [FOO1_PATH]: {\n      dependencies: [],\n      package: {\n        dir: FOO1_PATH,\n        manifest: {\n          name: 'foo',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/pkgs-graph/test"},{"name":"overrides are added for vulnerable dependencies","suites":[],"updatePoint":{"line":14,"column":53},"line":14,"code":"test('overrides are added for vulnerable dependencies', async () => {\n  const tmp = f.prepare('has-vulnerabilities')\n\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.ALL_VULN_RESP)\n\n  const { exitCode, output } = await audit.handler({\n    auditLevel: 'moderate',\n    dir: tmp,\n    fix: true,\n    registries,\n  })\n\n  expect(exitCode).toBe(0)\n  expect(output).toMatch(/Run \"pnpm install\"/)\n\n  const manifest = await loadJsonFile<ProjectManifest>(path.join(tmp, 'package.json'))\n  expect(manifest.pnpm?.overrides?.['axios@<=0.18.0']).toBe('>=0.18.1')\n  expect(manifest.pnpm?.overrides?.['sync-exec@>=0.0.0']).toBeFalsy()\n})","file":"fix.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"no overrides are added if no vulnerabilities are found","suites":[],"updatePoint":{"line":36,"column":60},"line":36,"code":"test('no overrides are added if no vulnerabilities are found', async () => {\n  const tmp = f.prepare('fixture')\n\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.NO_VULN_RESP)\n\n  const { exitCode, output } = await audit.handler({\n    auditLevel: 'moderate',\n    dir: tmp,\n    fix: true,\n    registries,\n  })\n\n  expect(exitCode).toBe(0)\n  expect(output).toBe('No fixes were made')\n})","file":"fix.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit","suites":[],"updatePoint":{"line":11,"column":11},"line":11,"code":"test('audit', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.ALL_VULN_RESP)\n\n  const { output, exitCode } = await audit.handler({\n    dir: path.join(__dirname, 'fixtures/has-vulnerabilities'),\n    registries,\n  })\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit --dev","suites":[],"updatePoint":{"line":24,"column":17},"line":24,"code":"test('audit --dev', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.DEV_VULN_ONLY_RESP)\n\n  const { output, exitCode } = await audit.handler({\n    dir: path.join(__dirname, 'fixtures/has-vulnerabilities'),\n    dev: true,\n    production: false,\n    registries,\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit --audit-level","suites":[],"updatePoint":{"line":40,"column":25},"line":40,"code":"test('audit --audit-level', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.ALL_VULN_RESP)\n\n  const { output, exitCode } = await audit.handler({\n    auditLevel: 'moderate',\n    dir: path.join(__dirname, 'fixtures/has-vulnerabilities'),\n    registries,\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit: no vulnerabilities","suites":[],"updatePoint":{"line":55,"column":31},"line":55,"code":"test('audit: no vulnerabilities', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.NO_VULN_RESP)\n\n  const { output, exitCode } = await audit.handler({\n    dir: path.join(__dirname, '../../../fixtures/has-outdated-deps'),\n    registries,\n  })\n\n  expect(stripAnsi(output)).toBe('No known vulnerabilities found\\n')\n  expect(exitCode).toBe(0)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit --json","suites":[],"updatePoint":{"line":69,"column":18},"line":69,"code":"test('audit --json', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(200, responses.ALL_VULN_RESP)\n\n  const { output, exitCode } = await audit.handler({\n    dir: path.join(__dirname, 'fixtures/has-vulnerabilities'),\n    json: true,\n    registries,\n  })\n\n  const json = JSON.parse(output)\n  expect(json.metadata).toBeTruthy()\n  expect(exitCode).toBe(1)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"audit does not exit with code 1 if the found vulnerabilities are having lower severity then what we asked for","suites":[],"line":85,"code":"test.skip('audit does not exit with code 1 if the found vulnerabilities are having lower severity then what we asked for', async () => {","file":"index.ts","skipped":true,"dir":"packages/plugin-commands-audit/test"},{"name":"audit does not exit with code 1 if the registry responds with a non-200 response and ignoreRegistryErrors is used","suites":[],"updatePoint":{"line":102,"column":119},"line":102,"code":"test('audit does not exit with code 1 if the registry responds with a non-200 response and ignoreRegistryErrors is used', async () => {\n  nock(registries.default)\n    .post('/-/npm/v1/security/audits')\n    .reply(500, { message: 'Something bad happened' })\n  const { output, exitCode } = await audit.handler({\n    dir: path.join(__dirname, 'fixtures/has-vulnerabilities'),\n    dev: true,\n    fetchRetries: 0,\n    ignoreRegistryErrors: true,\n    production: false,\n    registries,\n  })\n\n  expect(exitCode).toBe(0)\n  expect(stripAnsi(output)).toBe(`The audit endpoint (at ${registries.default}-/npm/v1/security/audits) responded with 500: {\"message\":\"Something bad happened\"}`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-audit/test"},{"name":"install Node (and npm, npx) by exact version of Node.js","suites":[],"updatePoint":{"line":10,"column":61},"line":10,"code":"test('install Node (and npm, npx) by exact version of Node.js', async () => {\n  tempDir()\n  const configDir = path.resolve('config')\n\n  await env.handler({\n    bin: process.cwd(),\n    configDir,\n    global: true,\n    pnpmHomeDir: process.cwd(),\n    rawConfig: {},\n  }, ['use', '16.4.0'])\n\n  const opts = {\n    env: {\n      [PATH]: `${process.cwd()}${path.delimiter}${process.env[PATH] as string}`,\n    },\n    extendEnv: false,\n  }\n\n  {\n    const { stdout } = execa.sync('node', ['-v'], opts)\n    expect(stdout.toString()).toBe('v16.4.0')\n  }\n\n  {\n    const { stdout } = execa.sync('npm', ['-v'], opts)\n    expect(stdout.toString()).toBe('7.18.1')\n  }\n\n  {\n    const { stdout } = execa.sync('npx', ['-v'], opts)\n    expect(stdout.toString()).toBe('7.18.1')\n  }\n\n  const dirs = fs.readdirSync(path.resolve('nodejs'))\n  expect(dirs).toEqual(['16.4.0'])\n\n  {\n    const { stdout } = execa.sync('npm', ['config', 'get', 'globalconfig'], opts)\n    expect(stdout.toString()).toBe(path.join(configDir, 'npmrc'))\n  }\n})","file":"env.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"resolveNodeVersion uses node-mirror:release option","suites":[],"updatePoint":{"line":53,"column":56},"line":53,"code":"test('resolveNodeVersion uses node-mirror:release option', async () => {\n  tempDir()\n  const configDir = path.resolve('config')\n\n  const nockScope = nock('https://pnpm-node-mirror-test.localhost')\n    .get('/download/release/index.json')\n    .reply(200, [])\n\n  await expect(\n    env.handler({\n      bin: process.cwd(),\n      configDir,\n      global: true,\n      pnpmHomeDir: process.cwd(),\n      rawConfig: {\n        'node-mirror:release': 'https://pnpm-node-mirror-test.localhost/download/release',\n      },\n    }, ['use', '16.4.0'])\n  ).rejects.toEqual(new PnpmError('COULD_NOT_RESOLVE_NODEJS', 'Couldn\\'t find Node.js version matching 16.4.0'))\n\n  expect(nockScope.isDone()).toBeTruthy()\n})","file":"env.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"fail if a non-existed Node.js version is tried to be installed","suites":[],"updatePoint":{"line":76,"column":68},"line":76,"code":"test('fail if a non-existed Node.js version is tried to be installed', async () => {\n  tempDir()\n\n  await expect(\n    env.handler({\n      bin: process.cwd(),\n      global: true,\n      pnpmHomeDir: process.cwd(),\n      rawConfig: {},\n    }, ['use', '6.999'])\n  ).rejects.toEqual(new PnpmError('COULD_NOT_RESOLVE_NODEJS', 'Couldn\\'t find Node.js version matching 6.999'))\n})","file":"env.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"fail if a non-existed Node.js LTS is tried to be installed","suites":[],"updatePoint":{"line":89,"column":64},"line":89,"code":"test('fail if a non-existed Node.js LTS is tried to be installed', async () => {\n  tempDir()\n\n  await expect(\n    env.handler({\n      bin: process.cwd(),\n      global: true,\n      pnpmHomeDir: process.cwd(),\n      rawConfig: {},\n    }, ['use', 'boo'])\n  ).rejects.toEqual(new PnpmError('COULD_NOT_RESOLVE_NODEJS', 'Couldn\\'t find Node.js version matching boo'))\n})","file":"env.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"it re-attempts failed downloads","suites":[],"updatePoint":{"line":103,"column":37},"line":103,"code":"test('it re-attempts failed downloads', async () => {\n  tempDir()\n\n  // This fixture was retrieved from http://nodejs.org/download/release/index.json on 2021-12-12.\n  const testReleaseInfoPath = path.join(__dirname, './fixtures/node-16.4.0-release-info.json')\n\n  const nockScope = nock('https://nodejs.org')\n    // Using nock's persist option since the default fetcher retries requests.\n    .persist()\n    .get('/download/release/index.json')\n    .replyWithFile(200, testReleaseInfoPath)\n    .persist()\n    .get(uri => uri.startsWith('/download/release/v16.4.0/'))\n    .replyWithError('Intentionally failing response for test')\n\n  try {\n    const attempts = 2\n    for (let i = 0; i < attempts; i++) {\n      await expect(\n        env.handler({\n          bin: process.cwd(),\n          global: true,\n          pnpmHomeDir: process.cwd(),\n          rawConfig: {},\n        }, ['use', '16.4.0'])\n      ).rejects.toThrow('Intentionally failing response for test')\n    }\n\n    expect(nockScope.isDone()).toBeTruthy()\n  } finally {\n    nock.cleanAll()\n  }\n})","file":"env.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"getNodeMirror(%s, %s)","suites":[],"line":3,"code":"test.each([\n  ['release', { 'node-mirror:release': 'http://test.mirror.localhost/release' }, 'http://test.mirror.localhost/release/'],\n  ['nightly', { 'node-mirror:nightly': 'http://test.mirror.localhost/nightly' }, 'http://test.mirror.localhost/nightly/'],\n  ['rc', { 'node-mirror:rc': 'http://test.mirror.localhost/rc' }, 'http://test.mirror.localhost/rc/'],\n  ['test', { 'node-mirror:test': 'http://test.mirror.localhost/test' }, 'http://test.mirror.localhost/test/'],\n  ['v8-canary', { 'node-mirror:v8-canary': 'http://test.mirror.localhost/v8-canary' }, 'http://test.mirror.localhost/v8-canary/'],\n])('getNodeMirror(%s, %s)', (releaseDir, rawConfig, expected) => {\n  expect(getNodeMirror(rawConfig, releaseDir)).toBe(expected)\n})","file":"getNodeMirror.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"getNodeMirror uses defaults","suites":[],"updatePoint":{"line":13,"column":33},"line":13,"code":"test('getNodeMirror uses defaults', () => {\n  const rawConfig = {}\n  expect(getNodeMirror(rawConfig, 'release')).toBe('https://nodejs.org/download/release/')\n})","file":"getNodeMirror.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"getNodeMirror returns base url with trailing /","suites":[],"updatePoint":{"line":18,"column":52},"line":18,"code":"test('getNodeMirror returns base url with trailing /', () => {\n  const rawConfig = {\n    'node-mirror:release': 'http://test.mirror.localhost',\n  }\n  expect(getNodeMirror(rawConfig, 'release')).toBe('http://test.mirror.localhost/')\n})","file":"getNodeMirror.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"check API (placeholder test)","suites":[],"updatePoint":{"line":8,"column":34},"line":8,"code":"test('check API (placeholder test)', async () => {\n  expect(typeof node.getNodeDir).toBe('function')\n})","file":"node.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"install Node uses node-mirror:release option","suites":[],"updatePoint":{"line":12,"column":50},"line":12,"code":"test('install Node uses node-mirror:release option', async () => {\n  tempDir()\n  const configDir = path.resolve('config')\n\n  const nodeMirrorRelease = 'https://pnpm-node-mirror-test.localhost/download/release'\n  const opts: node.NvmNodeCommandOptions = {\n    bin: process.cwd(),\n    configDir,\n    global: true,\n    pnpmHomeDir: process.cwd(),\n    rawConfig: {\n      'node-mirror:release': nodeMirrorRelease,\n    },\n    useNodeVersion: '16.4.0',\n  }\n\n  const fetchMock = jest.fn(async (url: string) => {\n    if (url.endsWith('.zip')) {\n      // The Windows code path for pnpm's node bootstrapping expects a subdir\n      // within the .zip file.\n      const pkgName = path.basename(url, '.zip')\n      const zip = new AdmZip()\n      zip.addFile(`${pkgName}/dummy-file`, Buffer.from('test'))\n\n      return new Response(Readable.from(zip.toBuffer()))\n    }\n\n    return new Response(Readable.from(Buffer.alloc(0)))\n  })\n\n  await node.getNodeDir(fetchMock, opts)\n\n  for (const call of fetchMock.mock.calls) {\n    expect(call[0]).toMatch(nodeMirrorRelease)\n  }\n})","file":"node.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"normalizedArch(%s, %s)","suites":[],"line":3,"code":"test.each([\n  ['win32', 'ia32', 'x86'],\n  ['linux', 'arm', 'armv7l'], // Raspberry Pi 4\n  ['linux', 'x64', 'x64'],\n])('normalizedArch(%s, %s)', (platform, arch, normalizedArch) => {\n  expect(normalizeArch(platform, arch)).toBe(normalizedArch)\n})","file":"normalizeArch.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"Node.js %s is resolved","suites":[],"line":8,"code":"test.each([\n  ['6', '6.17.1', 'release'],\n  ['16.0.0-rc.0', '16.0.0-rc.0', 'rc'],\n  ['rc/10', '10.23.0-rc.0', 'rc'],\n  ['nightly', /.+/, 'nightly'],\n  ['lts', /.+/, 'release'],\n  ['argon', '4.9.1', 'release'],\n  ['latest', /.+/, 'release'],\n])('Node.js %s is resolved', async (spec, version, releaseDir) => {\n  const node = await resolveNodeVersion(fetch, spec, rawConfig)\n  expect(node.version).toMatch(version)\n  expect(node.releaseDir).toBe(releaseDir)\n})","file":"resolveNodeVersion.test.ts","skipped":false,"dir":"packages/plugin-commands-env/test"},{"name":"getOptionsFromRootManifest() should read \"resolutions\" field for compatibility with Yarn","suites":[],"updatePoint":{"line":3,"column":94},"line":3,"code":"test('getOptionsFromRootManifest() should read \"resolutions\" field for compatibility with Yarn', () => {\n  const options = getOptionsFromRootManifest({\n    resolutions: {\n      foo: '1.0.0',\n    },\n  })\n  expect(options.overrides).toStrictEqual({ foo: '1.0.0' })\n})","file":"getOptionsFromRootManifest.test.ts","skipped":false,"dir":"packages/plugin-commands-installation/test"},{"name":"getOptionsFromRootManifest() should read \"overrides\" field","suites":[],"updatePoint":{"line":12,"column":64},"line":12,"code":"test('getOptionsFromRootManifest() should read \"overrides\" field', () => {\n  const options = getOptionsFromRootManifest({\n    pnpm: {\n      overrides: {\n        foo: '1.0.0',\n      },\n    },\n  })\n  expect(options.overrides).toStrictEqual({ foo: '1.0.0' })\n})","file":"getOptionsFromRootManifest.test.ts","skipped":false,"dir":"packages/plugin-commands-installation/test"},{"name":"getUpdateChoices()","suites":[],"updatePoint":{"line":4,"column":24},"line":4,"code":"test('getUpdateChoices()', () => {\n  expect(\n    getUpdateChoices([\n      {\n        alias: 'foo',\n        belongsTo: 'dependencies' as const,\n        current: '1.0.0',\n        latestManifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n        packageName: 'foo',\n        wanted: '1.0.0',\n      },\n      {\n        alias: 'foo',\n        belongsTo: 'devDependencies' as const,\n        current: '1.0.0',\n        latestManifest: {\n          name: 'foo',\n          version: '2.0.0',\n        },\n        packageName: 'foo',\n        wanted: '1.0.0',\n      },\n      {\n        alias: 'qar',\n        belongsTo: 'devDependencies' as const,\n        current: '1.0.0',\n        latestManifest: {\n          name: 'qar',\n          version: '1.2.0',\n        },\n        packageName: 'qar',\n        wanted: '1.0.0',\n      },\n      {\n        alias: 'zoo',\n        belongsTo: 'devDependencies' as const,\n        current: '1.1.0',\n        latestManifest: {\n          name: 'zoo',\n          version: '1.2.0',\n        },\n        packageName: 'zoo',\n        wanted: '1.1.0',\n      },\n      {\n        alias: 'qaz',\n        belongsTo: 'optionalDependencies' as const,\n        current: '1.0.1',\n        latestManifest: {\n          name: 'qaz',\n          version: '1.2.0',\n        },\n        packageName: 'qaz',\n        wanted: '1.0.1',\n      },\n      {\n        alias: 'qaz',\n        belongsTo: 'devDependencies' as const,\n        current: '1.0.1',\n        latestManifest: {\n          name: 'qaz',\n          version: '1.2.0',\n        },\n        packageName: 'foo',\n        wanted: '1.0.1',\n      },\n    ]))\n    .toStrictEqual([\n      {\n        message: chalk`foo            1.0.0  {redBright.bold 2.0.0} \\n    foo (dev)      1.0.1  1.{yellowBright.bold 2.0} `,\n        name: 'foo',\n      },\n      {\n        message: chalk`qar (dev)      1.0.0  1.{yellowBright.bold 2.0} `,\n        name: 'qar',\n      },\n      {\n        message: chalk`qaz (optional) 1.0.1  1.{yellowBright.bold 2.0} `,\n        name: 'qaz',\n      },\n      {\n        message: chalk`zoo (dev)      1.1.0  1.{yellowBright.bold 2.0} `,\n        name: 'zoo',\n      },\n    ])\n})","file":"update/getUpdateChoices.test.ts","skipped":false,"dir":"packages/plugin-commands-installation/test"},{"name":"updateToWorkspacePackagesFromManifest()","suites":[],"updatePoint":{"line":43,"column":45},"line":43,"code":"test('updateToWorkspacePackagesFromManifest()', () => {\n  const manifest = {\n    dependencies: {\n      alpha: '1.0.0',\n      foo: '1.0.0',\n    },\n    devDependencies: {\n      bar: '1.0.0',\n      betta: '1.0.0',\n    },\n    optionalDependencies: {\n      hamma: '1.0.0',\n      qar: '1.0.0',\n    },\n  }\n  expect(updateToWorkspacePackagesFromManifest(\n    manifest,\n    INCLUDE_ALL,\n    WORKSPACE_PACKAGES\n  )).toStrictEqual(['bar@workspace:*', 'foo@workspace:*', 'qar@workspace:*'])\n  expect(updateToWorkspacePackagesFromManifest(\n    manifest,\n    {\n      dependencies: true,\n      devDependencies: false,\n      optionalDependencies: false,\n    },\n    WORKSPACE_PACKAGES\n  )).toStrictEqual(['foo@workspace:*'])\n})","file":"updateWorkspaceDependencies.test.ts","skipped":false,"dir":"packages/plugin-commands-installation/test"},{"name":"createWorkspaceSpecs","suites":[],"updatePoint":{"line":74,"column":26},"line":74,"code":"test('createWorkspaceSpecs', () => {\n  expect(createWorkspaceSpecs(['bar', 'foo@2', 'qar@workspace:3'], WORKSPACE_PACKAGES)).toStrictEqual(['bar@workspace:*', 'foo@workspace:2', 'qar@workspace:3'])\n  let err!: PnpmError\n  try {\n    createWorkspaceSpecs(['express'], WORKSPACE_PACKAGES)\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.code).toBe('ERR_PNPM_WORKSPACE_PACKAGE_NOT_FOUND')\n  expect(err.message).toBe('\"express\" not found in the workspace')\n})","file":"updateWorkspaceDependencies.test.ts","skipped":false,"dir":"packages/plugin-commands-installation/test"},{"name":"listing packages","suites":[],"updatePoint":{"line":14,"column":22},"line":14,"code":"test('listing packages', async () => {\n  prepare({\n    dependencies: {\n      'is-positive': '1.0.0',\n    },\n    devDependencies: {\n      'is-negative': '1.0.0',\n    },\n  })\n\n  await execa('node', [pnpmBin, 'install'])\n\n  {\n    const output = await list.handler({\n      dev: false,\n      dir: process.cwd(),\n      optional: false,\n    }, [])\n\n    expect(stripAnsi(output)).toBe(`Legend: production dependency, optional only, dev only\n\nproject@0.0.0 ${process.cwd()}\n\ndependencies:\nis-positive 1.0.0`)\n  }\n\n  {\n    const output = await list.handler({\n      dir: process.cwd(),\n      optional: false,\n      production: false,\n    }, [])\n\n    expect(stripAnsi(output)).toBe(`Legend: production dependency, optional only, dev only\n\nproject@0.0.0 ${process.cwd()}\n\ndevDependencies:\nis-negative 1.0.0`)\n  }\n\n  {\n    const output = await list.handler({\n      dir: process.cwd(),\n    }, [])\n\n    expect(stripAnsi(output)).toBe(`Legend: production dependency, optional only, dev only\n\nproject@0.0.0 ${process.cwd()}\n\ndependencies:\nis-positive 1.0.0\n\ndevDependencies:\nis-negative 1.0.0`)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"listing packages of a project that has an external ","suites":[],"updatePoint":{"line":73,"column":75},"line":73,"code":"test(`listing packages of a project that has an external ${WANTED_LOCKFILE}`, async () => {\n  preparePackages([\n    {\n      name: 'pkg',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n    },\n  ])\n\n  await writeYamlFile('pnpm-workspace.yaml', { packages: ['**', '!store/**'] })\n  await fs.writeFile('.npmrc', 'shared-workspace-lockfile = true', 'utf8')\n\n  await execa('node', [pnpmBin, 'recursive', 'install'])\n\n  process.chdir('pkg')\n\n  const output = await list.handler({\n    dir: process.cwd(),\n    lockfileDir: path.resolve('..'),\n  }, [])\n\n  expect(stripAnsi(output)).toBe(`Legend: production dependency, optional only, dev only\n\npkg@1.0.0 ${process.cwd()}\n\ndependencies:\nis-positive 1.0.0`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"list on a project with skipped optional dependencies","suites":[],"line":107,"code":"test.skip('list on a project with skipped optional dependencies', async () => {","file":"index.ts","skipped":true,"dir":"packages/plugin-commands-listing/test"},{"name":"recursive list","suites":[],"updatePoint":{"line":13,"column":20},"line":13,"code":"test('recursive list', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await install.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    cacheDir: path.resolve('cache'),\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  const output = await list.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n  }, [])\n\n  expect(stripAnsi(output as unknown as string)).toBe(`Legend: production dependency, optional only, dev only\n\nproject-1@1.0.0 ${path.resolve('project-1')}\n\ndependencies:\nis-positive 1.0.0\n\nLegend: production dependency, optional only, dev only\n\nproject-2@1.0.0 ${path.resolve('project-2')}\n\ndependencies:\nis-negative 1.0.0`)\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"recursive list with shared-workspace-lockfile","suites":[],"updatePoint":{"line":71,"column":51},"line":71,"code":"test('recursive list with shared-workspace-lockfile', async () => {\n  await addDistTag({ package: 'dep-of-pkg-with-1-dep', version: '100.1.0', distTag: 'latest' })\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'pkg-with-1-dep': '100.0.0',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n    },\n  ])\n\n  await writeYamlFile('pnpm-workspace.yaml', { packages: ['**', '!store/**'] })\n  await fs.writeFile('.npmrc', 'shared-workspace-lockfile = true', 'utf8')\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await install.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    cacheDir: path.resolve('cache'),\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  const output = await list.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    cliOptions: { depth: 2 },\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n  }, [])\n\n  expect(stripAnsi(output as unknown as string)).toBe(`Legend: production dependency, optional only, dev only\n\nproject-1@1.0.0 ${path.resolve('project-1')}\n\ndependencies:\npkg-with-1-dep 100.0.0\n dep-of-pkg-with-1-dep 100.1.0\n\nLegend: production dependency, optional only, dev only\n\nproject-2@1.0.0 ${path.resolve('project-2')}\n\ndependencies:\nis-negative 1.0.0`)\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"recursive list --filter","suites":[],"updatePoint":{"line":135,"column":29},"line":135,"code":"test('recursive list --filter', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n        'project-2': '1.0.0',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n        'is-positive': '1.0.0',\n      },\n    },\n  ])\n\n  await install.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    cacheDir: path.resolve('cache'),\n    dir: process.cwd(),\n    recursive: true,\n    workspaceDir: process.cwd(),\n  })\n\n  const output = await list.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    ...await readProjects(process.cwd(), [\n      { includeDependencies: true, namePattern: 'project-1' },\n    ]),\n  }, [])\n\n  expect(stripAnsi(output as unknown as string)).toBe(`Legend: production dependency, optional only, dev only\n\nproject-1@1.0.0 ${path.resolve('project-1')}\n\ndependencies:\nis-positive 1.0.0\nproject-2 link:../project-2\n\nLegend: production dependency, optional only, dev only\n\nproject-2@1.0.0 ${path.resolve('project-2')}\n\ndependencies:\nis-negative 1.0.0`)\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"recursive list --filter link-workspace-packages=false","suites":[],"updatePoint":{"line":199,"column":59},"line":199,"code":"test('recursive list --filter link-workspace-packages=false', async () => {\n  preparePackages([\n    {\n      dependencies: {\n        'is-positive': '1.0.0',\n        'project-2': 'workspace:*',\n      },\n      name: 'project-1',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n    },\n    {\n      name: 'is-positive',\n      version: '1.0.0',\n    },\n  ])\n\n  await install.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), [], { linkWorkspacePackages: false }),\n    cacheDir: path.resolve('cache'),\n    dir: process.cwd(),\n    linkWorkspacePackages: false,\n    recursive: true,\n    workspaceDir: process.cwd(),\n  })\n\n  const output = await list.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    ...await readProjects(process.cwd(), [\n      { includeDependencies: true, namePattern: 'project-1' },\n    ], { linkWorkspacePackages: false }),\n  }, [])\n\n  expect(stripAnsi(output as unknown as string)).toBe(`Legend: production dependency, optional only, dev only\n\nproject-1@1.0.0 ${path.resolve('project-1')}\n\ndependencies:\nis-positive 1.0.0\nproject-2 link:../project-2`)\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"`pnpm recursive why` should fail if no package name was provided","suites":[],"updatePoint":{"line":247,"column":70},"line":247,"code":"test('`pnpm recursive why` should fail if no package name was provided', async () => {\n  prepare()\n\n  let err!: PnpmError\n  try {\n    await why.handler({\n      ...DEFAULT_OPTS,\n      ...await readProjects(process.cwd(), []),\n      dir: process.cwd(),\n      recursive: true,\n    }, [])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err.code).toBe('ERR_PNPM_MISSING_PACKAGE_NAME')\n  expect(err.message).toBe('`pnpm why` requires the package name')\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"`pnpm why` should fail if no package name was provided","suites":[],"updatePoint":{"line":8,"column":60},"line":8,"code":"test('`pnpm why` should fail if no package name was provided', async () => {\n  prepare()\n\n  let err!: PnpmError\n  try {\n    await why.handler({\n      dir: process.cwd(),\n    }, [])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err.code).toBe('ERR_PNPM_MISSING_PACKAGE_NAME')\n  expect(err.message).toMatch(/`pnpm why` requires the package name/)\n})","file":"why.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"\"why\" should find non-direct dependency","suites":[],"updatePoint":{"line":24,"column":45},"line":24,"code":"test('\"why\" should find non-direct dependency', async () => {\n  prepare({\n    dependencies: {\n      'dep-of-pkg-with-1-dep': '100.0.0',\n      'pkg-with-1-dep': '100.0.0',\n    },\n  })\n\n  await execa('pnpm', ['install', '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  const output = await why.handler({\n    dev: false,\n    dir: process.cwd(),\n    optional: false,\n  }, ['dep-of-pkg-with-1-dep'])\n\n  expect(stripAnsi(output)).toBe(`Legend: production dependency, optional only, dev only\n\nproject@0.0.0 ${process.cwd()}\n\ndependencies:\ndep-of-pkg-with-1-dep 100.0.0\npkg-with-1-dep 100.0.0\n dep-of-pkg-with-1-dep 100.0.0`)\n})","file":"why.ts","skipped":false,"dir":"packages/plugin-commands-listing/test"},{"name":"pnpm outdated: show details","suites":[],"updatePoint":{"line":39,"column":33},"line":39,"code":"test('pnpm outdated: show details', async () => {\n  tempDir()\n\n  await fs.mkdir(path.resolve('node_modules/.pnpm'), { recursive: true })\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'node_modules/.pnpm/lock.yaml'), path.resolve('node_modules/.pnpm/lock.yaml'))\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n    long: true,\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package            Current  Latest      Details                                     \n\n deprecated         1.0.0    Deprecated  This package is deprecated. Lorem ipsum     \n                                         dolor sit amet, consectetur adipiscing      \n                                         elit.                                       \n                                         https://foo.bar/qar                         \n\n is-negative        1.0.0    2.1.0       https://github.com/kevva/is-negative#readme \n\n is-positive (dev)  1.0.0    3.1.0       https://github.com/kevva/is-positive#readme \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: show details (using the public registry to verify that full metadata is being requested)","suites":[],"updatePoint":{"line":69,"column":109},"line":69,"code":"test('pnpm outdated: show details (using the public registry to verify that full metadata is being requested)', async () => {\n  tempDir()\n\n  await fs.mkdir(path.resolve('node_modules/.pnpm'), { recursive: true })\n  await fs.copyFile(path.join(has2OutdatedDepsFixture, 'node_modules/.pnpm/lock.yaml'), path.resolve('node_modules/.pnpm/lock.yaml'))\n  await fs.copyFile(path.join(has2OutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n    long: true,\n    rawConfig: { registry: 'https://registry.npmjs.org/' },\n    registries: { default: 'https://registry.npmjs.org/' },\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package            Current  Latest  Details                                     \n\n is-negative        1.0.1    2.1.0   https://github.com/kevva/is-negative#readme \n\n is-positive (dev)  1.0.0    3.1.0   https://github.com/kevva/is-positive#readme \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: showing only prod or dev dependencies","suites":[],"updatePoint":{"line":96,"column":58},"line":96,"code":"test('pnpm outdated: showing only prod or dev dependencies', async () => {\n  tempDir()\n\n  await fs.mkdir(path.resolve('node_modules/.pnpm'), { recursive: true })\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'node_modules/.pnpm/lock.yaml'), path.resolve('node_modules/.pnpm/lock.yaml'))\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...OUTDATED_OPTIONS,\n      dir: process.cwd(),\n      production: false,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output)).toBe(`\\\n\n Package            Current  Latest \n\n is-positive (dev)  1.0.0    3.1.0  \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...OUTDATED_OPTIONS,\n      dev: false,\n      dir: process.cwd(),\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output)).toBe(`\\\n\n Package      Current  Latest     \n\n deprecated   1.0.0    Deprecated \n\n is-negative  1.0.0    2.1.0      \n\n`)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: no table","suites":[],"updatePoint":{"line":140,"column":29},"line":140,"code":"test('pnpm outdated: no table', async () => {\n  tempDir()\n\n  await fs.mkdir(path.resolve('node_modules/.pnpm'), { recursive: true })\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'node_modules/.pnpm/lock.yaml'), path.resolve('node_modules/.pnpm/lock.yaml'))\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...OUTDATED_OPTIONS,\n      dir: process.cwd(),\n      table: false,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output)).toBe(`deprecated\n1.0.0 => Deprecated\n\nis-negative\n1.0.0 => 2.1.0\n\nis-positive (dev)\n1.0.0 => 3.1.0\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...OUTDATED_OPTIONS,\n      dir: process.cwd(),\n      long: true,\n      table: false,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output)).toBe(`deprecated\n1.0.0 => Deprecated\nThis package is deprecated. Lorem ipsum\ndolor sit amet, consectetur adipiscing\nelit.\nhttps://foo.bar/qar\n\nis-negative\n1.0.0 => 2.1.0\nhttps://github.com/kevva/is-negative#readme\n\nis-positive (dev)\n1.0.0 => 3.1.0\nhttps://github.com/kevva/is-positive#readme\n`)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: only current lockfile is available","suites":[],"updatePoint":{"line":193,"column":55},"line":193,"code":"test('pnpm outdated: only current lockfile is available', async () => {\n  tempDir()\n\n  await fs.mkdir(path.resolve('node_modules/.pnpm'), { recursive: true })\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'node_modules/.pnpm/lock.yaml'), path.resolve('node_modules/.pnpm/lock.yaml'))\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package            Current  Latest     \n\n deprecated         1.0.0    Deprecated \n\n is-negative        1.0.0    2.1.0      \n\n is-positive (dev)  1.0.0    3.1.0      \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: only wanted lockfile is available","suites":[],"updatePoint":{"line":219,"column":54},"line":219,"code":"test('pnpm outdated: only wanted lockfile is available', async () => {\n  tempDir()\n\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'pnpm-lock.yaml'), path.resolve('pnpm-lock.yaml'))\n  await fs.copyFile(path.join(hasOutdatedDepsFixture, 'package.json'), path.resolve('package.json'))\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package            Current                 Latest     \n\n deprecated         missing (wanted 1.0.0)  Deprecated \n\n is-positive (dev)  missing (wanted 3.1.0)  3.1.0      \n\n is-negative        missing (wanted 1.1.0)  2.1.0      \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated does not print anything when all is good","suites":[],"updatePoint":{"line":244,"column":60},"line":244,"code":"test('pnpm outdated does not print anything when all is good', async () => {\n  process.chdir(hasNotOutdatedDepsFixture)\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n  })\n\n  expect(output).toBe('')\n  expect(exitCode).toBe(0)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated with external lockfile","suites":[],"updatePoint":{"line":256,"column":42},"line":256,"code":"test('pnpm outdated with external lockfile', async () => {\n  process.chdir(hasOutdatedDepsFixtureAndExternalLockfile)\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n    lockfileDir: path.resolve('..'),\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package      Current               Latest \n\n is-positive  1.0.0 (wanted 3.1.0)  3.1.0  \n\n is-negative  1.0.0 (wanted 1.1.0)  2.1.0  \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated should fail when there is no  file in the root of the project","suites":[],"updatePoint":{"line":277,"column":99},"line":277,"code":"test(`pnpm outdated should fail when there is no ${WANTED_LOCKFILE} file in the root of the project`, async () => {\n  process.chdir(hasNoLockfileFixture)\n\n  let err!: PnpmError\n  try {\n    await outdated.handler({\n      ...OUTDATED_OPTIONS,\n      dir: process.cwd(),\n    })\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.code).toBe('ERR_PNPM_OUTDATED_NO_LOCKFILE')\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated should return empty when there is no lockfile and no dependencies","suites":[],"updatePoint":{"line":292,"column":85},"line":292,"code":"test('pnpm outdated should return empty when there is no lockfile and no dependencies', async () => {\n  prepare(undefined)\n\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    dir: process.cwd(),\n  })\n\n  expect(output).toBe('')\n  expect(exitCode).toBe(0)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm outdated: print only compatible versions","suites":[],"updatePoint":{"line":304,"column":51},"line":304,"code":"test('pnpm outdated: print only compatible versions', async () => {\n  const { output, exitCode } = await outdated.handler({\n    ...OUTDATED_OPTIONS,\n    compatible: true,\n    dir: hasMajorOutdatedDepsFixture,\n  })\n\n  expect(exitCode).toBe(1)\n  expect(stripAnsi(output)).toBe(`\\\n\n Package      Current  Latest \n\n is-negative  1.0.0    1.0.1  \n\n`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm recursive outdated","suites":[],"updatePoint":{"line":8,"column":29},"line":8,"code":"test('pnpm recursive outdated', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n        'is-positive': '2.0.0',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n      devDependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await install.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package            Current  Latest  Dependents           \n\n is-negative        1.0.0    2.1.0   project-2            \n\n is-negative (dev)  1.0.0    2.1.0   project-3            \n\n is-positive        1.0.0    3.1.0   project-1, project-3 \n\n is-positive        2.0.0    3.1.0   project-2            \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      production: false,\n      recursive: true,\n      selectedProjectsGraph,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package            Current  Latest  Dependents \n\n is-negative (dev)  1.0.0    2.1.0   project-3  \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      long: true,\n      recursive: true,\n      selectedProjectsGraph,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package            Current  Latest  Dependents            Details                                     \n\n is-negative        1.0.0    2.1.0   project-2             https://github.com/kevva/is-negative#readme \n\n is-negative (dev)  1.0.0    2.1.0   project-3             https://github.com/kevva/is-negative#readme \n\n is-positive        1.0.0    3.1.0   project-1, project-3  https://github.com/kevva/is-positive#readme \n\n is-positive        2.0.0    3.1.0   project-2             https://github.com/kevva/is-positive#readme \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n      table: false,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\nis-negative\n1.0.0 => 2.1.0\nDependent: project-2\n\nis-negative (dev)\n1.0.0 => 2.1.0\nDependent: project-3\n\nis-positive\n1.0.0 => 3.1.0\nDependents: project-1, project-3\n\nis-positive\n2.0.0 => 3.1.0\nDependent: project-2\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      long: true,\n      recursive: true,\n      selectedProjectsGraph,\n      table: false,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\nis-negative\n1.0.0 => 2.1.0\nDependent: project-2\nhttps://github.com/kevva/is-negative#readme\n\nis-negative (dev)\n1.0.0 => 2.1.0\nDependent: project-3\nhttps://github.com/kevva/is-negative#readme\n\nis-positive\n1.0.0 => 3.1.0\nDependents: project-1, project-3\nhttps://github.com/kevva/is-positive#readme\n\nis-positive\n2.0.0 => 3.1.0\nDependent: project-2\nhttps://github.com/kevva/is-positive#readme\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    }, ['is-positive'])\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package      Current  Latest  Dependents           \n\n is-positive  1.0.0    3.1.0   project-1, project-3 \n\n is-positive  2.0.0    3.1.0   project-2            \n\n`)\n  }\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"pnpm recursive outdated in workspace with shared lockfile","suites":[],"updatePoint":{"line":208,"column":63},"line":208,"code":"test('pnpm recursive outdated in workspace with shared lockfile', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n      devDependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await install.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package            Current  Latest  Dependents           \n\n is-negative        1.0.0    2.1.0   project-2            \n\n is-negative (dev)  1.0.0    2.1.0   project-3            \n\n is-positive        1.0.0    3.1.0   project-1, project-3 \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      production: false,\n      recursive: true,\n      selectedProjectsGraph,\n    })\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package            Current  Latest  Dependents \n\n is-negative (dev)  1.0.0    2.1.0   project-3  \n\n`)\n  }\n\n  {\n    const { output, exitCode } = await outdated.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    }, ['is-positive'])\n\n    expect(exitCode).toBe(1)\n    expect(stripAnsi(output as unknown as string)).toBe(`\\\n\n Package      Current  Latest  Dependents           \n\n is-positive  1.0.0    3.1.0   project-1, project-3 \n\n`)\n  }\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-outdated/test"},{"name":"publish: fails git check if branch is not on master or main","suites":[],"updatePoint":{"line":27,"column":65},"line":27,"code":"test('publish: fails git check if branch is not on master or main', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await execa('git', ['init'])\n  await execa('git', ['checkout', '-b', 'test'])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n\n  prompt.mockResolvedValue({\n    confirm: false,\n  })\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    }, [])\n  ).rejects.toThrow(\n    new PnpmError('GIT_NOT_CORRECT_BRANCH', \"Branch is not on 'master|main'.\")\n  )\n})","file":"gitChecks.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: fails git check if branch is not on specified branch","suites":[],"updatePoint":{"line":55,"column":67},"line":55,"code":"test('publish: fails git check if branch is not on specified branch', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await execa('git', ['init'])\n  await execa('git', ['checkout', '-b', 'master'])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n\n  prompt.mockResolvedValue({\n    confirm: false,\n  })\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n      publishBranch: 'latest',\n    }, [])\n  ).rejects.toThrow(\n    new PnpmError('GIT_NOT_CORRECT_BRANCH', \"Branch is not on 'latest'.\")\n  )\n})","file":"gitChecks.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: fails git check if branch is not clean","suites":[],"updatePoint":{"line":84,"column":53},"line":84,"code":"test('publish: fails git check if branch is not clean', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await execa('git', ['init'])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n\n  await fs.writeFile('LICENSE', 'workspace license', 'utf8')\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    }, [])\n  ).rejects.toThrow(\n    new PnpmError('GIT_NOT_UNCLEAN', 'Unclean working tree. Commit or stash changes first.')\n  )\n})","file":"gitChecks.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: fails git check if branch is not up-to-date","suites":[],"updatePoint":{"line":109,"column":58},"line":109,"code":"test('publish: fails git check if branch is not up-to-date', async () => {\n  const remote = tempy.directory()\n\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await execa('git', ['init'])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['init', '--bare'], { cwd: remote })\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n  await execa('git', ['commit', '--allow-empty', '--allow-empty-message', '-m', '', '--no-gpg-sign'])\n  await execa('git', ['remote', 'add', 'origin', remote])\n  await execa('git', ['push', '-u', 'origin', 'master'])\n  await execa('git', ['reset', '--hard', 'HEAD~1'])\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    }, [])\n  ).rejects.toThrow(\n    new PnpmError('GIT_NOT_LATEST', 'Remote history differs. Please pull changes.')\n  )\n})","file":"gitChecks.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: fails git check if HEAD is detached","suites":[],"updatePoint":{"line":139,"column":50},"line":139,"code":"test('publish: fails git check if HEAD is detached', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await execa('git', ['init'])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n  await execa('git', ['commit', '--allow-empty', '--allow-empty-message', '-m', '', '--no-gpg-sign'])\n  await execa('git', ['checkout', 'HEAD~1'])\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    }, [])\n  ).rejects.toThrow(\n    new PnpmError('GIT_UNKNOWN_BRANCH', 'The Git HEAD may not attached to any branch, but your \"publish-branch\" is set to \"master|main\".')\n  )\n})","file":"gitChecks.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: package with package.json","suites":[],"updatePoint":{"line":9,"column":37},"line":9,"code":"test('pack: package with package.json', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n  })\n\n  expect(await exists('test-publish-package.json-0.0.0.tgz')).toBeTruthy()\n  expect(await exists('package.json')).toBeTruthy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: package with package.yaml","suites":[],"updatePoint":{"line":26,"column":37},"line":26,"code":"test('pack: package with package.yaml', async () => {\n  prepare({\n    name: 'test-publish-package.yaml',\n    version: '0.0.0',\n  }, { manifestFormat: 'YAML' })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n  })\n\n  expect(await exists('test-publish-package.yaml-0.0.0.tgz')).toBeTruthy()\n  expect(await exists('package.yaml')).toBeTruthy()\n  expect(await exists('package.json')).toBeFalsy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: package with package.json5","suites":[],"updatePoint":{"line":44,"column":38},"line":44,"code":"test('pack: package with package.json5', async () => {\n  prepare({\n    name: 'test-publish-package.json5',\n    version: '0.0.0',\n  }, { manifestFormat: 'JSON5' })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n  })\n\n  expect(await exists('test-publish-package.json5-0.0.0.tgz')).toBeTruthy()\n  expect(await exists('package.json5')).toBeTruthy()\n  expect(await exists('package.json')).toBeFalsy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack a package with scoped name","suites":[],"updatePoint":{"line":62,"column":37},"line":62,"code":"test('pack a package with scoped name', async () => {\n  prepare({\n    name: '@pnpm/test-scope',\n    version: '0.0.0',\n  })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n  })\n\n  expect(await exists('pnpm-test-scope-0.0.0.tgz')).toBeTruthy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: runs prepack, prepare, and postpack","suites":[],"updatePoint":{"line":78,"column":47},"line":78,"code":"test('pack: runs prepack, prepare, and postpack', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n    scripts: {\n      prepack: 'node -e \"require(\\'fs\\').writeFileSync(\\'prepack\\', \\'\\')\"',\n      prepare: 'node -e \"require(\\'fs\\').writeFileSync(\\'prepare\\', \\'\\')\"',\n      postpack: 'node -e \"require(\\'fs\\').writeFileSync(\\'postpack\\', \\'\\')\"',\n    },\n  })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n  })\n\n  expect(await exists('test-publish-package.json-0.0.0.tgz')).toBeTruthy()\n  expect(await exists('prepack')).toBeTruthy()\n  expect(await exists('prepare')).toBeTruthy()\n  expect(await exists('postpack')).toBeTruthy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: should embed readme","suites":[],"updatePoint":{"line":131,"column":31},"line":131,"code":"test('pack: should embed readme', async () => {\n  tempDir()\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: path.join(__dirname, '../fixtures/readme'),\n    extraBinPaths: [],\n    packDestination: process.cwd(),\n    embedReadme: true,\n  })\n\n  await tar.x({ file: 'readme-0.0.0.tgz' })\n\n  const pkg = await import(path.resolve('package/package.json'))\n\n  expect(pkg.readme).toBeTruthy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: should not embed readme","suites":[],"updatePoint":{"line":150,"column":35},"line":150,"code":"test('pack: should not embed readme', async () => {\n  tempDir()\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: path.join(__dirname, '../fixtures/readme'),\n    extraBinPaths: [],\n    packDestination: process.cwd(),\n    embedReadme: false,\n  })\n\n  await tar.x({ file: 'readme-0.0.0.tgz' })\n\n  const pkg = await import(path.resolve('package/package.json'))\n\n  expect(pkg.readme).toBeFalsy()\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"pack: remove publishConfig","suites":[],"updatePoint":{"line":169,"column":32},"line":169,"code":"test('pack: remove publishConfig', async () => {\n  prepare({\n    name: 'remove-publish-config',\n    version: '0.0.0',\n    main: 'index.d.js',\n    publishConfig: {\n      types: 'index.d.ts',\n      main: 'index.js',\n    },\n  })\n\n  await pack.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: [] },\n    dir: process.cwd(),\n    extraBinPaths: [],\n    packDestination: process.cwd(),\n    embedReadme: false,\n  })\n\n  await tar.x({ file: 'remove-publish-config-0.0.0.tgz' })\n\n  expect((await import(path.resolve('package/package.json'))).default).toStrictEqual({\n    name: 'remove-publish-config',\n    version: '0.0.0',\n    main: 'index.js',\n    types: 'index.d.ts',\n  })\n})","file":"pack.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with package.json","suites":[],"updatePoint":{"line":24,"column":40},"line":24,"code":"test('publish: package with package.json', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.0',\n  })\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  expect(await exists('test-publish-package.json-0.0.0.tgz')).toBeFalsy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with package.yaml","suites":[],"updatePoint":{"line":39,"column":40},"line":39,"code":"test('publish: package with package.yaml', async () => {\n  prepare({\n    name: 'test-publish-package.yaml',\n    version: '0.0.0',\n  }, { manifestFormat: 'YAML' })\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  expect(await exists('package.yaml')).toBeTruthy()\n  expect(await exists('package.json')).toBeFalsy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with package.json5","suites":[],"updatePoint":{"line":55,"column":41},"line":55,"code":"test('publish: package with package.json5', async () => {\n  prepare({\n    name: 'test-publish-package.json5',\n    version: '0.0.0',\n  }, { manifestFormat: 'JSON5' })\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  expect(await exists('package.json5')).toBeTruthy()\n  expect(await exists('package.json')).toBeFalsy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with package.json5 running publish from different folder","suites":[],"updatePoint":{"line":71,"column":79},"line":71,"code":"test('publish: package with package.json5 running publish from different folder', async () => {\n  prepare({\n    name: 'test-publish-package.json5',\n    version: '0.0.1',\n  }, { manifestFormat: 'JSON5' })\n\n  process.chdir('..')\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS, './project'] },\n    dir: process.cwd(),\n  }, ['./project'])\n\n  expect(await exists('project/package.json5')).toBeTruthy()\n  expect(await exists('project/package.json')).toBeFalsy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish packages with workspace LICENSE if no own LICENSE is present","suites":[],"updatePoint":{"line":142,"column":74},"line":142,"code":"test('publish packages with workspace LICENSE if no own LICENSE is present', async () => {\n  preparePackages([\n    {\n      name: 'project-100',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-200',\n      version: '1.0.0',\n    },\n    {\n      name: 'target',\n      version: '1.0.0',\n    },\n  ], { manifestFormat: 'YAML' })\n\n  const workspaceDir = process.cwd()\n  await writeYamlFile('pnpm-workspace.yaml', { packages: ['**', '!store/**'] })\n  await fs.writeFile('LICENSE', 'workspace license', 'utf8')\n  await fs.writeFile('project-200/LICENSE', 'project-200 license', 'utf8')\n\n  process.chdir('project-100')\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n    workspaceDir,\n  }, [])\n\n  process.chdir('../project-200')\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n    workspaceDir,\n  }, [])\n\n  process.chdir('../target')\n\n  crossSpawn.sync(pnpmBin, ['add', 'project-100', 'project-200', '--no-link-workspace-packages', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  expect(await fs.readFile('node_modules/project-100/LICENSE', 'utf8')).toBe('workspace license')\n  expect(await fs.readFile('node_modules/project-200/LICENSE', 'utf8')).toBe('project-200 license')\n\n  process.chdir('..')\n  expect(await exists('project-100/LICENSE')).toBeFalsy()\n  expect(await exists('project-200/LICENSE')).toBeTruthy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with all possible fields in publishConfig","suites":[],"updatePoint":{"line":191,"column":64},"line":191,"code":"test('publish: package with all possible fields in publishConfig', async () => {\n  preparePackages([\n    {\n      name: 'test-publish-config',\n      version: '1.0.0',\n\n      bin: './bin.js',\n      main: './index.js',\n      module: './index.mjs',\n      types: './types.d.ts',\n      typings: './typings.d.ts',\n\n      publishConfig: {\n        bin: './published-bin.js',\n        browser: './published-browser.js',\n        es2015: './published-es2015.js',\n        esnext: './published-esnext.js',\n        exports: './published-exports.js',\n        main: './published.js',\n        module: './published.mjs',\n        types: './published-types.d.ts',\n        typings: './published-typings.d.ts',\n        'umd:main': './published-umd.js',\n        unpkg: './published-unpkg.js',\n      },\n    },\n    {\n      name: 'test-publish-config-installation',\n      version: '1.0.0',\n    },\n  ])\n\n  process.chdir('test-publish-config')\n  await fs.writeFile('published-bin.js', '#!/usr/bin/env node', 'utf8')\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  const { default: originalManifests } = await import(path.resolve('package.json'))\n  expect(originalManifests).toStrictEqual({\n    name: 'test-publish-config',\n    version: '1.0.0',\n\n    bin: './bin.js',\n    main: './index.js',\n    module: './index.mjs',\n    types: './types.d.ts',\n    typings: './typings.d.ts',\n\n    publishConfig: {\n      bin: './published-bin.js',\n      browser: './published-browser.js',\n      es2015: './published-es2015.js',\n      esnext: './published-esnext.js',\n      exports: './published-exports.js',\n      main: './published.js',\n      module: './published.mjs',\n      types: './published-types.d.ts',\n      typings: './published-typings.d.ts',\n      'umd:main': './published-umd.js',\n      unpkg: './published-unpkg.js',\n    },\n  })\n\n  process.chdir('../test-publish-config-installation')\n  crossSpawn.sync(pnpmBin, ['add', 'test-publish-config', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  const { default: publishedManifest } = await import(path.resolve('node_modules/test-publish-config/package.json'))\n  expect(publishedManifest).toStrictEqual({\n    name: 'test-publish-config',\n    version: '1.0.0',\n\n    bin: './published-bin.js',\n    main: './published.js',\n    module: './published.mjs',\n    types: './published-types.d.ts',\n    typings: './published-typings.d.ts',\n\n    browser: './published-browser.js',\n    es2015: './published-es2015.js',\n    esnext: './published-esnext.js',\n    exports: './published-exports.js',\n    'umd:main': './published-umd.js',\n    unpkg: './published-unpkg.js',\n  })\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: package with publishConfig.directory","suites":[],"updatePoint":{"line":280,"column":51},"line":280,"code":"test('publish: package with publishConfig.directory', async () => {\n  const packages = preparePackages([\n    {\n      name: 'test-publish-config-directory',\n      version: '1.0.0',\n\n      scripts: {\n        prepublishOnly: 'node --eval=\"const fs=require(\\'fs\\');fs.mkdirSync(\\'dist\\',{recursive:true});fs.writeFileSync(\\'dist/prepublishOnly\\', \\'\\', \\'utf8\\')\"',\n      },\n\n      publishConfig: {\n        directory: 'dist',\n      },\n    },\n  ])\n\n  const testPublishConfigDirectory = packages['test-publish-config-directory']\n\n  expect(testPublishConfigDirectory).toBeTruthy()\n\n  await fs.mkdir(path.join(testPublishConfigDirectory.dir(), 'dist'))\n\n  await fs.writeFile(\n    path.join(testPublishConfigDirectory.dir(), 'dist/package.json'),\n    JSON.stringify({\n      name: 'publish_config_directory_dist_package',\n      version: '1.0.0',\n    }),\n    {\n      encoding: 'utf-8',\n    }\n  )\n\n  process.chdir('test-publish-config-directory')\n\n  await publish.handler(\n    {\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    },\n    []\n  )\n\n  crossSpawn.sync(pnpmBin, ['add', 'publish_config_directory_dist_package', '--no-link-workspace-packages', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  expect(JSON.parse(await fs.readFile('node_modules/publish_config_directory_dist_package/package.json', { encoding: 'utf-8' })))\n    .toStrictEqual({\n      name: 'publish_config_directory_dist_package',\n      version: '1.0.0',\n    })\n  expect(existsSync('node_modules/publish_config_directory_dist_package/prepublishOnly')).toBeTruthy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish package that calls executable from the workspace .bin folder in prepublishOnly script","suites":[],"line":334,"code":"test.skip('publish package that calls executable from the workspace .bin folder in prepublishOnly script', async () => {","file":"publish.ts","skipped":true,"dir":"packages/plugin-commands-publishing/test"},{"name":"convert specs with workspace protocols to regular version ranges","suites":[],"updatePoint":{"line":395,"column":70},"line":395,"code":"test('convert specs with workspace protocols to regular version ranges', async () => {\n  preparePackages([\n    {\n      name: 'workspace-protocol-package',\n      version: '1.0.0',\n\n      dependencies: {\n        even: 'workspace:is-even@^1.0.0',\n        'file-type': 'workspace:12.0.1',\n        'is-negative': 'workspace:*',\n        'is-positive': '1.0.0',\n        'lodash.delay': '~4.1.0',\n        odd: 'workspace:is-odd@*',\n        rd: 'workspace:ramda@^',\n        'word-wrap': 'workspace:~',\n      },\n      devDependencies: {\n        'random-package': 'workspace:^1.2.3',\n        through: 'workspace:^',\n      },\n      optionalDependencies: {\n        'lodash.deburr': 'workspace:^4.1.0',\n        ww: 'workspace:wordwrap@~',\n      },\n      peerDependencies: {\n        'random-package': 'workspace:*',\n      },\n    },\n    {\n      name: 'is-even',\n      version: '1.0.0',\n    },\n    {\n      name: 'is-odd',\n      version: '1.0.0',\n    },\n    {\n      name: 'is-negative',\n      version: '1.0.0',\n    },\n    {\n      name: 'file-type',\n      version: '12.0.1',\n    },\n    {\n      name: 'lodash.deburr',\n      version: '4.1.0',\n    },\n    {\n      name: 'lodash.delay',\n      version: '4.1.0',\n    },\n    {\n      name: 'random-package',\n      version: '1.2.3',\n    },\n    {\n      name: 'target',\n      version: '1.0.0',\n    },\n    {\n      name: 'ramda',\n      version: '0.1.0',\n    },\n    {\n      name: 'word-wrap',\n      version: '0.1.0',\n    },\n    {\n      name: 'through',\n      version: '0.0.1',\n    },\n    {\n      name: 'wordwrap',\n      version: '0.0.1',\n    },\n  ])\n\n  await writeYamlFile('pnpm-workspace.yaml', { packages: ['**', '!store/**'] })\n\n  process.chdir('workspace-protocol-package')\n\n  await expect(\n    publish.handler({\n      ...DEFAULT_OPTS,\n      argv: { original: ['publish', ...CREDENTIALS] },\n      dir: process.cwd(),\n    }, [])\n  )\n    .rejects\n    // It would be great to match the exact error message\n    // but the message will contain randomly one of the dependency names\n    .toThrow(/^Cannot resolve workspace protocol of dependency \"/)\n\n  process.chdir('..')\n\n  crossSpawn.sync(pnpmBin, ['multi', 'install', '--store-dir=store', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  process.chdir('workspace-protocol-package')\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  process.chdir('../target')\n\n  crossSpawn.sync(pnpmBin, ['add', '--store-dir=store', 'workspace-protocol-package', '--no-link-workspace-packages', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  const { default: publishedManifest } = await import(path.resolve('node_modules/workspace-protocol-package/package.json'))\n  expect(publishedManifest.dependencies).toStrictEqual({\n    'file-type': '12.0.1',\n    'is-negative': '1.0.0',\n    'is-positive': '1.0.0',\n    'lodash.delay': '~4.1.0',\n    even: 'npm:is-even@^1.0.0',\n    odd: 'npm:is-odd@1.0.0',\n    rd: 'npm:ramda@^0.1.0',\n    'word-wrap': '~0.1.0',\n  })\n  expect(publishedManifest.devDependencies).toStrictEqual({\n    'random-package': '^1.2.3',\n    through: '^0.0.1',\n  })\n  expect(publishedManifest.optionalDependencies).toStrictEqual({\n    'lodash.deburr': '^4.1.0',\n    ww: 'npm:wordwrap@~0.0.1',\n  })\n  expect(publishedManifest.peerDependencies).toStrictEqual({\n    'random-package': '1.2.3',\n  })\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"convert specs with relative workspace protocols to regular version ranges","suites":[],"updatePoint":{"line":529,"column":79},"line":529,"code":"test('convert specs with relative workspace protocols to regular version ranges', async () => {\n  preparePackages([\n    {\n      name: 'relative-workspace-protocol-package',\n      version: '1.0.0',\n\n      dependencies: {\n        'file-type': 'workspace:../file-type',\n        'is-neg': 'workspace:../is-negative',\n        'is-positive': '1.0.0',\n        'lodash.delay': '~4.1.0',\n      },\n      devDependencies: {\n        'random-package': 'workspace:../random-package',\n      },\n      optionalDependencies: {\n        'lodash.deburr': 'workspace:../lodash.deburr',\n      },\n      peerDependencies: {\n        'random-package': 'workspace:../random-package',\n      },\n    },\n    {\n      name: 'is-negative',\n      version: '1.0.0',\n    },\n    {\n      name: 'file-type',\n      version: '12.0.1',\n    },\n    {\n      name: 'lodash.deburr',\n      version: '4.1.0',\n    },\n    {\n      name: 'lodash.delay',\n      version: '4.1.0',\n    },\n    {\n      name: 'random-package',\n      version: '1.2.3',\n    },\n    {\n      name: 'target',\n      version: '1.0.0',\n    },\n  ])\n\n  await writeYamlFile('pnpm-workspace.yaml', { packages: ['**', '!store/**'] })\n\n  process.chdir('relative-workspace-protocol-package')\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  process.chdir('../target')\n\n  crossSpawn.sync(pnpmBin, [\n    'add',\n    '--store-dir=../store',\n    'relative-workspace-protocol-package',\n    '--no-link-workspace-packages',\n    `--registry=http://localhost:${REGISTRY_MOCK_PORT}`,\n  ])\n\n  const { default: publishedManifest } = await import(path.resolve('node_modules/relative-workspace-protocol-package/package.json'))\n  expect(publishedManifest.dependencies).toStrictEqual({\n    'file-type': '12.0.1',\n    'is-neg': 'npm:is-negative@1.0.0',\n    'is-positive': '1.0.0',\n    'lodash.delay': '~4.1.0',\n  })\n  expect(publishedManifest.devDependencies).toStrictEqual({\n    'random-package': '1.2.3',\n  })\n  expect(publishedManifest.optionalDependencies).toStrictEqual({\n    'lodash.deburr': '4.1.0',\n  })\n  expect(publishedManifest.peerDependencies).toStrictEqual({\n    'random-package': '1.2.3',\n  })\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: runs all the lifecycle scripts","suites":[],"updatePoint":{"line":615,"column":45},"line":615,"code":"test('publish: runs all the lifecycle scripts', async () => {\n  prepare({\n    name: 'test-publish-with-scripts',\n    version: '0.0.0',\n\n    dependencies: {\n      'json-append': '1.1.1',\n    },\n\n    scripts: {\n      // eslint-disable:object-literal-sort-keys\n      prepublish: 'node -e \"process.stdout.write(\\'prepublish\\')\" | json-append output.json',\n      prepare: 'node -e \"process.stdout.write(\\'prepare\\')\" | json-append output.json',\n      prepublishOnly: 'node -e \"process.stdout.write(\\'prepublishOnly\\')\" | json-append output.json',\n      prepack: 'node -e \"process.stdout.write(\\'prepack\\')\" | json-append output.json',\n      publish: 'node -e \"process.stdout.write(\\'publish\\')\" | json-append output.json',\n      postpublish: 'node -e \"process.stdout.write(\\'postpublish\\')\" | json-append output.json',\n      // eslint-enable:object-literal-sort-keys\n    },\n  })\n\n  crossSpawn.sync(pnpmBin, ['install', '--ignore-scripts', '--store-dir=../store', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n  }, [])\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n  expect(outputs).toStrictEqual([\n    'prepublish',\n    'prepare',\n    'prepublishOnly',\n    'prepack',\n    'publish',\n    'postpublish',\n  ])\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: ignores all the lifecycle scripts when --ignore-scripts is used","suites":[],"updatePoint":{"line":655,"column":78},"line":655,"code":"test('publish: ignores all the lifecycle scripts when --ignore-scripts is used', async () => {\n  prepare({\n    name: 'test-publish-with-ignore-scripts',\n    version: '0.0.0',\n\n    dependencies: {\n      'json-append': '1.1.1',\n    },\n\n    scripts: {\n      // eslint-disable:object-literal-sort-keys\n      prepublish: 'node -e \"process.stdout.write(\\'prepublish\\')\" | json-append output.json',\n      prepare: 'node -e \"process.stdout.write(\\'prepare\\')\" | json-append output.json',\n      prepublishOnly: 'node -e \"process.stdout.write(\\'prepublishOnly\\')\" | json-append output.json',\n      prepack: 'node -e \"process.stdout.write(\\'prepack\\')\" | json-append output.json',\n      publish: 'node -e \"process.stdout.write(\\'publish\\')\" | json-append output.json',\n      postpublish: 'node -e \"process.stdout.write(\\'postpublish\\')\" | json-append output.json',\n      // eslint-enable:object-literal-sort-keys\n    },\n  })\n\n  crossSpawn.sync(pnpmBin, ['install', '--ignore-scripts', '--store-dir=../store', `--registry=http://localhost:${REGISTRY_MOCK_PORT}`])\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', ...CREDENTIALS] },\n    dir: process.cwd(),\n    ignoreScripts: true,\n  }, [])\n\n  expect(await exists('package.json')).toBeTruthy()\n  expect(await exists('output.json')).toBeFalsy()\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"publish: with specified publish branch name","suites":[],"updatePoint":{"line":689,"column":49},"line":689,"code":"test('publish: with specified publish branch name', async () => {\n  prepare({\n    name: 'test-publish-package.json',\n    version: '0.0.2',\n  })\n\n  const branch = 'some-random-publish-branch'\n  await execa('git', ['init'])\n  await execa('git', ['checkout', '-b', branch])\n  await execa('git', ['config', 'user.email', 'x@y.z'])\n  await execa('git', ['config', 'user.name', 'xyz'])\n  await execa('git', ['add', '*'])\n  await execa('git', ['commit', '-m', 'init', '--no-gpg-sign'])\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    argv: { original: ['publish', '--publish-branch', branch, ...CREDENTIALS] },\n    dir: process.cwd(),\n    publishBranch: branch,\n  }, [])\n})","file":"publish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"recursive publish","suites":[],"updatePoint":{"line":20,"column":23},"line":20,"code":"test('recursive publish', async () => {\n  // This suffix is added to the package name to avoid issue if Jest reruns the test\n  const SUFFIX = Date.now()\n\n  const pkg1 = {\n    name: `@pnpmtest/test-recursive-publish-project-1-${SUFFIX}`,\n    version: '1.0.0',\n\n    dependencies: {\n      'is-positive': '1.0.0',\n    },\n  }\n  const pkg2 = {\n    name: `@pnpmtest/test-recursive-publish-project-2-${SUFFIX}`,\n    version: '1.0.0',\n\n    dependencies: {\n      'is-negative': '1.0.0',\n    },\n  }\n  const projects = preparePackages([\n    pkg1,\n    pkg2,\n    // This will not be published because is-positive@1.0.0 is in the registry\n    {\n      name: 'is-positive',\n      version: '1.0.0',\n\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // This will not be published because it is a private package\n    {\n      name: 'i-am-private',\n      version: '1.0.0',\n\n      private: true,\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // Package with no name is skipped\n    {\n      location: 'no-name',\n      package: {\n        scripts: {\n          prepublishOnly: 'exit 1',\n        },\n      },\n    },\n  ])\n\n  await fs.writeFile('.npmrc', CREDENTIALS, 'utf8')\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    dryRun: true,\n    recursive: true,\n  }, [])\n\n  {\n    const { status } = crossSpawn.sync('npm', ['view', pkg1.name, 'versions', '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`, '--json'])\n    expect(status).toBe(1)\n  }\n  {\n    const { status } = crossSpawn.sync('npm', ['view', pkg2.name, 'versions', '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`, '--json'])\n    expect(status).toBe(1)\n  }\n\n  process.env.npm_config_userconfig = path.join('.npmrc')\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    recursive: true,\n  }, [])\n\n  {\n    const { stdout } = await execa('npm', ['view', pkg1.name, 'versions', '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`, '--json'])\n    expect(JSON.parse(stdout.toString())).toStrictEqual(pkg1.version)\n  }\n  {\n    const { stdout } = await execa('npm', ['view', pkg2.name, 'versions', '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`, '--json'])\n    expect(JSON.parse(stdout.toString())).toStrictEqual(pkg2.version)\n  }\n\n  await projects[pkg1.name].writePackageJson({ ...pkg1, version: '2.0.0' })\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    recursive: true,\n    tag: 'next',\n  }, [])\n\n  {\n    const { stdout } = await execa('npm', ['dist-tag', 'ls', pkg1.name, '--registry', `http://localhost:${REGISTRY_MOCK_PORT}`])\n    expect(stdout.toString()).toContain('next: 2.0.0')\n  }\n})","file":"recursivePublish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"print info when no packages are published","suites":[],"updatePoint":{"line":125,"column":47},"line":125,"code":"test('print info when no packages are published', async () => {\n  preparePackages([\n    // This will not be published because is-positive@1.0.0 is in the registry\n    {\n      name: 'is-positive',\n      version: '1.0.0',\n\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // This will not be published because it is a private package\n    {\n      name: 'i-am-private',\n      version: '1.0.0',\n\n      private: true,\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // Package with no name is skipped\n    {\n      location: 'no-name',\n      package: {\n        scripts: {\n          prepublishOnly: 'exit 1',\n        },\n      },\n    },\n  ])\n\n  await fs.writeFile('.npmrc', CREDENTIALS, 'utf8')\n\n  const reporter = jest.fn()\n  streamParser.on('data', reporter)\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    dryRun: true,\n    recursive: true,\n  }, [])\n\n  streamParser.removeListener('data', reporter)\n  expect(reporter).toBeCalledWith(expect.objectContaining({\n    level: 'info',\n    message: 'There are no new packages that should be published',\n    name: 'pnpm',\n    prefix: process.cwd(),\n  }))\n})","file":"recursivePublish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"packages are released even if their current version is published, when force=true","suites":[],"updatePoint":{"line":179,"column":87},"line":179,"code":"test('packages are released even if their current version is published, when force=true', async () => {\n  preparePackages([\n    // This version is already in the registry\n    {\n      name: 'is-positive',\n      version: '3.1.0',\n\n      scripts: {\n        prepublishOnly: 'pnpm version major',\n      },\n    },\n  ])\n\n  await fs.writeFile('.npmrc', CREDENTIALS, 'utf8')\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    force: true,\n    dir: process.cwd(),\n    dryRun: true,\n    recursive: true,\n  }, [])\n\n  const manifest = await loadJsonFile<ProjectManifest>('is-positive/package.json')\n  expect(manifest.version).toBe('4.0.0')\n})","file":"recursivePublish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"recursive publish writes publish summary","suites":[],"updatePoint":{"line":207,"column":46},"line":207,"code":"test('recursive publish writes publish summary', async () => {\n  preparePackages([\n    {\n      name: '@pnpmtest/test-recursive-publish-project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-positive': '1.0.0',\n      },\n    },\n    {\n      name: '@pnpmtest/test-recursive-publish-project-4',\n      version: '1.0.0',\n\n      dependencies: {\n        'is-negative': '1.0.0',\n      },\n    },\n    // This will not be published because is-positive@1.0.0 is in the registry\n    {\n      name: 'is-positive',\n      version: '1.0.0',\n\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // This will not be published because it is a private package\n    {\n      name: 'i-am-private',\n      version: '1.0.0',\n\n      private: true,\n      scripts: {\n        prepublishOnly: 'exit 1',\n      },\n    },\n    // Package with no name is skipped\n    {\n      location: 'no-name',\n      package: {\n        scripts: {\n          prepublishOnly: 'exit 1',\n        },\n      },\n    },\n  ])\n\n  await fs.writeFile('.npmrc', CREDENTIALS, 'utf8')\n\n  process.env.npm_config_userconfig = path.join('.npmrc')\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    recursive: true,\n    reportSummary: true,\n  }, [])\n\n  {\n    const publishSummary = await loadJsonFile('pnpm-publish-summary.json')\n    expect(publishSummary).toMatchSnapshot()\n    await fs.unlink('pnpm-publish-summary.json')\n  }\n\n  await publish.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), []),\n    dir: process.cwd(),\n    recursive: true,\n    reportSummary: true,\n  }, [])\n\n  {\n    const publishSummary = await loadJsonFile('pnpm-publish-summary.json')\n    expect(publishSummary).toStrictEqual({\n      publishedPackages: [],\n    })\n  }\n})","file":"recursivePublish.ts","skipped":false,"dir":"packages/plugin-commands-publishing/test"},{"name":"rebuilds dependencies","suites":[],"updatePoint":{"line":17,"column":27},"line":17,"code":"test('rebuilds dependencies', async () => {\n  const project = prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [\n    pnpmBin,\n    'add',\n    '--save-dev',\n    'pre-and-postinstall-scripts-example',\n    'pnpm/test-git-fetch#299c6d89507571462b992b92407a8a07663e32ee',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n    '--cache-dir',\n    cacheDir,\n  ])\n\n  let modules = await project.readModulesManifest()\n  expect(modules!.pendingBuilds).toStrictEqual([\n    '/pre-and-postinstall-scripts-example/1.0.0',\n    'github.com/pnpm/test-git-fetch/299c6d89507571462b992b92407a8a07663e32ee',\n  ])\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: false,\n    storeDir,\n  }, [])\n\n  modules = await project.readModulesManifest()\n  expect(modules).toBeTruthy()\n  expect(modules!.pendingBuilds.length).toBe(0)\n\n  {\n    expect(await exists('node_modules/pre-and-postinstall-scripts-example/generated-by-prepare.js')).toBeFalsy()\n    expect(await exists('node_modules/pre-and-postinstall-scripts-example/generated-by-preinstall.js')).toBeTruthy()\n\n    const generatedByPreinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-preinstall')\n    expect(typeof generatedByPreinstall).toBe('function')\n\n    const generatedByPostinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-postinstall')\n    expect(typeof generatedByPostinstall).toBe('function')\n  }\n\n  {\n    const scripts = project.requireModule('test-git-fetch/output.json')\n    expect(scripts[0]).toBe('preinstall')\n    expect(scripts[1]).toBe('install')\n    expect(scripts[2]).toBe('postinstall')\n    expect(scripts[3]).toBe('prepare')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild does not fail when a linked package is present","suites":[],"updatePoint":{"line":75,"column":60},"line":75,"code":"test('rebuild does not fail when a linked package is present', async () => {\n  prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  f.copy('local-pkg', path.resolve('..', 'local-pkg'))\n\n  await execa('node', [\n    pnpmBin,\n    'add',\n    'link:../local-pkg',\n    'is-positive',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: false,\n    storeDir,\n  }, [])\n\n  // see related issue https://github.com/pnpm/pnpm/issues/1155\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuilds specific dependencies","suites":[],"updatePoint":{"line":104,"column":36},"line":104,"code":"test('rebuilds specific dependencies', async () => {\n  const project = prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  await execa('node', [\n    pnpmBin,\n    'add',\n    '--save-dev',\n    'pre-and-postinstall-scripts-example',\n    'zkochan/install-scripts-example',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: false,\n    storeDir,\n  }, ['install-scripts-example-for-pnpm'])\n\n  await project.hasNot('pre-and-postinstall-scripts-example/generated-by-preinstall')\n  await project.hasNot('pre-and-postinstall-scripts-example/generated-by-postinstall')\n\n  const generatedByPreinstall = project.requireModule('install-scripts-example-for-pnpm/generated-by-preinstall')\n  expect(typeof generatedByPreinstall).toBe('function')\n\n  const generatedByPostinstall = project.requireModule('install-scripts-example-for-pnpm/generated-by-postinstall')\n  expect(typeof generatedByPostinstall).toBe('function')\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild with pending option","suites":[],"updatePoint":{"line":139,"column":33},"line":139,"code":"test('rebuild with pending option', async () => {\n  const project = prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  await execa('node', [\n    pnpmBin,\n    'add',\n    'pre-and-postinstall-scripts-example',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n  await execa('node', [\n    pnpmBin,\n    'add',\n    'zkochan/install-scripts-example',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  let modules = await project.readModulesManifest()\n  expect(modules!.pendingBuilds).toStrictEqual([\n    '/pre-and-postinstall-scripts-example/1.0.0',\n    'github.com/zkochan/install-scripts-example/6d879afcee10ece4d3f0e8c09de2993232f3430a',\n  ])\n\n  await project.hasNot('pre-and-postinstall-scripts-example/generated-by-preinstall')\n  await project.hasNot('pre-and-postinstall-scripts-example/generated-by-postinstall')\n\n  await project.hasNot('install-scripts-example-for-pnpm/generated-by-preinstall')\n  await project.hasNot('install-scripts-example-for-pnpm/generated-by-postinstall')\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: true,\n    storeDir,\n  }, [])\n\n  modules = await project.readModulesManifest()\n  expect(modules).toBeTruthy()\n  expect(modules!.pendingBuilds.length).toBe(0)\n\n  {\n    const generatedByPreinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-preinstall')\n    expect(typeof generatedByPreinstall).toBe('function')\n\n    const generatedByPostinstall = project.requireModule('pre-and-postinstall-scripts-example/generated-by-postinstall')\n    expect(typeof generatedByPostinstall).toBe('function')\n  }\n\n  {\n    const generatedByPreinstall = project.requireModule('install-scripts-example-for-pnpm/generated-by-preinstall')\n    expect(typeof generatedByPreinstall).toBe('function')\n\n    const generatedByPostinstall = project.requireModule('install-scripts-example-for-pnpm/generated-by-postinstall')\n    expect(typeof generatedByPostinstall).toBe('function')\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild dependencies in correct order","suites":[],"updatePoint":{"line":205,"column":43},"line":205,"code":"test('rebuild dependencies in correct order', async () => {\n  const project = prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [\n    pnpmBin,\n    'add',\n    'with-postinstall-a',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  let modules = await project.readModulesManifest()\n  expect(modules).toBeTruthy()\n  expect(modules!.pendingBuilds.length).not.toBe(0)\n\n  await project.hasNot('.pnpm/with-postinstall-b@1.0.0/node_modules/with-postinstall-b/output.json')\n  await project.hasNot('with-postinstall-a/output.json')\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: false,\n    storeDir,\n  }, [])\n\n  modules = await project.readModulesManifest()\n  expect(modules).toBeTruthy()\n  expect(modules!.pendingBuilds.length).toBe(0)\n\n  expect(+project.requireModule('.pnpm/with-postinstall-b@1.0.0/node_modules/with-postinstall-b/output.json')[0] < +project.requireModule('with-postinstall-a/output.json')[0]).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild links bins","suites":[],"updatePoint":{"line":243,"column":24},"line":243,"code":"test('rebuild links bins', async () => {\n  const project = prepareEmpty()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [\n    pnpmBin,\n    'add',\n    'has-generated-bins-as-dep',\n    'generated-bins',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  expect(await exists(path.resolve('node_modules/.bin/cmd1'))).toBeFalsy()\n  expect(await exists(path.resolve('node_modules/.bin/cmd2'))).toBeFalsy()\n\n  expect(await exists(path.resolve('node_modules/has-generated-bins-as-dep/package.json'))).toBeTruthy()\n  expect(await exists(path.resolve('node_modules/has-generated-bins-as-dep/node_modules/.bin/cmd1'))).toBeFalsy()\n  expect(await exists(path.resolve('node_modules/has-generated-bins-as-dep/node_modules/.bin/cmd2'))).toBeFalsy()\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: true,\n    storeDir,\n  }, [])\n\n  await project.isExecutable('.bin/cmd1')\n  await project.isExecutable('.bin/cmd2')\n  await project.isExecutable('has-generated-bins-as-dep/node_modules/.bin/cmd1')\n  await project.isExecutable('has-generated-bins-as-dep/node_modules/.bin/cmd2')\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild should not fail on incomplete ","suites":[],"updatePoint":{"line":281,"column":62},"line":281,"code":"test(`rebuild should not fail on incomplete ${WANTED_LOCKFILE}`, async () => {\n  prepare({\n    dependencies: {\n      'pre-and-postinstall-scripts-example': '1.0.0',\n    },\n    optionalDependencies: {\n      'not-compatible-with-any-os': '1.0.0',\n    },\n  })\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [\n    pnpmBin,\n    'install',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    storeDir,\n    '--ignore-scripts',\n  ])\n\n  const reporter = sinon.spy()\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    cacheDir,\n    dir: process.cwd(),\n    pending: true,\n    reporter,\n    storeDir,\n  }, [])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"pnpm recursive rebuild","suites":[],"updatePoint":{"line":12,"column":28},"line":12,"code":"test('pnpm recursive rebuild', async () => {\n  const projects = preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'pre-and-postinstall-scripts-example': '*',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'pre-and-postinstall-scripts-example': '*',\n      },\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('node', [\n    pnpmBin,\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n    '--ignore-scripts',\n  ])\n\n  await projects['project-1'].hasNot('pre-and-postinstall-scripts-example/generated-by-preinstall.js')\n  await projects['project-1'].hasNot('pre-and-postinstall-scripts-example/generated-by-postinstall.js')\n  await projects['project-2'].hasNot('pre-and-postinstall-scripts-example/generated-by-preinstall.js')\n  await projects['project-2'].hasNot('pre-and-postinstall-scripts-example/generated-by-postinstall.js')\n\n  await rebuild.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, [])\n\n  await projects['project-1'].has('pre-and-postinstall-scripts-example/generated-by-preinstall.js')\n  await projects['project-1'].has('pre-and-postinstall-scripts-example/generated-by-postinstall.js')\n  await projects['project-2'].has('pre-and-postinstall-scripts-example/generated-by-preinstall.js')\n  await projects['project-2'].has('pre-and-postinstall-scripts-example/generated-by-postinstall.js')\n})","file":"recursive.ts","skipped":false,"dir":"packages/plugin-commands-rebuild/test"},{"name":"rebuild multiple packages in correct order","suites":[],"line":65,"code":"test.skip('rebuild multiple packages in correct order', async () => {","file":"recursive.ts","skipped":true,"dir":"packages/plugin-commands-rebuild/test"},{"name":"throws an error if called without arguments","suites":[],"updatePoint":{"line":8,"column":47},"line":8,"code":"it('throws an error if called without arguments', async () => {\n  await expect(create.handler({}, [])).rejects.toThrow(PnpmError)\n  expect(dlx.handler).not.toBeCalled()\n})","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"appends `create-` to an unscoped package that doesn't start with `create-`","suites":[],"updatePoint":{"line":14,"column":78},"line":13,"code":"it(\n  'appends `create-` to an unscoped package that doesn\\'t start with `create-`',\n  async () => {\n    await create.handler({}, ['some-app'])\n    expect(dlx.handler).toBeCalledWith({}, ['create-some-app'])\n\n    await create.handler({}, ['create_no_dash'])\n    expect(dlx.handler).toBeCalledWith({}, ['create-create_no_dash'])\n  }\n)","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"does not append `create-` to an unscoped package that starts with `create-`","suites":[],"updatePoint":{"line":25,"column":78},"line":24,"code":"it(\n  'does not append `create-` to an unscoped package that starts with `create-`',\n  async () => {\n    await create.handler({}, ['create-some-app'])\n    expect(dlx.handler).toBeCalledWith({}, ['create-some-app'])\n\n    await create.handler({}, ['create-'])\n    expect(dlx.handler).toBeCalledWith({}, ['create-'])\n  }\n)","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"appends `create-` to a scoped package that doesn't start with `create-`","suites":[],"updatePoint":{"line":36,"column":75},"line":35,"code":"it(\n  'appends `create-` to a scoped package that doesn\\'t start with `create-`',\n  async () => {\n    await create.handler({}, ['@scope/some-app'])\n    expect(dlx.handler).toBeCalledWith({}, ['@scope/create-some-app'])\n\n    await create.handler({}, ['@scope/create_no_dash'])\n    expect(dlx.handler).toBeCalledWith({}, ['@scope/create-create_no_dash'])\n  }\n)","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"does not append `create-` to a scoped package that starts with `create-`","suites":[],"updatePoint":{"line":47,"column":75},"line":46,"code":"it(\n  'does not append `create-` to a scoped package that starts with `create-`',\n  async () => {\n    await create.handler({}, ['@scope/create-some-app'])\n    expect(dlx.handler).toBeCalledWith({}, ['@scope/create-some-app'])\n\n    await create.handler({}, ['@scope/create-'])\n    expect(dlx.handler).toBeCalledWith({}, ['@scope/create-'])\n  }\n)","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"infers a package name from a plain scope","suites":[],"updatePoint":{"line":57,"column":44},"line":57,"code":"it('infers a package name from a plain scope', async () => {\n  await create.handler({}, ['@scope'])\n  expect(dlx.handler).toBeCalledWith({}, ['@scope/create'])\n})","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"passes the remaining arguments to `dlx`","suites":[],"updatePoint":{"line":62,"column":43},"line":62,"code":"it('passes the remaining arguments to `dlx`', async () => {\n  await create.handler({}, ['some-app', 'directory/', '--silent'])\n  expect(dlx.handler).toBeCalledWith({}, ['create-some-app', 'directory/', '--silent'])\n})","file":"create.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"dlx","suites":[],"updatePoint":{"line":5,"column":9},"line":5,"code":"test('dlx', async () => {\n  prepareEmpty()\n\n  await dlx.handler({}, ['shx', 'touch', 'foo'])\n\n  expect(fs.existsSync('foo')).toBeTruthy()\n})","file":"dlx.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"dlx --package <pkg1> [--package <pkg2>]","suites":[],"updatePoint":{"line":13,"column":45},"line":13,"code":"test('dlx --package <pkg1> [--package <pkg2>]', async () => {\n  prepareEmpty()\n\n  await dlx.handler({\n    package: [\n      'zkochan/for-testing-pnpm-dlx',\n      'is-positive',\n    ],\n  }, ['foo'])\n\n  expect(fs.existsSync('foo')).toBeTruthy()\n})","file":"dlx.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"dlx should work with scoped packages","suites":[],"updatePoint":{"line":9,"column":42},"line":9,"code":"test('dlx should work with scoped packages', async () => {\n  prepareEmpty()\n  const userAgent = 'pnpm/0.0.0'\n\n  await dlx.handler({ userAgent }, ['@foo/bar'])\n\n  expect(execa).toBeCalledWith('bar', [], expect.objectContaining({\n    env: expect.objectContaining({\n      npm_config_user_agent: userAgent,\n    }),\n  }))\n})","file":"dlx.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"dlx should work with versioned packages","suites":[],"updatePoint":{"line":22,"column":45},"line":22,"code":"test('dlx should work with versioned packages', async () => {\n  prepareEmpty()\n\n  await dlx.handler({}, ['@foo/bar@next'])\n\n  expect(execa).toBeCalledWith(\n    'pnpm',\n    expect.arrayContaining(['add', '@foo/bar@next']),\n    expect.anything()\n  )\n  expect(execa).toBeCalledWith('bar', [], expect.anything())\n})","file":"dlx.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive exec","suites":[],"updatePoint":{"line":13,"column":25},"line":13,"code":"test('pnpm recursive exec', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n  }, ['npm', 'run', 'build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1', 'project-2-prebuild', 'project-2', 'project-2-postbuild'])\n  expect(outputs2).toStrictEqual(['project-1', 'project-3'])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"exec inside a workspace package","suites":[],"updatePoint":{"line":77,"column":37},"line":77,"code":"test('exec inside a workspace package', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n  ])\n\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: path.resolve('project-1'),\n    recursive: false,\n    selectedProjectsGraph: {},\n  }, ['npm', 'run', 'build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1'])\n  expect(outputs2).toStrictEqual(['project-1'])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive exec sets PNPM_PACKAGE_NAME env var","suites":[],"updatePoint":{"line":140,"column":56},"line":140,"code":"test('pnpm recursive exec sets PNPM_PACKAGE_NAME env var', async () => {\n  preparePackages([\n    {\n      name: 'foo',\n      version: '1.0.0',\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n  }, ['node', '-e', 'require(\\'fs\\').writeFileSync(\\'pkgname\\', process.env.PNPM_PACKAGE_NAME, \\'utf8\\')'])\n\n  expect(await fs.readFile('foo/pkgname', 'utf8')).toBe('foo')\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"testing the bail config with \"pnpm recursive exec\"","suites":[],"updatePoint":{"line":159,"column":56},"line":159,"code":"test('testing the bail config with \"pnpm recursive exec\"', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'exit 1 && node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  let failed = false\n  let err1!: PnpmError\n  try {\n    await exec.handler({\n      ...DEFAULT_OPTS,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    }, ['npm', 'run', 'build', '--no-bail'])\n  } catch (_err: any) { // eslint-disable-line\n    err1 = _err\n    failed = true\n  }\n  expect(err1.code).toBe('ERR_PNPM_RECURSIVE_FAIL')\n  expect(failed).toBeTruthy()\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n  expect(outputs).toStrictEqual(['project-1', 'project-3'])\n\n  await rimraf('./output.json')\n\n  failed = false\n  let err2!: PnpmError\n  try {\n    await exec.handler({\n      ...DEFAULT_OPTS,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n    }, ['npm', 'run', 'build'])\n  } catch (_err: any) { // eslint-disable-line\n    err2 = _err\n    failed = true\n  }\n\n  expect(err2.code).toBe('ERR_PNPM_RECURSIVE_FAIL')\n  expect(failed).toBeTruthy()\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive exec --no-sort","suites":[],"updatePoint":{"line":247,"column":35},"line":247,"code":"test('pnpm recursive exec --no-sort', async () => {\n  preparePackages([\n    {\n      name: 'a-dependent',\n      version: '1.0.0',\n\n      dependencies: {\n        'b-dependency': '1.0.0',\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'a-dependent\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'b-dependency',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'b-dependency\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    sort: false,\n    workspaceConcurrency: 1,\n  }, ['npm', 'run', 'build'])\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n\n  expect(outputs).toStrictEqual(['a-dependent', 'b-dependency'])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive exec --reverse","suites":[],"updatePoint":{"line":297,"column":35},"line":297,"code":"test('pnpm recursive exec --reverse', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output1.json',\n      },\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    selectedProjectsGraph,\n    recursive: true,\n    sort: true,\n    reverse: true,\n  }, ['npm', 'run', 'build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n\n  expect(outputs1[outputs1.length - 1]).toBe('project-1')\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm exec on single project","suites":[],"updatePoint":{"line":359,"column":33},"line":359,"code":"test('pnpm exec on single project', async () => {\n  prepare({})\n\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: false,\n    selectedProjectsGraph: {},\n  }, ['node', '-e', 'require(\"fs\").writeFileSync(\"output.json\", \"[]\", \"utf8\")'])\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n  expect(outputs).toStrictEqual([])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm exec on single project should return non-zero exit code when the process fails","suites":[],"updatePoint":{"line":373,"column":89},"line":373,"code":"test('pnpm exec on single project should return non-zero exit code when the process fails', async () => {\n  prepare({})\n\n  {\n    const { exitCode } = await exec.handler({\n      ...DEFAULT_OPTS,\n      dir: process.cwd(),\n      recursive: false,\n      selectedProjectsGraph: {},\n    }, ['node', '-e', 'process.exitCode=1'])\n\n    expect(exitCode).toBe(1)\n  }\n\n  {\n    const runResult = await run.handler({\n      ...DEFAULT_OPTS,\n      argv: {\n        original: ['pnpm', 'node', '-e', 'process.exitCode=1'],\n      },\n      dir: process.cwd(),\n      fallbackCommandUsed: true,\n      recursive: false,\n      selectedProjectsGraph: {},\n    }, ['node'])\n\n    expect(runResult['exitCode']).toBe(1)\n  }\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm exec outside of projects","suites":[],"updatePoint":{"line":403,"column":35},"line":403,"code":"test('pnpm exec outside of projects', async () => {\n  prepareEmpty()\n\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: false,\n    selectedProjectsGraph: {},\n  }, ['node', '-e', 'require(\"fs\").writeFileSync(\"output.json\", \"[]\", \"utf8\")'])\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n  expect(outputs).toStrictEqual([])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm exec shell mode","suites":[],"updatePoint":{"line":417,"column":26},"line":417,"code":"test('pnpm exec shell mode', async () => {\n  prepareEmpty()\n\n  const echoArgs = process.platform === 'win32' ? '%PNPM_PACKAGE_NAME% > name.txt' : '$PNPM_PACKAGE_NAME > name.txt'\n\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: false,\n    selectedProjectsGraph: {\n      [process.cwd()]: {\n        dependencies: [],\n        package: {\n          dir: process.cwd(),\n          writeProjectManifest: async () => {},\n          manifest: {\n            name: 'test_shell_mode',\n          },\n        },\n      },\n    },\n    shellMode: true,\n  }, ['echo', echoArgs])\n\n  const result = (await fs.readFile(path.resolve('name.txt'), 'utf8')).trim()\n\n  expect(result).toBe('test_shell_mode')\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive exec works with PnP","suites":[],"updatePoint":{"line":446,"column":40},"line":446,"code":"test('pnpm recursive exec works with PnP', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n  ])\n\n  const { selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ], {\n    env: {\n      NPM_CONFIG_NODE_LINKER: 'pnp',\n      NPM_CONFIG_SYMLINK: 'false',\n    },\n  })\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n  }, ['npm', 'run', 'build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1', 'project-2-prebuild', 'project-2', 'project-2-postbuild'])\n  expect(outputs2).toStrictEqual(['project-1', 'project-3'])\n})","file":"exec.e2e.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"exec should set npm_config_user_agent","suites":[],"updatePoint":{"line":10,"column":43},"line":10,"code":"test('exec should set npm_config_user_agent', async () => {\n  prepareEmpty()\n  const userAgent = 'pnpm/0.0.0'\n\n  await exec.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    selectedProjectsGraph: {},\n    userAgent,\n  }, ['eslint'])\n\n  expect(execa).toBeCalledWith('eslint', [], expect.objectContaining({\n    env: expect.objectContaining({\n      npm_config_user_agent: userAgent,\n    }),\n  }))\n})","file":"exec.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm run: returns correct exit code","suites":[],"updatePoint":{"line":20,"column":41},"line":20,"code":"test('pnpm run: returns correct exit code', async () => {\n  prepare({\n    scripts: {\n      exit0: 'exit 0',\n      exit1: 'exit 1',\n    },\n  })\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['exit0'])\n\n  let err!: Error & { errno: Number }\n  try {\n    await run.handler({\n      dir: process.cwd(),\n      extraBinPaths: [],\n      rawConfig: {},\n    }, ['exit1'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.errno).toBe(1)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm run --no-bail never fails","suites":[],"updatePoint":{"line":47,"column":36},"line":47,"code":"test('pnpm run --no-bail never fails', async () => {\n  prepare({\n    scripts: {\n      exit1: 'node recordArgs && exit 1',\n    },\n  })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await run.handler({\n    bail: false,\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['exit1'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([[]])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"run: pass the args to the command that is specified in the build script","suites":[],"updatePoint":{"line":69,"column":77},"line":69,"code":"test('run: pass the args to the command that is specified in the build script', async () => {\n  prepare({\n    scripts: {\n      foo: 'node recordArgs',\n      postfoo: 'node recordArgs',\n      prefoo: 'node recordArgs',\n    },\n  })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['foo', 'arg', '--flag=true', '--help', '-h'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([['arg', '--flag=true', '--help', '-h']])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"run: pass the args to the command that is specified in the build script of a package.yaml manifest","suites":[],"updatePoint":{"line":90,"column":104},"line":90,"code":"test('run: pass the args to the command that is specified in the build script of a package.yaml manifest', async () => {\n  prepare({\n    scripts: {\n      foo: 'node recordArgs',\n      postfoo: 'node recordArgs',\n      prefoo: 'node recordArgs',\n    },\n  }, { manifestFormat: 'YAML' })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['foo', 'arg', '--flag=true', '--help', '-h'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([['arg', '--flag=true', '--help', '-h']])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"test: pass the args to the command that is specified in the build script of a package.yaml manifest","suites":[],"updatePoint":{"line":111,"column":105},"line":111,"code":"test('test: pass the args to the command that is specified in the build script of a package.yaml manifest', async () => {\n  prepare({\n    scripts: {\n      posttest: 'node recordArgs',\n      pretest: 'node recordArgs',\n      test: 'node recordArgs',\n    },\n  }, { manifestFormat: 'YAML' })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await testCommand.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['arg', '--flag=true', '--help', '-h'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([['arg', '--flag=true', '--help', '-h']])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"run start: pass the args to the command that is specified in the build script of a package.yaml manifest","suites":[],"updatePoint":{"line":132,"column":110},"line":132,"code":"test('run start: pass the args to the command that is specified in the build script of a package.yaml manifest', async () => {\n  prepare({\n    scripts: {\n      poststart: 'node recordArgs',\n      prestart: 'node recordArgs',\n      start: 'node recordArgs',\n    },\n  }, { manifestFormat: 'YAML' })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['start', 'arg', '--flag=true', '--help', '-h'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([['arg', '--flag=true', '--help', '-h']])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"run stop: pass the args to the command that is specified in the build script of a package.yaml manifest","suites":[],"updatePoint":{"line":153,"column":109},"line":153,"code":"test('run stop: pass the args to the command that is specified in the build script of a package.yaml manifest', async () => {\n  prepare({\n    scripts: {\n      poststop: 'node recordArgs',\n      prestop: 'node recordArgs',\n      stop: 'node recordArgs',\n    },\n  }, { manifestFormat: 'YAML' })\n  await fs.writeFile('args.json', '[]', 'utf8')\n  await fs.writeFile('recordArgs.js', RECORD_ARGS_FILE, 'utf8')\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['stop', 'arg', '--flag=true', '--help', '-h'])\n\n  const { default: args } = await import(path.resolve('args.json'))\n  expect(args).toStrictEqual([['arg', '--flag=true', '--help', '-h']])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"restart: run stop, restart and start","suites":[],"updatePoint":{"line":174,"column":42},"line":174,"code":"test('restart: run stop, restart and start', async () => {\n  prepare({\n    scripts: {\n      poststop: 'node -e \"process.stdout.write(\\'poststop\\')\" | json-append ./output.json',\n      prestop: 'node -e \"process.stdout.write(\\'prestop\\')\" | json-append ./output.json',\n      stop: 'node -e \"process.stdout.write(\\'stop\\')\" | json-append ./output.json',\n\n      postrestart: 'node -e \"process.stdout.write(\\'postrestart\\')\" | json-append ./output.json',\n      prerestart: 'node -e \"process.stdout.write(\\'prerestart\\')\" | json-append ./output.json',\n      restart: 'node -e \"process.stdout.write(\\'restart\\')\" | json-append ./output.json',\n\n      poststart: 'node -e \"process.stdout.write(\\'poststart\\')\" | json-append ./output.json',\n      prestart: 'node -e \"process.stdout.write(\\'prestart\\')\" | json-append ./output.json',\n      start: 'node -e \"process.stdout.write(\\'start\\')\" | json-append ./output.json',\n    },\n  })\n\n  await execa('pnpm', ['add', 'json-append@1'])\n  await restart.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, [])\n\n  const { default: scriptsRan } = await import(path.resolve('output.json'))\n  expect(scriptsRan).toStrictEqual([\n    'stop',\n    'restart',\n    'start',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"restart: run stop, restart and start and all the pre/post scripts","suites":[],"updatePoint":{"line":206,"column":71},"line":206,"code":"test('restart: run stop, restart and start and all the pre/post scripts', async () => {\n  prepare({\n    scripts: {\n      poststop: 'node -e \"process.stdout.write(\\'poststop\\')\" | json-append ./output.json',\n      prestop: 'node -e \"process.stdout.write(\\'prestop\\')\" | json-append ./output.json',\n      stop: 'pnpm prestop && node -e \"process.stdout.write(\\'stop\\')\" | json-append ./output.json && pnpm poststop',\n\n      postrestart: 'node -e \"process.stdout.write(\\'postrestart\\')\" | json-append ./output.json',\n      prerestart: 'node -e \"process.stdout.write(\\'prerestart\\')\" | json-append ./output.json',\n      restart: 'node -e \"process.stdout.write(\\'restart\\')\" | json-append ./output.json',\n\n      poststart: 'node -e \"process.stdout.write(\\'poststart\\')\" | json-append ./output.json',\n      prestart: 'node -e \"process.stdout.write(\\'prestart\\')\" | json-append ./output.json',\n      start: 'node -e \"process.stdout.write(\\'start\\')\" | json-append ./output.json',\n    },\n  })\n\n  await execa('pnpm', ['add', 'json-append@1'])\n  await restart.handler({\n    dir: process.cwd(),\n    enablePrePostScripts: true,\n    extraBinPaths: [],\n    rawConfig: {},\n  }, [])\n\n  const { default: scriptsRan } = await import(path.resolve('output.json'))\n  expect(scriptsRan).toStrictEqual([\n    'prestop',\n    'stop',\n    'poststop',\n    'prerestart',\n    'restart',\n    'postrestart',\n    'prestart',\n    'start',\n    'poststart',\n  ])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"\"pnpm run\" prints the list of available commands","suites":[],"updatePoint":{"line":245,"column":54},"line":245,"code":"test('\"pnpm run\" prints the list of available commands', async () => {\n  prepare({\n    scripts: {\n      foo: 'echo hi',\n      test: 'ts-node test',\n    },\n  })\n\n  const output = await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, [])\n\n  expect(output).toBe(`\\\nLifecycle scripts:\n  test\n    ts-node test\n\nCommands available via \"pnpm run\":\n  foo\n    echo hi`)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"\"pnpm run\" prints the list of available commands, including commands of the root workspace project","suites":[],"updatePoint":{"line":269,"column":104},"line":269,"code":"test('\"pnpm run\" prints the list of available commands, including commands of the root workspace project', async () => {\n  preparePackages([\n    {\n      location: '.',\n      package: {\n        dependencies: {\n          'json-append': '1',\n        },\n        scripts: {\n          build: 'echo root',\n          test: 'test-all',\n        },\n      },\n    },\n    {\n      name: 'foo',\n      version: '1.0.0',\n\n      scripts: {\n        foo: 'echo hi',\n        test: 'ts-node test',\n      },\n    },\n  ])\n  await writeYamlFile('pnpm-workspace.yaml', {})\n  const workspaceDir = process.cwd()\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n\n  {\n    process.chdir('foo')\n    const output = await run.handler({\n      allProjects,\n      dir: process.cwd(),\n      extraBinPaths: [],\n      rawConfig: {},\n      selectedProjectsGraph,\n      workspaceDir,\n    }, [])\n\n    expect(output).toBe(`\\\nLifecycle scripts:\n  test\n    ts-node test\n\nCommands available via \"pnpm run\":\n  foo\n    echo hi\n\nCommands of the root workspace project (to run them, use \"pnpm -w run\"):\n  build\n    echo root\n  test\n    test-all`)\n  }\n  {\n    process.chdir('..')\n    const output = await run.handler({\n      allProjects,\n      dir: process.cwd(),\n      extraBinPaths: [],\n      rawConfig: {},\n      selectedProjectsGraph,\n      workspaceDir,\n    }, [])\n\n    expect(output).toBe(`\\\nLifecycle scripts:\n  test\n    test-all\n\nCommands available via \"pnpm run\":\n  build\n    echo root`)\n  }\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm run does not fail with --if-present even if the wanted script is not present","suites":[],"updatePoint":{"line":346,"column":87},"line":346,"code":"test('pnpm run does not fail with --if-present even if the wanted script is not present', async () => {\n  prepare({})\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    ifPresent: true,\n    rawConfig: {},\n  }, ['build'])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"if a script is not found but is present in the root, print an info message about it in the error message","suites":[],"updatePoint":{"line":357,"column":110},"line":357,"code":"test('if a script is not found but is present in the root, print an info message about it in the error message', async () => {\n  preparePackages([\n    {\n      location: '.',\n      package: {\n        dependencies: {\n          'json-append': '1',\n        },\n        scripts: {\n          build: 'node -e \"process.stdout.write(\\'root\\')\" | json-append ./output.json',\n        },\n      },\n    },\n    {\n      name: 'foo',\n      version: '1.0.0',\n    },\n  ])\n  await writeYamlFile('pnpm-workspace.yaml', {})\n\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n\n  let err!: PnpmError\n  try {\n    await run.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: path.resolve('foo'),\n      selectedProjectsGraph,\n      workspaceDir: process.cwd(),\n    }, ['build'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err).toBeTruthy()\n  expect(err.hint).toMatch(/But build is present in the root/)\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"scripts work with PnP","suites":[],"updatePoint":{"line":404,"column":27},"line":404,"code":"test('scripts work with PnP', async () => {\n  prepare({\n    scripts: {\n      foo: 'node -e \"process.stdout.write(\\'foo\\')\" | json-append ./output.json',\n    },\n  })\n\n  await execa(pnpmBin, ['add', 'json-append@1'], {\n    env: {\n      NPM_CONFIG_NODE_LINKER: 'pnp',\n      NPM_CONFIG_SYMLINK: 'false',\n    },\n  })\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n  }, ['foo'])\n\n  const { default: scriptsRan } = await import(path.resolve('output.json'))\n  expect(scriptsRan).toStrictEqual(['foo'])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm run with custom shell","suites":[],"updatePoint":{"line":427,"column":32},"line":427,"code":"test('pnpm run with custom shell', async () => {\n  prepare({\n    scripts: {\n      build: 'foo bar',\n    },\n    dependencies: {\n      'shell-mock': '0.0.0',\n    },\n  })\n\n  await execa(pnpmBin, [\n    'install',\n    `--registry=http://localhost:${REGISTRY_MOCK_PORT}`,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  await run.handler({\n    dir: process.cwd(),\n    extraBinPaths: [],\n    rawConfig: {},\n    scriptShell: path.resolve(`node_modules/.bin/shell-mock${isWindows() ? '.cmd' : ''}`),\n  }, ['build'])\n\n  expect((await import(path.resolve('shell-input.json'))).default).toStrictEqual(['-c', 'foo bar'])\n})","file":"index.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"run completion","suites":[],"updatePoint":{"line":4,"column":20},"line":4,"code":"test('run completion', async () => {\n  prepare({\n    scripts: {\n      lint: 'eslint',\n      test: 'node test.js',\n    },\n  })\n\n  expect(\n    await run.completion({}, [])\n  ).toStrictEqual(\n    [\n      {\n        name: 'lint',\n      },\n      {\n        name: 'test',\n      },\n    ]\n  )\n\n  expect(await run.completion({}, ['test'])).toStrictEqual([])\n})","file":"runCompletion.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive run","suites":[],"updatePoint":{"line":13,"column":24},"line":13,"code":"test('pnpm recursive run', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n\n      dependencies: {},\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1', 'project-2'])\n  expect(outputs2).toStrictEqual(['project-1', 'project-3'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive run with enable-pre-post-scripts","suites":[],"updatePoint":{"line":85,"column":53},"line":85,"code":"test('pnpm recursive run with enable-pre-post-scripts', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n\n      dependencies: {},\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    enablePrePostScripts: true,\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1', 'project-2-prebuild', 'project-2', 'project-2-postbuild'])\n  expect(outputs2).toStrictEqual(['project-1', 'project-3'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive run reversed","suites":[],"updatePoint":{"line":158,"column":33},"line":158,"code":"test('pnpm recursive run reversed', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output1.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n\n      dependencies: {},\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    reverse: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-2', 'project-1'])\n  expect(outputs2).toStrictEqual(['project-3', 'project-1'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive run concurrently","suites":[],"updatePoint":{"line":231,"column":37},"line":231,"code":"test('pnpm recursive run concurrently', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"let i = 20;setInterval(() => {if (!--i) process.exit(0); require(\\'json-append\\').append(Date.now(),\\'../output1.json\\');},50)\"',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"let i = 40;setInterval(() => {if (!--i) process.exit(0); require(\\'json-append\\').append(Date.now(),\\'../output2.json\\');},25)\"',\n      },\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(Math.max(outputs1[0], outputs2[0]) < Math.min(outputs1[outputs1.length - 1], outputs2[outputs2.length - 1])).toBeTruthy()\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm recursive run` fails when run without filters and no package has the desired command, unless if-present is set","suites":[],"updatePoint":{"line":281,"column":122},"line":281,"code":"test('`pnpm recursive run` fails when run without filters and no package has the desired command, unless if-present is set', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  console.log('recursive run does not fail when if-present is true')\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    ifPresent: true,\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['this-command-does-not-exist'])\n\n  let err!: PnpmError\n  try {\n    await run.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n      workspaceDir: process.cwd(),\n    }, ['this-command-does-not-exist'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.code).toBe('ERR_PNPM_RECURSIVE_RUN_NO_SCRIPT')\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm recursive run` fails when run with a filter that includes all packages and no package has the desired command, unless if-present is set","suites":[],"updatePoint":{"line":346,"column":147},"line":346,"code":"test('`pnpm recursive run` fails when run with a filter that includes all packages and no package has the desired command, unless if-present is set', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n    },\n  ])\n\n  console.log('recursive run does not fail when if-present is true')\n  await run.handler({\n    ...DEFAULT_OPTS,\n    ...await readProjects(process.cwd(), [{ namePattern: '*' }]),\n    dir: process.cwd(),\n    ifPresent: true,\n    recursive: true,\n    workspaceDir: process.cwd(),\n  }, ['this-command-does-not-exist'])\n\n  let err!: PnpmError\n  try {\n    await run.handler({\n      ...DEFAULT_OPTS,\n      ...await readProjects(process.cwd(), [{ namePattern: '*' }]),\n      dir: process.cwd(),\n      recursive: true,\n      workspaceDir: process.cwd(),\n    }, ['this-command-does-not-exist'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.code).toBe('ERR_PNPM_RECURSIVE_RUN_NO_SCRIPT')\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm recursive run` succeeds when run against a subset of packages and no package has the desired command","suites":[],"updatePoint":{"line":399,"column":112},"line":399,"code":"test('`pnpm recursive run` succeeds when run against a subset of packages and no package has the desired command', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n    },\n  ])\n\n  const { allProjects } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  const { selectedProjectsGraph } = await filterPkgsBySelectorObjects(\n    allProjects,\n    [{ namePattern: 'project-1' }],\n    { workspaceDir: process.cwd() }\n  )\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['this-command-does-not-exist'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"\"pnpm run --filter <pkg>\" without specifying the script name","suites":[],"updatePoint":{"line":451,"column":66},"line":451,"code":"test('\"pnpm run --filter <pkg>\" without specifying the script name', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      scripts: {\n        foo: 'echo hi',\n        test: 'ts-node test',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n    },\n  ])\n\n  const { allProjects } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  console.log('prints the list of available commands if a single project is selected')\n  {\n    const { selectedProjectsGraph } = await filterPkgsBySelectorObjects(\n      allProjects,\n      [{ namePattern: 'project-1' }],\n      { workspaceDir: process.cwd() }\n    )\n    const output = await run.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n      workspaceDir: process.cwd(),\n    }, [])\n\n    expect(output).toBe(`\\\nLifecycle scripts:\n  test\n    ts-node test\n\nCommands available via \"pnpm run\":\n  foo\n    echo hi`)\n  }\n  console.log('throws an error if several projects are selected')\n  {\n    const { selectedProjectsGraph } = await filterPkgsBySelectorObjects(\n      allProjects,\n      [{ includeDependents: true, namePattern: 'project-1' }],\n      { workspaceDir: process.cwd() }\n    )\n\n    let err!: PnpmError\n    try {\n      await run.handler({\n        ...DEFAULT_OPTS,\n        allProjects,\n        dir: process.cwd(),\n        recursive: true,\n        selectedProjectsGraph,\n        workspaceDir: process.cwd(),\n      }, [])\n    } catch (_err: any) { // eslint-disable-line\n      err = _err\n    }\n\n    expect(err).toBeTruthy()\n    expect(err.code).toBe('ERR_PNPM_SCRIPT_NAME_IS_REQUIRED')\n    expect(err.message).toBe('You must specify the script you want to run')\n  }\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"testing the bail config with \"pnpm recursive run\"","suites":[],"updatePoint":{"line":547,"column":55},"line":547,"code":"test('testing the bail config with \"pnpm recursive run\"', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'exit 1 && node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  let err1!: PnpmError\n  try {\n    await run.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n      workspaceDir: process.cwd(),\n    }, ['build', '--no-bail'])\n  } catch (_err: any) { // eslint-disable-line\n    err1 = _err\n  }\n  expect(err1.code).toBe('ERR_PNPM_RECURSIVE_FAIL')\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n  expect(outputs).toStrictEqual(['project-1', 'project-3'])\n\n  await rimraf('./output.json')\n\n  let err2!: PnpmError\n  try {\n    await run.handler({\n      ...DEFAULT_OPTS,\n      allProjects,\n      dir: process.cwd(),\n      recursive: true,\n      selectedProjectsGraph,\n      workspaceDir: process.cwd(),\n    }, ['build'])\n  } catch (_err: any) { // eslint-disable-line\n    err2 = _err\n  }\n\n  expect(err2.code).toBe('ERR_PNPM_RECURSIVE_FAIL')\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive run with filtering","suites":[],"updatePoint":{"line":633,"column":39},"line":633,"code":"test('pnpm recursive run with filtering', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output.json',\n        postbuild: 'node -e \"process.stdout.write(\\'project-2-postbuild\\')\" | json-append ../output.json',\n        prebuild: 'node -e \"process.stdout.write(\\'project-2-prebuild\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  const { allProjects } = await readProjects(process.cwd(), [])\n  const { selectedProjectsGraph } = await filterPkgsBySelectorObjects(\n    allProjects,\n    [{ namePattern: 'project-1' }],\n    { workspaceDir: process.cwd() }\n  )\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n\n  expect(outputs).toStrictEqual(['project-1'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm recursive run` should always trust the scripts","suites":[],"updatePoint":{"line":690,"column":58},"line":690,"code":"test('`pnpm recursive run` should always trust the scripts', async () => {\n  preparePackages([\n    {\n      name: 'project',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  process.env['npm_config_unsafe_perm'] = 'false'\n  await run.handler({\n    ...DEFAULT_OPTS,\n    dir: process.cwd(),\n    recursive: true,\n    workspaceDir: process.cwd(),\n    ...await readProjects(process.cwd(), []),\n  }, ['build'])\n  delete process.env.npm_config_unsafe_perm\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n\n  expect(outputs).toStrictEqual(['project'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm run -r` should avoid infinite recursion","suites":[],"updatePoint":{"line":729,"column":51},"line":729,"code":"test('`pnpm run -r` should avoid infinite recursion', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      scripts: {\n        build: `node ${pnpmBin} run -r build`,\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        build: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n  ])\n  await writeYamlFile('pnpm-workspace.yaml', {})\n\n  await execa(pnpmBin, [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [{ namePattern: 'project-1' }])\n  await run.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: path.resolve('project-1'),\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  }, ['build'])\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-2'])\n  expect(outputs2).toStrictEqual(['project-3'])\n})","file":"runRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive test","suites":[],"updatePoint":{"line":8,"column":25},"line":8,"code":"test('pnpm recursive test', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        test: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output1.json && node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        test: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output1.json',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        test: 'node -e \"process.stdout.write(\\'project-3\\')\" | json-append ../output2.json',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n\n      dependencies: {},\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await testCommand.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  const { default: outputs1 } = await import(path.resolve('output1.json'))\n  const { default: outputs2 } = await import(path.resolve('output2.json'))\n\n  expect(outputs1).toStrictEqual(['project-1', 'project-2'])\n  expect(outputs2).toStrictEqual(['project-1', 'project-3'])\n})","file":"testRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"`pnpm recursive test` does not fail if none of the packages has a test command","suites":[],"updatePoint":{"line":78,"column":84},"line":78,"code":"test('`pnpm recursive test` does not fail if none of the packages has a test command', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-3',\n      version: '1.0.0',\n\n      dependencies: {\n        'project-1': '1',\n      },\n    },\n    {\n      name: 'project-0',\n      version: '1.0.0',\n\n      dependencies: {},\n    },\n  ])\n\n  const { allProjects, selectedProjectsGraph } = await readProjects(process.cwd(), [])\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n\n  await testCommand.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n})","file":"testRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"pnpm recursive test with filtering","suites":[],"updatePoint":{"line":128,"column":40},"line":128,"code":"test('pnpm recursive test with filtering', async () => {\n  preparePackages([\n    {\n      name: 'project-1',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n      },\n      scripts: {\n        test: 'node -e \"process.stdout.write(\\'project-1\\')\" | json-append ../output.json',\n      },\n    },\n    {\n      name: 'project-2',\n      version: '1.0.0',\n\n      dependencies: {\n        'json-append': '1',\n        'project-1': '1',\n      },\n      scripts: {\n        test: 'node -e \"process.stdout.write(\\'project-2\\')\" | json-append ../output.json',\n      },\n    },\n  ])\n\n  const { allProjects } = await readProjects(process.cwd(), [])\n  const { selectedProjectsGraph } = await filterPkgsBySelectorObjects(\n    allProjects,\n    [{ namePattern: 'project-1' }],\n    { workspaceDir: process.cwd() }\n  )\n  await execa('pnpm', [\n    'install',\n    '-r',\n    '--registry',\n    REGISTRY,\n    '--store-dir',\n    path.resolve(DEFAULT_OPTS.storeDir),\n  ])\n  await testCommand.handler({\n    ...DEFAULT_OPTS,\n    allProjects,\n    dir: process.cwd(),\n    recursive: true,\n    selectedProjectsGraph,\n    workspaceDir: process.cwd(),\n  })\n\n  const { default: outputs } = await import(path.resolve('output.json'))\n\n  expect(outputs).toStrictEqual(['project-1'])\n})","file":"testRecursive.ts","skipped":false,"dir":"packages/plugin-commands-script-runners/test"},{"name":"PNPM_HOME is added to ~/.bashrc","suites":[],"updatePoint":{"line":15,"column":37},"line":15,"code":"test('PNPM_HOME is added to ~/.bashrc', async () => {\n  process.env.SHELL = '/bin/bash'\n  tempDir()\n  fs.writeFileSync('.bashrc', '', 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^Updated /)\n  const bashRCContent = fs.readFileSync('.bashrc', 'utf8')\n  expect(bashRCContent).toEqual(`\nexport PNPM_HOME=\"${__dirname}\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is added to ~/.bashrc and .bashrc file created","suites":[],"updatePoint":{"line":31,"column":62},"line":31,"code":"test('PNPM_HOME is added to ~/.bashrc and .bashrc file created', async () => {\n  process.env.SHELL = '/bin/bash'\n  tempDir()\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^Created /)\n  const bashRCContent = fs.readFileSync('.bashrc', 'utf8')\n  expect(bashRCContent).toEqual(`export PNPM_HOME=\"${__dirname}\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is not added to ~/.bashrc if already present","suites":[],"updatePoint":{"line":45,"column":60},"line":45,"code":"test('PNPM_HOME is not added to ~/.bashrc if already present', async () => {\n  process.env.SHELL = '/bin/bash'\n  tempDir()\n  fs.writeFileSync('.bashrc', `\nexport PNPM_HOME=\"pnpm_home\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`, 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^PNPM_HOME is already in /)\n  const bashRCContent = fs.readFileSync('.bashrc', 'utf8')\n  expect(bashRCContent).toEqual(`\nexport PNPM_HOME=\"pnpm_home\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is added to ~/.zshrc","suites":[],"updatePoint":{"line":64,"column":36},"line":64,"code":"test('PNPM_HOME is added to ~/.zshrc', async () => {\n  process.env.SHELL = '/bin/zsh'\n  tempDir()\n  fs.writeFileSync('.zshrc', '', 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^Updated /)\n  const bashRCContent = fs.readFileSync('.zshrc', 'utf8')\n  expect(bashRCContent).toEqual(`\nexport PNPM_HOME=\"${__dirname}\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is not added to ~/.zshrc if already present","suites":[],"updatePoint":{"line":80,"column":59},"line":80,"code":"test('PNPM_HOME is not added to ~/.zshrc if already present', async () => {\n  process.env.SHELL = '/bin/zsh'\n  tempDir()\n  fs.writeFileSync('.zshrc', `\nexport PNPM_HOME=\"pnpm_home\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`, 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^PNPM_HOME is already in /)\n  const bashRCContent = fs.readFileSync('.zshrc', 'utf8')\n  expect(bashRCContent).toEqual(`\nexport PNPM_HOME=\"pnpm_home\"\nexport PATH=\"$PNPM_HOME:$PATH\"\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is added to ~/.config/fish/config.fish","suites":[],"updatePoint":{"line":99,"column":54},"line":99,"code":"test('PNPM_HOME is added to ~/.config/fish/config.fish', async () => {\n  process.env.SHELL = '/bin/fish'\n  tempDir()\n  fs.mkdirSync('.config/fish', { recursive: true })\n  fs.writeFileSync('.config/fish/config.fish', '', 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^Updated /)\n  const bashRCContent = fs.readFileSync('.config/fish/config.fish', 'utf8')\n  expect(bashRCContent).toEqual(`\nset -gx PNPM_HOME \"${__dirname}\"\nset -gx PATH \"$PNPM_HOME\" $PATH\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is added to ~/.config/fish/config.fish and config.fish file created","suites":[],"updatePoint":{"line":116,"column":83},"line":116,"code":"test('PNPM_HOME is added to ~/.config/fish/config.fish and config.fish file created', async () => {\n  process.env.SHELL = '/bin/fish'\n  tempDir()\n  fs.mkdirSync('.config/fish', { recursive: true })\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^Created /)\n  const bashRCContent = fs.readFileSync('.config/fish/config.fish', 'utf8')\n  expect(bashRCContent).toEqual(`set -gx PNPM_HOME \"${__dirname}\"\nset -gx PATH \"$PNPM_HOME\" $PATH\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is not added to ~/.config/fish/config.fish if already present","suites":[],"updatePoint":{"line":131,"column":77},"line":131,"code":"test('PNPM_HOME is not added to ~/.config/fish/config.fish if already present', async () => {\n  process.env.SHELL = '/bin/fish'\n  tempDir()\n  fs.mkdirSync('.config/fish', { recursive: true })\n  fs.writeFileSync('.config/fish/config.fish', `\nset -gx PNPM_HOME \"pnpm_home\"\nset -gx PATH \"$PNPM_HOME\" $PATH\n`, 'utf8')\n  homedir['mockReturnValue'](process.cwd())\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n  expect(output).toMatch(/^PNPM_HOME is already in /)\n  const bashRCContent = fs.readFileSync('.config/fish/config.fish', 'utf8')\n  expect(bashRCContent).toEqual(`\nset -gx PNPM_HOME \"pnpm_home\"\nset -gx PATH \"$PNPM_HOME\" $PATH\n`)\n})","file":"setup.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Win32 registry environment values could not be retrieved","suites":[],"updatePoint":{"line":28,"column":62},"line":28,"code":"test('Win32 registry environment values could not be retrieved', async () => {\n  execa['mockResolvedValue']({\n    failed: true,\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(output).toContain('Win32 registry environment values could not be retrieved')\n})","file":"setupOnWindows/01.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Environment PATH is not configured correctly","suites":[],"updatePoint":{"line":28,"column":50},"line":28,"code":"test('Environment PATH is not configured correctly', async () => {\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: 'SOME KIND OF ERROR OR UNSUPPORTED RESPONSE FORMAT',\n  }).mockResolvedValue({\n    failed: true,\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(output).toContain('Current PATH is not set. No changes to this environment variable are applied')\n})","file":"setupOnWindows/02.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Environment PATH is empty","suites":[],"updatePoint":{"line":28,"column":31},"line":28,"code":"test('Environment PATH is empty', async () => {\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: `\nHKEY_CURRENT_USER\\\\Environment\n    Path    REG_EXPAND_SZ    \n`,\n  }).mockResolvedValue({\n    failed: false,\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(output).toContain('Current PATH is empty. No changes to this environment variable are applied')\n})","file":"setupOnWindows/03.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Successful first time installation","suites":[],"updatePoint":{"line":28,"column":40},"line":28,"code":"test('Successful first time installation', async () => {\n  const currentPathInRegistry = '%USERPROFILE%\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;%USERPROFILE%\\\\.config\\\\etc;'\n\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: `\nHKEY_CURRENT_USER\\\\Environment\n    Path    REG_EXPAND_SZ    ${currentPathInRegistry}\n`,\n  }).mockResolvedValueOnce({\n    failed: false,\n    stdout: 'PNPM_HOME ENV VAR SET',\n  }).mockResolvedValueOnce({\n    failed: false,\n    stdout: 'PATH UPDATED',\n  }).mockResolvedValue({\n    failed: true,\n    stderr: 'UNEXPECTED',\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(execa).toHaveBeenNthCalledWith(2, 'reg', ['add', regKey, '/v', 'PNPM_HOME', '/t', 'REG_EXPAND_SZ', '/d', __dirname, '/f'])\n  expect(execa).toHaveBeenNthCalledWith(3, 'reg', ['add', regKey, '/v', 'Path', '/t', 'REG_EXPAND_SZ', '/d', `${__dirname};${currentPathInRegistry}`, '/f'])\n  expect(execa).toHaveBeenNthCalledWith(4, 'setx', ['PNPM_HOME', __dirname])\n  expect(output).toContain(`Setting 'PNPM_HOME' to value '${__dirname}`)\n  expect(output).toContain('Updating PATH')\n  expect(output).toContain('PNPM_HOME ENV VAR SET')\n  expect(output).toContain('PATH UPDATED')\n})","file":"setupOnWindows/04.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"PNPM_HOME is already set, but path is updated","suites":[],"updatePoint":{"line":28,"column":51},"line":28,"code":"test('PNPM_HOME is already set, but path is updated', async () => {\n  const currentPathInRegistry = '%USERPROFILE%\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;%USERPROFILE%\\\\.config\\\\etc;'\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: `\nHKEY_CURRENT_USER\\\\Environment\n    PNPM_HOME    REG_EXPAND_SZ    .pnpm\\\\home\n    Path    REG_EXPAND_SZ    ${currentPathInRegistry}\n`,\n  }).mockResolvedValueOnce({\n    failed: false,\n    stdout: 'PATH UPDATED',\n  }).mockResolvedValue({\n    failed: true,\n    stderr: 'UNEXPECTED',\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(execa).toHaveBeenNthCalledWith(2, 'reg', ['add', regKey, '/v', 'Path', '/t', 'REG_EXPAND_SZ', '/d', `${'.pnpm\\\\home'};${currentPathInRegistry}`, '/f'])\n  expect(execa).toHaveBeenNthCalledWith(3, 'setx', ['PNPM_HOME', '.pnpm\\\\home'])\n  expect(output).toContain(`Currently 'PNPM_HOME' is set to '${'.pnpm\\\\home'}'`)\n  expect(output).toContain('Updating PATH')\n  expect(output).toContain('PATH UPDATED')\n})","file":"setupOnWindows/05.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Existing installation","suites":[],"updatePoint":{"line":28,"column":27},"line":28,"code":"test('Existing installation', async () => {\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: `\nHKEY_CURRENT_USER\\\\Environment\n    PNPM_HOME    REG_EXPAND_SZ    .pnpm\\\\home\n    Path    REG_EXPAND_SZ    %USERPROFILE%\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;%USERPROFILE%\\\\.config\\\\etc;.pnpm\\\\home;C:\\\\Windows;\n`,\n  }).mockResolvedValue({\n    failed: true,\n    stderr: 'UNEXPECTED',\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(output).toContain(`Currently 'PNPM_HOME' is set to '${'.pnpm\\\\home'}'`)\n  expect(output).toContain('PATH already contains PNPM_HOME')\n})","file":"setupOnWindows/06.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"Failure to install","suites":[],"updatePoint":{"line":28,"column":24},"line":28,"code":"test('Failure to install', async () => {\n  const currentPathInRegistry = '%USERPROFILE%\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;%USERPROFILE%\\\\.config\\\\etc;'\n\n  execa['mockResolvedValueOnce']({\n    failed: false,\n    stdout: `\nHKEY_CURRENT_USER\\\\Environment\n    Path    REG_EXPAND_SZ    ${currentPathInRegistry}\n`,\n  }).mockResolvedValueOnce({\n    failed: true,\n    stderr: 'FAILED TO SET PNPM_HOME',\n  }).mockResolvedValueOnce({\n    failed: true,\n    stderr: 'FAILED TO UPDATE PATH',\n  }).mockResolvedValue({\n    failed: true,\n    stderr: 'UNEXPECTED',\n  })\n\n  const output = await setup.handler({\n    pnpmHomeDir: __dirname,\n  })\n\n  expect(execa).toHaveBeenNthCalledWith(1, 'reg', ['query', regKey])\n  expect(execa).toHaveBeenNthCalledWith(2, 'reg', ['add', regKey, '/v', 'PNPM_HOME', '/t', 'REG_EXPAND_SZ', '/d', __dirname, '/f'])\n  expect(execa).toHaveBeenNthCalledWith(3, 'reg', ['add', regKey, '/v', 'Path', '/t', 'REG_EXPAND_SZ', '/d', `${__dirname};${currentPathInRegistry}`, '/f'])\n  expect(output).toContain(`Setting 'PNPM_HOME' to value '${__dirname}`)\n  expect(output).toContain('FAILED TO SET PNPM_HOME')\n  expect(output).toContain('Updating PATH')\n  expect(output).toContain('FAILED TO UPDATE PATH')\n})","file":"setupOnWindows/07.test.ts","skipped":false,"dir":"packages/plugin-commands-setup/test"},{"name":"pnpm store add express@4.16.3","suites":[],"updatePoint":{"line":10,"column":35},"line":10,"code":"test('pnpm store add express@4.16.3', async () => {\n  tempDir()\n\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: `http://localhost:${REGISTRY_MOCK_PORT}/`,\n    },\n    registries: { default: `http://localhost:${REGISTRY_MOCK_PORT}/` },\n    storeDir,\n    userConfig: {},\n  }, ['add', 'express@4.16.3'])\n\n  const { cafsHas } = assertStore(path.join(storeDir, STORE_VERSION))\n  await cafsHas('sha1-avilAjUNsyRuzEvs9rWjTSL37VM=')\n})","file":"storeAdd.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"pnpm store add scoped package that uses not the standard registry","suites":[],"updatePoint":{"line":32,"column":71},"line":32,"code":"test('pnpm store add scoped package that uses not the standard registry', async () => {\n  tempDir()\n\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: 'https://registry.npmjs.org/',\n    },\n    registries: {\n      '@foo': `http://localhost:${REGISTRY_MOCK_PORT}/`,\n      default: 'https://registry.npmjs.org/',\n    },\n    storeDir,\n    userConfig: {},\n  }, ['add', '@foo/no-deps@1.0.0'])\n\n  const { cafsHas } = assertStore(path.join(storeDir, STORE_VERSION))\n  await cafsHas('@foo/no-deps', '1.0.0')\n})","file":"storeAdd.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"should fail if some packages can not be added","suites":[],"updatePoint":{"line":57,"column":51},"line":57,"code":"test('should fail if some packages can not be added', async () => {\n  tempDir()\n  fs.mkdirSync('_')\n  process.chdir('_')\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('pnpm-store')\n\n  let thrown = false\n  try {\n    await store.handler({\n      cacheDir,\n      dir: process.cwd(),\n      pnpmHomeDir: '',\n      rawConfig: {\n        registry: 'https://registry.npmjs.org/',\n      },\n      registries: {\n        '@foo': `http://localhost:${REGISTRY_MOCK_PORT}/`,\n        default: 'https://registry.npmjs.org/',\n      },\n      storeDir,\n      userConfig: {},\n    }, ['add', '@pnpm/this-does-not-exist'])\n  } catch (e: any) { // eslint-disable-line\n    thrown = true\n    expect(e.code).toBe('ERR_PNPM_STORE_ADD_FAILURE')\n    expect(e.message).toBe('Some packages have not been added correctly')\n  }\n  expect(thrown).toBeTruthy()\n})","file":"storeAdd.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"CLI prints the current store path","suites":[],"updatePoint":{"line":9,"column":39},"line":9,"code":"test('CLI prints the current store path', async () => {\n  prepare()\n\n  const candidateStorePath = await store.handler({\n    cacheDir: path.resolve('cache'),\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    storeDir: '/home/example/.pnpm-store',\n    userConfig: {},\n  }, ['path'])\n\n  const expectedStorePath = os.platform() === 'win32'\n    ? '\\\\home\\\\example\\\\.pnpm-store\\\\v3'\n    : '/home/example/.pnpm-store/v3'\n\n  expect(candidateStorePath).toBe(expectedStorePath)\n})","file":"storePath.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"remove unreferenced packages","suites":[],"updatePoint":{"line":17,"column":34},"line":17,"code":"test('remove unreferenced packages', async () => {\n  const project = prepare()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [pnpmBin, 'add', 'is-negative@2.1.0', '--store-dir', storeDir, '--registry', REGISTRY])\n  await execa('node', [pnpmBin, 'remove', 'is-negative', '--store-dir', storeDir, '--config.modules-cache-max-age=0'], { env: { npm_config_registry: REGISTRY } })\n\n  await project.storeHas('is-negative', '2.1.0')\n\n  const reporter = jest.fn()\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    reporter,\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n\n  expect(reporter).toBeCalledWith(\n    expect.objectContaining({\n      level: 'info',\n      message: 'Removed 1 package',\n    })\n  )\n\n  await project.storeHasNot('is-negative', '2.1.0')\n\n  reporter.mockClear()\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    reporter,\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n\n  expect(reporter).not.toBeCalledWith(\n    expect.objectContaining({\n      level: 'info',\n      message: 'Removed 1 package',\n    })\n  )\n})","file":"storePrune.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"remove packages that are used by project that no longer exist","suites":[],"line":72,"code":"test.skip('remove packages that are used by project that no longer exist', async () => {","file":"storePrune.ts","skipped":true,"dir":"packages/plugin-commands-store/test"},{"name":"keep dependencies used by others","suites":[],"updatePoint":{"line":108,"column":38},"line":108,"code":"test('keep dependencies used by others', async () => {\n  const project = prepare()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  await execa('node', [pnpmBin, 'add', 'camelcase-keys@3.0.0', '--store-dir', storeDir, '--registry', REGISTRY])\n  await execa('node', [pnpmBin, 'add', 'hastscript@3.0.0', '--save-dev', '--store-dir', storeDir, '--registry', REGISTRY])\n  await execa('node', [pnpmBin, 'remove', 'camelcase-keys', '--store-dir', storeDir], { env: { npm_config_registry: REGISTRY } })\n\n  await project.storeHas('camelcase-keys', '3.0.0')\n  await project.hasNot('camelcase-keys')\n\n  await project.storeHas('camelcase', '3.0.0')\n\n  await project.storeHas('map-obj', '1.0.1')\n  await project.hasNot('map-obj')\n\n  // all dependencies are marked as dev\n  const lockfile = await project.readLockfile() as Lockfile\n  expect(isEmpty(lockfile.packages)).toBeFalsy()\n\n  Object.entries(lockfile.packages ?? {}).forEach(([depPath, dep]) => expect(dep.dev).toBeTruthy())\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n\n  await project.storeHasNot('camelcase-keys', '3.0.0')\n  await project.storeHasNot('map-obj', '1.0.1')\n  await project.storeHas('camelcase', '3.0.0')\n})","file":"storePrune.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"keep dependency used by package","suites":[],"updatePoint":{"line":147,"column":37},"line":147,"code":"test('keep dependency used by package', async () => {\n  const project = prepare()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  await execa('node', [pnpmBin, 'add', 'is-not-positive@1.0.0', 'is-positive@3.1.0', '--store-dir', storeDir, '--registry', REGISTRY])\n  await execa('node', [pnpmBin, 'remove', 'is-not-positive', '--store-dir', storeDir], { env: { npm_config_registry: REGISTRY } })\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n\n  await project.storeHas('is-positive', '3.1.0')\n})","file":"storePrune.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"prune will skip scanning non-directory in storeDir","suites":[],"updatePoint":{"line":169,"column":56},"line":169,"code":"test('prune will skip scanning non-directory in storeDir', async () => {\n  prepare()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n  await execa('node', [pnpmBin, 'add', 'is-not-positive@1.0.0', 'is-positive@3.1.0', '--store-dir', storeDir, '--registry', REGISTRY])\n  fs.writeFileSync(path.join(storeDir, STORE_VERSION, 'files/.DS_store'), 'foobar')\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n})","file":"storePrune.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"prune does not fail if the store contains an unexpected directory","suites":[],"updatePoint":{"line":189,"column":71},"line":189,"code":"test('prune does not fail if the store contains an unexpected directory', async () => {\n  const project = prepare()\n  const cacheDir = path.resolve('cache')\n  const storeDir = path.resolve('store')\n\n  await execa('node', [pnpmBin, 'add', 'is-negative@2.1.0', '--store-dir', storeDir, '--registry', REGISTRY])\n\n  await project.storeHas('is-negative', '2.1.0')\n  const alienDir = path.join(storeDir, 'v3/files/44/directory')\n  fs.mkdirSync(alienDir)\n\n  const reporter = jest.fn()\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    reporter,\n    storeDir,\n    userConfig: {},\n  }, ['prune'])\n\n  expect(reporter).toBeCalledWith(\n    expect.objectContaining({\n      level: 'warn',\n      message: `An alien directory is present in the store: ${alienDir}`,\n    })\n  )\n})","file":"storePrune.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"CLI fails when store status finds modified packages","suites":[],"updatePoint":{"line":13,"column":57},"line":13,"code":"test('CLI fails when store status finds modified packages', async () => {\n  prepare()\n  const tmp = tempy.directory()\n  const cacheDir = path.join(tmp, 'cache')\n  const storeDir = path.join(tmp, 'store')\n\n  await execa('node', [pnpmBin, 'add', 'is-positive@3.1.0', '--store-dir', storeDir, '--registry', REGISTRY, '--verify-store-integrity'])\n\n  await rimraf('node_modules/.pnpm/is-positive@3.1.0/node_modules/is-positive/index.js')\n\n  let err!: PnpmError\n  try {\n    await store.handler({\n      cacheDir,\n      dir: process.cwd(),\n      pnpmHomeDir: '',\n      rawConfig: {\n        registry: REGISTRY,\n      },\n      registries: { default: REGISTRY },\n      storeDir,\n      userConfig: {},\n    }, ['status'])\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n  expect(err.code).toBe('ERR_PNPM_MODIFIED_DEPENDENCY')\n  expect(err['modified'].length).toBe(1)\n  expect(err['modified'][0]).toMatch(/is-positive/)\n})","file":"storeStatus.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"CLI does not fail when store status does not find modified packages","suites":[],"updatePoint":{"line":44,"column":73},"line":44,"code":"test('CLI does not fail when store status does not find modified packages', async () => {\n  prepare()\n  const tmp = tempy.directory()\n  const cacheDir = path.join(tmp, 'cache')\n  const storeDir = path.join(tmp, 'store')\n\n  await execa('node', [\n    pnpmBin,\n    `--store-dir=${storeDir}`,\n    `--registry=${REGISTRY}`,\n    '--verify-store-integrity',\n    'add',\n    'eslint@3.4.0',\n    'gulp@4.0.2',\n    'highcharts@5.0.10',\n    'is-positive@3.1.0',\n    'react@15.4.1',\n    'webpack@5.24.2',\n    'koorchik/node-mole-rpc',\n  ])\n  // store status does not fail on not installed optional dependencies\n  await execa('node', [pnpmBin, 'add', 'not-compatible-with-any-os', '--save-optional', '--store-dir', storeDir, '--registry', REGISTRY, '--verify-store-integrity'])\n\n  await store.handler({\n    cacheDir,\n    dir: process.cwd(),\n    pnpmHomeDir: '',\n    rawConfig: {\n      registry: REGISTRY,\n    },\n    registries: { default: REGISTRY },\n    storeDir,\n    userConfig: {},\n  }, ['status'])\n})","file":"storeStatus.ts","skipped":false,"dir":"packages/plugin-commands-store/test"},{"name":"complete an option value","suites":[],"updatePoint":{"line":3,"column":30},"line":3,"code":"test('complete an option value', async () => {\n  const completions = await complete(\n    {\n      cliOptionsTypesByCommandName: {\n        install: () => ({\n          'resolution-strategy': ['fast', 'fewer-dependencies'],\n        }),\n      },\n      completionByCommandName: {},\n      initialCompletion: () => [],\n      shorthandsByCommandName: {},\n      universalOptionsTypes: {},\n    },\n    {\n      cmd: 'install',\n      currentTypedWordType: null,\n      lastOption: '--resolution-strategy',\n      options: {},\n      params: [],\n    }\n  )\n  expect(completions).toStrictEqual([\n    { name: 'fast' },\n    { name: 'fewer-dependencies' },\n  ])\n})","file":"complete.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"complete a command","suites":[],"updatePoint":{"line":30,"column":24},"line":30,"code":"test('complete a command', async () => {\n  const ctx = {\n    cliOptionsTypesByCommandName: {\n      run: () => ({\n        'if-present': Boolean,\n      }),\n    },\n    completionByCommandName: {\n      run: async () => [{ name: 'test' }],\n    },\n    initialCompletion: () => [],\n    shorthandsByCommandName: {},\n    universalOptionsTypes: {\n      filter: String,\n    },\n  }\n  expect(\n    await complete(ctx,\n      {\n        cmd: 'run',\n        currentTypedWordType: 'value',\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual(\n    [{ name: 'test' }]\n  )\n  expect(\n    await complete(ctx,\n      {\n        cmd: 'run',\n        currentTypedWordType: null,\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual(\n    [\n      { name: 'test' },\n      { name: '--filter' },\n      { name: '--if-present' },\n      { name: '--no-if-present' },\n    ]\n  )\n  expect(\n    await complete(ctx,\n      {\n        cmd: 'run',\n        currentTypedWordType: 'option',\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual(\n    [\n      { name: '--filter' },\n      { name: '--if-present' },\n      { name: '--no-if-present' },\n    ]\n  )\n})","file":"complete.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"if command completion fails, return empty array","suites":[],"updatePoint":{"line":96,"column":53},"line":96,"code":"test('if command completion fails, return empty array', async () => {\n  expect(\n    await complete(\n      {\n        cliOptionsTypesByCommandName: {},\n        completionByCommandName: {\n          run: async () => {\n            throw new Error('error')\n          },\n        },\n        initialCompletion: () => [],\n        shorthandsByCommandName: {},\n        universalOptionsTypes: {\n          filter: String,\n        },\n      },\n      {\n        cmd: 'run',\n        currentTypedWordType: 'value',\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual(\n    []\n  )\n})","file":"complete.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"initial completion","suites":[],"updatePoint":{"line":125,"column":24},"line":125,"code":"test('initial completion', async () => {\n  const ctx = {\n    cliOptionsTypesByCommandName: {},\n    completionByCommandName: {},\n    initialCompletion: () => [\n      { name: 'add' },\n      { name: 'install' },\n    ],\n    shorthandsByCommandName: {},\n    universalOptionsTypes: {\n      filter: String,\n    },\n  }\n  expect(\n    await complete(ctx,\n      {\n        cmd: null,\n        currentTypedWordType: null,\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual([\n    { name: 'add' },\n    { name: 'install' },\n    { name: '--filter' },\n    { name: '--version' },\n  ])\n  expect(\n    await complete(ctx,\n      {\n        cmd: 'ad',\n        currentTypedWordType: 'value',\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual([\n    { name: 'add' },\n    { name: 'install' },\n  ])\n  expect(\n    await complete(ctx,\n      {\n        cmd: null,\n        currentTypedWordType: 'option',\n        lastOption: null,\n        options: {},\n        params: [],\n      }\n    )\n  ).toStrictEqual([\n    { name: '--filter' },\n    { name: '--version' },\n  ])\n})","file":"complete.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"suggest no completions for after --version","suites":[],"updatePoint":{"line":184,"column":48},"line":184,"code":"test('suggest no completions for after --version', async () => {\n  expect(\n    await complete(\n      {\n        cliOptionsTypesByCommandName: {},\n        completionByCommandName: {},\n        initialCompletion: () => [\n          { name: 'add' },\n          { name: 'install' },\n        ],\n        shorthandsByCommandName: {},\n        universalOptionsTypes: {},\n      },\n      {\n        cmd: null,\n        currentTypedWordType: null,\n        lastOption: null,\n        options: { version: true },\n        params: [],\n      }\n    )\n  ).toStrictEqual([])\n})","file":"complete.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"formatUnknownOptionsError()","suites":[],"updatePoint":{"line":6,"column":33},"line":6,"code":"test('formatUnknownOptionsError()', async () => {\n  expect(\n    formatUnknownOptionsError(new Map([['foo', []]]))\n  ).toBe(\n    `${ERROR} ${chalk.red(\"Unknown option: 'foo'\")}`\n  )\n  expect(\n    formatUnknownOptionsError(new Map([['foo', ['foa', 'fob']]]))\n  ).toBe(\n    `${ERROR} ${chalk.red(\"Unknown option: 'foo'\")}\nDid you mean 'foa', or 'fob'? Use \"--config.unknown=value\" to force an unknown option.`\n  )\n  expect(\n    formatUnknownOptionsError(new Map([['foo', []], ['bar', []]]))\n  ).toBe(\n    `${ERROR} ${chalk.red(\"Unknown options: 'foo', 'bar'\")}`\n  )\n})","file":"formatError.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"getOptionCompletions()","suites":[],"updatePoint":{"line":18,"column":28},"line":18,"code":"test('getOptionCompletions()', () => {\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--store-dir')).toStrictEqual([])\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--dev')).toBeUndefined()\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--no-dev')).toBeUndefined()\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '-D')).toBeUndefined()\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--unknown')).toBeUndefined()\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--color')).toStrictEqual(['red', 'blue'])\n  expect(getOptionCompletions(TYPES, SHORTHANDS, '--')).toBeUndefined()\n})","file":"getOptionType.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"getLastOption()","suites":[],"updatePoint":{"line":28,"column":21},"line":28,"code":"test('getLastOption()', () => {\n  expect(\n    getLastOption({\n      last: '',\n      lastPartial: 'f',\n      line: 'pnpm i --resolution-strategy f ',\n      partial: 'pnpm i --resolution-strategy f',\n      point: 30,\n      prev: 'f',\n      words: 4,\n    })\n  ).toBe('--resolution-strategy')\n  expect(\n    getLastOption({\n      last: '',\n      lastPartial: '',\n      line: 'pnpm i --resolution-strategy ',\n      partial: 'pnpm i --resolution-strategy ',\n      point: 28,\n      prev: '--resolution-strategy',\n      words: 3,\n    })\n  ).toBe('--resolution-strategy')\n})","file":"getOptionType.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"currentTypedWordType()","suites":[],"updatePoint":{"line":53,"column":28},"line":53,"code":"test('currentTypedWordType()', () => {\n  expect(currentTypedWordType({\n    last: '',\n    lastPartial: '',\n    line: 'pnpm i --resolution-strategy ',\n    partial: 'pnpm i --resolution-strategy ',\n    point: 29,\n    prev: '--resolution-strategy',\n    words: 3,\n  })).toBe(null)\n  expect(currentTypedWordType({\n    last: '',\n    lastPartial: 'f',\n    line: 'pnpm i --resolution-strategy f ',\n    partial: 'pnpm i --resolution-strategy f',\n    point: 30,\n    prev: 'f',\n    words: 4,\n  })).toBe('value')\n  expect(currentTypedWordType({\n    last: '',\n    lastPartial: 'ex',\n    line: 'pnpm add ex --save-dev ',\n    partial: 'pnpm add ex',\n    point: 11,\n    prev: '--save-dev',\n    words: 4,\n  })).toBe('value')\n  expect(currentTypedWordType({\n    last: '',\n    lastPartial: '--res',\n    line: 'pnpm i --res foo ',\n    partial: 'pnpm i --res',\n    point: 12,\n    prev: 'foo',\n    words: 4,\n  })).toBe('option')\n})","file":"getOptionType.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"print an error when help not found","suites":[],"updatePoint":{"line":3,"column":40},"line":3,"code":"test('print an error when help not found', () => {\n  expect(\n    createHelp({})({}, ['foo']).split('\\n')[1]\n  ).toBe('No results for \"foo\"')\n})","file":"help.spec.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"optionTypesToCompletions()","suites":[],"updatePoint":{"line":3,"column":32},"line":3,"code":"test('optionTypesToCompletions()', () => {\n  expect(\n    optionTypesToCompletions({\n      bar: String,\n      foo: Boolean,\n    })\n  ).toStrictEqual([\n    {\n      name: '--bar',\n    },\n    {\n      name: '--foo',\n    },\n    {\n      name: '--no-foo',\n    },\n  ])\n})","file":"optionTypesToCompletions.test.ts","skipped":false,"dir":"packages/pnpm/test"},{"name":"ignoring a pnpmfile that exports undefined","suites":[],"updatePoint":{"line":4,"column":48},"line":4,"code":"test('ignoring a pnpmfile that exports undefined', () => {\n  const pnpmfile = requirePnpmfile(path.join(__dirname, 'pnpmfiles/undefined.js'), __dirname)\n  expect(pnpmfile).toBeUndefined()\n})","file":"index.ts","skipped":false,"dir":"packages/pnpmfile/test"},{"name":"readPackage hook run fails when returns undefined ","suites":[],"updatePoint":{"line":9,"column":56},"line":9,"code":"test('readPackage hook run fails when returns undefined ', () => {\n  const pnpmfilePath = path.join(__dirname, 'pnpmfiles/readPackageNoReturn.js')\n  const pnpmfile = requirePnpmfile(pnpmfilePath, __dirname)\n\n  return expect(\n    pnpmfile.hooks.readPackage({})\n  ).rejects.toEqual(new BadReadPackageHookError(pnpmfilePath, 'readPackage hook did not return a package manifest object.'))\n})","file":"index.ts","skipped":false,"dir":"packages/pnpmfile/test"},{"name":"readPackage hook run fails when returned dependencies is not an object ","suites":[],"updatePoint":{"line":18,"column":77},"line":18,"code":"test('readPackage hook run fails when returned dependencies is not an object ', () => {\n  const pnpmfilePath = path.join(__dirname, 'pnpmfiles/readPackageNoObject.js')\n  const pnpmfile = requirePnpmfile(pnpmfilePath, __dirname)\n  return expect(\n    pnpmfile.hooks.readPackage({})\n  ).rejects.toEqual(new BadReadPackageHookError(pnpmfilePath, 'readPackage hook returned package manifest object\\'s property \\'dependencies\\' must be an object.'))\n})","file":"index.ts","skipped":false,"dir":"packages/pnpmfile/test"},{"name":"filterLog hook combines with the global hook","suites":[],"updatePoint":{"line":26,"column":50},"line":26,"code":"test('filterLog hook combines with the global hook', () => {\n  const globalPnpmfile = path.join(__dirname, 'pnpmfiles/globalFilterLog.js')\n  const pnpmfile = path.join(__dirname, 'pnpmfiles/filterLog.js')\n  const hooks = requireHooks(__dirname, { globalPnpmfile, pnpmfile })\n\n  expect(hooks.filterLog).toBeDefined()\n  expect(hooks.filterLog!({\n    name: 'pnpm:summary',\n    level: 'error',\n    prefix: 'test',\n  })).toBeTruthy()\n  expect(hooks.filterLog!({\n    name: 'pnpm:summary',\n    level: 'debug',\n    prefix: 'test',\n  })).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/pnpmfile/test"},{"name":"remove one redundant package","suites":[],"updatePoint":{"line":15,"column":34},"line":15,"code":"test('remove one redundant package', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"remove redundant linked package","suites":[],"updatePoint":{"line":72,"column":37},"line":72,"code":"test('remove redundant linked package', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': 'link:../is-positive',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {},\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {},\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        specifiers: {},\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"keep all","suites":[],"updatePoint":{"line":101,"column":14},"line":101,"code":"test('keep all', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-negative': '^1.0.0',\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dependencies: {\n          'is-positive': '2.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"optional dependency should have optional = true","suites":[],"updatePoint":{"line":187,"column":53},"line":187,"code":"test('optional dependency should have optional = true', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'parent-of-foo': '1.0.0',\n          'pkg-with-good-optional': '1.0.0',\n        },\n        optionalDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'parent-of-foo': '1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/foo-child/1.0.0': {\n        optional: true,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/foo/1.0.0': {\n        dependencies: {\n          'foo-child': '1.0.0',\n        },\n        optional: true,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/parent-of-foo/1.0.0': {\n        dependencies: {\n          foo: '1.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        optionalDependencies: {\n          foo: '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'parent-of-foo': '1.0.0',\n      'pkg-with-good-optional': '^1.0.0',\n    },\n    optionalDependencies: {\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'parent-of-foo': '1.0.0',\n          'pkg-with-good-optional': '1.0.0',\n        },\n        optionalDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'parent-of-foo': '1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/foo-child/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/foo/1.0.0': {\n        dependencies: {\n          'foo-child': '1.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        optional: true,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/parent-of-foo/1.0.0': {\n        dependencies: {\n          foo: '1.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        optionalDependencies: {\n          foo: '1.0.0',\n          'is-positive': '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"optional dependency should not have optional = true if used not only as optional","suites":[],"updatePoint":{"line":323,"column":86},"line":323,"code":"test('optional dependency should not have optional = true if used not only as optional', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n          'pkg-with-good-optional': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        optionalDependencies: {\n          'is-positive': '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-positive': '^1.0.0',\n      'pkg-with-good-optional': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n          'pkg-with-good-optional': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        optionalDependencies: {\n          'is-positive': '1.0.0',\n        },\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"dev dependency should have dev = true","suites":[],"updatePoint":{"line":397,"column":43},"line":397,"code":"test('dev dependency should have dev = true', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'pkg-with-good-optional': '1.0.0',\n        },\n        devDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'pkg-with-good-optional': '^1.0.0',\n    },\n    devDependencies: {\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'pkg-with-good-optional': '1.0.0',\n        },\n        devDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'pkg-with-good-optional': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: true,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/pkg-with-good-optional/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"dev dependency should not have dev = true if it is used not only as dev","suites":[],"updatePoint":{"line":470,"column":77},"line":470,"code":"test('dev dependency should not have dev = true if it is used not only as dev', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'some-pkg': '1.0.0',\n        },\n        devDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'some-pkg': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/some-pkg/1.0.0': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'some-pkg': '^1.0.0',\n    },\n    devDependencies: {\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'some-pkg': '1.0.0',\n        },\n        devDependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n          'some-pkg': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/some-pkg/1.0.0': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"the dev field should be updated to dev = false if it is not a dev dependency anymore","suites":[],"updatePoint":{"line":548,"column":90},"line":548,"code":"test('the dev field should be updated to dev = false if it is not a dev dependency anymore', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          a: '1.0.0',\n        },\n        specifiers: {\n          a: '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/a/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      a: '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          a: '1.0.0',\n        },\n        specifiers: {\n          a: '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/a/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"subdependency is both optional and dev","suites":[],"updatePoint":{"line":598,"column":44},"line":598,"code":"test('subdependency is both optional and dev', () => {\n  expect(pruneLockfile(yaml`\n    importers:\n      .:\n        dependencies:\n          prod-parent: 1.0.0\n        devDependencies:\n          parent: 1.0.0\n        specifiers:\n          parent: ^1.0.0\n          prod-parent: ^1.0.0\n    lockfileVersion: 5\n    packages:\n      /parent/1.0.0:\n        optionalDependencies:\n          subdep: 1.0.0\n          subdep2: 1.0.0\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /prod-parent/1.0.0:\n        dependencies:\n          subdep2: 1.0.0\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /subdep/1.0.0:\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /subdep2/1.0.0:\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n  `, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'prod-parent': '^1.0.0',\n    },\n    devDependencies: {\n      parent: '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual(yaml`\n    importers:\n      .:\n        dependencies:\n          prod-parent: 1.0.0\n        devDependencies:\n          parent: 1.0.0\n        specifiers:\n          parent: ^1.0.0\n          prod-parent: ^1.0.0\n    lockfileVersion: 5\n    packages:\n      /parent/1.0.0:\n        dev: true\n        optionalDependencies:\n          subdep: 1.0.0\n          subdep2: 1.0.0\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /prod-parent/1.0.0:\n        dev: false\n        dependencies:\n          subdep2: 1.0.0\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /subdep/1.0.0:\n        dev: true\n        optional: true\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /subdep2/1.0.0:\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n  `)\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"dev = true is removed if dependency is used both as dev and prod dependency","suites":[],"updatePoint":{"line":674,"column":81},"line":674,"code":"test('dev = true is removed if dependency is used both as dev and prod dependency', () => {\n  expect(pruneLockfile(yaml`\n    importers:\n      .:\n        dependencies:\n          foo: /inflight/1.0.6\n        devDependencies:\n          inflight: 1.0.6\n        specifiers:\n          foo: 'npm:inflight@^1.0.6'\n          inflight: ^1.0.6\n    lockfileVersion: 5\n    packages:\n      /inflight/1.0.6:\n        dev: true\n        dependencies:\n          once: 1.4.0\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /once/1.4.0:\n        dev: true\n        dependencies:\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\n      /wrappy/1.0.2:\n        dev: true\n        resolution:\n          integrity: sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\n  `, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      foo: 'npm:inflight@^1.0.6',\n    },\n    devDependencies: {\n      inflight: '^1.0.6',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual(yaml`\n    importers:\n      .:\n        dependencies:\n          foo: /inflight/1.0.6\n        devDependencies:\n          inflight: 1.0.6\n        specifiers:\n          foo: 'npm:inflight@^1.0.6'\n          inflight: ^1.0.6\n    lockfileVersion: 5\n    packages:\n      /inflight/1.0.6:\n        dependencies:\n          once: 1.4.0\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /once/1.4.0:\n        dependencies:\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\n      /wrappy/1.0.2:\n        resolution:\n          integrity: sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\n  `)\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"optional = true is removed if dependency is used both as optional and prod dependency","suites":[],"updatePoint":{"line":743,"column":91},"line":743,"code":"test('optional = true is removed if dependency is used both as optional and prod dependency', () => {\n  expect(pruneLockfile(yaml`\n    importers:\n      .:\n        dependencies:\n          foo: /inflight/1.0.6\n        optionalDependencies:\n          inflight: 1.0.6\n        specifiers:\n          foo: 'npm:inflight@^1.0.6'\n          inflight: ^1.0.6\n    lockfileVersion: 5\n    packages:\n      /inflight/1.0.6:\n        optional: true\n        dependencies:\n          once: 1.4.0\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /once/1.4.0:\n        optional: true\n        dependencies:\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\n      /wrappy/1.0.2:\n        optional: true\n        resolution:\n          integrity: sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\n  `, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      foo: 'npm:inflight@^1.0.6',\n    },\n    optionalDependencies: {\n      inflight: '^1.0.6',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual(yaml`\n    importers:\n      .:\n        dependencies:\n          foo: /inflight/1.0.6\n        optionalDependencies:\n          inflight: 1.0.6\n        specifiers:\n          foo: 'npm:inflight@^1.0.6'\n          inflight: ^1.0.6\n    lockfileVersion: 5\n    packages:\n      /inflight/1.0.6:\n        dev: false\n        dependencies:\n          once: 1.4.0\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n      /once/1.4.0:\n        dev: false\n        dependencies:\n          wrappy: 1.0.2\n        resolution:\n          integrity: sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\n      /wrappy/1.0.2:\n        dev: false\n        resolution:\n          integrity: sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\n  `)\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"remove dependencies that are not in the package","suites":[],"updatePoint":{"line":815,"column":53},"line":815,"code":"test('remove dependencies that are not in the package', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        devDependencies: {\n          'is-negative': '1.0.0',\n        },\n        optionalDependencies: {\n          fsevents: '1.0.0',\n        },\n        specifiers: {\n          fsevents: '^1.0.0',\n          'is-negative': '^1.0.0',\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/fsevents/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-negative/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        specifiers: {},\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"ignore dependencies that are in package.json but are not in ","suites":[],"updatePoint":{"line":866,"column":84},"line":866,"code":"test(`ignore dependencies that are in package.json but are not in ${WANTED_LOCKFILE}`, () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-negative': '^1.0.0',\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"keep lockfileMinorVersion, if present","suites":[],"updatePoint":{"line":919,"column":43},"line":919,"code":"test('keep lockfileMinorVersion, if present', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 5.2,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-positive': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: 5.2,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"keep linked package even if it is not in package.json","suites":[],"updatePoint":{"line":970,"column":59},"line":970,"code":"test('keep linked package even if it is not in package.json', () => {\n  expect(pruneLockfile({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': 'link:../is-positive',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'foo',\n    version: '1.0.0',\n\n    dependencies: {\n      'is-negative': '^1.0.0',\n    },\n  }, '.', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      '.': {\n        dependencies: {\n          'is-negative': '1.0.0',\n          'is-positive': 'link:../is-positive',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"prune: don't remove package used by another importer","suites":[],"updatePoint":{"line":1023,"column":58},"line":1023,"code":"test(\"prune: don't remove package used by another importer\", () => {\n  expect(pruneLockfile({\n    importers: {\n      'packages/package-1': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n      'packages/package-2': {\n        dependencies: {\n          'is-negative': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, {\n    name: 'project-2',\n    version: '1.0.0',\n\n    dependencies: { 'is-negative': '^1.0.0' },\n  }, 'packages/package-2', DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      'packages/package-1': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n      'packages/package-2': {\n        dependencies: {\n          'is-negative': '1.0.0',\n        },\n        specifiers: {\n          'is-negative': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-negative/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"pruneSharedLockfile: remove one redundant package","suites":[],"updatePoint":{"line":1106,"column":55},"line":1106,"code":"test('pruneSharedLockfile: remove one redundant package', () => {\n  expect(pruneSharedLockfile({\n    importers: {\n      'packages/package-1': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n      '/is-positive/2.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  }, DEFAULT_OPTS)).toStrictEqual({\n    importers: {\n      'packages/package-1': {\n        dependencies: {\n          'is-positive': '1.0.0',\n        },\n        specifiers: {\n          'is-positive': '^1.0.0',\n        },\n      },\n    },\n    lockfileVersion: LOCKFILE_VERSION,\n    packages: {\n      '/is-positive/1.0.0': {\n        dev: false,\n        resolution: {\n          integrity: 'sha1-ChbBDewTLAqLCzb793Fo5VDvg/g=',\n        },\n      },\n    },\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/prune-lockfile/test"},{"name":"readPackageJson()","suites":[],"updatePoint":{"line":7,"column":23},"line":7,"code":"test('readPackageJson()', async () => {\n  expect((await readPackageJson(path.join(__dirname, '..', 'package.json'))).name).toBe('@pnpm/read-package-json')\n})","file":"index.ts","skipped":false,"dir":"packages/read-package-json/test"},{"name":"fromDir()","suites":[],"updatePoint":{"line":11,"column":15},"line":11,"code":"test('fromDir()', async () => {\n  expect((await readPackageJsonFromDir(path.join(__dirname, '..'))).name).toBe('@pnpm/read-package-json')\n})","file":"index.ts","skipped":false,"dir":"packages/read-package-json/test"},{"name":"readPackageJson() throw error when name is invalid","suites":[],"updatePoint":{"line":15,"column":56},"line":15,"code":"test('readPackageJson() throw error when name is invalid', async () => {\n  let err\n  try {\n    await readPackageJson(path.join(fixtures, 'invalid-name', 'package.json'))\n  } catch (_: any) { // eslint-disable-line\n    err = _\n  }\n  expect(err.code).toBe('ERR_PNPM_BAD_PACKAGE_JSON')\n})","file":"index.ts","skipped":false,"dir":"packages/read-package-json/test"},{"name":"readPackageJson() throw initial error when package.json not found","suites":[],"updatePoint":{"line":25,"column":71},"line":25,"code":"test('readPackageJson() throw initial error when package.json not found', async () => {\n  let err\n  try {\n    await readPackageJson(path.join(fixtures, 'package.json'))\n  } catch (_: any) { // eslint-disable-line\n    err = _\n  }\n  expect(err.code).toBe('ENOENT')\n})","file":"index.ts","skipped":false,"dir":"packages/read-package-json/test"},{"name":"readProjectManifest()","suites":[],"updatePoint":{"line":9,"column":27},"line":9,"code":"test('readProjectManifest()', async () => {\n  expect(\n    (await tryReadProjectManifest(path.join(fixtures, 'package-json'))).manifest\n  ).toStrictEqual(\n    { name: 'foo', version: '1.0.0' }\n  )\n\n  expect(\n    (await tryReadProjectManifest(path.join(fixtures, 'package-json5'))).manifest\n  ).toStrictEqual(\n    { name: 'foo', version: '1.0.0' }\n  )\n\n  expect(\n    (await tryReadProjectManifest(path.join(fixtures, 'package-yaml'))).manifest\n  ).toStrictEqual(\n    { name: 'foo', version: '1.0.0' }\n  )\n\n  expect(\n    (await tryReadProjectManifest(fixtures)).manifest\n  ).toStrictEqual(null)\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve tab indentation in json file","suites":[],"updatePoint":{"line":33,"column":43},"line":33,"code":"test('preserve tab indentation in json file', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json', '{\\n\\t\"name\": \"foo\"\\n}\\n', 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json', 'utf8')\n  expect(rawManifest).toBe('{\\n\\t\"name\": \"foo\",\\n\\t\"dependencies\": {\\n\\t\\t\"bar\": \"1.0.0\"\\n\\t}\\n}\\n')\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve space indentation in json file","suites":[],"updatePoint":{"line":46,"column":45},"line":46,"code":"test('preserve space indentation in json file', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json', '{\\n  \"name\": \"foo\"\\n}\\n', 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json', 'utf8')\n  expect(rawManifest).toBe('{\\n  \"name\": \"foo\",\\n  \"dependencies\": {\\n    \"bar\": \"1.0.0\"\\n  }\\n}\\n')\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve tab indentation in json5 file","suites":[],"updatePoint":{"line":59,"column":44},"line":59,"code":"test('preserve tab indentation in json5 file', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json5', \"{\\n\\tname: 'foo',\\n}\\n\", 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json5', 'utf8')\n  expect(rawManifest).toBe(\"{\\n\\tname: 'foo',\\n\\tdependencies: {\\n\\t\\tbar: '1.0.0',\\n\\t},\\n}\\n\")\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve space indentation in json5 file","suites":[],"updatePoint":{"line":72,"column":46},"line":72,"code":"test('preserve space indentation in json5 file', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json5', \"{\\n  name: 'foo'\\n}\\n\", 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json5', 'utf8')\n  expect(rawManifest).toBe(\"{\\n  name: 'foo',\\n  dependencies: {\\n    bar: '1.0.0',\\n  },\\n}\\n\")\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"do not save manifest if it had no changes","suites":[],"updatePoint":{"line":85,"column":47},"line":85,"code":"test('do not save manifest if it had no changes', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile(\n    'package.json5',\n    JSON.stringify({\n      dependencies: { foo: '*', bar: '*' },\n      devDependencies: {},\n    }),\n    'utf8'\n  )\n\n  const { writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  const stat1 = await fs.stat('package.json5')\n\n  await writeProjectManifest({\n    dependencies: { bar: '*', foo: '*' },\n    peerDependencies: {},\n  })\n\n  const stat2 = await fs.stat('package.json5')\n\n  expect(stat1.ino).toBe(stat2.ino)\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"fail on invalid JSON","suites":[],"updatePoint":{"line":111,"column":26},"line":111,"code":"test('fail on invalid JSON', async () => {\n  let err!: Error\n  try {\n    await readProjectManifest(path.join(fixtures, 'invalid-package-json'))\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err).toBeTruthy()\n  expect(err['code']).toBe('ERR_PNPM_JSON_PARSE')\n  // eslint-disable-next-line\n  expect(err.message).toMatch(/^Unexpected string in JSON at position 20 while parsing \\'{  \"name\": \"foo\"  \"version\": \"1.0.0\"}\\' in /)\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"fail on invalid JSON5","suites":[],"updatePoint":{"line":125,"column":27},"line":125,"code":"test('fail on invalid JSON5', async () => {\n  let err!: Error\n  try {\n    await readProjectManifest(path.join(fixtures, 'invalid-package-json5'))\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err).toBeTruthy()\n  expect(err['code']).toBe('ERR_PNPM_JSON5_PARSE')\n  expect(err.message).toMatch(/^JSON5: invalid character 'v' at 3:3 in/)\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"fail on invalid YAML","suites":[],"updatePoint":{"line":138,"column":26},"line":138,"code":"test('fail on invalid YAML', async () => {\n  let err!: Error\n  try {\n    await readProjectManifest(path.join(fixtures, 'invalid-package-yaml'))\n  } catch (_err: any) { // eslint-disable-line\n    err = _err\n  }\n\n  expect(err).toBeTruthy()\n  expect(err['code']).toBe('ERR_PNPM_YAML_PARSE')\n  expect(err.message).toMatch(/^missed comma between flow collection entries \\(3:3\\)/)\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve trailing new line at the end of package.json","suites":[],"updatePoint":{"line":151,"column":59},"line":151,"code":"test('preserve trailing new line at the end of package.json', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json', '{}', 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json', 'utf8')\n  expect(rawManifest).toBe('{\"dependencies\":{\"bar\":\"1.0.0\"}}')\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"preserve trailing new line at the end of package.json5","suites":[],"updatePoint":{"line":164,"column":60},"line":164,"code":"test('preserve trailing new line at the end of package.json5', async () => {\n  process.chdir(tempy.directory())\n\n  await fs.writeFile('package.json5', '{}', 'utf8')\n\n  const { manifest, writeProjectManifest } = await readProjectManifest(process.cwd())\n\n  await writeProjectManifest({ ...manifest, dependencies: { bar: '1.0.0' } })\n\n  const rawManifest = await fs.readFile('package.json5', 'utf8')\n  expect(rawManifest).toBe(\"{dependencies:{bar:'1.0.0'}}\")\n})","file":"index.ts","skipped":false,"dir":"packages/read-project-manifest/test"},{"name":"renderPeerIssues()","suites":[],"updatePoint":{"line":4,"column":24},"line":4,"code":"test('renderPeerIssues()', () => {\n  expect(stripAnsi(renderPeerIssues({\n    'packages/0': {\n      conflicts: ['eee'],\n      intersections: { ddd: '^1.0.0' },\n      bad: {},\n      missing: {\n        ddd: [\n          {\n            parents: [\n              {\n                name: 'zzz',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '^1.0.0',\n          },\n        ],\n        eee: [\n          {\n            parents: [\n              {\n                name: 'zzz',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '^1.0.0',\n          },\n          {\n            parents: [\n              {\n                name: 'www',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '^2.0.0',\n          },\n        ],\n      },\n    },\n    '.': {\n      missing: {\n        aaa: [\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n              {\n                name: 'yyy',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '>=1.0.0 <3.0.0',\n          },\n        ],\n      },\n      bad: {\n        bbb: [\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n            ],\n            foundVersion: '2',\n            resolvedFrom: [],\n            optional: false,\n            wantedRange: '^1.0.0',\n          },\n        ],\n        ccc: [\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n              {\n                name: 'yyy',\n                version: '1.0.0',\n              },\n            ],\n            foundVersion: '2',\n            resolvedFrom: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '^1.0.0',\n          },\n        ],\n      },\n      conflicts: [],\n      intersections: { aaa: '^1.0.0' },\n    },\n  }, { width: 500 }))).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/render-peer-issues/test"},{"name":"renderPeerIssues() optional peer dependencies are printed only if they are in conflict with non-optional peers","suites":[],"updatePoint":{"line":111,"column":116},"line":111,"code":"test('renderPeerIssues() optional peer dependencies are printed only if they are in conflict with non-optional peers', () => {\n  expect(stripAnsi(renderPeerIssues({\n    '.': {\n      missing: {\n        aaa: [\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n              {\n                name: 'yyy',\n                version: '1.0.0',\n              },\n            ],\n            optional: true,\n            wantedRange: '^1.0.0',\n          },\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n              {\n                name: 'yyy',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '^2.0.0',\n          },\n        ],\n        bbb: [\n          {\n            parents: [\n              {\n                name: 'xxx',\n                version: '1.0.0',\n              },\n            ],\n            optional: true,\n            wantedRange: '^1.0.0',\n          },\n        ],\n      },\n      bad: {},\n      conflicts: ['aaa'],\n      intersections: {},\n    },\n    empty: {\n      missing: {},\n      bad: {},\n      conflicts: [],\n      intersections: {},\n    },\n  }, { width: 500 }))).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/render-peer-issues/test"},{"name":"renderPeerIssues() format correctly the version ranges with spaces and \"*\"","suites":[],"updatePoint":{"line":171,"column":80},"line":171,"code":"test('renderPeerIssues() format correctly the version ranges with spaces and \"*\"', () => {\n  expect(stripAnsi(renderPeerIssues({\n    '.': {\n      conflicts: [],\n      intersections: { a: '*', b: '1 || 2' },\n      bad: {},\n      missing: {\n        a: [\n          {\n            parents: [\n              {\n                name: 'z',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '*',\n          },\n        ],\n        b: [\n          {\n            parents: [\n              {\n                name: 'z',\n                version: '1.0.0',\n              },\n            ],\n            optional: false,\n            wantedRange: '1 || 2',\n          },\n        ],\n      },\n    },\n  }, { width: 500 }))).toMatchSnapshot()\n})","file":"index.ts","skipped":false,"dir":"packages/render-peer-issues/test"},{"name":"relativeTarball()","suites":[],"updatePoint":{"line":4,"column":23},"line":4,"code":"test('relativeTarball()', () => {\n  expect(relativeTarball('https://registry.com/foo/bar.tgz', 'https://registry.com/foo')).toBe('bar.tgz')\n  expect(relativeTarball('https://registry.com/foo/bar.tgz', 'https://registry.com/foo/')).toBe('bar.tgz')\n})","file":"relativeTarball.test.ts","skipped":false,"dir":"packages/resolve-dependencies/test"},{"name":"server","suites":[],"updatePoint":{"line":33,"column":12},"line":33,"code":"test('server', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n  const storeCtrl = await connectStoreController({ remotePrefix, concurrency: 100 })\n  const projectDir = process.cwd()\n  const response = await storeCtrl.requestPackage(\n    { alias: 'is-positive', pref: '1.0.0' },\n    {\n      downloadPriority: 0,\n      lockfileDir: projectDir,\n      preferredVersions: {},\n      projectDir,\n      registry,\n      sideEffectsCache: false,\n    }\n  )\n\n  expect((await response.bundledManifest!()).name).toBe('is-positive')\n  expect(response.body.id).toBe('registry.npmjs.org/is-positive/1.0.0')\n\n  expect(response.body.manifest!.name).toBe('is-positive')\n  expect(response.body.manifest!.version).toBe('1.0.0')\n\n  const files = await response.files!()\n  expect(files.fromStore).toBeFalsy()\n  expect(files.filesIndex).toHaveProperty(['package.json'])\n  expect(response.finishing).toBeTruthy()\n\n  await response.finishing!()\n\n  await server.close()\n  await storeCtrl.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"fetchPackage","suites":[],"updatePoint":{"line":73,"column":18},"line":73,"code":"test('fetchPackage', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeDir = tempy.directory()\n  const storeCtrlForServer = await createStoreController(storeDir)\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n  const storeCtrl = await connectStoreController({ remotePrefix, concurrency: 100 })\n  const pkgId = 'registry.npmjs.org/is-positive/1.0.0'\n  const response = await storeCtrl.fetchPackage({\n    fetchRawManifest: true,\n    force: false,\n    lockfileDir: process.cwd(),\n    pkg: {\n      id: pkgId,\n      resolution: {\n        integrity: 'sha1-iACYVrZKLx632LsBeUGEJK4EUss=',\n        registry: 'https://registry.npmjs.org/',\n        tarball: 'https://registry.npmjs.org/is-positive/-/is-positive-1.0.0.tgz',\n      },\n    },\n  })\n\n  expect(typeof response.filesIndexFile).toBe('string')\n\n  expect(await response.bundledManifest!()).toBeTruthy()\n\n  const files = await response['files']()\n  expect(files.fromStore).toBeFalsy()\n  expect(files.filesIndex).toHaveProperty(['package.json'])\n  expect(response).toHaveProperty(['finishing'])\n\n  await response['finishing']()\n\n  await server.close()\n  await storeCtrl.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"server errors should arrive to the client","suites":[],"updatePoint":{"line":114,"column":47},"line":114,"code":"test('server errors should arrive to the client', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n  const storeCtrl = await connectStoreController({ remotePrefix, concurrency: 100 })\n  let caught = false\n  try {\n    const projectDir = process.cwd()\n    await storeCtrl.requestPackage(\n      { alias: 'not-an-existing-package', pref: '1.0.0' },\n      {\n        downloadPriority: 0,\n        lockfileDir: projectDir,\n        preferredVersions: {},\n        projectDir,\n        registry,\n        sideEffectsCache: false,\n      }\n    )\n  } catch (e: any) { // eslint-disable-line\n    caught = true\n    expect(e.message).toBe('GET https://registry.npmjs.org/not-an-existing-package: Not Found - 404')\n    expect(e.hint).toBe(`not-an-existing-package is not in the npm registry, or you have no permission to fetch it.\n\nNo authorization header was set for the request.`)\n    expect(e.code).toBe('ERR_PNPM_FETCH_404')\n    expect(e.response).toBeTruthy()\n    expect(e.pkgName).toBeTruthy()\n  }\n  expect(caught).toBeTruthy()\n\n  await server.close()\n  await storeCtrl.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"server upload","suites":[],"updatePoint":{"line":154,"column":19},"line":154,"code":"test('server upload', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeDir = tempy.directory()\n  const storeCtrlForServer = await createStoreController(storeDir)\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n  const storeCtrl = await connectStoreController({ remotePrefix, concurrency: 100 })\n\n  const fakeEngine = 'client-engine'\n  const filesIndexFile = path.join(storeDir, 'test.example.com/fake-pkg/1.0.0.json')\n\n  await storeCtrl.upload(path.join(__dirname, 'side-effect-fake-dir'), {\n    engine: fakeEngine,\n    filesIndexFile,\n  })\n\n  const cacheIntegrity = await loadJsonFile(filesIndexFile)\n  expect(Object.keys(cacheIntegrity?.['sideEffects'][fakeEngine]).sort()).toStrictEqual(['side-effect.js', 'side-effect.txt'])\n\n  await server.close()\n  await storeCtrl.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"disable server upload","suites":[],"updatePoint":{"line":181,"column":27},"line":181,"code":"test('disable server upload', async () => {\n  await rimraf('.store')\n\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    ignoreUploadRequests: true,\n    port,\n  })\n  const storeCtrl = await connectStoreController({ remotePrefix, concurrency: 100 })\n\n  const fakeEngine = 'client-engine'\n  const storeDir = tempy.directory()\n  const filesIndexFile = path.join(storeDir, 'test.example.com/fake-pkg/1.0.0.json')\n\n  let thrown = false\n  try {\n    await storeCtrl.upload(path.join(__dirname, 'side-effect-fake-dir'), {\n      engine: fakeEngine,\n      filesIndexFile,\n    })\n  } catch (e) {\n    thrown = true\n  }\n  expect(thrown).toBeTruthy()\n\n  expect(fs.existsSync(filesIndexFile)).toBeFalsy()\n\n  await server.close()\n  await storeCtrl.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"stop server with remote call","suites":[],"updatePoint":{"line":216,"column":34},"line":216,"code":"test('stop server with remote call', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  createServer(storeCtrlForServer, {\n    hostname,\n    ignoreStopRequests: false,\n    port,\n  })\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  const response = await fetch(`${remotePrefix}/stop`, { method: 'POST' })\n\n  expect(response.status).toBe(200)\n\n  expect(await isPortReachable(port)).toBeFalsy()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"disallow stop server with remote call","suites":[],"updatePoint":{"line":236,"column":43},"line":236,"code":"test('disallow stop server with remote call', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    ignoreStopRequests: true,\n    port,\n  })\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  const response = await fetch(`${remotePrefix}/stop`, { method: 'POST' })\n  expect(response.status).toBe(403)\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  await server.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"disallow store prune","suites":[],"updatePoint":{"line":257,"column":26},"line":257,"code":"test('disallow store prune', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  const response = await fetch(`${remotePrefix}/prune`, { method: 'POST' })\n  expect(response.status).toBe(403)\n\n  await server.close()\n  await storeCtrlForServer.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"server should only allow POST","suites":[],"updatePoint":{"line":276,"column":35},"line":276,"code":"test('server should only allow POST', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  // Try various methods (not including POST)\n  const methods = ['GET', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']\n\n  for (const method of methods) {\n    // Ensure 405 error is received\n    const response = await fetch(`${remotePrefix}/a-random-endpoint`, { method: method })\n    expect(response.status).toBe(405)\n    expect((await response.json() as any).error).toBeTruthy() // eslint-disable-line\n  }\n\n  await server.close()\n  await storeCtrlForServer.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"server route not found","suites":[],"updatePoint":{"line":302,"column":28},"line":302,"code":"test('server route not found', async () => {\n  const port = await getPort()\n  const hostname = 'localhost'\n  const remotePrefix = `http://${hostname}:${port}`\n  const storeCtrlForServer = await createStoreController()\n  const server = createServer(storeCtrlForServer, {\n    hostname,\n    port,\n  })\n\n  expect(await isPortReachable(port)).toBeTruthy()\n\n  // Ensure 404 error is received\n  const response = await fetch(`${remotePrefix}/a-random-endpoint`, { method: 'POST' })\n  // Ensure error is correct\n  expect(response.status).toBe(404)\n  expect((await response.json() as any).error).toBeTruthy() // eslint-disable-line\n\n  await server.close()\n  await storeCtrlForServer.close()\n})","file":"index.ts","skipped":false,"dir":"packages/server/test"},{"name":"fail when tarball size does not match content-length","suites":[],"updatePoint":{"line":34,"column":58},"line":34,"code":"test('fail when tarball size does not match content-length', async () => {\n  const scope = nock(registry)\n    .get('/foo.tgz')\n    .times(2)\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': (1024 * 1024).toString(),\n    })\n\n  process.chdir(tempy.directory())\n\n  const resolution = {\n    // Even though the integrity of the downloaded tarball\n    // will not match this value, the error will be about\n    // Content-Length mismatch,\n    // which indicates bad network connection. (see https://github.com/pnpm/pnpm/issues/1235)\n    integrity: 'sha1-HssnaJydJVE+rbzZFKc/VAi+enY=',\n    tarball: `${registry}foo.tgz`,\n  }\n\n  await expect(\n    fetch.tarball(cafs, resolution, {\n      lockfileDir: process.cwd(),\n    })\n  ).rejects.toThrow(\n    new BadTarballError({\n      expectedSize: 1048576,\n      receivedSize: tarballSize,\n      tarballUrl: resolution.tarball,\n    })\n  )\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"retry when tarball size does not match content-length","suites":[],"updatePoint":{"line":67,"column":59},"line":67,"code":"test('retry when tarball size does not match content-length', async () => {\n  nock(registry)\n    .get('/foo.tgz')\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': (1024 * 1024).toString(),\n    })\n\n  nock(registry)\n    .get('/foo.tgz')\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': tarballSize.toString(),\n    })\n\n  process.chdir(tempy.directory())\n\n  const resolution = { tarball: 'http://example.com/foo.tgz' }\n\n  const result = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(result.filesIndex).toBeTruthy()\n  expect(nock.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"fail when integrity check fails two times in a row","suites":[],"updatePoint":{"line":92,"column":56},"line":92,"code":"test('fail when integrity check fails two times in a row', async () => {\n  const scope = nock(registry)\n    .get('/foo.tgz')\n    .times(2)\n    .replyWithFile(200, f.find('babel-helper-hoist-variables-7.0.0-alpha.10.tgz'), {\n      'Content-Length': '1194',\n    })\n\n  process.chdir(tempy.directory())\n\n  const resolution = {\n    integrity: tarballIntegrity,\n    tarball: 'http://example.com/foo.tgz',\n  }\n\n  await expect(\n    fetch.tarball(cafs, resolution, {\n      lockfileDir: process.cwd(),\n    })\n  ).rejects.toThrow(\n    new TarballIntegrityError({\n      algorithm: 'sha512',\n      expected: 'sha1-HssnaJydJVE+rbyZFKc/VAi+enY=',\n      found: 'sha512-VuFL1iPaIxJK/k3gTxStIkc6+wSiDwlLdnCWNZyapsVLobu/0onvGOZolASZpfBFiDJYrOIGiDzgLIULTW61Vg== sha1-ACjKMFA7S6uRFXSDFfH4aT+4B4Y=',\n      sri: '',\n      url: resolution.tarball,\n    })\n  )\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"retry when integrity check fails","suites":[],"updatePoint":{"line":123,"column":38},"line":123,"code":"test('retry when integrity check fails', async () => {\n  const scope = nock(registry)\n    .get('/foo.tgz')\n    .replyWithFile(200, f.find('babel-helper-hoist-variables-7.0.0-alpha.10.tgz'), {\n      'Content-Length': '1194',\n    })\n    .get('/foo.tgz')\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': tarballSize.toString(),\n    })\n\n  process.chdir(tempy.directory())\n\n  const resolution = {\n    integrity: tarballIntegrity,\n    tarball: 'http://example.com/foo.tgz',\n  }\n\n  const params: Array<[number | null, number]> = []\n  await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n    onStart (size, attempts) {\n      params.push([size, attempts])\n    },\n  })\n\n  expect(params[0]).toStrictEqual([1194, 1])\n  expect(params[1]).toStrictEqual([tarballSize, 2])\n\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"fail when integrity check of local file fails","suites":[],"updatePoint":{"line":155,"column":51},"line":155,"code":"test('fail when integrity check of local file fails', async () => {\n  const storeDir = tempy.directory()\n  process.chdir(storeDir)\n\n  f.copy('babel-helper-hoist-variables-7.0.0-alpha.10.tgz', 'tar.tgz')\n  const resolution = {\n    integrity: tarballIntegrity,\n    tarball: 'file:tar.tgz',\n  }\n\n  await expect(\n    fetch.tarball(cafs, resolution, {\n      lockfileDir: process.cwd(),\n    })\n  ).rejects.toThrow(\n    new TarballIntegrityError({\n      algorithm: 'sha512',\n      expected: 'sha1-HssnaJydJVE+rbyZFKc/VAi+enY=',\n      found: 'sha512-VuFL1iPaIxJK/k3gTxStIkc6+wSiDwlLdnCWNZyapsVLobu/0onvGOZolASZpfBFiDJYrOIGiDzgLIULTW61Vg== sha1-ACjKMFA7S6uRFXSDFfH4aT+4B4Y=',\n      sri: '',\n      url: path.join(storeDir, 'tar.tgz'),\n    })\n  )\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"don't fail when integrity check of local file succeeds","suites":[],"updatePoint":{"line":180,"column":60},"line":180,"code":"test(\"don't fail when integrity check of local file succeeds\", async () => {\n  process.chdir(tempy.directory())\n\n  const localTarballLocation = path.resolve('tar.tgz')\n  f.copy('babel-helper-hoist-variables-7.0.0-alpha.10.tgz', localTarballLocation)\n  const resolution = {\n    integrity: await getFileIntegrity(localTarballLocation),\n    tarball: 'file:tar.tgz',\n  }\n\n  const { filesIndex } = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(typeof filesIndex['package.json']).toBe('object')\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"don't fail when fetching a local tarball in offline mode","suites":[],"updatePoint":{"line":197,"column":62},"line":197,"code":"test(\"don't fail when fetching a local tarball in offline mode\", async () => {\n  process.chdir(tempy.directory())\n\n  const tarballAbsoluteLocation = f.find('babel-helper-hoist-variables-7.0.0-alpha.10.tgz')\n  const resolution = {\n    integrity: await getFileIntegrity(tarballAbsoluteLocation),\n    tarball: `file:${tarballAbsoluteLocation}`,\n  }\n\n  const fetch = createFetcher(fetchFromRegistry, getCredentials, {\n    offline: true,\n    retry: {\n      maxTimeout: 100,\n      minTimeout: 0,\n      retries: 1,\n    },\n  })\n  const { filesIndex } = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(typeof filesIndex['package.json']).toBe('object')\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"fail when trying to fetch a non-local tarball in offline mode","suites":[],"updatePoint":{"line":221,"column":67},"line":221,"code":"test('fail when trying to fetch a non-local tarball in offline mode', async () => {\n  process.chdir(tempy.directory())\n\n  const tarballAbsoluteLocation = f.find('babel-helper-hoist-variables-7.0.0-alpha.10.tgz')\n  const resolution = {\n    integrity: await getFileIntegrity(tarballAbsoluteLocation),\n    tarball: `${registry}foo.tgz`,\n  }\n\n  const fetch = createFetcher(fetchFromRegistry, getCredentials, {\n    offline: true,\n    retry: {\n      maxTimeout: 100,\n      minTimeout: 0,\n      retries: 1,\n    },\n  })\n  await expect(\n    fetch.tarball(cafs, resolution, {\n      lockfileDir: process.cwd(),\n    })\n  ).rejects.toThrow(\n    new PnpmError('NO_OFFLINE_TARBALL',\n      `A package is missing from the store but cannot download it in offline mode. \\\nThe missing package may be downloaded from ${resolution.tarball}.`)\n  )\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"retry on server error","suites":[],"updatePoint":{"line":249,"column":27},"line":249,"code":"test('retry on server error', async () => {\n  const scope = nock(registry)\n    .get('/foo.tgz')\n    .reply(500)\n    .get('/foo.tgz')\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': tarballSize.toString(),\n    })\n\n  process.chdir(tempy.directory())\n\n  const resolution = {\n    integrity: tarballIntegrity,\n    tarball: 'http://example.com/foo.tgz',\n  }\n\n  const index = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(index).toBeTruthy()\n\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"throw error when accessing private package w/o authorization","suites":[],"updatePoint":{"line":274,"column":66},"line":274,"code":"test('throw error when accessing private package w/o authorization', async () => {\n  const scope = nock(registry)\n    .get('/foo.tgz')\n    .reply(403)\n\n  process.chdir(tempy.directory())\n\n  const resolution = {\n    integrity: tarballIntegrity,\n    tarball: 'http://example.com/foo.tgz',\n  }\n\n  await expect(\n    fetch.tarball(cafs, resolution, {\n      lockfileDir: process.cwd(),\n    })\n  ).rejects.toThrow(\n    new FetchError(\n      {\n        url: resolution.tarball,\n      },\n      {\n        status: 403,\n        // statusText: 'Forbidden',\n        statusText: '',\n      }\n    )\n  )\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"accessing private packages","suites":[],"updatePoint":{"line":305,"column":32},"line":305,"code":"test('accessing private packages', async () => {\n  const scope = nock(\n    registry,\n    {\n      reqheaders: {\n        authorization: 'Bearer ofjergrg349gj3f2',\n      },\n    }\n  )\n    .get('/foo.tgz')\n    .replyWithFile(200, tarballPath, {\n      'Content-Length': tarballSize.toString(),\n    })\n\n  process.chdir(tempy.directory())\n\n  const getCredentials = () => ({\n    alwaysAuth: undefined,\n    authHeaderValue: 'Bearer ofjergrg349gj3f2',\n  })\n  const fetch = createFetcher(fetchFromRegistry, getCredentials, {\n    retry: {\n      maxTimeout: 100,\n      minTimeout: 0,\n      retries: 1,\n    },\n  })\n\n  const resolution = {\n    integrity: tarballIntegrity,\n    registry,\n    tarball: 'http://example.com/foo.tgz',\n  }\n\n  const index = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(index).toBeTruthy()\n\n  expect(scope.isDone()).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"fetch a big repository","suites":[],"updatePoint":{"line":353,"column":28},"line":353,"code":"test('fetch a big repository', async () => {\n  process.chdir(tempy.directory())\n\n  const resolution = { tarball: 'https://codeload.github.com/sveltejs/action-deploy-docs/tar.gz/a65fbf5a90f53c9d72fed4daaca59da50f074355' }\n\n  const result = await fetch.tarball(cafs, resolution, {\n    lockfileDir: process.cwd(),\n  })\n\n  expect(result.filesIndex).toBeTruthy()\n})","file":"download.ts","skipped":false,"dir":"packages/tarball-fetcher/test"},{"name":"tarball from npm registry","suites":[],"updatePoint":{"line":4,"column":31},"line":4,"code":"test('tarball from npm registry', async () => {\n  const resolutionResult = await resolveFromTarball({ pref: 'http://registry.npmjs.org/is-array/-/is-array-1.0.1.tgz' })\n\n  expect(resolutionResult).toStrictEqual({\n    id: '@registry.npmjs.org/is-array/-/is-array-1.0.1.tgz',\n    normalizedPref: 'http://registry.npmjs.org/is-array/-/is-array-1.0.1.tgz',\n    resolution: {\n      tarball: 'http://registry.npmjs.org/is-array/-/is-array-1.0.1.tgz',\n    },\n    resolvedVia: 'url',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/tarball-resolver/test"},{"name":"tarball from URL that contain port number","suites":[],"updatePoint":{"line":17,"column":47},"line":17,"code":"test('tarball from URL that contain port number', async () => {\n  const resolutionResult = await resolveFromTarball({ pref: 'http://buildserver.mycompany.com:81/my-private-package-0.1.6.tgz' })\n\n  expect(resolutionResult).toStrictEqual({\n    id: '@buildserver.mycompany.com+81/my-private-package-0.1.6.tgz',\n    normalizedPref: 'http://buildserver.mycompany.com:81/my-private-package-0.1.6.tgz',\n    resolution: {\n      tarball: 'http://buildserver.mycompany.com:81/my-private-package-0.1.6.tgz',\n    },\n    resolvedVia: 'url',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/tarball-resolver/test"},{"name":"tarball not from npm registry","suites":[],"updatePoint":{"line":30,"column":35},"line":30,"code":"test('tarball not from npm registry', async () => {\n  const resolutionResult = await resolveFromTarball({ pref: 'https://github.com/hegemonic/taffydb/tarball/master' })\n\n  expect(resolutionResult).toStrictEqual({\n    id: '@github.com/hegemonic/taffydb/tarball/master',\n    normalizedPref: 'https://github.com/hegemonic/taffydb/tarball/master',\n    resolution: {\n      tarball: 'https://github.com/hegemonic/taffydb/tarball/master',\n    },\n    resolvedVia: 'url',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/tarball-resolver/test"},{"name":"tarballs from GitHub (is-negative)","suites":[],"updatePoint":{"line":43,"column":40},"line":43,"code":"test('tarballs from GitHub (is-negative)', async () => {\n  const resolutionResult = await resolveFromTarball({ pref: 'https://github.com/kevva/is-negative/archive/1d7e288222b53a0cab90a331f1865220ec29560c.tar.gz' })\n\n  expect(resolutionResult).toStrictEqual({\n    id: '@github.com/kevva/is-negative/archive/1d7e288222b53a0cab90a331f1865220ec29560c.tar.gz',\n    normalizedPref: 'https://github.com/kevva/is-negative/archive/1d7e288222b53a0cab90a331f1865220ec29560c.tar.gz',\n    resolution: {\n      tarball: 'https://github.com/kevva/is-negative/archive/1d7e288222b53a0cab90a331f1865220ec29560c.tar.gz',\n    },\n    resolvedVia: 'url',\n  })\n})","file":"index.ts","skipped":false,"dir":"packages/tarball-resolver/test"},{"name":"ignore direct URLs to repositories","suites":[],"updatePoint":{"line":56,"column":40},"line":56,"code":"test('ignore direct URLs to repositories', async () => {\n  expect(await resolveFromTarball({ pref: 'https://github.com/foo/bar' })).toBe(null)\n  expect(await resolveFromTarball({ pref: 'https://github.com/foo/bar/' })).toBe(null)\n  expect(await resolveFromTarball({ pref: 'https://gitlab.com/foo/bar' })).toBe(null)\n  expect(await resolveFromTarball({ pref: 'https://bitbucket.org/foo/bar' })).toBe(null)\n})","file":"index.ts","skipped":false,"dir":"packages/tarball-resolver/test"},{"name":"whichVersionIsPinned()","suites":[],"line":3,"code":"test.each([\n  ['^1.0.0', 'major'],\n  ['~1.0.0', 'minor'],\n  ['1.0.0', 'patch'],\n  ['*', 'none'],\n  ['workspace:^1.0.0', 'major'],\n])('whichVersionIsPinned()', (spec, expectedResult) => {\n  expect(whichVersionIsPinned(spec)).toEqual(expectedResult)\n})","file":"index.ts","skipped":false,"dir":"packages/which-version-is-pinned/test"},{"name":"writeProjectManifest()","suites":[],"updatePoint":{"line":10,"column":28},"line":10,"code":"test('writeProjectManifest()', async () => {\n  const dir = tempy.directory()\n\n  await writeProjectManifest(path.join(dir, 'package.json'), { name: 'foo', version: '1.0.0' })\n  expect(await readFile(path.join(dir, 'package.json'), 'utf8')).toBe('{\\n\\t\"name\": \"foo\",\\n\\t\"version\": \"1.0.0\"\\n}\\n')\n\n  await writeProjectManifest(path.join(dir, 'package.json5'), { name: 'foo', version: '1.0.0' })\n  expect(await readFile(path.join(dir, 'package.json5'), 'utf8')).toBe(\"{\\n\\tname: 'foo',\\n\\tversion: '1.0.0',\\n}\\n\")\n\n  await writeProjectManifest(path.join(dir, 'package.yaml'), { name: 'foo', version: '1.0.0' })\n  expect(await readFile(path.join(dir, 'package.yaml'), 'utf8')).toBe('name: foo\\nversion: 1.0.0\\n')\n})","file":"index.ts","skipped":false,"dir":"packages/write-project-manifest/test"},{"name":"assertProject()","suites":[],"updatePoint":{"line":5,"column":21},"line":5,"code":"test('assertProject()', async () => {\n  const project = assertProject(path.join(__dirname, '../../..'))\n\n  await project.has('rimraf')\n  await project.hasNot('sfdsff3g34')\n  expect(typeof project.requireModule('rimraf')).toBe('function')\n  await project.isExecutable('.bin/rimraf')\n})","file":"index.ts","skipped":false,"dir":"privatePackages/assert-project/test"},{"name":"assertProject() store functions","suites":[],"updatePoint":{"line":14,"column":37},"line":14,"code":"test('assertProject() store functions', async () => {\n  const project = assertProject(path.join(__dirname, 'fixture/project'), 'registry.npmjs.org')\n\n  expect(typeof await project.getStorePath()).toBe('string')\n  await project.storeHas('is-positive', '3.1.0')\n  expect(typeof await project.resolve('is-positive', '3.1.0')).toBe('string')\n  await project.storeHasNot('is-positive', '3.100.0')\n  expect(await project.readLockfile()).toBeTruthy()\n  expect(await project.readCurrentLockfile()).toBeTruthy()\n  expect(await project.readModulesManifest()).toBeTruthy()\n})","file":"index.ts","skipped":false,"dir":"privatePackages/assert-project/test"},{"name":"assertStore() store assertions","suites":[],"updatePoint":{"line":5,"column":36},"line":5,"code":"test('assertStore() store assertions', async () => {\n  const storePath = path.join(__dirname, 'fixture/store/v3/')\n  const encodedRegistryName = 'registry.npmjs.org'\n  const store = assertStore(storePath, encodedRegistryName)\n\n  await store.storeHas('is-positive', '3.1.0')\n  await store.storeHasNot('ansi-regex', '2.0.0')\n  await store.storeHasNot('is-positive', '2.0.0')\n})","file":"index.ts","skipped":false,"dir":"privatePackages/assert-store/test"},{"name":"assertStore() resolve","suites":[],"updatePoint":{"line":15,"column":27},"line":15,"code":"test('assertStore() resolve', async () => {\n  const storePath = path.join(__dirname, 'fixture/store/v3/')\n  const encodedRegistryName = 'registry.npmjs.org'\n  const store = assertStore(storePath, encodedRegistryName)\n\n  expect(typeof await store.resolve('is-positive', '3.1.0')).toBe('string')\n})","file":"index.ts","skipped":false,"dir":"privatePackages/assert-store/test"}]}