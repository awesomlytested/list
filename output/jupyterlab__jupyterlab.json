{"repo":"jupyterlab/jupyterlab","url":"https://github.com/jupyterlab/jupyterlab","branch":"master","configs":[{"package":"@jupyterlab/galata","lang":"js","dir":"galata/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/application","lang":"ts","dir":"packages/application/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/apputils","lang":"ts","dir":"packages/apputils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/cells","lang":"ts","dir":"packages/cells/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/codeeditor","lang":"ts","dir":"packages/codeeditor/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/codemirror","lang":"ts","dir":"packages/codemirror/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/completer","lang":"ts","dir":"packages/completer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/console","lang":"ts","dir":"packages/console/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/coreutils","lang":"ts","dir":"packages/coreutils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/csvviewer","lang":"ts","dir":"packages/csvviewer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/debugger","lang":"ts","dir":"packages/debugger/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/docmanager","lang":"ts","dir":"packages/docmanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/docprovider","lang":"ts","dir":"packages/docprovider/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/docregistry","lang":"ts","dir":"packages/docregistry/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/documentsearch","lang":"ts","dir":"packages/documentsearch/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/filebrowser","lang":"ts","dir":"packages/filebrowser/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/fileeditor","lang":"ts","dir":"packages/fileeditor/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/imageviewer","lang":"ts","dir":"packages/imageviewer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/inspector","lang":"ts","dir":"packages/inspector/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/logconsole","lang":"ts","dir":"packages/logconsole/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/mainmenu","lang":"ts","dir":"packages/mainmenu/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/nbformat","lang":"ts","dir":"packages/nbformat/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/notebook","lang":"ts","dir":"packages/notebook/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/observables","lang":"ts","dir":"packages/observables/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/outputarea","lang":"ts","dir":"packages/outputarea/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/rendermime","lang":"ts","dir":"packages/rendermime/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/services","lang":"ts","dir":"packages/services/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/settingregistry","lang":"ts","dir":"packages/settingregistry/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/shared-models","lang":"ts","dir":"packages/shared-models/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/statedb","lang":"ts","dir":"packages/statedb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/statusbar","lang":"ts","dir":"packages/statusbar/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/terminal","lang":"ts","dir":"packages/terminal/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/toc","lang":"ts","dir":"packages/toc/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/translation","lang":"ts","dir":"packages/translation/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/ui-components","lang":"ts","dir":"packages/ui-components/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/user","lang":"ts","dir":"packages/user/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@jupyterlab/testutils","lang":"ts","dir":"testutils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"measure  - ","suites":[],"updatePoint":{"line":39,"column":41,"index":3429},"line":39,"code":"    test(`measure ${file} - ${sample + 1}`, async ({\n      baseURL,\n      browserName,\n      page\n    }, testInfo) => {\n      const attachmentCommon = {\n        nSamples: benchmark.nSamples,\n        browser: browserName,\n        file: path.basename(file, '.ipynb'),\n        project: testInfo.project.name\n      };\n      const perf = galata.newPerformanceHelper(page);\n      await page.goto(baseURL + '?reset');\n      await page.click('#filebrowser >> .jp-BreadCrumbs-home');\n      await page.dblclick(`#filebrowser >> text=${tmpPath}`);\n      const openTime = await perf.measure(async () => {\n        // Open the notebook and wait for the spinner\n        await Promise.all([page.waitForSelector('[role=\"main\"] >> .jp-SpinnerContent'), page.dblclick(`#filebrowser >> text=${file}`)]); // Wait for spinner to be hidden\n\n        await page.waitForSelector('[role=\"main\"] >> .jp-SpinnerContent', {\n          state: 'hidden'\n        });\n      }); // Check the notebook is correctly opened\n\n      let panel = await page.$('[role=\"main\"] >> .jp-NotebookPanel'); // Get only the document node to avoid noise from kernel and debugger in the toolbar\n\n      let document = await panel.$('.jp-Notebook');\n      expect(await document.screenshot()).toMatchSnapshot(`${file.replace('.', '-')}.png`);\n      testInfo.attachments.push(benchmark.addAttachment({ ...attachmentCommon,\n        test: 'open',\n        time: openTime\n      })); // Shutdown the kernel to be sure it does not get in our way (especially for the close action)\n\n      await page.click('li[role=\"menuitem\"]:has-text(\"Kernel\")');\n      await page.click('ul[role=\"menu\"] >> text=Shut Down All Kernelsâ€¦');\n      await page.click(':nth-match(button:has-text(\"Shut Down All\"), 3)'); // Open text file\n\n      const fromTime = await perf.measure(async () => {\n        await page.dblclick(`#filebrowser >> text=${textFile}`);\n        await page.waitForSelector(`div[role=\"main\"] >> .lm-DockPanel-tabBar >> text=${path.basename(textFile)}`);\n      });\n      let editorPanel = page.locator('div[role=\"tabpanel\"]:has-text(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin mole\")');\n      await expect(editorPanel).toBeVisible();\n      testInfo.attachments.push(benchmark.addAttachment({ ...attachmentCommon,\n        test: 'switch-from',\n        time: fromTime\n      })); // Switch back\n\n      const toTime = await perf.measure(async () => {\n        await page.click(`div[role=\"main\"] >> .lm-DockPanel-tabBar >> text=${file}`);\n      }); // Check the notebook is correctly opened\n\n      panel = await page.$('[role=\"main\"] >> .jp-NotebookPanel'); // Get only the document node to avoid noise from kernel and debugger in the toolbar\n\n      document = await panel.$('.jp-Notebook');\n      expect(await document.screenshot()).toMatchSnapshot(`${file.replace('.', '-')}.png`);\n      testInfo.attachments.push(benchmark.addAttachment({ ...attachmentCommon,\n        test: 'switch-to',\n        time: toTime\n      })); // Close notebook\n\n      await page.click('li[role=\"menuitem\"]:has-text(\"File\")');\n      const closeTime = await perf.measure(async () => {\n        await page.click('ul[role=\"menu\"] >> text=Close Tab'); // Revert changes so we don't measure saving\n\n        const dimissButton = page.locator('button:has-text(\"Discard\")');\n\n        if (await dimissButton.isVisible({\n          timeout: 50\n        })) {\n          await dimissButton.click();\n        }\n      });\n      editorPanel = page.locator('div[role=\"tabpanel\"]:has-text(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin mole\")');\n      await expect(editorPanel).toBeVisible();\n      testInfo.attachments.push(benchmark.addAttachment({ ...attachmentCommon,\n        test: 'close',\n        time: closeTime\n      }));\n    });","file":"benchmark/notebook.spec.ts","skipped":false,"dir":"galata/test"},{"name":"Kernel capability","suites":[],"updatePoint":{"line":14,"column":25,"index":420},"line":14,"code":"  test('Kernel capability', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 62,\n      left: 1050,\n      width: 190,\n      height: 28\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_kernel.png');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Activate","suites":[],"updatePoint":{"line":31,"column":16,"index":896},"line":31,"code":"  test('Activate', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen()); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 62,\n      left: 800,\n      width: 190,\n      height: 28\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_activate.png');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Set breakpoint","suites":[],"updatePoint":{"line":50,"column":22,"index":1478},"line":50,"code":"  test('Set breakpoint', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 100,\n      left: 300,\n      width: 300,\n      height: 80\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_breakpoint.png');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Highlight run cell button","suites":[],"updatePoint":{"line":70,"column":33,"index":2105},"line":70,"code":"  test('Highlight run cell button', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page); // Inject capture zone\n\n    await page.evaluate(([mouse, zone]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse + zone);\n    }, [positionMouse({\n      x: 446,\n      y: 80\n    }), generateCaptureArea({\n      top: 62,\n      left: 400,\n      width: 190,\n      height: 80\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_run.png');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Stop on breakpoint","suites":[],"updatePoint":{"line":90,"column":26,"index":2652},"line":90,"code":"  test('Stop on breakpoint', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Don't wait as it will be blocked\n\n    page.notebook.runCell(1); // Wait to be stopped on the breakpoint\n\n    await page.debugger.waitForCallStack(); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 100,\n      left: 300,\n      width: 300,\n      height: 80\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_stop_on_breakpoint.png');\n    await page.click('button[title^=Continue]');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Debugger sidebar","suites":[],"updatePoint":{"line":115,"column":24,"index":3479},"line":115,"code":"  test('Debugger sidebar', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.click('[data-id=\"jp-debugger-sidebar\"]'); // Inject capture zone\n\n    await page.evaluate(([mouse, zone]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse + zone);\n    }, [positionMouse({\n      x: 1240,\n      y: 115\n    }), generateCaptureArea({\n      top: 22,\n      left: 1200,\n      width: 85,\n      height: 160\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_sidebar.png');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Variables panel","suites":[],"updatePoint":{"line":136,"column":23,"index":4087},"line":136,"code":"  test('Variables panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Don't wait as it will be blocked\n\n    page.notebook.runCell(1); // Wait to be stopped on the breakpoint\n\n    await page.debugger.waitForCallStack(); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 58,\n      left: 998,\n      width: 280,\n      height: 138\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('debugger_variables.png');\n    await page.click('button[title^=Continue]');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Call Stack panel","suites":[],"updatePoint":{"line":161,"column":24,"index":4905},"line":161,"code":"  test('Call Stack panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Don't wait as it will be blocked\n\n    page.notebook.runCell(1); // Wait to be stopped on the breakpoint\n\n    await page.debugger.waitForCallStack();\n    await page.pause(); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 196,\n      left: 998,\n      width: 280,\n      height: 138\n    })]);\n    await expect(page.locator('[aria-label=\"side panel content\"] >> text=add').first()).toBeVisible(); // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n\n    await (await page.$('#capture-screenshot')).screenshot({\n      path: 'test/documentation/screenshots/debugger-callstack.png'\n    });\n    await page.click('button[title^=Continue]');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Breakpoints panel","suites":[],"updatePoint":{"line":192,"column":25,"index":5968},"line":192,"code":"  test('Breakpoints panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Don't wait as it will be blocked\n\n    page.notebook.runCell(1); // Wait to be stopped on the breakpoint\n\n    await page.debugger.waitForCallStack(); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 334,\n      left: 998,\n      width: 280,\n      height: 138\n    })]);\n    const breakpointsPanel = await page.debugger.getBreakPointsPanel();\n    expect(await breakpointsPanel.innerText()).toMatch(/ipykernel.*\\/2114632017.py/); // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n\n    await (await page.$('#capture-screenshot')).screenshot({\n      path: 'test/documentation/screenshots/debugger-breakpoints.png'\n    });\n    await page.click('button[title^=Continue]');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Source panel","suites":[],"updatePoint":{"line":223,"column":20,"index":7059},"line":223,"code":"  test('Source panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setBreakpoint(page); // Don't wait as it will be blocked\n\n    page.notebook.runCell(1); // Wait to be stopped on the breakpoint\n\n    await page.debugger.waitForCallStack(); // Inject capture zone\n\n    await page.evaluate(([zone]) => {\n      document.body.insertAdjacentHTML('beforeend', zone);\n    }, [generateCaptureArea({\n      top: 478,\n      left: 998,\n      width: 280,\n      height: 138\n    })]);\n    await expect(page.locator('[aria-label=\"side panel content\"] >> text=Source/tmp/ipykernel_')).toBeVisible(); // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n\n    await (await page.$('#capture-screenshot')).screenshot({\n      path: 'test/documentation/screenshots/debugger-source.png'\n    });\n    await page.click('button[title^=Continue]');\n  });","file":"documentation/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Export Menu","suites":[],"updatePoint":{"line":13,"column":19,"index":335},"line":13,"code":"  test('Export Menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=Save and Export Notebook As'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 5px; left: 0px; width: 700px; height: 700px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('exporting_menu.png');\n  });","file":"documentation/export_notebook.test.ts","skipped":false,"dir":"galata/test"},{"name":"Slides","suites":[],"updatePoint":{"line":27,"column":14,"index":991},"line":27,"code":"  test('Slides', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.click('[title=\"Property Inspector\"]');\n    await page.pause();\n    await page.selectOption('.jp-PropertyInspector >> text=Slide Type >> select', {\n      label: 'Slide'\n    }); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 5px; left: 283px; width: 997px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('exporting_slide_type.png');\n  });","file":"documentation/export_notebook.test.ts","skipped":false,"dir":"galata/test"},{"name":"Sidebar","suites":[],"updatePoint":{"line":13,"column":15,"index":357},"line":13,"code":"  test('Sidebar', async ({\n    page\n  }) => {\n    await page.goto();\n    await openExtensionSidebar(page); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 600px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_default.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Warning","suites":[],"updatePoint":{"line":24,"column":15,"index":817},"line":24,"code":"  test('Warning', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.click('[title=\"Extension Manager\"]'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_disabled.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Warning acknowledge","suites":[],"updatePoint":{"line":35,"column":27,"index":1305},"line":35,"code":"  test('Warning acknowledge', async ({\n    page\n  }) => {\n    await page.goto();\n    await openExtensionSidebar(page); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_enabled.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Search","suites":[],"updatePoint":{"line":46,"column":14,"index":1764},"line":46,"code":"  test('Search', async ({\n    page\n  }) => {\n    await page.goto();\n    await openExtensionSidebar(page);\n    await page.fill('.jp-extensionmanager-view >> [placeholder=\"SEARCH\"]', 'drawio');\n    await page.keyboard.press('Tab'); // We can not wait for extension kept by the keyword as they are already in the DOM\n\n    await page.waitForSelector('text=No entries'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 600px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_search.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"With allowed and blocked list","suites":[],"updatePoint":{"line":61,"column":37,"index":2505},"line":61,"code":"  test('With allowed and blocked list', async ({\n    page\n  }) => {\n    await page.route(/.*\\/api\\/listings\\/.*\\/listings\\.json.*/, (route, request) => {\n      if (request.method() === 'GET') {\n        return route.fulfill({\n          status: 200,\n          body: `{\n                \"blocked_extensions_uris\": [\"http://banana.json\"],\n                \"allowed_extensions_uris\": [\"http://orange.json\"],\n                \"blocked_extensions\": [{\"name\":\"banana\",\"type\":\"jupyterlab\"}],\n                \"allowed_extensions\": [{\"name\":\"orange\",\"type\":\"jupyterlab\"}]\n              }`\n        });\n      } else {\n        return route.continue();\n      }\n    });\n    await page.goto();\n    await page.click('[title=\"Extension Manager\"]'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 160px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_simultaneous_block_allow.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Blocked installed extension","suites":[],"updatePoint":{"line":87,"column":35,"index":3600},"line":87,"code":"  test('Blocked installed extension', async ({\n    page\n  }) => {\n    await page.route(/.*\\/api\\/listings\\/.*\\/listings\\.json.*/, (route, request) => {\n      if (request.method() === 'GET') {\n        return route.fulfill({\n          status: 200,\n          body: `{\n                \"blocked_extensions_uris\": [\"http://banana.json\"],\n                \"allowed_extensions_uris\": [],\n                \"blocked_extensions\": [{\"name\":\"@jupyter-widgets/jupyterlab-manager\",\"type\":\"jupyterlab\"}],\n                \"allowed_extensions\": []\n              }`\n        });\n      } else {\n        return route.continue();\n      }\n    });\n    await page.goto();\n    await openExtensionSidebar(page); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 110px; left: 33px; width: 250px; height: 280px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_blocked_list.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Allowed installed extension","suites":[],"updatePoint":{"line":113,"column":35,"index":4642},"line":113,"code":"  test('Allowed installed extension', async ({\n    page\n  }) => {\n    await page.route(/.*\\/api\\/listings\\/.*\\/listings\\.json.*/, (route, request) => {\n      if (request.method() === 'GET') {\n        return route.fulfill({\n          status: 200,\n          body: `{\n                \"blocked_extensions_uris\": [],\n                \"allowed_extensions_uris\": [\"http://banana.json\"],\n                \"blocked_extensions\": [],\n                \"allowed_extensions\": [{\"name\":\"@jupyter-widgets/jupyterlab-manager\",\"type\":\"jupyterlab\"}]\n              }`\n        });\n      } else {\n        return route.continue();\n      }\n    });\n    await page.goto();\n    await openExtensionSidebar(page); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 110px; left: 33px; width: 250px; height: 280px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('extensions_allowed_list.png');\n  });","file":"documentation/extension_manager.test.ts","skipped":false,"dir":"galata/test"},{"name":"Welcome","suites":[],"updatePoint":{"line":14,"column":15,"index":387},"line":14,"code":"  test('Welcome', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // README.md in preview\n\n    await page.click('text=README.md', {\n      button: 'right'\n    });\n    await page.click('text=Open With');\n    await page.click('text=Markdown Preview');\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=New');\n    await page.click('#jp-mainmenu-file-new >> text=Terminal');\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=New');\n    await page.click('#jp-mainmenu-file-new >> text=Console');\n    await page.click('button:has-text(\"Select\")');\n    await page.dblclick('text=Data.ipynb');\n    await page.dblclick('text=lorenz.py');\n    await page.click('div[role=\"main\"] >> text=Lorenz.ipynb');\n    await page.notebook.run();\n    const cell = await page.$('[aria-label=\"Code Cell Content with Output\"] >> text=interactive');\n    await cell.click();\n    await page.keyboard.press('ContextMenu');\n    await page.click('text=Create New View for Cell Output'); // Emulate drag and drop\n\n    const viewerHandle = await page.$('div[role=\"main\"] >> text=lorenz.py');\n    await viewerHandle.click();\n    const viewerBBox = await viewerHandle.boundingBox();\n    await page.mouse.move(viewerBBox.x + 0.5 * viewerBBox.width, viewerBBox.y + 0.5 * viewerBBox.height);\n    await page.mouse.down();\n    await page.mouse.move(viewerBBox.x + 0.5 * viewerBBox.width, 600);\n    await page.mouse.up();\n    expect(await page.screenshot()).toMatchSnapshot('jupyterlab.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Overview","suites":[],"updatePoint":{"line":57,"column":16,"index":2209},"line":57,"code":"  test('Overview', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await openOverview(page);\n    expect(await page.screenshot()).toMatchSnapshot('interface_jupyterlab.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Left Sidebar","suites":[],"updatePoint":{"line":64,"column":20,"index":2432},"line":64,"code":"  test('Left Sidebar', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=data'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 31px; left: 0px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('interface_left.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Right Sidebar","suites":[],"updatePoint":{"line":81,"column":21,"index":3106},"line":81,"code":"  test('Right Sidebar', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await page.notebook.createNew();\n    await page.click('[title=\"Property Inspector\"]'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 32px; left: 997px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('interface_right.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open tabs","suites":[],"updatePoint":{"line":99,"column":17,"index":3768},"line":99,"code":"  test('Open tabs', async ({\n    page\n  }) => {\n    await openOverview(page);\n    await page.click('[title=\"Running Terminals and Kernels\"]'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 27px; left: 0px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('interface_tabs.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Tabs menu","suites":[],"updatePoint":{"line":110,"column":17,"index":4260},"line":110,"code":"  test('Tabs menu', async ({\n    page\n  }) => {\n    await openOverview(page);\n    await page.click('text=\"Tabs\"'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 210px; width: 700px; height: 350px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('interface_tabs_menu.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"File menu","suites":[],"updatePoint":{"line":121,"column":17,"index":4730},"line":121,"code":"  test('File menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]'); // Inject arrow and capture zone\n\n    await page.evaluate(([arrow]) => {\n      document.body.insertAdjacentHTML('beforeend', arrow);\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 27px; left: 0px; width: 283px; height: 400px;\"></div>');\n    }, [generateArrow({\n      x: 50,\n      y: 55\n    }, -30)]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('files_menu_left.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"File New menu","suites":[],"updatePoint":{"line":142,"column":21,"index":5477},"line":142,"code":"  test('File New menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    await page.click('text=File');\n    await page.mouse.move(70, 40);\n    await page.click('ul[role=\"menu\"] >> text=New'); // Inject mouse and capture zone\n\n    await page.evaluate(([mouse]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse);\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 0px; width: 620px; height: 400px;\"></div>');\n    }, [positionMouse({\n      x: 35,\n      y: 35\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('files_menu_top.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Shareable link","suites":[],"updatePoint":{"line":166,"column":22,"index":6341},"line":166,"code":"  test('Shareable link', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.click('text=Lorenz.ipynb', {\n      button: 'right'\n    });\n    await page.hover('text=Copy Shareable Link'); // Inject mouse and capture zone\n\n    await page.evaluate(([mouse]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse);\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 0px; width: 500px; height: 500px;\"></div>');\n    }, [positionMouse({\n      x: 260,\n      y: 350\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('files_shareable_link.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"File New Text file","suites":[],"updatePoint":{"line":190,"column":26,"index":7229},"line":190,"code":"  test('File New Text file', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    await page.click('text=File');\n    await page.mouse.move(70, 40);\n    await page.click('ul[role=\"menu\"] >> text=New');\n    await page.hover('ul[role=\"menu\"] >> text=Text File'); // Inject mouse and capture zone\n\n    await page.evaluate(([mouse]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse);\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 0px; width: 620px; height: 400px;\"></div>');\n    }, [positionMouse({\n      x: 500,\n      y: 110\n    })]);\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('files_create_text_file.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Text Editor Overview","suites":[],"updatePoint":{"line":215,"column":28,"index":8168},"line":215,"code":"  test('Text Editor Overview', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Open jupyterlab.md\n\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=narrative');\n    await page.dblclick('text=jupyterlab.md'); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    expect(await page.screenshot()).toMatchSnapshot('file_editor_overview.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Text Editor Settings","suites":[],"updatePoint":{"line":231,"column":28,"index":8678},"line":231,"code":"  test('Text Editor Settings', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Open jupyterlab.md\n\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=narrative');\n    await page.dblclick('text=jupyterlab.md');\n    await page.click('text=Settings');\n    await page.click('ul[role=\"menu\"] >> text=Text Editor Key Map'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 260px; width: 600px; height: 450px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('file_editor_settings.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Notebook","suites":[],"updatePoint":{"line":251,"column":16,"index":9482},"line":251,"code":"  test('Notebook', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Open Data.ipynb\n\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Data.ipynb');\n    await page.notebook.setCell(1, 'code', \"import pandas\\ndf = pandas.read_csv('../data/iris.csv')\\ndf.head(5)\");\n    await page.notebook.setCell(3, 'code', \"import json\\nfrom IPython.display import GeoJSON\\nwith open('../data/Museums_in_DC.geojson') as f:\\ns = GeoJSON(json.load(f), layer_options={'minZoom': 11})\");\n    await page.notebook.run(); // Relax threshold as displayed map may change a bit (in particular text positioning)\n\n    expect(await page.screenshot()).toMatchSnapshot('notebook_ui.png', {\n      threshold: 0.3\n    });\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Terminals","suites":[],"updatePoint":{"line":272,"column":17,"index":10417},"line":272,"code":"  test('Terminals', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Open Data.ipynb\n\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Data.ipynb'); // Open a terminal\n\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=New');\n    await page.click('#jp-mainmenu-file-new >> text=Terminal');\n    await page.waitForSelector('.jp-Terminal');\n    await page.keyboard.type('cd $JUPYTERLAB_GALATA_ROOT_DIR');\n    await page.keyboard.press('Enter');\n    await page.keyboard.type('tree . -L 2');\n    await page.keyboard.press('Enter'); // Wait for command answer\n\n    await page.waitForTimeout(200);\n    expect(await page.screenshot()).toMatchSnapshot('terminal_layout.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Kernels and Terminals","suites":[],"updatePoint":{"line":298,"column":29,"index":11374},"line":298,"code":"  test('Kernels and Terminals', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Open a terminal\n\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=New');\n    await page.click('#jp-mainmenu-file-new >> text=Terminal');\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Data.ipynb');\n    await page.dblclick('text=Julia.ipynb');\n    await page.click('[title=\"Running Terminals and Kernels\"]'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 27px; left: 0px; width: 283px; height: 400px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('running_layout.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Command Palette","suites":[],"updatePoint":{"line":321,"column":23,"index":12326},"line":321,"code":"  test('Command Palette', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.keyboard.press('Control+Shift+C');\n    expect(await (await page.$('#modal-command-palette')).screenshot()).toMatchSnapshot('command_palette.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open With","suites":[],"updatePoint":{"line":328,"column":17,"index":12565},"line":328,"code":"  test('Open With', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await page.click('text=README.md', {\n      button: 'right'\n    });\n    await page.click('text=Open With');\n    await page.hover('text=Markdown Preview'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 0px; left: 0px; width: 700px; height: 500px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('file_formats_open_with.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"HTML Display","suites":[],"updatePoint":{"line":348,"column":20,"index":13271},"line":348,"code":"  test('HTML Display', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    await page.notebook.createNew();\n    await page.notebook.setCell(0, 'code', \"from IPython.display import display, HTML\\ndisplay(HTML('<h1>Hello World</h1>'))\");\n    await page.notebook.run();\n    await page.click('text=File');\n    await page.click('ul[role=\"menu\"] >> text=New Console for Notebook');\n    await page.click('.jp-CodeConsole-input >> pre[role=\"presentation\"]');\n    await page.keyboard.type(\"from IPython.display import display, HTML\\ndisplay(HTML('<h1>Hello World</h1>'))\");\n    await page.keyboard.press('Shift+Enter');\n    expect(await page.screenshot()).toMatchSnapshot('file_formats_html_display.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Altair","suites":[],"updatePoint":{"line":370,"column":14,"index":14190},"line":370,"code":"  test('Altair', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    await page.notebook.createNew();\n    await page.notebook.setCell(0, 'code', \"import altair as alt\\n# load a simple dataset as a pandas DataFrame\\nfrom vega_datasets import data\\ncars = data.cars()\\n\\nalt.Chart(cars).mark_point().encode(x='Horsepower', y='Miles_per_Gallon', color='Origin').interactive()\");\n    await page.notebook.run(); // Need to wait for altair to update the canvas\n\n    await page.waitForSelector('summary');\n    expect(await page.screenshot()).toMatchSnapshot('file_formats_altair.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"VDOM","suites":[],"updatePoint":{"line":389,"column":12,"index":14995},"line":389,"code":"  test('VDOM', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Hide file browser\n\n    await page.click('[title^=\"File Browser\"]');\n    await page.notebook.createNew();\n    await page.notebook.setCell(0, 'code', \"from IPython.display import display\\nfrom vdom.helpers import h1, p, img, div, b\\n\\ndisplay(\\ndiv(\\nh1('Our Incredibly Declarative Example'),\\np('Can you believe we wrote this ', b('in Python'), '?'),\\nimg(src='https://turnoff.us/image/en/death-and-the-programmer.png', style={'height': '268px'}),\\np('What will ', b('you'), ' create next?')))\");\n    await page.notebook.run();\n    expect(await page.screenshot()).toMatchSnapshot('file_formats_nteract_vdom.png');\n  });","file":"documentation/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Menu","suites":[],"updatePoint":{"line":13,"column":12,"index":341},"line":13,"code":"  test('Menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.click('text=Settings');\n    await page.click('ul[role=\"menu\"] >> text=Language'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 5px; left: 250px; width: 800px; height: 600px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('language_settings.png');\n  });","file":"documentation/internationalization.test.ts","skipped":false,"dir":"galata/test"},{"name":"Confirm language","suites":[],"updatePoint":{"line":25,"column":24,"index":869},"line":25,"code":"  test('Confirm language', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.click('text=Settings');\n    await page.click('ul[role=\"menu\"] >> text=Language');\n    await page.click('#jp-mainmenu-settings-language >> text=Chinese'); // Inject capture zone\n\n    await page.evaluate(() => {\n      document.body.insertAdjacentHTML('beforeend', '<div id=\"capture-screenshot\" style=\"position: absolute; top: 200px; left: 350px; width: 600px; height: 300px;\"></div>');\n    });\n    expect(await (await page.$('#capture-screenshot')).screenshot()).toMatchSnapshot('language_change.png');\n  });","file":"documentation/internationalization.test.ts","skipped":false,"dir":"galata/test"},{"name":"UI in Chinese","suites":[],"updatePoint":{"line":38,"column":21,"index":1466},"line":38,"code":"  test('UI in Chinese', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.click('text=Settings');\n    await page.click('ul[role=\"menu\"] >> text=Language');\n    await page.click('#jp-mainmenu-settings-language >> text=Chinese');\n    await Promise.all([page.waitForNavigation(), page.waitForSelector('#jupyterlab-splash'), page.click('button:has-text(\"Change and reload\")')]);\n    await page.waitForSelector('#jupyterlab-splash', {\n      state: 'detached'\n    });\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    }); // Wait for the launcher to be loaded\n\n    await page.waitForSelector('text=README.md');\n    expect(await page.screenshot()).toMatchSnapshot('language_chinese.png');\n  });","file":"documentation/internationalization.test.ts","skipped":false,"dir":"galata/test"},{"name":"Upload directory to server","suites":[],"updatePoint":{"line":8,"column":34,"index":337},"line":8,"code":"  test('Upload directory to server', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadDirectory(path.resolve(__dirname, './upload'), tmpPath); // Upload removed existing tmpPath, so we need to get inside\n\n    await page.dblclick(`text=${tmpPath}`);\n    expect(await page.waitForSelector('text=sub_folder')).toBeTruthy();\n    expect(await page.waitForSelector('text=upload_image.png')).toBeTruthy();\n    expect(await page.waitForSelector('text=upload_notebook.ipynb')).toBeTruthy();\n  });","file":"galata/contents.spec.ts","skipped":false,"dir":"galata/test"},{"name":"File operations","suites":[],"updatePoint":{"line":19,"column":23,"index":836},"line":19,"code":"  test('File operations', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadFile(path.resolve(__dirname, './upload/upload_image.png'), `${tmpPath}/upload_image.png`);\n    await page.contents.renameFile(`${tmpPath}/upload_image.png`, `${tmpPath}/renamed_image.png`);\n    expect(await page.contents.fileExists(`${tmpPath}/renamed_image.png`)).toEqual(true);\n    await page.filebrowser.openDirectory(tmpPath);\n    expect(await page.filebrowser.getCurrentDirectory()).toEqual(tmpPath);\n    expect(await page.contents.deleteFile(`${tmpPath}/renamed_image.png`)).toEqual(true);\n  });","file":"galata/contents.spec.ts","skipped":false,"dir":"galata/test"},{"name":"Go to home directory","suites":[],"updatePoint":{"line":30,"column":28,"index":1440},"line":30,"code":"  test('Go to home directory', async ({\n    page\n  }) => {\n    expect(await page.filebrowser.openHomeDirectory()).toEqual(true);\n  });","file":"galata/contents.spec.ts","skipped":false,"dir":"galata/test"},{"name":"File Explorer visibility","suites":[],"updatePoint":{"line":35,"column":32,"index":1579},"line":35,"code":"  test('File Explorer visibility', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadDirectory(path.resolve(__dirname, './upload'), tmpPath);\n    await page.contents.deleteFile(`${tmpPath}/upload_image.png`);\n    expect(await page.filebrowser.isFileListedInBrowser('upload_image.png')).toEqual(false);\n    await page.filebrowser.revealFileInBrowser(`${tmpPath}/sub_folder/upload_image.png`);\n    expect(await page.filebrowser.isFileListedInBrowser('upload_image.png')).toEqual(true);\n  });","file":"galata/contents.spec.ts","skipped":false,"dir":"galata/test"},{"name":"Delete uploads","suites":[],"updatePoint":{"line":45,"column":22,"index":2080},"line":45,"code":"  test('Delete uploads', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadFile(path.resolve(__dirname, './upload/upload_notebook.ipynb'), `${tmpPath}/sub_dir/notebook.ipynb`);\n    expect(await page.contents.deleteFile(`${tmpPath}/sub_dir/notebook.ipynb`)).toEqual(true);\n    expect(await page.contents.deleteDirectory(`${tmpPath}/sub_dir`)).toEqual(true);\n  });","file":"galata/contents.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should have non-default appPath","suites":[],"updatePoint":{"line":11,"column":39,"index":377},"line":11,"code":"  test('should have non-default appPath', async ({\n    page\n  }) => {\n    expect(page.appPath).toEqual(APP_PATH);\n  });","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should goto the application page and load hook","suites":[],"updatePoint":{"line":17,"column":52,"index":514},"line":17,"code":"test('should goto the application page and load hook', async ({\n  page\n}) => {\n  expect(await page.evaluate(() => typeof window.galataip === 'object')).toEqual(true);\n});","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should test if the application is in simple mode","suites":[],"updatePoint":{"line":22,"column":54,"index":687},"line":22,"code":"test('should test if the application is in simple mode', async ({\n  page\n}) => {\n  expect(await page.isInSimpleMode()).toEqual(false);\n});","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should reload the application page and load hook","suites":[],"updatePoint":{"line":27,"column":54,"index":826},"line":27,"code":"test('should reload the application page and load hook', async ({\n  page\n}) => {\n  await page.reload();\n  expect(await page.evaluate(() => typeof window.galataip === 'object')).toEqual(true);\n});","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should reset the UI","suites":[],"updatePoint":{"line":33,"column":25,"index":993},"line":33,"code":"test('should reset the UI', async ({\n  page\n}) => {\n  await page.resetUI();\n  expect(await page.menu.isAnyOpen()).toEqual(false);\n  expect(await page.waitForSelector(page.launcherSelector)).toBeTruthy();\n  expect(await page.kernel.isAnyRunning()).toEqual(false);\n  expect(await page.statusbar.isVisible()).toEqual(true);\n  expect(await page.sidebar.isTabOpen('filebrowser')).toEqual(true);\n});","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should toggle simple mode","suites":[],"updatePoint":{"line":43,"column":31,"index":1393},"line":43,"code":"test('should toggle simple mode', async ({\n  page\n}) => {\n  expect(await page.setSimpleMode(true)).toEqual(true);\n  expect(await page.isInSimpleMode()).toEqual(true);\n}); // test that stock playwright test is accessible with page not being JupyterLabPage","file":"galata/jupyterlabpage.spec.ts","skipped":false,"dir":"galata/test"},{"name":"should display the launcher","suites":[],"updatePoint":{"line":6,"column":33,"index":262},"line":6,"code":"test('should display the launcher', async ({\n  page\n}) => {\n  expect(await page.waitForSelector(page.launcherSelector)).toBeTruthy();\n});","file":"galata/test.spec.ts","skipped":false,"dir":"galata/test"},{"name":"Show Collapser Unselected; showHCB","suites":[],"updatePoint":{"line":22,"column":42,"index":821},"line":22,"code":"  test('Show Collapser Unselected; showHCB', async ({\n    page\n  }) => {\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('showHCB_heading_unselected.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Show Collapser Selected; showHCB","suites":[],"updatePoint":{"line":27,"column":40,"index":1013},"line":27,"code":"  test('Show Collapser Selected; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('showHCB_heading_selected.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Collapse Heading; showHCB","suites":[],"updatePoint":{"line":33,"column":33,"index":1236},"line":33,"code":"  test('Collapse Heading; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('showHCB_collapse_heading.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Expand Heading via Collapser Button; showHCB","suites":[],"updatePoint":{"line":40,"column":52,"index":1561},"line":40,"code":"  test('Expand Heading via Collapser Button; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('showHCB_expand_heading_via_collapser.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Show Collapser Unselected; no_showHCB","suites":[],"updatePoint":{"line":66,"column":45,"index":2421},"line":66,"code":"  test('Show Collapser Unselected; no_showHCB', async ({\n    page\n  }) => {\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('no_showHCB_heading_unselected.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Show Collapser Selected; no_showHCB","suites":[],"updatePoint":{"line":71,"column":43,"index":2619},"line":71,"code":"  test('Show Collapser Selected; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('no_showHCB_heading_selected.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Collapse Heading; no_showHCB","suites":[],"updatePoint":{"line":77,"column":36,"index":2848},"line":77,"code":"  test('Collapse Heading; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('no_showHCB_collapse_heading.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Expand Heading via Collapser Button; no_showHCB","suites":[],"updatePoint":{"line":84,"column":55,"index":3179},"line":84,"code":"  test('Expand Heading via Collapser Button; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    await page.click('text=xxxxxxxxxx # Heading 1Heading 1Â¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('no_showHCB_expand_heading_via_collapser.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Jump to Previous Header","suites":[],"updatePoint":{"line":113,"column":31,"index":4258},"line":113,"code":"  test('Jump to Previous Header', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('jump_previous_header.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Collapse Previous Header","suites":[],"updatePoint":{"line":120,"column":32,"index":4530},"line":120,"code":"  test('Collapse Previous Header', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('collapse_previous_header.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Collapse Previous Headers","suites":[],"updatePoint":{"line":128,"column":33,"index":4851},"line":128,"code":"  test('Collapse Previous Headers', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('collapse_previous_headers.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"ReExpand Headers 01","suites":[],"updatePoint":{"line":138,"column":27,"index":5255},"line":138,"code":"  test('ReExpand Headers 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('a');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_01.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"ReExpand Headers 02","suites":[],"updatePoint":{"line":153,"column":27,"index":5868},"line":153,"code":"  test('ReExpand Headers 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('ArrowRight');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_02.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"ReExpand Headers 03","suites":[],"updatePoint":{"line":165,"column":27,"index":6355},"line":165,"code":"  test('ReExpand Headers 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowUp');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_03a.png');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_03b.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Below 01","suites":[],"updatePoint":{"line":182,"column":27,"index":7138},"line":182,"code":"  test('Add Header Below 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 3');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(2);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_01.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Below 02","suites":[],"updatePoint":{"line":197,"column":27,"index":7734},"line":197,"code":"  test('Add Header Below 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 3');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_02.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Below 03","suites":[],"updatePoint":{"line":212,"column":27,"index":8339},"line":212,"code":"  test('Add Header Below 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowUp');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 1.2');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(2);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_03.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Above 01","suites":[],"updatePoint":{"line":229,"column":27,"index":9025},"line":229,"code":"  test('Add Header Above 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_01.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Above 02","suites":[],"updatePoint":{"line":239,"column":27,"index":9406},"line":239,"code":"  test('Add Header Above 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(4);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_02.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add Header Above 03","suites":[],"updatePoint":{"line":249,"column":27,"index":9787},"line":249,"code":"  test('Add Header Above 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(3);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_03.png');\n  });","file":"jupyterlab/collapsible-headings.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open completer on notebook","suites":[],"updatePoint":{"line":14,"column":36,"index":483},"line":14,"code":"    test('Open completer on notebook', async ({\n      page\n    }) => {\n      await page.notebook.setCell(0, 'code', 'option_1 = 1\\n' + 'option_2 = lambda x: x\\n' + 'option_3 = int');\n      await page.notebook.runCell(0, true);\n      await page.notebook.addCell('code', 'option');\n      await page.notebook.enterCellEditingMode(1); // we need to wait until the completer gets bound to the cell after entering it\n\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      const imageName = 'completer.png'; // TODO: on first trigger types are not properly displayed, reference image will need updating\n\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/completer.test.ts","skipped":false,"dir":"galata/test"},{"name":"Filter notebook completer suggestions by typing","suites":[],"updatePoint":{"line":36,"column":57,"index":1547},"line":36,"code":"    test('Filter notebook completer suggestions by typing', async ({\n      page\n    }) => {\n      // test against https://github.com/jupyterlab/jupyterlab/issues/11377\n      // `getopt` did not change much in many years, it should be stable\n      await page.notebook.setCell(0, 'code', 'import getopt');\n      await page.notebook.runCell(0, true);\n      await page.notebook.addCell('code', 'getopt.');\n      await page.notebook.enterCellEditingMode(1); // we need to wait until the completer gets bound to the cell after entering it\n\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.type('g', {\n        delay: 50\n      });\n      const imageName = 'completer-filter.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/completer.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open completer on console","suites":[],"updatePoint":{"line":76,"column":35,"index":3213},"line":76,"code":"    test('Open completer on console', async ({\n      page\n    }) => {\n      const completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      const imageName = 'completer-console.png'; // TODO: on first trigger types are not properly displayed, reference image will need updating\n\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/completer.test.ts","skipped":false,"dir":"galata/test"},{"name":"Filter console completer suggestions by typing","suites":[],"updatePoint":{"line":85,"column":56,"index":3619},"line":85,"code":"    test('Filter console completer suggestions by typing', async ({\n      page\n    }) => {\n      const completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.type('g', {\n        delay: 10\n      });\n      const imageName = 'completer-console-filter.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/completer.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open file browser context menu on folder","suites":[],"updatePoint":{"line":45,"column":48,"index":1448},"line":45,"code":"  test('Open file browser context menu on folder', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.filebrowser.refresh();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFolderName}\")`, {\n      button: 'right'\n    }); // Context menu should be available\n\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = 'folder.png';\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open file browser context menu on file","suites":[],"updatePoint":{"line":60,"column":46,"index":2034},"line":60,"code":"  test('Open file browser context menu on file', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFileName}\")`, {\n      button: 'right'\n    }); // Context menu should be available\n\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = 'file.png';\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open file browser context submenu open with","suites":[],"updatePoint":{"line":74,"column":51,"index":2583},"line":74,"code":"  test('Open file browser context submenu open with', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFileName}\")`, {\n      button: 'right'\n    }); // Context menu should be available\n\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    await page.hover('text=Open With');\n    await page.waitForSelector('li[role=\"menuitem\"]:has-text(\"Editor\")');\n    const imageName = `file-openwith.png`; // Get the last menu -> will be submenu\n\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open tab context menu","suites":[],"updatePoint":{"line":91,"column":29,"index":3274},"line":91,"code":"  test('Open tab context menu', async ({\n    page\n  }) => {\n    await page.click('div[role=\"main\"] >> text=Launcher', {\n      button: 'right'\n    }); // Context menu should be available\n\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = `tab-launcher.png`;\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open notebook tab context menu","suites":[],"updatePoint":{"line":115,"column":40,"index":3979},"line":115,"code":"    test('Open notebook tab context menu', async ({\n      page\n    }) => {\n      await page.click('div[role=\"main\"] >> text=simple_notebook.ipynb', {\n        button: 'right'\n      }); // Context menu should be available\n\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `tab-notebook.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open context on markdown cell","suites":[],"updatePoint":{"line":127,"column":39,"index":4421},"line":127,"code":"    test('Open context on markdown cell', async ({\n      page\n    }) => {\n      await page.click('text=Test NotebookÂ¶', {\n        button: 'right'\n      });\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `notebook-md.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open context on code cell","suites":[],"updatePoint":{"line":138,"column":35,"index":4794},"line":138,"code":"    test('Open context on code cell', async ({\n      page\n    }) => {\n      await page.click('text=from IPython.display import Image', {\n        button: 'right'\n      });\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `notebook-code.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open file editor context menu","suites":[],"updatePoint":{"line":150,"column":37,"index":5196},"line":150,"code":"  test('Open file editor context menu', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.dblclick(`span:has-text(\"${testFileName}\")`);\n    await page.click('text=# Title', {\n      button: 'right'\n    });\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = `fileeditor.png`;\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/contextmenu.test.ts","skipped":false,"dir":"galata/test"},{"name":"Move Debugger to right","suites":[],"updatePoint":{"line":20,"column":30,"index":702},"line":20,"code":"  test('Move Debugger to right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('jp-debugger-sidebar');\n    expect(await page.sidebar.getTabPosition('jp-debugger-sidebar')).toBe('right');\n  });","file":"jupyterlab/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open Debugger on right","suites":[],"updatePoint":{"line":26,"column":30,"index":915},"line":26,"code":"  test('Open Debugger on right', async ({\n    page\n  }) => {\n    await page.sidebar.openTab('jp-debugger-sidebar');\n    expect(await page.sidebar.isTabOpen('jp-debugger-sidebar')).toBeTruthy();\n  });","file":"jupyterlab/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Start debug session","suites":[],"updatePoint":{"line":32,"column":27,"index":1112},"line":32,"code":"  test('Start debug session', async ({\n    page,\n    tmpPath\n  }) => {\n    await openNotebook(page, tmpPath, 'code_notebook.ipynb');\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await page.notebook.waitForCellGutter(0);\n    await page.notebook.clickCellGutter(0, 2);\n    await page.debugger.waitForBreakPoints();\n    const breakpointsPanel = await page.debugger.getBreakPointsPanel();\n    expect(await breakpointsPanel.innerText()).toMatch(/ipykernel/);\n    const callStackPanel = await page.debugger.getCallStackPanel();\n    expect(await callStackPanel.innerText()).toBe(''); // don't add await, run will be blocked by the breakpoint\n\n    page.notebook.run().then();\n    await page.debugger.waitForCallStack();\n    expect(await callStackPanel.innerText()).toMatch(/ipykernel/);\n    await page.debugger.waitForVariables();\n    const variablesPanel = await page.debugger.getVariablesPanel();\n    expect(await variablesPanel.screenshot()).toMatchSnapshot('start-debug-session-variables.png');\n    await page.debugger.waitForSources();\n    const sourcesPanel = await page.debugger.getSourcePanel();\n    expect(await sourcesPanel.screenshot()).toMatchSnapshot('start-debug-session-sources.png');\n  });","file":"jupyterlab/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Start debug session (Script)","suites":[],"updatePoint":{"line":57,"column":36,"index":2377},"line":57,"code":"  test('Start debug session (Script)', async ({\n    page,\n    tmpPath\n  }) => {\n    await openNotebook(page, tmpPath, 'code_script.py');\n    await page.click('div.jp-FileEditor', {\n      button: 'right'\n    });\n    const menu = await page.menu.getOpenMenu();\n    await (await menu.$('[data-command=\"fileeditor:create-console\"]')).click();\n    await page.waitForSelector('.jp-Dialog-body');\n    const select = await page.$('.jp-Dialog-body >> select');\n    const option = await select.$('option:has-text(\"ipykernel\")');\n    await select.selectOption(option);\n    await page.click('div.jp-Dialog-content >> button:has-text(\"Select\")'); // activate the script tab\n\n    await page.click('.jp-FileEditor');\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await page.notebook.waitForCodeGutter();\n    await page.notebook.clickCodeGutter(2);\n    await page.debugger.waitForBreakPoints();\n    const breakpointsPanel = await page.debugger.getBreakPointsPanel();\n    expect(await breakpointsPanel.innerText()).toMatch(/ipykernel/);\n    const callStackPanel = await page.debugger.getCallStackPanel();\n    expect(await callStackPanel.innerText()).toBe(''); // don't add await, run will be blocked by the breakpoint\n\n    await page.menu.clickMenuItem('Run>Run All Code');\n    await page.debugger.waitForCallStack();\n    expect(await callStackPanel.innerText()).toMatch(/ipykernel/);\n    await page.debugger.waitForVariables();\n    const variablesPanel = await page.debugger.getVariablesPanel();\n    expect(await variablesPanel.screenshot()).toMatchSnapshot('start-debug-session-script-variables.png');\n    await page.debugger.waitForSources();\n    const sourcesPanel = await page.debugger.getSourcePanel();\n    expect(await sourcesPanel.screenshot()).toMatchSnapshot('start-debug-session-script-sources.png');\n  });","file":"jupyterlab/debugger.test.ts","skipped":false,"dir":"galata/test"},{"name":"Launch Screen","suites":[],"updatePoint":{"line":6,"column":21,"index":250},"line":6,"code":"  test('Launch Screen', async ({\n    page\n  }) => {\n    const imageName = 'launch.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });","file":"jupyterlab/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Enter Simple Mode","suites":[],"updatePoint":{"line":12,"column":25,"index":426},"line":12,"code":"  test('Enter Simple Mode', async ({\n    page\n  }) => {\n    await page.setSimpleMode(true);\n    expect(await page.isInSimpleMode()).toEqual(true);\n    const imageName = 'simple-mode.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Leave Simple Mode","suites":[],"updatePoint":{"line":20,"column":25,"index":684},"line":20,"code":"  test('Leave Simple Mode', async ({\n    page\n  }) => {\n    await page.goto(page.url().replace('/lab', '/doc'));\n    await page.setSimpleMode(false);\n    expect(await page.isInSimpleMode()).toEqual(false);\n  });","file":"jupyterlab/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle Dark theme","suites":[],"updatePoint":{"line":27,"column":25,"index":896},"line":27,"code":"  test('Toggle Dark theme', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    const imageName = 'dark-theme.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });","file":"jupyterlab/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle Light theme","suites":[],"updatePoint":{"line":34,"column":26,"index":1114},"line":34,"code":"  test('Toggle Light theme', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    await page.theme.setLightTheme();\n    expect(await page.theme.getTheme()).toEqual('JupyterLab Light');\n  });","file":"jupyterlab/general.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open menu item ","suites":[],"updatePoint":{"line":11,"column":36,"index":629},"line":11,"code":"    test(`Open menu item ${menuPath}`, async ({\n      page\n    }) => {\n      await page.goto();\n      await page.menu.open(menuPath);\n      expect(await page.menu.isOpen(menuPath)).toBeTruthy();\n      const imageName = `opened-menu-${menuPath.replace(/>/g, '-')}.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n    });","file":"jupyterlab/menus.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open language menu","suites":[],"updatePoint":{"line":22,"column":26,"index":1032},"line":22,"code":"  test('Open language menu', async ({\n    page\n  }) => {\n    await page.route(/.*\\/api\\/translation.*/, (route, request) => {\n      if (request.method() === 'GET') {\n        return route.fulfill({\n          status: 200,\n          body: '{\"data\": {\"en\": {\"displayName\": \"English\", \"nativeName\": \"English\"}}, \"message\": \"\"}'\n        });\n      } else {\n        return route.continue();\n      }\n    });\n    await page.goto();\n    const menuPath = 'Settings>Language';\n    await page.menu.open(menuPath);\n    expect(await page.menu.isOpen(menuPath)).toBeTruthy();\n    const imageName = `opened-menu-settings-language.png`;\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });","file":"jupyterlab/menus.test.ts","skipped":false,"dir":"galata/test"},{"name":"Close all menus","suites":[],"updatePoint":{"line":43,"column":23,"index":1779},"line":43,"code":"  test('Close all menus', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.menu.open('File>New');\n    await page.menu.closeAll();\n    expect(await page.menu.isAnyOpen()).toEqual(false);\n  });","file":"jupyterlab/menus.test.ts","skipped":false,"dir":"galata/test"},{"name":"Create a Raw cell","suites":[],"updatePoint":{"line":20,"column":25,"index":756},"line":20,"code":"  test('Create a Raw cell', async ({\n    page\n  }) => {\n    await page.notebook.setCell(0, 'raw', 'Just a raw cell');\n    expect(await page.notebook.getCellCount()).toBe(1);\n    expect(await page.notebook.getCellType(0)).toBe('raw');\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Create a Markdown cell","suites":[],"updatePoint":{"line":27,"column":30,"index":1001},"line":27,"code":"  test('Create a Markdown cell', async ({\n    page\n  }) => {\n    await page.notebook.addCell('markdown', '## This is **bold** and *italic* [link to jupyter.org!](http://jupyter.org)');\n    await page.notebook.runCell(1, true);\n    expect(await page.notebook.getCellCount()).toBe(2);\n    expect(await page.notebook.getCellType(1)).toBe('markdown');\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Create a Code cell","suites":[],"updatePoint":{"line":35,"column":26,"index":1351},"line":35,"code":"  test('Create a Code cell', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    expect(await page.notebook.getCellCount()).toBe(2);\n    expect(await page.notebook.getCellType(1)).toBe('code');\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Save Notebook","suites":[],"updatePoint":{"line":42,"column":21,"index":1577},"line":42,"code":"  test('Save Notebook', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await expect(page.notebook.save()).resolves.not.toThrow();\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open menu item ","suites":[],"updatePoint":{"line":49,"column":36,"index":1781},"line":49,"code":"    test(`Open menu item ${menuPath}`, async ({\n      page,\n      sessions\n    }) => {\n      // Wait for kernel to be idle as some menu depend of kernel information\n      expect(await page.waitForSelector(`#jp-main-statusbar >> text=Idle`)).toBeTruthy();\n      await page.menu.open(menuPath);\n      expect(await page.menu.isOpen(menuPath)).toBeTruthy();\n      const imageName = `opened-menu-${menuPath.replace(/>/g, '-')}.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n    });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Run cells","suites":[],"updatePoint":{"line":62,"column":17,"index":2334},"line":62,"code":"  test('Run cells', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await page.notebook.run();\n    await page.notebook.save();\n    const imageName = 'run-cells.png';\n    expect((await page.notebook.getCellTextOutput(2))[0]).toBe('8');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle Dark theme","suites":[],"updatePoint":{"line":73,"column":25,"index":2730},"line":73,"code":"  test('Toggle Dark theme', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await page.notebook.run();\n    await page.theme.setDarkTheme();\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    const imageName = 'dark-theme.png';\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-create.test.ts","skipped":false,"dir":"galata/test"},{"name":"Execute Code cell","suites":[],"updatePoint":{"line":19,"column":25,"index":685},"line":19,"code":"  test('Execute Code cell', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    await page.notebook.runCell(1, true);\n    const imageName = 'run-cell.png';\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Re-edit after execution","suites":[],"updatePoint":{"line":28,"column":31,"index":1013},"line":28,"code":"  test('Re-edit after execution', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    await page.notebook.runCell(1, true);\n    await page.notebook.setCell(1, 'code', '2 ** 6');\n    const imageName = 'reedit-cell.png';\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Execute again","suites":[],"updatePoint":{"line":38,"column":21,"index":1388},"line":38,"code":"  test('Execute again', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    await page.notebook.runCell(1, true);\n    await page.notebook.setCell(1, 'code', '2 ** 6');\n    const imageName = 'execute-again.png';\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Copy-Paste cell","suites":[],"updatePoint":{"line":48,"column":23,"index":1767},"line":48,"code":"  test('Copy-Paste cell', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    let imageName = 'copy-paste-cell.png';\n    await page.notebook.selectCells(1);\n    await page.menu.clickMenuItem('Edit>Copy Cells');\n    await page.notebook.selectCells(0);\n    await page.menu.clickMenuItem('Edit>Paste Cells Above');\n    let nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Cut-Paste cell","suites":[],"updatePoint":{"line":60,"column":22,"index":2225},"line":60,"code":"  test('Cut-Paste cell', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'cut-paste-cell.png';\n    await page.notebook.selectCells(0);\n    await page.menu.clickMenuItem('Edit>Cut Cells');\n    await page.notebook.selectCells(2);\n    await page.menu.clickMenuItem('Edit>Paste Cells Below');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Paste-Replace cell","suites":[],"updatePoint":{"line":72,"column":26,"index":2689},"line":72,"code":"  test('Paste-Replace cell', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'paste-replace-cell.png';\n    await page.notebook.selectCells(0);\n    await page.menu.clickMenuItem('Edit>Copy Cells');\n    await page.notebook.selectCells(2);\n    await page.menu.clickMenuItem('Edit>Paste Cells and Replace');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Delete cell","suites":[],"updatePoint":{"line":84,"column":19,"index":3157},"line":84,"code":"  test('Delete cell', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'delete-cell.png';\n    await page.notebook.selectCells(2);\n    await page.menu.clickMenuItem('Edit>Delete Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Select all cells","suites":[],"updatePoint":{"line":94,"column":24,"index":3518},"line":94,"code":"  test('Select all cells', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'select-all-cells.png';\n    await page.notebook.selectCells(2);\n    await page.menu.clickMenuItem('Edit>Select All Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Deselect all cells","suites":[],"updatePoint":{"line":104,"column":26,"index":3890},"line":104,"code":"  test('Deselect all cells', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'deselect-all-cells.png';\n    await page.notebook.selectCells(1, 2);\n    await page.menu.clickMenuItem('Edit>Deselect All Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Move cells up","suites":[],"updatePoint":{"line":114,"column":21,"index":4264},"line":114,"code":"  test('Move cells up', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'move-cell-up.png';\n    await page.notebook.selectCells(1);\n    await page.menu.clickMenuItem('Edit>Move Cells Up');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Move cells down","suites":[],"updatePoint":{"line":124,"column":23,"index":4626},"line":124,"code":"  test('Move cells down', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'move-cell-down.png';\n    await page.notebook.selectCells(0);\n    await page.menu.clickMenuItem('Edit>Move Cells Down');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Split cell","suites":[],"updatePoint":{"line":134,"column":18,"index":4987},"line":134,"code":"  test('Split cell', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    const imageName = 'split-cell.png';\n    await page.notebook.enterCellEditingMode(2);\n    await page.keyboard.press('End');\n    await page.keyboard.press('Enter');\n    await page.keyboard.insertText('3 ** 2');\n    await page.keyboard.press('Home');\n    await page.menu.clickMenuItem('Edit>Split Cell');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Merge split cells","suites":[],"updatePoint":{"line":148,"column":25,"index":5518},"line":148,"code":"  test('Merge split cells', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    await page.notebook.addCell('code', '3 ** 2');\n    const imageName = 'merge-cells.png';\n    await page.notebook.selectCells(1, 2);\n    await page.menu.clickMenuItem('Edit>Merge Selected Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-edit.test.ts","skipped":false,"dir":"galata/test"},{"name":"Highlight LaTeX syntax","suites":[],"updatePoint":{"line":32,"column":30,"index":1320},"line":32,"code":"  test('Highlight LaTeX syntax', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'highlight-latex.png';\n    await page.notebook.enterCellEditingMode(0);\n    const cell = await page.notebook.getCell(0);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-markdown.test.ts","skipped":false,"dir":"galata/test"},{"name":"Do not highlight TeX in code blocks","suites":[],"updatePoint":{"line":42,"column":43,"index":1706},"line":42,"code":"  test('Do not highlight TeX in code blocks', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'do-not-highlight-not-latex.png';\n    await enterEditingModeForScreenshot(page, 1);\n    const cell = await page.notebook.getCell(1);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-markdown.test.ts","skipped":false,"dir":"galata/test"},{"name":"Do not enter math mode for standalone dollar","suites":[],"updatePoint":{"line":52,"column":52,"index":2113},"line":52,"code":"  test('Do not enter math mode for standalone dollar', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'do-not-highlight-standalone-dollar.png';\n    await enterEditingModeForScreenshot(page, 2);\n    const cell = await page.notebook.getCell(2);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-markdown.test.ts","skipped":false,"dir":"galata/test"},{"name":"Execute code cell","suites":[],"updatePoint":{"line":18,"column":25,"index":463},"line":18,"code":"  test('Execute code cell', async ({\n    page\n  }) => {\n    await page.sidebar.close('left');\n    await page.notebook.setCell(0, 'code', 'print(\"hello\")');\n    await page.notebook.addCell('code', '2 * 3');\n    await page.notebook.runCellByCell();\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    const imageName = 'mobile-layout.png';\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-mobile.test.ts","skipped":false,"dir":"galata/test"},{"name":"Insert cells","suites":[],"updatePoint":{"line":20,"column":20,"index":758},"line":20,"code":"  test('Insert cells', async ({\n    page\n  }) => {\n    const imageName = 'insert-cells.png';\n    await page.notebook.selectCells(0);\n    await page.notebook.clickToolbarItem('insert');\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('insert');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Copy-Paste cell","suites":[],"updatePoint":{"line":31,"column":23,"index":1173},"line":31,"code":"  test('Copy-Paste cell', async ({\n    page\n  }) => {\n    const imageName = 'copy-paste-cell.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('copy');\n    await page.notebook.selectCells(0);\n    await page.notebook.clickToolbarItem('paste');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Cut cell","suites":[],"updatePoint":{"line":42,"column":16,"index":1581},"line":42,"code":"  test('Cut cell', async ({\n    page\n  }) => {\n    const imageName = 'cut-cell.png';\n    await page.notebook.selectCells(1);\n    await page.notebook.clickToolbarItem('cut');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Paste cell","suites":[],"updatePoint":{"line":51,"column":18,"index":1892},"line":51,"code":"  test('Paste cell', async ({\n    page\n  }) => {\n    // Cut cell to populate clipboard\n    await page.notebook.selectCells(1);\n    await page.notebook.clickToolbarItem('cut');\n    const imageName = 'paste-cell.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('paste');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Delete cells","suites":[],"updatePoint":{"line":63,"column":20,"index":2336},"line":63,"code":"  test('Delete cells', async ({\n    page\n  }) => {\n    const imageName = 'delete-cell.png';\n    await page.notebook.selectCells(1, 2);\n    await page.menu.clickMenuItem('Edit>Delete Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Run cell","suites":[],"updatePoint":{"line":72,"column":16,"index":2658},"line":72,"code":"  test('Run cell', async ({\n    page\n  }) => {\n    const imageName = 'run-cell.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('run');\n    await page.waitForSelector('text=8'); // await page.notebook.waitForRun();\n\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Change cell type to Markdown","suites":[],"updatePoint":{"line":83,"column":36,"index":3067},"line":83,"code":"  test('Change cell type to Markdown', async ({\n    page\n  }) => {\n    const imageName = 'change-to-markdown.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('cellType');\n    await page.keyboard.press('m');\n    await page.keyboard.press('Enter');\n    await page.notebook.selectCells(2);\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/notebook-toolbar.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open Sidebar tab ","suites":[],"updatePoint":{"line":8,"column":39,"index":442},"line":8,"code":"    test(`Open Sidebar tab ${sidebarId}`, async ({\n      page\n    }) => {\n      await page.sidebar.openTab(sidebarId);\n      expect(await page.sidebar.isTabOpen(sidebarId)).toEqual(true);\n      const imageName = `opened-sidebar-${sidebarId.replace('.', '-')}.png`;\n      const position = await page.sidebar.getTabPosition(sidebarId);\n      const sidebar = await page.sidebar.getContentPanel(position);\n      expect(await sidebar.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n    });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle Light theme","suites":[],"updatePoint":{"line":19,"column":26,"index":928},"line":19,"code":"  test('Toggle Light theme', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    await page.theme.setLightTheme();\n    expect(await page.theme.getTheme()).toEqual('JupyterLab Light');\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Move File Browser to right","suites":[],"updatePoint":{"line":26,"column":34,"index":1143},"line":26,"code":"  test('Move File Browser to right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    expect(await page.sidebar.getTabPosition('filebrowser')).toBe('right');\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open File Browser on right","suites":[],"updatePoint":{"line":32,"column":34,"index":1344},"line":32,"code":"  test('Open File Browser on right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    await page.sidebar.openTab('filebrowser');\n    expect(await page.sidebar.isTabOpen('filebrowser')).toEqual(true);\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open Sidebar on right","suites":[],"updatePoint":{"line":39,"column":29,"index":1582},"line":39,"code":"  test('Open Sidebar on right', async ({\n    page\n  }) => {\n    await page.sidebar.open('right');\n    expect(await page.sidebar.isOpen('right')).toEqual(true);\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Close Sidebar on right","suites":[],"updatePoint":{"line":45,"column":30,"index":1749},"line":45,"code":"  test('Close Sidebar on right', async ({\n    page\n  }) => {\n    await page.sidebar.open('right');\n    await page.menu.clickMenuItem('View>Appearance>Show Right Sidebar');\n    expect(await page.sidebar.isOpen('right')).toEqual(false);\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Capture File Browser on right","suites":[],"updatePoint":{"line":52,"column":37,"index":1997},"line":52,"code":"  test('Capture File Browser on right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    await page.sidebar.openTab('filebrowser');\n    let imageName = 'filebrowser-right.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"Move Debugger to left","suites":[],"updatePoint":{"line":60,"column":29,"index":2273},"line":60,"code":"  test('Move Debugger to left', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToLeft('jp-debugger-sidebar');\n    expect(await page.sidebar.getTabPosition('jp-debugger-sidebar')).toEqual('left');\n  });","file":"jupyterlab/sidebars.test.ts","skipped":false,"dir":"galata/test"},{"name":"should appear in the sidebar","suites":[],"updatePoint":{"line":13,"column":38,"index":444},"line":13,"code":"    test('should appear in the sidebar', async ({\n      page\n    }) => {\n      await page.sidebar.openTab('jp-running-sessions');\n      await expect(page.locator('text=terminals/1')).toBeVisible();\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Light theme terminal inherit","suites":[],"updatePoint":{"line":21,"column":38,"index":689},"line":21,"code":"    test('Light theme terminal inherit', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'inherit');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-inherit.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Light theme terminal light","suites":[],"updatePoint":{"line":29,"column":36,"index":1024},"line":29,"code":"    test('Light theme terminal light', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Light');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'light');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-light.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Light theme terminal dark","suites":[],"updatePoint":{"line":38,"column":35,"index":1424},"line":38,"code":"    test('Light theme terminal dark', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Dark');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'dark');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-dark.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Dark theme terminal inherit","suites":[],"updatePoint":{"line":47,"column":37,"index":1823},"line":47,"code":"    test('Dark theme terminal inherit', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'inherit');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-inherit.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Dark theme terminal light","suites":[],"updatePoint":{"line":56,"column":35,"index":2195},"line":56,"code":"    test('Dark theme terminal light', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Light');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'light');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-light.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Dark theme terminal dark","suites":[],"updatePoint":{"line":66,"column":34,"index":2632},"line":66,"code":"    test('Dark theme terminal dark', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Dark');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'dark');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-dark.png');\n    });","file":"jupyterlab/terminal.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open a text editor","suites":[],"updatePoint":{"line":7,"column":26,"index":296},"line":7,"code":"  test('Open a text editor', async ({\n    page\n  }) => {\n    const imageName = 'text-editor.png';\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n    expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/texteditor.test.ts","skipped":false,"dir":"galata/test"},{"name":"Changing a text editor settings","suites":[],"updatePoint":{"line":16,"column":39,"index":678},"line":16,"code":"  test('Changing a text editor settings', async ({\n    page\n  }) => {\n    const imageName = 'text-editor-rulers.png';\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    await page.menu.clickMenuItem('Settings>Settings Editor');\n    await page.click('text=Text Editor'); // Add two rulers\n\n    await page.click('text=\"Add\"');\n    await page.click('[id=\"jp-SettingsEditor-@jupyterlab/fileeditor-extension:plugin_editorConfig_rulers_0\"]');\n    await page.type('[id=\"jp-SettingsEditor-@jupyterlab/fileeditor-extension:plugin_editorConfig_rulers_0\"]', '50');\n    await page.click('text=\"Add\"');\n    await page.click('[id=\"jp-SettingsEditor-@jupyterlab/fileeditor-extension:plugin_editorConfig_rulers_1\"]');\n    await page.type('[id=\"jp-SettingsEditor-@jupyterlab/fileeditor-extension:plugin_editorConfig_rulers_1\"]', '75');\n    await page.activity.activateTab(DEFAULT_NAME);\n    const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n    expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/texteditor.test.ts","skipped":false,"dir":"galata/test"},{"name":"should display running indicators","suites":[],"updatePoint":{"line":20,"column":41,"index":857},"line":20,"code":"  test('should display running indicators', async ({\n    page\n  }) => {\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const executed = page.notebook.run();\n    await tocPanel.waitForSelector('[data-running=\"1\"]');\n    expect(await tocPanel.screenshot()).toMatchSnapshot('toc-running-indicators.png');\n    await executed;\n  });","file":"jupyterlab/toc-running.test.ts","skipped":false,"dir":"galata/test"},{"name":"should display running indicator on first visible top level","suites":[],"updatePoint":{"line":29,"column":67,"index":1281},"line":29,"code":"  test('should display running indicator on first visible top level', async ({\n    page\n  }) => {\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents')); // Collapse ToC\n\n    await page.click('[aria-label=\"Table of Contents section\"] li >> :nth-match(div, 3)');\n    const executed = page.notebook.runCell(5);\n    await tocPanel.waitForSelector('[data-running=\"1\"]');\n    expect(await tocPanel.screenshot()).toMatchSnapshot('toc-running-indicator-top-level.png');\n    await executed;\n  });","file":"jupyterlab/toc-running.test.ts","skipped":false,"dir":"galata/test"},{"name":"should display running indicator in prompt","suites":[],"updatePoint":{"line":40,"column":50,"index":1810},"line":40,"code":"  test('should display running indicator in prompt', async ({\n    page\n  }) => {\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon');\n    await toolbarButtons[0].click();\n    const executed = page.notebook.runCell(3);\n    await expect(tocPanel.waitForSelector('li:has-text(\"[*]: xxxxxxxxxx sleep(2)\")')).toBeDefined();\n    await executed;\n  });","file":"jupyterlab/toc-running.test.ts","skipped":false,"dir":"galata/test"},{"name":"Add tags","suites":[],"updatePoint":{"line":38,"column":16,"index":1143},"line":38,"code":"  test('Add tags', async ({\n    page\n  }) => {\n    await page.sidebar.openTab('jp-property-inspector');\n    const imageName = 'add-tags.png';\n    const tagInputSelector = 'div.tag-holder input.add-tag';\n    let piPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('jp-property-inspector'));\n    let addTagInput = await piPanel.$(tagInputSelector);\n    await addTagInput.click();\n    await page.keyboard.insertText('tag1');\n    await page.keyboard.press('Enter');\n    addTagInput = await piPanel.$(tagInputSelector);\n    await addTagInput.click();\n    await page.keyboard.insertText('tag2');\n    await page.keyboard.press('Enter');\n    await page.notebook.save();\n    const cellTagsPanel = await piPanel.$('.jp-NotebookTools-tool.jp-TagTool');\n    expect(await cellTagsPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Assign tags to cells","suites":[],"updatePoint":{"line":57,"column":28,"index":2003},"line":57,"code":"  test('Assign tags to cells', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.sidebar.openTab('jp-property-inspector');\n    let piPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('jp-property-inspector'));\n    const tags = await piPanel.$$('.lm-Widget.tag');\n    expect(tags.length).toBe(3); // including Add Tag\n\n    await tags[0].click();\n    await page.notebook.activate(fileName);\n    await page.notebook.selectCells(9);\n    await page.sidebar.openTab('jp-property-inspector');\n    await tags[1].click();\n    await page.notebook.activate(fileName);\n    await page.notebook.selectCells(11);\n    await page.sidebar.openTab('jp-property-inspector');\n    await tags[0].click();\n    await tags[1].click();\n    await page.notebook.activate(fileName);\n    await page.notebook.save();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open Table of Contents panel","suites":[],"updatePoint":{"line":79,"column":36,"index":2862},"line":79,"code":"  test('Open Table of Contents panel', async ({\n    page\n  }) => {\n    const imageName = 'toc-panel.png';\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle code","suites":[],"updatePoint":{"line":88,"column":19,"index":3231},"line":88,"code":"  test('Toggle code', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon');\n    expect(toolbarButtons.length).toBe(4);\n    const imageName = 'toggle-code.png';\n    await toolbarButtons[0].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n    await toolbarButtons[0].click();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle markdown","suites":[],"updatePoint":{"line":101,"column":23,"index":3803},"line":101,"code":"  test('Toggle markdown', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon');\n    expect(toolbarButtons.length).toBe(4);\n    const imageName = 'toggle-markdown.png';\n    await toolbarButtons[1].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n    await toolbarButtons[1].click();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle list","suites":[],"updatePoint":{"line":114,"column":19,"index":4375},"line":114,"code":"  test('Toggle list', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon');\n    expect(toolbarButtons.length).toBe(4);\n    const imageName = 'toggle-numbered-list.png';\n    await toolbarButtons[2].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n    await toolbarButtons[2].click();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle show tags","suites":[],"updatePoint":{"line":127,"column":24,"index":4957},"line":127,"code":"  test('Toggle show tags', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon');\n    expect(toolbarButtons.length).toBe(4); // toggle code and markdown\n\n    await toolbarButtons[0].click();\n    await toolbarButtons[1].click();\n    const imageName = 'show-tags.png';\n    await toolbarButtons[3].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle tag 1","suites":[],"updatePoint":{"line":142,"column":20,"index":5590},"line":142,"code":"  test('Toggle tag 1', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon'); // toggle code and markdown\n\n    await toolbarButtons[0].click();\n    await toolbarButtons[1].click();\n    await toolbarButtons[3].click();\n    const tags = await tocPanel.$$('.toc-tag');\n    expect(tags.length).toBe(2);\n    const imageName = 'toggle-tag-1.png';\n    await tags[0].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n    await tags[0].click();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Toggle tag 2","suites":[],"updatePoint":{"line":160,"column":20,"index":6318},"line":160,"code":"  test('Toggle tag 2', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const toolbarButtons = await tocPanel.$$('.toc-toolbar .toc-toolbar-icon'); // toggle code and markdown\n\n    await toolbarButtons[0].click();\n    await toolbarButtons[1].click();\n    await toolbarButtons[3].click();\n    const tags = await tocPanel.$$('.toc-tag');\n    const imageName = 'toggle-tag-2.png';\n    await tags[1].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n    await tags[1].click();\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"Open context menu","suites":[],"updatePoint":{"line":177,"column":25,"index":7018},"line":177,"code":"  test('Open context menu', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.sidebar.openTab('table-of-contents');\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    await (await tocPanel.$('li > .toc-level-size-1')).click({\n      button: 'right'\n    });\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot('notebook-context-menu.png');\n  });","file":"jupyterlab/toc.test.ts","skipped":false,"dir":"galata/test"},{"name":"should reset the workspace","suites":[],"updatePoint":{"line":39,"column":34,"index":1167},"line":39,"code":"  test('should reset the workspace', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto();\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n    await page.goto('?reset');\n    const launcher = page.locator('div.jp-Launcher-sectionHeader');\n    expect(await launcher.first().screenshot()).toMatchSnapshot('workspace-reset.png');\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should open a file from `tree` url","suites":[],"updatePoint":{"line":49,"column":42,"index":1529},"line":49,"code":"  test('should open a file from `tree` url', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}/${mdFile}`);\n    await expect(page.locator('[role=\"main\"] >> text=Title').first()).toBeVisible();\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should open a file from `tree` url if workspace is not empty","suites":[],"updatePoint":{"line":56,"column":68,"index":1782},"line":56,"code":"  test('should open a file from `tree` url if workspace is not empty', async ({\n    page,\n    tmpPath\n  }) => {\n    await Promise.all([// Wait for the workspace to be saved\n    page.waitForResponse(response => response.request().method() === 'PUT' && /api\\/workspaces/.test(response.request().url()) && response.request().postDataJSON().data[`editor:${tmpPath}/${mdFile}`]), page.goto(`tree/${tmpPath}/${mdFile}`)]);\n    await expect(page.locator('[role=\"main\"] >> text=Title').first()).toBeVisible();\n    await page.goto(`tree/${tmpPath}/${nbFile}`);\n    await expect(page.locator(`[role=\"main\"] >> text=${mdFile}`).first()).toBeVisible();\n    await expect(page.locator('[role=\"main\"] >> text=Test NotebookÂ¶').first()).toBeVisible();\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should reset the workspace in simple mode","suites":[],"updatePoint":{"line":67,"column":49,"index":2504},"line":67,"code":"  test('should reset the workspace in simple mode', async ({\n    baseURL,\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`${baseURL}/doc/tree/${tmpPath}`);\n    await page.sidebar.open('left');\n    await page.dblclick(`text=${nbFile}`);\n    await page.goto('?reset');\n    const launcher = page.locator('div.jp-Launcher-sectionHeader');\n    expect(await launcher.first().screenshot()).toMatchSnapshot('workspace-simple-reset.png');\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should open a file in simple mode from `tree` url","suites":[],"updatePoint":{"line":79,"column":57,"index":2953},"line":79,"code":"  test('should open a file in simple mode from `tree` url', async ({\n    baseURL,\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`${baseURL}/doc/tree/${tmpPath}/${mdFile}`);\n    await expect(page.locator('[role=\"main\"] >> text=Title').first()).toBeVisible();\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should open a new file in simple mode from `tree` url","suites":[],"updatePoint":{"line":87,"column":61,"index":3227},"line":87,"code":"  test('should open a new file in simple mode from `tree` url', async ({\n    baseURL,\n    page,\n    tmpPath\n  }) => {\n    await Promise.all([// Wait for the workspace to be saved\n    page.waitForResponse(response => response.request().method() === 'PUT' && /api\\/workspaces/.test(response.request().url()) && response.request().postDataJSON().data[`editor:${tmpPath}/${mdFile}`]), page.goto(`${baseURL}/doc/tree/${tmpPath}/${mdFile}`)]);\n    await expect(page.locator('[role=\"main\"] >> text=Title').first()).toBeVisible();\n    await page.goto(`${baseURL}/doc/tree/${tmpPath}/${nbFile}`);\n    await expect(page.locator('[role=\"main\"] >> text=Test NotebookÂ¶').first()).toBeVisible(); // Wait for the kernel to be ready so it does not unfocus the menu\n\n    await page.waitForSelector('text= | Idle');\n    await expect(page.menu.getMenuItem(`Tabs>${mdFile}`)).toBeDefined();\n  });","file":"jupyterlab/workspace.test.ts","skipped":false,"dir":"galata/test"},{"name":"should construct a new layout restorer","suites":["apputils","LayoutRestorer","#constructor()"],"updatePoint":{"line":14,"column":48},"line":14,"code":"      it('should construct a new layout restorer', () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve<void>(void 0),\n          registry: new CommandRegistry()\n        });\n        expect(restorer).toBeInstanceOf(LayoutRestorer);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a promise available right away","suites":["apputils","LayoutRestorer","#restored"],"updatePoint":{"line":25,"column":50},"line":25,"code":"      it('should be a promise available right away', () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve<void>(void 0),\n          registry: new CommandRegistry()\n        });\n        expect(restorer.restored).toBeInstanceOf(Promise);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should resolve when restorer is done","suites":["apputils","LayoutRestorer","#restored"],"updatePoint":{"line":34,"column":46},"line":34,"code":"      it('should resolve when restorer is done', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const promise = restorer.restored;\n        ready.resolve(void 0);\n        await expect(promise).resolves.not.toThrow();\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget in the main area to be tracked by the restorer","suites":["apputils","LayoutRestorer","#add()"],"updatePoint":{"line":48,"column":76},"line":48,"code":"      it('should add a widget in the main area to be tracked by the restorer', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: null },\n          leftArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout.mainArea?.currentWidget).toBe(currentWidget);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget in the down area to be tracked by the restorer","suites":["apputils","LayoutRestorer","#add()"],"updatePoint":{"line":82,"column":76},"line":82,"code":"      it('should add a widget in the down area to be tracked by the restorer', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget, widgets: null, size: null },\n          leftArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout.downArea?.currentWidget).toBe(currentWidget);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should always return a value","suites":["apputils","LayoutRestorer","#fetch()"],"updatePoint":{"line":118,"column":38},"line":118,"code":"      it('should always return a value', async () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve(void 0),\n          registry: new CommandRegistry()\n        });\n        const layout = await restorer.fetch();\n        expect(layout).not.toBe(null);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should fetch saved data","suites":["apputils","LayoutRestorer","#fetch()"],"updatePoint":{"line":128,"column":33},"line":128,"code":"      it('should fetch saved data', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        // The `fresh` attribute is only here to check against the return value.\n        const dehydrated: ILabShell.ILayout = {\n          fresh: false,\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: 0 },\n          leftArea: {\n            currentWidget,\n            collapsed: true,\n            widgets: [currentWidget],\n            visible: true\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout).toEqual(dehydrated);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should restore the widgets in a tracker","suites":["apputils","LayoutRestorer","#restore()"],"updatePoint":{"line":166,"column":49},"line":166,"code":"      it('should restore the widgets in a tracker', async () => {\n        const tracker = new WidgetTracker({ namespace: 'foo-widget' });\n        const registry = new CommandRegistry();\n        const state = new StateDB();\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: state,\n          first: ready.promise,\n          registry\n        });\n        let called = false;\n        const key = `${tracker.namespace}:${tracker.namespace}`;\n\n        registry.addCommand(tracker.namespace, {\n          execute: () => {\n            called = true;\n          }\n        });\n        await state.save(key, { data: null });\n        ready.resolve(undefined);\n        await restorer.restore(tracker, {\n          name: () => tracker.namespace,\n          command: tracker.namespace\n        });\n        await restorer.restored;\n        expect(called).toBe(true);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should not run before `first` promise","suites":["apputils","LayoutRestorer","#save()"],"updatePoint":{"line":196,"column":47},"line":196,"code":"      it('should not run before `first` promise', async () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: new Promise(() => {\n            // no op\n          }),\n          registry: new CommandRegistry()\n        });\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: null },\n          leftArea: {\n            currentWidget: null,\n            collapsed: true,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n\n        await expect(restorer.save(dehydrated)).rejects.toBe(\n          'save() was called prematurely.'\n        );\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should save data","suites":["apputils","LayoutRestorer","#save()"],"updatePoint":{"line":228,"column":26},"line":228,"code":"      it('should save data', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        // The `fresh` attribute is only here to check against the return value.\n        const dehydrated: ILabShell.ILayout = {\n          fresh: false,\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: 0 },\n          leftArea: {\n            currentWidget,\n            collapsed: true,\n            widgets: [currentWidget],\n            visible: true\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout).toEqual(dehydrated);\n      });","file":"layoutrestorer.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should construct a new router","suites":["apputils","Router","#constructor()"],"updatePoint":{"line":22,"column":39},"line":22,"code":"      it('should construct a new router', () => {\n        expect(router).toBeInstanceOf(Router);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be the base URL of the application","suites":["apputils","Router","#base"],"updatePoint":{"line":28,"column":51},"line":28,"code":"      it('should be the base URL of the application', () => {\n        expect(router.base).toBe(base);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be the command registry used by the router","suites":["apputils","Router","#commands"],"updatePoint":{"line":34,"column":59},"line":34,"code":"      it('should be the command registry used by the router', () => {\n        expect(router.commands).toBe(commands);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should return the current window location as an object","suites":["apputils","Router","#current"],"updatePoint":{"line":40,"column":64},"line":40,"code":"      it('should return the current window location as an object', () => {\n        const path = '/';\n        const request = path;\n        const search = '';\n        const hash = '';\n\n        expect(router.current).toEqual({ hash, path, request, search });\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should emit a signal when a path is routed","suites":["apputils","Router","#routed"],"updatePoint":{"line":51,"column":52},"line":51,"code":"      it('should emit a signal when a path is routed', async () => {\n        let routed = false;\n\n        commands.addCommand('a', {\n          execute: () => {\n            routed = true;\n          }\n        });\n        router.register({ command: 'a', pattern: /.*/, rank: 10 });\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(routed).toBe(true);\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a unique token","suites":["apputils","Router","#stop"],"updatePoint":{"line":72,"column":34},"line":72,"code":"      it('should be a unique token', () => {\n        expect(router.stop).toBeInstanceOf(Token);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should stop routing if returned by a routed command","suites":["apputils","Router","#stop"],"updatePoint":{"line":76,"column":61},"line":76,"code":"      it('should stop routing if returned by a routed command', async () => {\n        const wanted = ['a', 'b'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        commands.addCommand('b', {\n          execute: () => {\n            recorded.push('b');\n          }\n        });\n        commands.addCommand('c', { execute: () => router.stop });\n        commands.addCommand('d', {\n          execute: () => {\n            recorded.push('d');\n          }\n        });\n\n        router.register({ command: 'a', pattern: /.*/, rank: 10 });\n        router.register({ command: 'b', pattern: /.*/, rank: 20 });\n        router.register({ command: 'c', pattern: /.*/, rank: 30 });\n        router.register({ command: 'd', pattern: /.*/, rank: 40 });\n\n        const promise = signalToPromise(router.routed);\n        await router.route();\n        await promise;\n        expect(recorded).toEqual(wanted);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"cannot be tested since changing location is a security risk","suites":["apputils","Router","#navigate()"],"line":110,"code":"      it.skip('cannot be tested since changing location is a security risk', () => {","file":"router.spec.ts","skipped":true,"dir":"packages/application/test"},{"name":"should register a command with a route pattern","suites":["apputils","Router","#register()"],"updatePoint":{"line":117,"column":56},"line":117,"code":"      it('should register a command with a route pattern', async () => {\n        const wanted = ['a'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        router.register({ command: 'a', pattern: /.*/ });\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(recorded).toEqual(wanted);\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should route the location to a command","suites":["apputils","Router","#route()"],"updatePoint":{"line":139,"column":48},"line":139,"code":"      it('should route the location to a command', async () => {\n        const wanted = ['a'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        router.register({ command: 'a', pattern: /#a/, rank: 10 });\n        expect(recorded.length).toBe(0);\n\n        // Change the hash because changing location is a security error.\n        window.location.hash = 'a';\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(recorded).toEqual(wanted);\n          window.location.hash = '';\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });","file":"router.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should create a LabShell instance","suites":["LabShell","#constructor()"],"updatePoint":{"line":38,"column":41},"line":38,"code":"    it('should create a LabShell instance', () => {\n      expect(shell).toBeInstanceOf(LabShell);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should return whether the left area is collapsed","suites":["LabShell","#leftCollapsed"],"updatePoint":{"line":44,"column":56},"line":44,"code":"    it('should return whether the left area is collapsed', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.leftCollapsed).toBe(true);\n      shell.activateById('foo');\n      expect(shell.leftCollapsed).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should return whether the right area is collapsed","suites":["LabShell","#rightCollapsed"],"updatePoint":{"line":55,"column":57},"line":55,"code":"    it('should return whether the right area is collapsed', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.rightCollapsed).toBe(true);\n      shell.activateById('foo');\n      expect(shell.rightCollapsed).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be the current widget in the shell main area","suites":["LabShell","#currentWidget"],"updatePoint":{"line":66,"column":59},"line":66,"code":"    it('should be the current widget in the shell main area', () => {\n      expect(shell.currentWidget).toBe(null);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.currentWidget).toBe(null);\n      simulate(widget.node, 'focus');\n      expect(shell.currentWidget).toBe(widget);\n      widget.parent = null;\n      expect(shell.currentWidget).toBe(null);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should test whether the main area is empty","suites":["LabShell","#isEmpty()"],"updatePoint":{"line":80,"column":50},"line":80,"code":"    it('should test whether the main area is empty', () => {\n      expect(shell.isEmpty('main')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should test whether the top area is empty","suites":["LabShell","#isEmpty()"],"updatePoint":{"line":88,"column":49},"line":88,"code":"    it('should test whether the top area is empty', () => {\n      // top-level menu area is added by default\n      expect(shell.isEmpty('top')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should test whether the menu area is empty","suites":["LabShell","#isEmpty()"],"updatePoint":{"line":93,"column":50},"line":93,"code":"    it('should test whether the menu area is empty', () => {\n      expect(shell.isEmpty('menu')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should test whether the left area is empty","suites":["LabShell","#isEmpty()"],"updatePoint":{"line":101,"column":50},"line":101,"code":"    it('should test whether the left area is empty', () => {\n      expect(shell.isEmpty('left')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should test whether the right area is empty","suites":["LabShell","#isEmpty()"],"updatePoint":{"line":109,"column":51},"line":109,"code":"    it('should test whether the right area is empty', () => {\n      expect(shell.isEmpty('right')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should resolve when the app is restored for the first time","suites":["LabShell","#restored"],"updatePoint":{"line":119,"column":66},"line":119,"code":"    it('should resolve when the app is restored for the first time', async () => {\n      const state = shell.saveLayout();\n      const mode: DockPanel.Mode = 'multiple-document';\n      shell.restoreLayout(mode, state);\n      await expect(shell.restored).resolves.not.toThrow();\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the header","suites":["LabShell","#add(widget, \"header\")"],"updatePoint":{"line":128,"column":41},"line":128,"code":"    it('should add a widget to the header', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'header');\n      expect(shell.isEmpty('header')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"header\")"],"updatePoint":{"line":135,"column":49},"line":135,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'header');\n      expect(shell.isEmpty('header')).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should accept options","suites":["LabShell","#add(widget, \"header\")"],"updatePoint":{"line":141,"column":29},"line":141,"code":"    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'header', { rank: 10 });\n      expect(shell.isEmpty('header')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the menu","suites":["LabShell","#add(widget, \"menu\")"],"updatePoint":{"line":150,"column":39},"line":150,"code":"    it('should add a widget to the menu', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"menu\")"],"updatePoint":{"line":157,"column":49},"line":157,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should accept options","suites":["LabShell","#add(widget, \"menu\")"],"updatePoint":{"line":163,"column":29},"line":163,"code":"    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu', { rank: 10 });\n      expect(shell.isEmpty('menu')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the top area","suites":["LabShell","#add(widget, \"top\")"],"updatePoint":{"line":172,"column":43},"line":172,"code":"    it('should add a widget to the top area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'top');\n      // top-level title and menu area are added by default\n      expect(toArray(shell.widgets('top')).length).toEqual(3);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"top\")"],"updatePoint":{"line":180,"column":49},"line":180,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'top');\n      // top-level title and menu area are added by default\n      expect(toArray(shell.widgets('top')).length).toEqual(2);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should accept options","suites":["LabShell","#add(widget, \"top\")"],"updatePoint":{"line":187,"column":29},"line":187,"code":"    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'top', { rank: 10 });\n      // top-level title and menu area are added by default\n      expect(toArray(shell.widgets('top')).length).toEqual(3);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add widgets according to their ranks","suites":["LabShell","#add(widget, \"top\")"],"updatePoint":{"line":195,"column":51},"line":195,"code":"    it('should add widgets according to their ranks', () => {\n      const foo = new Widget();\n      const bar = new Widget();\n      foo.id = 'foo';\n      bar.id = 'bar';\n      shell.add(foo, 'top', { rank: 10001 });\n      shell.add(bar, 'top', { rank: 10000 });\n      expect(\n        toArray(shell.widgets('top'))\n          .slice(-2)\n          .map(v => v.id)\n      ).toEqual(['bar', 'foo']);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the left area","suites":["LabShell","#add(widget, \"left\")"],"updatePoint":{"line":211,"column":44},"line":211,"code":"    it('should add a widget to the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"left\")"],"updatePoint":{"line":218,"column":49},"line":218,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should accept options","suites":["LabShell","#add(widget, \"left\")"],"updatePoint":{"line":224,"column":29},"line":224,"code":"    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left', { rank: 10 });\n      expect(shell.isEmpty('left')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the right area","suites":["LabShell","#add(widget, \"right\")"],"updatePoint":{"line":233,"column":45},"line":233,"code":"    it('should add a widget to the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"right\")"],"updatePoint":{"line":240,"column":49},"line":240,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should accept options","suites":["LabShell","#add(widget, \"right\")"],"updatePoint":{"line":246,"column":29},"line":246,"code":"    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right', { rank: 10 });\n      expect(shell.isEmpty('right')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should add a widget to the main area","suites":["LabShell","#add(widget, \"main\")"],"updatePoint":{"line":255,"column":44},"line":255,"code":"    it('should add a widget to the main area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget has no id","suites":["LabShell","#add(widget, \"main\")"],"updatePoint":{"line":262,"column":49},"line":262,"code":"    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should activate a widget in the left area","suites":["LabShell","#activateById()"],"updatePoint":{"line":270,"column":49},"line":270,"code":"    it('should activate a widget in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget is not in the left area","suites":["LabShell","#activateById()"],"updatePoint":{"line":279,"column":63},"line":279,"code":"    it('should be a no-op if the widget is not in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should activate a widget in the right area","suites":["LabShell","#activateById()"],"updatePoint":{"line":287,"column":50},"line":287,"code":"    it('should activate a widget in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget is not in the right area","suites":["LabShell","#activateById()"],"updatePoint":{"line":296,"column":64},"line":296,"code":"    it('should be a no-op if the widget is not in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should activate a widget in the main area","suites":["LabShell","#activateById()"],"updatePoint":{"line":304,"column":49},"line":304,"code":"    it('should activate a widget in the main area', async () => {\n      const widget = new ContentWidget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      shell.activateById('foo');\n      await framePromise();\n      expect(widget.activated).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be a no-op if the widget is not in the main area","suites":["LabShell","#activateById()"],"updatePoint":{"line":313,"column":63},"line":313,"code":"    it('should be a no-op if the widget is not in the main area', async () => {\n      const widget = new ContentWidget();\n      widget.id = 'foo';\n      shell.activateById('foo');\n      await framePromise();\n      expect(widget.activated).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should collapse all widgets in the left area","suites":["LabShell","#collapseLeft()"],"updatePoint":{"line":323,"column":52},"line":323,"code":"    it('should collapse all widgets in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n      shell.collapseLeft();\n      expect(widget.isVisible).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should collapse all widgets in the right area","suites":["LabShell","#collapseRight()"],"updatePoint":{"line":335,"column":53},"line":335,"code":"    it('should collapse all widgets in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n      shell.collapseRight();\n      expect(widget.isVisible).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should expand the most recently used widget","suites":["LabShell","#expandLeft()"],"updatePoint":{"line":347,"column":51},"line":347,"code":"    it('should expand the most recently used widget', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'left', { rank: 10 });\n      shell.add(widget2, 'left', { rank: 1 });\n      shell.activateById('foo');\n      shell.collapseLeft();\n      expect(widget.isVisible).toBe(false);\n      shell.expandLeft();\n      expect(widget.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should expand the first widget if none have been activated","suites":["LabShell","#expandLeft()"],"updatePoint":{"line":361,"column":66},"line":361,"code":"    it('should expand the first widget if none have been activated', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'left', { rank: 10 });\n      shell.add(widget2, 'left', { rank: 1 });\n      expect(widget2.isVisible).toBe(false);\n      shell.expandLeft();\n      expect(widget2.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should expand the most recently used widget","suites":["LabShell","#expandRight()"],"updatePoint":{"line":375,"column":51},"line":375,"code":"    it('should expand the most recently used widget', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.add(widget2, 'right', { rank: 1 });\n      shell.activateById('foo');\n      shell.collapseRight();\n      expect(widget.isVisible).toBe(false);\n      shell.expandRight();\n      expect(widget.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should expand the first widget if none have been activated","suites":["LabShell","#expandRight()"],"updatePoint":{"line":389,"column":66},"line":389,"code":"    it('should expand the first widget if none have been activated', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.add(widget2, 'right', { rank: 1 });\n      expect(widget2.isVisible).toBe(false);\n      shell.expandRight();\n      expect(widget2.isVisible).toBe(true);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should close all of the widgets in the main area","suites":["LabShell","#closeAll()"],"updatePoint":{"line":403,"column":56},"line":403,"code":"    it('should close all of the widgets in the main area', () => {\n      const foo = new Widget();\n      foo.id = 'foo';\n      shell.add(foo, 'main');\n      const bar = new Widget();\n      bar.id = 'bar';\n      shell.add(bar, 'main');\n      shell.closeAll();\n      expect(foo.parent).toBe(null);\n      expect(bar.parent).toBe(null);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should save the layout of the shell","suites":["LabShell","#saveLayout"],"updatePoint":{"line":417,"column":43},"line":417,"code":"    it('should save the layout of the shell', () => {\n      const foo = new Widget();\n      foo.id = 'foo';\n      shell.add(foo, 'main');\n      const state = shell.saveLayout();\n      shell.activateById('foo');\n      expect(shell.mode).toBe('multiple-document');\n      expect(state.mainArea?.currentWidget).toBe(null);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should restore the layout of the shell","suites":["LabShell","#restoreLayout"],"updatePoint":{"line":429,"column":46},"line":429,"code":"    it('should restore the layout of the shell', () => {\n      const state = shell.saveLayout();\n      const mode: DockPanel.Mode = 'multiple-document';\n      shell.mode = 'single-document';\n      shell.restoreLayout(mode, state);\n      expect(shell.mode).toBe('multiple-document');\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should list widgets in each area","suites":["LabShell","#widgets"],"updatePoint":{"line":439,"column":40},"line":439,"code":"    it('should list widgets in each area', () => {\n      let widget: Widget;\n\n      widget = new Widget();\n      widget.id = 'header';\n      shell.add(widget, 'header');\n\n      widget = new Widget();\n      widget.id = 'top';\n      shell.add(widget, 'top');\n\n      widget = new Widget();\n      widget.id = 'menu';\n      shell.add(widget, 'menu');\n\n      widget = new Widget();\n      widget.id = 'left';\n      shell.add(widget, 'left');\n\n      widget = new Widget();\n      widget.id = 'right';\n      shell.add(widget, 'right');\n\n      widget = new Widget();\n      widget.id = 'main';\n      shell.add(widget, 'main');\n\n      expect(toArray(shell.widgets('header')).map(v => v.id)).toEqual([\n        'header'\n      ]);\n      expect(\n        toArray(shell.widgets('top'))\n          .slice(-1)\n          .map(v => v.id)\n      ).toEqual(['top']);\n      expect(toArray(shell.widgets('menu')).map(v => v.id)).toEqual(['menu']);\n      expect(toArray(shell.widgets('left')).map(v => v.id)).toEqual(['left']);\n      expect(toArray(shell.widgets('right')).map(v => v.id)).toEqual(['right']);\n      expect(toArray(shell.widgets('main')).map(v => v.id)).toEqual(['main']);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should default to main area","suites":["LabShell","#widgets"],"updatePoint":{"line":480,"column":35},"line":480,"code":"    it('should default to main area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(toArray(shell.widgets()).map(v => v.id)).toEqual(['foo']);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should throw an error when an unrecognized area is given","suites":["LabShell","#widgets"],"updatePoint":{"line":487,"column":64},"line":487,"code":"    it('should throw an error when an unrecognized area is given', () => {\n      expect(() => shell.widgets('foo' as any)).toThrowError(/Invalid area/);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should be hidden in multiple document mode and visible in single document mode","suites":["LabShell","#titlePanel"],"updatePoint":{"line":493,"column":86},"line":493,"code":"    it('should be hidden in multiple document mode and visible in single document mode', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.mode = 'multiple-document';\n      expect(widget.isVisible).toBe(false);\n      shell.mode = 'single-document';\n      expect(widget.isVisible).toBe(false);\n    });","file":"shell.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"%j & default %s has isEnabled %s","suites":["@jupyterlab/application","createSemanticCommand"],"line":32,"code":"    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, false],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, false],\n      [[], true, true]\n    ])('%j & default %s has isEnabled %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isEnabled: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isEnabled: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isEnabled?.call({})).toEqual(expected);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"%j & default %s has isToggled %s","suites":["@jupyterlab/application","createSemanticCommand"],"line":68,"code":"    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, false],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, false],\n      [[], true, true]\n    ])('%j & default %s has isToggled %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isToggled: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isToggled: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isToggled?.call({})).toEqual(expected);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"%j & default %s has isVisible %s","suites":["@jupyterlab/application","createSemanticCommand"],"line":104,"code":"    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, true],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, true],\n      [[], true, true]\n    ])('%j & default %s has isVisible %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isVisible: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isVisible: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isVisible?.call({})).toEqual(expected);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/application/test"},{"name":"should create a command linker","suites":["@jupyterlab/apputils","CommandLinker","#constructor()"],"updatePoint":{"line":12,"column":40},"line":12,"code":"      it('should create a command linker', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker).toBeInstanceOf(CommandLinker);\n        linker.dispose();\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should test whether a command linker has been disposed","suites":["@jupyterlab/apputils","CommandLinker","#isDisposed"],"updatePoint":{"line":20,"column":64},"line":20,"code":"      it('should test whether a command linker has been disposed', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker.isDisposed).toBe(false);\n        linker.dispose();\n        expect(linker.isDisposed).toBe(true);\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should connect a node to a command","suites":["@jupyterlab/apputils","CommandLinker","#connectNode()"],"updatePoint":{"line":29,"column":44},"line":29,"code":"      it('should connect a node to a command', () => {\n        let called = false;\n        const command = 'commandlinker:connect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        const node = document.createElement('div');\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        document.body.appendChild(node);\n        linker.connectNode(node, command, undefined);\n\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should disconnect a node from a command","suites":["@jupyterlab/apputils","CommandLinker","#disconnectNode()"],"updatePoint":{"line":55,"column":49},"line":55,"code":"      it('should disconnect a node from a command', () => {\n        let called = false;\n        const command = 'commandlinker:disconnect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        const node = document.createElement('div');\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        document.body.appendChild(node);\n        linker.connectNode(node, command, undefined);\n\n        // Make sure connection is working.\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        // Reset flag.\n        called = false;\n\n        // Make sure disconnection is working.\n        linker.disconnectNode(node);\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(false);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should dispose the resources held by the linker","suites":["@jupyterlab/apputils","CommandLinker","#dispose()"],"updatePoint":{"line":91,"column":57},"line":91,"code":"      it('should dispose the resources held by the linker', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker.isDisposed).toBe(false);\n        linker.dispose();\n        expect(linker.isDisposed).toBe(true);\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should connect a node to a command","suites":["@jupyterlab/apputils","CommandLinker","#populateVNodeDataset()"],"updatePoint":{"line":100,"column":44},"line":100,"code":"      it('should connect a node to a command', () => {\n        let called = false;\n        const command = 'commandlinker:connect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        let node: HTMLElement;\n        let vnode: VirtualNode;\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        vnode = h.div({\n          dataset: linker.populateVNodeDataset(command, undefined)\n        });\n        node = VirtualDOM.realize(vnode);\n        document.body.appendChild(node);\n\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });","file":"commandlinker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create a new command palette","suites":["@jupyterlab/apputils","ModalCommandPalette","#constructor()"],"updatePoint":{"line":38,"column":45},"line":38,"code":"      it('should create a new command palette', () => {\n        expect(palette).toBeInstanceOf(CommandPalette);\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create a new modal command palette","suites":["@jupyterlab/apputils","ModalCommandPalette","#constructor()"],"updatePoint":{"line":41,"column":51},"line":41,"code":"      it('should create a new modal command palette', () => {\n        expect(modalPalette).toBeInstanceOf(ModalCommandPalette);\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should attach to the document body","suites":["@jupyterlab/apputils","ModalCommandPalette","#constructor()"],"updatePoint":{"line":44,"column":44},"line":44,"code":"      it('should attach to the document body', () => {\n        expect(document.body.contains(modalPalette.node)).toBe(true);\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should start hidden","suites":["@jupyterlab/apputils","ModalCommandPalette","#constructor()"],"updatePoint":{"line":47,"column":29},"line":47,"code":"      it('should start hidden', () => {\n        expect(modalPalette.isHidden).toBe(true);\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should become visible when activated","suites":["@jupyterlab/apputils","ModalCommandPalette","#activate()"],"updatePoint":{"line":53,"column":46},"line":53,"code":"      it('should become visible when activated', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        expect(modalPalette.isVisible).toBe(true);\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should become hidden and clear the input when calling hideAndReset","suites":["@jupyterlab/apputils","ModalCommandPalette","#hideAndReset()"],"updatePoint":{"line":60,"column":76},"line":60,"code":"      it('should become hidden and clear the input when calling hideAndReset', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search stringâ€¦';\n        modalPalette.hideAndReset();\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should hide and reset when focus is shifted","suites":["@jupyterlab/apputils","ModalCommandPalette","#blur()"],"updatePoint":{"line":70,"column":53},"line":70,"code":"      it('should hide and reset when focus is shifted', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search stringâ€¦';\n        simulate(modalPalette.node, 'blur', {\n          relatedTarget: document.body\n        });\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should hide and reset when ESC is pressed","suites":["@jupyterlab/apputils","ModalCommandPalette","#escape()"],"updatePoint":{"line":82,"column":51},"line":82,"code":"      it('should hide and reset when ESC is pressed', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search stringâ€¦';\n        simulate(modalPalette.node, 'keydown', { keyCode: 27 });\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should hide and reset when a command is executed","suites":["@jupyterlab/apputils","ModalCommandPalette","#execute()"],"updatePoint":{"line":92,"column":58},"line":92,"code":"      it('should hide and reset when a command is executed', () => {\n        commands.addCommand('mock-command', {\n          execute: (args: JSONObject) => {\n            return args;\n          }\n        });\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        void commands.execute('mock-command');\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });","file":"commandpalette.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept at least the title argument","suites":["@jupyterlab/apputils","InputDialog","getBoolean()"],"updatePoint":{"line":14,"column":51},"line":14,"code":"      it('should accept at least the title argument', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be false by default","suites":["@jupyterlab/apputils","InputDialog","getBoolean()"],"updatePoint":{"line":23,"column":36},"line":23,"code":"      it('should be false by default', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(false);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept options","suites":["@jupyterlab/apputils","InputDialog","getBoolean()"],"updatePoint":{"line":36,"column":31},"line":36,"code":"      it('should accept options', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not',\n          value: true\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(true);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be editable","suites":["@jupyterlab/apputils","InputDialog","getBoolean()"],"updatePoint":{"line":50,"column":28},"line":50,"code":"      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getBoolean({\n          title: 'Check or not',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.checked = true;\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(true);\n        document.body.removeChild(node);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept at least two arguments","suites":["@jupyterlab/apputils","InputDialog","getItem()"],"updatePoint":{"line":76,"column":46},"line":76,"code":"      it('should accept at least two arguments', async () => {\n        const dialog = InputDialog.getItem({\n          title: 'list',\n          items: ['item1']\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the first item by default","suites":["@jupyterlab/apputils","InputDialog","getItem()"],"updatePoint":{"line":86,"column":45},"line":86,"code":"      it('should be the first item by default', async () => {\n        const dialog = InputDialog.getItem({\n          items: ['item1', 'item2'],\n          title: 'Pick a choice'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item1');\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept options","suites":["@jupyterlab/apputils","InputDialog","getItem()"],"updatePoint":{"line":100,"column":31},"line":100,"code":"      it('should accept options', async () => {\n        const dialog = InputDialog.getItem({\n          label: 'list',\n          items: ['item1', 'item2'],\n          current: 1,\n          editable: false,\n          title: 'Pick a choice',\n          placeholder: 'item'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item2');\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be editable","suites":["@jupyterlab/apputils","InputDialog","getItem()"],"updatePoint":{"line":118,"column":28},"line":118,"code":"      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getItem({\n          label: 'list',\n          items: ['item1', 'item2'],\n          title: 'Pick a choice',\n          placeholder: 'item',\n          editable: true,\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = 'item3';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item3');\n        document.body.removeChild(node);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept at least one argument","suites":["@jupyterlab/apputils","InputDialog","getText()"],"updatePoint":{"line":148,"column":45},"line":148,"code":"      it('should accept at least one argument', async () => {\n        const dialog = InputDialog.getText({\n          title: 'text'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be an empty string by default","suites":["@jupyterlab/apputils","InputDialog","getText()"],"updatePoint":{"line":157,"column":46},"line":157,"code":"      it('should be an empty string by default', async () => {\n        const dialog = InputDialog.getText({\n          title: 'Give a text'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('');\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept options","suites":["@jupyterlab/apputils","InputDialog","getText()"],"updatePoint":{"line":170,"column":31},"line":170,"code":"      it('should accept options', async () => {\n        const dialog = InputDialog.getText({\n          label: 'text',\n          title: 'Give a text',\n          placeholder: 'your text',\n          text: 'answer'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('answer');\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be editable","suites":["@jupyterlab/apputils","InputDialog","getText()"],"updatePoint":{"line":186,"column":28},"line":186,"code":"      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getText({\n          title: 'text',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = 'my answer';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('my answer');\n        document.body.removeChild(node);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept at least one argument","suites":["@jupyterlab/apputils","InputDialog","getNumber()"],"updatePoint":{"line":212,"column":45},"line":212,"code":"      it('should accept at least one argument', async () => {\n        const dialog = InputDialog.getNumber({\n          title: 'number'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be 0 by default","suites":["@jupyterlab/apputils","InputDialog","getNumber()"],"updatePoint":{"line":221,"column":32},"line":221,"code":"      it('should be 0 by default', async () => {\n        const dialog = InputDialog.getNumber({\n          title: 'Pick a number'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(0);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should accept options","suites":["@jupyterlab/apputils","InputDialog","getNumber()"],"updatePoint":{"line":234,"column":31},"line":234,"code":"      it('should accept options', async () => {\n        const dialog = InputDialog.getNumber({\n          label: 'number',\n          title: 'Pick a number',\n          value: 10\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(10);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be editable","suites":["@jupyterlab/apputils","InputDialog","getNumber()"],"updatePoint":{"line":249,"column":28},"line":249,"code":"      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getNumber({\n          label: 'text',\n          title: 'Pick a number',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = '25';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(25);\n        document.body.removeChild(node);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return NaN if empty","suites":["@jupyterlab/apputils","InputDialog","getNumber()"],"updatePoint":{"line":274,"column":36},"line":274,"code":"      it('should return NaN if empty', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getNumber({\n          label: 'text',\n          title: 'Pick a number',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = '';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBeNaN();\n        document.body.removeChild(node);\n      });","file":"inputdialog.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create a new main area widget","suites":["@jupyterlab/apputils","MainAreaWidget","#constructor()"],"updatePoint":{"line":11,"column":46},"line":11,"code":"      it('should create a new main area widget', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        expect(widget).toBeInstanceOf(MainAreaWidget);\n        expect(widget.hasClass('jp-MainAreaWidget')).toBe(true);\n        expect(widget.title.closable).toBe(true);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow toolbar options","suites":["@jupyterlab/apputils","MainAreaWidget","#constructor()"],"updatePoint":{"line":19,"column":38},"line":19,"code":"      it('should allow toolbar options', () => {\n        const content = new Widget();\n        const toolbar = new Toolbar();\n        const widget = new MainAreaWidget({ content, toolbar });\n        expect(widget.hasClass('jp-MainAreaWidget')).toBe(true);\n        expect(widget.toolbar).toBe(toolbar);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should exist and have correct type","suites":["@jupyterlab/apputils","MainAreaWidget","contentHeader"],"updatePoint":{"line":29,"column":44},"line":29,"code":"      it('should exist and have correct type', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        expect(widget.contentHeader).toBeInstanceOf(BoxPanel);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should focus on activation","suites":["@jupyterlab/apputils","MainAreaWidget","#onActivateRequest()"],"updatePoint":{"line":37,"column":36},"line":37,"code":"      it('should focus on activation', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(document.activeElement).toBe(widget.content.node);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should dispose on close","suites":["@jupyterlab/apputils","MainAreaWidget","#onCloseRequest()"],"updatePoint":{"line":47,"column":33},"line":47,"code":"      it('should dispose on close', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.CloseRequest);\n        expect(widget.isDisposed).toBe(true);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should propagate to the content","suites":["@jupyterlab/apputils","MainAreaWidget","#onUpdateRequest()"],"updatePoint":{"line":57,"column":41},"line":57,"code":"      it('should propagate to the content', () => {\n        let updated: boolean;\n        const content = new (class extends Widget {\n          onUpdateRequest() {\n            updated = true;\n          }\n        })();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        updated = false;\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(updated).toBe(true);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should proxy from content to main","suites":["@jupyterlab/apputils","MainAreaWidget","title"],"updatePoint":{"line":73,"column":43},"line":73,"code":"      it('should proxy from content to main', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        content.title.label = 'foo';\n        expect(widget.title.label).toBe('foo');\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should proxy from main to content","suites":["@jupyterlab/apputils","MainAreaWidget","title"],"updatePoint":{"line":80,"column":43},"line":80,"code":"      it('should proxy from main to content', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        widget.title.label = 'foo';\n        expect(content.title.label).toBe('foo');\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should dispose of main","suites":["@jupyterlab/apputils","MainAreaWidget","dispose"],"updatePoint":{"line":89,"column":32},"line":89,"code":"      it('should dispose of main', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        content.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"mainareawidget.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow h1 tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":8,"column":28},"line":8,"code":"    it('should allow h1 tags', () => {\n      const h1 = '<h1>foo</h1>';\n      expect(defaultSanitizer.sanitize(h1)).toBe(h1);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow h2 tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":13,"column":28},"line":13,"code":"    it('should allow h2 tags', () => {\n      const h2 = '<h2>foo</h2>';\n      expect(defaultSanitizer.sanitize(h2)).toBe(h2);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should not allow svg tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":18,"column":33},"line":18,"code":"    it('should not allow svg tags', () => {\n      const svg = '<svg>foo</svg>';\n      expect(defaultSanitizer.sanitize(svg)).toBe('foo');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow img tags and some attributes","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":23,"column":49},"line":23,"code":"    it('should allow img tags and some attributes', () => {\n      const img =\n        '<img src=\"smiley.gif\" alt=\"Smiley face\" height=\"42\" width=\"42\" />';\n      expect(defaultSanitizer.sanitize(img)).toBe(img);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow span tags and class attribute","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":29,"column":50},"line":29,"code":"    it('should allow span tags and class attribute', () => {\n      const span = '<span class=\"foo\">bar</span>';\n      expect(defaultSanitizer.sanitize(span)).toBe(span);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should set the rel attribute for <a> tags to \"nofollow","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":34,"column":62},"line":34,"code":"    it('should set the rel attribute for <a> tags to \"nofollow', () => {\n      const a = '<a rel=\"foo\" href=\"bar\">Baz</a>';\n      const expected = a.replace('foo', 'nofollow');\n      expect(defaultSanitizer.sanitize(a)).toBe(expected);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow the `data-commandlinker-command` attribute for button tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":40,"column":79},"line":40,"code":"    it('should allow the `data-commandlinker-command` attribute for button tags', () => {\n      const button =\n        '<button data-commandlinker-command=\"terminal:create-new\" onClick={some evil code}>Create Terminal</button>';\n      const expectedButton =\n        '<button data-commandlinker-command=\"terminal:create-new\">Create Terminal</button>';\n      expect(defaultSanitizer.sanitize(button)).toBe(expectedButton);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow the class attribute for code tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":48,"column":54},"line":48,"code":"    it('should allow the class attribute for code tags', () => {\n      const code = '<code class=\"foo\">bar</code>';\n      expect(defaultSanitizer.sanitize(code)).toBe(code);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow the class attribute for div tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":53,"column":53},"line":53,"code":"    it('should allow the class attribute for div tags', () => {\n      const div = '<div class=\"foo\">bar</div>';\n      expect(defaultSanitizer.sanitize(div)).toBe(div);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow the class attribute for p tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":58,"column":51},"line":58,"code":"    it('should allow the class attribute for p tags', () => {\n      const p = '<p class=\"foo\">bar</p>';\n      expect(defaultSanitizer.sanitize(p)).toBe(p);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow the class attribute for pre tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":63,"column":53},"line":63,"code":"    it('should allow the class attribute for pre tags', () => {\n      const pre = '<pre class=\"foo\">bar</pre>';\n      expect(defaultSanitizer.sanitize(pre)).toBe(pre);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip script tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":68,"column":32},"line":68,"code":"    it('should strip script tags', () => {\n      const script = '<script>alert(\"foo\")</script>';\n      expect(defaultSanitizer.sanitize(script)).toBe('');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip iframe tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":73,"column":32},"line":73,"code":"    it('should strip iframe tags', () => {\n      const script = '<iframe src=\"\"></iframe>';\n      expect(defaultSanitizer.sanitize(script)).toBe('');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip link tags","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":78,"column":30},"line":78,"code":"    it('should strip link tags', () => {\n      const link = '<link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\">';\n      expect(defaultSanitizer.sanitize(link)).toBe('');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should pass through simple well-formed whitelisted markup","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":83,"column":65},"line":83,"code":"    it('should pass through simple well-formed whitelisted markup', () => {\n      const div = '<div><p>Hello <b>there</b></p></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe(div);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow video tags with some attributes","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":88,"column":52},"line":88,"code":"    it('should allow video tags with some attributes', () => {\n      const video =\n        '<video src=\"my/video.mp4\" height=\"42\" width=\"42\"' +\n        ' autoplay controls loop muted></video>';\n      expect(defaultSanitizer.sanitize(video)).toBe(video);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow audio tags with some attributes","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":95,"column":52},"line":95,"code":"    it('should allow audio tags with some attributes', () => {\n      const audio =\n        '<audio src=\"my/audio.ogg autoplay loop ' + 'controls muted\"></audio>';\n      expect(defaultSanitizer.sanitize(audio)).toBe(audio);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow input tags but disable them","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":101,"column":48},"line":101,"code":"    it('should allow input tags but disable them', () => {\n      const html = defaultSanitizer.sanitize(\n        '<input type=\"checkbox\" checked />'\n      );\n      const div = document.createElement('div');\n      let input: HTMLInputElement;\n\n      div.innerHTML = html;\n      input = div.querySelector('input')!;\n\n      expect(input.disabled).toBe(true);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should allow harmless inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":116,"column":40},"line":116,"code":"    it('should allow harmless inline CSS', () => {\n      const div = '<div style=\"color:green\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe(div);\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip 'content' properties from inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":121,"column":57},"line":121,"code":"    it(\"should strip 'content' properties from inline CSS\", () => {\n      const div = '<div style=\"color: green; content: attr(title)\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe(\n        '<div style=\"color:green\"></div>'\n      );\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip 'counter-increment' properties from inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":128,"column":67},"line":128,"code":"    it(\"should strip 'counter-increment' properties from inline CSS\", () => {\n      const div = '<div style=\"counter-increment: example-counter;\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe('<div></div>');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip 'counter-reset' properties from inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":133,"column":63},"line":133,"code":"    it(\"should strip 'counter-reset' properties from inline CSS\", () => {\n      const div = '<div style=\"counter-reset: chapter-count 0;\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe('<div></div>');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip 'widows' properties from inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":138,"column":56},"line":138,"code":"    it(\"should strip 'widows' properties from inline CSS\", () => {\n      const div = '<div style=\"widows: 2;\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe('<div></div>');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should strip 'orphans' properties from inline CSS","suites":["defaultSanitizer","#sanitize()"],"updatePoint":{"line":143,"column":57},"line":143,"code":"    it(\"should strip 'orphans' properties from inline CSS\", () => {\n      const div = '<div style=\"orphans: 3;\"></div>';\n      expect(defaultSanitizer.sanitize(div)).toBe('<div></div>');\n    });","file":"sanitizer.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add a new command","suites":["@jupyterlab/apputils","SemanticCommand","#add"],"updatePoint":{"line":13,"column":34},"line":13,"code":"      it('should add a new command', () => {\n        const commandId = 'test:command';\n        let test = 2;\n        semanticCmd.add({\n          id: commandId,\n          isEnabled: () => test === 2,\n          rank: 10\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add a command with default rank if not provided","suites":["@jupyterlab/apputils","SemanticCommand","#add"],"updatePoint":{"line":25,"column":64},"line":25,"code":"      it('should add a command with default rank if not provided', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          rank: SemanticCommand.DEFAULT_RANK + 1\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add an enabled command if isEnabled not provided","suites":["@jupyterlab/apputils","SemanticCommand","#add"],"updatePoint":{"line":39,"column":65},"line":39,"code":"      it('should add an enabled command if isEnabled not provided', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          isEnabled: () => false\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should reject adding a command with an already used id","suites":["@jupyterlab/apputils","SemanticCommand","#add"],"updatePoint":{"line":53,"column":64},"line":53,"code":"      it('should reject adding a command with an already used id', () => {\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(() => {\n          semanticCmd.add({ id: commandId });\n        }).toThrowError(/Command\\s.+\\sis already defined\\./);\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return null if no command is defined","suites":["@jupyterlab/apputils","SemanticCommand","#getActiveCommandId"],"updatePoint":{"line":66,"column":53},"line":66,"code":"      it('should return null if no command is defined', () => {\n        expect(semanticCmd.getActiveCommandId(new Widget())).toBeNull();\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return null if no command is enabled","suites":["@jupyterlab/apputils","SemanticCommand","#getActiveCommandId"],"updatePoint":{"line":70,"column":53},"line":70,"code":"      it('should return null if no command is enabled', () => {\n        semanticCmd.add({\n          id: 'test:disabled',\n          isEnabled: () => false\n        });\n        expect(semanticCmd.getActiveCommandId(new Widget())).toBeNull();\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return the enabled command with the smallest rank","suites":["@jupyterlab/apputils","SemanticCommand","#getActiveCommandId"],"updatePoint":{"line":78,"column":66},"line":78,"code":"      it('should return the enabled command with the smallest rank', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          rank: 20\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId,\n          rank: 10\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });","file":"semanticCommand.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create a session context","suites":["@jupyterlab/apputils","SessionContext","#constructor()"],"updatePoint":{"line":79,"column":41},"line":79,"code":"      it('should create a session context', () => {\n        expect(sessionContext).toBeInstanceOf(SessionContext);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when the session context is disposed","suites":["@jupyterlab/apputils","SessionContext","#disposed"],"updatePoint":{"line":85,"column":64},"line":85,"code":"      it('should be emitted when the session context is disposed', async () => {\n        sessionContext.kernelPreference = { canStart: false };\n        await sessionContext.initialize();\n        let called = false;\n        sessionContext.disposed.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        sessionContext.dispose();\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when the kernel changes","suites":["@jupyterlab/apputils","SessionContext","#kernelChanged"],"updatePoint":{"line":100,"column":51},"line":100,"code":"      it('should be emitted when the kernel changes', async () => {\n        let called = false;\n        sessionContext.kernelChanged.connect(\n          (sender, { oldValue, newValue }) => {\n            if (oldValue !== null) {\n              return;\n            }\n            expect(sender).toBe(sessionContext);\n            expect(oldValue).toBeNull();\n            expect(newValue).toBe(sessionContext.session?.kernel || null);\n            called = true;\n          }\n        );\n        await sessionContext.initialize();\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when the session changes","suites":["@jupyterlab/apputils","SessionContext","#sessionChanged"],"updatePoint":{"line":119,"column":52},"line":119,"code":"      it('should be emitted when the session changes', async () => {\n        let called = false;\n        sessionContext.sessionChanged.connect(\n          (sender, { oldValue, newValue }) => {\n            if (oldValue !== null) {\n              return;\n            }\n            expect(sender).toBe(sessionContext);\n            expect(oldValue).toBeNull();\n            expect(newValue).toBe(sessionContext.session);\n            called = true;\n          }\n        );\n        await sessionContext.initialize();\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when the status changes","suites":["@jupyterlab/apputils","SessionContext","#statusChanged"],"updatePoint":{"line":138,"column":51},"line":138,"code":"      it('should be emitted when the status changes', async () => {\n        let called = false;\n        sessionContext.statusChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(typeof args).toBe('string');\n          called = true;\n        });\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted for iopub kernel messages","suites":["@jupyterlab/apputils","SessionContext","#iopubMessage"],"updatePoint":{"line":152,"column":53},"line":152,"code":"      it('should be emitted for iopub kernel messages', async () => {\n        let called = false;\n        sessionContext.iopubMessage.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          called = true;\n        });\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when a session path changes","suites":["@jupyterlab/apputils","SessionContext","#propertyChanged"],"updatePoint":{"line":165,"column":55},"line":165,"code":"      it('should be emitted when a session path changes', async () => {\n        let called = false;\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('path');\n          called = true;\n        });\n        await sessionContext.session!.setPath('foo');\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when a session name changes","suites":["@jupyterlab/apputils","SessionContext","#propertyChanged"],"updatePoint":{"line":177,"column":55},"line":177,"code":"      it('should be emitted when a session name changes', async () => {\n        let called = false;\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('name');\n          called = true;\n        });\n        await sessionContext.session!.setName('foo');\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be emitted when a session type changes","suites":["@jupyterlab/apputils","SessionContext","#propertyChanged"],"updatePoint":{"line":189,"column":55},"line":189,"code":"      it('should be emitted when a session type changes', async () => {\n        let called = false;\n\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('type');\n          called = true;\n        });\n        await sessionContext.session!.setType('foo');\n        expect(called).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the current kernel of the the session","suites":["@jupyterlab/apputils","SessionContext","#kernel"],"updatePoint":{"line":204,"column":57},"line":204,"code":"      it('should be the current kernel of the the session', async () => {\n        expect(sessionContext.session?.kernel).toBeFalsy();\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel).toBeTruthy();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the kernel preference of the session","suites":["@jupyterlab/apputils","SessionContext","#kernelPreference"],"updatePoint":{"line":212,"column":56},"line":212,"code":"      it('should be the kernel preference of the session', () => {\n        const preference: ISessionContext.IKernelPreference = {\n          name: 'foo',\n          language: 'bar',\n          id: '1234',\n          shouldStart: true,\n          canStart: true\n        };\n        sessionContext.kernelPreference = preference;\n        expect(sessionContext.kernelPreference).toBe(preference);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the session manager used by the session","suites":["@jupyterlab/apputils","SessionContext","#manager"],"updatePoint":{"line":226,"column":59},"line":226,"code":"      it('should be the session manager used by the session', () => {\n        expect(sessionContext.sessionManager).toBe(sessionManager);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should start the default kernel","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":232,"column":41},"line":232,"code":"      it('should start the default kernel', async () => {\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel?.name).toBe(\n          specsManager.specs!.default\n        );\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should connect to an existing session on the path","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":239,"column":59},"line":239,"code":"      it('should connect to an existing session on the path', async () => {\n        const other = await sessionManager.startNew({\n          name: '',\n          path,\n          type: 'test'\n        });\n\n        await sessionContext.initialize();\n        expect(other.kernel?.id).toBeDefined();\n        expect(other.kernel?.id).toBe(sessionContext.session?.kernel?.id);\n        await other.shutdown();\n        other.dispose();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should connect to an existing kernel","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":253,"column":46},"line":253,"code":"      it('should connect to an existing kernel', async () => {\n        // Shut down and dispose the session so it can be re-instantiated.\n        await sessionContext.shutdown();\n\n        const other = await sessionManager.startNew({\n          name: '',\n          path: UUID.uuid4(),\n          type: 'test'\n        });\n        const kernelPreference = { id: other.kernel!.id };\n\n        sessionContext = new SessionContext({\n          sessionManager,\n          specsManager,\n          kernelPreference\n        });\n        await sessionContext.initialize();\n        expect(other.kernel?.id).toBeDefined();\n        expect(other.kernel?.id).toBe(sessionContext.session?.kernel?.id);\n        // We don't call other.shutdown() here because that\n        // is handled by the afterEach() handler above.\n        other.dispose();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should yield true if there is no distinct kernel to start","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":277,"column":67},"line":277,"code":"      it('should yield true if there is no distinct kernel to start', async () => {\n        // Remove the kernel preference before initializing.\n        sessionContext.kernelPreference = {};\n        const result = await sessionContext.initialize();\n        expect(result).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be a no-op if the shouldStart kernelPreference is false","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":284,"column":72},"line":284,"code":"      it('should be a no-op if the shouldStart kernelPreference is false', async () => {\n        sessionContext.kernelPreference = { shouldStart: false };\n        const result = await sessionContext.initialize();\n        expect(result).toBe(false);\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be a no-op if the canStart kernelPreference is false","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":291,"column":69},"line":291,"code":"      it('should be a no-op if the canStart kernelPreference is false', async () => {\n        sessionContext.kernelPreference = { canStart: false };\n        const result = await sessionContext.initialize();\n        expect(result).toBe(false);\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should handle an error during startup","suites":["@jupyterlab/apputils","SessionContext","#initialize()"],"updatePoint":{"line":298,"column":47},"line":298,"code":"      it('should handle an error during startup', async () => {\n        // Give it a mock manager that errors on connectTo\n        const mockManager = new SessionManager({ kernelManager });\n\n        sessionContext = new SessionContext({\n          path,\n          sessionManager: mockManager,\n          specsManager,\n          kernelPreference: { name: specsManager.specs?.default }\n        });\n\n        (mockManager as any).running = () => {\n          return [{ path }];\n        };\n        (mockManager as any).connectTo = () => {\n          throw new Error('mock error');\n        };\n\n        let caught = false;\n        const promise = sessionContext.initialize().catch(() => {\n          caught = true;\n        });\n        await Promise.all([promise, acceptDialog()]);\n        expect(caught).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the display name of the current kernel","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayName"],"updatePoint":{"line":326,"column":58},"line":326,"code":"      it('should be the display name of the current kernel', async () => {\n        await sessionContext.initialize();\n        const spec = await sessionContext.session!.kernel!.spec;\n        expect(sessionContext.kernelDisplayName).toBe(spec!.display_name);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should display \"No Kernel\" when there is no kernel","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayName"],"updatePoint":{"line":332,"column":60},"line":332,"code":"      it('should display \"No Kernel\" when there is no kernel', async () => {\n        sessionContext.kernelPreference = {\n          canStart: false,\n          shouldStart: false\n        };\n        expect(sessionContext.kernelDisplayName).toBe('No Kernel');\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should display the pending kernel name when it looks like we are starting a kernel","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayName"],"updatePoint":{"line":340,"column":92},"line":340,"code":"      it('should display the pending kernel name when it looks like we are starting a kernel', async () => {\n        sessionContext.kernelPreference = {\n          autoStartDefault: true,\n          canStart: true,\n          shouldStart: true\n        };\n        expect(sessionContext.kernelDisplayName).toBe('Echo Kernel');\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the status of the current kernel if connected","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayStatus"],"updatePoint":{"line":351,"column":65},"line":351,"code":"      it('should be the status of the current kernel if connected', async () => {\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(sessionContext.kernelDisplayStatus).toBe(\n          sessionContext.session?.kernel?.status\n        );\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be the connection status of the current kernel if not connected","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayStatus"],"updatePoint":{"line":359,"column":80},"line":359,"code":"      it('should be the connection status of the current kernel if not connected', async () => {\n        await sessionContext.initialize();\n        const reconnect = sessionContext.session!.kernel!.reconnect();\n        expect(sessionContext.kernelDisplayStatus).toBe(\n          sessionContext.session?.kernel?.connectionStatus\n        );\n        await reconnect;\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be \"initializing\" if it looks like we are trying to start a kernel","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayStatus"],"updatePoint":{"line":368,"column":83},"line":368,"code":"      it('should be \"initializing\" if it looks like we are trying to start a kernel', async () => {\n        sessionContext.kernelPreference = {};\n        expect(sessionContext.kernelDisplayStatus).toBe('initializing');\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be \"idle\" if there is no current kernel","suites":["@jupyterlab/apputils","SessionContext","#kernelDisplayStatus"],"updatePoint":{"line":373,"column":56},"line":373,"code":"      it('should be \"idle\" if there is no current kernel', async () => {\n        await sessionContext.initialize();\n        await sessionContext.shutdown();\n        expect(sessionContext.kernelDisplayStatus).toBe('idle');\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should test whether a client session has been disposed","suites":["@jupyterlab/apputils","SessionContext","#isDisposed"],"updatePoint":{"line":381,"column":64},"line":381,"code":"      it('should test whether a client session has been disposed', () => {\n        expect(sessionContext.isDisposed).toBe(false);\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should dispose the resources held by the client session","suites":["@jupyterlab/apputils","SessionContext","#dispose()"],"updatePoint":{"line":389,"column":65},"line":389,"code":"      it('should dispose the resources held by the client session', () => {\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should not shut down the session by default","suites":["@jupyterlab/apputils","SessionContext","#dispose()"],"updatePoint":{"line":396,"column":53},"line":396,"code":"      it('should not shut down the session by default', async () => {\n        await sessionContext.initialize();\n        const id = sessionContext.session!.id;\n        sessionContext.dispose();\n        const sessions = await SessionAPI.listRunning();\n        expect(sessions.find(s => s.id === id)).toBeTruthy();\n        await SessionAPI.shutdownSession(id);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should shut down the session when shutdownOnDispose is true","suites":["@jupyterlab/apputils","SessionContext","#dispose()"],"updatePoint":{"line":405,"column":69},"line":405,"code":"      it('should shut down the session when shutdownOnDispose is true', async () => {\n        sessionContext.kernelPreference = {\n          ...sessionContext.kernelPreference,\n          shutdownOnDispose: true\n        };\n        const delegate = new PromiseDelegate();\n        await sessionContext.initialize();\n        const id = sessionContext.session!.id;\n        // Wait for the session to shut down.\n        sessionContext.sessionManager.runningChanged.connect((_, sessions) => {\n          if (!sessions.find(s => s.id === id)) {\n            delegate.resolve(void 0);\n            return;\n          }\n        });\n        sessionContext.dispose();\n        await expect(delegate.promise).resolves.not.toThrow();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should change the current kernel","suites":["@jupyterlab/apputils","SessionContext","#changeKernel()"],"updatePoint":{"line":426,"column":42},"line":426,"code":"      it('should change the current kernel', async () => {\n        await sessionContext.initialize();\n\n        const name = sessionContext.session?.kernel?.name;\n        const id = sessionContext.session?.kernel?.id;\n        const kernel = (await sessionContext.changeKernel({ name }))!;\n\n        expect(kernel.id).not.toBe(id);\n        expect(kernel.name).toBe(name);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should still work if called before fully initialized","suites":["@jupyterlab/apputils","SessionContext","#changeKernel()"],"updatePoint":{"line":437,"column":62},"line":437,"code":"      it('should still work if called before fully initialized', async () => {\n        const initPromise = sessionContext.initialize(); // Start but don't finish init.\n        const name = 'echo';\n        const kernelPromise = sessionContext.changeKernel({ name });\n\n        let lastKernel = null;\n        sessionContext.kernelChanged.connect(() => {\n          lastKernel = sessionContext.session?.kernel;\n        });\n        const results = await Promise.all([kernelPromise, initPromise]);\n        const kernel = results[0];\n        const shouldSelect = results[1];\n        expect(shouldSelect).toBe(false);\n        expect(lastKernel).toBe(kernel);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should handle multiple requests","suites":["@jupyterlab/apputils","SessionContext","#changeKernel()"],"updatePoint":{"line":453,"column":41},"line":453,"code":"      it('should handle multiple requests', async () => {\n        await sessionContext.initialize();\n        const name = 'echo';\n        const kernelPromise0 = sessionContext.changeKernel({ name });\n        // The last launched kernel should win.\n        const kernelPromise1 = sessionContext.changeKernel({ name });\n\n        let lastKernel = null;\n        sessionContext.kernelChanged.connect(() => {\n          lastKernel = sessionContext.session?.kernel;\n        });\n        const results = await Promise.all([kernelPromise0, kernelPromise1]);\n        // We can't know which of the two was launched first, so the result\n        // could be either, just make sure it isn't the original kernel.\n        expect([results[0], results[1]]).toContain(lastKernel);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should kill the kernel and shut down the session","suites":["@jupyterlab/apputils","SessionContext","#shutdown"],"updatePoint":{"line":472,"column":58},"line":472,"code":"      it('should kill the kernel and shut down the session', async () => {\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel).toBeTruthy();\n        await sessionContext.shutdown();\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should handle a shutdown during startup","suites":["@jupyterlab/apputils","SessionContext","#shutdown"],"updatePoint":{"line":479,"column":49},"line":479,"code":"      it('should handle a shutdown during startup', async () => {\n        const initPromise = sessionContext.initialize(); // Start but don't finish init.\n        const shutdownPromise = sessionContext.shutdown();\n        const results = await Promise.all([initPromise, shutdownPromise]);\n        expect(results[0]).toBe(false);\n        expect(sessionContext.session).toBe(null);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return null if no options are given","suites":["@jupyterlab/apputils","SessionContext",".getDefaultKernel()"],"updatePoint":{"line":489,"column":52},"line":489,"code":"      it('should return null if no options are given', () => {\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: {}\n          })\n        ).toBeNull();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return a matching name","suites":["@jupyterlab/apputils","SessionContext",".getDefaultKernel()"],"updatePoint":{"line":498,"column":39},"line":498,"code":"      it('should return a matching name', () => {\n        const spec = specsManager.specs!.kernelspecs[\n          specsManager.specs!.default\n        ]!;\n\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: { name: spec.name }\n          })\n        ).toBe(spec.name);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return null if no match is found","suites":["@jupyterlab/apputils","SessionContext",".getDefaultKernel()"],"updatePoint":{"line":511,"column":49},"line":511,"code":"      it('should return null if no match is found', () => {\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: { name: 'foo' }\n          })\n        ).toBeNull();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return a matching language","suites":["@jupyterlab/apputils","SessionContext",".getDefaultKernel()"],"updatePoint":{"line":520,"column":43},"line":520,"code":"      it('should return a matching language', () => {\n        const spec = specsManager.specs!.kernelspecs[\n          specsManager.specs!.default\n        ]!;\n        const kernelspecs: any = {};\n\n        kernelspecs[spec.name] = spec;\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: {\n              default: spec.name,\n              kernelspecs\n            },\n            preference: { language: spec.language }\n          })\n        ).toBe(spec.name);\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return null if a language matches twice","suites":["@jupyterlab/apputils","SessionContext",".getDefaultKernel()"],"updatePoint":{"line":538,"column":56},"line":538,"code":"      it('should return null if a language matches twice', () => {\n        const spec = specsManager.specs!.kernelspecs[\n          specsManager.specs!.default\n        ]!;\n        const kernelspecs: any = {};\n\n        kernelspecs['foo'] = spec;\n        kernelspecs['bar'] = spec;\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: {\n              default: spec.name,\n              kernelspecs\n            },\n            preference: { language: spec.language }\n          })\n        ).toBeNull();\n      });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should select a kernel for the session","suites":["@jupyterlab/apputils","SessionContext",".sessionContextDialogs","#selectKernel()"],"updatePoint":{"line":560,"column":50},"line":560,"code":"        it('should select a kernel for the session', async () => {\n          await sessionContext.initialize();\n\n          const { id, name } = sessionContext!.session!.kernel!;\n          const accept = acceptDialog();\n\n          await sessionContextDialogs.selectKernel(sessionContext);\n          await accept;\n\n          const session = sessionContext?.session;\n          expect(session!.kernel!.id).not.toBe(id);\n          expect(session!.kernel!.name).toBe(name);\n        });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should keep the existing kernel if dismissed","suites":["@jupyterlab/apputils","SessionContext",".sessionContextDialogs","#selectKernel()"],"updatePoint":{"line":574,"column":56},"line":574,"code":"        it('should keep the existing kernel if dismissed', async () => {\n          await sessionContext.initialize();\n\n          const { id, name } = sessionContext!.session!.kernel!;\n          const dismiss = dismissDialog();\n\n          await sessionContextDialogs.selectKernel(sessionContext);\n          await dismiss;\n\n          const session = sessionContext.session;\n          expect(session!.kernel!.id).toBe(id);\n          expect(session!.kernel!.name).toBe(name);\n        });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should restart if the user accepts the dialog","suites":["@jupyterlab/apputils","SessionContext",".sessionContextDialogs","#restart()"],"updatePoint":{"line":590,"column":57},"line":590,"code":"        it('should restart if the user accepts the dialog', async () => {\n          const emission = testEmission(sessionContext.statusChanged, {\n            find: (_, args) => args === 'restarting'\n          });\n          await sessionContext.initialize();\n          await sessionContext!.session?.kernel?.info;\n          const restart = sessionContextDialogs.restart(sessionContext);\n\n          await acceptDialog();\n          expect(await restart).toBe(true);\n          await emission;\n        });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should not restart if the user rejects the dialog","suites":["@jupyterlab/apputils","SessionContext",".sessionContextDialogs","#restart()"],"updatePoint":{"line":603,"column":61},"line":603,"code":"        it('should not restart if the user rejects the dialog', async () => {\n          let called = false;\n\n          await sessionContext.initialize();\n          sessionContext.statusChanged.connect((sender, args) => {\n            if (args === 'restarting') {\n              called = true;\n            }\n          });\n\n          const restart = sessionContextDialogs.restart(sessionContext);\n          await dismissDialog();\n          expect(await restart).toBe(false);\n          expect(called).toBe(false);\n        });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should start the same kernel as the previously started kernel","suites":["@jupyterlab/apputils","SessionContext",".sessionContextDialogs","#restart()"],"updatePoint":{"line":619,"column":73},"line":619,"code":"        it('should start the same kernel as the previously started kernel', async () => {\n          await sessionContext.initialize();\n          await sessionContext.shutdown();\n          await sessionContextDialogs.restart(sessionContext);\n          expect(sessionContext?.session?.kernel).toBeTruthy();\n        });","file":"sessioncontext.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add an inline svg node with the 'stop' icon","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createInterruptButton()"],"updatePoint":{"line":45,"column":62},"line":45,"code":"        it(\"should add an inline svg node with the 'stop' icon\", async () => {\n          const button = Toolbar.createInterruptButton(sessionContext);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='stop']\")\n          ).toBeDefined();\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add an inline svg node with the 'refresh' icon","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createRestartButton()"],"updatePoint":{"line":56,"column":65},"line":56,"code":"        it(\"should add an inline svg node with the 'refresh' icon\", async () => {\n          const button = Toolbar.createRestartButton(sessionContext);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='refresh']\")\n          ).toBeDefined();\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should display the `'display_name'` of the kernel","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createKernelNameItem()"],"updatePoint":{"line":67,"column":61},"line":67,"code":"        it(\"should display the `'display_name'` of the kernel\", async () => {\n          const item = Toolbar.createKernelNameItem(sessionContext);\n          await sessionContext.initialize();\n          Widget.attach(item, document.body);\n          await framePromise();\n          const node = item.node.querySelector(\n            '.jp-ToolbarButtonComponent-label'\n          )!;\n          expect(node.textContent).toBe(sessionContext.kernelDisplayName);\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should display a busy status if the kernel status is busy","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createKernelStatusItem()"],"updatePoint":{"line":85,"column":69},"line":85,"code":"        it('should display a busy status if the kernel status is busy', async () => {\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          let called = false;\n          sessionContext.statusChanged.connect((_, status) => {\n            if (status === 'busy') {\n              // eslint-disable-next-line jest/no-conditional-expect\n              expect(\n                item.node.querySelector(\"[data-icon$='circle']\")\n              ).toBeDefined();\n              called = true;\n            }\n          });\n          const future = sessionContext.session!.kernel!.requestExecute({\n            code: 'a = 109\\na'\n          })!;\n          await future.done;\n          expect(called).toBe(true);\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should show the current status in the node title","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createKernelStatusItem()"],"updatePoint":{"line":104,"column":60},"line":104,"code":"        it('should show the current status in the node title', async () => {\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          const status = sessionContext.session?.kernel?.status;\n          expect(item.node.title.toLowerCase()).toContain(status);\n          let called = false;\n          const future = sessionContext.session!.kernel!.requestExecute({\n            code: 'a = 1'\n          })!;\n          future.onIOPub = msg => {\n            if (sessionContext.session?.kernel?.status === 'busy') {\n              // eslint-disable-next-line jest/no-conditional-expect\n              expect(item.node.title.toLowerCase()).toContain('busy');\n              called = true;\n            }\n          };\n          await future.done;\n          expect(called).toBe(true);\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should handle a starting session","suites":["@jupyterlab/apputils","Toolbar","Kernel buttons",".createKernelStatusItem()"],"updatePoint":{"line":123,"column":44},"line":123,"code":"        it('should handle a starting session', async () => {\n          await sessionContext.session?.kernel?.info;\n          await sessionContext.shutdown();\n          sessionContext = await createSessionContext();\n          await sessionContext.initialize();\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          expect(item.node.title).toBe('Kernel Connecting');\n          expect(\n            item.node.querySelector(\"[data-icon$='circle-empty']\")\n          ).toBeDefined();\n          await sessionContext.initialize();\n          await sessionContext.session?.kernel?.info;\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should set a default factory","suites":["@jupyterlab/apputils","ToolbarWidgetRegistry","#constructor"],"updatePoint":{"line":142,"column":38},"line":142,"code":"      it('should set a default factory', () => {\n        const dummy = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        expect(registry.defaultFactory).toBe(dummy);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should set a default factory","suites":["@jupyterlab/apputils","ToolbarWidgetRegistry","#defaultFactory"],"updatePoint":{"line":153,"column":38},"line":153,"code":"      it('should set a default factory', () => {\n        const dummy = jest.fn();\n        const dummy2 = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        registry.defaultFactory = dummy2;\n\n        expect(registry.defaultFactory).toBe(dummy2);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should call the default factory as fallback","suites":["@jupyterlab/apputils","ToolbarWidgetRegistry","#createWidget"],"updatePoint":{"line":167,"column":53},"line":167,"code":"      it('should call the default factory as fallback', () => {\n        const documentWidget = new Widget();\n        const dummyWidget = new Widget();\n        const dummy = jest.fn().mockReturnValue(dummyWidget);\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        const widget = registry.createWidget('factory', documentWidget, item);\n\n        expect(widget).toBe(dummyWidget);\n        expect(dummy).toBeCalledWith('factory', documentWidget, item);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should call the registered factory","suites":["@jupyterlab/apputils","ToolbarWidgetRegistry","#createWidget"],"updatePoint":{"line":185,"column":44},"line":185,"code":"      it('should call the registered factory', () => {\n        const documentWidget = new Widget();\n        const dummyWidget = new Widget();\n        const defaultFactory = jest.fn().mockReturnValue(dummyWidget);\n        const dummy = jest.fn().mockReturnValue(dummyWidget);\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        registry.registerFactory('factory', item.name, dummy);\n\n        const widget = registry.createWidget('factory', documentWidget, item);\n\n        expect(widget).toBe(dummyWidget);\n        expect(dummy).toBeCalledWith(documentWidget);\n        expect(defaultFactory).toBeCalledTimes(0);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return the previous registered factory","suites":["@jupyterlab/apputils","ToolbarWidgetRegistry","#registerFactory"],"updatePoint":{"line":209,"column":55},"line":209,"code":"      it('should return the previous registered factory', () => {\n        const defaultFactory = jest.fn();\n        const dummy = jest.fn();\n        const dummy2 = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        expect(\n          registry.registerFactory('factory', item.name, dummy)\n        ).toBeUndefined();\n        expect(registry.registerFactory('factory', item.name, dummy2)).toBe(\n          dummy\n        );\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return the toolbar items","suites":["@jupyterlab/apputils","createToolbarFactory"],"updatePoint":{"line":232,"column":39},"line":232,"code":"    it('should return the toolbar items', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: jest.fn()\n      });\n\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'insert',\n                command: 'notebook:insert-cell-below',\n                rank: 20\n              },\n              { name: 'spacer', type: 'spacer', rank: 100 },\n              { name: 'cut', command: 'notebook:cut-cell', rank: 21 },\n              {\n                name: 'clear-all',\n                command: 'notebook:clear-all-cell-outputs',\n                rank: 60,\n                disabled: true\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      await settingRegistry.load(bar.id);\n      // Trick push this test after all other promise in the hope they get resolve\n      // before going further - in particular we are looking at the update of the items\n      // factory in `createToolbarFactory`\n      await Promise.resolve();\n\n      const items = factory(new Widget());\n      expect(items).toHaveLength(3);\n      expect(items.get(0).name).toEqual('insert');\n      expect(items.get(1).name).toEqual('cut');\n      expect(items.get(2).name).toEqual('spacer');\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should update the toolbar items with late settings load","suites":["@jupyterlab/apputils","createToolbarFactory"],"updatePoint":{"line":323,"column":63},"line":323,"code":"    it('should update the toolbar items with late settings load', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: jest.fn()\n      });\n\n      const foo: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: 'foo',\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              { name: 'cut', command: 'notebook:cut-cell', rank: 21 },\n              { name: 'insert', rank: 40 },\n              {\n                name: 'clear-all',\n                disabled: true\n              }\n            ]\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'insert',\n                command: 'notebook:insert-cell-below',\n                rank: 20\n              },\n              {\n                name: 'clear-all',\n                command: 'notebook:clear-all-cell-outputs',\n                rank: 60\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            case foo.id:\n              return foo;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      await settingRegistry.load(bar.id);\n      // Trick push this test after all other promise in the hope they get resolve\n      // before going further - in particular we are looking at the update of the items\n      // factory in `createToolbarFactory`\n      await Promise.resolve();\n      await settingRegistry.load(foo.id);\n\n      const items = factory(new Widget());\n      expect(items).toHaveLength(2);\n      expect(items.get(0).name).toEqual('cut');\n      expect(items.get(1).name).toEqual('insert');\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create an WidgetTracker","suites":["@jupyterlab/apputils","WidgetTracker","#constructor()"],"updatePoint":{"line":47,"column":40},"line":47,"code":"      it('should create an WidgetTracker', () => {\n        expect(tracker).toBeInstanceOf(WidgetTracker);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should emit for the first added widget","suites":["@jupyterlab/apputils","WidgetTracker","#currentChanged"],"updatePoint":{"line":66,"column":48},"line":66,"code":"      it('should emit for the first added widget', async () => {\n        const promise = signalToPromise(tracker.currentChanged);\n        void tracker.add(widget);\n        await expect(promise).resolves.not.toThrow();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should emit when a widget is added and there is another widget that does not have focus","suites":["@jupyterlab/apputils","WidgetTracker","#currentChanged"],"updatePoint":{"line":72,"column":97},"line":72,"code":"      it('should emit when a widget is added and there is another widget that does not have focus', async () => {\n        await tracker.add(widget);\n        const promise = signalToPromise(tracker.currentChanged);\n        await tracker.add(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should not emit when a widget is added and there is another widget that has focus","suites":["@jupyterlab/apputils","WidgetTracker","#currentChanged"],"updatePoint":{"line":79,"column":91},"line":79,"code":"      it('should not emit when a widget is added and there is another widget that has focus', async () => {\n        Widget.attach(widget, document.body);\n        focus(widget);\n        await tracker.add(widget);\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        await tracker.add(widget2);\n        expect(called).toBe(false);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should emit when the focus changes","suites":["@jupyterlab/apputils","WidgetTracker","#currentChanged"],"updatePoint":{"line":91,"column":44},"line":91,"code":"      it('should emit when the focus changes', async () => {\n        Widget.attach(widget, document.body);\n        Widget.attach(widget2, document.body);\n        focus(widget);\n        await tracker.add(widget);\n        await tracker.add(widget2);\n        const promise = signalToPromise(tracker.currentChanged);\n        focus(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should emit when a widget has been added","suites":["@jupyterlab/apputils","WidgetTracker","#widgetAdded"],"updatePoint":{"line":117,"column":50},"line":117,"code":"      it('should emit when a widget has been added', async () => {\n        const promise = signalToPromise(tracker.widgetAdded);\n\n        await tracker.add(widget);\n\n        const [sender, args] = await promise;\n\n        expect(sender).toBe(tracker);\n        expect(args).toBe(widget);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should not emit when a widget has been injected","suites":["@jupyterlab/apputils","WidgetTracker","#widgetAdded"],"updatePoint":{"line":128,"column":57},"line":128,"code":"      it('should not emit when a widget has been injected', async () => {\n        let total = 0;\n        const promise = testEmission(tracker.currentChanged, {\n          find: () => {\n            return total === 1;\n          }\n        });\n\n        tracker.widgetAdded.connect(() => {\n          total++;\n        });\n        void tracker.add(widget);\n        void tracker.inject(widget2);\n        Widget.attach(widget2, document.body);\n        focus(widget2);\n        Widget.detach(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should default to null","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":149,"column":32},"line":149,"code":"      it('should default to null', () => {\n        expect(tracker.currentWidget).toBeNull();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be updated when a widget is added","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":153,"column":50},"line":153,"code":"      it('should be updated when a widget is added', async () => {\n        const widget = createWidget();\n\n        await tracker.add(widget);\n        expect(tracker.currentWidget).toBe(widget);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be updated when a widget is focused","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":161,"column":52},"line":161,"code":"      it('should be updated when a widget is focused', async () => {\n        const panel = new Panel();\n        const widget0 = createWidget();\n        const widget1 = createWidget();\n\n        await tracker.add(widget0);\n        await tracker.add(widget1);\n        panel.addWidget(widget0);\n        panel.addWidget(widget1);\n        Widget.attach(panel, document.body);\n        expect(tracker.currentWidget).toBe(widget1);\n        focus(widget0);\n        expect(tracker.currentWidget).toBe(widget0);\n        panel.dispose();\n        widget0.dispose();\n        widget1.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should revert to last added widget on widget disposal","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":179,"column":63},"line":179,"code":"      it('should revert to last added widget on widget disposal', async () => {\n        const one = createWidget();\n        const two = createWidget();\n\n        await tracker.add(one);\n        await tracker.add(two);\n        focus(one);\n        focus(two);\n        expect(tracker.currentWidget).toBe(two);\n        two.dispose();\n        expect(tracker.currentWidget).toBe(one);\n        one.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should preserve the tracked widget on widget disposal","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":193,"column":63},"line":193,"code":"      it('should preserve the tracked widget on widget disposal', () => {\n        const panel = new Panel();\n        const widgets = [createWidget(), createWidget(), createWidget()];\n\n        widgets.forEach(widget => {\n          void tracker.add(widget);\n          panel.addWidget(widget);\n        });\n        Widget.attach(panel, document.body);\n\n        focus(widgets[0]);\n        expect(tracker.currentWidget).toBe(widgets[0]);\n\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        widgets[2].dispose();\n        expect(tracker.currentWidget).toBe(widgets[0]);\n        expect(called).toBe(false);\n        panel.dispose();\n        widgets.forEach(widget => {\n          widget.dispose();\n        });\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should select the previously added widget on widget disposal","suites":["@jupyterlab/apputils","WidgetTracker","#currentWidget"],"updatePoint":{"line":219,"column":70},"line":219,"code":"      it('should select the previously added widget on widget disposal', () => {\n        const panel = new Panel();\n        const widgets = [createWidget(), createWidget(), createWidget()];\n\n        Widget.attach(panel, document.body);\n        widgets.forEach(widget => {\n          void tracker.add(widget);\n          panel.addWidget(widget);\n          focus(widget);\n        });\n\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        widgets[2].dispose();\n        expect(tracker.currentWidget).toBe(widgets[1]);\n        expect(called).toBe(true);\n        panel.dispose();\n        widgets.forEach(widget => {\n          widget.dispose();\n        });\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should test whether the tracker is disposed","suites":["@jupyterlab/apputils","WidgetTracker","#isDisposed"],"updatePoint":{"line":245,"column":53},"line":245,"code":"      it('should test whether the tracker is disposed', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should add a widget to the tracker","suites":["@jupyterlab/apputils","WidgetTracker","#add()"],"updatePoint":{"line":253,"column":44},"line":253,"code":"      it('should add a widget to the tracker', async () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should reject a widget that already exists","suites":["@jupyterlab/apputils","WidgetTracker","#add()"],"updatePoint":{"line":261,"column":52},"line":261,"code":"      it('should reject a widget that already exists', async () => {\n        const widget = createWidget();\n        let failed = false;\n        expect(tracker.has(widget)).toBe(false);\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        try {\n          await tracker.add(widget);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should reject a widget that is disposed","suites":["@jupyterlab/apputils","WidgetTracker","#add()"],"updatePoint":{"line":276,"column":49},"line":276,"code":"      it('should reject a widget that is disposed', async () => {\n        const widget = createWidget();\n        let failed = false;\n        expect(tracker.has(widget)).toBe(false);\n        widget.dispose();\n        try {\n          await tracker.add(widget);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should remove an added widget if it is disposed","suites":["@jupyterlab/apputils","WidgetTracker","#add()"],"updatePoint":{"line":290,"column":57},"line":290,"code":"      it('should remove an added widget if it is disposed', async () => {\n        const widget = createWidget();\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n        expect(tracker.has(widget)).toBe(false);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should dispose of the resources used by the tracker","suites":["@jupyterlab/apputils","WidgetTracker","#dispose()"],"updatePoint":{"line":300,"column":61},"line":300,"code":"      it('should dispose of the resources used by the tracker', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/apputils","WidgetTracker","#dispose()"],"updatePoint":{"line":306,"column":47},"line":306,"code":"      it('should be safe to call multiple times', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should find a tracked item that matches a filter function","suites":["@jupyterlab/apputils","WidgetTracker","#find()"],"updatePoint":{"line":315,"column":67},"line":315,"code":"      it('should find a tracked item that matches a filter function', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.find(widget => widget.id === 'B')).toBe(widgetB);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return a void if no item is found","suites":["@jupyterlab/apputils","WidgetTracker","#find()"],"updatePoint":{"line":331,"column":50},"line":331,"code":"      it('should return a void if no item is found', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.find(widget => widget.id === 'D')).toBeFalsy();\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should filter according to a predicate function","suites":["@jupyterlab/apputils","WidgetTracker","#filter()"],"updatePoint":{"line":349,"column":57},"line":349,"code":"      it('should filter according to a predicate function', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'include-A';\n        widgetB.id = 'include-B';\n        widgetC.id = 'exclude-C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        const list = tracker.filter(\n          widget => widget.id.indexOf('include') !== -1\n        );\n        expect(list.length).toBe(2);\n        expect(list[0]).toBe(widgetA);\n        expect(list[1]).toBe(widgetB);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return an empty array if no item is found","suites":["@jupyterlab/apputils","WidgetTracker","#filter()"],"updatePoint":{"line":370,"column":58},"line":370,"code":"      it('should return an empty array if no item is found', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.filter(widget => widget.id === 'D').length).toBe(0);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should iterate through all the tracked items","suites":["@jupyterlab/apputils","WidgetTracker","#forEach()"],"updatePoint":{"line":388,"column":54},"line":388,"code":"      it('should iterate through all the tracked items', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        let visited = '';\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        tracker.forEach(widget => {\n          visited += widget.id;\n        });\n        expect(visited).toBe('ABC');\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should return `true` if an item exists in the tracker","suites":["@jupyterlab/apputils","WidgetTracker","#has()"],"updatePoint":{"line":410,"column":63},"line":410,"code":"      it('should return `true` if an item exists in the tracker', () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        void tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should inject a widget into the tracker","suites":["@jupyterlab/apputils","WidgetTracker","#inject()"],"updatePoint":{"line":420,"column":49},"line":420,"code":"      it('should inject a widget into the tracker', async () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        void tracker.inject(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should remove an injected widget if it is disposed","suites":["@jupyterlab/apputils","WidgetTracker","#inject()"],"updatePoint":{"line":428,"column":60},"line":428,"code":"      it('should remove an injected widget if it is disposed', async () => {\n        const widget = createWidget();\n        void tracker.inject(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n        expect(tracker.has(widget)).toBe(false);\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should be called when the current widget is changed","suites":["@jupyterlab/apputils","WidgetTracker","#onCurrentChanged()"],"updatePoint":{"line":438,"column":61},"line":438,"code":"      it('should be called when the current widget is changed', async () => {\n        const tracker = new TestTracker({ namespace });\n        const widget = createWidget();\n        await tracker.add(widget);\n        expect(tracker.methods).toEqual(\n          expect.arrayContaining(['onCurrentChanged'])\n        );\n        widget.dispose();\n      });","file":"widgettracker.spec.ts","skipped":false,"dir":"packages/apputils/test"},{"name":"should create an input area widget","suites":["@jupyterlab/cells","InputArea","#constructor()"],"updatePoint":{"line":17,"column":44},"line":17,"code":"      it('should create an input area widget', () => {\n        const widget = new InputArea({ model });\n        expect(widget).toBeInstanceOf(InputArea);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the model used by the input area","suites":["@jupyterlab/cells","InputArea","#model"],"updatePoint":{"line":24,"column":52},"line":24,"code":"      it('should be the model used by the input area', () => {\n        const widget = new InputArea({ model });\n        expect(widget.model).toBe(model);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the content factory used by the input area","suites":["@jupyterlab/cells","InputArea","#contentFactory"],"updatePoint":{"line":31,"column":62},"line":31,"code":"      it('should be the content factory used by the input area', () => {\n        const widget = new InputArea({ model });\n        expect(widget.contentFactory).toBe(InputArea.defaultContentFactory);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the editor widget used by the input area","suites":["@jupyterlab/cells","InputArea","#editorWidget"],"updatePoint":{"line":38,"column":60},"line":38,"code":"      it('should be the editor widget used by the input area', () => {\n        const widget = new InputArea({ model });\n        expect(widget.editorWidget).toBeInstanceOf(CodeEditorWrapper);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the code editor used by the cell","suites":["@jupyterlab/cells","InputArea","#editor"],"updatePoint":{"line":45,"column":52},"line":45,"code":"      it('should be the code editor used by the cell', () => {\n        const widget = new InputArea({ model });\n        expect(widget.editor.host).toBe(widget.editorWidget.node);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the prompt node used by the cell","suites":["@jupyterlab/cells","InputArea","#promptNode"],"updatePoint":{"line":52,"column":52},"line":52,"code":"      it('should be the prompt node used by the cell', () => {\n        const widget = new InputArea({ model });\n        expect(widget.promptNode.className).toContain('jp-InputPrompt');\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should render the widget","suites":["@jupyterlab/cells","InputArea","#renderInput()"],"updatePoint":{"line":59,"column":34},"line":59,"code":"      it('should render the widget', () => {\n        const widget = new InputArea({ model });\n        const rendered = new Widget();\n        Widget.attach(widget, document.body);\n        widget.renderInput(rendered);\n        expect(rendered.isAttached).toBe(true);\n        widget.dispose();\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be called to show the editor","suites":["@jupyterlab/cells","InputArea","#showEditor()"],"updatePoint":{"line":70,"column":45},"line":70,"code":"      it('should be called to show the editor', () => {\n        const widget = new InputArea({ model });\n        const rendered = new Widget();\n        Widget.attach(widget, document.body);\n        widget.renderInput(rendered);\n        widget.showEditor();\n        expect(rendered.isAttached).toBe(false);\n        widget.dispose();\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should change the value of the input prompt","suites":["@jupyterlab/cells","InputArea","#setPrompt()"],"updatePoint":{"line":82,"column":53},"line":82,"code":"      it('should change the value of the input prompt', () => {\n        const widget = new InputArea({ model });\n        const prompt = widget.node.querySelector(`.${PROMPT_CLASS}`)!;\n        expect(prompt.textContent).toHaveLength(0);\n        widget.setPrompt('foo');\n        expect(prompt.textContent).toContain('foo');\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources used by the widget","suites":["@jupyterlab/cells","InputArea","#dispose()"],"updatePoint":{"line":92,"column":60},"line":92,"code":"      it('should dispose of the resources used by the widget', () => {\n        const widget = new InputArea({ model });\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new content factory","suites":["@jupyterlab/cells","InputArea",".ContentFactory","#constructor()"],"updatePoint":{"line":103,"column":47},"line":103,"code":"        it('should create a new content factory', () => {\n          const factory = new InputArea.ContentFactory();\n          expect(factory).toBeInstanceOf(InputArea.ContentFactory);\n        });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the code editor factory being used","suites":["@jupyterlab/cells","InputArea",".ContentFactory","#editorFactory"],"updatePoint":{"line":110,"column":56},"line":110,"code":"        it('should be the code editor factory being used', () => {\n          const factory = new InputArea.ContentFactory();\n          expect(factory.editorFactory).toBe(InputArea.defaultEditorFactory);\n        });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create an input prompt","suites":["@jupyterlab/cells","InputArea",".ContentFactory","#createInputPrompt()"],"updatePoint":{"line":117,"column":41},"line":117,"code":"        it('should create an input prompt', () => {\n          const factory = new InputArea.ContentFactory();\n          expect(factory.createInputPrompt()).toBeInstanceOf(InputPrompt);\n        });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be an instance of the content factory","suites":["@jupyterlab/cells","InputArea",".defaultContentFactory"],"updatePoint":{"line":125,"column":54},"line":125,"code":"      it('should be an instance of the content factory', () => {\n        expect(InputArea.defaultContentFactory).toBeInstanceOf(\n          InputArea.ContentFactory\n        );\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be an editor factory","suites":["@jupyterlab/cells","InputArea",".defaultEditorFactory"],"updatePoint":{"line":133,"column":37},"line":133,"code":"      it('should be an editor factory', () => {\n        const factory = InputArea.defaultEditorFactory;\n        const host = document.createElement('div');\n        expect(factory({ host, model }).host).toBe(host);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create an input prompt","suites":["@jupyterlab/cells","InputPrompt","#constructor()"],"updatePoint":{"line":143,"column":39},"line":143,"code":"      it('should create an input prompt', () => {\n        const widget = new InputPrompt();\n        expect(widget).toBeInstanceOf(InputPrompt);\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the execution count for the prompt","suites":["@jupyterlab/cells","InputPrompt","#executionCount"],"updatePoint":{"line":150,"column":54},"line":150,"code":"      it('should be the execution count for the prompt', () => {\n        const widget = new InputPrompt();\n        expect(widget.executionCount).toBeNull();\n        widget.executionCount = '1';\n        expect(widget.executionCount).toBe('1');\n      });","file":"inputarea.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a cell model","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":31,"column":36},"line":31,"code":"      it('should create a cell model', () => {\n        const model = new CellModel({});\n        expect(model).toBeInstanceOf(CellModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a base cell argument","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":36,"column":44},"line":36,"code":"      it('should accept a base cell argument', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: { trusted: false }\n        };\n        const model = new CellModel({ cell });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.value.text).toBe(cell.source);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a base cell argument with a multiline source","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":47,"column":68},"line":47,"code":"      it('should accept a base cell argument with a multiline source', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false },\n          id: 'cell_id'\n        };\n        const model = new CellModel({ cell });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.value.text).toBe((cell.source as string[]).join(''));\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should use the id argument","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":59,"column":36},"line":59,"code":"      it('should use the id argument', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false },\n          id: 'cell_id'\n        };\n        const model = new CellModel({ cell, id: 'my_id' });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id).toBe('my_id');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should use the cell id if an id is not supplied","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":71,"column":57},"line":71,"code":"      it('should use the cell id if an id is not supplied', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false },\n          id: 'cell_id'\n        };\n        const model = new CellModel({ cell });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id).toBe('cell_id');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should generate an id if an id or cell id is not supplied","suites":["cells/model","CellModel","#constructor()"],"updatePoint":{"line":83,"column":67},"line":83,"code":"      it('should generate an id if an id or cell id is not supplied', () => {\n        const cell = {\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false }\n        };\n        const model = new CellModel({ cell });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id.length).toBeGreaterThan(0);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should signal when model content has changed","suites":["cells/model","CellModel","#contentChanged"],"updatePoint":{"line":96,"column":54},"line":96,"code":"      it('should signal when model content has changed', () => {\n        const model = new CellModel({});\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        expect(called).toBe(false);\n        model.value.text = 'foo';\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should signal when model state has changed","suites":["cells/model","CellModel","#stateChanged"],"updatePoint":{"line":109,"column":52},"line":109,"code":"      it('should signal when model state has changed', () => {\n        const model = new CodeCellModel({});\n        let called = false;\n        const listener = (sender: any, args: IChangedArgs<any>) => {\n          if (args.name == 'executionCount') {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args.newValue).toBe(1);\n            called = true;\n          }\n        };\n        model.stateChanged.connect(listener);\n        model.executionCount = 1;\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should not signal when model state has not changed","suites":["cells/model","CellModel","#stateChanged"],"updatePoint":{"line":124,"column":60},"line":124,"code":"      it('should not signal when model state has not changed', () => {\n        const model = new CodeCellModel({});\n        let called = 0;\n        model.stateChanged.connect((model, args) => {\n          if (args.name == 'executionCount') {\n            called++;\n          }\n        });\n        expect(called).toBe(0);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the trusted state of the cell","suites":["cells/model","CellModel","#trusted"],"updatePoint":{"line":141,"column":49},"line":141,"code":"      it('should be the trusted state of the cell', () => {\n        const model = new CodeCellModel({});\n        expect(model.trusted).toBe(false);\n        model.trusted = true;\n        expect(model.trusted).toBe(true);\n        const other = new CodeCellModel({ cell: model.toJSON() });\n        expect(other.trusted).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should update the trusted state of the output models","suites":["cells/model","CellModel","#trusted"],"updatePoint":{"line":150,"column":62},"line":150,"code":"      it('should update the trusted state of the output models', () => {\n        const model = new CodeCellModel({});\n        model.outputs.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(model.outputs.get(0).trusted).toBe(false);\n        model.trusted = true;\n        expect(model.outputs.get(0).trusted).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should signal when model metadata has changed","suites":["cells/model","CellModel","#metadataChanged"],"updatePoint":{"line":160,"column":55},"line":160,"code":"      it('should signal when model metadata has changed', () => {\n        const model = new TestModel({});\n        const listener = (sender: any, args: any) => {\n          value = args.newValue;\n        };\n        let value = '';\n        model.metadata.changed.connect(listener);\n        expect(Object.keys(value)).toHaveLength(0);\n        model.metadata.set('foo', 'bar');\n        expect(value).toBe('bar');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should not signal when model metadata has not changed","suites":["cells/model","CellModel","#metadataChanged"],"updatePoint":{"line":172,"column":63},"line":172,"code":"      it('should not signal when model metadata has not changed', () => {\n        const model = new TestModel({});\n        let called = 0;\n        model.metadata.changed.connect(() => {\n          called++;\n        });\n        expect(called).toBe(0);\n        model.metadata.set('foo', 'bar');\n        expect(called).toBe(1);\n        model.metadata.set('foo', 'bar');\n        expect(called).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should default to an empty string","suites":["cells/model","CellModel","#source"],"updatePoint":{"line":187,"column":43},"line":187,"code":"      it('should default to an empty string', () => {\n        const model = new CellModel({});\n        expect(model.value.text).toHaveLength(0);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be settable","suites":["cells/model","CellModel","#source"],"updatePoint":{"line":192,"column":28},"line":192,"code":"      it('should be settable', () => {\n        const model = new CellModel({});\n        expect(model.value.text).toHaveLength(0);\n        model.value.text = 'foo';\n        expect(model.value.text).toBe('foo');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be false by default","suites":["cells/model","CellModel","#isDisposed"],"updatePoint":{"line":201,"column":36},"line":201,"code":"      it('should be false by default', () => {\n        const model = new CellModel({});\n        expect(model.isDisposed).toBe(false);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be true after model is disposed","suites":["cells/model","CellModel","#isDisposed"],"updatePoint":{"line":206,"column":48},"line":206,"code":"      it('should be true after model is disposed', () => {\n        const model = new CellModel({});\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources held by the model","suites":["cells/model","CellModel","#dispose()"],"updatePoint":{"line":214,"column":59},"line":214,"code":"      it('should dispose of the resources held by the model', () => {\n        const model = new TestModel({});\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be safe to call multiple times","suites":["cells/model","CellModel","#dispose()"],"updatePoint":{"line":220,"column":47},"line":220,"code":"      it('should be safe to call multiple times', () => {\n        const model = new CellModel({});\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should return a base cell encapsulation of the model value","suites":["cells/model","CellModel","#toJSON()"],"updatePoint":{"line":229,"column":68},"line":229,"code":"      it('should return a base cell encapsulation of the model value', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: { trusted: false }\n        };\n        const model = new TestModel({ cell });\n        expect(model.toJSON()).not.toBe(cell);\n        expect(model.toJSON()).toEqual(cell);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should always return a string source","suites":["cells/model","CellModel","#toJSON()"],"updatePoint":{"line":240,"column":46},"line":240,"code":"      it('should always return a string source', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false }\n        };\n        const model = new TestModel({ cell });\n        cell.source = (cell.source as string[]).join('');\n        expect(model.toJSON()).not.toBe(cell);\n        expect(model.toJSON()).toEqual(cell);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should handle a metadata for the cell","suites":["cells/model","CellModel","#metadata"],"updatePoint":{"line":254,"column":47},"line":254,"code":"      it('should handle a metadata for the cell', () => {\n        const model = new CellModel({});\n        expect(model.metadata.get('foo')).toBeUndefined();\n        model.metadata.set('foo', 1);\n        expect(model.metadata.get('foo')).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should get a list of user metadata keys","suites":["cells/model","CellModel","#metadata"],"updatePoint":{"line":261,"column":49},"line":261,"code":"      it('should get a list of user metadata keys', () => {\n        const model = new CellModel({});\n        expect(toArray(model.metadata.keys())).toHaveLength(0);\n        model.metadata.set('foo', 1);\n        expect(model.metadata.keys()).toEqual(['foo']);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should trigger changed signal","suites":["cells/model","CellModel","#metadata"],"updatePoint":{"line":268,"column":39},"line":268,"code":"      it('should trigger changed signal', () => {\n        const model = new CellModel({});\n        let called = false;\n        model.metadata.changed.connect(() => {\n          called = true;\n        });\n        model.metadata.set('foo', 1);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be set with type \"raw\"","suites":["cells/model","RawCellModel","#type"],"updatePoint":{"line":282,"column":39},"line":282,"code":"      it('should be set with type \"raw\"', () => {\n        const model = new RawCellModel({});\n        expect(model.type).toBe('raw');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should return a raw cell encapsulation of the model value","suites":["cells/model","RawCellModel","#toJSON()"],"updatePoint":{"line":288,"column":67},"line":288,"code":"      it('should return a raw cell encapsulation of the model value', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: {},\n          id: 'cell_id'\n        };\n        const model = new RawCellModel({ cell });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be set with type \"markdown\"","suites":["cells/model","MarkdownCellModel","#type"],"updatePoint":{"line":305,"column":44},"line":305,"code":"      it('should be set with type \"markdown\"', () => {\n        const model = new MarkdownCellModel({});\n        expect(model.type).toBe('markdown');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should return a markdown cell encapsulation of the model value","suites":["cells/model","MarkdownCellModel","#toJSON()"],"updatePoint":{"line":311,"column":72},"line":311,"code":"      it('should return a markdown cell encapsulation of the model value', () => {\n        const cell: nbformat.IMarkdownCell = {\n          cell_type: 'markdown',\n          source: 'foo',\n          metadata: {},\n          id: 'cell_id'\n        };\n        const model = new MarkdownCellModel({ cell });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a code cell model","suites":["cells/model","CodeCellModel","#constructor()"],"updatePoint":{"line":328,"column":41},"line":328,"code":"      it('should create a code cell model', () => {\n        const model = new CodeCellModel({});\n        expect(model).toBeInstanceOf(CodeCellModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a code cell argument","suites":["cells/model","CodeCellModel","#constructor()"],"updatePoint":{"line":333,"column":44},"line":333,"code":"      it('should accept a code cell argument', () => {\n        const cell: nbformat.ICodeCell = {\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [\n            {\n              output_type: 'display_data',\n              data: { 'text/plain': 'foo' },\n              metadata: {}\n            } as nbformat.IDisplayData\n          ],\n          source: 'foo',\n          metadata: { trusted: false }\n        };\n        const model = new CodeCellModel({ cell });\n        expect(model).toBeInstanceOf(CodeCellModel);\n        expect(model.value.text).toBe(cell.source);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should connect the outputs changes to content change signal","suites":["cells/model","CodeCellModel","#constructor()"],"updatePoint":{"line":352,"column":69},"line":352,"code":"      it('should connect the outputs changes to content change signal', () => {\n        const data = {\n          output_type: 'display_data',\n          data: { 'text/plain': 'foo' },\n          metadata: {}\n        } as nbformat.IDisplayData;\n        const model = new CodeCellModel({});\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        expect(called).toBe(false);\n        model.outputs.add(data);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should sync collapsed and jupyter.outputs_hidden metadata on construction","suites":["cells/model","CodeCellModel","#constructor()"],"updatePoint":{"line":368,"column":83},"line":368,"code":"      it('should sync collapsed and jupyter.outputs_hidden metadata on construction', () => {\n        let model: CodeCellModel;\n        let jupyter: JSONObject | undefined;\n\n        // Setting `collapsed` works\n        model = new CodeCellModel({\n          cell: {\n            cell_type: 'code',\n            source: '',\n            metadata: { collapsed: true }\n          }\n        });\n        expect(model.metadata.get('collapsed')).toBe(true);\n        jupyter = model.metadata.get('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(true);\n\n        // Setting `jupyter.outputs_hidden` works\n        model = new CodeCellModel({\n          cell: {\n            cell_type: 'code',\n            source: '',\n            metadata: { jupyter: { outputs_hidden: true } }\n          }\n        });\n        expect(model.metadata.get('collapsed')).toBe(true);\n        jupyter = model.metadata.get('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(true);\n\n        // `collapsed` takes precedence\n        model = new CodeCellModel({\n          cell: {\n            cell_type: 'code',\n            source: '',\n            metadata: { collapsed: false, jupyter: { outputs_hidden: true } }\n          }\n        });\n        expect(model.metadata.get('collapsed')).toBe(false);\n        jupyter = model.metadata.get('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(false);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be set with type \"code\"","suites":["cells/model","CodeCellModel","#type"],"updatePoint":{"line":411,"column":40},"line":411,"code":"      it('should be set with type \"code\"', () => {\n        const model = new CodeCellModel({});\n        expect(model.type).toBe('code');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should show the execution count of the cell","suites":["cells/model","CodeCellModel","#executionCount"],"updatePoint":{"line":418,"column":53},"line":418,"code":"      it('should show the execution count of the cell', () => {\n        const cell: nbformat.ICodeCell = {\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [],\n          source: 'foo',\n          metadata: { trusted: false }\n        };\n        const model = new CodeCellModel({ cell });\n        expect(model.executionCount).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be settable","suites":["cells/model","CodeCellModel","#executionCount"],"updatePoint":{"line":430,"column":28},"line":430,"code":"      it('should be settable', () => {\n        const model = new CodeCellModel({});\n        expect(model.executionCount).toBeNull();\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should emit a state change signal when set","suites":["cells/model","CodeCellModel","#executionCount"],"updatePoint":{"line":437,"column":52},"line":437,"code":"      it('should emit a state change signal when set', () => {\n        const model = new CodeCellModel({});\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        expect(model.executionCount).toBeNull();\n        expect(called).toBe(false);\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should not signal when state has not changed","suites":["cells/model","CodeCellModel","#executionCount"],"updatePoint":{"line":450,"column":54},"line":450,"code":"      it('should not signal when state has not changed', () => {\n        const model = new CodeCellModel({});\n        let called = 0;\n        model.stateChanged.connect((model, args) => {\n          if (args.name == 'executionCount') {\n            called++;\n          }\n        });\n        expect(model.executionCount).toBeNull();\n        expect(called).toBe(0);\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should set dirty flag and signal","suites":["cells/model","CodeCellModel","#executionCount"],"updatePoint":{"line":466,"column":42},"line":466,"code":"      it('should set dirty flag and signal', () => {\n        const model = new CodeCellModel({});\n        let called = 0;\n        model.stateChanged.connect((model, args) => {\n          if (args.name == 'isDirty') {\n            called++;\n          }\n        });\n        expect(model.executionCount).toBeNull();\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(0);\n\n        model.executionCount = 1;\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(0);\n\n        model.value.text = 'foo';\n        expect(model.isDirty).toBe(true);\n        expect(called).toBe(1);\n\n        model.executionCount = 2;\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be an output area model","suites":["cells/model","CodeCellModel","#outputs"],"updatePoint":{"line":493,"column":40},"line":493,"code":"      it('should be an output area model', () => {\n        const model = new CodeCellModel({});\n        expect(model.outputs).toBeInstanceOf(OutputAreaModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources held by the model","suites":["cells/model","CodeCellModel","#dispose()"],"updatePoint":{"line":500,"column":59},"line":500,"code":"      it('should dispose of the resources held by the model', () => {\n        const model = new CodeCellModel({});\n        expect(model.outputs).toBeInstanceOf(OutputAreaModel);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n        expect(model.outputs).toBeNull();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be safe to call multiple times","suites":["cells/model","CodeCellModel","#dispose()"],"updatePoint":{"line":508,"column":47},"line":508,"code":"      it('should be safe to call multiple times', () => {\n        const model = new CodeCellModel({});\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should return a code cell encapsulation of the model value","suites":["cells/model","CodeCellModel","#toJSON()"],"updatePoint":{"line":517,"column":68},"line":517,"code":"      it('should return a code cell encapsulation of the model value', () => {\n        const cell: nbformat.ICodeCell = {\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [\n            {\n              output_type: 'display_data',\n              data: {\n                'text/plain': 'foo',\n                'application/json': { bar: 1 }\n              },\n              metadata: {}\n            } as nbformat.IDisplayData\n          ],\n          source: 'foo',\n          metadata: { trusted: false },\n          id: 'cell_id'\n        };\n        const model = new CodeCellModel({ cell });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n        const output = serialized.outputs[0] as any;\n        expect(output.data['application/json']['bar']).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should sync collapsed and jupyter.outputs_hidden metadata when changed","suites":["cells/model","CodeCellModel",".metadata"],"updatePoint":{"line":545,"column":80},"line":545,"code":"      it('should sync collapsed and jupyter.outputs_hidden metadata when changed', () => {\n        const metadata = new CodeCellModel({}).metadata;\n\n        expect(metadata.get('collapsed')).toBeUndefined();\n        expect(metadata.get('jupyter')).toBeUndefined();\n\n        // Setting collapsed sets jupyter.outputs_hidden\n        metadata.set('collapsed', true);\n        expect(metadata.get('collapsed')).toBe(true);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: true\n        });\n\n        metadata.set('collapsed', false);\n        expect(metadata.get('collapsed')).toBe(false);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: false\n        });\n\n        metadata.delete('collapsed');\n        expect(metadata.get('collapsed')).toBeUndefined();\n        expect(metadata.get('jupyter')).toBeUndefined();\n\n        // Setting jupyter.outputs_hidden sets collapsed\n        metadata.set('jupyter', { outputs_hidden: true });\n        expect(metadata.get('collapsed')).toBe(true);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: true\n        });\n\n        metadata.set('jupyter', { outputs_hidden: false });\n        expect(metadata.get('collapsed')).toBe(false);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: false\n        });\n\n        metadata.delete('jupyter');\n        expect(metadata.get('collapsed')).toBeUndefined();\n        expect(metadata.get('jupyter')).toBeUndefined();\n\n        // Deleting jupyter.outputs_hidden preserves other jupyter fields\n        metadata.set('jupyter', { outputs_hidden: true, other: true });\n        expect(metadata.get('collapsed')).toBe(true);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: true,\n          other: true\n        });\n        metadata.set('jupyter', { other: true });\n        expect(metadata.get('collapsed')).toBeUndefined();\n        expect(metadata.get('jupyter')).toEqual({\n          other: true\n        });\n\n        // Deleting collapsed preserves other jupyter fields\n        metadata.set('jupyter', { outputs_hidden: true, other: true });\n        expect(metadata.get('collapsed')).toBe(true);\n        expect(metadata.get('jupyter')).toEqual({\n          outputs_hidden: true,\n          other: true\n        });\n        metadata.delete('collapsed');\n        expect(metadata.get('collapsed')).toBeUndefined();\n        expect(metadata.get('jupyter')).toEqual({\n          other: true\n        });\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new output area factory","suites":["cells/model","CodeCellModel",".ContentFactory","#constructor()"],"updatePoint":{"line":615,"column":51},"line":615,"code":"        it('should create a new output area factory', () => {\n          const factory = new CodeCellModel.ContentFactory();\n          expect(factory).toBeInstanceOf(CodeCellModel.ContentFactory);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create an output area model","suites":["cells/model","CodeCellModel",".ContentFactory","#createOutputArea()"],"updatePoint":{"line":622,"column":46},"line":622,"code":"        it('should create an output area model', () => {\n          const factory = new CodeCellModel.ContentFactory();\n          expect(factory.createOutputArea({ trusted: true })).toBeInstanceOf(\n            OutputAreaModel\n          );\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be an ContentFactory","suites":["cells/model","CodeCellModel",".defaultContentFactory"],"updatePoint":{"line":632,"column":37},"line":632,"code":"      it('should be an ContentFactory', () => {\n        expect(CodeCellModel.defaultContentFactory).toBeInstanceOf(\n          CodeCellModel.ContentFactory\n        );\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a base cell widget","suites":["cells/widget","Cell","#constructor()"],"updatePoint":{"line":115,"column":42},"line":115,"code":"      it('should create a base cell widget', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget).toBeInstanceOf(Cell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a custom contentFactory","suites":["cells/widget","Cell","#constructor()"],"updatePoint":{"line":120,"column":47},"line":120,"code":"      it('should accept a custom contentFactory', () => {\n        const contentFactory = NBTestUtils.createBaseCellFactory();\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget).toBeInstanceOf(Cell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a custom editorConfig","suites":["cells/widget","Cell","#constructor()"],"updatePoint":{"line":126,"column":45},"line":126,"code":"      it('should accept a custom editorConfig', () => {\n        const editorConfig: Partial<CodeEditor.IConfig> = {\n          insertSpaces: false,\n          matchBrackets: false\n        };\n        const widget = new Cell({\n          editorConfig,\n          model,\n          contentFactory\n        }).initializeState();\n        expect(widget.editor.getOption('insertSpaces')).toEqual(false);\n        expect(widget.editor.getOption('matchBrackets')).toEqual(false);\n        expect(widget.editor.getOption('lineNumbers')).toEqual(\n          CodeEditor.defaultConfig.lineNumbers\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the model used by the widget","suites":["cells/widget","Cell","#model"],"updatePoint":{"line":145,"column":48},"line":145,"code":"      it('should be the model used by the widget', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.model).toEqual(model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be a code editor widget","suites":["cells/widget","Cell","#editorWidget"],"updatePoint":{"line":153,"column":40},"line":153,"code":"      it('should be a code editor widget', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.editorWidget).toBeInstanceOf(CodeEditorWrapper);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be a cell editor","suites":["cells/widget","Cell","#editor"],"updatePoint":{"line":160,"column":33},"line":160,"code":"      it('should be a cell editor', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.editor.uuid).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the input area for the cell","suites":["cells/widget","Cell","#inputArea"],"updatePoint":{"line":167,"column":47},"line":167,"code":"      it('should be the input area for the cell', () => {\n        const widget = new Cell({ model }).initializeState();\n        expect(widget.inputArea).toBeInstanceOf(InputArea);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be a boolean","suites":["cells/widget","Cell","#readOnly"],"updatePoint":{"line":174,"column":29},"line":174,"code":"      it('should be a boolean', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(typeof widget.readOnly).toEqual('boolean');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should default to false","suites":["cells/widget","Cell","#readOnly"],"updatePoint":{"line":179,"column":33},"line":179,"code":"      it('should default to false', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be settable","suites":["cells/widget","Cell","#readOnly"],"updatePoint":{"line":184,"column":28},"line":184,"code":"      it('should be settable', () => {\n        const widget = new Cell({\n          model,\n          contentFactory\n        }).initializeState();\n        widget.readOnly = true;\n        expect(widget.readOnly).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should ignore being set to the same value","suites":["cells/widget","Cell","#readOnly"],"updatePoint":{"line":193,"column":51},"line":193,"code":"      it('should ignore being set to the same value', async () => {\n        const widget = new LogBaseCell().initializeState();\n        widget.readOnly = true;\n        widget.readOnly = true;\n        await framePromise();\n        expect(widget.methods).toEqual(['onUpdateRequest']);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should reflect model metadata","suites":["cells/widget","Cell","#readOnly"],"updatePoint":{"line":201,"column":39},"line":201,"code":"      it('should reflect model metadata', () => {\n        model.metadata.set('editable', false);\n\n        const widget = new Cell({\n          model,\n          contentFactory\n        }).initializeState();\n        expect(widget.readOnly).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the view state of the input being collapsed","suites":["cells/widget","Cell","#inputCollapsed"],"updatePoint":{"line":213,"column":63},"line":213,"code":"      it('should be the view state of the input being collapsed', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.inputHidden).toEqual(false);\n        widget.inputHidden = true;\n        expect(widget.inputHidden).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should load the editable state from the model","suites":["cells/widget","Cell","#loadEditableState()"],"updatePoint":{"line":222,"column":55},"line":222,"code":"      it('should load the editable state from the model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n\n        model.metadata.set('editable', false);\n        widget.loadEditableState();\n        expect(widget.readOnly).toEqual(true);\n\n        model.metadata.set('editable', true);\n        widget.loadEditableState();\n        expect(widget.readOnly).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should save the editable state to the model","suites":["cells/widget","Cell","#saveEditableState()"],"updatePoint":{"line":238,"column":53},"line":238,"code":"      it('should save the editable state to the model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n\n        widget.readOnly = true;\n        widget.saveEditableState();\n        expect(model.metadata.get('editable')).toEqual(false);\n\n        widget.readOnly = false;\n        widget.saveEditableState();\n        // Default values are not saved explicitly\n        expect(model.metadata.get('editable')).toEqual(undefined);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should control automatic syncing of editable state with model","suites":["cells/widget","Cell","#syncEditable"],"updatePoint":{"line":255,"column":71},"line":255,"code":"      it('should control automatic syncing of editable state with model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.syncEditable).toEqual(false);\n        expect(widget.readOnly).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.readOnly = true;\n        expect(model.metadata.get('editable')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.metadata.set('editable', true);\n        expect(widget.readOnly).toEqual(true);\n\n        widget.syncEditable = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.metadata.get('editable')).toEqual(undefined);\n        expect(widget.readOnly).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.readOnly = true;\n        expect(model.metadata.get('editable')).toEqual(false);\n\n        // Synced if setting metadata attribute\n        model.metadata.set('editable', true);\n        expect(widget.readOnly).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should load the input collapse state from the model","suites":["cells/widget","Cell","#loadCollapseState()"],"updatePoint":{"line":287,"column":61},"line":287,"code":"      it('should load the input collapse state from the model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.inputHidden).toEqual(false);\n\n        model.metadata.set('jupyter', { source_hidden: true });\n        widget.loadCollapseState();\n        expect(widget.inputHidden).toEqual(true);\n\n        model.metadata.set('jupyter', { source_hidden: false });\n        widget.loadCollapseState();\n        expect(widget.inputHidden).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should save the collapse state to the model","suites":["cells/widget","Cell","#saveCollapseState()"],"updatePoint":{"line":303,"column":53},"line":303,"code":"      it('should save the collapse state to the model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.inputHidden).toEqual(false);\n\n        widget.inputHidden = true;\n        widget.saveCollapseState();\n        expect(model.metadata.get('jupyter')).toEqual({\n          source_hidden: true\n        });\n\n        widget.inputHidden = false;\n        widget.saveCollapseState();\n        // Default values are not saved explicitly\n        expect(model.metadata.get('jupyter')).toEqual(undefined);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should control automatic syncing of collapse state with model","suites":["cells/widget","Cell","#syncCollapse"],"updatePoint":{"line":322,"column":71},"line":322,"code":"      it('should control automatic syncing of collapse state with model', () => {\n        const model = new CellModel({});\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget.syncCollapse).toEqual(false);\n        expect(widget.inputHidden).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.inputHidden = true;\n        expect(model.metadata.get('jupyter')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.metadata.set('jupyter', { source_hidden: false });\n        expect(widget.inputHidden).toEqual(true);\n\n        widget.syncCollapse = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.metadata.get('jupyter')).toEqual(undefined);\n        expect(widget.inputHidden).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.inputHidden = true;\n        expect(model.metadata.get('jupyter')).toEqual({\n          source_hidden: true\n        });\n\n        // Synced if setting metadata attribute\n        model.metadata.set('jupyter', {});\n        expect(widget.inputHidden).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should focus the cell editor","suites":["cells/widget","Cell","#onActivateRequest()"],"updatePoint":{"line":356,"column":38},"line":356,"code":"      it('should focus the cell editor', async () => {\n        const widget = new LogBaseCell().initializeState();\n        Widget.attach(widget, document.body);\n        widget.activate();\n        await framePromise();\n        expect(widget.methods).toContain('onActivateRequest');\n        await framePromise();\n        expect(widget.editor.hasFocus()).toEqual(true);\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should not throw an error (full test in input area)","suites":["cells/widget","Cell","#setPrompt()"],"updatePoint":{"line":369,"column":61},"line":369,"code":"      it('should not throw an error (full test in input area)', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(() => {\n          widget.setPrompt('');\n        }).not.toThrow();\n        expect(() => {\n          widget.setPrompt('null');\n        }).not.toThrow();\n        expect(() => {\n          widget.setPrompt('test');\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources held by the widget","suites":["cells/widget","Cell","#dispose()"],"updatePoint":{"line":384,"column":60},"line":384,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be safe to call multiple times","suites":["cells/widget","Cell","#dispose()"],"updatePoint":{"line":390,"column":47},"line":390,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should run when widget is attached","suites":["cells/widget","Cell","#onAfterAttach()"],"updatePoint":{"line":399,"column":44},"line":399,"code":"      it('should run when widget is attached', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.methods).not.toContain('onAfterAttach');\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toContain('onAfterAttach');\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should update the widget","suites":["cells/widget","Cell","#onUpdateRequest()"],"updatePoint":{"line":409,"column":34},"line":409,"code":"      it('should update the widget', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be a contentFactory","suites":["cells/widget","Cell","#.defaultContentFactory"],"updatePoint":{"line":418,"column":36},"line":418,"code":"      it('should be a contentFactory', () => {\n        expect(Cell.defaultContentFactory).toBeInstanceOf(Cell.ContentFactory);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a ContentFactory","suites":["cells/widget","Cell",".ContentFactory","#constructor"],"updatePoint":{"line":425,"column":42},"line":425,"code":"        it('should create a ContentFactory', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(Cell.ContentFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the editor factory used by the content factory","suites":["cells/widget","Cell",".ContentFactory","#editorFactory"],"updatePoint":{"line":432,"column":68},"line":432,"code":"        it('should be the editor factory used by the content factory', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.editorFactory).toEqual(editorFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new cell header","suites":["cells/widget","Cell",".ContentFactory","#createCellHeader()"],"updatePoint":{"line":439,"column":43},"line":439,"code":"        it('should create a new cell header', () => {\n          const factory = new Cell.ContentFactory();\n          expect(factory.createCellHeader()).toBeInstanceOf(CellHeader);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new cell footer","suites":["cells/widget","Cell",".ContentFactory","#createCellFooter()"],"updatePoint":{"line":446,"column":43},"line":446,"code":"        it('should create a new cell footer', () => {\n          const factory = new Cell.ContentFactory();\n          expect(factory.createCellFooter()).toBeInstanceOf(CellFooter);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new output prompt","suites":["cells/widget","Cell",".ContentFactory","#createOutputPrompt()"],"updatePoint":{"line":453,"column":45},"line":453,"code":"        it('should create a new output prompt', () => {\n          const factory = new Cell.ContentFactory();\n          expect(factory.createOutputPrompt()).toBeInstanceOf(OutputPrompt);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new input prompt","suites":["cells/widget","Cell",".ContentFactory","#createInputPrompt()"],"updatePoint":{"line":460,"column":44},"line":460,"code":"        it('should create a new input prompt', () => {\n          const factory = new Cell.ContentFactory();\n          expect(factory.createInputPrompt()).toBeInstanceOf(InputPrompt);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a code cell widget","suites":["cells/widget","CodeCell","#constructor()"],"updatePoint":{"line":473,"column":42},"line":473,"code":"      it('should create a code cell widget', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(CodeCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a custom contentFactory","suites":["cells/widget","CodeCell","#constructor()"],"updatePoint":{"line":479,"column":47},"line":479,"code":"      it('should accept a custom contentFactory', () => {\n        const contentFactory = NBTestUtils.createCodeCellFactory();\n        const widget = new CodeCell({ model, contentFactory, rendermime });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(CodeCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the output area used by the cell","suites":["cells/widget","CodeCell","#outputArea"],"updatePoint":{"line":488,"column":52},"line":488,"code":"      it('should be the output area used by the cell', () => {\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputArea).toBeInstanceOf(OutputArea);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should initialize from the model","suites":["cells/widget","CodeCell","#outputCollapsed"],"updatePoint":{"line":496,"column":42},"line":496,"code":"      it('should initialize from the model', () => {\n        const collapsedModel = new CodeCellModel({});\n        let widget = new CodeCell({ model: collapsedModel, rendermime });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n\n        collapsedModel.metadata.set('collapsed', true);\n        widget = new CodeCell({ model: collapsedModel, rendermime });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(true);\n\n        collapsedModel.metadata.delete('collapsed');\n        collapsedModel.metadata.set('jupyter', { outputs_hidden: true });\n        widget = new CodeCell({ model: collapsedModel, rendermime });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be the view state of the output being collapsed","suites":["cells/widget","CodeCell","#outputCollapsed"],"updatePoint":{"line":514,"column":64},"line":514,"code":"      it('should be the view state of the output being collapsed', () => {\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n        widget.outputHidden = true;\n        expect(widget.outputHidden).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should initialize from the model","suites":["cells/widget","CodeCell","#outputsScrolled"],"updatePoint":{"line":524,"column":42},"line":524,"code":"      it('should initialize from the model', () => {\n        const model = new CodeCellModel({});\n        let widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.metadata.set('scrolled', false);\n        widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.metadata.set('scrolled', 'auto');\n        widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.metadata.set('scrolled', true);\n        widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should load the output scrolled state from the model","suites":["cells/widget","CodeCell","#loadScrolledState()"],"updatePoint":{"line":548,"column":62},"line":548,"code":"      it('should load the output scrolled state from the model', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.metadata.set('scrolled', true);\n        widget.loadScrolledState();\n        expect(widget.outputsScrolled).toEqual(true);\n\n        model.metadata.set('scrolled', false);\n        widget.loadScrolledState();\n        expect(widget.outputsScrolled).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should save the collapse state to the model","suites":["cells/widget","CodeCell","#saveScrolledState()"],"updatePoint":{"line":565,"column":53},"line":565,"code":"      it('should save the collapse state to the model', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        widget.outputsScrolled = true;\n        widget.saveScrolledState();\n        expect(model.metadata.get('scrolled')).toEqual(true);\n\n        widget.outputsScrolled = false;\n        widget.saveScrolledState();\n        // Default values are not saved explicitly\n        expect(model.metadata.get('scrolled')).toEqual(undefined);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should control automatic syncing of scrolled state with model","suites":["cells/widget","CodeCell","#syncScrolled"],"updatePoint":{"line":583,"column":71},"line":583,"code":"      it('should control automatic syncing of scrolled state with model', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.syncScrolled).toEqual(false);\n        expect(widget.outputsScrolled).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.outputsScrolled = true;\n        expect(model.metadata.get('scrolled')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.metadata.set('scrolled', false);\n        expect(widget.outputsScrolled).toEqual(true);\n\n        widget.syncScrolled = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.metadata.get('scrolled')).toEqual(undefined);\n        expect(widget.outputsScrolled).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.outputsScrolled = true;\n        expect(model.metadata.get('scrolled')).toEqual(true);\n\n        // Synced if setting metadata attribute\n        model.metadata.set('scrolled', false);\n        expect(widget.outputsScrolled).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should load the output collapse state from the model","suites":["cells/widget","CodeCell","#loadCollapseState()"],"updatePoint":{"line":616,"column":62},"line":616,"code":"      it('should load the output collapse state from the model', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(false);\n\n        model.metadata.set('collapsed', true);\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(true);\n\n        model.metadata.set('collapsed', false);\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should save the collapse state to the model `collapsed` metadata","suites":["cells/widget","CodeCell","#saveCollapseState()"],"updatePoint":{"line":634,"column":74},"line":634,"code":"      it('should save the collapse state to the model `collapsed` metadata', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n\n        widget.outputHidden = true;\n        widget.saveCollapseState();\n        expect(model.metadata.get('collapsed')).toEqual(true);\n\n        // Default values are not saved explicitly\n        widget.outputHidden = false;\n        widget.saveCollapseState();\n        expect(model.metadata.get('collapsed')).toEqual(undefined);\n\n        // Default values are explicitly deleted\n        model.metadata.set('collapsed', false);\n        widget.outputHidden = false;\n        widget.saveCollapseState();\n        expect(model.metadata.get('collapsed')).toEqual(undefined);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should control automatic syncing of collapse state with model","suites":["cells/widget","CodeCell","#syncCollapse"],"updatePoint":{"line":658,"column":71},"line":658,"code":"      it('should control automatic syncing of collapse state with model', () => {\n        const model = new CodeCellModel({});\n        const widget = new CodeCell({ model, rendermime });\n        widget.initializeState();\n        expect(widget.syncCollapse).toEqual(false);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.outputHidden = true;\n        expect(model.metadata.get('collapsed')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.metadata.set('collapsed', false);\n        expect(widget.outputHidden).toEqual(true);\n\n        widget.syncCollapse = true;\n\n        // Setting sync does an initial sync from model to view.\n        expect(model.metadata.get('collapsed')).toEqual(undefined);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.outputHidden = true;\n        expect(model.metadata.get('collapsed')).toEqual(true);\n\n        // Synced if setting metadata attribute\n        model.metadata.set('collapsed', false);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Synced if deleting collapsed metadata attribute\n        widget.outputHidden = true;\n        expect(model.metadata.get('collapsed')).toEqual(true);\n        model.metadata.delete('collapsed');\n        expect(widget.outputHidden).toEqual(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources held by the widget","suites":["cells/widget","CodeCell","#dispose()"],"updatePoint":{"line":696,"column":60},"line":696,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be safe to call multiple times","suites":["cells/widget","CodeCell","#dispose()"],"updatePoint":{"line":703,"column":47},"line":703,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should update the widget","suites":["cells/widget","CodeCell","#onUpdateRequest()"],"updatePoint":{"line":713,"column":34},"line":713,"code":"      it('should update the widget', () => {\n        const widget = new LogCodeCell().initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should fire when model metadata changes","suites":["cells/widget","CodeCell","#onMetadataChanged()"],"updatePoint":{"line":722,"column":49},"line":722,"code":"      it('should fire when model metadata changes', () => {\n        const method = 'onMetadataChanged';\n        const widget = new LogCodeCell().initializeState();\n        expect(widget.methods).not.toContain(method);\n        widget.model.metadata.set('foo', 1);\n        expect(widget.methods).toContain(method);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should fulfill a promise if there is no code to execute","suites":["cells/widget","CodeCell",".execute()"],"updatePoint":{"line":744,"column":65},"line":744,"code":"      it('should fulfill a promise if there is no code to execute', async () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        await expect(\n          CodeCell.execute(widget, sessionContext)\n        ).resolves.not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should fulfill a promise if there is code to execute","suites":["cells/widget","CodeCell",".execute()"],"updatePoint":{"line":752,"column":62},"line":752,"code":"      it('should fulfill a promise if there is code to execute', async () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        let originalCount: number;\n        widget.model.value.text = 'foo';\n        originalCount = widget.model.executionCount!;\n        await CodeCell.execute(widget, sessionContext);\n        const executionCount = widget.model.executionCount;\n        expect(executionCount).not.toEqual(originalCount);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should not save timing info by default","suites":["cells/widget","CodeCell",".execute()"],"updatePoint":{"line":771,"column":48},"line":771,"code":"      it('should not save timing info by default', async () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        await CodeCell.execute(widget, sessionContext);\n        expect(widget.model.metadata.get('execution')).toBeUndefined();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should save timing info if requested","suites":["cells/widget","CodeCell",".execute()"],"updatePoint":{"line":776,"column":46},"line":776,"code":"      it('should save timing info if requested', async () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        await CodeCell.execute(widget, sessionContext, { recordTiming: true });\n        expect(widget.model.metadata.get('execution')).toBeDefined();\n        const timingInfo = widget.model.metadata.get('execution') as any;\n        for (const key of TIMING_KEYS) {\n          expect(timingInfo[key]).toBeDefined();\n        }\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should set the cell prompt properly while executing","suites":["cells/widget","CodeCell",".execute()"],"updatePoint":{"line":786,"column":61},"line":786,"code":"      it('should set the cell prompt properly while executing', async () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.model.value.text = 'foo';\n        const future1 = CodeCell.execute(widget, sessionContext);\n        expect(widget.promptNode.textContent).toEqual('[*]:');\n        const future2 = CodeCell.execute(widget, sessionContext);\n        expect(widget.promptNode.textContent).toEqual('[*]:');\n        await expect(future1).rejects.toThrow('Canceled');\n        expect(widget.promptNode.textContent).toEqual('[*]:');\n        const msg = await future2;\n        expect(msg).not.toBeUndefined();\n\n        expect(widget.promptNode.textContent).toEqual(\n          `[${(msg as IExecuteReplyMsg).content.execution_count}]:`\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a markdown cell widget","suites":["cells/widget","MarkdownCell","#constructor()"],"updatePoint":{"line":811,"column":46},"line":811,"code":"      it('should create a markdown cell widget', () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(MarkdownCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should accept a custom contentFactory","suites":["cells/widget","MarkdownCell","#constructor()"],"updatePoint":{"line":817,"column":47},"line":817,"code":"      it('should accept a custom contentFactory', () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(MarkdownCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should set the default mimetype to text/x-ipythongfm","suites":["cells/widget","MarkdownCell","#constructor()"],"updatePoint":{"line":823,"column":62},"line":823,"code":"      it('should set the default mimetype to text/x-ipythongfm', () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        expect(widget.model.mimeType).toEqual('text/x-ipythongfm');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should default to true","suites":["cells/widget","MarkdownCell","#rendered"],"updatePoint":{"line":831,"column":32},"line":831,"code":"      it('should default to true', async () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        Widget.attach(widget, document.body);\n        expect(widget.rendered).toEqual(true);\n        await framePromise();\n        expect(widget.node.classList.contains(RENDERED_CLASS)).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should unrender the widget","suites":["cells/widget","MarkdownCell","#rendered"],"updatePoint":{"line":840,"column":36},"line":840,"code":"      it('should unrender the widget', async () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        Widget.attach(widget, document.body);\n        widget.rendered = false;\n        await framePromise();\n        expect(widget.node.classList.contains(RENDERED_CLASS)).toEqual(false);\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should dispose of the resources held by the widget","suites":["cells/widget","MarkdownCell","#dispose()"],"updatePoint":{"line":852,"column":60},"line":852,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should be safe to call multiple times","suites":["cells/widget","MarkdownCell","#dispose()"],"updatePoint":{"line":859,"column":47},"line":859,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new MarkdownCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should update the widget","suites":["cells/widget","MarkdownCell","#onUpdateRequest()"],"updatePoint":{"line":869,"column":34},"line":869,"code":"      it('should update the widget', () => {\n        const widget = new LogMarkdownCell({\n          model,\n          rendermime,\n          contentFactory\n        }).initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a raw cell widget","suites":["cells/widget","RawCell","#constructor()"],"updatePoint":{"line":886,"column":41},"line":886,"code":"      it('should create a raw cell widget', () => {\n        const model = new RawCellModel({});\n        const widget = new RawCell({ model, contentFactory }).initializeState();\n        expect(widget).toBeInstanceOf(RawCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new cell header","suites":["cells/widget","CellHeader","#constructor()"],"updatePoint":{"line":896,"column":41},"line":896,"code":"      it('should create a new cell header', () => {\n        expect(new CellHeader()).toBeInstanceOf(CellHeader);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a new cell footer","suites":["cells/widget","CellFooter","#constructor()"],"updatePoint":{"line":904,"column":41},"line":904,"code":"      it('should create a new cell footer', () => {\n        expect(new CellFooter()).toBeInstanceOf(CellFooter);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/cells/test"},{"name":"should create a CodeEditor Model","suites":["CodeEditor.Model","#constructor()"],"updatePoint":{"line":19,"column":40},"line":19,"code":"    it('should create a CodeEditor Model', () => {\n      expect(model).toBeInstanceOf(CodeEditor.Model);\n      expect(model.value.text).toBe('');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should create a CodeEditor Model with an initial value","suites":["CodeEditor.Model","#constructor()"],"updatePoint":{"line":24,"column":62},"line":24,"code":"    it('should create a CodeEditor Model with an initial value', () => {\n      const other = new CodeEditor.Model({ value: 'Initial text here' });\n      expect(other).toBeInstanceOf(CodeEditor.Model);\n      expect(other.value.text).toBe('Initial text here');\n      other.dispose();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should create a CodeEditor Model with an initial mimetype","suites":["CodeEditor.Model","#constructor()"],"updatePoint":{"line":31,"column":65},"line":31,"code":"    it('should create a CodeEditor Model with an initial mimetype', () => {\n      const other = new CodeEditor.Model({\n        value: 'import this',\n        mimeType: 'text/x-python'\n      });\n      expect(other).toBeInstanceOf(CodeEditor.Model);\n      expect(other.mimeType).toBe('text/x-python');\n      expect(other.value.text).toBe('import this');\n      other.dispose();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be emitted when the mime type changes","suites":["CodeEditor.Model","#mimeTypeChanged"],"updatePoint":{"line":44,"column":52},"line":44,"code":"    it('should be emitted when the mime type changes', () => {\n      let called = false;\n      model.mimeTypeChanged.connect((sender, args) => {\n        expect(sender).toBe(model);\n        expect(args.oldValue).toBe('text/plain');\n        expect(args.newValue).toBe('text/foo');\n        called = true;\n      });\n      model.mimeType = 'text/foo';\n      expect(called).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the observable value of the model","suites":["CodeEditor.Model","#value"],"updatePoint":{"line":58,"column":51},"line":58,"code":"    it('should be the observable value of the model', () => {\n      let called = false;\n      const handler = (\n        sender: IObservableString,\n        args: IObservableString.IChangedArgs\n      ) => {\n        expect(sender).toBe(model.value);\n        expect(args.type).toBe('set');\n        expect(args.value).toBe('foo');\n        called = true;\n      };\n      model.value.changed.connect(handler);\n      model.value.text = 'foo';\n      expect(called).toBe(true);\n      model.value.changed.disconnect(handler);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle an insert","suites":["CodeEditor.Model","#value"],"updatePoint":{"line":75,"column":31},"line":75,"code":"    it('should handle an insert', () => {\n      let called = false;\n      const handler = (\n        sender: IObservableString,\n        args: IObservableString.IChangedArgs\n      ) => {\n        expect(args.type).toBe('insert');\n        expect(args.value).toBe('foo');\n        called = true;\n      };\n      model.value.changed.connect(handler);\n      model.value.insert(0, 'foo');\n      expect(called).toBe(true);\n      model.value.changed.disconnect(handler);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle a remove","suites":["CodeEditor.Model","#value"],"updatePoint":{"line":91,"column":30},"line":91,"code":"    it('should handle a remove', () => {\n      let called = false;\n      model.value.text = 'foo';\n      const handler = (\n        sender: IObservableString,\n        args: IObservableString.IChangedArgs\n      ) => {\n        expect(args.type).toBe('remove');\n        expect(args.value).toBe('f');\n        called = true;\n      };\n      model.value.changed.connect(handler);\n      model.value.remove(0, 1);\n      expect(called).toBe(true);\n      model.value.changed.disconnect(handler);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the selections associated with the model","suites":["CodeEditor.Model","#selections"],"updatePoint":{"line":110,"column":58},"line":110,"code":"    it('should be the selections associated with the model', () => {\n      expect(model.selections.keys().length).toBe(0);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the mime type of the model","suites":["CodeEditor.Model","#mimeType"],"updatePoint":{"line":116,"column":44},"line":116,"code":"    it('should be the mime type of the model', () => {\n      expect(model.mimeType).toBe('text/plain');\n      model.mimeType = 'text/foo';\n      expect(model.mimeType).toBe('text/foo');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should get the modelDB object associated with the model","suites":["CodeEditor.Model","#modelDB"],"updatePoint":{"line":124,"column":63},"line":124,"code":"    it('should get the modelDB object associated with the model', () => {\n      expect(model.modelDB.has('value')).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should test whether the model is disposed","suites":["CodeEditor.Model","#isDisposed"],"updatePoint":{"line":130,"column":49},"line":130,"code":"    it('should test whether the model is disposed', () => {\n      expect(model.isDisposed).toBe(false);\n      model.dispose();\n      expect(model.isDisposed).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should create a new metadata editor","suites":["codeeditor","JSONEditor","#constructor"],"updatePoint":{"line":58,"column":45},"line":58,"code":"      it('should create a new metadata editor', () => {\n        const newEditor = new JSONEditor({ editorFactory });\n        expect(newEditor).toBeInstanceOf(JSONEditor);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the header node used by the editor","suites":["codeeditor","JSONEditor","#headerNode"],"updatePoint":{"line":65,"column":54},"line":65,"code":"      it('should be the header node used by the editor', () => {\n        expect(Array.from(editor.headerNode.classList)).toEqual(\n          expect.arrayContaining(['jp-JSONEditor-header'])\n        );\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the editor host node used by the editor","suites":["codeeditor","JSONEditor","#editorHostNode"],"updatePoint":{"line":73,"column":59},"line":73,"code":"      it('should be the editor host node used by the editor', () => {\n        expect(Array.from(editor.editorHostNode.classList)).toEqual(\n          expect.arrayContaining(['jp-JSONEditor-host'])\n        );\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the revert button node used by the editor","suites":["codeeditor","JSONEditor","#revertButtonNode"],"updatePoint":{"line":81,"column":61},"line":81,"code":"      it('should be the revert button node used by the editor', () => {\n        expect(\n          editor.revertButtonNode.querySelector(\"[data-icon$='undo']\")\n        ).toBeDefined();\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the commit button node used by the editor","suites":["codeeditor","JSONEditor","#commitButtonNode"],"updatePoint":{"line":89,"column":61},"line":89,"code":"      it('should be the commit button node used by the editor', () => {\n        expect(\n          editor.commitButtonNode.querySelector(\"[data-icon$='check']\")\n        ).toBeDefined();\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be the source of the metadata","suites":["codeeditor","JSONEditor","#source"],"updatePoint":{"line":97,"column":46},"line":97,"code":"      it('should be the source of the metadata', () => {\n        expect(editor.source).toBe(null);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be settable","suites":["codeeditor","JSONEditor","#source"],"updatePoint":{"line":101,"column":28},"line":101,"code":"      it('should be settable', () => {\n        const source = new ObservableJSON();\n        editor.source = source;\n        expect(editor.source).toBe(source);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should update the text area value","suites":["codeeditor","JSONEditor","#source"],"updatePoint":{"line":107,"column":43},"line":107,"code":"      it('should update the text area value', () => {\n        const model = editor.model;\n        expect(model.value.text).toBe('No data!');\n        editor.source = new ObservableJSON();\n        expect(model.value.text).toBe('{}');\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should test whether the editor value is dirty","suites":["codeeditor","JSONEditor","#isDirty"],"updatePoint":{"line":116,"column":55},"line":116,"code":"      it('should test whether the editor value is dirty', () => {\n        expect(editor.isDirty).toBe(false);\n        Widget.attach(editor, document.body);\n        editor.model.value.text = 'a';\n        expect(editor.isDirty).toBe(true);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be dirty if the value changes while focused","suites":["codeeditor","JSONEditor","#isDirty"],"updatePoint":{"line":123,"column":60},"line":123,"code":"      it('should be dirty if the value changes while focused', () => {\n        editor.source = new ObservableJSON();\n        Widget.attach(editor, document.body);\n        editor.editor.focus();\n        expect(editor.isDirty).toBe(false);\n        editor.source.set('foo', 1);\n        expect(editor.isDirty).toBe(true);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should not be set if not focused","suites":["codeeditor","JSONEditor","#isDirty"],"updatePoint":{"line":132,"column":42},"line":132,"code":"      it('should not be set if not focused', () => {\n        editor.source = new ObservableJSON();\n        Widget.attach(editor, document.body);\n        expect(editor.isDirty).toBe(false);\n        editor.source.set('foo', 1);\n        expect(editor.isDirty).toBe(false);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should add the error flag if invalid JSON","suites":["codeeditor","JSONEditor","model.value.changed"],"updatePoint":{"line":142,"column":51},"line":142,"code":"      it('should add the error flag if invalid JSON', () => {\n        editor.model.value.text = 'foo';\n        expect(editor.hasClass('jp-mod-error')).toBe(true);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should show the commit button if the value has changed","suites":["codeeditor","JSONEditor","model.value.changed"],"updatePoint":{"line":147,"column":64},"line":147,"code":"      it('should show the commit button if the value has changed', () => {\n        editor.model.value.text = '{\"foo\": 2}';\n        editor.model.value.text = '{\"foo\": 1}';\n        expect(editor.commitButtonNode.hidden).toBe(false);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should not show the commit button if the value is invalid","suites":["codeeditor","JSONEditor","model.value.changed"],"updatePoint":{"line":153,"column":67},"line":153,"code":"      it('should not show the commit button if the value is invalid', () => {\n        editor.model.value.text = 'foo';\n        expect(editor.commitButtonNode.hidden).toBe(true);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should show the revert button if the value has changed","suites":["codeeditor","JSONEditor","model.value.changed"],"updatePoint":{"line":158,"column":64},"line":158,"code":"      it('should show the revert button if the value has changed', () => {\n        editor.model.value.text = 'foo';\n        expect(editor.revertButtonNode.hidden).toBe(false);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle blur events on the host node","suites":["codeeditor","JSONEditor","#handleEvent()","blur"],"updatePoint":{"line":170,"column":54},"line":170,"code":"        it('should handle blur events on the host node', () => {\n          editor.editor.focus();\n          simulate(editor.editorHostNode, 'blur');\n          expect(editor.events).toEqual(expect.arrayContaining(['blur']));\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should revert to current data if there was no change","suites":["codeeditor","JSONEditor","#handleEvent()","blur"],"updatePoint":{"line":176,"column":64},"line":176,"code":"        it('should revert to current data if there was no change', () => {\n          editor.source = new ObservableJSON();\n          editor.editor.focus();\n          editor.source.set('foo', 1);\n          const model = editor.model;\n          expect(model.value.text).toBe('{}');\n          simulate(editor.editorHostNode, 'blur');\n          expect(model.value.text).toBe('{\\n    \"foo\": 1\\n}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should not revert to current data if there was a change","suites":["codeeditor","JSONEditor","#handleEvent()","blur"],"updatePoint":{"line":186,"column":67},"line":186,"code":"        it('should not revert to current data if there was a change', () => {\n          editor.source = new ObservableJSON();\n          editor.model.value.text = 'foo';\n          editor.source.set('foo', 1);\n          const model = editor.model;\n          expect(model.value.text).toBe('foo');\n          simulate(editor.editorHostNode, 'blur');\n          expect(model.value.text).toBe('foo');\n          expect(editor.commitButtonNode.hidden).toBe(true);\n          expect(editor.revertButtonNode.hidden).toBe(false);\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle click events on the revert button","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":200,"column":59},"line":200,"code":"        it('should handle click events on the revert button', () => {\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.events).toEqual(expect.arrayContaining(['click']));\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should revert the current data","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":205,"column":42},"line":205,"code":"        it('should revert the current data', () => {\n          editor.source = new ObservableJSON();\n          editor.model.value.text = 'foo';\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.model.value.text).toBe('{}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle programmatic changes","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":212,"column":46},"line":212,"code":"        it('should handle programmatic changes', () => {\n          editor.source = new ObservableJSON();\n          editor.model.value.text = 'foo';\n          editor.source.set('foo', 1);\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.model.value.text).toBe('{\\n    \"foo\": 1\\n}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should handle click events on the commit button","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":220,"column":59},"line":220,"code":"        it('should handle click events on the commit button', () => {\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.events).toEqual(expect.arrayContaining(['click']));\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should bail if it is not valid JSON","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":225,"column":47},"line":225,"code":"        it('should bail if it is not valid JSON', () => {\n          editor.source = new ObservableJSON();\n          editor.model.value.text = 'foo';\n          editor.source.set('foo', 1);\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.value.text).toBe('foo');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should override a key that was set programmatically","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":233,"column":63},"line":233,"code":"        it('should override a key that was set programmatically', () => {\n          editor.source = new ObservableJSON();\n          editor.model.value.text = '{\"foo\": 2}';\n          editor.source.set('foo', 1);\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.value.text).toBe('{\\n    \"foo\": 2\\n}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should allow a programmatic key to update","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":241,"column":53},"line":241,"code":"        it('should allow a programmatic key to update', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.value.text = '{\"foo\":1, \"bar\": 2}';\n          editor.source.set('foo', 2);\n          simulate(editor.commitButtonNode, 'click');\n          const expected = '{\\n    \"foo\": 2,\\n    \"bar\": 2\\n}';\n          expect(editor.model.value.text).toBe(expected);\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should allow a key to be added by the user","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":252,"column":54},"line":252,"code":"        it('should allow a key to be added by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.value.text = '{\"foo\":1, \"bar\": 2, \"baz\": 3}';\n          editor.source.set('foo', 2);\n          simulate(editor.commitButtonNode, 'click');\n          const value = '{\\n    \"foo\": 2,\\n    \"bar\": 2,\\n    \"baz\": 3\\n}';\n          expect(editor.model.value.text).toBe(value);\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should allow a key to be removed by the user","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":263,"column":56},"line":263,"code":"        it('should allow a key to be removed by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.value.text = '{\"foo\": 1}';\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.value.text).toBe('{\\n    \"foo\": 1\\n}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should allow a key to be removed programmatically that was not set by the user","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":272,"column":90},"line":272,"code":"        it('should allow a key to be removed programmatically that was not set by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.value.text = '{\"foo\": 1, \"bar\": 3}';\n          editor.source.delete('foo');\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.value.text).toBe('{\\n    \"bar\": 3\\n}');\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should keep a key that was removed programmatically that was changed by the user","suites":["codeeditor","JSONEditor","#handleEvent()","click"],"updatePoint":{"line":282,"column":92},"line":282,"code":"        it('should keep a key that was removed programmatically that was changed by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.value.text = '{\"foo\": 2, \"bar\": 3}';\n          editor.source.set('foo', null);\n          simulate(editor.commitButtonNode, 'click');\n          const expected = '{\\n    \"foo\": 2,\\n    \"bar\": 3\\n}';\n          expect(editor.model.value.text).toBe(expected);\n        });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should add event listeners","suites":["codeeditor","JSONEditor","#onAfterAttach()"],"updatePoint":{"line":296,"column":36},"line":296,"code":"      it('should add event listeners', () => {\n        Widget.attach(editor, document.body);\n        expect(editor.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        editor.editor.focus();\n        simulate(editor.editorHostNode, 'blur');\n        simulate(editor.revertButtonNode, 'click');\n        simulate(editor.commitButtonNode, 'click');\n        expect(editor.events).toEqual(['blur', 'click', 'click']);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should update the editor","suites":["codeeditor","JSONEditor","#onAfterShow()"],"updatePoint":{"line":310,"column":34},"line":310,"code":"      it('should update the editor', async () => {\n        editor.hide();\n        Widget.attach(editor, document.body);\n        editor.show();\n        await framePromise();\n        expect(editor.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should remove event listeners","suites":["codeeditor","JSONEditor","#onBeforeDetach()"],"updatePoint":{"line":322,"column":39},"line":322,"code":"      it('should remove event listeners', () => {\n        Widget.attach(editor, document.body);\n        Widget.detach(editor);\n        expect(editor.methods).toEqual(\n          expect.arrayContaining(['onBeforeDetach'])\n        );\n        editor.editor.focus();\n        simulate(editor.editorHostNode, 'blur');\n        simulate(editor.revertButtonNode, 'click');\n        simulate(editor.commitButtonNode, 'click');\n        expect(editor.events).toEqual([]);\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should update the value","suites":["codeeditor","JSONEditor","#source.changed"],"updatePoint":{"line":337,"column":33},"line":337,"code":"      it('should update the value', () => {\n        editor.source = new ObservableJSON();\n        editor.source.set('foo', 1);\n        expect(editor.model.value.text).toBe('{\\n    \"foo\": 1\\n}');\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should bail if the input is dirty","suites":["codeeditor","JSONEditor","#source.changed"],"updatePoint":{"line":343,"column":43},"line":343,"code":"      it('should bail if the input is dirty', () => {\n        Widget.attach(editor, document.body);\n        editor.source = new ObservableJSON();\n        editor.model.value.text = 'ha';\n        editor.source.set('foo', 2);\n        expect(editor.model.value.text).toBe('ha');\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should bail if the input is focused","suites":["codeeditor","JSONEditor","#source.changed"],"updatePoint":{"line":351,"column":45},"line":351,"code":"      it('should bail if the input is focused', () => {\n        Widget.attach(editor, document.body);\n        editor.model.value.text = '{}';\n        editor.source = new ObservableJSON();\n        editor.editor.focus();\n        editor.source.set('foo', 2);\n        expect(editor.model.value.text).toBe('{}');\n      });","file":"jsoneditor.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be a CodeEditorWrapper","suites":["CodeEditorWrapper","#constructor()"],"updatePoint":{"line":77,"column":37},"line":77,"code":"    it('should be a CodeEditorWrapper', () => {\n      expect(widget).toBeInstanceOf(CodeEditorWrapper);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should add a focus listener","suites":["CodeEditorWrapper","#constructor()"],"updatePoint":{"line":81,"column":35},"line":81,"code":"    it('should add a focus listener', () => {\n      widget.node.tabIndex = -1;\n      simulate(widget.node, 'focus');\n      const editor = widget.editor as LogEditor;\n      expect(editor.events).toEqual(expect.arrayContaining(['focus']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be a a code editor","suites":["CodeEditorWrapper","#editor"],"updatePoint":{"line":90,"column":33},"line":90,"code":"    it('should be a a code editor', () => {\n      expect(widget.editor.getOption('lineNumbers')).toBe(false);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should dispose of the resources used by the widget","suites":["CodeEditorWrapper","#dispose()"],"updatePoint":{"line":96,"column":58},"line":96,"code":"    it('should dispose of the resources used by the widget', () => {\n      expect(widget.isDisposed).toBe(false);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should remove the focus listener","suites":["CodeEditorWrapper","#dispose()"],"updatePoint":{"line":104,"column":40},"line":104,"code":"    it('should remove the focus listener', () => {\n      const editor = widget.editor as LogEditor;\n      expect(editor.isDisposed).toBe(false);\n      widget.dispose();\n      expect(editor.isDisposed).toBe(true);\n\n      widget.node.tabIndex = -1;\n      simulate(widget.node, 'focus');\n      expect(editor.events).toEqual(expect.not.arrayContaining(['focus']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should be a no-op if the editor was not resized","suites":["CodeEditorWrapper","#handleEvent()","focus"],"updatePoint":{"line":118,"column":57},"line":118,"code":"      it('should be a no-op if the editor was not resized', () => {\n        Widget.attach(widget, document.body);\n        const editor = widget.editor as LogEditor;\n        editor.methods = [];\n        simulate(editor.editor.getInputField(), 'focus');\n        expect(editor.methods).toEqual([]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should refresh if editor was resized","suites":["CodeEditorWrapper","#handleEvent()","focus"],"updatePoint":{"line":126,"column":46},"line":126,"code":"      it('should refresh if editor was resized', () => {\n        Widget.attach(widget, document.body);\n        const editor = widget.editor as LogEditor;\n        MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n        editor.methods = [];\n        simulate(editor.editor.getInputField(), 'focus');\n        expect(editor.methods).toEqual(['refresh']);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should focus the editor","suites":["CodeEditorWrapper","#onActivateRequest()"],"updatePoint":{"line":138,"column":31},"line":138,"code":"    it('should focus the editor', () => {\n      Widget.attach(widget, document.body);\n      MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n      expect(widget.methods).toEqual(\n        expect.arrayContaining(['onActivateRequest'])\n      );\n      expect(widget.editor.hasFocus()).toBe(true);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should refresh the editor","suites":["CodeEditorWrapper","#onAfterAttach()"],"updatePoint":{"line":149,"column":33},"line":149,"code":"    it('should refresh the editor', async () => {\n      Widget.attach(widget, document.body);\n      const editor = widget.editor as LogEditor;\n      await framePromise();\n      expect(editor.methods).toEqual(expect.arrayContaining(['refresh']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should refresh the editor","suites":["CodeEditorWrapper","#onAfterShow()"],"updatePoint":{"line":158,"column":33},"line":158,"code":"    it('should refresh the editor', async () => {\n      widget.hide();\n      Widget.attach(widget, document.body);\n      const editor = widget.editor as LogEditor;\n      expect(editor.methods).toEqual(expect.not.arrayContaining(['refresh']));\n      widget.show();\n      expect(widget.methods).toEqual(expect.arrayContaining(['onAfterShow']));\n      await framePromise();\n      expect(editor.methods).toEqual(expect.arrayContaining(['refresh']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should set the size of the editor","suites":["CodeEditorWrapper","#onResize()"],"updatePoint":{"line":171,"column":41},"line":171,"code":"    it('should set the size of the editor', () => {\n      const msg = new Widget.ResizeMessage(10, 10);\n      const editor = widget.editor as LogEditor;\n      MessageLoop.sendMessage(widget, msg);\n      expect(editor.methods).toEqual(expect.arrayContaining(['setSize']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should refresh the editor","suites":["CodeEditorWrapper","#onResize()"],"updatePoint":{"line":178,"column":33},"line":178,"code":"    it('should refresh the editor', () => {\n      const editor = widget.editor as LogEditor;\n      Widget.attach(widget, document.body);\n      editor.focus();\n      editor.methods = [];\n      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n      expect(editor.methods).toEqual(expect.arrayContaining(['refresh']));\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should defer the refresh until focused","suites":["CodeEditorWrapper","#onResize()"],"updatePoint":{"line":187,"column":46},"line":187,"code":"    it('should defer the refresh until focused', () => {\n      const editor = widget.editor as LogEditor;\n      Widget.attach(widget, document.body);\n      editor.methods = [];\n      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n      expect(editor.methods).toEqual([]);\n      simulate(editor.editor.getInputField(), 'focus');\n      expect(editor.methods).toEqual(['refresh']);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/codeeditor/test"},{"name":"should create a CodeMirrorEditor","suites":["CodeMirrorEditor","#constructor()"],"updatePoint":{"line":43,"column":40},"line":43,"code":"    it('should create a CodeMirrorEditor', () => {\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should emit a signal when the top edge is requested","suites":["CodeMirrorEditor","#edgeRequested"],"updatePoint":{"line":49,"column":59},"line":49,"code":"    it('should emit a signal when the top edge is requested', () => {\n      let edge: CodeEditor.EdgeLocation | null = null;\n      const event = generate('keydown', { keyCode: UP_ARROW });\n      const listener = (sender: any, args: CodeEditor.EdgeLocation) => {\n        edge = args;\n      };\n      editor.edgeRequested.connect(listener);\n      expect(edge).toBeNull();\n      editor.editor.triggerOnKeyDown(event);\n      expect(edge).toBe('top');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should emit a signal when the bottom edge is requested","suites":["CodeMirrorEditor","#edgeRequested"],"updatePoint":{"line":61,"column":62},"line":61,"code":"    it('should emit a signal when the bottom edge is requested', () => {\n      let edge: CodeEditor.EdgeLocation | null = null;\n      const event = generate('keydown', { keyCode: DOWN_ARROW });\n      const listener = (sender: any, args: CodeEditor.EdgeLocation) => {\n        edge = args;\n      };\n      editor.edgeRequested.connect(listener);\n      expect(edge).toBeNull();\n      editor.editor.triggerOnKeyDown(event);\n      expect(edge).toBe('bottom');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should be the unique id of the editor","suites":["CodeMirrorEditor","#uuid"],"updatePoint":{"line":75,"column":45},"line":75,"code":"    it('should be the unique id of the editor', () => {\n      expect(editor.uuid).toBeTruthy();\n      const uuid = 'foo';\n      editor = new LogFileEditor({ model, host, uuid });\n      expect(editor.uuid).toBe('foo');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should be the selection style of the editor","suites":["CodeMirrorEditor","#selectionStyle"],"updatePoint":{"line":84,"column":51},"line":84,"code":"    it('should be the selection style of the editor', () => {\n      expect(editor.selectionStyle).toEqual(CodeEditor.defaultSelectionStyle);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should be settable","suites":["CodeMirrorEditor","#selectionStyle"],"updatePoint":{"line":88,"column":26},"line":88,"code":"    it('should be settable', () => {\n      const style = {\n        className: 'foo',\n        displayName: 'bar',\n        color: 'black'\n      };\n      editor.selectionStyle = style;\n      expect(editor.selectionStyle).toEqual(style);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should be the codemirror editor wrapped by the editor","suites":["CodeMirrorEditor","#editor"],"updatePoint":{"line":100,"column":61},"line":100,"code":"    it('should be the codemirror editor wrapped by the editor', () => {\n      const cm = editor.editor;\n      expect(cm.getDoc()).toBe(editor.doc);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should be the codemirror doc wrapped by the editor","suites":["CodeMirrorEditor","#doc"],"updatePoint":{"line":107,"column":58},"line":107,"code":"    it('should be the codemirror doc wrapped by the editor', () => {\n      const doc = editor.doc;\n      expect(doc.getEditor()).toBe(editor.editor);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the number of lines in the editor","suites":["CodeMirrorEditor","#lineCount"],"updatePoint":{"line":114,"column":52},"line":114,"code":"    it('should get the number of lines in the editor', () => {\n      expect(editor.lineCount).toBe(1);\n      editor.model.value.text = 'foo\\nbar\\nbaz';\n      expect(editor.lineCount).toBe(3);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get whether line numbers should be shown","suites":["CodeMirrorEditor","#getOption()"],"updatePoint":{"line":122,"column":55},"line":122,"code":"    it('should get whether line numbers should be shown', () => {\n      expect(editor.getOption('lineNumbers')).toBe(false);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get whether horizontally scrolling should be used","suites":["CodeMirrorEditor","#getOption()"],"updatePoint":{"line":126,"column":64},"line":126,"code":"    it('should get whether horizontally scrolling should be used', () => {\n      expect(editor.getOption('lineWrap')).toBe('on');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get whether the editor is readonly","suites":["CodeMirrorEditor","#getOption()"],"updatePoint":{"line":130,"column":49},"line":130,"code":"    it('should get whether the editor is readonly', () => {\n      expect(editor.getOption('readOnly')).toBe(false);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set whether line numbers should be shown","suites":["CodeMirrorEditor","#setOption()"],"updatePoint":{"line":136,"column":55},"line":136,"code":"    it('should set whether line numbers should be shown', () => {\n      editor.setOption('lineNumbers', true);\n      expect(editor.getOption('lineNumbers')).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set whether horizontally scrolling should be used","suites":["CodeMirrorEditor","#setOption()"],"updatePoint":{"line":141,"column":64},"line":141,"code":"    it('should set whether horizontally scrolling should be used', () => {\n      editor.setOption('lineWrap', 'off');\n      expect(editor.getOption('lineWrap')).toBe('off');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set whether the editor is readonly","suites":["CodeMirrorEditor","#setOption()"],"updatePoint":{"line":146,"column":49},"line":146,"code":"    it('should set whether the editor is readonly', () => {\n      editor.setOption('readOnly', true);\n      expect(editor.getOption('readOnly')).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the model used by the editor","suites":["CodeMirrorEditor","#model"],"updatePoint":{"line":153,"column":47},"line":153,"code":"    it('should get the model used by the editor', () => {\n      expect(editor.model).toBe(model);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the text height of a line in the editor","suites":["CodeMirrorEditor","#lineHeight"],"updatePoint":{"line":159,"column":58},"line":159,"code":"    it('should get the text height of a line in the editor', () => {\n      expect(editor.lineHeight).toBeGreaterThan(0);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the character width in the editor","suites":["CodeMirrorEditor","#charWidth"],"updatePoint":{"line":165,"column":52},"line":165,"code":"    it('should get the character width in the editor', () => {\n      expect(editor.charWidth).toBeGreaterThan(0);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should test whether the editor is disposed","suites":["CodeMirrorEditor","#isDisposed"],"updatePoint":{"line":171,"column":50},"line":171,"code":"    it('should test whether the editor is disposed', () => {\n      expect(editor.isDisposed).toBe(false);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should dispose of the resources used by the editor","suites":["CodeMirrorEditor","#dispose()"],"updatePoint":{"line":179,"column":58},"line":179,"code":"    it('should dispose of the resources used by the editor', () => {\n      expect(editor.isDisposed).toBe(false);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get a line of text","suites":["CodeMirrorEditor","#getLine()"],"updatePoint":{"line":189,"column":33},"line":189,"code":"    it('should get a line of text', () => {\n      model.value.text = 'foo\\nbar';\n      expect(editor.getLine(0)).toBe('foo');\n      expect(editor.getLine(1)).toBe('bar');\n      expect(editor.getLine(2)).toBeUndefined();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the offset for a given position","suites":["CodeMirrorEditor","#getOffsetAt()"],"updatePoint":{"line":198,"column":50},"line":198,"code":"    it('should get the offset for a given position', () => {\n      model.value.text = 'foo\\nbar';\n      let pos = {\n        column: 2,\n        line: 1\n      };\n      expect(editor.getOffsetAt(pos)).toBe(6);\n      pos = {\n        column: 2,\n        line: 5\n      };\n      expect(editor.getOffsetAt(pos)).toBe(7);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the position for a given offset","suites":["CodeMirrorEditor","#getPositionAt()"],"updatePoint":{"line":214,"column":50},"line":214,"code":"    it('should get the position for a given offset', () => {\n      model.value.text = 'foo\\nbar';\n      let pos = editor.getPositionAt(6);\n      expect(pos.column).toBe(2);\n      expect(pos.line).toBe(1);\n      pos = editor.getPositionAt(101);\n      expect(pos.column).toBe(3);\n      expect(pos.line).toBe(1);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should undo one edit","suites":["CodeMirrorEditor","#undo()"],"updatePoint":{"line":226,"column":28},"line":226,"code":"    it('should undo one edit', () => {\n      model.value.text = 'foo';\n      editor.undo();\n      expect(model.value.text).toBe('');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should redo one undone edit","suites":["CodeMirrorEditor","#redo()"],"updatePoint":{"line":234,"column":35},"line":234,"code":"    it('should redo one undone edit', () => {\n      model.value.text = 'foo';\n      editor.undo();\n      editor.redo();\n      expect(model.value.text).toBe('foo');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should clear the undo history","suites":["CodeMirrorEditor","#clearHistory()"],"updatePoint":{"line":243,"column":37},"line":243,"code":"    it('should clear the undo history', () => {\n      model.value.text = 'foo';\n      editor.clearHistory();\n      editor.undo();\n      expect(model.value.text).toBe('foo');\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should give focus to the editor","suites":["CodeMirrorEditor","#focus()"],"updatePoint":{"line":252,"column":39},"line":252,"code":"    it('should give focus to the editor', () => {\n      expect(host.contains(document.activeElement)).toBe(false);\n      editor.focus();\n      expect(host.contains(document.activeElement)).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should test whether the editor has focus","suites":["CodeMirrorEditor","#hasFocus()"],"updatePoint":{"line":260,"column":48},"line":260,"code":"    it('should test whether the editor has focus', () => {\n      expect(editor.hasFocus()).toBe(false);\n      editor.focus();\n      expect(editor.hasFocus()).toBe(true);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should blur the editor","suites":["CodeMirrorEditor","#blur()"],"updatePoint":{"line":268,"column":30},"line":268,"code":"    it('should blur the editor', () => {\n      editor.focus();\n      expect(host.contains(document.activeElement)).toBe(true);\n      editor.blur();\n      expect(host.contains(document.activeElement)).toBe(false);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should add the focus class to the host","suites":["CodeMirrorEditor","#handleEvent","focus"],"updatePoint":{"line":278,"column":48},"line":278,"code":"      it('should add the focus class to the host', () => {\n        simulate(editor.editor.getInputField(), 'focus');\n        expect(host.classList.contains('jp-mod-focused')).toBe(true);\n      });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should remove the focus class from the host","suites":["CodeMirrorEditor","#handleEvent","blur"],"updatePoint":{"line":285,"column":53},"line":285,"code":"      it('should remove the focus class from the host', () => {\n        simulate(editor.editor.getInputField(), 'focus');\n        expect(host.classList.contains('jp-mod-focused')).toBe(true);\n        simulate(editor.editor.getInputField(), 'blur');\n        expect(host.classList.contains('jp-mod-focused')).toBe(false);\n      });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should repaint the editor","suites":["CodeMirrorEditor","#refresh()"],"updatePoint":{"line":295,"column":33},"line":295,"code":"    it('should repaint the editor', () => {\n      editor.refresh();\n      expect(editor).toBeTruthy();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should add a keydown handler to the editor","suites":["CodeMirrorEditor","#addKeydownHandler()"],"updatePoint":{"line":302,"column":50},"line":302,"code":"    it('should add a keydown handler to the editor', () => {\n      let called = 0;\n      const handler = () => {\n        called++;\n        return true;\n      };\n      const disposable = editor.addKeydownHandler(handler);\n      let evt = generate('keydown', { keyCode: ENTER });\n      editor.editor.triggerOnKeyDown(evt);\n      expect(called).toBe(1);\n      disposable.dispose();\n      expect(disposable.isDisposed).toBe(true);\n\n      evt = generate('keydown', { keyCode: ENTER });\n      editor.editor.triggerOnKeyDown(evt);\n      expect(called).toBe(1);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set the size of the editor in pixels","suites":["CodeMirrorEditor","#setSize()"],"updatePoint":{"line":322,"column":51},"line":322,"code":"    it('should set the size of the editor in pixels', () => {\n      editor.setSize({ width: 100, height: 100 });\n      editor.setSize(null);\n      expect(editor).toBeTruthy();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should reveal the given position in the editor","suites":["CodeMirrorEditor","#revealPosition()"],"updatePoint":{"line":330,"column":54},"line":330,"code":"    it('should reveal the given position in the editor', () => {\n      model.value.text = TEXT;\n      editor.revealPosition({ line: 50, column: 0 });\n      expect(editor).toBeTruthy();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should reveal the given selection in the editor","suites":["CodeMirrorEditor","#revealSelection()"],"updatePoint":{"line":338,"column":55},"line":338,"code":"    it('should reveal the given selection in the editor', () => {\n      model.value.text = TEXT;\n      const start = { line: 50, column: 0 };\n      const end = { line: 52, column: 0 };\n      editor.setSelection({ start, end });\n      editor.revealSelection(editor.getSelection());\n      expect(editor).toBeTruthy();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the window coordinates given a cursor position","suites":["CodeMirrorEditor","#getCoordinateForPosition()"],"updatePoint":{"line":349,"column":65},"line":349,"code":"    it('should get the window coordinates given a cursor position', () => {\n      model.value.text = TEXT;\n      const coord = editor.getCoordinateForPosition({ line: 10, column: 1 });\n      if (typeof process !== 'undefined') {\n        // eslint-disable-next-line jest/no-conditional-expect\n        expect(coord.left).toBe(0);\n      } else {\n        // eslint-disable-next-line jest/no-conditional-expect\n        expect(coord.left).toBeGreaterThan(0);\n      }\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the window coordinates given a cursor position","suites":["CodeMirrorEditor","#getPositionForCoordinate()"],"updatePoint":{"line":363,"column":65},"line":363,"code":"    it('should get the window coordinates given a cursor position', () => {\n      model.value.text = TEXT;\n      const coord = editor.getCoordinateForPosition({ line: 10, column: 1 });\n      const newPos = editor.getPositionForCoordinate(coord)!;\n      expect(newPos.line).toBeTruthy();\n      expect(newPos.column).toBeTruthy();\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the primary position of the cursor","suites":["CodeMirrorEditor","#getCursorPosition()"],"updatePoint":{"line":373,"column":53},"line":373,"code":"    it('should get the primary position of the cursor', () => {\n      model.value.text = TEXT;\n      let pos = editor.getCursorPosition();\n      expect(pos.line).toBe(0);\n      expect(pos.column).toBe(0);\n\n      editor.setCursorPosition({ line: 12, column: 3 });\n      pos = editor.getCursorPosition();\n      expect(pos.line).toBe(12);\n      expect(pos.column).toBe(3);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set the primary position of the cursor","suites":["CodeMirrorEditor","#setCursorPosition()"],"updatePoint":{"line":387,"column":53},"line":387,"code":"    it('should set the primary position of the cursor', () => {\n      model.value.text = TEXT;\n      editor.setCursorPosition({ line: 12, column: 3 });\n      const pos = editor.getCursorPosition();\n      expect(pos.line).toBe(12);\n      expect(pos.column).toBe(3);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the primary selection of the editor","suites":["CodeMirrorEditor","#getSelection()"],"updatePoint":{"line":397,"column":54},"line":397,"code":"    it('should get the primary selection of the editor', () => {\n      const selection = editor.getSelection();\n      expect(selection.start.line).toBe(0);\n      expect(selection.end.line).toBe(0);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set the primary selection of the editor","suites":["CodeMirrorEditor","#setSelection()"],"updatePoint":{"line":405,"column":54},"line":405,"code":"    it('should set the primary selection of the editor', () => {\n      model.value.text = TEXT;\n      const start = { line: 50, column: 0 };\n      const end = { line: 52, column: 0 };\n      editor.setSelection({ start, end });\n      expect(editor.getSelection().start).toEqual(start);\n      expect(editor.getSelection().end).toEqual(end);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should remove any secondary cursors","suites":["CodeMirrorEditor","#setSelection()"],"updatePoint":{"line":414,"column":43},"line":414,"code":"    it('should remove any secondary cursors', () => {\n      model.value.text = TEXT;\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      editor.setSelection(range1);\n      expect(editor.getSelections().length).toBe(1);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should get the selections for all the cursors","suites":["CodeMirrorEditor","#getSelections()"],"updatePoint":{"line":431,"column":53},"line":431,"code":"    it('should get the selections for all the cursors', () => {\n      model.value.text = TEXT;\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      const selections = editor.getSelections();\n      expect(selections[0].start.line).toBe(50);\n      expect(selections[1].end.line).toBe(54);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set the selections for all the cursors","suites":["CodeMirrorEditor","#setSelections()"],"updatePoint":{"line":449,"column":53},"line":449,"code":"    it('should set the selections for all the cursors', () => {\n      model.value.text = TEXT;\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      const selections = editor.getSelections();\n      expect(selections[0].start.line).toBe(50);\n      expect(selections[1].end.line).toBe(54);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should set a default selection for an empty array","suites":["CodeMirrorEditor","#setSelections()"],"updatePoint":{"line":465,"column":57},"line":465,"code":"    it('should set a default selection for an empty array', () => {\n      model.value.text = TEXT;\n      editor.setSelections([]);\n      const selection = editor.getSelection();\n      expect(selection.start.line).toBe(0);\n      expect(selection.end.line).toBe(0);\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should run when there is a keydown event on the editor","suites":["CodeMirrorEditor","#onKeydown()"],"updatePoint":{"line":475,"column":62},"line":475,"code":"    it('should run when there is a keydown event on the editor', () => {\n      const event = generate('keydown', { keyCode: UP_ARROW });\n      expect(editor.methods).toEqual(expect.not.arrayContaining(['onKeydown']));\n      editor.editor.triggerOnKeyDown(event);\n      expect(editor.methods).toEqual(expect.arrayContaining(['onKeydown']));\n    });","file":"editor.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a CodeMirrorEditorFactory","suites":["CodeMirrorEditorFactory","#constructor()"],"updatePoint":{"line":38,"column":47},"line":38,"code":"    it('should create a CodeMirrorEditorFactory', () => {\n      const factory = new CodeMirrorEditorFactory();\n      expect(factory).toBeInstanceOf(CodeMirrorEditorFactory);\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a CodeMirrorEditorFactory with options","suites":["CodeMirrorEditorFactory","#constructor()"],"updatePoint":{"line":43,"column":60},"line":43,"code":"    it('should create a CodeMirrorEditorFactory with options', () => {\n      const factory = new ExposeCodeMirrorEditorFactory(options);\n      expect(factory).toBeInstanceOf(CodeMirrorEditorFactory);\n      expect(factory.inlineCodeMirrorConfig.extraKeys).toEqual(\n        options.extraKeys\n      );\n      expect(factory.documentCodeMirrorConfig.extraKeys).toEqual(\n        options.extraKeys\n      );\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a new editor","suites":["CodeMirrorEditorFactory","#newInlineEditor"],"updatePoint":{"line":56,"column":34},"line":56,"code":"    it('should create a new editor', () => {\n      const factory = new CodeMirrorEditorFactory();\n      const editor = factory.newInlineEditor({ host, model });\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      editor.dispose();\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a new editor with given options","suites":["CodeMirrorEditorFactory","#newInlineEditor"],"updatePoint":{"line":63,"column":53},"line":63,"code":"    it('should create a new editor with given options', () => {\n      const factory = new CodeMirrorEditorFactory(options);\n      const editor = factory.newInlineEditor({\n        host,\n        model\n      }) as CodeMirrorEditor;\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      for (const key in Object.keys(options)) {\n        const option = key as keyof CodeMirrorEditor.IConfig;\n        expect(editor.getOption(option)).toBe(options[option]);\n      }\n      editor.dispose();\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a new editor","suites":["CodeMirrorEditorFactory","#newDocumentEditor"],"updatePoint":{"line":79,"column":34},"line":79,"code":"    it('should create a new editor', () => {\n      const factory = new CodeMirrorEditorFactory();\n      const editor = factory.newDocumentEditor({ host, model });\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      editor.dispose();\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a new editor with given options","suites":["CodeMirrorEditorFactory","#newDocumentEditor"],"updatePoint":{"line":86,"column":53},"line":86,"code":"    it('should create a new editor with given options', () => {\n      const factory = new CodeMirrorEditorFactory(options);\n      const editor = factory.newDocumentEditor({\n        host,\n        model\n      }) as CodeMirrorEditor;\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      for (const key in Object.keys(options)) {\n        const option = key as keyof CodeMirrorEditor.IConfig;\n        expect(editor.getOption(option)).toBe(options[option]);\n      }\n      editor.dispose();\n    });","file":"factory.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should load a defined spec","suites":["Mode","#ensure"],"updatePoint":{"line":102,"column":34},"line":102,"code":"    it('should load a defined spec', async () => {\n      CodeMirror.modeInfo.push(fakeMode('foo'));\n      CodeMirror.defineMode('foo', () => {\n        return {};\n      });\n      const spec = (await Mode.ensure('text/foo'))!;\n      expect(spec.name).toBe('FOO');\n    });","file":"mode.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should load a bundled spec","suites":["Mode","#ensure"],"updatePoint":{"line":111,"column":34},"line":111,"code":"    it('should load a bundled spec', async () => {\n      const spec = (await Mode.ensure('application/json'))!;\n      expect(spec.name).toBe('JSON');\n    });","file":"mode.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should add a spec loader","suites":["Mode","#ensure"],"updatePoint":{"line":116,"column":32},"line":116,"code":"    it('should add a spec loader', async () => {\n      let called = 0;\n      let loaded = 0;\n\n      Mode.addSpecLoader(async spec => {\n        called++;\n        if (spec.mode !== 'bar') {\n          return false;\n        }\n        loaded++;\n        return true;\n      }, 42);\n\n      CodeMirror.modeInfo.push(fakeMode('bar'));\n\n      let spec = await Mode.ensure('bar');\n      expect(called).toBe(1);\n      expect(loaded).toBe(1);\n      expect(spec!.name).toBe('BAR');\n\n      spec = await Mode.ensure('python');\n      expect(called).toBe(1);\n      expect(loaded).toBe(1);\n\n      try {\n        spec = await Mode.ensure('APL');\n      } catch (err) {\n        // apparently one cannot use webpack `require` in jest\n      }\n      expect(called).toBe(2);\n      expect(loaded).toBe(1);\n    });","file":"mode.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should default to plain text","suites":["Mode","#ensure"],"updatePoint":{"line":149,"column":36},"line":149,"code":"    it('should default to plain text', async () => {\n      const spec = (await Mode.ensure('this is not a mode'))!;\n      expect(spec.name).toBe('Plain Text');\n    });","file":"mode.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a simple mode","suites":["Mode","#ensure"],"updatePoint":{"line":154,"column":35},"line":154,"code":"    it('should create a simple mode', async () => {\n      CodeMirror.modeInfo.push(fakeMode('baz'));\n      CodeMirror.defineSimpleMode('baz', FAKE_SIMPLE_STATES);\n      const spec = (await Mode.ensure('text/baz'))!;\n      expect(spec.name).toBe('BAZ');\n    });","file":"mode.spec.ts","skipped":false,"dir":"packages/codemirror/test"},{"name":"should create a completer handler","suites":["@jupyterlab/completer","CompletionHandler","#constructor()"],"updatePoint":{"line":65,"column":43},"line":65,"code":"      it('should create a completer handler', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        expect(handler).toBeInstanceOf(CompletionHandler);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["@jupyterlab/completer","CompletionHandler","#editor"],"updatePoint":{"line":75,"column":32},"line":75,"code":"      it('should default to null', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        expect(handler.editor).toBeNull();\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be settable","suites":["@jupyterlab/completer","CompletionHandler","#editor"],"updatePoint":{"line":83,"column":28},"line":83,"code":"      it('should be settable', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        const widget = createEditorWidget();\n        expect(handler.editor).toBeNull();\n        handler.editor = widget.editor;\n        expect(handler.editor).toBe(widget.editor);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be resettable","suites":["@jupyterlab/completer","CompletionHandler","#editor"],"updatePoint":{"line":94,"column":30},"line":94,"code":"      it('should be resettable', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        const one = createEditorWidget();\n        const two = createEditorWidget();\n        expect(handler.editor).toBeNull();\n        handler.editor = one.editor;\n        expect(handler.editor).toBe(one.editor);\n        handler.editor = two.editor;\n        expect(handler.editor).toBe(two.editor);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should remove the completer active and enabled classes of the old editor","suites":["@jupyterlab/completer","CompletionHandler","#editor"],"updatePoint":{"line":108,"column":82},"line":108,"code":"      it('should remove the completer active and enabled classes of the old editor', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        const widget = createEditorWidget();\n        handler.editor = widget.editor;\n        widget.toggleClass('jp-mod-completer-enabled');\n        widget.toggleClass('jp-mod-completer-active');\n        handler.editor = null;\n        expect(widget.hasClass('jp-mod-completer-enabled')).toBe(false);\n        expect(widget.hasClass('jp-mod-completer-active')).toBe(false);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be true if handler has been disposed","suites":["@jupyterlab/completer","CompletionHandler","#isDisposed"],"updatePoint":{"line":124,"column":53},"line":124,"code":"      it('should be true if handler has been disposed', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should dispose of the handler resources","suites":["@jupyterlab/completer","CompletionHandler","#dispose()"],"updatePoint":{"line":136,"column":49},"line":136,"code":"      it('should dispose of the handler resources', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/completer","CompletionHandler","#dispose()"],"updatePoint":{"line":146,"column":47},"line":146,"code":"      it('should be safe to call multiple times', () => {\n        const handler = new CompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should fire when the active editor emits a text change","suites":["@jupyterlab/completer","CompletionHandler","#onTextChanged()"],"updatePoint":{"line":159,"column":64},"line":159,"code":"      it('should fire when the active editor emits a text change', () => {\n        const handler = new TestCompletionHandler({\n          connector,\n          completer: new Completer({ editor: null })\n        });\n        handler.editor = createEditorWidget().editor;\n        expect(handler.methods).toEqual(\n          expect.not.arrayContaining(['onTextChanged'])\n        );\n        handler.editor.model.value.text = 'foo';\n        expect(handler.methods).toEqual(\n          expect.arrayContaining(['onTextChanged'])\n        );\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should call model change handler if model exists","suites":["@jupyterlab/completer","CompletionHandler","#onTextChanged()"],"updatePoint":{"line":174,"column":58},"line":174,"code":"      it('should call model change handler if model exists', () => {\n        const completer = new Completer({\n          editor: null,\n          model: new TestCompleterModel()\n        });\n        const handler = new TestCompletionHandler({ completer, connector });\n        const editor = createEditorWidget().editor;\n        const model = completer.model as TestCompleterModel;\n\n        handler.editor = editor;\n        expect(model.methods).toEqual(\n          expect.not.arrayContaining(['handleTextChange'])\n        );\n        editor.model.value.text = 'bar';\n        editor.setCursorPosition({ line: 0, column: 2 });\n        // This signal is emitted (again) because the cursor position that\n        // a natural user would create need to be recreated here.\n        (editor.model.value.changed as any).emit({ type: 'set', value: 'bar' });\n        expect(model.methods).toEqual(\n          expect.arrayContaining(['handleTextChange'])\n        );\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should fire when the completer widget emits a signal","suites":["@jupyterlab/completer","CompletionHandler","#onCompletionSelected()"],"updatePoint":{"line":199,"column":62},"line":199,"code":"      it('should fire when the completer widget emits a signal', () => {\n        const completer = new Completer({ editor: null });\n        const handler = new TestCompletionHandler({ completer, connector });\n\n        expect(handler.methods).toEqual(\n          expect.not.arrayContaining(['onCompletionSelected'])\n        );\n        (completer.selected as any).emit('foo');\n        expect(handler.methods).toEqual(\n          expect.arrayContaining(['onCompletionSelected'])\n        );\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should call model create patch method if model exists","suites":["@jupyterlab/completer","CompletionHandler","#onCompletionSelected()"],"updatePoint":{"line":212,"column":63},"line":212,"code":"      it('should call model create patch method if model exists', () => {\n        const completer = new Completer({\n          editor: null,\n          model: new TestCompleterModel()\n        });\n        const handler = new TestCompletionHandler({ completer, connector });\n        const model = completer.model as TestCompleterModel;\n\n        handler.editor = createEditorWidget().editor;\n        expect(model.methods).toEqual(\n          expect.not.arrayContaining(['createPatch'])\n        );\n        (completer.selected as any).emit('foo');\n        expect(model.methods).toEqual(expect.arrayContaining(['createPatch']));\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should update cell if patch exists","suites":["@jupyterlab/completer","CompletionHandler","#onCompletionSelected()"],"updatePoint":{"line":228,"column":44},"line":228,"code":"      it('should update cell if patch exists', () => {\n        const model = new CompleterModel();\n        const patch = 'foobar';\n        const completer = new Completer({ editor: null, model });\n        const handler = new TestCompletionHandler({ completer, connector });\n        const editor = createEditorWidget().editor;\n        const text = 'eggs\\nfoo # comment\\nbaz';\n        const want = 'eggs\\nfoobar # comment\\nbaz';\n        const line = 1;\n        const column = 5; // this sets the cursor after the \"#\" sign - not in the mid of the replaced word\n        const request: Completer.ITextState = {\n          column,\n          line,\n          lineHeight: 0,\n          charWidth: 0,\n          coords: null,\n          text\n        };\n\n        handler.editor = editor;\n        handler.editor.model.value.text = text;\n        handler.editor.setCursorPosition({ line, column: column + 3 });\n        model.original = request;\n        model.cursor = { start: column, end: column + 3 };\n        (completer.selected as any).emit(patch);\n        expect(handler.editor.model.value.text).toBe(want);\n        expect(handler.editor.getCursorPosition()).toEqual({\n          line,\n          column: column + 6\n        });\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be undoable and redoable","suites":["@jupyterlab/completer","CompletionHandler","#onCompletionSelected()"],"updatePoint":{"line":260,"column":41},"line":260,"code":"      it('should be undoable and redoable', () => {\n        const model = new CompleterModel();\n        const patch = 'foobar';\n        const completer = new Completer({ editor: null, model });\n        const handler = new TestCompletionHandler({ completer, connector });\n        const editor = createEditorWidget().editor;\n        const text = 'eggs\\nfoo # comment\\nbaz';\n        const want = 'eggs\\nfoobar # comment\\nbaz';\n        const line = 1;\n        const column = 5;\n        const request: Completer.ITextState = {\n          column,\n          line,\n          lineHeight: 0,\n          charWidth: 0,\n          coords: null,\n          text\n        };\n\n        handler.editor = editor;\n        handler.editor.model.value.text = text;\n        handler.editor.model.sharedModel.clearUndoHistory();\n        handler.editor.setCursorPosition({ line, column: column + 3 });\n        model.original = request;\n        model.cursor = { start: column, end: column + 3 };\n        // Make the completion, check its value and cursor position.\n        (completer.selected as any).emit(patch);\n        expect(editor.model.value.text).toBe(want);\n        expect(editor.getCursorPosition()).toEqual({\n          line,\n          column: column + 6\n        });\n        // Undo the completion, check its value and cursor position.\n        editor.undo();\n        expect(editor.model.value.text).toBe(text);\n        expect(editor.getCursorPosition()).toEqual({\n          line,\n          column: column + 3\n        });\n        // Redo the completion, check its value and cursor position.\n        editor.redo();\n        expect(editor.model.value.text).toBe(want);\n        expect(editor.getCursorPosition()).toEqual({\n          line,\n          column: column + 6\n        });\n      });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should update cursor position after autocomplete on empty word","suites":["@jupyterlab/completer","CompletionHandler","#onCompletionSelected()"],"updatePoint":{"line":309,"column":70},"line":309,"code":"    it('should update cursor position after autocomplete on empty word', () => {\n      const model = new CompleterModel();\n      const patch = 'foobar';\n      const completer = new Completer({ editor: null, model });\n      const handler = new TestCompletionHandler({ completer, connector });\n      const editor = createEditorWidget().editor;\n      const text = 'eggs\\n  # comment\\nbaz';\n      const want = 'eggs\\n foobar # comment\\nbaz';\n      const line = 1;\n      const column = 1;\n      const request: Completer.ITextState = {\n        column: column,\n        line,\n        lineHeight: 0,\n        charWidth: 0,\n        coords: null,\n        text\n      };\n\n      handler.editor = editor;\n      handler.editor.model.value.text = text;\n      handler.editor.model.sharedModel.clearUndoHistory();\n      handler.editor.setCursorPosition({ line, column });\n      model.original = request;\n      const offset = handler.editor.getOffsetAt({ line, column });\n      model.cursor = { start: offset, end: offset };\n      // Make the completion, check its value and cursor position.\n      (completer.selected as any).emit(patch);\n      expect(editor.model.value.text).toBe(want);\n      expect(editor.getCursorPosition()).toEqual({\n        line,\n        column: column + 6\n      });\n    });","file":"handler.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a manager","suites":["completer/manager","CompletionProviderManager","#constructor()"],"updatePoint":{"line":81,"column":33},"line":81,"code":"      it('should create a manager', () => {\n        expect(manager).toBeInstanceOf(CompletionProviderManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a ConnectorProxy","suites":["completer/manager","CompletionProviderManager","#generateConnectorProxy()"],"updatePoint":{"line":87,"column":40},"line":87,"code":"      it('should create a ConnectorProxy', async () => {\n        const connectorProxy = await manager['generateConnectorProxy']({\n          session: sessionContext.session,\n          editor: null\n        });\n        expect(connectorProxy).toBeInstanceOf(ConnectorProxy);\n        expect(connectorProxy['_providers'].length).toBe(1);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should register a new provider","suites":["completer/manager","CompletionProviderManager","#registerProvider()"],"updatePoint":{"line":98,"column":40},"line":98,"code":"      it('should register a new provider', () => {\n        manager.registerProvider(new FooCompletionProvider());\n        expect(manager.getProviders().size).toBe(2);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not register a provider twice","suites":["completer/manager","CompletionProviderManager","#registerProvider()"],"updatePoint":{"line":102,"column":46},"line":102,"code":"      it('should not register a provider twice', () => {\n        manager.registerProvider(new FooCompletionProvider());\n        manager.registerProvider(new FooCompletionProvider());\n        expect(manager.getProviders().size).toBe(2);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should have jupyterlab provider by default","suites":["completer/manager","CompletionProviderManager","#activateProvider()"],"updatePoint":{"line":110,"column":52},"line":110,"code":"      it('should have jupyterlab provider by default', () => {\n        expect(manager['_activeProviders'].size).toBe(1);\n        expect(manager['_activeProviders'].has(DEFAULT_PROVIDER_ID)).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should activate requested provider","suites":["completer/manager","CompletionProviderManager","#activateProvider()"],"updatePoint":{"line":114,"column":44},"line":114,"code":"      it('should activate requested provider', () => {\n        manager.registerProvider(new FooCompletionProvider());\n        manager.activateProvider([SAMPLE_PROVIDER_ID]);\n        expect(manager['_activeProviders'].size).toBe(1);\n        expect(manager['_activeProviders'].has(DEFAULT_PROVIDER_ID)).toBe(\n          false\n        );\n        expect(manager['_activeProviders'].has(SAMPLE_PROVIDER_ID)).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should activate multiple providers","suites":["completer/manager","CompletionProviderManager","#activateProvider()"],"updatePoint":{"line":123,"column":44},"line":123,"code":"      it('should activate multiple providers', () => {\n        manager.registerProvider(new FooCompletionProvider());\n        manager.activateProvider([SAMPLE_PROVIDER_ID, DEFAULT_PROVIDER_ID]);\n        expect(manager['_activeProviders'].size).toBe(2);\n        expect(manager['_activeProviders'].has(DEFAULT_PROVIDER_ID)).toBe(true);\n        expect(manager['_activeProviders'].has(SAMPLE_PROVIDER_ID)).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should skip unavailble providers","suites":["completer/manager","CompletionProviderManager","#activateProvider()"],"updatePoint":{"line":130,"column":42},"line":130,"code":"      it('should skip unavailble providers', () => {\n        manager.registerProvider(new FooCompletionProvider());\n        manager.activateProvider(['randomId']);\n        expect(manager['_activeProviders'].size).toBe(2);\n        expect(manager['_activeProviders'].has(DEFAULT_PROVIDER_ID)).toBe(true);\n        expect(manager['_activeProviders'].has('randomId')).toBe(false);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a handler with connector proxy","suites":["completer/manager","CompletionProviderManager","#generateHandler()"],"updatePoint":{"line":140,"column":54},"line":140,"code":"      it('should create a handler with connector proxy', async () => {\n        const handler = await manager['generateHandler']({});\n        expect(handler).toBeInstanceOf(CompletionHandler);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should attach a handler to the notebook panel","suites":["completer/manager","CompletionProviderManager","#attachPanel()"],"updatePoint":{"line":147,"column":55},"line":147,"code":"      it('should attach a handler to the notebook panel', async () => {\n        const context = contextFactory();\n        const panel = NBTestUtils.createNotebookPanel(context);\n        await manager.attachPanel(panel);\n        expect(manager['_panelHandlers'].has(panel.id)).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a completer model","suites":["completer/model","CompleterModel","#constructor()"],"updatePoint":{"line":26,"column":41},"line":26,"code":"      it('should create a completer model', () => {\n        const model = new CompleterModel();\n        expect(model).toBeInstanceOf(CompleterModel);\n        expect(model.setCompletionItems).toBeDefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should signal when model options have changed","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":34,"column":55},"line":34,"code":"      it('should signal when model options have changed', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setOptions(['foo']);\n        expect(called).toBe(1);\n        model.setOptions(['foo'], { foo: 'instance' });\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should signal when model items have changed","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":48,"column":53},"line":48,"code":"      it('should signal when model items have changed', () => {\n        let model = new CompleterModel();\n        let called = 0;\n        let listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setCompletionItems!([{ label: 'foo' }]);\n        expect(called).toBe(1);\n        model.setCompletionItems!([{ label: 'foo' }]);\n        model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not signal when options have not changed","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":63,"column":57},"line":63,"code":"      it('should not signal when options have not changed', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setOptions(['foo']);\n        model.setOptions(['foo']);\n        expect(called).toBe(1);\n        model.setOptions(['foo'], { foo: 'instance' });\n        model.setOptions(['foo'], { foo: 'instance' });\n        expect(called).toBe(2);\n        model.setOptions([], {});\n        model.setOptions([], {});\n        expect(called).toBe(3);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not signal when items have not changed","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":82,"column":55},"line":82,"code":"      it('should not signal when items have not changed', () => {\n        let model = new CompleterModel();\n        let called = 0;\n        let listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setCompletionItems!([{ label: 'foo' }]);\n        model.setCompletionItems!([{ label: 'foo' }]);\n        expect(called).toBe(1);\n        model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n        model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n        expect(called).toBe(2);\n        model.setCompletionItems!([]);\n        model.setCompletionItems!([]);\n        expect(called).toBe(3);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should signal when original request changes","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":101,"column":53},"line":101,"code":"      it('should signal when original request changes', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = makeState('foo');\n        expect(called).toBe(1);\n        model.original = null;\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not signal when original request has not changed","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":115,"column":65},"line":115,"code":"      it('should not signal when original request has not changed', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = makeState('foo');\n        model.original = makeState('foo');\n        expect(called).toBe(1);\n        model.original = null;\n        model.original = null;\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should signal when current text changes","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":131,"column":49},"line":131,"code":"      it('should signal when current text changes', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = request;\n        expect(called).toBe(1);\n        model.cursor = cursor;\n        model.current = change;\n        expect(called).toBe(2);\n        model.current = null;\n        expect(called).toBe(3);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not signal when current text is unchanged","suites":["completer/model","CompleterModel","#stateChanged"],"updatePoint":{"line":153,"column":58},"line":153,"code":"      it('should not signal when current text is unchanged', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = request;\n        expect(called).toBe(1);\n        model.cursor = cursor;\n        model.current = change;\n        model.current = change;\n        expect(called).toBe(2);\n        model.current = null;\n        model.current = null;\n        expect(called).toBe(3);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to { items: [] }","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":179,"column":41},"line":179,"code":"      it('should default to { items: [] }', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [];\n        expect(model.completionItems!()).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return unmarked ICompletionItems if query is blank","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":185,"column":67},"line":185,"code":"      it('should return unmarked ICompletionItems if query is blank', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ];\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        expect(model.completionItems!()).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return a marked list of items if query is set","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":200,"column":62},"line":200,"code":"      it('should return a marked list of items if query is set', () => {\n        let model = new CompleterModel();\n        let want = '<mark>f</mark>oo';\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        model.query = 'f';\n        expect(model.completionItems!().length).toEqual(1);\n        expect(model.completionItems!()[0].label).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should order list based on score","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":213,"column":42},"line":213,"code":"      it('should order list based on score', () => {\n        const model = new CompleterModel();\n        const want: CompletionHandler.ICompletionItems = [\n          { insertText: 'qux', label: '<mark>qux</mark>' },\n          { insertText: 'quux', label: '<mark>qu</mark>u<mark>x</mark>' }\n        ];\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' },\n          { label: 'quux' },\n          { label: 'qux' }\n        ]);\n        model.query = 'qux';\n        expect(model.completionItems!()).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should break ties in score by locale sort","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":230,"column":51},"line":230,"code":"      it('should break ties in score by locale sort', () => {\n        const model = new CompleterModel();\n        const want: CompletionHandler.ICompletionItems = [\n          { insertText: 'quux', label: '<mark>qu</mark>ux' },\n          { insertText: 'qux', label: '<mark>qu</mark>x' }\n        ];\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' },\n          { label: 'quux' },\n          { label: 'qux' }\n        ]);\n        model.query = 'qu';\n        expect(model.completionItems!()).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return { items: [] } if reset","suites":["completer/model","CompleterModel","#completionItems()"],"updatePoint":{"line":247,"column":46},"line":247,"code":"      it('should return { items: [] } if reset', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [];\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        model.reset();\n        expect(model.completionItems!()).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return an unfiltered list of items if query is blank","suites":["completer/model","CompleterModel","#items()"],"updatePoint":{"line":261,"column":69},"line":261,"code":"      it('should return an unfiltered list of items if query is blank', () => {\n        const model = new CompleterModel();\n        const want: Completer.IItem[] = [\n          { raw: 'foo', text: 'foo' },\n          { raw: 'bar', text: 'bar' },\n          { raw: 'baz', text: 'baz' }\n        ];\n        model.setOptions(['foo', 'bar', 'baz']);\n        expect(toArray(model.items())).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return a filtered list of items if query is set","suites":["completer/model","CompleterModel","#items()"],"updatePoint":{"line":272,"column":64},"line":272,"code":"      it('should return a filtered list of items if query is set', () => {\n        const model = new CompleterModel();\n        const want: Completer.IItem[] = [\n          { raw: 'foo', text: '<mark>f</mark>oo' }\n        ];\n        model.setOptions(['foo', 'bar', 'baz']);\n        model.query = 'f';\n        expect(toArray(model.items())).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should order list based on score","suites":["completer/model","CompleterModel","#items()"],"updatePoint":{"line":282,"column":42},"line":282,"code":"      it('should order list based on score', () => {\n        const model = new CompleterModel();\n        const want: Completer.IItem[] = [\n          { raw: 'qux', text: '<mark>qux</mark>' },\n          { raw: 'quux', text: '<mark>qu</mark>u<mark>x</mark>' }\n        ];\n        model.setOptions(['foo', 'bar', 'baz', 'quux', 'qux']);\n        model.query = 'qux';\n        expect(toArray(model.items())).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should break ties in score by locale sort","suites":["completer/model","CompleterModel","#items()"],"updatePoint":{"line":293,"column":51},"line":293,"code":"      it('should break ties in score by locale sort', () => {\n        const model = new CompleterModel();\n        const want: Completer.IItem[] = [\n          { raw: 'quux', text: '<mark>qu</mark>ux' },\n          { raw: 'qux', text: '<mark>qu</mark>x' }\n        ];\n        model.setOptions(['foo', 'bar', 'baz', 'qux', 'quux']);\n        model.query = 'qu';\n        expect(toArray(model.items())).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to an empty iterator","suites":["completer/model","CompleterModel","#options()"],"updatePoint":{"line":306,"column":45},"line":306,"code":"      it('should default to an empty iterator', () => {\n        const model = new CompleterModel();\n        expect(model.options().next()).toBeUndefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return model options","suites":["completer/model","CompleterModel","#options()"],"updatePoint":{"line":311,"column":37},"line":311,"code":"      it('should return model options', () => {\n        const model = new CompleterModel();\n        const options = ['foo'];\n        model.setOptions(options, {});\n        expect(toArray(model.options())).not.toBe(options);\n        expect(toArray(model.options())).toEqual(options);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return the typeMap","suites":["completer/model","CompleterModel","#options()"],"updatePoint":{"line":319,"column":35},"line":319,"code":"      it('should return the typeMap', () => {\n        const model = new CompleterModel();\n        const options = ['foo'];\n        const typeMap = { foo: 'instance' };\n        model.setOptions(options, typeMap);\n        expect(JSONExt.deepEqual(model.typeMap(), typeMap)).toBeTruthy();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["completer/model","CompleterModel","#original"],"updatePoint":{"line":329,"column":32},"line":329,"code":"      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.original).toBeNull();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return the original request","suites":["completer/model","CompleterModel","#original"],"updatePoint":{"line":334,"column":44},"line":334,"code":"      it('should return the original request', () => {\n        const model = new CompleterModel();\n        const request = makeState('foo');\n        model.original = request;\n        expect(model.original).toBe(request);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["completer/model","CompleterModel","#current"],"updatePoint":{"line":343,"column":32},"line":343,"code":"      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.current).toBeNull();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should initially equal the original request","suites":["completer/model","CompleterModel","#current"],"updatePoint":{"line":348,"column":53},"line":348,"code":"      it('should initially equal the original request', () => {\n        const model = new CompleterModel();\n        const request = makeState('foo');\n        model.original = request;\n        expect(model.current).toBe(request);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not set if original request is nonexistent","suites":["completer/model","CompleterModel","#current"],"updatePoint":{"line":355,"column":59},"line":355,"code":"      it('should not set if original request is nonexistent', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.current = change;\n        expect(model.current).toBeNull();\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        expect(model.current).toBe(change);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not set if cursor is nonexistent","suites":["completer/model","CompleterModel","#current"],"updatePoint":{"line":370,"column":49},"line":370,"code":"      it('should not set if cursor is nonexistent', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.original = request;\n        model.cursor = null;\n        model.current = change;\n        expect(model.current).not.toBe(change);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset model if change is shorter than original","suites":["completer/model","CompleterModel","#current"],"updatePoint":{"line":382,"column":63},"line":382,"code":"      it('should reset model if change is shorter than original', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'fo';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        expect(model.current).toBeNull();\n        expect(model.original).toBeNull();\n        expect(model.options().next()).toBeUndefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["completer/model","CompleterModel","#cursor"],"updatePoint":{"line":399,"column":32},"line":399,"code":"      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.cursor).toBeNull();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should not set if original request is nonexistent","suites":["completer/model","CompleterModel","#cursor"],"updatePoint":{"line":404,"column":59},"line":404,"code":"      it('should not set if original request is nonexistent', () => {\n        const model = new CompleterModel();\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState('foo');\n        model.cursor = cursor;\n        expect(model.cursor).toBeNull();\n        model.original = request;\n        model.cursor = cursor;\n        expect(model.cursor).toBe(cursor);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be true if model has been disposed","suites":["completer/model","CompleterModel","#isDisposed"],"updatePoint":{"line":417,"column":51},"line":417,"code":"      it('should be true if model has been disposed', () => {\n        const model = new CompleterModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should dispose of the model resources","suites":["completer/model","CompleterModel","#dispose()"],"updatePoint":{"line":426,"column":47},"line":426,"code":"      it('should dispose of the model resources', () => {\n        const model = new CompleterModel();\n        model.setOptions(['foo'], { foo: 'instance' });\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be safe to call multiple times","suites":["completer/model","CompleterModel","#dispose()"],"updatePoint":{"line":434,"column":47},"line":434,"code":"      it('should be safe to call multiple times', () => {\n        const model = new CompleterModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should set current change value","suites":["completer/model","CompleterModel","#handleTextChange()"],"updatePoint":{"line":444,"column":41},"line":444,"code":"      it('should set current change value', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        (change as any).column = 4;\n        model.original = request;\n        model.cursor = cursor;\n        expect(model.current).toBe(request);\n        model.handleTextChange(change);\n        expect(model.current).toBe(change);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset if last char is whitespace && column < original","suites":["completer/model","CompleterModel","#handleTextChange()"],"updatePoint":{"line":459,"column":70},"line":459,"code":"      it('should reset if last char is whitespace && column < original', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foo ';\n        const request = makeState(currentValue);\n        (request as any).column = 3;\n        const change = makeState(newValue);\n        (change as any).column = 0;\n        model.original = request;\n        expect(model.original).toBe(request);\n        model.handleTextChange(change);\n        expect(model.original).toBeNull();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return a patch value","suites":["completer/model","CompleterModel","#createPatch()"],"updatePoint":{"line":475,"column":37},"line":475,"code":"      it('should return a patch value', () => {\n        const model = new CompleterModel();\n        const patch = 'foobar';\n        const want: Completer.IPatch = {\n          start: 0,\n          end: 3,\n          value: patch\n        };\n        const cursor: Completer.ICursorSpan = { start: 0, end: 3 };\n        model.original = makeState('foo');\n        model.cursor = cursor;\n        expect(model.createPatch(patch)).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should return undefined if original request or cursor are null","suites":["completer/model","CompleterModel","#createPatch()"],"updatePoint":{"line":489,"column":72},"line":489,"code":"      it('should return undefined if original request or cursor are null', () => {\n        const model = new CompleterModel();\n        expect(model.createPatch('foo')).toBeUndefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should handle line breaks in original value","suites":["completer/model","CompleterModel","#createPatch()"],"updatePoint":{"line":494,"column":53},"line":494,"code":"      it('should handle line breaks in original value', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo\\nbar';\n        const patch = 'barbaz';\n        const start = currentValue.length;\n        const end = currentValue.length;\n        const want: Completer.IPatch = {\n          start,\n          end,\n          value: patch\n        };\n        const cursor: Completer.ICursorSpan = { start, end };\n        model.original = makeState(currentValue);\n        model.cursor = cursor;\n        expect(model.createPatch(patch)).toEqual(want);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a completer widget","suites":["completer/widget","Completer","#constructor()"],"updatePoint":{"line":87,"column":42},"line":87,"code":"      it('should create a completer widget', () => {\n        const widget = new Completer({ editor: null });\n        expect(widget).toBeInstanceOf(Completer);\n        expect(Array.from(widget.node.classList)).toEqual(\n          expect.arrayContaining(['jp-Completer'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should accept options with a model","suites":["completer/widget","Completer","#constructor()"],"updatePoint":{"line":95,"column":44},"line":95,"code":"      it('should accept options with a model', () => {\n        const options: Completer.IOptions = {\n          editor: null,\n          model: new CompleterModel()\n        };\n        const widget = new Completer(options);\n        expect(widget).toBeInstanceOf(Completer);\n        expect(widget.model).toBe(options.model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should accept options with a renderer","suites":["completer/widget","Completer","#constructor()"],"updatePoint":{"line":105,"column":47},"line":105,"code":"      it('should accept options with a renderer', () => {\n        const options: Completer.IOptions = {\n          editor: null,\n          model: new CompleterModel(),\n          renderer: new CustomRenderer()\n        };\n        options.model!.setOptions(['foo', 'bar']);\n\n        const widget = new Completer(options);\n        expect(widget).toBeInstanceOf(Completer);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n        const items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n        expect(items).toHaveLength(2);\n        expect(Array.from(items[0].classList)).toEqual(\n          expect.arrayContaining([TEST_ITEM_CLASS])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should accept completion items with a renderer","suites":["completer/widget","Completer","#constructor()"],"updatePoint":{"line":124,"column":56},"line":124,"code":"      it('should accept completion items with a renderer', () => {\n        let options: Completer.IOptions = {\n          editor: null,\n          model: new CompleterModel(),\n          renderer: new CustomRenderer()\n        };\n        options.model!.setCompletionItems!([\n          { label: 'foo', documentation: 'foo does bar' },\n          { label: 'bar' }\n        ]);\n\n        let widget = new Completer(options);\n        expect(widget).toBeInstanceOf(Completer);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n        let items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n        expect(items).toHaveLength(2);\n        expect(Array.from(items[0].classList)).toEqual(\n          expect.arrayContaining([TEST_ITEM_CLASS])\n        );\n\n        let panel = widget.node.querySelector(`.${DOC_PANEL_CLASS}`)!;\n        expect(panel.children).toHaveLength(1);\n        expect(Array.from(panel.firstElementChild!.classList)).toEqual(\n          expect.arrayContaining([TEST_DOC_CLASS])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should emit a signal when an item is selected","suites":["completer/widget","Completer","#selected"],"updatePoint":{"line":154,"column":55},"line":154,"code":"      it('should emit a signal when an item is selected', () => {\n        const anchor = createEditorWidget();\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model: new CompleterModel()\n        };\n        let value = '';\n        const listener = (sender: any, selected: string) => {\n          value = selected;\n        };\n        options.model!.setOptions(['foo', 'bar']);\n        Widget.attach(anchor, document.body);\n\n        const widget = new Completer(options);\n\n        widget.selected.connect(listener);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(value).toBe('');\n        widget.selectActive();\n        expect(value).toBe('foo');\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should emit the insert text if it is present","suites":["completer/widget","Completer","#selected","#selected with completion items"],"updatePoint":{"line":180,"column":56},"line":180,"code":"        it('should emit the insert text if it is present', () => {\n          let anchor = createEditorWidget();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model: new CompleterModel()\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          options.model!.setCompletionItems!([\n            { label: 'foo', insertText: 'bar' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          widget.selectActive();\n          expect(value).toBe('bar');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should emit the label if insert text is not present","suites":["completer/widget","Completer","#selected","#selected with completion items"],"updatePoint":{"line":208,"column":63},"line":208,"code":"        it('should emit the label if insert text is not present', () => {\n          let anchor = createEditorWidget();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model: new CompleterModel()\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          options.model!.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          widget.selectActive();\n          expect(value).toBe('foo');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should emit a signal when completer visibility changes","suites":["completer/widget","Completer","#visibilityChanged"],"updatePoint":{"line":239,"column":64},"line":239,"code":"      it('should emit a signal when completer visibility changes', async () => {\n        const panel = new Panel();\n        const code = createEditorWidget();\n        const editor = code.editor;\n        const model = new CompleterModel();\n        let called = false;\n\n        editor.model.value.text = 'a';\n        panel.node.style.position = 'absolute';\n        panel.node.style.top = '0px';\n        panel.node.style.left = '0px';\n        panel.node.style.height = '1000px';\n        code.node.style.height = '900px';\n        panel.addWidget(code);\n        Widget.attach(panel, document.body);\n        panel.node.scrollTop = 0;\n        document.body.scrollTop = 0;\n\n        const position = code.editor.getPositionAt(1)!;\n\n        editor.setCursorPosition(position);\n\n        const request: Completer.ITextState = {\n          column: position.column,\n          lineHeight: editor.lineHeight,\n          charWidth: editor.charWidth,\n          line: position.line,\n          text: 'a'\n        };\n\n        model.original = request;\n        model.cursor = { start: 0, end: 1 };\n        model.setOptions(['abc', 'abd', 'abe', 'abi']);\n\n        const widget = new Completer({ model, editor: code.editor });\n        widget.hide();\n        expect(called).toBe(false);\n        widget.visibilityChanged.connect(() => {\n          called = true;\n        });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n        await framePromise();\n        expect(called).toBe(true);\n        widget.dispose();\n        code.dispose();\n        panel.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should emit a signal when completion items completer visibility changes","suites":["completer/widget","Completer","#visibilityChanged"],"updatePoint":{"line":289,"column":81},"line":289,"code":"      it('should emit a signal when completion items completer visibility changes', async () => {\n        let panel = new Panel();\n        let code = createEditorWidget();\n        let editor = code.editor;\n        let model = new CompleterModel();\n        let called = false;\n\n        editor.model.value.text = 'a';\n        panel.node.style.position = 'absolute';\n        panel.node.style.top = '0px';\n        panel.node.style.left = '0px';\n        panel.node.style.height = '1000px';\n        code.node.style.height = '900px';\n        panel.addWidget(code);\n        Widget.attach(panel, document.body);\n        panel.node.scrollTop = 0;\n        document.body.scrollTop = 0;\n\n        let position = code.editor.getPositionAt(1)!;\n\n        editor.setCursorPosition(position);\n\n        let request: Completer.ITextState = {\n          column: position.column,\n          lineHeight: editor.lineHeight,\n          charWidth: editor.charWidth,\n          line: position.line,\n          text: 'a'\n        };\n\n        model.original = request;\n        model.cursor = { start: 0, end: 1 };\n        model.setCompletionItems!([\n          { label: 'abc' },\n          { label: 'abd' },\n          { label: 'abe' },\n          { label: 'abi' }\n        ]);\n\n        let widget = new Completer({ model, editor: code.editor });\n        widget.hide();\n        expect(called).toBe(false);\n        widget.visibilityChanged.connect(() => {\n          called = true;\n        });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n        await framePromise();\n        expect(called).toBe(true);\n        widget.dispose();\n        code.dispose();\n        panel.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["completer/widget","Completer","#model"],"updatePoint":{"line":346,"column":32},"line":346,"code":"      it('should default to null', () => {\n        const widget = new Completer({ editor: null });\n        expect(widget.model).toBeNull();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be settable","suites":["completer/widget","Completer","#model"],"updatePoint":{"line":351,"column":28},"line":351,"code":"      it('should be settable', () => {\n        const widget = new Completer({ editor: null });\n        expect(widget.model).toBeNull();\n        widget.model = new CompleterModel();\n        expect(widget.model).toBeInstanceOf(CompleterModel);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be safe to set multiple times","suites":["completer/widget","Completer","#model"],"updatePoint":{"line":358,"column":46},"line":358,"code":"      it('should be safe to set multiple times', () => {\n        const model = new CompleterModel();\n        const widget = new Completer({ editor: null });\n        widget.model = model;\n        widget.model = model;\n        expect(widget.model).toBe(model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be safe to reset","suites":["completer/widget","Completer","#model"],"updatePoint":{"line":366,"column":33},"line":366,"code":"      it('should be safe to reset', () => {\n        const model = new CompleterModel();\n        const widget = new Completer({\n          editor: null,\n          model: new CompleterModel()\n        });\n        expect(widget.model).not.toBe(model);\n        widget.model = model;\n        expect(widget.model).toBe(model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should default to null","suites":["completer/widget","Completer","#editor"],"updatePoint":{"line":379,"column":32},"line":379,"code":"      it('should default to null', () => {\n        const widget = new Completer({ editor: null });\n        expect(widget.editor).toBeNull();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be settable","suites":["completer/widget","Completer","#editor"],"updatePoint":{"line":384,"column":28},"line":384,"code":"      it('should be settable', () => {\n        const anchor = createEditorWidget();\n        const widget = new Completer({ editor: null });\n        expect(widget.editor).toBeNull();\n        widget.editor = anchor.editor;\n        expect(widget.editor).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should dispose of the resources held by the widget","suites":["completer/widget","Completer","#dispose()"],"updatePoint":{"line":394,"column":60},"line":394,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new Completer({ editor: null });\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should be safe to call multiple times","suites":["completer/widget","Completer","#dispose()"],"updatePoint":{"line":400,"column":47},"line":400,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new Completer({ editor: null });\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset the completer widget","suites":["completer/widget","Completer","#reset()"],"updatePoint":{"line":409,"column":43},"line":409,"code":"      it('should reset the completer widget', () => {\n        const anchor = createEditorWidget();\n        const model = new CompleterModel();\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n        model.setOptions(['foo', 'bar'], { foo: 'instance', bar: 'function' });\n        Widget.attach(anchor, document.body);\n\n        const widget = new Completer(options);\n\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isHidden).toBe(false);\n        expect(model.options).toBeTruthy();\n        widget.reset();\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isHidden).toBe(true);\n        expect(model.options().next()).toBeUndefined();\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset the completer widget and its completion items","suites":["completer/widget","Completer","#reset()"],"updatePoint":{"line":433,"column":68},"line":433,"code":"      it('should reset the completer widget and its completion items', () => {\n        let anchor = createEditorWidget();\n        let model = new CompleterModel();\n        let options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n        model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n        Widget.attach(anchor, document.body);\n\n        let widget = new Completer(options);\n\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isHidden).toBe(false);\n        expect(model.completionItems!()).toEqual([\n          { label: 'foo' },\n          { label: 'bar' }\n        ]);\n        widget.reset();\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isHidden).toBe(true);\n        expect(model.completionItems!()).toEqual([]);\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should handle document keydown, mousedown, and scroll events","suites":["completer/widget","Completer","#handleEvent()"],"updatePoint":{"line":462,"column":70},"line":462,"code":"      it('should handle document keydown, mousedown, and scroll events', () => {\n        const anchor = createEditorWidget();\n        const widget = new LogWidget({ editor: anchor.editor });\n        Widget.attach(anchor, document.body);\n        Widget.attach(widget, document.body);\n        ['keydown', 'mousedown', 'scroll'].forEach(type => {\n          simulate(document.body, type);\n          expect(widget.events).toEqual(expect.arrayContaining([type]));\n        });\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset if keydown is outside anchor","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":476,"column":53},"line":476,"code":"        it('should reset if keydown is outside anchor', () => {\n          const model = new CompleterModel();\n          const anchor = createEditorWidget();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setOptions(['foo', 'bar'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(false);\n          expect(model.options).toBeTruthy();\n          simulate(document.body, 'keydown', { keyCode: 70 }); // F\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(true);\n          expect(model.options().next()).toBeUndefined();\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should reset completion items if keydown is outside anchor","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":503,"column":70},"line":503,"code":"        it('should reset completion items if keydown is outside anchor', () => {\n          let model = new CompleterModel();\n          let anchor = createEditorWidget();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(false);\n          expect(model.completionItems!()).toEqual([\n            { label: 'foo' },\n            { label: 'bar' }\n          ]);\n          simulate(document.body, 'keydown', { keyCode: 70 }); // F\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(true);\n          expect(model.completionItems!()).toEqual([]);\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the item below and wrap to top past last (arrow keys)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":530,"column":79},"line":530,"code":"        it('should select the item below and wrap to top past last (arrow keys)', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setOptions(['foo', 'bar', 'baz'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n          const target = document.createElement('div');\n\n          anchor.node.appendChild(target);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          const items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the item below and wrap to top past last (tab)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":595,"column":72},"line":595,"code":"        it('should select the item below and wrap to top past last (tab)', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setOptions(['foo', 'bar', 'baz'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n          const target = document.createElement('div');\n\n          anchor.node.appendChild(target);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          const items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the completion item below and wrap to top past last (arrow keys)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":660,"column":90},"line":660,"code":"        it('should select the completion item below and wrap to top past last (arrow keys)', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'bar' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n          let target = document.createElement('div');\n\n          anchor.node.appendChild(target);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          let items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the completion item below and wrap to top past last (tab)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":725,"column":83},"line":725,"code":"        it('should select the completion item below and wrap to top past last (tab)', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'bar' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n          let target = document.createElement('div');\n\n          anchor.node.appendChild(target);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          let items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(target, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the item above and wrap to bottom past first (arrow keys)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":790,"column":83},"line":790,"code":"        it('should select the item above and wrap to bottom past first (arrow keys)', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setOptions(['foo', 'bar', 'baz'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          const items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the item above and wrap to bottom past first (tab)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":873,"column":76},"line":873,"code":"        it('should select the item above and wrap to bottom past first (tab)', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setOptions(['foo', 'bar', 'baz'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          const items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the completion item above and wrap to top past first (arrow keys)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":956,"column":91},"line":956,"code":"        it('should select the completion item above and wrap to top past first (arrow keys)', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'bar' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          let items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 40 }); // Down\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 38 }); // Up\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should select the completion item above and wrap to top past first (tab)","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":1040,"column":84},"line":1040,"code":"        it('should select the completion item above and wrap to top past first (tab)', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          model.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'bar' },\n            { label: 'baz' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          let items = widget.node.querySelectorAll(`.${ITEM_CLASS}`);\n\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          simulate(anchor.node, 'keydown', { keyCode: 9, shiftKey: true }); // Shift + Tab\n          expect(Array.from(items[0].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[1].classList)).toEqual(\n            expect.not.arrayContaining([ACTIVE_CLASS])\n          );\n          expect(Array.from(items[2].classList)).toEqual(\n            expect.arrayContaining([ACTIVE_CLASS])\n          );\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should mark common subset on start and complete that subset on tab","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":1124,"column":78},"line":1124,"code":"        it('should mark common subset on start and complete that subset on tab', async () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          const listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setOptions(['fo', 'foo', 'foo', 'fooo'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          await framePromise();\n          const marked = widget.node.querySelectorAll(`.${ITEM_CLASS} mark`);\n          expect(Object.keys(value)).toHaveLength(0);\n          expect(marked).toHaveLength(4);\n          expect(marked[0].textContent).toBe('fo');\n          expect(marked[1].textContent).toBe('fo');\n          expect(marked[2].textContent).toBe('fo');\n          expect(marked[3].textContent).toBe('fo');\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('fo');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should mark common subset of completion items on start and complete that subset on tab","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":1161,"column":98},"line":1161,"code":"        it('should mark common subset of completion items on start and complete that subset on tab', async () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setCompletionItems!([\n            { label: 'fo' },\n            { label: 'foo' },\n            { label: 'foo' },\n            { label: 'fooo' }\n          ]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          await framePromise();\n          let marked = widget.node.querySelectorAll(`.${ITEM_CLASS} mark`);\n          expect(value).toHaveLength(0);\n          expect(marked).toHaveLength(4);\n          expect(marked[0].textContent).toBe('fo');\n          expect(marked[1].textContent).toBe('fo');\n          expect(marked[2].textContent).toBe('fo');\n          expect(marked[3].textContent).toBe('fo');\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('fo');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should insert single completion item on tab","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":1201,"column":53},"line":1201,"code":"      it('should insert single completion item on tab', async () => {\n        const anchor = createEditorWidget();\n        const model = new CompleterModel();\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n        let value = '';\n        const listener = (sender: any, selected: string) => {\n          value = selected;\n        };\n        model.setCompletionItems!([{ label: 'foo' }]);\n        Widget.attach(anchor, document.body);\n\n        const widget = new Completer(options);\n\n        widget.selected.connect(listener);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n        expect(value).toBe('foo');\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should insert single completion item insertText on tab","suites":["completer/widget","Completer","#handleEvent()","keydown"],"updatePoint":{"line":1226,"column":64},"line":1226,"code":"      it('should insert single completion item insertText on tab', async () => {\n        const anchor = createEditorWidget();\n        const model = new CompleterModel();\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n        let value = '';\n        const listener = (sender: any, selected: string) => {\n          value = selected;\n        };\n        model.setCompletionItems!([{ label: 'foo', insertText: 'bar' }]);\n        Widget.attach(anchor, document.body);\n\n        const widget = new Completer(options);\n\n        widget.selected.connect(listener);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n        expect(value).toBe('bar');\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should trigger a selected signal on mouse down","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1252,"column":58},"line":1252,"code":"        it('should trigger a selected signal on mouse down', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          const listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setOptions(['foo', 'bar', 'baz'], {\n            foo: 'instance',\n            bar: 'function'\n          });\n          model.query = 'b';\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          const item = widget.node.querySelectorAll(`.${ITEM_CLASS} mark`)[1];\n\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n          expect(model.query).toBe('ba');\n          simulate(item, 'mousedown');\n          expect(value).toBe('baz');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should trigger a selected signal on mouse down of completion item","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1286,"column":77},"line":1286,"code":"        it('should trigger a selected signal on mouse down of completion item', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setCompletionItems!([\n            { label: 'foo' },\n            { label: 'bar' },\n            { label: 'baz' }\n          ]);\n          model.query = 'b';\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n\n          let item = widget.node.querySelectorAll(`.${ITEM_CLASS} mark`)[1];\n\n          simulate(anchor.node, 'keydown', { keyCode: 9 }); // Tab key\n          expect(model.query).toBe('ba');\n          simulate(item, 'mousedown');\n          expect(value).toBe('baz');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should ignore nonstandard mouse clicks (e.g., right click)","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1321,"column":70},"line":1321,"code":"        it('should ignore nonstandard mouse clicks (e.g., right click)', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          const listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setOptions(['foo', 'bar']);\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          simulate(widget.node, 'mousedown', { button: 1 });\n          expect(value).toBe('');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should ignore nonstandard mouse clicks (e.g., right click) on completion item","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1347,"column":89},"line":1347,"code":"        it('should ignore nonstandard mouse clicks (e.g., right click) on completion item', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          simulate(widget.node, 'mousedown', { button: 1 });\n          expect(value).toBe('');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should ignore a mouse down that misses an item","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1373,"column":58},"line":1373,"code":"        it('should ignore a mouse down that misses an item', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          const listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setOptions(['foo', 'bar']);\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          simulate(widget.node, 'mousedown');\n          expect(value).toBe('');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should ignore a mouse down that misses a completion item","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1399,"column":68},"line":1399,"code":"        it('should ignore a mouse down that misses a completion item', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let value = '';\n          let listener = (sender: any, selected: string) => {\n            value = selected;\n          };\n          model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(value).toBe('');\n          simulate(widget.node, 'mousedown');\n          expect(value).toBe('');\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should hide widget if mouse down misses it","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1425,"column":54},"line":1425,"code":"        it('should hide widget if mouse down misses it', () => {\n          const anchor = createEditorWidget();\n          const model = new CompleterModel();\n          const options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          const listener = (sender: any, selected: string) => {\n            // no op\n          };\n          model.setOptions(['foo', 'bar']);\n          Widget.attach(anchor, document.body);\n\n          const widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(false);\n          simulate(anchor.node, 'mousedown');\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(true);\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should hide completion items widget if mouse down misses it","suites":["completer/widget","Completer","#handleEvent()","mousedown"],"updatePoint":{"line":1451,"column":71},"line":1451,"code":"        it('should hide completion items widget if mouse down misses it', () => {\n          let anchor = createEditorWidget();\n          let model = new CompleterModel();\n          let options: Completer.IOptions = {\n            editor: anchor.editor,\n            model\n          };\n          let listener = (sender: any, selected: string) => {\n            // no op\n          };\n          model.setCompletionItems!([{ label: 'foo' }, { label: 'bar' }]);\n          Widget.attach(anchor, document.body);\n\n          let widget = new Completer(options);\n\n          widget.selected.connect(listener);\n          Widget.attach(widget, document.body);\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(false);\n          simulate(anchor.node, 'mousedown');\n          MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n          expect(widget.isHidden).toBe(true);\n          widget.dispose();\n          anchor.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should position itself according to the anchor","suites":["completer/widget","Completer","#handleEvent()","scroll"],"line":1479,"code":"        it.skip('should position itself according to the anchor', async () => {","file":"widget.spec.ts","skipped":true,"dir":"packages/completer/test"},{"name":"should emit a selection if there is only one match","suites":["completer/widget","Completer","#onUpdateRequest()"],"updatePoint":{"line":1541,"column":60},"line":1541,"code":"      it('should emit a selection if there is only one match', () => {\n        const anchor = createEditorWidget();\n        const model = new CompleterModel();\n        const coords = { left: 0, right: 0, top: 100, bottom: 120 };\n        const request: Completer.ITextState = {\n          column: 0,\n          lineHeight: 0,\n          charWidth: 0,\n          line: 0,\n          coords,\n          text: 'f'\n        };\n\n        let value = '';\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n        const listener = (sender: any, selected: string) => {\n          value = selected;\n        };\n\n        Widget.attach(anchor, document.body);\n        model.original = request;\n        model.setOptions(['foo']);\n\n        const widget = new Completer(options);\n        widget.selected.connect(listener);\n        Widget.attach(widget, document.body);\n\n        expect(value).toBe('');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(value).toBe('foo');\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should do nothing if a model does not exist","suites":["completer/widget","Completer","#onUpdateRequest()"],"updatePoint":{"line":1578,"column":53},"line":1578,"code":"      it('should do nothing if a model does not exist', () => {\n        const widget = new LogWidget({ editor: null });\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should un-hide widget if multiple options are available","suites":["completer/widget","Completer","#onUpdateRequest()"],"updatePoint":{"line":1586,"column":65},"line":1586,"code":"      it('should un-hide widget if multiple options are available', () => {\n        const anchor = createEditorWidget();\n        const model = new CompleterModel();\n        const coords = { left: 0, right: 0, top: 100, bottom: 120 };\n        const request: Completer.ITextState = {\n          column: 0,\n          lineHeight: 0,\n          charWidth: 0,\n          line: 0,\n          coords,\n          text: 'f'\n        };\n\n        const options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n\n        Widget.attach(anchor, document.body);\n        model.original = request;\n        model.setOptions(['foo', 'bar', 'baz']);\n\n        const widget = new Completer(options);\n        widget.hide();\n        expect(widget.isHidden).toBe(true);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isVisible).toBe(true);\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should un-hide widget if multiple completion items are available","suites":["completer/widget","Completer","#onUpdateRequest()"],"updatePoint":{"line":1618,"column":74},"line":1618,"code":"      it('should un-hide widget if multiple completion items are available', () => {\n        let anchor = createEditorWidget();\n        let model = new CompleterModel();\n        let coords = { left: 0, right: 0, top: 100, bottom: 120 };\n        let request: Completer.ITextState = {\n          column: 0,\n          lineHeight: 0,\n          charWidth: 0,\n          line: 0,\n          coords,\n          text: 'f'\n        };\n\n        let options: Completer.IOptions = {\n          editor: anchor.editor,\n          model\n        };\n\n        Widget.attach(anchor, document.body);\n        model.original = request;\n        model.setCompletionItems!([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n\n        let widget = new Completer(options);\n        widget.hide();\n        expect(widget.isHidden).toBe(true);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.isVisible).toBe(true);\n        widget.dispose();\n        anchor.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/completer/test"},{"name":"should create a new foreign handler","suites":["@jupyterlab/console","ForeignHandler","#constructor()"],"updatePoint":{"line":144,"column":45},"line":144,"code":"      it('should create a new foreign handler', () => {\n        expect(handler).toBeInstanceOf(ForeignHandler);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should default to `false`","suites":["@jupyterlab/console","ForeignHandler","#enabled"],"updatePoint":{"line":150,"column":35},"line":150,"code":"      it('should default to `false`', () => {\n        expect(handler.enabled).toBe(false);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should allow foreign cells to be injected if `true`","suites":["@jupyterlab/console","ForeignHandler","#enabled"],"updatePoint":{"line":154,"column":61},"line":154,"code":"      it('should allow foreign cells to be injected if `true`', async () => {\n        handler.enabled = true;\n        let called = false;\n        handler.injected.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should reject foreign cells if `false`","suites":["@jupyterlab/console","ForeignHandler","#enabled"],"updatePoint":{"line":165,"column":48},"line":165,"code":"      it('should reject foreign cells if `false`', async () => {\n        handler.enabled = false;\n        let called = false;\n        handler.rejected.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should indicate whether the handler is disposed","suites":["@jupyterlab/console","ForeignHandler","#isDisposed"],"updatePoint":{"line":178,"column":57},"line":178,"code":"      it('should indicate whether the handler is disposed', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a client session object","suites":["@jupyterlab/console","ForeignHandler","#session"],"updatePoint":{"line":186,"column":43},"line":186,"code":"      it('should be a client session object', () => {\n        expect(handler.sessionContext.session!.path).toBeTruthy();\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be set upon instantiation","suites":["@jupyterlab/console","ForeignHandler","#parent"],"updatePoint":{"line":192,"column":42},"line":192,"code":"      it('should be set upon instantiation', () => {\n        const parent = new TestParent();\n        handler = new TestHandler({\n          sessionContext: handler.sessionContext,\n          parent\n        });\n        expect(handler.parent).toBe(parent);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should dispose the resources held by the handler","suites":["@jupyterlab/console","ForeignHandler","#dispose()"],"updatePoint":{"line":203,"column":58},"line":203,"code":"      it('should dispose the resources held by the handler', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/console","ForeignHandler","#dispose()"],"updatePoint":{"line":209,"column":47},"line":209,"code":"      it('should be safe to call multiple times', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called when messages come through","suites":["@jupyterlab/console","ForeignHandler","#onIOPubMessage()"],"updatePoint":{"line":218,"column":53},"line":218,"code":"      it('should be called when messages come through', async () => {\n        handler.enabled = false;\n        let called = false;\n        handler.received.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should inject relevant cells into the parent","suites":["@jupyterlab/console","ForeignHandler","#onIOPubMessage()"],"updatePoint":{"line":229,"column":54},"line":229,"code":"      it('should inject relevant cells into the parent', async () => {\n        handler.enabled = true;\n        const parent = handler.parent as TestParent;\n        expect(parent.widgets.length).toBe(0);\n        let called = false;\n        handler.injected.connect(() => {\n          expect(parent.widgets.length).toBeGreaterThan(0);\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should not reject relevant iopub messages","suites":["@jupyterlab/console","ForeignHandler","#onIOPubMessage()"],"updatePoint":{"line":243,"column":51},"line":243,"code":"      it('should not reject relevant iopub messages', async () => {\n        let called = false;\n        let errored = false;\n        handler.enabled = true;\n        handler.rejected.connect(() => {\n          errored = true;\n        });\n        handler.received.connect((sender, msg) => {\n          if (KernelMessage.isClearOutputMsg(msg)) {\n            called = true;\n          }\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, clearMsg);\n        expect(called).toBe(true);\n        expect(errored).toBe(false);\n      });","file":"foreign.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a console history object","suites":["console/history","ConsoleHistory","#constructor()"],"updatePoint":{"line":68,"column":48},"line":68,"code":"      it('should create a console history object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history).toBeInstanceOf(ConsoleHistory);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should get whether the object is disposed","suites":["console/history","ConsoleHistory","#isDisposed"],"updatePoint":{"line":75,"column":51},"line":75,"code":"      it('should get whether the object is disposed', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be the client session object","suites":["console/history","ConsoleHistory","#session"],"updatePoint":{"line":84,"column":45},"line":84,"code":"      it('should be the client session object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.sessionContext).toBe(sessionContext);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should dispose the history object","suites":["console/history","ConsoleHistory","#dispose()"],"updatePoint":{"line":91,"column":43},"line":91,"code":"      it('should dispose the history object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be safe to dispose multiple times","suites":["console/history","ConsoleHistory","#dispose()"],"updatePoint":{"line":98,"column":50},"line":98,"code":"      it('should be safe to dispose multiple times', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should return an empty string if no history exists","suites":["console/history","ConsoleHistory","#back()"],"updatePoint":{"line":108,"column":60},"line":108,"code":"      it('should return an empty string if no history exists', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const result = await history.back('');\n        expect(result).toBe('');\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should return previous items if they exist","suites":["console/history","ConsoleHistory","#back()"],"updatePoint":{"line":114,"column":52},"line":114,"code":"      it('should return previous items if they exist', async () => {\n        const history = new TestHistory({ sessionContext });\n        history.onHistory(mockHistory);\n        const result = await history.back('');\n        if (mockHistory.content.status !== 'ok') {\n          throw new Error('Test history reply is not an \"ok\" reply');\n        }\n        const index = mockHistory.content.history.length - 1;\n        const last = (mockHistory.content.history[index] as any)[2];\n        expect(result).toBe(last);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should return an empty string if no history exists","suites":["console/history","ConsoleHistory","#forward()"],"updatePoint":{"line":128,"column":60},"line":128,"code":"      it('should return an empty string if no history exists', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const result = await history.forward('');\n        expect(result).toBe('');\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should return next items if they exist","suites":["console/history","ConsoleHistory","#forward()"],"updatePoint":{"line":134,"column":48},"line":134,"code":"      it('should return next items if they exist', async () => {\n        const history = new TestHistory({ sessionContext });\n        history.onHistory(mockHistory);\n        await Promise.all([history.back(''), history.back('')]);\n        const result = await history.forward('');\n        if (mockHistory.content.status !== 'ok') {\n          throw new Error('Test history reply is not an \"ok\" reply');\n        }\n        const index = mockHistory.content.history.length - 1;\n        const last = (mockHistory.content.history[index] as any)[2];\n        expect(result).toBe(last);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should allow addition of history items","suites":["console/history","ConsoleHistory","#push()"],"updatePoint":{"line":149,"column":48},"line":149,"code":"      it('should allow addition of history items', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const item = 'foo';\n        history.push(item);\n        const result = await history.back('');\n        expect(result).toBe(item);\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called upon an editor text change","suites":["console/history","ConsoleHistory","#onTextChange()"],"updatePoint":{"line":159,"column":53},"line":159,"code":"      it('should be called upon an editor text change', () => {\n        const history = new TestHistory({ sessionContext });\n        expect(history.methods).toEqual(\n          expect.not.arrayContaining(['onTextChange'])\n        );\n        const model = new CodeEditor.Model();\n        const host = document.createElement('div');\n        const editor = new CodeMirrorEditor({ model, host });\n        history.editor = editor;\n        model.value.text = 'foo';\n        expect(history.methods).toEqual(\n          expect.arrayContaining(['onTextChange'])\n        );\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called upon an editor edge request","suites":["console/history","ConsoleHistory","#onEdgeRequest()"],"updatePoint":{"line":176,"column":54},"line":176,"code":"      it('should be called upon an editor edge request', async () => {\n        const history = new TestHistory({ sessionContext });\n        expect(history.methods).toEqual(\n          expect.not.arrayContaining(['onEdgeRequest'])\n        );\n        const host = document.createElement('div');\n        const model = new CodeEditor.Model();\n        const editor = new CodeMirrorEditor({ model, host });\n        history.editor = editor;\n        history.push('foo');\n        const promise = signalToPromise(editor.model.value.changed);\n        editor.edgeRequested.emit('top');\n        expect(history.methods).toEqual(\n          expect.arrayContaining(['onEdgeRequest'])\n        );\n        await promise;\n        expect(editor.model.value.text).toBe('foo');\n      });","file":"history.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a new console panel","suites":["console/panel","ConsolePanel","#constructor()"],"updatePoint":{"line":56,"column":43},"line":56,"code":"      it('should create a new console panel', () => {\n        expect(panel).toBeInstanceOf(ConsolePanel);\n        expect(Array.from(panel.node.classList)).toEqual(\n          expect.arrayContaining(['jp-ConsolePanel'])\n        );\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a code console widget created at instantiation","suites":["console/panel","ConsolePanel","#console"],"updatePoint":{"line":65,"column":66},"line":65,"code":"      it('should be a code console widget created at instantiation', () => {\n        expect(panel.console).toBeInstanceOf(CodeConsole);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a client session object","suites":["console/panel","ConsolePanel","#session"],"updatePoint":{"line":71,"column":43},"line":71,"code":"      it('should be a client session object', () => {\n        expect(panel.sessionContext.kernelChanged).toBeTruthy();\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should dispose of the resources held by the panel","suites":["console/panel","ConsolePanel","#dispose()"],"updatePoint":{"line":77,"column":59},"line":77,"code":"      it('should dispose of the resources held by the panel', () => {\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should start the session","suites":["console/panel","ConsolePanel","#onAfterAttach()"],"updatePoint":{"line":86,"column":34},"line":86,"code":"      it('should start the session', async () => {\n        Widget.attach(panel, document.body);\n        await panel.sessionContext.ready;\n        await expect(\n          panel.sessionContext.session!.kernel!.info\n        ).resolves.not.toThrow();\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should give the focus to the console prompt","suites":["console/panel","ConsolePanel","#onActivateRequest()"],"updatePoint":{"line":96,"column":53},"line":96,"code":"      it('should give the focus to the console prompt', () => {\n        Widget.attach(panel, document.body);\n        MessageLoop.sendMessage(panel, Widget.Msg.ActivateRequest);\n        expect(panel.console.promptCell!.editor.hasFocus()).toBe(true);\n        return dismissDialog();\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should dispose of the panel resources after closing","suites":["console/panel","ConsolePanel","#onCloseRequest()"],"updatePoint":{"line":105,"column":61},"line":105,"code":"      it('should dispose of the panel resources after closing', () => {\n        Widget.attach(panel, document.body);\n        expect(panel.isDisposed).toBe(false);\n        MessageLoop.sendMessage(panel, Widget.Msg.CloseRequest);\n        expect(panel.isDisposed).toBe(true);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a new code console factory","suites":["console/panel","ConsolePanel",".ContentFactory","#constructor"],"updatePoint":{"line":115,"column":52},"line":115,"code":"        it('should create a new code console factory', () => {\n          const factory = new ConsolePanel.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(ConsolePanel.ContentFactory);\n        });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a console widget","suites":["console/panel","ConsolePanel",".ContentFactory","#createConsole()"],"updatePoint":{"line":122,"column":42},"line":122,"code":"        it('should create a console widget', () => {\n          const options = {\n            contentFactory: contentFactory,\n            rendermime,\n            mimeTypeService,\n            sessionContext: panel.sessionContext\n          };\n          expect(contentFactory.createConsole(options)).toBeInstanceOf(\n            CodeConsole\n          );\n        });","file":"panel.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a new console content widget","suites":["console/widget","CodeConsole","#constructor()"],"updatePoint":{"line":69,"column":52},"line":69,"code":"      it('should create a new console content widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget).toBeInstanceOf(CodeConsole);\n        expect(Array.from(widget.node.classList)).toEqual(\n          expect.arrayContaining(['jp-CodeConsole'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should exist upon instantiation","suites":["console/widget","CodeConsole","#cells"],"updatePoint":{"line":79,"column":41},"line":79,"code":"      it('should exist upon instantiation', () => {\n        expect(widget.cells).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should reflect the contents of the widget","suites":["console/widget","CodeConsole","#cells"],"updatePoint":{"line":83,"column":51},"line":83,"code":"      it('should reflect the contents of the widget', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBe(1);\n        widget.clear();\n        expect(widget.cells.length).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should emit a date upon execution","suites":["console/widget","CodeConsole","#executed"],"updatePoint":{"line":95,"column":43},"line":95,"code":"      it('should emit a date upon execution', async () => {\n        let called: Date | null = null;\n        const force = true;\n        Widget.attach(widget, document.body);\n        widget.executed.connect((sender, time) => {\n          called = time;\n        });\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(called).toBeInstanceOf(Date);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a code cell widget","suites":["console/widget","CodeConsole","#promptCell"],"updatePoint":{"line":109,"column":38},"line":109,"code":"      it('should be a code cell widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be replaced after execution","suites":["console/widget","CodeConsole","#promptCell"],"updatePoint":{"line":114,"column":44},"line":114,"code":"      it('should be replaced after execution', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n\n        const old = widget.promptCell;\n        expect(old).toBeInstanceOf(CodeCell);\n\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n        expect(widget.promptCell).not.toBe(old);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a client session object","suites":["console/widget","CodeConsole","#session"],"updatePoint":{"line":129,"column":43},"line":129,"code":"      it('should be a client session object', () => {\n        expect(widget.sessionContext.sessionChanged).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be the content factory used by the widget","suites":["console/widget","CodeConsole","#contentFactory"],"updatePoint":{"line":135,"column":58},"line":135,"code":"      it('should be the content factory used by the widget', () => {\n        expect(widget.contentFactory).toBeInstanceOf(\n          CodeConsole.ContentFactory\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should add a code cell to the content widget","suites":["console/widget","CodeConsole","#addCell()"],"updatePoint":{"line":143,"column":54},"line":143,"code":"      it('should add a code cell to the content widget', () => {\n        const contentFactory = NBTestUtils.createCodeCellFactory();\n        const model = new CodeCellModel({});\n        const cell = new CodeCell({\n          model,\n          contentFactory,\n          rendermime\n        }).initializeState();\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        widget.addCell(cell);\n        expect(widget.cells.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should clear all of the content cells except the banner","suites":["console/widget","CodeConsole","#clear()"],"updatePoint":{"line":159,"column":65},"line":159,"code":"      it('should clear all of the content cells except the banner', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBeGreaterThan(0);\n        widget.clear();\n        expect(widget.cells.length).toBe(0);\n        expect(widget.promptCell!.model.value.text).toBe('');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should dispose the content widget","suites":["console/widget","CodeConsole","#dispose()"],"updatePoint":{"line":172,"column":43},"line":172,"code":"      it('should dispose the content widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be safe to dispose multiple times","suites":["console/widget","CodeConsole","#dispose()"],"updatePoint":{"line":179,"column":50},"line":179,"code":"      it('should be safe to dispose multiple times', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should execute contents of the prompt if forced","suites":["console/widget","CodeConsole","#execute()"],"updatePoint":{"line":189,"column":57},"line":189,"code":"      it('should execute contents of the prompt if forced', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBeGreaterThan(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should check if code is multiline and allow amending","suites":["console/widget","CodeConsole","#execute()"],"updatePoint":{"line":198,"column":62},"line":198,"code":"      it('should check if code is multiline and allow amending', async () => {\n        const force = false;\n        const timeout = 9000;\n        Widget.attach(widget, document.body);\n        widget.promptCell!.model.value.text = 'for x in range(5):';\n        expect(widget.cells.length).toBe(0);\n        const session = widget.sessionContext as SessionContext;\n        session.kernelPreference = { name: 'ipython' };\n        await session.initialize();\n        await widget.execute(force, timeout);\n        expect(widget.cells.length).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should add a code cell and execute it","suites":["console/widget","CodeConsole","#inject()"],"updatePoint":{"line":213,"column":47},"line":213,"code":"      it('should add a code cell and execute it', async () => {\n        const code = 'print(\"#inject()\")';\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        await widget.inject(code);\n        expect(widget.cells.length).toBeGreaterThan(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should insert a line break into the prompt","suites":["console/widget","CodeConsole","#insertLinebreak()"],"updatePoint":{"line":223,"column":52},"line":223,"code":"      it('should insert a line break into the prompt', () => {\n        Widget.attach(widget, document.body);\n\n        const model = widget.promptCell!.model;\n        expect(model.value.text).toHaveLength(0);\n        widget.insertLinebreak();\n        expect(model.value.text).toBe('\\n');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should serialize the contents of a console","suites":["console/widget","CodeConsole","#serialize()"],"updatePoint":{"line":234,"column":52},"line":234,"code":"      it('should serialize the contents of a console', () => {\n        Widget.attach(widget, document.body);\n        widget.promptCell!.model.value.text = 'foo';\n\n        const serialized = widget.serialize();\n        expect(serialized).toHaveLength(1);\n        expect(serialized[0].source).toBe('foo');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called after attach, creating a prompt","suites":["console/widget","CodeConsole","#newPromptCell()"],"updatePoint":{"line":245,"column":58},"line":245,"code":"      it('should be called after attach, creating a prompt', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['newPromptCell'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n        expect(widget.promptCell).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called after execution, creating a prompt","suites":["console/widget","CodeConsole","#newPromptCell()"],"updatePoint":{"line":257,"column":61},"line":257,"code":"      it('should be called after execution, creating a prompt', async () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['newPromptCell'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n\n        const old = widget.promptCell;\n        const force = true;\n        expect(old).toBeInstanceOf(CodeCell);\n        widget.methods = [];\n\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n        expect(widget.promptCell).not.toBe(old);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should focus the prompt editor","suites":["console/widget","CodeConsole","#onActivateRequest()"],"updatePoint":{"line":284,"column":40},"line":284,"code":"      it('should focus the prompt editor', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onActivateRequest'])\n        );\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onActivateRequest'])\n        );\n        expect(widget.promptCell!.editor.hasFocus()).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be called after attach, creating a prompt","suites":["console/widget","CodeConsole","#onAfterAttach()"],"updatePoint":{"line":299,"column":58},"line":299,"code":"      it('should be called after attach, creating a prompt', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onAfterAttach'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        expect(widget.promptCell).toBeTruthy();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a new ContentFactory","suites":["console/widget","CodeConsole",".ContentFactory","#constructor"],"updatePoint":{"line":314,"column":46},"line":314,"code":"        it('should create a new ContentFactory', () => {\n          const factory = new CodeConsole.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(CodeConsole.ContentFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a code cell","suites":["console/widget","CodeConsole",".ContentFactory","#createCodeCell"],"updatePoint":{"line":321,"column":37},"line":321,"code":"        it('should create a code cell', () => {\n          const model = new CodeCellModel({});\n          const prompt = contentFactory.createCodeCell({\n            rendermime: widget.rendermime,\n            model,\n            contentFactory\n          });\n          expect(prompt).toBeInstanceOf(CodeCell);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a foreign cell","suites":["console/widget","CodeConsole",".ContentFactory","#createRawCell"],"updatePoint":{"line":333,"column":40},"line":333,"code":"        it('should create a foreign cell', () => {\n          const model = new RawCellModel({});\n          const prompt = contentFactory.createRawCell({\n            model,\n            contentFactory\n          });\n          expect(prompt).toBeInstanceOf(RawCell);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a new model factory","suites":["console/widget","CodeConsole",".ModelFactory","#constructor()"],"updatePoint":{"line":346,"column":45},"line":346,"code":"        it('should create a new model factory', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory).toBeInstanceOf(CodeConsole.ModelFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should accept a codeCellContentFactory","suites":["console/widget","CodeConsole",".ModelFactory","#constructor()"],"updatePoint":{"line":351,"column":50},"line":351,"code":"        it('should accept a codeCellContentFactory', () => {\n          const codeCellContentFactory = new CodeCellModel.ContentFactory();\n          const factory = new CodeConsole.ModelFactory({\n            codeCellContentFactory\n          });\n          expect(factory.codeCellContentFactory).toBe(codeCellContentFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be the code cell content factory used by the factory","suites":["console/widget","CodeConsole",".ModelFactory","#codeCellContentFactory"],"updatePoint":{"line":361,"column":71},"line":361,"code":"        it('should be the code cell content factory used by the factory', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory.codeCellContentFactory).toBe(\n            CodeCellModel.defaultContentFactory\n          );\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a code cell","suites":["console/widget","CodeConsole",".ModelFactory","#createCodeCell()"],"updatePoint":{"line":370,"column":37},"line":370,"code":"        it('should create a code cell', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory.createCodeCell({})).toBeInstanceOf(CodeCellModel);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should create a raw cell model","suites":["console/widget","CodeConsole",".ModelFactory","#createRawCell()"],"updatePoint":{"line":377,"column":42},"line":377,"code":"        it('should create a raw cell model', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory.createRawCell({})).toBeInstanceOf(RawCellModel);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should be a ModelFactory","suites":["console/widget","CodeConsole",".defaultModelFactory"],"updatePoint":{"line":385,"column":34},"line":385,"code":"      it('should be a ModelFactory', () => {\n        expect(CodeConsole.defaultModelFactory).toBeInstanceOf(\n          CodeConsole.ModelFactory\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/console/test"},{"name":"should accept a signal","suites":["@jupyterlab/coreutils","ActivityMonitor()","#constructor()"],"updatePoint":{"line":25,"column":32},"line":25,"code":"      it('should accept a signal', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor).toBeInstanceOf(ActivityMonitor);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should accept a timeout","suites":["@jupyterlab/coreutils","ActivityMonitor()","#constructor()"],"updatePoint":{"line":30,"column":33},"line":30,"code":"      it('should accept a timeout', () => {\n        const monitor = new ActivityMonitor<TestObject, string[]>({\n          signal: testObj.two,\n          timeout: 100\n        });\n        expect(monitor).toBeInstanceOf(ActivityMonitor);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should be emitted after the signal has fired and a timeout","suites":["@jupyterlab/coreutils","ActivityMonitor()","#activityStopped"],"updatePoint":{"line":40,"column":68},"line":40,"code":"      it('should be emitted after the signal has fired and a timeout', async () => {\n        let called = false;\n        const monitor = new ActivityMonitor({ signal, timeout: 100 });\n        monitor.activityStopped.connect((sender, args) => {\n          expect(sender).toBe(monitor);\n          expect(args.sender).toBe(testObj);\n          expect(args.args).toBe(10);\n          called = true;\n        });\n        signal.emit(10);\n        expect(called).toBe(false);\n        await sleep(100);\n        expect(called).toBe(true);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should default to `1000`","suites":["@jupyterlab/coreutils","ActivityMonitor()","#timeout"],"updatePoint":{"line":57,"column":34},"line":57,"code":"      it('should default to `1000`', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor.timeout).toBe(1000);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should be set-able","suites":["@jupyterlab/coreutils","ActivityMonitor()","#timeout"],"updatePoint":{"line":62,"column":28},"line":62,"code":"      it('should be set-able', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.timeout = 200;\n        expect(monitor.timeout).toBe(200);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should test whether the monitor is disposed","suites":["@jupyterlab/coreutils","ActivityMonitor()","#isDisposed"],"updatePoint":{"line":70,"column":53},"line":70,"code":"      it('should test whether the monitor is disposed', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor.isDisposed).toBe(false);\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should dispose of the resources used by the monitor","suites":["@jupyterlab/coreutils","ActivityMonitor()","#dispose()"],"updatePoint":{"line":79,"column":61},"line":79,"code":"      it('should dispose of the resources used by the monitor', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should be a no-op if called more than once","suites":["@jupyterlab/coreutils","ActivityMonitor()","#dispose()"],"updatePoint":{"line":85,"column":52},"line":85,"code":"      it('should be a no-op if called more than once', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.dispose();\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });","file":"activitymonitor.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return true for a valid markdown extension","suites":["@jupyterlab/coreutils","MarkdownCodeBlocks",".isMarkdown()"],"updatePoint":{"line":15,"column":59},"line":15,"code":"      it('should return true for a valid markdown extension', () => {\n        const isMarkdown = MarkdownCodeBlocks.isMarkdown('.md');\n        expect(isMarkdown).toBe(true);\n      });","file":"markdowncodeblocks.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should find a simple block","suites":["@jupyterlab/coreutils","MarkdownCodeBlocks",".findMarkdownCodeBlocks()"],"updatePoint":{"line":22,"column":36},"line":22,"code":"      it('should find a simple block', () => {\n        const codeblocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(\n          MULTI_LINE_BLOCK\n        );\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10\\nb = 20\\n');\n      });","file":"markdowncodeblocks.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should find a single line block","suites":["@jupyterlab/coreutils","MarkdownCodeBlocks",".findMarkdownCodeBlocks()"],"updatePoint":{"line":30,"column":41},"line":30,"code":"      it('should find a single line block', () => {\n        const codeblocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(\n          SINGLE_LINE_BLOCK\n        );\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10');\n      });","file":"markdowncodeblocks.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should find a block with a language","suites":["@jupyterlab/coreutils","MarkdownCodeBlocks",".findMarkdownCodeBlocks()"],"updatePoint":{"line":38,"column":45},"line":38,"code":"      it('should find a block with a language', () => {\n        const codeblocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(\n          MULTI_LINE_BLOCK_WITH_LANGUAGE\n        );\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10\\nb = 20\\n');\n      });","file":"markdowncodeblocks.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get a known option","suites":["@jupyterlab/coreutils","PageConfig","#getOption()"],"updatePoint":{"line":14,"column":35},"line":14,"code":"      it('should get a known option', () => {\n        expect(PageConfig.getOption('foo')).toBe('bar');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return an empty string for an unknown option","suites":["@jupyterlab/coreutils","PageConfig","#getOption()"],"updatePoint":{"line":18,"column":61},"line":18,"code":"      it('should return an empty string for an unknown option', () => {\n        expect(PageConfig.getOption('bar')).toBe('');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get last option value and set it to the passed value","suites":["@jupyterlab/coreutils","PageConfig","#setOption()"],"updatePoint":{"line":24,"column":69},"line":24,"code":"      it('should get last option value and set it to the passed value', () => {\n        expect(PageConfig.setOption('foo', 'bar1')).toBe('bar');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get a known option","suites":["@jupyterlab/coreutils","PageConfig","#setOption()"],"updatePoint":{"line":28,"column":35},"line":28,"code":"      it('should get a known option', () => {\n        expect(PageConfig.getOption('foo')).toBe('bar');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should add a new option","suites":["@jupyterlab/coreutils","PageConfig","#setOption()"],"updatePoint":{"line":32,"column":33},"line":32,"code":"      it('should add a new option', () => {\n        expect(PageConfig.setOption('bar', 'foo')).toBe('');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get a different known option","suites":["@jupyterlab/coreutils","PageConfig","#setOption()"],"updatePoint":{"line":36,"column":45},"line":36,"code":"      it('should get a different known option', () => {\n        expect(PageConfig.getOption('bar')).toBe('foo');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get the base url of the page","suites":["@jupyterlab/coreutils","PageConfig","#getBaseUrl()"],"updatePoint":{"line":42,"column":45},"line":42,"code":"      it('should get the base url of the page', () => {\n        // The value was passed as a command line arg.\n        expect(PageConfig.getBaseUrl()).toContain('http://localhost');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get the base ws url of the page","suites":["@jupyterlab/coreutils","PageConfig","#getWsUrl()"],"updatePoint":{"line":49,"column":48},"line":49,"code":"      it('should get the base ws url of the page', () => {\n        // The value was passed as a command line arg.\n        const expected = 'ws' + PageConfig.getBaseUrl().slice(4);\n        expect(PageConfig.getWsUrl()).toBe(expected);\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle a good base url","suites":["@jupyterlab/coreutils","PageConfig","#getWsUrl()"],"updatePoint":{"line":55,"column":39},"line":55,"code":"      it('should handle a good base url', () => {\n        const url = 'http://foo.com';\n        expect(PageConfig.getWsUrl(url)).toBe('ws://foo.com/');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should be an empty string for a bad base url","suites":["@jupyterlab/coreutils","PageConfig","#getWsUrl()"],"updatePoint":{"line":60,"column":54},"line":60,"code":"      it('should be an empty string for a bad base url', () => {\n        const url = 'blargh://foo.com';\n        expect(PageConfig.getWsUrl(url)).toBe('');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return shortest url by default","suites":["@jupyterlab/coreutils","PageConfig","#getUrl()"],"updatePoint":{"line":69,"column":47},"line":69,"code":"      it('should return shortest url by default', () => {\n        const url = PageConfig.getUrl({});\n        expect(url).toEqual('http://localhost/lab');\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return a local shareable url if shareUrl is undefined","suites":["@jupyterlab/coreutils","PageConfig","#getUrl()"],"updatePoint":{"line":74,"column":70},"line":74,"code":"      it('should return a local shareable url if shareUrl is undefined', () => {\n        const url = PageConfig.getUrl({\n          workspace: PageConfig.defaultWorkspace,\n          treePath: path,\n          toShare: true\n        });\n\n        expect(url).toEqual(`http://localhost/lab/tree${path}`);\n      });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return a non-local shareable url if shareUrl is defined","suites":["@jupyterlab/coreutils","PageConfig","#getUrl()","hub environment"],"updatePoint":{"line":91,"column":74},"line":91,"code":"        it('should return a non-local shareable url if shareUrl is defined', () => {\n          const url = PageConfig.getUrl({\n            workspace: PageConfig.defaultWorkspace,\n            treePath: path,\n            toShare: true\n          });\n\n          expect(url).toEqual(`${shareUrl}/lab/tree${path}`);\n        });","file":"pageconfig.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should join the arguments and normalize the path","suites":["@jupyterlab/coreutils","PathExt",".join()"],"updatePoint":{"line":11,"column":58},"line":11,"code":"      it('should join the arguments and normalize the path', () => {\n        const path = PathExt.join('foo', '../../../bar');\n        expect(path).toBe('../../bar');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should not return \".\" for an empty path","suites":["@jupyterlab/coreutils","PathExt",".join()"],"updatePoint":{"line":16,"column":49},"line":16,"code":"      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.join('', '');\n        expect(path).toBe('');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return the last portion of a path","suites":["@jupyterlab/coreutils","PathExt",".basename()"],"updatePoint":{"line":23,"column":50},"line":23,"code":"      it('should return the last portion of a path', () => {\n        expect(PathExt.basename(TESTPATH)).toBe('test-path.js');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get the directory name of a path","suites":["@jupyterlab/coreutils","PathExt",".dirname()"],"updatePoint":{"line":29,"column":49},"line":29,"code":"      it('should get the directory name of a path', () => {\n        expect(PathExt.dirname(TESTPATH)).toBe('foo/test/simple');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should not return \".\" for an empty path","suites":["@jupyterlab/coreutils","PathExt",".dirname()"],"updatePoint":{"line":33,"column":49},"line":33,"code":"      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.dirname('');\n        expect(path).toBe('');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should not return \".\" for a path in the root directory","suites":["@jupyterlab/coreutils","PathExt",".dirname()"],"updatePoint":{"line":38,"column":64},"line":38,"code":"      it('should not return \".\" for a path in the root directory', () => {\n        const path = PathExt.dirname('foo.txt');\n        expect(path).toBe('');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should get the file extension of the path","suites":["@jupyterlab/coreutils","PathExt",".extname()"],"updatePoint":{"line":45,"column":51},"line":45,"code":"      it('should get the file extension of the path', () => {\n        expect(PathExt.extname(TESTPATH)).toBe('.js');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should only take the last occurrence of a dot","suites":["@jupyterlab/coreutils","PathExt",".extname()"],"updatePoint":{"line":49,"column":55},"line":49,"code":"      it('should only take the last occurrence of a dot', () => {\n        expect(PathExt.extname('foo.tar.gz')).toBe('.gz');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should normalize a string path","suites":["@jupyterlab/coreutils","PathExt",".normalize()"],"updatePoint":{"line":55,"column":40},"line":55,"code":"      it('should normalize a string path', () => {\n        const path = PathExt.normalize('./fixtures///b/../b/c.js');\n        expect(path).toBe('fixtures/b/c.js');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should not return \".\" for an empty path","suites":["@jupyterlab/coreutils","PathExt",".normalize()"],"updatePoint":{"line":60,"column":49},"line":60,"code":"      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.normalize('');\n        expect(path).toBe('');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should resolve a sequence of paths to an absolute path on the server","suites":["@jupyterlab/coreutils","PathExt",".resolve()"],"updatePoint":{"line":67,"column":78},"line":67,"code":"      it('should resolve a sequence of paths to an absolute path on the server', () => {\n        const path = PathExt.resolve('var/src', '../', 'file/');\n        expect(path.indexOf('var/file')).not.toBe(-1);\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should solve the relative path","suites":["@jupyterlab/coreutils","PathExt",".relative()"],"updatePoint":{"line":74,"column":40},"line":74,"code":"      it('should solve the relative path', () => {\n        const path = PathExt.relative('var/src', 'var/apache');\n        expect(path).toBe('../apache');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should normalize a file extension to be of type `.foo`","suites":["@jupyterlab/coreutils","PathExt",".normalizeExtension()"],"updatePoint":{"line":81,"column":64},"line":81,"code":"      it('should normalize a file extension to be of type `.foo`', () => {\n        expect(PathExt.normalizeExtension('foo')).toBe('.foo');\n        expect(PathExt.normalizeExtension('.bar')).toBe('.bar');\n      });","file":"path.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should convert a time to a human readable string","suites":["@jupyterlab/coreutils","Time",".formatHuman()"],"updatePoint":{"line":9,"column":58},"line":9,"code":"      it('should convert a time to a human readable string', () => {\n        const date = new Date();\n        date.setSeconds(date.getSeconds() - 10);\n        const value = Time.formatHuman(date);\n        expect(value).toBe('seconds ago');\n        date.setMinutes(date.getMinutes() - 3);\n        expect(Time.formatHuman(date.toISOString())).toBe('3 minutes ago');\n      });","file":"time.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should convert a timestring to a date format","suites":["@jupyterlab/coreutils","Time",".format()"],"updatePoint":{"line":20,"column":54},"line":20,"code":"      it('should convert a timestring to a date format', () => {\n        expect(Time.format(new Date()).length).toBe(16);\n        const date = new Date();\n        const value = Time.format(date.toISOString(), 'MM-DD');\n        expect(value.length).toBe(5);\n      });","file":"time.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should parse a url into a URLExt object","suites":["@jupyterlab/coreutils","URLExt",".parse()"],"updatePoint":{"line":9,"column":49},"line":9,"code":"      it('should parse a url into a URLExt object', () => {\n        const obj = URLExt.parse('http://www.example.com');\n        expect(obj.href).toBe('http://www.example.com/');\n        expect(obj.protocol).toBe('http:');\n        expect(obj.host).toBe('www.example.com');\n        expect(obj.hostname).toBe('www.example.com');\n        expect(obj.pathname).toBe('/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle query and hash","suites":["@jupyterlab/coreutils","URLExt",".parse()"],"updatePoint":{"line":18,"column":38},"line":18,"code":"      it('should handle query and hash', () => {\n        const url = \"http://example.com/path?that's#all, folks\";\n        const obj = URLExt.parse(url);\n        // Chrome has a different href\n        expect([\n          'http://example.com/path?that%27s#all,%20folks',\n          'http://example.com/path?that%27s#all, folks'\n        ]).toContain(obj.href);\n        expect(obj.protocol).toBe('http:');\n        expect(obj.host).toBe('example.com');\n        expect(obj.hostname).toBe('example.com');\n        expect(obj.search).toBe('?that%27s');\n        expect(obj.pathname).toBe('/path');\n        // Chrome has a different hash\n        expect(['#all,%20folks', '#all, folks']).toContain(obj.hash);\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should join a sequence of url components","suites":["@jupyterlab/coreutils","URLExt",".join()"],"updatePoint":{"line":37,"column":50},"line":37,"code":"      it('should join a sequence of url components', () => {\n        expect(URLExt.join('/foo/', 'bar/')).toBe('/foo/bar/');\n        expect(URLExt.join('//example.com', 'bar/')).toBe('//example.com/bar/');\n        expect(URLExt.join('//example.com', 'foo:bar/')).toBe(\n          '//example.com/foo:bar/'\n        );\n        expect(URLExt.join('http://www.example.com/', '/bar')).toBe(\n          'http://www.example.com/bar'\n        );\n        expect(URLExt.join('http://user:pass@www.example.com/', '/bar')).toBe(\n          'http://user:pass@www.example.com/bar'\n        );\n        expect(URLExt.join('//example.com', 'foo:bar:', 'baz')).toBe(\n          '//example.com/foo:bar:/baz'\n        );\n        expect(URLExt.join('http://example.com', 'foo:bar:', 'baz')).toBe(\n          'http://example.com/foo:bar:/baz'\n        );\n        expect(\n          URLExt.join('http://example.com', 'foo', '..', '..', 'bar/')\n        ).toBe('http://example.com/bar/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should encode and join a sequence of url components","suites":["@jupyterlab/coreutils","URLExt",".encodeParts()"],"updatePoint":{"line":62,"column":61},"line":62,"code":"      it('should encode and join a sequence of url components', () => {\n        expect(URLExt.encodeParts('>/>')).toBe('%3E/%3E');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle leading slash","suites":["@jupyterlab/coreutils","URLExt",".normalize()"],"updatePoint":{"line":68,"column":37},"line":68,"code":"      it('should handle leading slash', () => {\n        expect(URLExt.normalize('/')).toBe(location.origin + '/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle leading double slash","suites":["@jupyterlab/coreutils","URLExt",".normalize()"],"updatePoint":{"line":72,"column":44},"line":72,"code":"      it('should handle leading double slash', () => {\n        expect(URLExt.normalize('//foo')).toBe(location.protocol + '//foo/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle http","suites":["@jupyterlab/coreutils","URLExt",".normalize()"],"updatePoint":{"line":76,"column":28},"line":76,"code":"      it('should handle http', () => {\n        expect(URLExt.normalize('http://foo')).toBe('http://foo/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should handle other","suites":["@jupyterlab/coreutils","URLExt",".normalize()"],"updatePoint":{"line":80,"column":29},"line":80,"code":"      it('should handle other', () => {\n        expect(URLExt.normalize('ftp://foo')).toBe('ftp://foo/');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should return a serialized object string suitable for a query","suites":["@jupyterlab/coreutils","URLExt","objectToQueryString()"],"updatePoint":{"line":86,"column":71},"line":86,"code":"      it('should return a serialized object string suitable for a query', () => {\n        const obj = {\n          name: 'foo',\n          id: 'baz'\n        };\n        expect(URLExt.objectToQueryString(obj)).toBe('?name=foo&id=baz');\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should test whether the url is a local url","suites":["@jupyterlab/coreutils","URLExt",".isLocal()"],"updatePoint":{"line":96,"column":52},"line":96,"code":"      it('should test whether the url is a local url', () => {\n        expect(URLExt.isLocal('https://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('http://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('//foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('file://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('data:text/plain,123ABC')).toBe(false);\n        expect(URLExt.isLocal('/foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('httpserver/index.html')).toBe(true);\n        expect(URLExt.isLocal('../foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('./foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('bar.txt')).toBe(true);\n      });","file":"url.spec.ts","skipped":false,"dir":"packages/coreutils/test"},{"name":"should instantiate a `DSVModel`","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":88,"column":41},"line":88,"code":"      it('should instantiate a `DSVModel`', () => {\n        const d = new DSVModel({ data: 'a,b,c\\nd,e,f\\n', delimiter: ',' });\n        expect(d.rowCount('column-header')).toBe(1);\n        expect(d.rowCount('body')).toBe(1);\n        expect(d.columnCount('row-header')).toBe(1);\n        expect(d.columnCount('body')).toBe(3);\n        expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n          'a',\n          'b',\n          'c'\n        ]);\n        expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n          'd',\n          'e',\n          'f'\n        ]);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"parses a number of test files correctly","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":107,"column":47},"line":107,"code":"    it('parses a number of test files correctly', () => {\n      for (const [, csv, answer] of CSV_TEST_FILES) {\n        const d = new DSVModel({ data: csv, delimiter: ',' });\n        const labels = [];\n        for (let i = 0; i < d.columnCount('body'); i++) {\n          labels.push(d.data('column-header', 0, i));\n        }\n        const values = [];\n        for (let r = 0; r < d.rowCount('body'); r++) {\n          const row: { [key: string]: string } = {};\n          for (let c = 0; c < d.columnCount('body'); c++) {\n            row[labels[c]] = d.data('body', r, c);\n          }\n          values.push(row);\n        }\n        expect(values).toEqual(answer);\n      }\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles tab-separated data","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":126,"column":34},"line":126,"code":"    it('handles tab-separated data', () => {\n      const d = new DSVModel({ data: 'a\\tb\\tc\\nd\\te\\tf\\n', delimiter: '\\t' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles not having a header","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":140,"column":35},"line":140,"code":"    it('handles not having a header', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\nd,e,f\\n',\n        delimiter: ',',\n        header: false\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(2);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        '1',\n        '2',\n        '3'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['a', 'b', 'c']);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles having only a header","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":159,"column":36},"line":159,"code":"    it('handles having only a header', () => {\n      const d = new DSVModel({ data: 'a,b,c\\n', delimiter: ',', header: true });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(0);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles single non-header line","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":172,"column":38},"line":172,"code":"    it('handles single non-header line', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\n',\n        delimiter: ',',\n        header: false\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        '1',\n        '2',\n        '3'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['a', 'b', 'c']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles CRLF row delimiter","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":190,"column":34},"line":190,"code":"    it('handles CRLF row delimiter', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\r\\nd,e,f\\r\\n',\n        delimiter: ',',\n        rowDelimiter: '\\r\\n'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles CR row delimiter","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":208,"column":32},"line":208,"code":"    it('handles CR row delimiter', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\rd,e,f\\r',\n        delimiter: ',',\n        rowDelimiter: '\\r'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"can guess the row delimiter","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":226,"column":35},"line":226,"code":"    it('can guess the row delimiter', () => {\n      const d = new DSVModel({ data: 'a,b,c\\rd,e,f\\r', delimiter: ',' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a given quote character","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":240,"column":39},"line":240,"code":"    it('handles a given quote character', () => {\n      const d = new DSVModel({\n        data: `a,'b','c'\\r'd',e,'f'\\r`,\n        delimiter: ',',\n        quote: `'`\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles delimiters and quotes inside quotes","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":258,"column":51},"line":258,"code":"    it('handles delimiters and quotes inside quotes', () => {\n      const d = new DSVModel({\n        data: `'a\\rx',b,'c''x'\\r'd,x',e,'f'\\r`,\n        delimiter: ',',\n        quote: `'`,\n        rowDelimiter: '\\r'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a\\rx',\n        'b',\n        `c'x`\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        'd,x',\n        'e',\n        'f'\n      ]);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles rows that are too short or too long","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":281,"column":51},"line":281,"code":"    it('handles rows that are too short or too long', () => {\n      const d = new DSVModel({ data: `a,b,c\\n,c,d,e,f\\ng,h`, delimiter: ',' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(2);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        '',\n        'c',\n        'd,e,f'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['g', 'h', '']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles delayed parsing of rows past the initial rows","suites":["csvviewer/model","DSVModel","#constructor()"],"updatePoint":{"line":300,"column":61},"line":300,"code":"    it('handles delayed parsing of rows past the initial rows', async () => {\n      const d = new DSVModel({\n        data: `a,b,c\\nc,d,e\\nf,g,h\\ni,j,k`,\n        delimiter: ',',\n        initialRows: 2\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n\n      // Expected behavior is that all unparsed data is lumped into the final field.\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        'c',\n        'd',\n        'e\\nf,g,h\\ni,j,k'\n      ]);\n\n      // Check everything is in order after all the data has been parsed asynchronously.\n      await d.ready;\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(3);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['c', 'd', 'e']);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['f', 'g', 'h']);\n      expect([0, 1, 2].map(i => d.data('body', 2, i))).toEqual(['i', 'j', 'k']);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"does basic parsing of csv files","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":8,"column":39},"line":8,"code":"    it('does basic parsing of csv files', () => {\n      const data = `a,b,c,d\\r\\n0,1,2,3\\r\\n4,5,6,7`;\n      const options = { data };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([0, 9, 18]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        9,\n        11,\n        13,\n        15,\n        18,\n        20,\n        22,\n        24\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles trailing row delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":39,"column":38},"line":39,"code":"    it('handles trailing row delimiter', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        12,\n        14,\n        16,\n        18,\n        20,\n        22\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles single-line data","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":67,"column":32},"line":67,"code":"    it('handles single-line data', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles changing the field delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":82,"column":44},"line":82,"code":"    it('handles changing the field delimiter', () => {\n      const data = `a\\tb\\tc\\td\\n0\\t1\\t2\\t3\\n4\\t5\\t6\\t7\\n`;\n      const options = { data, delimiter: '\\t', rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        12,\n        14,\n        16,\n        18,\n        20,\n        22\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles starting on a new row","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":110,"column":37},"line":110,"code":"    it('handles starting on a new row', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14, 16, 18, 20, 22]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a max row argument","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":125,"column":34},"line":125,"code":"    it('handles a max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', maxRows: 2 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 8, 10, 12, 14]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a start index and max row argument","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":140,"column":50},"line":140,"code":"    it('handles a start index and max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8, maxRows: 1 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match first row by default","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":155,"column":53},"line":155,"code":"    it('adjusts columns to match first row by default', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        10,\n        10,\n        11,\n        13,\n        15,\n        17\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match first row by default with CRLF row delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":183,"column":77},"line":183,"code":"    it('adjusts columns to match first row by default with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        9,\n        11,\n        11,\n        11,\n        13,\n        15,\n        17,\n        19\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":211,"column":38},"line":211,"code":"    it('adjusts columns to match ncols', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        7,\n        8,\n        10,\n        10,\n        10,\n        10,\n        11,\n        13,\n        15,\n        17,\n        19\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with CRLF row delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":242,"column":62},"line":242,"code":"    it('adjusts columns to match ncols with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        7,\n        9,\n        11,\n        11,\n        11,\n        11,\n        13,\n        15,\n        17,\n        19,\n        21\n      ]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with one row","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":273,"column":51},"line":273,"code":"    it('adjusts columns to match ncols with one row', () => {\n      const data = `a,b,c,d`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with one row and trailing delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":288,"column":74},"line":288,"code":"    it('adjusts columns to match ncols with one row and trailing delimiter', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a single row delimiter","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":303,"column":38},"line":303,"code":"    it('handles a single row delimiter', () => {\n      const data = `\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles adding columns or merging columns as necessary","suites":["csvviewer/parsenoquotes","parseDSVNoQuotes"],"updatePoint":{"line":318,"column":62},"line":318,"code":"    it('handles adding columns or merging columns as necessary', () => {\n      const data = `a,b,c\\n,c,d,e,f\\ng,h`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 6, 15]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 9, 15, 17, 18]);\n    });","file":"parse-noquotes.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"does basic parsing of csv files","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":8,"column":39},"line":8,"code":"    it('does basic parsing of csv files', () => {\n      const data = `a,b,c,d\\r\\n0,1,2,3\\r\\n4,5,6,7`;\n      const options = { data };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([0, 9, 18]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        9,\n        11,\n        13,\n        15,\n        18,\n        20,\n        22,\n        24\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles trailing row delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":39,"column":38},"line":39,"code":"    it('handles trailing row delimiter', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        12,\n        14,\n        16,\n        18,\n        20,\n        22\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles single-line data","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":67,"column":32},"line":67,"code":"    it('handles single-line data', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles changing the field delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":82,"column":44},"line":82,"code":"    it('handles changing the field delimiter', () => {\n      const data = `a\\tb\\tc\\td\\n0\\t1\\t2\\t3\\n4\\t5\\t6\\t7\\n`;\n      const options = { data, delimiter: '\\t', rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        12,\n        14,\n        16,\n        18,\n        20,\n        22\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles starting on a new row","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":110,"column":37},"line":110,"code":"    it('handles starting on a new row', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14, 16, 18, 20, 22]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a max row argument","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":125,"column":34},"line":125,"code":"    it('handles a max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', maxRows: 2 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 8, 10, 12, 14]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a start index and max row argument","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":140,"column":50},"line":140,"code":"    it('handles a start index and max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8, maxRows: 1 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match first row by default","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":155,"column":53},"line":155,"code":"    it('adjusts columns to match first row by default', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        8,\n        10,\n        10,\n        10,\n        11,\n        13,\n        15,\n        17\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match first row by default with CRLF row delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":183,"column":77},"line":183,"code":"    it('adjusts columns to match first row by default with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        9,\n        11,\n        11,\n        11,\n        13,\n        15,\n        17,\n        19\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":211,"column":38},"line":211,"code":"    it('adjusts columns to match ncols', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        7,\n        8,\n        10,\n        10,\n        10,\n        10,\n        11,\n        13,\n        15,\n        17,\n        19\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with CRLF row delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":242,"column":62},"line":242,"code":"    it('adjusts columns to match ncols with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0,\n        2,\n        4,\n        6,\n        7,\n        9,\n        11,\n        11,\n        11,\n        11,\n        13,\n        15,\n        17,\n        19,\n        21\n      ]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with one row","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":273,"column":51},"line":273,"code":"    it('adjusts columns to match ncols with one row', () => {\n      const data = `a,b,c,d`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"adjusts columns to match ncols with one row and trailing delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":288,"column":74},"line":288,"code":"    it('adjusts columns to match ncols with one row and trailing delimiter', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles a single row delimiter","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":303,"column":38},"line":303,"code":"    it('handles a single row delimiter', () => {\n      const data = `\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles adding columns or merging columns as necessary","suites":["csvviewer/parse","parseDSV"],"updatePoint":{"line":318,"column":62},"line":318,"code":"    it('handles adding columns or merging columns as necessary', () => {\n      const data = `a,b,c\\n,c,d,e,f\\ng,h`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 6, 15]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 9, 15, 17, 18]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"does basic parsing of quoted csv files","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":335,"column":46},"line":335,"code":"    it('does basic parsing of quoted csv files', () => {\n      const data = `first,\"last\",address,city,zip`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([0, 6, 13, 21, 26]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles quotes with field delimiters","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":350,"column":44},"line":350,"code":"    it('handles quotes with field delimiters', () => {\n      const data = `a,\"b,c\",d\\n\"e\",\"f\"`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 10]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 8, 10, 14, 17]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles quotes with row delimiters","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":365,"column":42},"line":365,"code":"    it('handles quotes with row delimiters', () => {\n      const data = `a,\"b\\nc\",d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 10]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 8, 10, 12, 13]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles quotes with escaped quotes","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":380,"column":42},"line":380,"code":"    it('handles quotes with escaped quotes', () => {\n      const data = `a,\"b\"\"c\",d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 9, 11, 13, 14]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles setting the quote character","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":395,"column":43},"line":395,"code":"    it('handles setting the quote character', () => {\n      const data = `a,'b'',\\nc',d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n', quote: `'` };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 11, 13, 15, 16]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles single quoted field","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":410,"column":35},"line":410,"code":"    it('handles single quoted field', () => {\n      const data = `\"a\"`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles empty quoted field","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":425,"column":34},"line":425,"code":"    it('handles empty quoted field', () => {\n      const data = `a,\"\",b`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 5]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"handles empty file","suites":["csvviewer/parse","parseDSV quotes"],"updatePoint":{"line":440,"column":26},"line":440,"code":"    it('handles empty file', () => {\n      const data = ``;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(0);\n      expect(results.offsets).toEqual([]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(0);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([]);\n    });","file":"parse.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should instantiate a `CSVDelimiter` toolbar widget","suites":["csvviewer/toolbar","CSVDelimiter","#constructor()"],"updatePoint":{"line":24,"column":60},"line":24,"code":"      it('should instantiate a `CSVDelimiter` toolbar widget', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget).toBeInstanceOf(CSVDelimiter);\n        expect(Array.from(widget.node.classList)).toEqual(\n          expect.arrayContaining(['jp-CSVDelimiter'])\n        );\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should allow pre-selecting the delimiter","suites":["csvviewer/toolbar","CSVDelimiter","#constructor()"],"updatePoint":{"line":33,"column":50},"line":33,"code":"      it('should allow pre-selecting the delimiter', () => {\n        const wanted = (delimiter = DELIMITERS[DELIMITERS.length - 1]);\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.selectNode.value).toBe(wanted);\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should emit a value when the dropdown value changes","suites":["csvviewer/toolbar","CSVDelimiter","#delimiterChanged"],"updatePoint":{"line":42,"column":61},"line":42,"code":"      it('should emit a value when the dropdown value changes', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        let delimiterTest = '';\n        const index = DELIMITERS.length - 1;\n        const wanted = DELIMITERS[index];\n        widget.delimiterChanged.connect((s, value) => {\n          delimiterTest = value;\n        });\n        Widget.attach(widget, document.body);\n        widget.selectNode.selectedIndex = index;\n        simulate(widget.selectNode, 'change');\n        expect(delimiterTest).toBe(wanted);\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should change the delimiter","suites":["csvviewer/toolbar","CSVDelimiter","#handleEvent"],"updatePoint":{"line":59,"column":37},"line":59,"code":"      it('should change the delimiter', () => {\n        const viewer = mockViewer();\n        const widget = new CSVDelimiter({ widget: viewer });\n        const wanted = DELIMITERS[1];\n        widget.selectNode.value = wanted;\n        widget.handleEvent({ type: 'change' } as any);\n        expect(viewer.delimiter).toBe(wanted);\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should return the delimiter dropdown select tag","suites":["csvviewer/toolbar","CSVDelimiter","#selectNode"],"updatePoint":{"line":71,"column":57},"line":71,"code":"      it('should return the delimiter dropdown select tag', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.selectNode.tagName.toLowerCase()).toBe('select');\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should dispose of the resources held by the widget","suites":["csvviewer/toolbar","CSVDelimiter","#dispose()"],"updatePoint":{"line":79,"column":60},"line":79,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should be safe to call multiple times","suites":["csvviewer/toolbar","CSVDelimiter","#dispose()"],"updatePoint":{"line":86,"column":47},"line":86,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should instantiate a `CSVViewer`","suites":["csvviewer/widget","CSVViewer","#constructor()"],"updatePoint":{"line":26,"column":42},"line":26,"code":"      it('should instantiate a `CSVViewer`', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget).toBeInstanceOf(CSVViewer);\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should be the context for the file","suites":["csvviewer/widget","CSVViewer","#context"],"updatePoint":{"line":34,"column":44},"line":34,"code":"      it('should be the context for the file', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.context).toBe(context);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should dispose of the resources held by the widget","suites":["csvviewer/widget","CSVViewer","#dispose()"],"updatePoint":{"line":41,"column":60},"line":41,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should be safe to call multiple times","suites":["csvviewer/widget","CSVViewer","#dispose()"],"updatePoint":{"line":48,"column":47},"line":48,"code":"      it('should be safe to call multiple times', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"searches incrementally and set background color","suites":["csvviewer/widget","GridSearchService"],"updatePoint":{"line":82,"column":55},"line":82,"code":"    it('searches incrementally and set background color', () => {\n      const model = createModel();\n      const searchService = createGridSearchService(model);\n\n      const cellRenderer = searchService.cellBackgroundColorRendererFunc({\n        matchBackgroundColor: 'anotherMatch',\n        currentMatchBackgroundColor: 'currentMatch',\n        textColor: '',\n        horizontalAlignment: 'right'\n      });\n\n      /**\n       * fake rendering a cell and returns the background color for this coordinate.\n       */\n      function fakeRenderCell(row: number, column: number) {\n        const cellConfig = {\n          value: model.data('body', row, column),\n          row,\n          column\n        } as CellRenderer.CellConfig;\n        return cellRenderer(cellConfig);\n      }\n\n      // searching for \"match\", cells at (0,1) and (1,1) should match.\n      // (0,1) is the current match\n      const query = /match/;\n      searchService.find(query);\n      expect(fakeRenderCell(0, 1)).toBe('currentMatch');\n      expect(fakeRenderCell(1, 1)).toBe('anotherMatch');\n      expect(fakeRenderCell(0, 0)).toBe('');\n\n      // search again, the current match \"moves\" to be (1,1)\n      searchService.find(query);\n      expect(fakeRenderCell(0, 1)).toBe('anotherMatch');\n      expect(fakeRenderCell(1, 1)).toBe('currentMatch');\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/csvviewer/test"},{"name":"should compute a valid code id when the parameters are set","suites":["DebuggerConfig","#getCodeId"],"updatePoint":{"line":19,"column":66},"line":19,"code":"    it('should compute a valid code id when the parameters are set', () => {\n      const [prefix, suffix] = ['foo', 'bar'];\n      config.setHashParams({ method: 'Murmur2', seed: 'bar', kernel });\n      config.setTmpFileParams({ prefix, suffix, kernel });\n      const codeId = config.getCodeId('i = 0', kernel);\n      expect(codeId.startsWith(prefix)).toBe(true);\n      expect(codeId.endsWith(suffix)).toBe(true);\n    });","file":"config.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should throw if the kernel does not have hash parameters","suites":["DebuggerConfig","#getCodeId"],"updatePoint":{"line":28,"column":64},"line":28,"code":"    it('should throw if the kernel does not have hash parameters', () => {\n      config.setTmpFileParams({ prefix: 'foo', suffix: 'bar', kernel });\n      expect(() => {\n        config.getCodeId('i = 0', kernel);\n      }).toThrow('has no hashing params');\n    });","file":"config.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should throw if the kernel does not have tmp file parameters","suites":["DebuggerConfig","#getCodeId"],"updatePoint":{"line":35,"column":68},"line":35,"code":"    it('should throw if the kernel does not have tmp file parameters', () => {\n      config.setHashParams({ method: 'Murmur2', seed: 'bar', kernel });\n      expect(() => {\n        config.getCodeId('i = 0', kernel);\n      }).toThrow('has no tmp file params');\n    });","file":"config.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should create a new debugger sidebar","suites":["Debugger","#constructor()"],"updatePoint":{"line":150,"column":44},"line":150,"code":"    it('should create a new debugger sidebar', () => {\n      expect(sidebar).toBeInstanceOf(Debugger.Sidebar);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have 5 child widgets","suites":["Debugger","Panel"],"updatePoint":{"line":162,"column":35},"line":162,"code":"    it('should have 5 child widgets', () => {\n      expect(sidebar.widgets.length).toBe(5);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have 5 toolbars","suites":["Debugger","Panel"],"updatePoint":{"line":166,"column":30},"line":166,"code":"    it('should have 5 toolbars', () => {\n      expect(toolbarList.length).toBe(5);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have expanding icon","suites":["Debugger","Panel","Variable toolbar"],"updatePoint":{"line":174,"column":36},"line":174,"code":"      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have title","suites":["Debugger","Panel","Variable toolbar"],"updatePoint":{"line":180,"column":27},"line":180,"code":"      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Variables');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have two buttons","suites":["Debugger","Panel","Variable toolbar"],"updatePoint":{"line":187,"column":33},"line":187,"code":"      it('should have two buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(2);\n        expect(buttons[0].title).toBe('Tree View');\n        expect(buttons[1].title).toBe('Table View');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have expanding icon","suites":["Debugger","Panel","Callstack toolbar"],"updatePoint":{"line":199,"column":36},"line":199,"code":"      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have title","suites":["Debugger","Panel","Callstack toolbar"],"updatePoint":{"line":205,"column":27},"line":205,"code":"      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Callstack');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have six buttons","suites":["Debugger","Panel","Callstack toolbar"],"updatePoint":{"line":212,"column":33},"line":212,"code":"      it('should have six buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(6);\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have expanding icon","suites":["Debugger","Panel","Breakpoints toolbar"],"updatePoint":{"line":222,"column":36},"line":222,"code":"      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have title","suites":["Debugger","Panel","Breakpoints toolbar"],"updatePoint":{"line":228,"column":27},"line":228,"code":"      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Breakpoints');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have two buttons","suites":["Debugger","Panel","Breakpoints toolbar"],"updatePoint":{"line":235,"column":33},"line":235,"code":"      it('should have two buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(2);\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have expanding icon","suites":["Debugger","Panel","Source toolbar"],"updatePoint":{"line":245,"column":36},"line":245,"code":"      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have title","suites":["Debugger","Panel","Source toolbar"],"updatePoint":{"line":251,"column":27},"line":251,"code":"      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Source');\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have one button","suites":["Debugger","Panel","Source toolbar"],"updatePoint":{"line":259,"column":32},"line":259,"code":"      it('should have one button', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(1);\n      });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have a body","suites":["Debugger","#callstack"],"updatePoint":{"line":267,"column":26},"line":267,"code":"    it('should have a body', () => {\n      expect(sidebar.callstack.widgets.length).toEqual(1);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have the jp-DebuggerCallstack class","suites":["Debugger","#callstack"],"updatePoint":{"line":271,"column":50},"line":271,"code":"    it('should have the jp-DebuggerCallstack class', () => {\n      expect(sidebar.callstack.hasClass('jp-DebuggerCallstack')).toBe(true);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should display the stack frames","suites":["Debugger","#callstack"],"updatePoint":{"line":275,"column":39},"line":275,"code":"    it('should display the stack frames', () => {\n      const node = sidebar.callstack.node;\n      const items = node.querySelectorAll('.jp-DebuggerCallstack-body li');\n\n      expect(items).toHaveLength(1);\n      expect(items[0].innerHTML).toContain('module');\n      expect(items[0].innerHTML).toContain('3'); // line for the first breakpoint\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have the jp-DebuggerBreakpoints class","suites":["Debugger","#breakpoints"],"updatePoint":{"line":286,"column":52},"line":286,"code":"    it('should have the jp-DebuggerBreakpoints class', () => {\n      expect(sidebar.breakpoints.hasClass('jp-DebuggerBreakpoints')).toBe(true);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should contain the list of breakpoints","suites":["Debugger","#breakpoints"],"updatePoint":{"line":290,"column":46},"line":290,"code":"    it('should contain the list of breakpoints', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      expect(items).toHaveLength(2);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should contain the path to the breakpoints","suites":["Debugger","#breakpoints"],"updatePoint":{"line":296,"column":50},"line":296,"code":"    it('should contain the path to the breakpoints', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-source');\n      items.forEach(item => {\n        // TODO: replace by toEqual when there is an alternative to the rtl\n        // breakpoint display\n        expect(item.innerHTML).toContain(path.slice(1));\n      });\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should contain the line number","suites":["Debugger","#breakpoints"],"updatePoint":{"line":306,"column":38},"line":306,"code":"    it('should contain the line number', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-line');\n\n      await act(() => service.updateBreakpoints(code, breakpoints));\n\n      items.forEach((item, i) => {\n        const parsed = parseInt(item.innerHTML, 10);\n        expect(parsed).toEqual(lines[i]);\n      });\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should be updated when new breakpoints are added","suites":["Debugger","#breakpoints"],"updatePoint":{"line":318,"column":56},"line":318,"code":"    it('should be updated when new breakpoints are added', async () => {\n      const node = sidebar.breakpoints.node;\n      let items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      const len1 = items.length;\n\n      const bps = breakpoints.concat([\n        {\n          id: 3,\n          line: 4,\n          verified: true,\n          source: {\n            path\n          }\n        }\n      ]);\n\n      await act(() => service.updateBreakpoints(code, bps));\n\n      items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      const len2 = items.length;\n\n      expect(len2).toEqual(len1 + 1);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should contain the path after a restore","suites":["Debugger","#breakpoints"],"updatePoint":{"line":342,"column":47},"line":342,"code":"    it('should contain the path after a restore', async () => {\n      await service.restoreState(true);\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-source');\n      items.forEach(item => {\n        // TODO: replace by toEqual when there is an alternative to the rtl\n        // breakpoint display\n        expect(item.innerHTML).toContain(path.slice(1));\n      });\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should have a body","suites":["Debugger","#sources"],"updatePoint":{"line":355,"column":26},"line":355,"code":"    it('should have a body', () => {\n      expect(sidebar.sources.widgets.length).toEqual(1);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should display the source path in the header","suites":["Debugger","#sources"],"updatePoint":{"line":359,"column":52},"line":359,"code":"    it('should display the source path in the header', () => {\n      const header = sidebar.sources.toolbar;\n      const pathWidget = header.node.innerHTML;\n      expect(pathWidget).toContain(path);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should display the source code in the body","suites":["Debugger","#sources"],"updatePoint":{"line":365,"column":50},"line":365,"code":"    it('should display the source code in the body', () => {\n      const body = sidebar.sources.widgets[0] as SourcesBody;\n      const children = toArray(body.children());\n      const editor = children[0] as CodeEditorWrapper;\n      expect(editor.model.value.text).toEqual(code);\n    });","file":"debugger.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return true for kernels that have support for debugging","suites":["Debugging support","#isAvailable"],"updatePoint":{"line":73,"column":70},"line":73,"code":"    it('should return true for kernels that have support for debugging', async () => {\n      const enabled = await service.isAvailable({\n        kernel: { name: 'xpython' }\n      } as any);\n      expect(enabled).toBe(true);\n    });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return false for kernels that do not have support for debugging","suites":["Debugging support","#isAvailable"],"line":80,"code":"    it.skip('should return false for kernels that do not have support for debugging', async () => {","file":"service.spec.ts","skipped":true,"dir":"packages/debugger/test"},{"name":"should create a new instance","suites":["DebuggerService","#constructor()"],"updatePoint":{"line":117,"column":36},"line":117,"code":"    it('should create a new instance', () => {\n      expect(service).toBeInstanceOf(Debugger.Service);\n    });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should start the service if the session is set","suites":["DebuggerService","#start()"],"updatePoint":{"line":123,"column":54},"line":123,"code":"    it('should start the service if the session is set', async () => {\n      service.session = session;\n      await service.start();\n      expect(service.isStarted).toEqual(true);\n    });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should stop the service if the session is set","suites":["DebuggerService","#stop()"],"updatePoint":{"line":131,"column":53},"line":131,"code":"    it('should stop the service if the session is set', async () => {\n      service.session = session;\n      await service.start();\n      await service.stop();\n      expect(service.isStarted).toEqual(false);\n    });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should emit the sessionChanged signal when setting the session","suites":["DebuggerService","#session"],"updatePoint":{"line":140,"column":70},"line":140,"code":"    it('should emit the sessionChanged signal when setting the session', () => {\n      const sessionChangedEvents: (IDebugger.ISession | null)[] = [];\n      service.sessionChanged.connect((_, newSession) => {\n        sessionChangedEvents.push(newSession);\n      });\n      service.session = session;\n      expect(sessionChangedEvents.length).toEqual(1);\n      expect(sessionChangedEvents[0]).toEqual(session);\n    });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should update the breakpoints","suites":["DebuggerService","protocol","#updateBreakpoints"],"updatePoint":{"line":184,"column":39},"line":184,"code":"      it('should update the breakpoints', async () => {\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        await service.updateBreakpoints(code, breakpoints);\n        const bpList = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList.length).toEqual(breakpoints.length);\n        expect(bpList[0].line).toEqual(breakpoints[0].line);\n        expect(bpList[1].line).toEqual(breakpoints[1].line);\n        expect(bpList[0].source).toEqual(breakpoints[0].source);\n        expect(bpList[1].source).toEqual(breakpoints[1].source);\n      });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should restore the breakpoints","suites":["DebuggerService","protocol","#restoreState"],"updatePoint":{"line":200,"column":40},"line":200,"code":"      it('should restore the breakpoints', async () => {\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        const bpList1 = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList1.length).toEqual(0);\n        await service.restoreState(true);\n        const bpList2 = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList2).toEqual(breakpoints);\n      });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should restart the debugger and send the breakpoints again","suites":["DebuggerService","protocol","#restart"],"updatePoint":{"line":214,"column":68},"line":214,"code":"      it('should restart the debugger and send the breakpoints again', async () => {\n        await service.restart();\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        await service.restoreState(true);\n        const bpList = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList).toEqual(breakpoints);\n      });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return false if the model is null","suites":["DebuggerService","protocol","#hasStoppedThreads"],"updatePoint":{"line":227,"column":50},"line":227,"code":"      it('should return false if the model is null', () => {\n        const hasStoppedThreads = service.hasStoppedThreads();\n        expect(hasStoppedThreads).toBe(false);\n      });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return true when the execution has stopped","suites":["DebuggerService","protocol","#hasStoppedThreads"],"updatePoint":{"line":232,"column":59},"line":232,"code":"      it('should return true when the execution has stopped', async () => {\n        const { model } = service;\n        const variablesChanged = signalToPromise(model.variables.changed);\n\n        // trigger a manual execute request\n        connection!.kernel!.requestExecute({ code });\n\n        // wait for the first stopped event and variables changed\n        await variablesChanged;\n\n        const hasStoppedThreads = service.hasStoppedThreads();\n        expect(hasStoppedThreads).toBe(true);\n        await service.restart();\n      });","file":"service.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return whether the object is disposed","suites":["Debugger.Session","#isDisposed"],"updatePoint":{"line":55,"column":52},"line":55,"code":"    it('should return whether the object is disposed', () => {\n      const debugSession = new Debugger.Session({\n        connection\n      });\n      expect(debugSession.isDisposed).toEqual(false);\n      debugSession.dispose();\n      expect(debugSession.isDisposed).toEqual(true);\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should be emitted when sending debug messages","suites":["Debugger.Session","#eventMessage"],"updatePoint":{"line":66,"column":53},"line":66,"code":"    it('should be emitted when sending debug messages', async () => {\n      const debugSession = new Debugger.Session({\n        connection\n      });\n      let events: string[] = [];\n      debugSession.eventMessage.connect((sender, event) => {\n        events.push(event.event);\n      });\n      await debugSession.start();\n      await debugSession.stop();\n      expect(events).toEqual(\n        expect.arrayContaining(['output', 'initialized', 'process'])\n      );\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should send debug messages to the kernel","suites":["Debugger.Session","#sendRequest success"],"updatePoint":{"line":83,"column":48},"line":83,"code":"    it('should send debug messages to the kernel', async () => {\n      const debugSession = new Debugger.Session({\n        connection\n      });\n      await debugSession.start();\n      const code = 'i=0\\ni+=1\\ni+=1';\n      const reply = await debugSession.sendRequest('dumpCell', {\n        code\n      });\n      await debugSession.stop();\n      expect(reply.body.sourcePath).toContain('.py');\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should handle replies with success false","suites":["Debugger.Session","#sendRequest failure"],"updatePoint":{"line":98,"column":48},"line":98,"code":"    it('should handle replies with success false', async () => {\n      const debugSession = new Debugger.Session({\n        connection\n      });\n      await debugSession.start();\n      const reply = await debugSession.sendRequest('evaluate', {\n        expression: 'a'\n      });\n      await debugSession.stop();\n      const { success, message } = reply;\n      expect(success).toBe(false);\n      expect(message).toBeTruthy();\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return the state of the current debug session","suites":["protocol","#debugInfo"],"updatePoint":{"line":196,"column":60},"line":196,"code":"    it('should return the state of the current debug session', async () => {\n      const reply = await debugSession.sendRequest('debugInfo', {});\n      expect(reply.body.isStarted).toBe(true);\n\n      const breakpoints = reply.body.breakpoints;\n      // breakpoints are in the same file\n      expect(breakpoints.length).toEqual(1);\n\n      const breakpointsInfo = breakpoints[0];\n      const breakpointLines = breakpointsInfo.breakpoints.map(bp => {\n        return bp.line;\n      });\n      expect(breakpointLines).toEqual([3, 5]);\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return the correct stackframes","suites":["protocol","#stackTrace"],"updatePoint":{"line":213,"column":45},"line":213,"code":"    it('should return the correct stackframes', async () => {\n      const reply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      expect(reply.success).toBe(true);\n      const stackFrames = reply.body.stackFrames;\n      expect(stackFrames.length).toEqual(1);\n      const frame = stackFrames[0];\n      // first breakpoint\n      expect(frame.line).toEqual(3);\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return the correct scopes","suites":["protocol","#scopes"],"updatePoint":{"line":227,"column":40},"line":227,"code":"    it('should return the correct scopes', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frameId = stackFramesReply.body.stackFrames[0].id;\n      const scopesReply = await debugSession.sendRequest('scopes', {\n        frameId\n      });\n      const scopes = scopesReply.body.scopes;\n      expect(scopes.length).toBeGreaterThanOrEqual(1);\n\n      const locals = scopes.find(scope => scope.name === 'Locals');\n      expect(locals).toBeTruthy();\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return the variables and their values","suites":["protocol","#variables"],"updatePoint":{"line":265,"column":52},"line":265,"code":"    it('should return the variables and their values', async () => {\n      const variables = await getVariables();\n      expect(variables.length).toBeGreaterThan(0);\n      const i = find(variables, variable => variable.name === 'i');\n      expect(i).toBeDefined();\n      expect(i!.type).toEqual('int');\n      expect(i!.value).toEqual('1');\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should return the amount of variables requested","suites":["protocol","#variablesPagination"],"line":276,"code":"    it.skip('should return the amount of variables requested', async () => {","file":"session.spec.ts","skipped":true,"dir":"packages/debugger/test"},{"name":"should proceed to the next breakpoint","suites":["protocol","#continue"],"updatePoint":{"line":286,"column":45},"line":286,"code":"    it('should proceed to the next breakpoint', async () => {\n      const [first, second] = signalToPromises(debugSession.eventMessage, 2);\n      await debugSession.sendRequest('continue', { threadId });\n\n      // wait for debug events\n      const [, continued] = await first;\n      expect(continued.event).toEqual('continued');\n      const [, stopped] = await second;\n      expect(stopped.event).toEqual('stopped');\n\n      const variables = await getVariables();\n      const i = find(variables, variable => variable.name === 'i');\n      expect(i).toBeDefined();\n      expect(i!.type).toEqual('int');\n      expect(i!.value).toEqual('2');\n\n      const j = find(variables, variable => variable.name === 'j');\n      expect(j).toBeDefined();\n      expect(j!.type).toEqual('int');\n      expect(j!.value).toEqual('4');\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should retrieve the source of the dumped code cell","suites":["protocol","#source"],"updatePoint":{"line":310,"column":58},"line":310,"code":"    it('should retrieve the source of the dumped code cell', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frame = stackFramesReply.body.stackFrames[0];\n      const source = frame.source;\n      const reply = await debugSession.sendRequest('source', {\n        source: { path: source!.path! },\n        sourceReference: source!.sourceReference!\n      });\n      const sourceCode = reply.body.content;\n      expect(sourceCode).toEqual(code);\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should evaluate the code sent to the kernel","suites":["protocol","#evaluate"],"updatePoint":{"line":326,"column":51},"line":326,"code":"    it('should evaluate the code sent to the kernel', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frameId = stackFramesReply.body.stackFrames[0].id;\n      const reply = await debugSession.sendRequest('evaluate', {\n        frameId,\n        context: 'repl',\n        expression: 'k = 123',\n        format: {}\n      });\n      expect(reply.success).toBe(true);\n\n      const variables = await getVariables();\n      const k = find(variables, variable => variable.name === 'k');\n      expect(k).toBeDefined();\n      expect(k!.type).toEqual('int');\n      expect(k!.value).toEqual('123');\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should be hit when the condition is true","suites":["protocol","#setBreakpoints with condition"],"updatePoint":{"line":348,"column":48},"line":348,"code":"    it('should be hit when the condition is true', async () => {\n      const reply = await debugSession.sendRequest('dumpCell', {\n        code\n      });\n      await debugSession.sendRequest('setBreakpoints', {\n        breakpoints: [{ line: 9, condition: 'i == 5' }],\n        source: { path: reply.body.sourcePath },\n        sourceModified: false\n      });\n      await debugSession.sendRequest('configurationDone', {});\n\n      // advance to the conditional breakpoint\n      await debugSession.sendRequest('continue', { threadId });\n\n      const variables = await getVariables();\n      const j = find(variables, variable => variable.name === 'j');\n      expect(j).toBeDefined();\n      expect(j!.value).toEqual('25');\n    });","file":"session.spec.ts","skipped":false,"dir":"packages/debugger/test"},{"name":"should create a new document manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#constructor()"],"updatePoint":{"line":101,"column":46},"line":101,"code":"      it('should create a new document manager', () => {\n        expect(manager).toBeInstanceOf(DocumentManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should test whether the manager is disposed","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#isDisposed"],"updatePoint":{"line":107,"column":53},"line":107,"code":"      it('should test whether the manager is disposed', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should dispose of the resources used by the manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#dispose()"],"updatePoint":{"line":115,"column":61},"line":115,"code":"      it('should dispose of the resources used by the manager', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should get the service manager for the manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#services"],"updatePoint":{"line":125,"column":56},"line":125,"code":"      it('should get the service manager for the manager', async () => {\n        await expect(manager.services.ready).resolves.not.toThrow();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should get the registry used by the manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#registry"],"updatePoint":{"line":131,"column":53},"line":131,"code":"      it('should get the registry used by the manager', () => {\n        expect(manager.registry).toBeInstanceOf(DocumentRegistry);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should open a file and return the widget used to view it","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#open()"],"updatePoint":{"line":137,"column":66},"line":137,"code":"      it('should open a file and return the widget used to view it', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path)!;\n        expect(widget.hasClass('WidgetFactory')).toBe(true);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should start a kernel if one is given","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#open()"],"updatePoint":{"line":147,"column":47},"line":147,"code":"      it('should start a kernel if one is given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        const session = await services.sessions.startNew({\n          name: '',\n          path: model.path,\n          type: 'test'\n        });\n        const id = session.kernel!.id;\n        widget = manager.open(session.path, 'default', { id })!;\n        context = manager.contextForWidget(widget)!;\n        await context.ready;\n        await context.sessionContext.ready;\n        expect(context.sessionContext.session?.kernel).toBeTruthy();\n        await context.sessionContext.shutdown();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should not auto-start a kernel if there is none given","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#open()"],"updatePoint":{"line":166,"column":63},"line":166,"code":"      it('should not auto-start a kernel if there is none given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'default')!;\n        context = manager.contextForWidget(widget)!;\n        await dismissDialog();\n        expect(context.sessionContext.session?.kernel).toBeFalsy();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the factory is not found","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#open()"],"updatePoint":{"line":177,"column":61},"line":177,"code":"      it('should return undefined if the factory is not found', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the factory has no model factory","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#open()"],"updatePoint":{"line":186,"column":69},"line":186,"code":"      it('should return undefined if the factory has no model factory', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test',\n          modelName: 'foo',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should open a file and return the widget used to view it","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createNew()"],"updatePoint":{"line":203,"column":66},"line":203,"code":"      it('should open a file and return the widget used to view it', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        expect(widget.hasClass('WidgetFactory')).toBe(true);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should start a kernel if one is given","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createNew()"],"updatePoint":{"line":213,"column":47},"line":213,"code":"      it('should start a kernel if one is given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        const session = await services.sessions.startNew({\n          name: '',\n          path: model.path,\n          type: 'test'\n        });\n        const id = session.kernel!.id;\n        widget = manager.createNew(session.path, 'default', { id })!;\n        context = manager.contextForWidget(widget)!;\n        await context.ready;\n        await context.sessionContext.ready;\n        expect(context.sessionContext.session!.kernel!.id).toBe(id);\n        await context.sessionContext.shutdown();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should not start a kernel if not given","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createNew()"],"updatePoint":{"line":232,"column":48},"line":232,"code":"      it('should not start a kernel if not given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'default')!;\n        context = manager.contextForWidget(widget)!;\n        await dismissDialog();\n        expect(context.sessionContext.session?.kernel).toBeFalsy();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the factory is not found","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createNew()"],"updatePoint":{"line":243,"column":61},"line":243,"code":"      it('should return undefined if the factory is not found', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the factory has no model factory","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createNew()"],"updatePoint":{"line":252,"column":69},"line":252,"code":"      it('should return undefined if the factory has no model factory', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test',\n          modelName: 'foo',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should find a widget given a file and a widget name","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":269,"column":61},"line":269,"code":"      it('should find a widget given a file and a widget name', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path);\n        expect(manager.findWidget(model.path, 'test')).toBe(widget);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should find a widget given a file","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":279,"column":43},"line":279,"code":"      it('should find a widget given a file', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path);\n        expect(manager.findWidget(model.path)).toBe(widget);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should fail to find a widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":289,"column":38},"line":289,"code":"      it('should fail to find a widget', () => {\n        expect(manager.findWidget('foo')).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should fail to find a widget with non default factory and the default widget name","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":293,"column":91},"line":293,"code":"      it('should fail to find a widget with non default factory and the default widget name', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test2',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'test2');\n        expect(manager.findWidget(model.path)).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should find a widget with non default factory given a file and a null widget name","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":307,"column":91},"line":307,"code":"      it('should find a widget with non default factory given a file and a null widget name', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test2',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'test2');\n        expect(manager.findWidget(model.path, null)).toBe(widget);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should find the context for a widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#contextForWidget()"],"updatePoint":{"line":324,"column":46},"line":324,"code":"      it('should find the context for a widget', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        context = manager.contextForWidget(widget)!;\n        expect(context.path).toBe(model.path);\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should fail to find the context for the widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#contextForWidget()"],"updatePoint":{"line":335,"column":56},"line":335,"code":"      it('should fail to find the context for the widget', () => {\n        widget = new Widget();\n        expect(manager.contextForWidget(widget)).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should clone the given widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#cloneWidget()"],"updatePoint":{"line":342,"column":39},"line":342,"code":"      it('should clone the given widget', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        const clone = manager.cloneWidget(widget)!;\n        expect(manager.contextForWidget(widget)).toBe(\n          manager.contextForWidget(clone)\n        );\n        await dismissDialog();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the source widget is not managed","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#cloneWidget()"],"updatePoint":{"line":355,"column":69},"line":355,"code":"      it('should return undefined if the source widget is not managed', () => {\n        widget = new Widget();\n        expect(manager.cloneWidget(widget)).toBeUndefined();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should allow widget factories to have custom clone behavior","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#cloneWidget()"],"updatePoint":{"line":360,"column":69},"line":360,"code":"      it('should allow widget factories to have custom clone behavior', () => {\n        widget = manager.createNew('foo', 'CloneTestWidget')!;\n        const clonedWidget: CloneTestWidget = manager.cloneWidget(\n          widget\n        ) as CloneTestWidget;\n        expect(clonedWidget.counter).toBe(1);\n        const newWidget: CloneTestWidget = manager.createNew(\n          'bar',\n          'CloneTestWidget'\n        ) as CloneTestWidget;\n        expect(newWidget.counter).toBe(0);\n        expect(\n          (manager.cloneWidget(clonedWidget) as CloneTestWidget).counter\n        ).toBe(2);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should close the widgets associated with a given path","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#closeFile()"],"updatePoint":{"line":378,"column":63},"line":378,"code":"      it('should close the widgets associated with a given path', async () => {\n        let called = 0;\n        let path = '';\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        path = model.path;\n        widget = manager.createNew(path)!;\n        const clone = manager.cloneWidget(widget)!;\n\n        widget.disposed.connect(() => {\n          called++;\n        });\n        clone.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        await manager.closeFile(path);\n        expect(called).toBe(2);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be a no-op if there are no open files on that path","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#closeFile()"],"updatePoint":{"line":400,"column":67},"line":400,"code":"      it('should be a no-op if there are no open files on that path', async () => {\n        await expect(manager.closeFile('foo')).resolves.not.toThrow();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should close all of the open documents","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#closeAll()"],"updatePoint":{"line":406,"column":48},"line":406,"code":"      it('should close all of the open documents', async () => {\n        let called = 0;\n        let path = '';\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        path = model.path;\n        const widget0 = manager.createNew(path)!;\n        widget0.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        const widget1 = manager.createNew(path)!;\n        widget1.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        await manager.closeAll();\n        expect(called).toBe(2);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be a no-op if there are no open documents","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#closeAll()"],"updatePoint":{"line":428,"column":58},"line":428,"code":"      it('should be a no-op if there are no open documents', async () => {\n        await expect(manager.closeAll()).resolves.not.toThrow();\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should create a new save handler","suites":["docregistry/savehandler","SaveHandler","#constructor()"],"updatePoint":{"line":47,"column":42},"line":47,"code":"      it('should create a new save handler', () => {\n        expect(handler).toBeInstanceOf(SaveHandler);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be the save interval of the handler","suites":["docregistry/savehandler","SaveHandler","#saveInterval()"],"updatePoint":{"line":53,"column":52},"line":53,"code":"      it('should be the save interval of the handler', () => {\n        expect(handler.saveInterval).toBe(120);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be set-able","suites":["docregistry/savehandler","SaveHandler","#saveInterval()"],"updatePoint":{"line":57,"column":28},"line":57,"code":"      it('should be set-able', () => {\n        handler.saveInterval = 200;\n        expect(handler.saveInterval).toBe(200);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should test whether the handler is active","suites":["docregistry/savehandler","SaveHandler","#isActive"],"updatePoint":{"line":64,"column":51},"line":64,"code":"      it('should test whether the handler is active', () => {\n        expect(handler.isActive).toBe(false);\n        handler.start();\n        expect(handler.isActive).toBe(true);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should test whether the handler is disposed","suites":["docregistry/savehandler","SaveHandler","#isDisposed"],"updatePoint":{"line":72,"column":53},"line":72,"code":"      it('should test whether the handler is disposed', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be true after the context is disposed","suites":["docregistry/savehandler","SaveHandler","#isDisposed"],"updatePoint":{"line":78,"column":54},"line":78,"code":"      it('should be true after the context is disposed', () => {\n        context.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should dispose of the resources used by the handler","suites":["docregistry/savehandler","SaveHandler","#dispose()"],"updatePoint":{"line":85,"column":61},"line":85,"code":"      it('should dispose of the resources used by the handler', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should start the save handler","suites":["docregistry/savehandler","SaveHandler","#start()"],"updatePoint":{"line":95,"column":39},"line":95,"code":"      it('should start the save handler', () => {\n        handler.start();\n        expect(handler.isActive).toBe(true);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should trigger a save","suites":["docregistry/savehandler","SaveHandler","#start()"],"updatePoint":{"line":100,"column":31},"line":100,"code":"      it('should trigger a save', () => {\n        const promise = signalToPromise(context.fileChanged);\n        context.model.fromString('bar');\n        expect(handler.isActive).toBe(false);\n        handler.saveInterval = 0.1;\n        handler.start();\n        return promise;\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should continue to save","suites":["docregistry/savehandler","SaveHandler","#start()"],"updatePoint":{"line":109,"column":33},"line":109,"code":"      it('should continue to save', async () => {\n        let called = 0;\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n        const promise = testEmission(context.fileChanged, {\n          test: () => {\n            if (called === 0) {\n              context.model.fromString('bar');\n              called++;\n            }\n            return called === 1;\n          }\n        });\n        context.model.fromString('foo');\n        expect(handler.isActive).toBe(false);\n        handler.saveInterval = 0.1;\n        handler.start();\n        return promise;\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should overwrite the file on disk","suites":["docregistry/savehandler","SaveHandler","#start()"],"updatePoint":{"line":129,"column":43},"line":129,"code":"      it('should overwrite the file on disk', async () => {\n        const delegate = new PromiseDelegate();\n\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n        context.model.fromString('foo');\n        await context.initialize(true);\n\n        // The context allows up to 0.5 difference in timestamps before complaining.\n        setTimeout(async () => {\n          await manager.contents.save(context.path, {\n            type: factory.contentType,\n            format: factory.fileFormat,\n            content: 'bar'\n          });\n          handler.saveInterval = 1;\n          handler.start();\n          context.model.fromString('baz');\n          context.fileChanged.connect(() => {\n            expect(context.model.toString()).toBe('baz');\n            delegate.resolve(undefined);\n          });\n        }, 1500);\n\n        // Extend the timeout to wait for the dialog because of the setTimeout.\n        await acceptDialog(document.body, 3000);\n        await delegate.promise;\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should revert to the file on disk","suites":["docregistry/savehandler","SaveHandler","#start()"],"updatePoint":{"line":158,"column":43},"line":158,"code":"      it('should revert to the file on disk', async () => {\n        const delegate = new PromiseDelegate();\n        const revert = () => {\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const buttons = dialog.getElementsByTagName('button');\n\n          for (let i = 0; i < buttons.length; i++) {\n            if (buttons[i].textContent === 'Revert') {\n              buttons[i].click();\n              return;\n            }\n          }\n        };\n\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n\n        await context.initialize(true);\n        context.model.fromString('foo');\n        context.fileChanged.connect(() => {\n          expect(context.model.toString()).toBe('bar');\n          delegate.resolve(undefined);\n        });\n\n        // The context allows up to 0.5 difference in timestamps before complaining.\n        setTimeout(async () => {\n          await manager.contents.save(context.path, {\n            type: factory.contentType,\n            format: factory.fileFormat,\n            content: 'bar'\n          });\n          handler.saveInterval = 1;\n          handler.start();\n          context.model.fromString('baz');\n        }, 1500);\n\n        // Extend the timeout to wait for the dialog because of the setTimeout.\n        await waitForDialog(document.body, 3000);\n        revert();\n        await delegate.promise;\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should stop the save timer","suites":["docregistry/savehandler","SaveHandler","#stop()"],"updatePoint":{"line":202,"column":36},"line":202,"code":"      it('should stop the save timer', () => {\n        handler.start();\n        expect(handler.isActive).toBe(true);\n        handler.stop();\n        expect(handler.isActive).toBe(false);\n      });","file":"savehandler.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should create a new document widget manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#constructor()"],"updatePoint":{"line":87,"column":53},"line":87,"code":"      it('should create a new document widget manager', () => {\n        expect(manager).toBeInstanceOf(DocumentWidgetManager);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should test whether the manager is disposed","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#isDisposed"],"updatePoint":{"line":93,"column":53},"line":93,"code":"      it('should test whether the manager is disposed', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should dispose of the resources used by the manager","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#dispose()"],"updatePoint":{"line":101,"column":61},"line":101,"code":"      it('should dispose of the resources used by the manager', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should create a widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createWidget()"],"updatePoint":{"line":111,"column":32},"line":111,"code":"      it('should create a widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(widget).toBeInstanceOf(Widget);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should emit the widgetCreated signal","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#createWidget()"],"updatePoint":{"line":117,"column":46},"line":117,"code":"      it('should emit the widgetCreated signal', () => {\n        let called = false;\n\n        widgetFactory.widgetCreated.connect(() => {\n          called = true;\n        });\n        manager.createWidget(widgetFactory, context);\n        expect(called).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should install a message hook","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#adoptWidget()"],"updatePoint":{"line":129,"column":39},"line":129,"code":"      it('should install a message hook', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        MessageLoop.sendMessage(widget, new Message('foo'));\n        expect(manager.methods).toEqual(\n          expect.arrayContaining(['messageHook'])\n        );\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should add the document class","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#adoptWidget()"],"updatePoint":{"line":140,"column":39},"line":140,"code":"      it('should add the document class', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        expect(widget.hasClass('jp-Document')).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be retrievable","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#adoptWidget()"],"updatePoint":{"line":148,"column":31},"line":148,"code":"      it('should be retrievable', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        expect(manager.contextForWidget(widget)).toBe(context);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should find a registered widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":158,"column":41},"line":158,"code":"      it('should find a registered widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(manager.findWidget(context, 'test')).toBe(widget);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if not found","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#findWidget()"],"updatePoint":{"line":164,"column":46},"line":164,"code":"      it('should return undefined if not found', () => {\n        expect(manager.findWidget(context, 'test')).toBeUndefined();\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return the context for a widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#contextForWidget()"],"updatePoint":{"line":170,"column":48},"line":170,"code":"      it('should return the context for a widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(manager.contextForWidget(widget)).toBe(context);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if not tracked","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#contextForWidget()"],"updatePoint":{"line":176,"column":48},"line":176,"code":"      it('should return undefined if not tracked', () => {\n        expect(manager.contextForWidget(new Widget())).toBeUndefined();\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should create a new widget with the same context using the same factory","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#cloneWidget()"],"updatePoint":{"line":182,"column":81},"line":182,"code":"      it('should create a new widget with the same context using the same factory', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const clone = manager.cloneWidget(widget)!;\n\n        expect(clone.hasClass('WidgetFactory')).toBe(true);\n        expect(clone.hasClass('jp-Document')).toBe(true);\n        expect(manager.contextForWidget(clone)).toBe(context);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return undefined if the source widget is not managed","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#cloneWidget()"],"updatePoint":{"line":191,"column":69},"line":191,"code":"      it('should return undefined if the source widget is not managed', () => {\n        expect(manager.cloneWidget(new Widget())).toBeUndefined();\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should close all of the widgets associated with a context","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#closeWidgets()"],"updatePoint":{"line":197,"column":67},"line":197,"code":"      it('should close all of the widgets associated with a context', async () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const clone = manager.cloneWidget(widget)!;\n\n        await manager.closeWidgets(context);\n        expect(widget.isDisposed).toBe(true);\n        expect(clone.isDisposed).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be called for a message to a tracked widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#messageHook()"],"updatePoint":{"line":208,"column":60},"line":208,"code":"      it('should be called for a message to a tracked widget', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        MessageLoop.sendMessage(widget, new Message('foo'));\n        expect(manager.methods).toEqual(\n          expect.arrayContaining(['messageHook'])\n        );\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return false for close-request messages","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#messageHook()"],"updatePoint":{"line":219,"column":56},"line":219,"code":"      it('should return false for close-request messages', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const msg = new Message('close-request');\n\n        expect(manager.messageHook(widget, msg)).toBe(false);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should return true for other messages","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#messageHook()"],"updatePoint":{"line":226,"column":47},"line":226,"code":"      it('should return true for other messages', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const msg = new Message('foo');\n\n        expect(manager.messageHook(widget, msg)).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should set the title of the widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#setCaption()"],"updatePoint":{"line":235,"column":44},"line":235,"code":"      it('should set the title of the widget', async () => {\n        await context.initialize(true);\n\n        const widget = manager.createWidget(widgetFactory, context);\n        const delegate = new PromiseDelegate();\n\n        widget.title.changed.connect(async () => {\n          expect(manager.methods).toEqual(\n            expect.arrayContaining(['setCaption'])\n          );\n          expect(widget.title.caption).toContain('Last Checkpoint');\n          await dismissDialog();\n          delegate.resolve(undefined);\n        });\n        await delegate.promise;\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should be called when a widget is closed","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":254,"column":50},"line":254,"code":"      it('should be called when a widget is closed', async () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const delegate = new PromiseDelegate();\n\n        widget.disposed.connect(async () => {\n          expect(manager.methods).toEqual(expect.arrayContaining(['onClose']));\n          await dismissDialog();\n          delegate.resolve(undefined);\n        });\n        widget.close();\n        await delegate.promise;\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should prompt the user before closing","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":267,"column":47},"line":267,"code":"      it('should prompt the user before closing', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const widget = manager.createWidget(widgetFactory, context);\n        const closed = manager.onClose(widget);\n\n        await Promise.all([dangerDialog(), closed]);\n\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should not prompt if the factory is readonly","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":279,"column":54},"line":279,"code":"      it('should not prompt if the factory is readonly', async () => {\n        const readonly = manager.createWidget(readOnlyFactory, context);\n\n        await manager.onClose(readonly);\n\n        expect(readonly.isDisposed).toBe(true);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should not prompt if the other widget is writable","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":287,"column":59},"line":287,"code":"      it('should not prompt if the other widget is writable', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const one = manager.createWidget(widgetFactory, context);\n        const two = manager.createWidget(widgetFactory, context);\n\n        await manager.onClose(one);\n\n        expect(one.isDisposed).toBe(true);\n        expect(two.isDisposed).toBe(false);\n        two.dispose();\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should prompt if the only other widget has a readonly factory","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":301,"column":71},"line":301,"code":"      it('should prompt if the only other widget has a readonly factory', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const writable = manager.createWidget(widgetFactory, context);\n        const readonly = manager.createWidget(readOnlyFactory, context);\n        const closed = manager.onClose(writable);\n\n        await dangerDialog();\n        await closed;\n\n        expect(writable.isDisposed).toBe(true);\n        expect(readonly.isDisposed).toBe(false);\n        readonly.dispose();\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should close the widget","suites":["@jupyterlab/docmanager","DocumentWidgetManager","#onClose()"],"updatePoint":{"line":317,"column":33},"line":317,"code":"      it('should close the widget', async () => {\n        context.model.fromString('foo');\n        const widget = manager.createWidget(widgetFactory, context);\n        const promise = manager.onClose(widget);\n        await dismissDialog();\n        await promise;\n        expect(widget.isDisposed).toBe(false);\n      });","file":"widgetmanager.spec.ts","skipped":false,"dir":"packages/docmanager/test"},{"name":"should have a type","suites":["@jupyterlab/docprovider","docprovider"],"updatePoint":{"line":8,"column":26},"line":8,"code":"    it('should have a type', () => {\n      expect(WebSocketProviderWithLocks).not.toBeUndefined();\n    });","file":"yprovider.spec.ts","skipped":false,"dir":"packages/docprovider/test"},{"name":"should create a new context","suites":["docregistry/context","Context","#constructor()"],"updatePoint":{"line":49,"column":37},"line":49,"code":"      it('should create a new context', () => {\n        context = new Context({\n          manager,\n          factory,\n          path: UUID.uuid4() + '.txt'\n        });\n        expect(context).toBeInstanceOf(Context);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be emitted when the path changes","suites":["docregistry/context","Context","#pathChanged"],"updatePoint":{"line":60,"column":49},"line":60,"code":"      it('should be emitted when the path changes', async () => {\n        const newPath = UUID.uuid4() + '.txt';\n        let called = false;\n        context.pathChanged.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args).toBe(newPath);\n          called = true;\n        });\n        await context.initialize(true);\n        await manager.contents.rename(context.path, newPath);\n        expect(called).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be emitted when the file is saved","suites":["docregistry/context","Context","#fileChanged"],"updatePoint":{"line":75,"column":50},"line":75,"code":"      it('should be emitted when the file is saved', async () => {\n        const path = context.path;\n        let called = false;\n        context.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args.path).toBe(path);\n          called = true;\n        });\n        await context.initialize(true);\n        expect(called).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should emit 'starting' when the file starts saving","suites":["docregistry/context","Context","#saving"],"updatePoint":{"line":89,"column":60},"line":89,"code":"      it(\"should emit 'starting' when the file starts saving\", async () => {\n        let called = false;\n        let checked = false;\n        context.saveState.connect((sender, args) => {\n          if (!called) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args).toBe('started');\n\n            checked = true;\n          }\n\n          called = true;\n        });\n\n        await context.initialize(true);\n        expect(called).toBe(true);\n        expect(checked).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should emit 'completed' when the file ends saving","suites":["docregistry/context","Context","#saving"],"updatePoint":{"line":110,"column":59},"line":110,"code":"      it(\"should emit 'completed' when the file ends saving\", async () => {\n        let called = 0;\n        let checked = false;\n        context.saveState.connect((sender, args) => {\n          if (called > 0) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args).toBe('completed');\n            checked = true;\n          }\n\n          called += 1;\n        });\n\n        await context.initialize(true);\n        expect(called).toBe(2);\n        expect(checked).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should emit 'failed' when the save operation fails out","suites":["docregistry/context","Context","#saving"],"updatePoint":{"line":130,"column":64},"line":130,"code":"      it(\"should emit 'failed' when the save operation fails out\", async () => {\n        context = new Context({\n          manager,\n          factory,\n          path: 'readonly.txt'\n        });\n\n        let called = 0;\n        let checked;\n        context.saveState.connect((sender, args) => {\n          if (called > 0) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            checked = args;\n          }\n\n          called += 1;\n        });\n\n        await expect(context.initialize(true)).rejects.toThrowError(\n          'Invalid response: 403 Forbidden'\n        );\n        expect(called).toBe(2);\n        expect(checked).toBe('failed');\n\n        await acceptDialog();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should indicate whether the context is ready","suites":["docregistry/context","Context","#isReady"],"updatePoint":{"line":160,"column":54},"line":160,"code":"      it('should indicate whether the context is ready', async () => {\n        expect(context.isReady).toBe(false);\n        const func = async () => {\n          await context.ready;\n          expect(context.isReady).toBe(true);\n        };\n        const promise = func();\n        await context.initialize(true);\n        await promise;\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should resolve when the file is saved for the first time","suites":["docregistry/context","Context","#ready()"],"updatePoint":{"line":173,"column":66},"line":173,"code":"      it('should resolve when the file is saved for the first time', async () => {\n        await context.initialize(true);\n        await expect(context.ready).resolves.not.toThrow();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should resolve when the file is reverted for the first time","suites":["docregistry/context","Context","#ready()"],"updatePoint":{"line":178,"column":69},"line":178,"code":"      it('should resolve when the file is reverted for the first time', async () => {\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(false);\n        await expect(context.ready).resolves.not.toThrow();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should initialize the model when the file is saved for the first time","suites":["docregistry/context","Context","#ready()"],"updatePoint":{"line":188,"column":79},"line":188,"code":"      it('should initialize the model when the file is saved for the first time', async () => {\n        const context = await initNotebookContext({ manager });\n        context.model.fromJSON(NBTestUtils.DEFAULT_CONTENT);\n        expect(context.model.cells.canUndo).toBe(true);\n        await context.initialize(true);\n        await context.ready;\n        expect(context.model.cells.canUndo).toBe(false);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should initialize the model when the file is reverted for the first time","suites":["docregistry/context","Context","#ready()"],"updatePoint":{"line":197,"column":82},"line":197,"code":"      it('should initialize the model when the file is reverted for the first time', async () => {\n        const context = await initNotebookContext({ manager });\n        await manager.contents.save(context.path, {\n          type: 'notebook',\n          format: 'json',\n          content: NBTestUtils.DEFAULT_CONTENT\n        });\n        context.model.fromJSON(NBTestUtils.DEFAULT_CONTENT);\n        expect(context.model.cells.canUndo).toBe(true);\n        await context.initialize(false);\n        await context.ready;\n        expect(context.model.cells.canUndo).toBe(false);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be emitted when the context is disposed","suites":["docregistry/context","Context","#disposed"],"updatePoint":{"line":213,"column":56},"line":213,"code":"      it('should be emitted when the context is disposed', () => {\n        let called = false;\n        context.disposed.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        context.dispose();\n        expect(called).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the model associated with the document","suites":["docregistry/context","Context","#model"],"updatePoint":{"line":226,"column":58},"line":226,"code":"      it('should be the model associated with the document', () => {\n        expect(context.model.toString()).toBe('');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a ISessionContext object","suites":["docregistry/context","Context","#sessionContext"],"updatePoint":{"line":232,"column":44},"line":232,"code":"      it('should be a ISessionContext object', () => {\n        expect(context.sessionContext).toBeInstanceOf(SessionContext);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the current path for the context","suites":["docregistry/context","Context","#path"],"updatePoint":{"line":238,"column":52},"line":238,"code":"      it('should be the current path for the context', () => {\n        expect(typeof context.path).toBe('string');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be 500ms by default","suites":["docregistry/context","Context","#lastModifiedCheckMargin"],"updatePoint":{"line":244,"column":36},"line":244,"code":"      it('should be 500ms by default', () => {\n        expect(context.lastModifiedCheckMargin).toBe(500);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be set-able","suites":["docregistry/context","Context","#lastModifiedCheckMargin"],"updatePoint":{"line":248,"column":28},"line":248,"code":"      it('should be set-able', () => {\n        context.lastModifiedCheckMargin = 600;\n        expect(context.lastModifiedCheckMargin).toBe(600);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be `null` before population","suites":["docregistry/context","Context","#contentsModel"],"updatePoint":{"line":255,"column":44},"line":255,"code":"      it('should be `null` before population', () => {\n        expect(context.contentsModel).toBeNull();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be set after population","suites":["docregistry/context","Context","#contentsModel"],"updatePoint":{"line":259,"column":40},"line":259,"code":"      it('should be set after population', async () => {\n        const { path } = context;\n\n        void context.initialize(true);\n        await context.ready;\n        expect(context.contentsModel!.path).toBe(path);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the name of the factory used by the context","suites":["docregistry/context","Context","#factoryName"],"updatePoint":{"line":269,"column":63},"line":269,"code":"      it('should be the name of the factory used by the context', () => {\n        expect(context.factoryName).toBe(factory.name);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should test whether the context is disposed","suites":["docregistry/context","Context","#isDisposed"],"updatePoint":{"line":275,"column":53},"line":275,"code":"      it('should test whether the context is disposed', () => {\n        expect(context.isDisposed).toBe(false);\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should dispose of the resources used by the context","suites":["docregistry/context","Context","#dispose()"],"updatePoint":{"line":283,"column":61},"line":283,"code":"      it('should dispose of the resources used by the context', () => {\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should change the name of the file to the new name","suites":["docregistry/context","Context","#rename()"],"updatePoint":{"line":292,"column":60},"line":292,"code":"      it('should change the name of the file to the new name', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n\n        const newName = UUID.uuid4() + '.txt';\n\n        await context.rename(newName);\n        await context.save();\n\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n\n        const model = await manager.contents.get(newName, opts);\n\n        expect(model.content).toBe('foo');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should save the contents of the file to disk","suites":["docregistry/context","Context","#save()"],"updatePoint":{"line":314,"column":54},"line":314,"code":"      it('should save the contents of the file to disk', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n        await context.save();\n\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n\n        expect(model.content).toBe('foo');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should should preserve LF line endings upon save","suites":["docregistry/context","Context","#save()"],"updatePoint":{"line":329,"column":58},"line":329,"code":"      it('should should preserve LF line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\nbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\nbar');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should should preserve CR line endings upon save","suites":["docregistry/context","Context","#save()"],"updatePoint":{"line":347,"column":58},"line":347,"code":"      it('should should preserve CR line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\rbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\rbar');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should should preserve CRLF line endings upon save","suites":["docregistry/context","Context","#save()"],"updatePoint":{"line":365,"column":60},"line":365,"code":"      it('should should preserve CRLF line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\r\\nbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\r\\nbar');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should save the document to a different path chosen by the user","suites":["docregistry/context","Context","#saveAs()"],"updatePoint":{"line":385,"column":73},"line":385,"code":"      it('should save the document to a different path chosen by the user', async () => {\n        const initialize = context.initialize(true);\n        const newPath = UUID.uuid4() + '.txt';\n\n        const func = async () => {\n          await initialize;\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n\n          input.value = newPath;\n          await acceptDialog();\n        };\n        const promise = func();\n        await initialize;\n\n        const oldPath = context.path;\n        await context.saveAs();\n        await promise;\n        expect(context.path).toBe(newPath);\n        // Make sure the both files are there now.\n        const model = await manager.contents.get('', { content: true });\n        expect(model.content.find((x: any) => x.name === oldPath)).toBeTruthy();\n        expect(model.content.find((x: any) => x.name === newPath)).toBeTruthy();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should bring up a conflict dialog","suites":["docregistry/context","Context","#saveAs()"],"updatePoint":{"line":411,"column":43},"line":411,"code":"      it('should bring up a conflict dialog', async () => {\n        const newPath = UUID.uuid4() + '.txt';\n\n        const func = async () => {\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n          input.value = newPath;\n          await acceptDialog(); // Accept rename dialog\n          await acceptDialog(); // Accept conflict dialog\n        };\n        await manager.contents.save(newPath, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(true);\n        const promise = func();\n        await context.saveAs();\n        await promise;\n        expect(context.path).toBe(newPath);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should keep the file if overwrite is aborted","suites":["docregistry/context","Context","#saveAs()"],"updatePoint":{"line":434,"column":54},"line":434,"code":"      it('should keep the file if overwrite is aborted', async () => {\n        const oldPath = context.path;\n        const newPath = UUID.uuid4() + '.txt';\n        const func = async () => {\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n          input.value = newPath;\n          await acceptDialog(); // Accept rename dialog\n          await dismissDialog(); // Reject conflict dialog\n        };\n        await manager.contents.save(newPath, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(true);\n        const promise = func();\n        await context.saveAs();\n        await promise;\n        expect(context.path).toBe(oldPath);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should just save if the file name does not change","suites":["docregistry/context","Context","#saveAs()"],"updatePoint":{"line":457,"column":59},"line":457,"code":"      it('should just save if the file name does not change', async () => {\n        const path = context.path;\n        await context.initialize(true);\n        const promise = context.saveAs();\n        await acceptDialog();\n        await promise;\n        expect(context.path).toBe(path);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should revert the contents of the file to the disk","suites":["docregistry/context","Context","#revert()"],"updatePoint":{"line":468,"column":60},"line":468,"code":"      it('should revert the contents of the file to the disk', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n        await context.save();\n        context.model.fromString('bar');\n        await context.revert();\n        expect(context.model.toString()).toBe('foo');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should normalize CRLF line endings to LF","suites":["docregistry/context","Context","#revert()"],"updatePoint":{"line":477,"column":50},"line":477,"code":"      it('should normalize CRLF line endings to LF', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\r\\nbar'\n        });\n        await context.revert();\n        expect(context.model.toString()).toBe('foo\\nbar');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should create a checkpoint for the file","suites":["docregistry/context","Context","#createCheckpoint()"],"updatePoint":{"line":490,"column":49},"line":490,"code":"      it('should create a checkpoint for the file', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        expect(model.id).toBeTruthy();\n        expect(model.last_modified).toBeTruthy();\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should delete the given checkpoint","suites":["docregistry/context","Context","#deleteCheckpoint()"],"updatePoint":{"line":499,"column":44},"line":499,"code":"      it('should delete the given checkpoint', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        await context.deleteCheckpoint(model.id);\n        const models = await context.listCheckpoints();\n        expect(models.length).toBe(0);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should restore the value to the last checkpoint value","suites":["docregistry/context","Context","#restoreCheckpoint()"],"updatePoint":{"line":509,"column":63},"line":509,"code":"      it('should restore the value to the last checkpoint value', async () => {\n        context.model.fromString('bar');\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        context.model.fromString('foo');\n        const id = model.id;\n        await context.save();\n        await context.restoreCheckpoint(id);\n        await context.revert();\n        expect(context.model.toString()).toBe('bar');\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should list the checkpoints for the file","suites":["docregistry/context","Context","#listCheckpoints()"],"updatePoint":{"line":523,"column":50},"line":523,"code":"      it('should list the checkpoints for the file', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        const id = model.id;\n        const models = await context.listCheckpoints();\n        let found = false;\n        for (const model of models) {\n          if (model.id === id) {\n            found = true;\n          }\n        }\n        expect(found).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a url resolver","suites":["docregistry/context","Context","#urlResolver"],"updatePoint":{"line":539,"column":34},"line":539,"code":"      it('should be a url resolver', () => {\n        expect(context.urlResolver).toBeInstanceOf(\n          RenderMimeRegistry.UrlResolver\n        );\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add a sibling widget","suites":["docregistry/context","Context","#addSibling()"],"updatePoint":{"line":547,"column":37},"line":547,"code":"      it('should add a sibling widget', () => {\n        let called = false;\n        const opener = (widget: Widget) => {\n          called = true;\n        };\n        context = new Context({\n          manager,\n          factory,\n          path: UUID.uuid4() + '.txt',\n          opener\n        });\n        context.addSibling(new Widget());\n        expect(called).toBe(true);\n      });","file":"context.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#fileTypes"],"updatePoint":{"line":42,"column":39},"line":42,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.fileTypes).toEqual(['text']);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#name"],"updatePoint":{"line":52,"column":39},"line":52,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.name).toBe('test');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to an empty array","suites":["docregistry/default","ABCWidgetFactory","#defaultFor"],"updatePoint":{"line":62,"column":42},"line":62,"code":"      it('should default to an empty array', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.defaultFor).toEqual([]);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#defaultFor"],"updatePoint":{"line":70,"column":39},"line":70,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          defaultFor: ['text']\n        });\n        expect(factory.defaultFor).toEqual(['text']);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to an empty array","suites":["docregistry/default","ABCWidgetFactory","#defaultRendered"],"updatePoint":{"line":81,"column":42},"line":81,"code":"      it('should default to an empty array', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.defaultRendered).toEqual([]);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#defaultRendered"],"updatePoint":{"line":89,"column":39},"line":89,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          defaultRendered: ['text']\n        });\n        expect(factory.defaultRendered).toEqual(['text']);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to false","suites":["docregistry/default","ABCWidgetFactory","#readOnly"],"updatePoint":{"line":100,"column":33},"line":100,"code":"      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.readOnly).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#readOnly"],"updatePoint":{"line":108,"column":39},"line":108,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          readOnly: true\n        });\n        expect(factory.readOnly).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to `text`","suites":["docregistry/default","ABCWidgetFactory","#modelName"],"updatePoint":{"line":119,"column":34},"line":119,"code":"      it('should default to `text`', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.modelName).toBe('text');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#modelName"],"updatePoint":{"line":127,"column":39},"line":127,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          modelName: 'notebook'\n        });\n        expect(factory.modelName).toBe('notebook');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to false","suites":["docregistry/default","ABCWidgetFactory","#preferKernel"],"updatePoint":{"line":138,"column":33},"line":138,"code":"      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.preferKernel).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#preferKernel"],"updatePoint":{"line":146,"column":39},"line":146,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          preferKernel: true\n        });\n        expect(factory.preferKernel).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should default to false","suites":["docregistry/default","ABCWidgetFactory","#canStartKernel"],"updatePoint":{"line":157,"column":33},"line":157,"code":"      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.canStartKernel).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be the value passed in","suites":["docregistry/default","ABCWidgetFactory","#canStartKernel"],"updatePoint":{"line":165,"column":39},"line":165,"code":"      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          canStartKernel: true\n        });\n        expect(factory.canStartKernel).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should have toolbar items","suites":["docregistry/default","ABCWidgetFactory","#canStartKernel"],"updatePoint":{"line":174,"column":35},"line":174,"code":"      it('should have toolbar items', async () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          toolbarFactory: () => [\n            {\n              name: 'foo',\n              widget: new Widget()\n            },\n            {\n              name: 'bar',\n              widget: new Widget()\n            }\n          ]\n        });\n        const context = await Mock.createFileContext();\n        const widget = factory.createNew(context);\n        const widget2 = factory.createNew(context);\n        expect(toArray(widget.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(toArray(widget2.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(toArray(widget.toolbar.children()).length).toBe(3);\n        expect(toArray(widget2.toolbar.children()).length).toBe(3);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get whether the factory has been disposed","suites":["docregistry/default","ABCWidgetFactory","#isDisposed"],"updatePoint":{"line":208,"column":58},"line":208,"code":"      it('should get whether the factory has been disposed', () => {\n        const factory = createFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should dispose of the resources held by the factory","suites":["docregistry/default","ABCWidgetFactory","#dispose()"],"updatePoint":{"line":217,"column":61},"line":217,"code":"      it('should dispose of the resources held by the factory', () => {\n        const factory = createFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be safe to call multiple times","suites":["docregistry/default","ABCWidgetFactory","#dispose()"],"updatePoint":{"line":223,"column":47},"line":223,"code":"      it('should be safe to call multiple times', () => {\n        const factory = createFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should create a new widget given a document model and a context","suites":["docregistry/default","ABCWidgetFactory","#createNew()"],"updatePoint":{"line":232,"column":73},"line":232,"code":"      it('should create a new widget given a document model and a context', async () => {\n        const factory = createFactory();\n        const context = await Mock.createFileContext();\n        const widget = factory.createNew(context);\n        expect(widget).toBeInstanceOf(Widget);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should take an optional source widget for cloning","suites":["docregistry/default","ABCWidgetFactory","#createNew()"],"updatePoint":{"line":239,"column":59},"line":239,"code":"      it('should take an optional source widget for cloning', async () => {\n        const factory = createFactory();\n        const context = await Mock.createFileContext();\n        const widget = factory.createNew(context);\n        const clonedWidget: IDocumentWidget = factory.createNew(\n          context,\n          widget\n        );\n        expect(clonedWidget).not.toBe(widget);\n        expect(clonedWidget.hasClass('WidgetFactory')).toBe(true);\n        expect(clonedWidget.context).toBe(widget.context);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the name of the model type","suites":["docregistry/default","Base64ModelFactory","#name"],"updatePoint":{"line":256,"column":47},"line":256,"code":"      it('should get the name of the model type', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.name).toBe('base64');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the file type","suites":["docregistry/default","Base64ModelFactory","#contentType"],"updatePoint":{"line":263,"column":34},"line":263,"code":"      it('should get the file type', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.contentType).toBe('file');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the file format","suites":["docregistry/default","Base64ModelFactory","#fileFormat"],"updatePoint":{"line":270,"column":36},"line":270,"code":"      it('should get the file format', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.fileFormat).toBe('base64');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should create a new document model","suites":["docregistry/default","DocumentModel","#constructor()"],"updatePoint":{"line":279,"column":44},"line":279,"code":"      it('should create a new document model', () => {\n        const model = new DocumentModel();\n        expect(model).toBeInstanceOf(DocumentModel);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should accept an optional language preference","suites":["docregistry/default","DocumentModel","#constructor()"],"updatePoint":{"line":284,"column":55},"line":284,"code":"      it('should accept an optional language preference', () => {\n        const model = new DocumentModel('foo');\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get whether the model has been disposed","suites":["docregistry/default","DocumentModel","#isDisposed"],"updatePoint":{"line":291,"column":56},"line":291,"code":"      it('should get whether the model has been disposed', () => {\n        const model = new DocumentModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be emitted when the content of the model changes","suites":["docregistry/default","DocumentModel","#contentChanged"],"updatePoint":{"line":300,"column":65},"line":300,"code":"      it('should be emitted when the content of the model changes', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.contentChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        model.fromString('foo');\n        expect(called).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should not be emitted if the content does not change","suites":["docregistry/default","DocumentModel","#contentChanged"],"updatePoint":{"line":312,"column":62},"line":312,"code":"      it('should not be emitted if the content does not change', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        model.fromString('');\n        expect(called).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be emitted when the state of the model changes","suites":["docregistry/default","DocumentModel","#stateChanged"],"updatePoint":{"line":324,"column":63},"line":324,"code":"      it('should be emitted when the state of the model changes', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('readOnly');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.readOnly = true;\n        expect(called).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should not be emitted if the state does not change","suites":["docregistry/default","DocumentModel","#stateChanged"],"updatePoint":{"line":338,"column":60},"line":338,"code":"      it('should not be emitted if the state does not change', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.dirty = false;\n        expect(called).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the dirty state of the document","suites":["docregistry/default","DocumentModel","#dirty"],"updatePoint":{"line":350,"column":52},"line":350,"code":"      it('should get the dirty state of the document', () => {\n        const model = new DocumentModel();\n        expect(model.dirty).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should emit `stateChanged` when changed","suites":["docregistry/default","DocumentModel","#dirty"],"updatePoint":{"line":355,"column":49},"line":355,"code":"      it('should emit `stateChanged` when changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('dirty');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.dirty = true;\n        expect(called).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should not emit `stateChanged` when not changed","suites":["docregistry/default","DocumentModel","#dirty"],"updatePoint":{"line":369,"column":57},"line":369,"code":"      it('should not emit `stateChanged` when not changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.dirty = false;\n        expect(called).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the read only state of the document","suites":["docregistry/default","DocumentModel","#readOnly"],"updatePoint":{"line":381,"column":56},"line":381,"code":"      it('should get the read only state of the document', () => {\n        const model = new DocumentModel();\n        expect(model.readOnly).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should emit `stateChanged` when changed","suites":["docregistry/default","DocumentModel","#readOnly"],"updatePoint":{"line":386,"column":49},"line":386,"code":"      it('should emit `stateChanged` when changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('readOnly');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.readOnly = true;\n        expect(called).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should not emit `stateChanged` when not changed","suites":["docregistry/default","DocumentModel","#readOnly"],"updatePoint":{"line":400,"column":57},"line":400,"code":"      it('should not emit `stateChanged` when not changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.readOnly = false;\n        expect(called).toBe(false);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the default kernel name of the document","suites":["docregistry/default","DocumentModel","#defaultKernelName"],"updatePoint":{"line":412,"column":60},"line":412,"code":"      it('should get the default kernel name of the document', () => {\n        const model = new DocumentModel();\n        expect(model.defaultKernelName).toBe('');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the default kernel language of the document","suites":["docregistry/default","DocumentModel","defaultKernelLanguage"],"updatePoint":{"line":419,"column":64},"line":419,"code":"      it('should get the default kernel language of the document', () => {\n        const model = new DocumentModel();\n        expect(model.defaultKernelLanguage).toBe('');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be set by the constructor arg","suites":["docregistry/default","DocumentModel","defaultKernelLanguage"],"updatePoint":{"line":424,"column":46},"line":424,"code":"      it('should be set by the constructor arg', () => {\n        const model = new DocumentModel('foo');\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should dispose of the resources held by the document manager","suites":["docregistry/default","DocumentModel","#dispose()"],"updatePoint":{"line":431,"column":70},"line":431,"code":"      it('should dispose of the resources held by the document manager', () => {\n        const model = new DocumentModel();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be safe to call more than once","suites":["docregistry/default","DocumentModel","#dispose()"],"updatePoint":{"line":437,"column":47},"line":437,"code":"      it('should be safe to call more than once', () => {\n        const model = new DocumentModel();\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should serialize the model to a string","suites":["docregistry/default","DocumentModel","#toString()"],"updatePoint":{"line":446,"column":48},"line":446,"code":"      it('should serialize the model to a string', () => {\n        const model = new DocumentModel();\n        expect(model.toString()).toBe('');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should deserialize the model from a string","suites":["docregistry/default","DocumentModel","#fromString()"],"updatePoint":{"line":453,"column":52},"line":453,"code":"      it('should deserialize the model from a string', () => {\n        const model = new DocumentModel();\n        model.fromString('foo');\n        expect(model.toString()).toBe('foo');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should serialize the model to JSON","suites":["docregistry/default","DocumentModel","#toJSON()"],"updatePoint":{"line":461,"column":44},"line":461,"code":"      it('should serialize the model to JSON', () => {\n        const model = new DocumentModel();\n        const data = { foo: 1 };\n        model.fromJSON(data);\n        expect(model.toJSON()).toEqual(data);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should deserialize the model from JSON","suites":["docregistry/default","DocumentModel","#fromJSON()"],"updatePoint":{"line":470,"column":48},"line":470,"code":"      it('should deserialize the model from JSON', () => {\n        const model = new DocumentModel();\n        const data: null = null;\n        model.fromJSON(data);\n        expect(model.toString()).toBe('null');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the name of the model type","suites":["docregistry/default","TextModelFactory","#name"],"updatePoint":{"line":481,"column":47},"line":481,"code":"      it('should get the name of the model type', () => {\n        const factory = new TextModelFactory();\n        expect(factory.name).toBe('text');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the file type","suites":["docregistry/default","TextModelFactory","#contentType"],"updatePoint":{"line":488,"column":34},"line":488,"code":"      it('should get the file type', () => {\n        const factory = new TextModelFactory();\n        expect(factory.contentType).toBe('file');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the file format","suites":["docregistry/default","TextModelFactory","#fileFormat"],"updatePoint":{"line":495,"column":36},"line":495,"code":"      it('should get the file format', () => {\n        const factory = new TextModelFactory();\n        expect(factory.fileFormat).toBe('text');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get whether the factory is disposed","suites":["docregistry/default","TextModelFactory","#isDisposed"],"updatePoint":{"line":502,"column":52},"line":502,"code":"      it('should get whether the factory is disposed', () => {\n        const factory = new TextModelFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should dispose of the resources held by the factory","suites":["docregistry/default","TextModelFactory","#dispose()"],"updatePoint":{"line":511,"column":61},"line":511,"code":"      it('should dispose of the resources held by the factory', () => {\n        const factory = new TextModelFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be safe to call multiple times","suites":["docregistry/default","TextModelFactory","#dispose()"],"updatePoint":{"line":517,"column":47},"line":517,"code":"      it('should be safe to call multiple times', () => {\n        const factory = new TextModelFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should create a new model","suites":["docregistry/default","TextModelFactory","#createNew()"],"updatePoint":{"line":526,"column":35},"line":526,"code":"      it('should create a new model', () => {\n        const factory = new TextModelFactory();\n        const model = factory.createNew();\n        expect(model).toBeInstanceOf(DocumentModel);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should accept a language preference","suites":["docregistry/default","TextModelFactory","#createNew()"],"updatePoint":{"line":532,"column":45},"line":532,"code":"      it('should accept a language preference', () => {\n        const factory = new TextModelFactory();\n        const model = factory.createNew('foo');\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the preferred kernel language given an extension","suites":["docregistry/default","TextModelFactory","#preferredLanguage()"],"updatePoint":{"line":540,"column":69},"line":540,"code":"      it('should get the preferred kernel language given an extension', () => {\n        const factory = new TextModelFactory();\n        expect(factory.preferredLanguage('.py')).toBe('python');\n        expect(factory.preferredLanguage('.jl')).toBe('julia');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should set the title for the path","suites":["docregistry/default","DocumentWidget","#constructor"],"updatePoint":{"line":569,"column":43},"line":569,"code":"      it('should set the title for the path', () => {\n        expect(widget.title.label).toBe(context.localPath);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should update the title when the path changes","suites":["docregistry/default","DocumentWidget","#constructor"],"updatePoint":{"line":573,"column":55},"line":573,"code":"      it('should update the title when the path changes', async () => {\n        const path = UUID.uuid4() + '.jl';\n        await manager.contents.rename(context.path, path);\n        expect(widget.title.label).toBe(path);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add the dirty class when the model is dirty","suites":["docregistry/default","DocumentWidget","#constructor"],"updatePoint":{"line":579,"column":60},"line":579,"code":"      it('should add the dirty class when the model is dirty', async () => {\n        context.model.fromString('bar');\n        expect(widget.title.className).toContain('jp-mod-dirty');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should remove the dirty class","suites":["docregistry/default","DocumentWidget","#constructor"],"updatePoint":{"line":584,"column":39},"line":584,"code":"      it('should remove the dirty class', () => {\n        context.model.dirty = true;\n        context.model.dirty = true;\n        expect(widget.title.className).toContain('jp-mod-dirty');\n        context.model.dirty = false;\n        expect(widget.title.className).not.toContain('jp-mod-dirty');\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should store the context","suites":["docregistry/default","DocumentWidget","#constructor"],"updatePoint":{"line":592,"column":34},"line":592,"code":"      it('should store the context', () => {\n        expect(widget.context).toBe(context);\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should resolve after the reveal and context ready promises","suites":["docregistry/default","DocumentWidget","#revealed"],"updatePoint":{"line":600,"column":68},"line":600,"code":"      it('should resolve after the reveal and context ready promises', async () => {\n        const thisContext = new Context({\n          manager,\n          factory: new TextModelFactory(),\n          path: UUID.uuid4()\n        });\n        const x = Object.create(null);\n        const reveal = sleep(300, x);\n        const contextReady = Promise.all([thisContext.ready, x]);\n        const widget = new DocumentWidget({\n          context: thisContext,\n          content,\n          reveal\n        });\n        expect(widget.isRevealed).toBe(false);\n\n        // Our promise should resolve before the widget reveal promise.\n        expect(await Promise.race([widget.revealed, reveal])).toBe(x);\n        // The context ready promise should also resolve first.\n        void thisContext.initialize(true);\n        expect(await Promise.race([widget.revealed, contextReady])).toEqual([\n          undefined,\n          x\n        ]);\n        // The widget.revealed promise should finally resolve.\n        expect(await widget.revealed).toBeUndefined();\n\n        thisContext.dispose();\n      });","file":"default.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should require a context parameter","suites":["docregistry/mimedocument","MimeDocumentFactory","#createNew()"],"updatePoint":{"line":59,"column":44},"line":59,"code":"      it('should require a context parameter', () => {\n        const widgetFactory = new MimeDocumentFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          rendermime: RENDERMIME,\n          primaryFileType: DocumentRegistry.getDefaultTextFileType()\n        });\n        expect(widgetFactory.createNew(dContext)).toBeInstanceOf(MimeDocument);\n      });","file":"mimedocument.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should require options","suites":["docregistry/mimedocument","MimeContent","#constructor()"],"updatePoint":{"line":73,"column":32},"line":73,"code":"      it('should require options', () => {\n        const renderer = RENDERMIME.createRenderer('text/markdown');\n        const widget = new MimeContent({\n          context: dContext,\n          renderer,\n          mimeType: 'text/markdown',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        expect(widget).toBeInstanceOf(MimeContent);\n      });","file":"mimedocument.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should resolve when the widget is ready","suites":["docregistry/mimedocument","MimeContent","#ready"],"updatePoint":{"line":87,"column":49},"line":87,"code":"      it('should resolve when the widget is ready', async () => {\n        const renderer = RENDERMIME.createRenderer('text/markdown');\n        const widget = new LogRenderer({\n          context: dContext,\n          renderer,\n          mimeType: 'text/markdown',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        await widget.ready;\n        const layout = widget.layout as BoxLayout;\n        expect(layout.widgets.length).toBe(1);\n      });","file":"mimedocument.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should change the document contents","suites":["docregistry/mimedocument","MimeContent","contents changed"],"updatePoint":{"line":103,"column":45},"line":103,"code":"      it('should change the document contents', async () => {\n        RENDERMIME.addFactory(fooFactory);\n        const emission = testEmission(dContext.model.contentChanged, {\n          test: () => {\n            expect(dContext.model.toString()).toBe('bar');\n          }\n        });\n        const renderer = RENDERMIME.createRenderer('text/foo');\n        const widget = new LogRenderer({\n          context: dContext,\n          renderer,\n          mimeType: 'text/foo',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        await widget.ready;\n        await emission;\n      });","file":"mimedocument.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get whether the registry has been disposed","suites":["docregistry/registry","DocumentRegistry","#isDisposed"],"updatePoint":{"line":64,"column":59},"line":64,"code":"      it('should get whether the registry has been disposed', () => {\n        expect(registry.isDisposed).toBe(false);\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should dispose of the resources held by the registry","suites":["docregistry/registry","DocumentRegistry","#dispose()"],"updatePoint":{"line":72,"column":62},"line":72,"code":"      it('should dispose of the resources held by the registry', () => {\n        registry.addFileType({ name: 'notebook', extensions: ['.ipynb'] });\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be safe to call multiple times","suites":["docregistry/registry","DocumentRegistry","#dispose()"],"updatePoint":{"line":78,"column":47},"line":78,"code":"      it('should be safe to call multiple times', () => {\n        registry.dispose();\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add the widget factory to the registry","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":86,"column":55},"line":86,"code":"      it('should add the widget factory to the registry', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(registry.getWidgetFactory(factory.name)).toBe(factory);\n        expect(registry.getWidgetFactory(factory.name.toUpperCase())).toBe(\n          factory\n        );\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should become the global default if `*` is given as a defaultFor","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":95,"column":74},"line":95,"code":"      it('should become the global default if `*` is given as a defaultFor', () => {\n        const factory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('*').name).toBe('global');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should override an existing global default","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":105,"column":52},"line":105,"code":"      it('should override an existing global default', () => {\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'global',\n            fileTypes: ['*'],\n            defaultFor: ['*']\n          })\n        );\n        const factory = new WidgetFactory({\n          name: 'bar',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('*').name).toBe('bar');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should override an existing extension default","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":122,"column":55},"line":122,"code":"      it('should override an existing extension default', () => {\n        registry.addWidgetFactory(createFactory());\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be removed from the registry when disposed","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":129,"column":59},"line":129,"code":"      it('should be removed from the registry when disposed', () => {\n        const factory = createFactory();\n        const disposable = registry.addWidgetFactory(factory);\n        disposable.dispose();\n        expect(registry.getWidgetFactory('test')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should throw for an invalid factory name","suites":["docregistry/registry","DocumentRegistry","#addWidgetFactory()"],"updatePoint":{"line":136,"column":50},"line":136,"code":"      it('should throw for an invalid factory name', () => {\n        expect(() => {\n          registry.addWidgetFactory(\n            new WidgetFactory({\n              name: 'default',\n              fileTypes: [],\n              defaultFor: []\n            })\n          );\n        }).toThrowError(/Invalid/);\n        expect(() => {\n          registry.addWidgetFactory(\n            new WidgetFactory({\n              name: '',\n              fileTypes: [],\n              defaultFor: []\n            })\n          );\n        }).toThrowError(/Invalid/);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add the model factory to the registry","suites":["docregistry/registry","DocumentRegistry","#addModelFactory()"],"updatePoint":{"line":159,"column":54},"line":159,"code":"      it('should add the model factory to the registry', () => {\n        const factory = new Base64ModelFactory();\n        expect(() => {\n          registry.addModelFactory(factory);\n        }).not.toThrow();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a no-op a factory with the given `name` is already registered","suites":["docregistry/registry","DocumentRegistry","#addModelFactory()"],"updatePoint":{"line":166,"column":81},"line":166,"code":"      it('should be a no-op a factory with the given `name` is already registered', () => {\n        const factory = new Base64ModelFactory();\n        registry.addModelFactory(factory);\n\n        expect(() => {\n          const disposable = registry.addModelFactory(new Base64ModelFactory());\n          disposable.dispose();\n        }).not.toThrow();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a no-op if the same factory is already registered","suites":["docregistry/registry","DocumentRegistry","#addModelFactory()"],"updatePoint":{"line":176,"column":69},"line":176,"code":"      it('should be a no-op if the same factory is already registered', () => {\n        const factory = new Base64ModelFactory();\n        registry.addModelFactory(factory);\n        expect(() => {\n          const disposable = registry.addModelFactory(factory);\n          disposable.dispose();\n        }).not.toThrow();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be removed from the registry when disposed","suites":["docregistry/registry","DocumentRegistry","#addModelFactory()"],"updatePoint":{"line":185,"column":59},"line":185,"code":"      it('should be removed from the registry when disposed', () => {\n        const factory = new Base64ModelFactory();\n        expect(() => {\n          const disposable = registry.addModelFactory(factory);\n          disposable.dispose();\n        }).not.toThrow();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add a widget extension to the registry","suites":["docregistry/registry","DocumentRegistry","#addWidgetExtension()"],"updatePoint":{"line":195,"column":55},"line":195,"code":"      it('should add a widget extension to the registry', () => {\n        const extension = new WidgetExtension();\n        registry.addWidgetExtension('foo', extension);\n        expect(registry.widgetExtensions('foo').next()).toBe(extension);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a no-op if the extension is already registered for a given widget factory","suites":["docregistry/registry","DocumentRegistry","#addWidgetExtension()"],"updatePoint":{"line":201,"column":93},"line":201,"code":"      it('should be a no-op if the extension is already registered for a given widget factory', () => {\n        const extension = new WidgetExtension();\n        registry.addWidgetExtension('foo', extension);\n        const disposable = registry.addWidgetExtension('foo', extension);\n        disposable.dispose();\n        expect(registry.widgetExtensions('foo').next()).toBe(extension);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be removed from the registry when disposed","suites":["docregistry/registry","DocumentRegistry","#addWidgetExtension()"],"updatePoint":{"line":209,"column":59},"line":209,"code":"      it('should be removed from the registry when disposed', () => {\n        const extension = new WidgetExtension();\n        const disposable = registry.addWidgetExtension('foo', extension);\n        disposable.dispose();\n        expect(toArray(registry.widgetExtensions('foo')).length).toBe(0);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add a file type to the document registry","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":218,"column":57},"line":218,"code":"      it('should add a file type to the document registry', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        registry.addFileType(fileType);\n        expect(registry.fileTypes().next()!.name).toBe(fileType.name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be removed from the registry when disposed","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":225,"column":59},"line":225,"code":"      it('should be removed from the registry when disposed', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        const disposable = registry.addFileType(fileType);\n        disposable.dispose();\n        expect(toArray(registry.fileTypes()).length).toBe(0);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be a no-op if a file type of the same name is registered","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":233,"column":73},"line":233,"code":"      it('should be a no-op if a file type of the same name is registered', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        registry.addFileType(fileType);\n        const disposable = registry.addFileType(fileType);\n        disposable.dispose();\n        expect(registry.fileTypes().next()!.name).toBe(fileType.name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add a file type to some factories","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":242,"column":50},"line":242,"code":"      it('should add a file type to some factories', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        expect(registry.defaultWidgetFactory('dummy.test').name).toEqual(\n          gFactory.name\n        );\n\n        const fileType = { name: 'test-file', extensions: ['.test'] };\n        registry.addFileType(fileType, [factory.name]);\n        expect(registry.defaultWidgetFactory('dummy.test').name).toEqual(\n          factory.name\n        );\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should add a file type to some factories without changing the default","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":264,"column":79},"line":264,"code":"      it('should add a file type to some factories without changing the default', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n\n        const newFactory = new WidgetFactory({\n          name: 'new-factory',\n          fileTypes: ['new-foobar']\n        });\n        registry.addWidgetFactory(newFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.foo.bar'] };\n        registry.addFileType(fileType, [newFactory.name]);\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n        expect(\n          registry.preferredWidgetFactories('dummy.foo.bar').map(f => f.name)\n        ).toContain(newFactory.name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should remove the link to factory when disposed","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":295,"column":57},"line":295,"code":"      it('should remove the link to factory when disposed', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.test'] };\n        const disposable = registry.addFileType(fileType, [factory.name]);\n\n        disposable.dispose();\n\n        expect(registry.defaultWidgetFactory('dummy.test').name).toBe(\n          gFactory.name\n        );\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should remove the link to factory when disposed without changing the default","suites":["docregistry/registry","DocumentRegistry","#addFileType()"],"updatePoint":{"line":316,"column":86},"line":316,"code":"      it('should remove the link to factory when disposed without changing the default', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        const newFactory = new WidgetFactory({\n          name: 'new-factory',\n          fileTypes: ['new-foobar']\n        });\n        registry.addWidgetFactory(newFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.foo.bar'] };\n        const disposable = registry.addFileType(fileType, [newFactory.name]);\n\n        disposable.dispose();\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n        expect(\n          registry.preferredWidgetFactories('dummy.foo.bar').map(f => f.name)\n        ).not.toContain(newFactory.name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should give the valid registered widget factories","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":354,"column":59},"line":354,"code":"      it('should give the valid registered widget factories', () => {\n        expect(toArray(registry.preferredWidgetFactories('foo.txt'))).toEqual(\n          []\n        );\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const factories = registry.preferredWidgetFactories('a.foo.bar');\n        expect(toArray(factories)).toEqual([factory, gFactory]);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should not list a factory whose model is not registered","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":370,"column":65},"line":370,"code":"      it('should not list a factory whose model is not registered', () => {\n        registry.addWidgetFactory(createFactory('foobar'));\n        expect(registry.preferredWidgetFactories('a.foo.bar').length).toEqual(\n          0\n        );\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should select the factory for a given extension","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":377,"column":57},"line":377,"code":"      it('should select the factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.preferredWidgetFactories('a.txt')[0]).toBe(factory);\n        expect(registry.preferredWidgetFactories('a.md')[0]).toBe(mdFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should respect the priority order","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":389,"column":43},"line":389,"code":"      it('should respect the priority order', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        const factories = registry.preferredWidgetFactories('a.txt');\n        expect(toArray(factories)).toEqual([factory, gFactory]);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should list a default rendered factory after the default factory","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":407,"column":74},"line":407,"code":"      it('should list a default rendered factory after the default factory', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultRendered: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n\n        const factories = registry.preferredWidgetFactories('a.md');\n        expect(factories).toEqual([mdFactory, gFactory]);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle multi-part extensions","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":427,"column":45},"line":427,"code":"      it('should handle multi-part extensions', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const tFactory = new WidgetFactory({\n          name: 'table',\n          fileTypes: ['tablejson']\n        });\n        registry.addWidgetFactory(tFactory);\n        const jFactory = new WidgetFactory({\n          name: 'json',\n          fileTypes: ['json']\n        });\n        registry.addWidgetFactory(jFactory);\n        let factories = registry.preferredWidgetFactories('foo.table.json');\n        expect(toArray(factories)).toEqual([tFactory, jFactory]);\n        factories = registry.preferredWidgetFactories('foo.json');\n        expect(toArray(factories)).toEqual([jFactory]);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle just a multi-part extension","suites":["docregistry/registry","DocumentRegistry","#preferredWidgetFactories()"],"updatePoint":{"line":446,"column":51},"line":446,"code":"      it('should handle just a multi-part extension', () => {\n        const factory = new WidgetFactory({\n          name: 'table',\n          fileTypes: ['tablejson']\n        });\n        registry.addWidgetFactory(factory);\n        let factories = registry.preferredWidgetFactories('foo.table.json');\n        expect(toArray(factories)).toEqual([factory]);\n        factories = registry.preferredWidgetFactories('foo.json');\n        expect(toArray(factories)).toEqual([]);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the default widget factory for a given extension","suites":["docregistry/registry","DocumentRegistry","#defaultWidgetFactory()"],"updatePoint":{"line":460,"column":69},"line":460,"code":"      it('should get the default widget factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultFor: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n        expect(registry.defaultWidgetFactory('a.md')).toBe(mdFactory);\n        expect(registry.defaultWidgetFactory()).toBe(gFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should override the default widget factory for a file type","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":482,"column":68},"line":482,"code":"      it('should override the default widget factory for a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(mdFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should override the default rendered widget factory for a file type","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":493,"column":77},"line":493,"code":"      it('should override the default rendered widget factory for a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        expect(registry.defaultRenderedWidgetFactory('a.foo.bar')).toBe(\n          mdFactory\n        );\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should revert to the default widget factory when unset","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":506,"column":64},"line":506,"code":"      it('should revert to the default widget factory when unset', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        registry.setDefaultWidgetFactory('foobar', undefined);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should throw if the factory or file type do not exist","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":520,"column":63},"line":520,"code":"      it('should throw if the factory or file type do not exist', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(() => {\n          registry.setDefaultWidgetFactory('foobar', 'fake');\n        }).toThrowError(/Cannot find/);\n        expect(() => {\n          registry.setDefaultWidgetFactory('fake', undefined);\n        }).toThrowError(/Cannot find/);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should throw if the factory cannot render a file type","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":531,"column":63},"line":531,"code":"      it('should throw if the factory cannot render a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(() => {\n          registry.setDefaultWidgetFactory('foobar', 'markdown');\n        }).toThrowError(/cannot view/);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should revert to the default widget factory if the override is removed","suites":["docregistry/registry","DocumentRegistry","#setDefaultWidgetFactory()"],"updatePoint":{"line":543,"column":80},"line":543,"code":"      it('should revert to the default widget factory if the override is removed', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        const disposable = registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        disposable.dispose();\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the default rendered widget factory for a given extension","suites":["docregistry/registry","DocumentRegistry","#defaultRenderedWidgetFactory()"],"updatePoint":{"line":559,"column":78},"line":559,"code":"      it('should get the default rendered widget factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultRendered: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.defaultRenderedWidgetFactory('a.baz')).toBe(factory);\n        expect(registry.defaultRenderedWidgetFactory('a.md')).toBe(mdFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the default widget factory if no default rendered factory is registered","suites":["docregistry/registry","DocumentRegistry","#defaultRenderedWidgetFactory()"],"updatePoint":{"line":572,"column":92},"line":572,"code":"      it('should get the default widget factory if no default rendered factory is registered', () => {\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        expect(registry.defaultRenderedWidgetFactory('a.md')).toBe(gFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the registered file types","suites":["docregistry/registry","DocumentRegistry","#fileTypes()"],"updatePoint":{"line":584,"column":46},"line":584,"code":"      it('should get the registered file types', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        expect(toArray(registry.fileTypes()).length).toBe(0);\n        const fileTypes = [\n          { name: 'notebook', extensions: ['.ipynb'] },\n          { name: 'python', extensions: ['.py'] },\n          { name: 'table', extensions: ['.table.json'] }\n        ];\n        registry.addFileType(fileTypes[0]);\n        registry.addFileType(fileTypes[1]);\n        registry.addFileType(fileTypes[2]);\n        const values = registry.fileTypes();\n        expect(values.next()!.name).toBe(fileTypes[0].name);\n        expect(values.next()!.name).toBe(fileTypes[1].name);\n        expect(values.next()!.name).toBe(fileTypes[2].name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get a file type by name","suites":["docregistry/registry","DocumentRegistry","#getFileType()"],"updatePoint":{"line":603,"column":40},"line":603,"code":"      it('should get a file type by name', () => {\n        expect(registry.getFileType('notebook')).toBeTruthy();\n        expect(registry.getFileType('python')).toBeTruthy();\n        expect(registry.getFileType('fizzbuzz')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get a kernel preference","suites":["docregistry/registry","DocumentRegistry","#getKernelPreference()"],"updatePoint":{"line":611,"column":40},"line":611,"code":"      it('should get a kernel preference', () => {\n        registry.addWidgetFactory(createFactory());\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'python',\n            fileTypes: ['python'],\n            preferKernel: true,\n            canStartKernel: true\n          })\n        );\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'global',\n            fileTypes: ['*'],\n            defaultFor: ['*']\n          })\n        );\n        let pref = registry.getKernelPreference('.c', 'global');\n        expect(pref!.language).toBe('clike');\n        expect(pref!.shouldStart).toBe(false);\n        expect(pref!.canStart).toBe(false);\n\n        pref = registry.getKernelPreference('.py', 'python');\n        expect(pref!.language).toBe('python');\n        expect(pref!.shouldStart).toBe(true);\n        expect(pref!.canStart).toBe(true);\n\n        pref = registry.getKernelPreference('.py', 'baz');\n        expect(pref).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get a registered model factory by name","suites":["docregistry/registry","DocumentRegistry","#getModelFactory()"],"updatePoint":{"line":644,"column":55},"line":644,"code":"      it('should get a registered model factory by name', () => {\n        const mFactory = new Base64ModelFactory();\n        registry.addModelFactory(mFactory);\n        expect(registry.getModelFactory('base64')).toBe(mFactory);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get a widget factory by name","suites":["docregistry/registry","DocumentRegistry","#getWidgetFactory()"],"updatePoint":{"line":652,"column":45},"line":652,"code":"      it('should get a widget factory by name', () => {\n        registry.addModelFactory(new Base64ModelFactory());\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.getWidgetFactory(factory.name)).toBe(factory);\n        expect(registry.getWidgetFactory('markdown')).toBe(mdFactory);\n        expect(registry.getWidgetFactory('baz')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the registered extensions for a given widget","suites":["docregistry/registry","DocumentRegistry","#widgetExtensions()"],"updatePoint":{"line":668,"column":65},"line":668,"code":"      it('should get the registered extensions for a given widget', () => {\n        const foo = new WidgetExtension();\n        const bar = new WidgetExtension();\n        registry.addWidgetExtension('fizz', foo);\n        registry.addWidgetExtension('fizz', bar);\n        registry.addWidgetExtension('buzz', foo);\n        const fizz = toArray(registry.widgetExtensions('fizz'));\n        expect(fizz[0]).toBe(foo);\n        expect(fizz[1]).toBe(bar);\n        expect(fizz.length).toBe(2);\n        const buzz = toArray(registry.widgetExtensions('buzz'));\n        expect(buzz[0]).toBe(foo);\n        expect(toArray(buzz).length).toBe(1);\n        expect(registry.widgetExtensions('baz').next()).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle a directory","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":692,"column":35},"line":692,"code":"      it('should handle a directory', () => {\n        const ft = registry.getFileTypeForModel({\n          type: 'directory'\n        });\n        expect(ft.name).toBe('directory');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle a notebook","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":699,"column":34},"line":699,"code":"      it('should handle a notebook', () => {\n        const ft = registry.getFileTypeForModel({\n          type: 'notebook'\n        });\n        expect(ft.name).toBe('notebook');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle a python file","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":706,"column":37},"line":706,"code":"      it('should handle a python file', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.py'\n        });\n        expect(ft.name).toBe('python');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle an unknown file","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":713,"column":39},"line":713,"code":"      it('should handle an unknown file', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.bar'\n        });\n        expect(ft.name).toBe('text');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the most specific extension","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":720,"column":48},"line":720,"code":"      it('should get the most specific extension', () => {\n        [\n          { name: 'json', extensions: ['.json'] },\n          { name: 'vega', extensions: ['.vg.json'] }\n        ].forEach(ft => {\n          registry.addFileType(ft);\n        });\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.vg.json'\n        });\n        expect(ft.name).toBe('vega');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be case insensitive","suites":["docregistry/registry","DocumentRegistry","#getFileTypeForModel()"],"updatePoint":{"line":733,"column":36},"line":733,"code":"      it('should be case insensitive', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.PY'\n        });\n        expect(ft.name).toBe('python');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle a notebook","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":748,"column":34},"line":748,"code":"      it('should handle a notebook', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.ipynb');\n        expect(ft[0].name).toBe('notebook');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should handle a python file","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":753,"column":37},"line":753,"code":"      it('should handle a python file', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.py');\n        expect(ft[0].name).toBe('python');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should return an empty list for an unknown file","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":758,"column":57},"line":758,"code":"      it('should return an empty list for an unknown file', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.weird');\n        expect(ft.length).toBe(0);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should get the most specific extension first","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":763,"column":54},"line":763,"code":"      it('should get the most specific extension first', () => {\n        [\n          { name: 'json', extensions: ['.json'] },\n          { name: 'vega', extensions: ['.vg.json'] }\n        ].forEach(ft => {\n          registry.addFileType(ft);\n        });\n        const ft = registry.getFileTypesForPath('foo/bar/baz.vg.json');\n        expect(ft[0].name).toBe('vega');\n        expect(ft[1].name).toBe('json');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should be case insensitive","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"line":775,"code":"      it.each([\n        ['python', null, 'foo/bar/baz.PY'],\n        ['r-markdown', ['.Rmd'], 'foo/bar/baz.Rmd']\n      ])('should be case insensitive', (name, extensions, filename) => {\n        if (extensions) {\n          registry.addFileType({ name, extensions });\n        }\n        const ft = registry.getFileTypesForPath(filename);\n        expect(ft[0].name).toBe(name);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should support pattern matching","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":786,"column":41},"line":786,"code":"      it('should support pattern matching', () => {\n        registry.addFileType({\n          name: 'test',\n          extensions: ['.temp'],\n          pattern: '.*\\\\.test$'\n        });\n\n        const ft = registry.getFileTypesForPath('foo/bar/baz.test');\n        expect(ft[0].name).toBe('test');\n\n        const ft2 = registry.getFileTypesForPath('foo/bar/baz.temp');\n        expect(ft2[0].name).toBe('test');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should returns all file types","suites":["docregistry/registry","DocumentRegistry","#getFileTypesForPath()"],"updatePoint":{"line":800,"column":39},"line":800,"code":"      it('should returns all file types', () => {\n        registry.addFileType({\n          name: 'test',\n          extensions: ['.foo.bar']\n        });\n\n        const ft = registry.getFileTypesForPath('foo/bar/test.foo.bar');\n        expect(ft.length).toBeGreaterThanOrEqual(2);\n        expect(ft.map(f => f.name)).toContain('test');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/docregistry/test"},{"name":"should highlight text fragment nested in a node","suites":["documentsearch/genericsearchprovider","GenericSearchProvider","#startQuery()"],"updatePoint":{"line":42,"column":57},"line":42,"code":"      it('should highlight text fragment nested in a node', async () => {\n        widget.node.innerHTML = '<pre>xyz</pre>';\n        match = await queryOne(/x/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span class=\"${MATCH_CLASSES}\">x</span>yz`\n        );\n\n        match = await queryOne(/y/);\n        expect(getHTMLForMatch(match)).toBe(\n          `x<span class=\"${MATCH_CLASSES}\">y</span>z`\n        );\n\n        match = await queryOne(/z/);\n        expect(getHTMLForMatch(match)).toBe(\n          `xy<span class=\"${MATCH_CLASSES}\">z</span>`\n        );\n      });","file":"documentsearchprovider.spec.ts","skipped":false,"dir":"packages/documentsearch/test"},{"name":"should highlight in presence of nested spans adjacent to text nodes","suites":["documentsearch/genericsearchprovider","GenericSearchProvider","#startQuery()"],"updatePoint":{"line":60,"column":77},"line":60,"code":"      it('should highlight in presence of nested spans adjacent to text nodes', async () => {\n        widget.node.innerHTML = '<pre><span>x</span>yz</pre>';\n        match = await queryOne(/x/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span><span class=\"${MATCH_CLASSES}\">x</span></span>yz`\n        );\n\n        match = await queryOne(/y/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span>x</span><span class=\"${MATCH_CLASSES}\">y</span>z`\n        );\n\n        match = await queryOne(/z/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span>x</span>y<span class=\"${MATCH_CLASSES}\">z</span>`\n        );\n\n        widget.node.innerHTML = '<pre>x<span>y</span>z</pre>';\n        match = await queryOne(/x/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span class=\"${MATCH_CLASSES}\">x</span><span>y</span>z`\n        );\n\n        match = await queryOne(/y/);\n        expect(getHTMLForMatch(match)).toBe(\n          `x<span><span class=\"${MATCH_CLASSES}\">y</span></span>z`\n        );\n\n        match = await queryOne(/z/);\n        expect(getHTMLForMatch(match)).toBe(\n          `x<span>y</span><span class=\"${MATCH_CLASSES}\">z</span>`\n        );\n\n        widget.node.innerHTML = '<pre>xy<span>z</span></pre>';\n        match = await queryOne(/x/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span class=\"${MATCH_CLASSES}\">x</span>y<span>z</span>`\n        );\n\n        match = await queryOne(/y/);\n        expect(getHTMLForMatch(match)).toBe(\n          `x<span class=\"${MATCH_CLASSES}\">y</span><span>z</span>`\n        );\n\n        match = await queryOne(/z/);\n        expect(getHTMLForMatch(match)).toBe(\n          `xy<span><span class=\"${MATCH_CLASSES}\">z</span></span>`\n        );\n      });","file":"documentsearchprovider.spec.ts","skipped":false,"dir":"packages/documentsearch/test"},{"name":"should slice out the match correctly in nested nodes","suites":["documentsearch/genericsearchprovider","GenericSearchProvider","#startQuery()"],"updatePoint":{"line":110,"column":62},"line":110,"code":"      it('should slice out the match correctly in nested nodes', async () => {\n        widget.node.innerHTML = '<pre><span>xy</span>z</pre>';\n        match = await queryOne(/x/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span><span class=\"${MATCH_CLASSES}\">x</span>y</span>z`\n        );\n\n        match = await queryOne(/y/);\n        expect(getHTMLForMatch(match)).toBe(\n          `<span>x<span class=\"${MATCH_CLASSES}\">y</span></span>z`\n        );\n      });","file":"documentsearchprovider.spec.ts","skipped":false,"dir":"packages/documentsearch/test"},{"name":"should create a new BreadCrumbs instance","suites":["filebrowser/model","BreadCrumbs","#constructor()"],"updatePoint":{"line":100,"column":50},"line":100,"code":"      it('should create a new BreadCrumbs instance', () => {\n        const bread = new BreadCrumbs({ model });\n        expect(bread).toBeInstanceOf(BreadCrumbs);\n        const items = crumbs.node.querySelectorAll(ITEM_QUERY);\n        expect(items.length).toBe(1);\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should add the jp-BreadCrumbs class","suites":["filebrowser/model","BreadCrumbs","#constructor()"],"updatePoint":{"line":107,"column":45},"line":107,"code":"      it('should add the jp-BreadCrumbs class', () => {\n        expect(crumbs.hasClass('jp-BreadCrumbs')).toBe(true);\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should switch to the parent directory","suites":["filebrowser/model","BreadCrumbs","#handleEvent()","click"],"updatePoint":{"line":114,"column":49},"line":114,"code":"        it('should switch to the parent directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(4);\n          const promise = signalToPromise(model.pathChanged);\n          expect(items[2].textContent).toBe(second);\n          simulate(items[2], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(3);\n        });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should switch to the home directory","suites":["filebrowser/model","BreadCrumbs","#handleEvent()","click"],"updatePoint":{"line":128,"column":47},"line":128,"code":"        it('should switch to the home directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.pathChanged);\n          simulate(items[0], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(1);\n          expect(model.path).toBe('');\n        });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should switch to the grandparent directory","suites":["filebrowser/model","BreadCrumbs","#handleEvent()","click"],"updatePoint":{"line":141,"column":54},"line":141,"code":"        it('should switch to the grandparent directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.pathChanged);\n          simulate(items[1], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(2);\n          expect(model.path).toBe(first);\n        });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should refresh the current directory","suites":["filebrowser/model","BreadCrumbs","#handleEvent()","click"],"updatePoint":{"line":154,"column":48},"line":154,"code":"        it('should refresh the current directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.refreshed);\n          expect(items[3].textContent).toBe(third);\n          simulate(items[3], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(4);\n          expect(model.path).toBe(path);\n        });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should post an update request","suites":["filebrowser/model","BreadCrumbs","#onAfterAttach()"],"updatePoint":{"line":171,"column":39},"line":171,"code":"      it('should post an update request', async () => {\n        Widget.attach(crumbs, document.body);\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        await framePromise();\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should add event listeners","suites":["filebrowser/model","BreadCrumbs","#onAfterAttach()"],"updatePoint":{"line":182,"column":36},"line":182,"code":"      it('should add event listeners', () => {\n        Widget.attach(crumbs, document.body);\n        simulate(crumbs.node, 'click');\n        expect(crumbs.events).toEqual(expect.arrayContaining(['click']));\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should remove event listeners","suites":["filebrowser/model","BreadCrumbs","#onBeforeDetach()"],"updatePoint":{"line":190,"column":39},"line":190,"code":"      it('should remove event listeners', () => {\n        Widget.attach(crumbs, document.body);\n        Widget.detach(crumbs);\n        simulate(crumbs.node, 'click');\n        expect(crumbs.events).not.toEqual(expect.arrayContaining(['click']));\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be called when the model updates","suites":["filebrowser/model","BreadCrumbs","#onUpdateRequest()"],"updatePoint":{"line":199,"column":49},"line":199,"code":"      it('should be called when the model updates', async () => {\n        const model = new FileBrowserModel({ manager });\n        await model.cd(path);\n        crumbs = new LogCrumbs({ model });\n        await model.cd('..');\n        await framePromise();\n\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        const items = crumbs.node.querySelectorAll(ITEM_QUERY);\n        expect(items.length).toBe(3);\n        model.dispose();\n      });","file":"crumbs.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should construct a new file browser model","suites":["filebrowser/model","FileBrowserModel","#constructor()"],"updatePoint":{"line":94,"column":51},"line":94,"code":"      it('should construct a new file browser model', () => {\n        model = new FileBrowserModel({ manager });\n        expect(model).toBeInstanceOf(FileBrowserModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted when the path changes","suites":["filebrowser/model","FileBrowserModel","#pathChanged"],"updatePoint":{"line":101,"column":49},"line":101,"code":"      it('should be emitted when the path changes', async () => {\n        let called = false;\n        model.pathChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('path');\n          expect(args.oldValue).toBe('');\n          expect(args.newValue).toBe(subDir);\n          called = true;\n        });\n        await model.cd(subDir);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted after a refresh","suites":["filebrowser/model","FileBrowserModel","#refreshed"],"updatePoint":{"line":116,"column":43},"line":116,"code":"      it('should be emitted after a refresh', async () => {\n        let called = false;\n        model.refreshed.connect((sender, arg) => {\n          expect(sender).toBe(model);\n          expect(arg).toBeUndefined();\n          called = true;\n        });\n        await model.cd();\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted when the path changes","suites":["filebrowser/model","FileBrowserModel","#refreshed"],"updatePoint":{"line":127,"column":49},"line":127,"code":"      it('should be emitted when the path changes', async () => {\n        let called = false;\n        model.refreshed.connect((sender, arg) => {\n          expect(sender).toBe(model);\n          expect(arg).toBeUndefined();\n          called = true;\n        });\n        await model.cd(subDir);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted when a file is created","suites":["filebrowser/model","FileBrowserModel","#fileChanged"],"updatePoint":{"line":140,"column":50},"line":140,"code":"      it('should be emitted when a file is created', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('new');\n          expect(args.oldValue).toBeNull();\n          expect(args.newValue!.type).toBe('file');\n          called = true;\n        });\n        await manager.newUntitled({ type: 'file' });\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted when a file is renamed","suites":["filebrowser/model","FileBrowserModel","#fileChanged"],"updatePoint":{"line":153,"column":50},"line":153,"code":"      it('should be emitted when a file is renamed', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('rename');\n          expect(args.oldValue!.path).toBe(name);\n          expect(args.newValue!.path).toBe(name + '.bak');\n          called = true;\n        });\n        await manager.rename(name, name + '.bak');\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be emitted when a file is deleted","suites":["filebrowser/model","FileBrowserModel","#fileChanged"],"updatePoint":{"line":166,"column":50},"line":166,"code":"      it('should be emitted when a file is deleted', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('delete');\n          expect(args.oldValue!.path).toBe(name);\n          expect(args.newValue).toBeNull();\n          called = true;\n        });\n        await manager.deleteFile(name);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be the current path of the model","suites":["filebrowser/model","FileBrowserModel","#path"],"updatePoint":{"line":181,"column":49},"line":181,"code":"      it('should be the current path of the model', async () => {\n        expect(model.path).toBe('');\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be and remain the root path of the model","suites":["filebrowser/model","FileBrowserModel","#rootPath"],"updatePoint":{"line":189,"column":57},"line":189,"code":"      it('should be and remain the root path of the model', async () => {\n        expect(model.rootPath).toBe('');\n        await model.cd('src/');\n        expect(model.rootPath).toBe('');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should get an iterator of items in the current path","suites":["filebrowser/model","FileBrowserModel","#items()"],"updatePoint":{"line":197,"column":61},"line":197,"code":"      it('should get an iterator of items in the current path', () => {\n        const items = model.items();\n        expect(items.next()).toBeTruthy();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should test whether the model is disposed","suites":["filebrowser/model","FileBrowserModel","#isDisposed"],"updatePoint":{"line":204,"column":51},"line":204,"code":"      it('should test whether the model is disposed', () => {\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be the session models for the active notebooks","suites":["filebrowser/model","FileBrowserModel","#sessions()"],"updatePoint":{"line":212,"column":63},"line":212,"code":"      it('should be the session models for the active notebooks', async () => {\n        const contents = await manager.newUntitled({ type: 'notebook' });\n        const session = await serviceManager.sessions.startNew({\n          name: '',\n          path: contents.path,\n          type: 'test'\n        });\n        await model.cd();\n        expect(model.sessions().next()).toBeTruthy();\n        await session.shutdown();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should dispose of the resources held by the model","suites":["filebrowser/model","FileBrowserModel","#dispose()"],"updatePoint":{"line":226,"column":59},"line":226,"code":"      it('should dispose of the resources held by the model', () => {\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be safe to call more than once","suites":["filebrowser/model","FileBrowserModel","#dispose()"],"updatePoint":{"line":231,"column":47},"line":231,"code":"      it('should be safe to call more than once', () => {\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should refresh the contents","suites":["filebrowser/model","FileBrowserModel","#refresh()"],"updatePoint":{"line":239,"column":37},"line":239,"code":"      it('should refresh the contents', async () => {\n        await expect(model.refresh()).resolves.not.toThrow();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should change directory","suites":["filebrowser/model","FileBrowserModel","#cd()"],"updatePoint":{"line":245,"column":33},"line":245,"code":"      it('should change directory', async () => {\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should change to a nested directory","suites":["filebrowser/model","FileBrowserModel","#cd()"],"updatePoint":{"line":250,"column":45},"line":250,"code":"      it('should change to a nested directory', async () => {\n        await model.cd(subSubDir);\n        expect(model.path).toBe(subSubDir);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should accept a relative path","suites":["filebrowser/model","FileBrowserModel","#cd()"],"updatePoint":{"line":255,"column":39},"line":255,"code":"      it('should accept a relative path', async () => {\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should accept a parent directory","suites":["filebrowser/model","FileBrowserModel","#cd()"],"updatePoint":{"line":260,"column":42},"line":260,"code":"      it('should accept a parent directory', async () => {\n        await model.cd(subDir);\n        await model.cd('..');\n        expect(model.path).toBe('');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be resilient to a slow initial fetch","suites":["filebrowser/model","FileBrowserModel","#cd()"],"updatePoint":{"line":266,"column":53},"line":266,"code":"      it('should be resilient to a slow initial fetch', async () => {\n        const delayedServiceManager = new Mock.ServiceManagerMock();\n        (delayedServiceManager as any).contents = new DelayedContentsManager();\n        const contents = await delayedServiceManager.contents.newUntitled({\n          type: 'directory'\n        });\n        subDir = contents.path;\n\n        const manager = new DocumentManager({\n          registry,\n          opener,\n          manager: delayedServiceManager\n        });\n        model = new FileBrowserModel({ manager, state }); // Should delay 1000ms\n\n        // An initial refresh is called in the constructor.\n        // If it is too slow, it can come in after the directory change,\n        // causing a directory set by, e.g., the tree handler to be wrong.\n        // This checks to make sure we are handling that case correctly.\n        await model.cd(subDir); // should delay 500ms\n        await sleep(2000);\n        expect(model.path).toBe(subDir);\n\n        manager.dispose();\n        delayedServiceManager.contents.dispose();\n        delayedServiceManager.dispose();\n        model.dispose();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should restore based on ID","suites":["filebrowser/model","FileBrowserModel","#restore()"],"updatePoint":{"line":297,"column":36},"line":297,"code":"      it('should restore based on ID', async () => {\n        const id = 'foo';\n        const model2 = new FileBrowserModel({ manager, state });\n        await model.restore(id);\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n        expect(model2.path).toBe('');\n        await model2.restore(id);\n        expect(model2.path).toBe(subDir);\n        model2.dispose();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should be safe to call multiple times","suites":["filebrowser/model","FileBrowserModel","#restore()"],"updatePoint":{"line":309,"column":47},"line":309,"code":"      it('should be safe to call multiple times', async () => {\n        const id = 'bar';\n        const model2 = new FileBrowserModel({ manager, state });\n        await model.restore(id);\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n        expect(model2.path).toBe('');\n        await model2.restore(id);\n        await model2.restore(id);\n        expect(model2.path).toBe(subDir);\n        model2.dispose();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should download the file without error","suites":["filebrowser/model","FileBrowserModel","#download()"],"line":324,"code":"      it.skip('should download the file without error', () => {","file":"model.spec.ts","skipped":true,"dir":"packages/filebrowser/test"},{"name":"should upload a file object","suites":["filebrowser/model","FileBrowserModel","#upload()"],"updatePoint":{"line":330,"column":37},"line":330,"code":"      it('should upload a file object', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should overwrite","suites":["filebrowser/model","FileBrowserModel","#upload()"],"updatePoint":{"line":339,"column":26},"line":339,"code":"      it('should overwrite', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n        const promise = model.upload(file);\n        await acceptDialog();\n        await promise;\n        expect(contents.name).toBe(fname);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should not overwrite","suites":["filebrowser/model","FileBrowserModel","#upload()"],"updatePoint":{"line":352,"column":30},"line":352,"code":"      it('should not overwrite', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n        const promise = model.upload(file);\n        await dismissDialog();\n\n        await expect(promise).rejects.toBe('File not uploaded');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should emit the fileChanged signal","suites":["filebrowser/model","FileBrowserModel","#upload()"],"updatePoint":{"line":365,"column":44},"line":365,"code":"      it('should emit the fileChanged signal', async () => {\n        const fname = UUID.uuid4() + '.html';\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('save');\n          expect(args.oldValue).toBeNull();\n          expect(args.newValue!.path).toBe(fname);\n          called = true;\n        });\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        await model.upload(file);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should not upload large file","suites":["filebrowser/model","FileBrowserModel","#upload()","older notebook version"],"updatePoint":{"line":392,"column":40},"line":392,"code":"        it('should not upload large file', async () => {\n          const fname = UUID.uuid4() + '.html';\n          const file = new File([new ArrayBuffer(LARGE_FILE_SIZE + 1)], fname);\n\n          await expect(model.upload(file)).rejects.toBe(\n            `Cannot upload file (>15 MB). ${fname}`\n          );\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should upload a large  file of size ","suites":["filebrowser/model","FileBrowserModel","#upload()","newer notebook version"],"updatePoint":{"line":423,"column":68},"line":423,"code":"            it(`should upload a large ${ending} file of size ${size}`, async () => {\n              const fname = UUID.uuid4() + ending;\n\n              // minimal valid (according to server) notebook\n              let content =\n                '{\"nbformat\": 4, \"metadata\": {\"_\": \"\"}, \"nbformat_minor\": 2, \"cells\": []}';\n              // make metadata longer so that total document is `size` long\n              content = content.replace(\n                '\"_\": \"\"',\n                `\"_\": \"${' '.repeat(size - content.length)}\"`\n              );\n              const file = new File([content], fname, { type: 'text/plain' });\n              await model.upload(file);\n              // Ensure we get the file back.\n              const contentModel = await model.manager.services.contents.get(\n                fname\n              );\n              expect(contentModel.content.length).toBeGreaterThan(0);\n            });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should produce progress as a large file uploads","suites":["filebrowser/model","FileBrowserModel","#upload()","newer notebook version"],"updatePoint":{"line":445,"column":59},"line":445,"code":"        it(`should produce progress as a large file uploads`, async () => {\n          const fname = UUID.uuid4() + '.txt';\n          const file = new File([new ArrayBuffer(2 * CHUNK_SIZE)], fname);\n\n          const [start, first, second, finished] = signalToPromises(\n            model.uploadChanged,\n            4\n          );\n\n          const uploaded = model.upload(file);\n          expect(toArray(model.uploads())).toEqual([]);\n          expect(await start).toEqual([\n            model,\n            {\n              name: 'start',\n              oldValue: null,\n              newValue: { path: fname, progress: 0 }\n            }\n          ]);\n          expect(toArray(model.uploads())).toEqual([\n            { path: fname, progress: 0 }\n          ]);\n          expect(await first).toEqual([\n            model,\n            {\n              name: 'update',\n              oldValue: { path: fname, progress: 0 },\n              newValue: { path: fname, progress: 0 }\n            }\n          ]);\n          expect(toArray(model.uploads())).toEqual([\n            { path: fname, progress: 0 }\n          ]);\n          expect(await second).toEqual([\n            model,\n            {\n              name: 'update',\n              oldValue: { path: fname, progress: 0 },\n              newValue: { path: fname, progress: 1 / 2 }\n            }\n          ]);\n          expect(toArray(model.uploads())).toEqual([\n            { path: fname, progress: 1 / 2 }\n          ]);\n          expect(await finished).toEqual([\n            model,\n            {\n              name: 'finish',\n              oldValue: { path: fname, progress: 1 / 2 },\n              newValue: null\n            }\n          ]);\n          expect(toArray(model.uploads())).toEqual([]);\n          await uploaded;\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should construct a new filtered file browser model","suites":["@jupyterlab/filebrowser","FilterFileBrowserModel","#constructor()"],"updatePoint":{"line":50,"column":60},"line":50,"code":"      it('should construct a new filtered file browser model', () => {\n        const model = new FilterFileBrowserModel({ manager });\n        expect(model).toBeInstanceOf(FilterFileBrowserModel);\n      });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should accept filter option","suites":["@jupyterlab/filebrowser","FilterFileBrowserModel","#constructor()"],"updatePoint":{"line":55,"column":37},"line":55,"code":"      it('should accept filter option', () => {\n        const model = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => false\n        });\n        expect(model).toBeInstanceOf(FilterFileBrowserModel);\n      });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should list all elements if no filter is defined","suites":["@jupyterlab/filebrowser","FilterFileBrowserModel","#items()"],"updatePoint":{"line":65,"column":58},"line":65,"code":"      it('should list all elements if no filter is defined', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = toArray(filteredModel.items());\n        const items = toArray(model.items());\n        expect(filteredItems.length).toBe(items.length);\n      });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should list all directories whatever the filter","suites":["@jupyterlab/filebrowser","FilterFileBrowserModel","#items()"],"updatePoint":{"line":78,"column":57},"line":78,"code":"      it('should list all directories whatever the filter', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => false\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = toArray(filteredModel.items());\n        const items = toArray(model.items());\n        const folders = items.filter(item => item.type === 'directory');\n        expect(filteredItems.length).toBe(folders.length);\n      });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should respect the filter","suites":["@jupyterlab/filebrowser","FilterFileBrowserModel","#items()"],"updatePoint":{"line":93,"column":35},"line":93,"code":"      it('should respect the filter', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => model.type === 'notebook'\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = toArray(\n          filteredModel.items()\n        ) as Contents.IModel[];\n        const items = toArray(model.items());\n        const shownItems = items.filter(\n          item => item.type === 'directory' || item.type === 'notebook'\n        );\n        expect(filteredItems.length).toBe(shownItems.length);\n        const notebooks = filteredItems.filter(\n          item => item.type === 'notebook'\n        );\n        expect(notebooks.length).toBeGreaterThan(0);\n      });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should create a dialog","suites":["@jupyterlab/filebrowser","FileDialog.getOpenFiles()"],"updatePoint":{"line":119,"column":30},"line":119,"code":"    it('should create a dialog', async () => {\n      const dialog = FileDialog.getOpenFiles({\n        manager\n      });\n\n      await dismissDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(false);\n      expect(result.value).toBeNull();\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should accept options","suites":["@jupyterlab/filebrowser","FileDialog.getOpenFiles()"],"updatePoint":{"line":132,"column":29},"line":132,"code":"    it('should accept options', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getOpenFiles({\n        manager,\n        title: 'Select a notebook',\n        host: node,\n        filter: (value: Contents.IModel) => value.type === 'notebook'\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(true);\n      const items = result.value!;\n      expect(items.length).toBe(1);\n\n      document.body.removeChild(node);\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should return one selected file","suites":["@jupyterlab/filebrowser","FileDialog.getOpenFiles()"],"updatePoint":{"line":155,"column":39},"line":155,"code":"    it('should return one selected file', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getOpenFiles({\n        manager,\n        title: 'Select a notebook',\n        host: node,\n        filter: (value: Contents.IModel) => value.type === 'notebook'\n      });\n\n      await waitForDialog();\n      await framePromise();\n\n      let counter = 0;\n      const listing = node.getElementsByClassName('jp-DirListing-content')[0];\n      expect(listing).toBeTruthy();\n\n      let items = listing.getElementsByTagName('li');\n      counter = 0;\n      // Wait for the directory listing to be populated\n      while (items.length === 0 && counter < 100) {\n        await sleep(10);\n        items = listing.getElementsByTagName('li');\n        counter++;\n      }\n\n      // Fails if there is no items shown\n      expect(items.length).toBeGreaterThan(0);\n\n      // Emulate notebook file selection\n      const item = listing.querySelector('li[data-file-type=\"notebook\"]')!;\n      simulate(item, 'mousedown');\n\n      await acceptDialog();\n      const result = await dialog;\n      const files = result.value!;\n      expect(files.length).toBe(1);\n      expect(files[0].type).toBe('notebook');\n      expect(files[0].name).toEqual(expect.stringMatching(/Untitled.*.ipynb/));\n\n      document.body.removeChild(node);\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should return current path if nothing is selected","suites":["@jupyterlab/filebrowser","FileDialog.getOpenFiles()"],"updatePoint":{"line":200,"column":57},"line":200,"code":"    it('should return current path if nothing is selected', async () => {\n      const dialog = FileDialog.getOpenFiles({\n        manager\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n      const items = result.value!;\n\n      expect(items.length).toBe(1);\n      expect(items[0].type).toBe('directory');\n      expect(items[0].path).toBe('');\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should create a dialog","suites":["@jupyterlab/filebrowser","FileDialog.getExistingDirectory()"],"updatePoint":{"line":217,"column":30},"line":217,"code":"    it('should create a dialog', async () => {\n      const dialog = FileDialog.getExistingDirectory({\n        manager\n      });\n\n      await dismissDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(false);\n      expect(result.value).toBeNull();\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should accept options","suites":["@jupyterlab/filebrowser","FileDialog.getExistingDirectory()"],"updatePoint":{"line":230,"column":29},"line":230,"code":"    it('should accept options', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getExistingDirectory({\n        manager,\n        title: 'Select a folder',\n        host: node\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(true);\n      expect(result.value!.length).toBe(1);\n\n      document.body.removeChild(node);\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should return one selected directory","suites":["@jupyterlab/filebrowser","FileDialog.getExistingDirectory()"],"updatePoint":{"line":251,"column":44},"line":251,"code":"    it('should return one selected directory', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getExistingDirectory({\n        manager,\n        title: 'Select a folder',\n        host: node\n      });\n\n      await waitForDialog();\n      await framePromise();\n\n      let counter = 0;\n      const listing = node.getElementsByClassName('jp-DirListing-content')[0];\n      expect(listing).toBeTruthy();\n\n      let items = listing.getElementsByTagName('li');\n      // Wait for the directory listing to be populated\n      while (items.length === 0 && counter < 100) {\n        await sleep(10);\n        items = listing.getElementsByTagName('li');\n        counter++;\n      }\n\n      // Fails if there is no items shown\n      expect(items.length).toBeGreaterThan(0);\n\n      // Emulate notebook file selection\n      simulate(items.item(items.length - 1)!, 'mousedown');\n\n      await acceptDialog();\n      const result = await dialog;\n      const files = result.value!;\n      expect(files.length).toBe(1);\n      expect(files[0].type).toBe('directory');\n      expect(files[0].name).toEqual(\n        expect.stringMatching(/Untitled Folder( \\d+)?/)\n      );\n\n      document.body.removeChild(node);\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should return current path if nothing is selected","suites":["@jupyterlab/filebrowser","FileDialog.getExistingDirectory()"],"updatePoint":{"line":295,"column":57},"line":295,"code":"    it('should return current path if nothing is selected', async () => {\n      const dialog = FileDialog.getExistingDirectory({\n        manager\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n      const items = result.value!;\n\n      expect(items.length).toBe(1);\n      expect(items[0].type).toBe('directory');\n      expect(items[0].path).toBe('');\n    });","file":"openfiledialog.spec.ts","skipped":false,"dir":"packages/filebrowser/test"},{"name":"should create an editor wrapper widget","suites":["fileeditorcodewrapper","FileEditorCodeWrapper","#constructor()"],"updatePoint":{"line":83,"column":48},"line":83,"code":"      it('should create an editor wrapper widget', () => {\n        expect(widget).toBeInstanceOf(FileEditorCodeWrapper);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should update the editor text when the model changes","suites":["fileeditorcodewrapper","FileEditorCodeWrapper","#constructor()"],"updatePoint":{"line":87,"column":62},"line":87,"code":"      it('should update the editor text when the model changes', async () => {\n        await context.initialize(true);\n        await context.ready;\n        widget.context.model.fromString('foo');\n        expect(widget.editor.model.value.text).toBe('foo');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should be the context used by the widget","suites":["fileeditorcodewrapper","FileEditorCodeWrapper","#context"],"updatePoint":{"line":96,"column":50},"line":96,"code":"      it('should be the context used by the widget', () => {\n        expect(widget.context).toBe(context);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should create an editor widget","suites":["fileeditorcodewrapper","FileEditor","#constructor()"],"updatePoint":{"line":120,"column":40},"line":120,"code":"      it('should create an editor widget', () => {\n        expect(widget).toBeInstanceOf(FileEditor);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should update the editor text when the model changes","suites":["fileeditorcodewrapper","FileEditor","#constructor()"],"updatePoint":{"line":124,"column":62},"line":124,"code":"      it('should update the editor text when the model changes', async () => {\n        await context.initialize(true);\n        await context.ready;\n        widget.context.model.fromString('foo');\n        expect(widget.editor.model.value.text).toBe('foo');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should set the mime type for the path","suites":["fileeditorcodewrapper","FileEditor","#constructor()"],"updatePoint":{"line":131,"column":47},"line":131,"code":"      it('should set the mime type for the path', () => {\n        expect(widget.editor.model.mimeType).toBe('text/x-python');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should update the mime type when the path changes","suites":["fileeditorcodewrapper","FileEditor","#constructor()"],"updatePoint":{"line":135,"column":59},"line":135,"code":"      it('should update the mime type when the path changes', async () => {\n        let called = false;\n        context.pathChanged.connect((sender, args) => {\n          expect(widget.editor.model.mimeType).toBe('text/x-julia');\n          called = true;\n        });\n        await context.initialize(true);\n        await manager.contents.rename(context.path, UUID.uuid4() + '.jl');\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should be the context used by the widget","suites":["fileeditorcodewrapper","FileEditor","#context"],"updatePoint":{"line":148,"column":50},"line":148,"code":"      it('should be the context used by the widget', () => {\n        expect(widget.context).toBe(context);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should focus the editor","suites":["fileeditorcodewrapper","FileEditor","#handleEvent()","mousedown"],"updatePoint":{"line":164,"column":35},"line":164,"code":"        it('should focus the editor', () => {\n          simulate(widget.node, 'mousedown');\n          expect(widget.events).toContain('mousedown');\n          expect(widget.editor.hasFocus()).toBe(true);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should add event listeners","suites":["fileeditorcodewrapper","FileEditor","#onAfterAttach()"],"updatePoint":{"line":173,"column":36},"line":173,"code":"      it('should add event listeners', async () => {\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toContain('onAfterAttach');\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).toContain('mousedown');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should remove event listeners","suites":["fileeditorcodewrapper","FileEditor","#onBeforeDetach()"],"updatePoint":{"line":183,"column":39},"line":183,"code":"      it('should remove event listeners', async () => {\n        Widget.attach(widget, document.body);\n        await framePromise();\n        Widget.detach(widget);\n        expect(widget.methods).toContain('onBeforeDetach');\n        widget.events = [];\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).not.toContain('mousedown');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should focus the node after an update","suites":["fileeditorcodewrapper","FileEditor","#onActivateRequest()"],"updatePoint":{"line":195,"column":47},"line":195,"code":"      it('should focus the node after an update', async () => {\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toContain('onActivateRequest');\n        await framePromise();\n        expect(widget.editor.hasFocus()).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should create an FileEditorFactory","suites":["fileeditorcodewrapper","FileEditorFactory","#constructor()"],"updatePoint":{"line":219,"column":44},"line":219,"code":"      it('should create an FileEditorFactory', () => {\n        expect(widgetFactory).toBeInstanceOf(FileEditorFactory);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should create a document widget","suites":["fileeditorcodewrapper","FileEditorFactory","#createNewWidget()"],"updatePoint":{"line":225,"column":41},"line":225,"code":"      it('should create a document widget', () => {\n        const d = widgetFactory.createNew(context);\n        expect(d).toBeInstanceOf(DocumentWidget);\n        expect(d.content).toBeInstanceOf(FileEditor);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/fileeditor/test"},{"name":"should create an ImageViewer","suites":["ImageViewer","#constructor()"],"updatePoint":{"line":89,"column":36},"line":89,"code":"    it('should create an ImageViewer', () => {\n      expect(widget).toBeInstanceOf(ImageViewer);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should keep the title in sync with the file name","suites":["ImageViewer","#constructor()"],"updatePoint":{"line":93,"column":56},"line":93,"code":"    it('should keep the title in sync with the file name', async () => {\n      const newPath = ((IMAGE as any).path = UUID.uuid4() + '.png');\n      expect(widget.title.label).toBe(context.path);\n      let called = false;\n      context.pathChanged.connect(() => {\n        expect(widget.title.label).toBe(newPath);\n        called = true;\n      });\n      await manager.contents.rename(context.path, newPath);\n      expect(called).toBe(true);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should set the content after the context is ready","suites":["ImageViewer","#constructor()"],"updatePoint":{"line":105,"column":57},"line":105,"code":"    it('should set the content after the context is ready', async () => {\n      await context.ready;\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      const img = widget.node.querySelector('img') as HTMLImageElement;\n      expect(img.src).toContain(IMAGE.content);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should handle a change to the content","suites":["ImageViewer","#constructor()"],"updatePoint":{"line":112,"column":45},"line":112,"code":"    it('should handle a change to the content', async () => {\n      await context.ready;\n      context.model.fromString(OTHER);\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      const img = widget.node.querySelector('img') as HTMLImageElement;\n      expect(img.src).toContain(OTHER);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should be the context associated with the widget","suites":["ImageViewer","#context"],"updatePoint":{"line":122,"column":56},"line":122,"code":"    it('should be the context associated with the widget', () => {\n      expect(widget.context).toBe(context);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should default to 1","suites":["ImageViewer","#scale"],"updatePoint":{"line":128,"column":27},"line":128,"code":"    it('should default to 1', () => {\n      expect(widget.scale).toBe(1);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should be settable","suites":["ImageViewer","#scale"],"updatePoint":{"line":132,"column":26},"line":132,"code":"    it('should be settable', () => {\n      widget.scale = 0.5;\n      expect(widget.scale).toBe(0.5);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should dispose of the resources used by the widget","suites":["ImageViewer","#dispose()"],"updatePoint":{"line":139,"column":58},"line":139,"code":"    it('should dispose of the resources used by the widget', () => {\n      expect(widget.isDisposed).toBe(false);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should render the image","suites":["ImageViewer","#onUpdateRequest()"],"updatePoint":{"line":149,"column":31},"line":149,"code":"    it('should render the image', async () => {\n      const img: HTMLImageElement = widget.node.querySelector('img')!;\n      await widget.ready;\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      expect(widget.methods).toContain('onUpdateRequest');\n      expect(img.src).toContain(IMAGE.content);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should focus the widget","suites":["ImageViewer","#onActivateRequest()"],"updatePoint":{"line":159,"column":31},"line":159,"code":"    it('should focus the widget', () => {\n      Widget.attach(widget, document.body);\n      MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n      expect(widget.methods).toContain('onActivateRequest');\n      expect(widget.node.contains(document.activeElement)).toBe(true);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should create an image document widget","suites":["ImageViewerFactory","#createNewWidget"],"updatePoint":{"line":170,"column":46},"line":170,"code":"    it('should create an image document widget', async () => {\n      const factory = new ImageViewerFactory({\n        name: 'Image',\n        modelName: 'base64',\n        fileTypes: ['png'],\n        defaultFor: ['png']\n      });\n      const context = await createFileContext(\n        IMAGE.path,\n        new Mock.ServiceManagerMock()\n      );\n      const d = factory.createNew(context);\n      expect(d).toBeInstanceOf(DocumentWidget);\n      expect(d.content).toBeInstanceOf(ImageViewer);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/imageviewer/test"},{"name":"should construct a new inspector widget","suites":["inspector/index","Inspector","#constructor()"],"updatePoint":{"line":39,"column":49},"line":39,"code":"      it('should construct a new inspector widget', () => {\n        const widget = new InspectorPanel();\n        expect(widget).toBeInstanceOf(InspectorPanel);\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should add the `jp-Inspector` class","suites":["inspector/index","Inspector","#constructor()"],"updatePoint":{"line":44,"column":45},"line":44,"code":"      it('should add the `jp-Inspector` class', () => {\n        const widget = new InspectorPanel();\n        expect(widget.hasClass('jp-Inspector')).toBe(true);\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should default to `null`","suites":["inspector/index","Inspector","#source"],"updatePoint":{"line":51,"column":34},"line":51,"code":"      it('should default to `null`', () => {\n        const widget = new InspectorPanel();\n        expect(widget.source).toBeNull();\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should be settable multiple times","suites":["inspector/index","Inspector","#source"],"updatePoint":{"line":56,"column":43},"line":56,"code":"      it('should be settable multiple times', () => {\n        const widget = new InspectorPanel();\n        const source = new TestInspectable();\n        expect(widget.source).toBeNull();\n        widget.source = source;\n        expect(widget.source).toBe(source);\n        widget.source = null;\n        expect(widget.source).toBeNull();\n        widget.source = new TestInspectable();\n        expect(widget.source).toBeInstanceOf(TestInspectable);\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should dispose of the resources used by the inspector","suites":["inspector/index","Inspector","#dispose()"],"updatePoint":{"line":70,"column":63},"line":70,"code":"      it('should dispose of the resources used by the inspector', () => {\n        const widget = new InspectorPanel();\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should be a no-op if called more than once","suites":["inspector/index","Inspector","#dispose()"],"updatePoint":{"line":77,"column":52},"line":77,"code":"      it('should be a no-op if called more than once', () => {\n        const widget = new InspectorPanel();\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should fire when a source updates","suites":["inspector/index","Inspector","#onInspectorUpdate()"],"updatePoint":{"line":87,"column":43},"line":87,"code":"      it('should fire when a source updates', () => {\n        const widget = new TestInspectorPanel();\n        widget.source = new TestInspectable();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onInspectorUpdate'])\n        );\n        (widget.source.inspected as any).emit({ content: new Widget() });\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onInspectorUpdate'])\n        );\n      });","file":"inspector.spec.ts","skipped":false,"dir":"packages/inspector/test"},{"name":"should create an LoggerOutputAreaModel","suites":["LoggerOutputAreaModel","#constructor()"],"updatePoint":{"line":38,"column":46},"line":38,"code":"    it('should create an LoggerOutputAreaModel', () => {\n      expect(model).toBeInstanceOf(LoggerOutputAreaModel);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should set the max length","suites":["LoggerOutputAreaModel","#constructor()"],"updatePoint":{"line":42,"column":33},"line":42,"code":"    it('should set the max length', async () => {\n      const model = new LoggerOutputAreaModel({ maxLength: 10 });\n      expect(model.maxLength).toEqual(10);\n      model.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should set the maximum number of messages in the first-in first-out queue","suites":["LoggerOutputAreaModel","#maxLength"],"updatePoint":{"line":50,"column":81},"line":50,"code":"    it('should set the maximum number of messages in the first-in first-out queue', () => {\n      for (let i = 0; i < 12; i++) {\n        model.add({\n          output_type: 'display_data',\n          data: { 'text/plain': i.toString() },\n          timestamp: Date.now(),\n          level: 'info'\n        });\n      }\n      expect(model.length).toEqual(10);\n      expect(model.get(0).data['text/plain']).toEqual('2');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"setting maxLength should immediately apply and trim the message list","suites":["LoggerOutputAreaModel","#maxLength"],"updatePoint":{"line":63,"column":76},"line":63,"code":"    it('setting maxLength should immediately apply and trim the message list', () => {\n      for (let i = 0; i < 12; i++) {\n        model.add({\n          output_type: 'display_data',\n          data: { 'text/plain': i.toString() },\n          timestamp: Date.now(),\n          level: 'info'\n        });\n      }\n      expect(model.maxLength).toEqual(10);\n      expect(model.length).toEqual(10);\n      model.maxLength = 5;\n      expect(model.maxLength).toEqual(5);\n      expect(model.length).toEqual(5);\n      expect(model.get(0).data['text/plain']).toEqual('7');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should create a Logger with initial properties","suites":["Logger","#constructor()"],"updatePoint":{"line":92,"column":54},"line":92,"code":"    it('should create a Logger with initial properties', () => {\n      expect(logger).toBeInstanceOf(Logger);\n      expect(logger.source).toEqual('test source');\n      expect(logger.maxLength).toEqual(10);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should set the maximum number of messages in the first-in first-out queue","suites":["Logger","#maxLength"],"updatePoint":{"line":100,"column":81},"line":100,"code":"    it('should set the maximum number of messages in the first-in first-out queue', () => {\n      for (let i = 0; i < 12; i++) {\n        logger.log({ type: 'text', data: i.toString(), level: 'critical' });\n      }\n      expect(logger.length).toEqual(10);\n      expect(logger.outputAreaModel.get(0).data['text/plain']).toEqual('2');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"setting maxLength should immediately apply and trim the message list","suites":["Logger","#maxLength"],"updatePoint":{"line":108,"column":76},"line":108,"code":"    it('setting maxLength should immediately apply and trim the message list', () => {\n      for (let i = 0; i < 12; i++) {\n        logger.log({ type: 'text', data: i.toString(), level: 'critical' });\n      }\n      const model = logger.outputAreaModel;\n      expect(logger.maxLength).toEqual(10);\n      expect(logger.length).toEqual(10);\n      logger.maxLength = 5;\n      expect(logger.maxLength).toEqual(5);\n      expect(logger.length).toEqual(5);\n      expect(model.get(0).data['text/plain']).toEqual('7');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should default to \"warning\"","suites":["Logger","#level"],"updatePoint":{"line":130,"column":35},"line":130,"code":"    it('should default to \"warning\"', () => {\n      expect(logger.level).toEqual('warning');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"filters for messages: %s","suites":["Logger","#level"],"line":134,"code":"    it.each(levels)('filters for messages: %s', (level: LogLevel) => {\n      logger.level = level;\n      const messages: ILogPayload[] = levels.map(level => ({\n        type: 'text',\n        data: level,\n        level\n      }));\n      messages.forEach(m => logger.log({ ...m }));\n      const logged: string[] = [];\n      for (let i = 0; i < logger.length; i++) {\n        const msg = logger.outputAreaModel.get(i);\n        logged.push(msg.level);\n      }\n      const shouldInclude = levels.slice(0, levels.indexOf(level) + 1);\n      const shouldExclude = levels.slice(levels.indexOf(level) + 1);\n      shouldInclude.forEach(x => {\n        expect(logged).toContain(x);\n      });\n      shouldExclude.forEach(x => {\n        expect(logged).not.toContain(x);\n      });\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs a \"metadata\" level text message if changed","suites":["Logger","#level"],"updatePoint":{"line":157,"column":55},"line":157,"code":"    it('logs a \"metadata\" level text message if changed', () => {\n      logger.level = 'info';\n      const msg = logger.outputAreaModel.get(0);\n      expect(msg.level).toBe('metadata');\n      expect(msg.data['text/plain']).toContain('info');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits a stateChanged signal when changing","suites":["Logger","#level"],"updatePoint":{"line":164,"column":49},"line":164,"code":"    it('emits a stateChanged signal when changing', () => {\n      const s = new SignalLogger(logger.stateChanged);\n      logger.level = 'info';\n      expect(s.args).toEqual([\n        {\n          name: 'level',\n          oldValue: 'warning',\n          newValue: 'info'\n        }\n      ]);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"setting to its current value has no effect","suites":["Logger","#level"],"updatePoint":{"line":177,"column":50},"line":177,"code":"    it('setting to its current value has no effect', () => {\n      const s = new SignalLogger(logger.stateChanged);\n      logger.level = logger.level; // eslint-disable-line\n      expect(s.args.length).toBe(0);\n      expect(logger.length).toBe(0);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"records how many messages are stored","suites":["Logger","#length"],"updatePoint":{"line":187,"column":44},"line":187,"code":"    it('records how many messages are stored', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.length).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"may be less than the messages logged if messages were combined","suites":["Logger","#length"],"updatePoint":{"line":195,"column":70},"line":195,"code":"    it('may be less than the messages logged if messages were combined', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"initially is null","suites":["Logger","#rendermime"],"updatePoint":{"line":211,"column":25},"line":211,"code":"    it('initially is null', () => {\n      expect(logger.rendermime).toBe(null);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"sets the rendermime attribute","suites":["Logger","#rendermime"],"updatePoint":{"line":215,"column":37},"line":215,"code":"    it('sets the rendermime attribute', () => {\n      const value = new RenderMimeRegistry();\n      logger.rendermime = value;\n      expect(logger.rendermime).toBe(value);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits a stateChanged signal when changed","suites":["Logger","#rendermime"],"updatePoint":{"line":221,"column":48},"line":221,"code":"    it('emits a stateChanged signal when changed', () => {\n      const oldValue = (logger.rendermime = new RenderMimeRegistry());\n      const newValue = oldValue.clone();\n      const s = new SignalLogger(logger.stateChanged);\n      logger.rendermime = newValue;\n      expect(s.args).toEqual([{ name: 'rendermime', oldValue, newValue }]);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"setting to current value has no effect","suites":["Logger","#rendermime"],"updatePoint":{"line":230,"column":46},"line":230,"code":"    it('setting to current value has no effect', () => {\n      logger.rendermime = new RenderMimeRegistry();\n      const s = new SignalLogger(logger.stateChanged);\n      logger.rendermime = logger.rendermime; // eslint-disable-line\n      expect(s.args).toEqual([]);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"starts at zero","suites":["Logger","#version"],"updatePoint":{"line":240,"column":22},"line":240,"code":"    it('starts at zero', () => {\n      expect(logger.version).toBe(0);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"increments every time a message is logged","suites":["Logger","#version"],"updatePoint":{"line":244,"column":49},"line":244,"code":"    it('increments every time a message is logged', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.version).toBe(2);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"increments even if messages are combined","suites":["Logger","#version"],"updatePoint":{"line":250,"column":48},"line":250,"code":"    it('increments even if messages are combined', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(logger.length).toBe(1);\n      expect(logger.version).toBe(2);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"does not increment on clearing messages","suites":["Logger","#version"],"updatePoint":{"line":265,"column":47},"line":265,"code":"    it('does not increment on clearing messages', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.version).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n      expect(logger.version).toBe(2);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs text messages","suites":["Logger","#log()"],"updatePoint":{"line":276,"column":26},"line":276,"code":"    it('logs text messages', () => {\n      logger.log({ type: 'text', data: 'message', level: 'warning' });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs html messages","suites":["Logger","#log()"],"updatePoint":{"line":281,"column":26},"line":281,"code":"    it('logs html messages', () => {\n      logger.log({ type: 'html', data: 'message', level: 'warning' });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs output stream messages","suites":["Logger","#log()"],"updatePoint":{"line":286,"column":35},"line":286,"code":"    it('logs output stream messages', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message' },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs display_data messages","suites":["Logger","#log()"],"updatePoint":{"line":295,"column":34},"line":295,"code":"    it('logs display_data messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'display_data',\n          data: { 'text/plain': 'message' }\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs execute_result messages","suites":["Logger","#log()"],"updatePoint":{"line":307,"column":36},"line":307,"code":"    it('logs execute_result messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'execute_result',\n          data: { 'text/plain': 'message', execution_count: 5 }\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"logs error messages","suites":["Logger","#log()"],"updatePoint":{"line":319,"column":27},"line":319,"code":"    it('logs error messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'error',\n          ename: 'Error',\n          evalue: 'Error',\n          traceback: ['level 1', 'level 2']\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits an \"append\" content changed signal","suites":["Logger","#log()"],"updatePoint":{"line":333,"column":48},"line":333,"code":"    it('emits an \"append\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits an \"append\" content changed signal and log outputs","suites":["Logger","#log()"],"updatePoint":{"line":340,"column":64},"line":340,"code":"    it('emits an \"append\" content changed signal and log outputs', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(s.args).toEqual(['append', 'append']);\n      expect(logger.length).toBe(1);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"adds a timestamp to the message","suites":["Logger","#log()"],"updatePoint":{"line":357,"column":39},"line":357,"code":"    it('adds a timestamp to the message', () => {\n      const before = Date.now();\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      const after = Date.now();\n      const msgTime = logger.outputAreaModel.get(0).timestamp.getTime();\n      expect(msgTime).toBeGreaterThanOrEqual(before);\n      expect(msgTime).toBeLessThanOrEqual(after);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"clears messages","suites":["Logger","#clear()"],"updatePoint":{"line":368,"column":23},"line":368,"code":"    it('clears messages', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.length).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits a \"clear\" content changed signal","suites":["Logger","#clear()"],"updatePoint":{"line":376,"column":46},"line":376,"code":"    it('emits a \"clear\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.clear();\n      expect(s.args).toEqual(['append', 'clear']);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"adds a metadata message to the message list","suites":["Logger","#checkpoint()"],"updatePoint":{"line":386,"column":51},"line":386,"code":"    it('adds a metadata message to the message list', () => {\n      logger.checkpoint();\n      expect(logger.outputAreaModel.get(0).level).toBe('metadata');\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits an \"append\" content changed signal","suites":["Logger","#checkpoint()"],"updatePoint":{"line":391,"column":48},"line":391,"code":"    it('emits an \"append\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.checkpoint();\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });","file":"logger.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should create a registry with initial parameters","suites":["LoggerRegistry","#constructor()"],"updatePoint":{"line":42,"column":56},"line":42,"code":"    it('should create a registry with initial parameters', () => {\n      expect(registry).toBeInstanceOf(LoggerRegistry);\n      expect(registry.maxLength).toBe(10);\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"gets a specific logger","suites":["LoggerRegistry","#getLogger()"],"updatePoint":{"line":49,"column":30},"line":49,"code":"    it('gets a specific logger', () => {\n      const A = registry.getLogger('A');\n      const B = registry.getLogger('B');\n      expect(registry.getLogger('A')).toEqual(A);\n      expect(registry.getLogger('B')).toEqual(B);\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"creates a new logger on demand if needed with default parameters","suites":["LoggerRegistry","#getLogger()"],"updatePoint":{"line":55,"column":72},"line":55,"code":"    it('creates a new logger on demand if needed with default parameters', () => {\n      const A = registry.getLogger('A');\n      expect(A.rendermime).toBe(defaultRendermime);\n      expect(A.maxLength).toBe(registry.maxLength);\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits a registry changed \"append\" signal","suites":["LoggerRegistry","#getLogger()"],"updatePoint":{"line":60,"column":48},"line":60,"code":"    it('emits a registry changed \"append\" signal', () => {\n      const s = new SignalLogger(registry.registryChanged);\n      registry.getLogger('A');\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"gets all current loggers","suites":["LoggerRegistry","#getLoggers"],"updatePoint":{"line":69,"column":32},"line":69,"code":"    it('gets all current loggers', () => {\n      const A = registry.getLogger('A');\n      expect(registry.getLoggers()).toEqual([A]);\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"overrides the max length for all loggers","suites":["LoggerRegistry","#maxLength"],"updatePoint":{"line":76,"column":48},"line":76,"code":"    it('overrides the max length for all loggers', () => {\n      const A = registry.getLogger('A');\n      const B = registry.getLogger('B');\n      A.maxLength = 5;\n      B.maxLength = 20;\n      expect(A.maxLength).toEqual(5);\n      expect(B.maxLength).toEqual(20);\n      registry.maxLength = 12;\n      expect(A.maxLength).toEqual(12);\n      expect(B.maxLength).toEqual(12);\n    });","file":"registry.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should create a console with initial parameters","suites":["LogConsolePanel","#constructor()"],"updatePoint":{"line":67,"column":55},"line":67,"code":"    it('should create a console with initial parameters', () => {\n      expect(logConsole).toBeInstanceOf(LogConsolePanel);\n      expect(logConsole.loggerRegistry).toBe(registry);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"returns the logger registry","suites":["LogConsolePanel","#loggerRegistry"],"updatePoint":{"line":74,"column":35},"line":74,"code":"    it('returns the logger registry', () => {\n      expect(logConsole.loggerRegistry).toBe(registry);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"sets the current source","suites":["LogConsolePanel","#source"],"updatePoint":{"line":80,"column":31},"line":80,"code":"    it('sets the current source', () => {\n      expect(logConsole.source).toBe(null);\n      registry.getLogger('A');\n      logConsole.source = 'A';\n      expect(logConsole.source).toBe('A');\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"displays output only from the current source","suites":["LogConsolePanel","#source"],"updatePoint":{"line":87,"column":52},"line":87,"code":"    it('displays output only from the current source', () => {\n      const loggerA = registry.getLogger('A');\n      const loggerB = registry.getLogger('B');\n      loggerA.log({\n        type: 'html',\n        data: '<div id=\"A\"></div>',\n        level: 'warning'\n      });\n      loggerB.log({\n        type: 'html',\n        data: '<div id=\"B\"></div>',\n        level: 'warning'\n      });\n      logConsole.source = 'A';\n      const nodeA = logConsole.node.querySelector('#A')!;\n      const nodeB = logConsole.node.querySelector('#B')!;\n      expect(nodeA).not.toBeNull();\n      expect(anyAncestor(nodeA, isHiddenLumino)).toBe(false);\n      expect(nodeB).not.toBeNull();\n      expect(anyAncestor(nodeB, isHiddenLumino)).toBe(true);\n\n      logConsole.source = 'B';\n      expect(anyAncestor(nodeA, isHiddenLumino)).toBe(true);\n      expect(anyAncestor(nodeB, isHiddenLumino)).toBe(false);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits a source changed signal if changed","suites":["LogConsolePanel","#source"],"updatePoint":{"line":113,"column":48},"line":113,"code":"    it('emits a source changed signal if changed', () => {\n      const s = new SignalLogger(logConsole.sourceChanged);\n      logConsole.source = 'A';\n      logConsole.source = null;\n      expect(s.args).toEqual([\n        { name: 'source', oldValue: null, newValue: 'A' },\n        { name: 'source', oldValue: 'A', newValue: null }\n      ]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"has no effect if not changed","suites":["LogConsolePanel","#source"],"updatePoint":{"line":124,"column":36},"line":124,"code":"    it('has no effect if not changed', () => {\n      const s = new SignalLogger(logConsole.sourceChanged);\n      logConsole.source = null;\n      expect(s.args).toEqual([]);\n\n      registry.getLogger('A');\n      logConsole.source = 'A';\n\n      s.clear();\n      logConsole.source = 'A';\n      expect(s.args).toEqual([]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"gives the version for the current source","suites":["LogConsolePanel","#sourceVersion"],"updatePoint":{"line":140,"column":48},"line":140,"code":"    it('gives the version for the current source', () => {\n      const A = registry.getLogger('A');\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      logConsole.source = 'A';\n      expect(logConsole.sourceVersion).toBe(A.version);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"is null if the source is null","suites":["LogConsolePanel","#sourceVersion"],"updatePoint":{"line":147,"column":37},"line":147,"code":"    it('is null if the source is null', () => {\n      expect(logConsole.source).toBe(null);\n      expect(logConsole.sourceVersion).toBe(null);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"gives the logger for the current source","suites":["LogConsolePanel","#logger"],"updatePoint":{"line":154,"column":47},"line":154,"code":"    it('gives the logger for the current source', () => {\n      const A = registry.getLogger('A');\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      logConsole.source = 'A';\n      expect(logConsole.logger).toBe(A);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"is null if the source is null","suites":["LogConsolePanel","#logger"],"updatePoint":{"line":161,"column":37},"line":161,"code":"    it('is null if the source is null', () => {\n      expect(logConsole.source).toBe(null);\n      expect(logConsole.logger).toBe(null);\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits when console is attached","suites":["LogConsolePanel","#sourceDisplayed"],"updatePoint":{"line":168,"column":38},"line":168,"code":"    it('emits when console is attached', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      logConsole.source = 'A';\n      expect(s.args).toEqual([]);\n\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits when console is shown","suites":["LogConsolePanel","#sourceDisplayed"],"updatePoint":{"line":180,"column":35},"line":180,"code":"    it('emits when console is shown', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      logConsole.source = 'A';\n      logConsole.hide();\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n      logConsole.show();\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits when source is selected","suites":["LogConsolePanel","#sourceDisplayed"],"updatePoint":{"line":193,"column":37},"line":193,"code":"    it('emits when source is selected', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      const loggerB = registry.getLogger('B');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      loggerB.log({ type: 'text', data: 'B1', level: 'warning' });\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n\n      logConsole.source = 'A';\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.clear();\n\n      loggerB.log({ type: 'text', data: 'B2', level: 'warning' });\n      expect(s.args).toEqual([]);\n      logConsole.source = 'B';\n      expect(s.args).toEqual([{ source: 'B', version: 2 }]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"emits when logging to displayed source","suites":["LogConsolePanel","#sourceDisplayed"],"updatePoint":{"line":213,"column":46},"line":213,"code":"    it('emits when logging to displayed source', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n\n      logConsole.source = 'A';\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.clear();\n\n      loggerA.log({ type: 'text', data: 'A2', level: 'warning' });\n      expect(s.args).toEqual([{ source: 'A', version: 2 }]);\n      s.dispose();\n    });","file":"widget.spec.ts","skipped":false,"dir":"packages/logconsole/test"},{"name":"should construct a new edit menu","suites":["@jupyterlab/mainmenu","EditMenu","#constructor()"],"updatePoint":{"line":25,"column":42},"line":25,"code":"      it('should construct a new edit menu', () => {\n        expect(menu).toBeInstanceOf(EditMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"edit.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new file menu","suites":["@jupyterlab/mainmenu","FileMenu","#constructor()"],"updatePoint":{"line":25,"column":42},"line":25,"code":"      it('should construct a new file menu', () => {\n        expect(menu).toBeInstanceOf(FileMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"file.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a submenu for `New...` commands","suites":["@jupyterlab/mainmenu","FileMenu","#newMenu"],"updatePoint":{"line":33,"column":51},"line":33,"code":"      it('should be a submenu for `New...` commands', () => {\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.newMenu.title.label).toBe('');\n      });","file":"file.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new help menu","suites":["@jupyterlab/mainmenu","HelpMenu","#constructor()"],"updatePoint":{"line":25,"column":42},"line":25,"code":"      it('should construct a new help menu', () => {\n        expect(menu).toBeInstanceOf(HelpMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"help.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new kernel menu","suites":["@jupyterlab/mainmenu","KernelMenu","#constructor()"],"updatePoint":{"line":25,"column":44},"line":25,"code":"      it('should construct a new kernel menu', () => {\n        expect(menu).toBeInstanceOf(KernelMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"kernel.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new main menu","suites":["@jupyterlab/mainmenu","MainMenu","#constructor()"],"updatePoint":{"line":37,"column":42},"line":37,"code":"      it('should construct a new main menu', () => {\n        const menu = new MainMenu(new CommandRegistry());\n        expect(menu).toBeInstanceOf(MainMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should add a new menu","suites":["@jupyterlab/mainmenu","MainMenu","#addMenu()"],"updatePoint":{"line":44,"column":31},"line":44,"code":"      it('should add a new menu', () => {\n        const menu = new Menu({ commands });\n        mainMenu.addMenu(menu);\n        expect(find(mainMenu.menus, m => menu === m) !== undefined).toBe(true);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should take a rank as an option","suites":["@jupyterlab/mainmenu","MainMenu","#addMenu()"],"updatePoint":{"line":50,"column":41},"line":50,"code":"      it('should take a rank as an option', () => {\n        const menu1 = new Menu({ commands });\n        const menu2 = new Menu({ commands });\n        mainMenu.addMenu(menu1, { rank: 300 });\n        mainMenu.addMenu(menu2, { rank: 200 });\n        expect(\n          ArrayExt.firstIndexOf(mainMenu.menus, menu1) >\n            ArrayExt.firstIndexOf(mainMenu.menus, menu2)\n        ).toBe(true);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a FileMenu","suites":["@jupyterlab/mainmenu","MainMenu","#fileMenu"],"updatePoint":{"line":63,"column":30},"line":63,"code":"      it('should be a FileMenu', () => {\n        expect(mainMenu.fileMenu).toBeInstanceOf(FileMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 1","suites":["@jupyterlab/mainmenu","MainMenu","#fileMenu"],"updatePoint":{"line":67,"column":33},"line":67,"code":"      it('has a default rank of 1', () => {\n        expect(mainMenu.fileMenu.rank).toEqual(1);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a EditMenu","suites":["@jupyterlab/mainmenu","MainMenu","#editMenu"],"updatePoint":{"line":73,"column":30},"line":73,"code":"      it('should be a EditMenu', () => {\n        expect(mainMenu.editMenu).toBeInstanceOf(EditMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 2","suites":["@jupyterlab/mainmenu","MainMenu","#editMenu"],"updatePoint":{"line":77,"column":33},"line":77,"code":"      it('has a default rank of 2', () => {\n        expect(mainMenu.editMenu.rank).toEqual(2);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a ViewMenu","suites":["@jupyterlab/mainmenu","MainMenu","#viewMenu"],"updatePoint":{"line":83,"column":30},"line":83,"code":"      it('should be a ViewMenu', () => {\n        expect(mainMenu.viewMenu).toBeInstanceOf(ViewMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 3","suites":["@jupyterlab/mainmenu","MainMenu","#viewMenu"],"updatePoint":{"line":87,"column":33},"line":87,"code":"      it('has a default rank of 3', () => {\n        expect(mainMenu.viewMenu.rank).toEqual(3);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a RunMenu","suites":["@jupyterlab/mainmenu","MainMenu","#runMenu"],"updatePoint":{"line":93,"column":29},"line":93,"code":"      it('should be a RunMenu', () => {\n        expect(mainMenu.runMenu).toBeInstanceOf(RunMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 4","suites":["@jupyterlab/mainmenu","MainMenu","#runMenu"],"updatePoint":{"line":97,"column":33},"line":97,"code":"      it('has a default rank of 4', () => {\n        expect(mainMenu.runMenu.rank).toEqual(4);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a KernelMenu","suites":["@jupyterlab/mainmenu","MainMenu","#kernelMenu"],"updatePoint":{"line":103,"column":32},"line":103,"code":"      it('should be a KernelMenu', () => {\n        expect(mainMenu.kernelMenu).toBeInstanceOf(KernelMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 5","suites":["@jupyterlab/mainmenu","MainMenu","#kernelMenu"],"updatePoint":{"line":107,"column":33},"line":107,"code":"      it('has a default rank of 5', () => {\n        expect(mainMenu.kernelMenu.rank).toEqual(5);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a TabsMenu","suites":["@jupyterlab/mainmenu","MainMenu","#tabsMenu"],"updatePoint":{"line":113,"column":30},"line":113,"code":"      it('should be a TabsMenu', () => {\n        expect(mainMenu.tabsMenu).toBeInstanceOf(TabsMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 500","suites":["@jupyterlab/mainmenu","MainMenu","#tabsMenu"],"updatePoint":{"line":117,"column":35},"line":117,"code":"      it('has a default rank of 500', () => {\n        expect(mainMenu.tabsMenu.rank).toEqual(500);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a SettingsMenu","suites":["@jupyterlab/mainmenu","MainMenu","#settingsMenu"],"updatePoint":{"line":123,"column":34},"line":123,"code":"      it('should be a SettingsMenu', () => {\n        expect(mainMenu.settingsMenu).toBeInstanceOf(SettingsMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 999","suites":["@jupyterlab/mainmenu","MainMenu","#settingsMenu"],"updatePoint":{"line":127,"column":35},"line":127,"code":"      it('has a default rank of 999', () => {\n        expect(mainMenu.settingsMenu.rank).toEqual(999);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should be a HelpMenu","suites":["@jupyterlab/mainmenu","MainMenu","#helpMenu"],"updatePoint":{"line":133,"column":30},"line":133,"code":"      it('should be a HelpMenu', () => {\n        expect(mainMenu.helpMenu).toBeInstanceOf(HelpMenu);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"has a default rank of 1000","suites":["@jupyterlab/mainmenu","MainMenu","#helpMenu"],"updatePoint":{"line":137,"column":36},"line":137,"code":"      it('has a default rank of 1000', () => {\n        expect(mainMenu.helpMenu.rank).toEqual(1000);\n      });","file":"mainmenu.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new run menu","suites":["@jupyterlab/mainmenu","RunMenu","#constructor()"],"updatePoint":{"line":25,"column":41},"line":25,"code":"      it('should construct a new run menu', () => {\n        expect(menu).toBeInstanceOf(RunMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"run.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should construct a new view menu","suites":["@jupyterlab/mainmenu","ViewMenu","#constructor()"],"updatePoint":{"line":25,"column":42},"line":25,"code":"      it('should construct a new view menu', () => {\n        expect(menu).toBeInstanceOf(ViewMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });","file":"view.spec.ts","skipped":false,"dir":"packages/mainmenu/test"},{"name":"should return true for a valid json object","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":10,"column":50},"line":10,"code":"    it('should return true for a valid json object', () => {\n      expect(VALIDATE('application/json', { foo: 1 })).toBe(true);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should return true for a valid json-like object","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":14,"column":55},"line":14,"code":"    it('should return true for a valid json-like object', () => {\n      expect(VALIDATE('application/foo+json', { foo: 1 })).toBe(true);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should return true for a valid string object","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":18,"column":52},"line":18,"code":"    it('should return true for a valid string object', () => {\n      expect(VALIDATE('text/plain', 'foo')).toBe(true);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should return true for a valid array of strings object","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":22,"column":62},"line":22,"code":"    it('should return true for a valid array of strings object', () => {\n      expect(VALIDATE('text/plain', ['foo', 'bar'])).toBe(true);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should return false for a json type with string data","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":26,"column":60},"line":26,"code":"    it('should return false for a json type with string data', () => {\n      expect(VALIDATE('application/foo+json', 'bar')).toBe(false);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should return false for a string type with json data","suites":["@jupyterlab/nbformat","validateMimeValue"],"updatePoint":{"line":30,"column":60},"line":30,"code":"    it('should return false for a string type with json data', () => {\n      expect(VALIDATE('foo/bar', { foo: 1 })).toBe(false);\n    });","file":"nbformat.spec.ts","skipped":false,"dir":"packages/nbformat/test"},{"name":"should emit when Markdown and code cells are run","suites":["@jupyterlab/notebook","NotebookActions","#executed"],"updatePoint":{"line":88,"column":58},"line":88,"code":"      it('should emit when Markdown and code cells are run', async () => {\n        const cell = widget.activeCell as CodeCell;\n        const next = widget.widgets[1] as MarkdownCell;\n        let emitted = 0;\n        let failed = 0;\n        widget.select(next);\n        cell.model.outputs.clear();\n        next.rendered = false;\n        NotebookActions.executed.connect((_, args) => {\n          const { success } = args;\n          emitted += 1;\n          if (!success) {\n            failed += 1;\n          }\n        });\n\n        await NotebookActions.run(widget, sessionContext);\n        expect(emitted).toBe(2);\n        expect(failed).toBe(0);\n        expect(next.rendered).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit an error for a cell execution failure.","suites":["@jupyterlab/notebook","NotebookActions","#executed"],"updatePoint":{"line":110,"column":60},"line":110,"code":"      it('should emit an error for a cell execution failure.', async () => {\n        let emitted = 0;\n        let failed = 0;\n        let cellError: KernelError | null | undefined = null;\n        NotebookActions.executed.connect((_, args) => {\n          const { success, error } = args;\n          emitted += 1;\n          if (!success) {\n            failed += 1;\n            cellError = error;\n          }\n        });\n\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        cell.value.text = ERROR_INPUT;\n        widget.model!.cells.push(cell);\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        expect(result).toBe(false);\n        expect(emitted).toBe(2);\n        expect(failed).toBe(1);\n        expect(cellError).toBeInstanceOf(KernelError);\n        expect(cellError!.errorName).toBe('NameError');\n        expect(cellError!.errorValue).toBe(\"name 'foo' is not defined\");\n        expect(cellError!.traceback).not.toBeNull();\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit only when code cell execution is scheduled","suites":["@jupyterlab/notebook","NotebookActions","#executionScheduled"],"updatePoint":{"line":140,"column":64},"line":140,"code":"      it('should emit only when code cell execution is scheduled', async () => {\n        const cell = widget.activeCell as CodeCell;\n        const next = widget.widgets[1] as MarkdownCell;\n        let emitted = 0;\n        widget.activeCell!.model.value.text = \"print('hello')\";\n        widget.select(next);\n        cell.model.outputs.clear();\n        next.rendered = false;\n        NotebookActions.executionScheduled.connect(() => {\n          emitted += 1;\n        });\n\n        await NotebookActions.run(widget, sessionContext);\n        expect(emitted).toBe(1);\n        expect(next.rendered).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should split the active cell into two cells","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":159,"column":53},"line":159,"code":"      it('should split the active cell into two cells', () => {\n        const cell = widget.activeCell!;\n        const source = 'thisisasamplestringwithnospaces';\n        cell.model.value.text = source;\n        const index = widget.activeCellIndex;\n        const editor = cell.editor;\n        editor.setCursorPosition(editor.getPositionAt(10)!);\n        NotebookActions.splitCell(widget);\n        const cells = widget.model!.cells;\n        const newSource =\n          cells.get(index).value.text + cells.get(index + 1).value.text;\n        expect(newSource).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve leading white space in the second cell","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":173,"column":64},"line":173,"code":"      it('should preserve leading white space in the second cell', () => {\n        const cell = widget.activeCell!;\n        const source = 'this\\n\\n   is a test';\n        cell.model.value.text = source;\n        const editor = cell.editor;\n        editor.setCursorPosition(editor.getPositionAt(4)!);\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell!.model.value.text).toBe('   is a test');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":183,"column":45},"line":183,"code":"      it('should clear the existing selection', () => {\n        each(widget.widgets, child => {\n          widget.select(child);\n        });\n        NotebookActions.splitCell(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the second cell","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":196,"column":41},"line":196,"code":"      it('should activate the second cell', () => {\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the types of each cell","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":201,"column":48},"line":201,"code":"      it('should preserve the types of each cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell).toBeInstanceOf(MarkdownCell);\n        const prev = widget.widgets[0];\n        expect(prev).toBeInstanceOf(MarkdownCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create two empty cells if there is no content","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":209,"column":62},"line":209,"code":"      it('should create two empty cells if there is no content', () => {\n        widget.activeCell!.model.value.text = '';\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell!.model.value.text).toBe('');\n        const prev = widget.widgets[0];\n        expect(prev.model.value.text).toBe('');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":217,"column":48},"line":217,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":223,"column":41},"line":223,"code":"      it('should preserve the widget mode', () => {\n        NotebookActions.splitCell(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.splitCell(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#splitCell({})"],"updatePoint":{"line":231,"column":29},"line":231,"code":"      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.value.text;\n        const count = widget.widgets.length;\n        NotebookActions.splitCell(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should merge the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":243,"column":41},"line":243,"code":"      it('should merge the selected cells', () => {\n        let source = widget.activeCell!.model.value.text + '\\n\\n';\n        let next = widget.widgets[1];\n        widget.select(next);\n        source += next.model.value.text + '\\n\\n';\n        next = widget.widgets[2];\n        widget.select(next);\n        source += next.model.value.text;\n        const count = widget.widgets.length;\n        NotebookActions.mergeCells(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n        expect(widget.activeCell!.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":257,"column":48},"line":257,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select the next cell if there is only one cell selected","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":263,"column":72},"line":263,"code":"      it('should select the next cell if there is only one cell selected', () => {\n        let source = widget.activeCell!.model.value.text + '\\n\\n';\n        const next = widget.widgets[1];\n        source += next.model.value.text;\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell!.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select the previous cell if there is only one cell selected and mergeAbove is true","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":271,"column":99},"line":271,"code":"      it('should select the previous cell if there is only one cell selected and mergeAbove is true', () => {\n        widget.activeCellIndex = 1;\n        let source = widget.activeCell!.model.value.text;\n        const previous = widget.widgets[0];\n        source = previous.model.value.text + '\\n\\n' + source;\n        NotebookActions.mergeCells(widget, true);\n        expect(widget.activeCell!.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should do nothing if first cell selected and mergeAbove is true","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":280,"column":73},"line":280,"code":"      it('should do nothing if first cell selected and mergeAbove is true', () => {\n        let source = widget.activeCell!.model.value.text;\n        const cellNumber = widget.widgets.length;\n        NotebookActions.mergeCells(widget, true);\n        expect(widget.widgets.length).toBe(cellNumber);\n        expect(widget.activeCell!.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the outputs of a code cell","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":288,"column":49},"line":288,"code":"      it('should clear the outputs of a code cell', () => {\n        NotebookActions.mergeCells(widget);\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":294,"column":41},"line":294,"code":"      it('should preserve the widget mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.mergeCells(widget);\n        expect(widget.mode).toBe('edit');\n        widget.mode = 'command';\n        NotebookActions.mergeCells(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":303,"column":29},"line":303,"code":"      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.value.text;\n        const count = widget.widgets.length;\n        NotebookActions.mergeCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should unrender a markdown cell","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":313,"column":41},"line":313,"code":"      it('should unrender a markdown cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        let cell = widget.activeCell as MarkdownCell;\n        cell.rendered = true;\n        NotebookActions.mergeCells(widget);\n        cell = widget.activeCell as MarkdownCell;\n        expect(cell.rendered).toBe(false);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the cell type of the active cell","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":323,"column":58},"line":323,"code":"      it('should preserve the cell type of the active cell', () => {\n        NotebookActions.changeCellType(widget, 'raw');\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell).toBeInstanceOf(RawCell);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should merge attachments if the last selected cell is a %s cell","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"line":330,"code":"      it.each(['raw', 'markdown'] as CellType[])(\n        'should merge attachments if the last selected cell is a %s cell',\n        type => {\n          for (let i = 0; i < 2; i++) {\n            NotebookActions.changeCellType(widget, type);\n            const markdownCell = widget.widgets[i] as MarkdownCell;\n            const attachment: IMimeBundle = { 'text/plain': 'test' };\n            markdownCell.model.attachments.set(UUID.uuid4(), attachment);\n            widget.select(markdownCell);\n          }\n          NotebookActions.mergeCells(widget);\n          const model = (widget.activeCell as MarkdownCell).model;\n          expect(model.attachments.length).toBe(2);\n        }\n      );","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should drop attachments if the last selected cell is a code cell","suites":["@jupyterlab/notebook","NotebookActions","#mergeCells"],"updatePoint":{"line":346,"column":74},"line":346,"code":"      it('should drop attachments if the last selected cell is a code cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        const markdownCell = widget.activeCell as MarkdownCell;\n        const attachment: IMimeBundle = { 'text/plain': 'test' };\n        markdownCell.model.attachments.set(UUID.uuid4(), attachment);\n\n        const codeCell = widget.widgets[1];\n        widget.select(codeCell);\n        NotebookActions.changeCellType(widget, 'code');\n        NotebookActions.deselectAll(widget);\n\n        widget.select(markdownCell);\n        widget.select(codeCell);\n\n        NotebookActions.mergeCells(widget);\n\n        const model = widget.activeCell!.model.toJSON();\n        expect(model.cell_type).toEqual('code');\n        expect(model.attachments).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should delete the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":369,"column":42},"line":369,"code":"      it('should delete the selected cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should increment deletedCells model when cells deleted","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":377,"column":64},"line":377,"code":"      it('should increment deletedCells model when cells deleted', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.model!.deletedCells.length;\n        NotebookActions.deleteCells(widget);\n        expect(widget.model!.deletedCells.length).toBe(count + 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":385,"column":48},"line":385,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should switch to command mode","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":391,"column":39},"line":391,"code":"      it('should switch to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.deleteCells(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the cell after the last selected cell","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":397,"column":63},"line":397,"code":"      it('should activate the cell after the last selected cell', () => {\n        widget.activeCellIndex = 4;\n        const prev = widget.widgets[2];\n        widget.select(prev);\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCellIndex).toBe(3);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select the previous cell if the last cell is deleted","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":405,"column":69},"line":405,"code":"      it('should select the previous cell if the last cell is deleted', () => {\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add a code cell if all cells are deleted","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":411,"column":57},"line":411,"code":"      it('should add a code cell if all cells are deleted', async () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.deleteCells(widget);\n        await sleep();\n        expect(widget.widgets.length).toBe(1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":421,"column":29},"line":421,"code":"      it('should be undo-able', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const source = widget.activeCell!.model.value.text;\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able if all the cells are deleted","suites":["@jupyterlab/notebook","NotebookActions","#deleteCells()"],"updatePoint":{"line":433,"column":58},"line":433,"code":"      it('should be undo-able if all the cells are deleted', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        const count = widget.widgets.length;\n        const source = widget.widgets[1].model.value.text;\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        expect(widget.widgets[1].model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should insert a code cell above the active cell","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":447,"column":57},"line":447,"code":"      it('should insert a code cell above the active cell', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":455,"column":48},"line":455,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should widget mode should be preserved","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":461,"column":48},"line":461,"code":"      it('should widget mode should be preserved', () => {\n        NotebookActions.insertAbove(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.insertAbove(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":469,"column":29},"line":469,"code":"      it('should be undo-able', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertAbove(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":476,"column":45},"line":476,"code":"      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.insertAbove(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the new active cell","suites":["@jupyterlab/notebook","NotebookActions","#insertAbove()"],"updatePoint":{"line":489,"column":39},"line":489,"code":"      it('should be the new active cell', () => {\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCell!.model.value.text).toBe('');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should insert a code cell below the active cell","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":496,"column":57},"line":496,"code":"      it('should insert a code cell below the active cell', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":504,"column":48},"line":504,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should widget mode should be preserved","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":510,"column":48},"line":510,"code":"      it('should widget mode should be preserved', () => {\n        NotebookActions.insertBelow(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.insertBelow(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":518,"column":29},"line":518,"code":"      it('should be undo-able', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertBelow(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":525,"column":45},"line":525,"code":"      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.insertBelow(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the new active cell","suites":["@jupyterlab/notebook","NotebookActions","#insertBelow()"],"updatePoint":{"line":538,"column":39},"line":538,"code":"      it('should be the new active cell', () => {\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCell!.model.value.text).toBe('');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change the selected cell type(s)","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":545,"column":49},"line":545,"code":"      it('should change the selected cell type(s)', () => {\n        let next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.changeCellType(widget, 'raw');\n        expect(widget.activeCell).toBeInstanceOf(RawCell);\n        next = widget.widgets[widget.activeCellIndex + 1];\n        expect(next).toBeInstanceOf(RawCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":554,"column":48},"line":554,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.changeCellType(widget, 'code');\n        expect(widget.activeCell).toBeUndefined();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":560,"column":41},"line":560,"code":"      it('should preserve the widget mode', () => {\n        NotebookActions.changeCellType(widget, 'code');\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.changeCellType(widget, 'raw');\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":568,"column":29},"line":568,"code":"      it('should be undo-able', () => {\n        NotebookActions.changeCellType(widget, 'raw');\n        NotebookActions.undo(widget);\n        const cell = widget.widgets[0];\n        expect(cell).toBeInstanceOf(CodeCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":575,"column":45},"line":575,"code":"      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.changeCellType(widget, 'raw');\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should unrender markdown cells","suites":["@jupyterlab/notebook","NotebookActions","#changeCellType()"],"updatePoint":{"line":588,"column":40},"line":588,"code":"      it('should unrender markdown cells', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        const cell = widget.activeCell as MarkdownCell;\n        expect(cell.rendered).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should run the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":596,"column":39},"line":596,"code":"      it('should run the selected cells', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should delete deletedCells metadata when cell run","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":613,"column":59},"line":613,"code":"      it('should delete deletedCells metadata when cell run', () => {\n        const cell = widget.activeCell as CodeCell;\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        cell.model.outputs.clear();\n        return NotebookActions.run(widget, sessionContext).then(result => {\n          expect(result).toBe(true);\n          expect(widget.model!.deletedCells.length).toBe(0);\n          expect(emitted).toBe(1);\n        });\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":627,"column":48},"line":627,"code":"      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(false);\n        expect(emitted).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the last selected cell","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":638,"column":48},"line":638,"code":"      it('should activate the last selected cell', async () => {\n        const other = widget.widgets[2];\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.select(other);\n        other.model.value.text = 'a = 1';\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.activeCell).toBe(other);\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the selection","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":652,"column":36},"line":652,"code":"      it('should clear the selection', async () => {\n        const next = widget.widgets[1];\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.select(next);\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":665,"column":39},"line":665,"code":"      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle no session","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":677,"column":34},"line":677,"code":"      it('should handle no session', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(widget, undefined);\n        expect(result).toBe(true);\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.executionCount).toBeNull();\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should stop executing code cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":689,"column":54},"line":689,"code":"      it('should stop executing code cells on an error', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        let cell = widget.model!.contentFactory.createCodeCell({});\n        cell.value.text = ERROR_INPUT;\n        widget.model!.cells.insert(2, cell);\n        widget.select(widget.widgets[2]);\n        cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.push(cell);\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        expect(result).toBe(false);\n        expect(cell.executionCount).toBeNull();\n        await ipySessionContext.session!.kernel!.restart();\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should render all markdown cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#run()"],"updatePoint":{"line":708,"column":54},"line":708,"code":"      it('should render all markdown cells on an error', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const cell = widget.model!.contentFactory.createMarkdownCell({});\n        widget.model!.cells.push(cell);\n        const child = widget.widgets[widget.widgets.length - 1] as MarkdownCell;\n        child.rendered = false;\n        widget.select(child);\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(100);\n        expect(result).toBe(false);\n        expect(child.rendered).toBe(true);\n        await ipySessionContext.session!.kernel!.restart();\n        expect(emitted).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should run the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":732,"column":39},"line":732,"code":"      it('should run the selected cells', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":747,"column":48},"line":747,"code":"      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":756,"column":45},"line":756,"code":"      it('should clear the existing selection', async () => {\n        const next = widget.widgets[3];\n        widget.select(next);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        expect(result).toBe(false);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":768,"column":39},"line":768,"code":"      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the cell after the last selected cell","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":778,"column":63},"line":778,"code":"      it('should activate the cell after the last selected cell', async () => {\n        const next = widget.widgets[3] as MarkdownCell;\n        widget.select(next);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.activeCellIndex).toBe(4);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new code cell in edit mode if necessary","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":789,"column":65},"line":789,"code":"      it('should create a new code cell in edit mode if necessary', async () => {\n        const count = widget.widgets.length;\n        widget.activeCellIndex = count - 1;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should allow an undo of the new cell","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":802,"column":46},"line":802,"code":"      it('should allow an undo of the new cell', async () => {\n        const count = widget.widgets.length;\n        widget.activeCellIndex = count - 1;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should stop executing code cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":814,"column":54},"line":814,"code":"      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.push(cell);\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        expect(result).toBe(false);\n        expect(cell.executionCount).toBeNull();\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should render all markdown cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAndAdvance()"],"updatePoint":{"line":828,"column":54},"line":828,"code":"      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        widget.select(cell);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(100);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should run the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":849,"column":39},"line":849,"code":"      it('should run the selected cells', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":864,"column":48},"line":864,"code":"      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":873,"column":45},"line":873,"code":"      it('should clear the existing selection', async () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should insert a new code cell in edit mode after the last selected cell","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":884,"column":81},"line":884,"code":"      it('should insert a new code cell in edit mode after the last selected cell', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        next.model.value.text = 'a = 1';\n        const count = widget.widgets.length;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n        expect(widget.mode).toBe('edit');\n        expect(widget.widgets.length).toBe(count + 1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should allow an undo of the cell insert","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":899,"column":49},"line":899,"code":"      it('should allow an undo of the cell insert', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        next.model.value.text = 'a = 1';\n        const count = widget.widgets.length;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should stop executing code cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":913,"column":54},"line":913,"code":"      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.push(cell);\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          ipySessionContext\n        );\n        expect(result).toBe(false);\n        expect(cell.executionCount).toBeNull();\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should render all markdown cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAndInsert()"],"updatePoint":{"line":927,"column":54},"line":927,"code":"      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        widget.select(cell);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          ipySessionContext\n        );\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(100);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should run all of the cells in the notebook","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":953,"column":53},"line":953,"code":"      it('should run all of the cells in the notebook', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":964,"column":48},"line":964,"code":"      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":970,"column":39},"line":970,"code":"      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the existing selection","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":977,"column":45},"line":977,"code":"      it('should clear the existing selection', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the last cell","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":985,"column":39},"line":985,"code":"      it('should activate the last cell', async () => {\n        await NotebookActions.runAll(widget, sessionContext);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should stop executing code cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":990,"column":54},"line":990,"code":"      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.push(cell);\n        const result = await NotebookActions.runAll(widget, ipySessionContext);\n        expect(result).toBe(false);\n        expect(cell.executionCount).toBeNull();\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should render all markdown cells on an error","suites":["@jupyterlab/notebook","NotebookActions","#runAll()"],"updatePoint":{"line":1001,"column":54},"line":1001,"code":"      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.value.text = ERROR_INPUT;\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        const result = await NotebookActions.runAll(widget, ipySessionContext);\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(100);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n        await ipySessionContext.session!.kernel!.restart();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select the cell above the active cell","suites":["@jupyterlab/notebook","NotebookActions","#selectAbove()"],"updatePoint":{"line":1017,"column":54},"line":1017,"code":"      it('should select the cell above the active cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#selectAbove()"],"updatePoint":{"line":1023,"column":48},"line":1023,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the bottom","suites":["@jupyterlab/notebook","NotebookActions","#selectAbove()"],"updatePoint":{"line":1029,"column":46},"line":1029,"code":"      it('should not wrap around to the bottom', () => {\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the mode","suites":["@jupyterlab/notebook","NotebookActions","#selectAbove()"],"updatePoint":{"line":1034,"column":34},"line":1034,"code":"      it('should preserve the mode', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.selectAbove(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.selectAbove(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should skip collapsed cells in edit mode","suites":["@jupyterlab/notebook","NotebookActions","#selectAbove()"],"updatePoint":{"line":1043,"column":50},"line":1043,"code":"      it('should skip collapsed cells in edit mode', () => {\n        widget.activeCellIndex = 3;\n        widget.mode = 'edit';\n        widget.widgets[1].inputHidden = true;\n        widget.widgets[2].inputHidden = true;\n        widget.widgets[3].inputHidden = false;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select the cell below the active cell","suites":["@jupyterlab/notebook","NotebookActions","#selectBelow()"],"updatePoint":{"line":1055,"column":54},"line":1055,"code":"      it('should select the cell below the active cell', () => {\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#selectBelow()"],"updatePoint":{"line":1060,"column":48},"line":1060,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the top","suites":["@jupyterlab/notebook","NotebookActions","#selectBelow()"],"updatePoint":{"line":1066,"column":43},"line":1066,"code":"      it('should not wrap around to the top', () => {\n        widget.activeCellIndex = widget.widgets.length - 1;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).not.toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the mode","suites":["@jupyterlab/notebook","NotebookActions","#selectBelow()"],"updatePoint":{"line":1072,"column":34},"line":1072,"code":"      it('should preserve the mode', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.selectBelow(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.selectBelow(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not change if in edit mode and no non-collapsed cells below","suites":["@jupyterlab/notebook","NotebookActions","#selectBelow()"],"updatePoint":{"line":1081,"column":76},"line":1081,"code":"      it('should not change if in edit mode and no non-collapsed cells below', () => {\n        widget.activeCellIndex = widget.widgets.length - 2;\n        widget.mode = 'edit';\n        widget.widgets[widget.widgets.length - 1].inputHidden = true;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should extend the selection to the cell above","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1091,"column":55},"line":1091,"code":"      it('should extend the selection to the cell above', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should extend the selection to the topmost cell","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1097,"column":57},"line":1097,"code":"      it('should extend the selection to the topmost cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget, true);\n        for (let i = widget.activeCellIndex; i >= 0; i--) {\n          expect(widget.isSelected(widget.widgets[i])).toBe(true);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1105,"column":48},"line":1105,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode if there is a selection","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1111,"column":63},"line":1111,"code":"      it('should change to command mode if there is a selection', () => {\n        widget.mode = 'edit';\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the bottom","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1118,"column":46},"line":1118,"code":"      it('should not wrap around to the bottom', () => {\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n        const last = widget.widgets[widget.widgets.length - 1];\n        expect(widget.isSelected(last)).toBe(false);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deselect the current cell if the cell above is selected","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1127,"column":72},"line":1127,"code":"      it('should deselect the current cell if the cell above is selected', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        NotebookActions.extendSelectionBelow(widget);\n        const cell = widget.activeCell!;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(cell)).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select only the first cell if we move from the second to first","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1135,"column":79},"line":1135,"code":"      it('should select only the first cell if we move from the second to first', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        const cell = widget.activeCell!;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(cell)).toBe(false);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the cell","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionAbove()"],"updatePoint":{"line":1143,"column":34},"line":1143,"code":"      it('should activate the cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should extend the selection to the cell below","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1151,"column":55},"line":1151,"code":"      it('should extend the selection to the cell below', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should extend the selection the bottom-most cell","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1157,"column":58},"line":1157,"code":"      it('should extend the selection the bottom-most cell', () => {\n        NotebookActions.extendSelectionBelow(widget, true);\n        for (let i = widget.activeCellIndex; i < widget.widgets.length; i++) {\n          expect(widget.isSelected(widget.widgets[i])).toBe(true);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1163,"column":48},"line":1163,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode if there is a selection","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1169,"column":63},"line":1169,"code":"      it('should change to command mode if there is a selection', () => {\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the top","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1175,"column":43},"line":1175,"code":"      it('should not wrap around to the top', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(last);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deselect the current cell if the cell below is selected","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1185,"column":72},"line":1185,"code":"      it('should deselect the current cell if the cell below is selected', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        NotebookActions.extendSelectionAbove(widget);\n        NotebookActions.extendSelectionAbove(widget);\n        const current = widget.activeCell!;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(current)).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select only the last cell if we move from the second last to last","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1195,"column":82},"line":1195,"code":"      it('should select only the last cell if we move from the second last to last', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        NotebookActions.extendSelectionAbove(widget);\n        const current = widget.activeCell!;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(current)).toBe(false);\n        expect(widget.activeCellIndex).toBe(last);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the cell","suites":["@jupyterlab/notebook","NotebookActions","#extendSelectionBelow()"],"updatePoint":{"line":1205,"column":34},"line":1205,"code":"      it('should activate the cell', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should move the selected cells up","suites":["@jupyterlab/notebook","NotebookActions","#moveUp()"],"updatePoint":{"line":1212,"column":43},"line":1212,"code":"      it('should move the selected cells up', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.extendSelectionAbove(widget);\n        NotebookActions.moveUp(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(false);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#moveUp()"],"updatePoint":{"line":1222,"column":48},"line":1222,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the bottom","suites":["@jupyterlab/notebook","NotebookActions","#moveUp()"],"updatePoint":{"line":1228,"column":46},"line":1228,"code":"      it('should not wrap around to the bottom', () => {\n        expect(widget.activeCellIndex).toBe(0);\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#moveUp()"],"updatePoint":{"line":1234,"column":29},"line":1234,"code":"      it('should be undo-able', () => {\n        widget.activeCellIndex++;\n        const source = widget.activeCell!.model.value.text;\n        NotebookActions.moveUp(widget);\n        expect(widget.model!.cells.get(0).value.text).toBe(source);\n        NotebookActions.undo(widget);\n        expect(widget.model!.cells.get(1).value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should move the selected cells down","suites":["@jupyterlab/notebook","NotebookActions","#moveDown()"],"updatePoint":{"line":1245,"column":45},"line":1245,"code":"      it('should move the selected cells down', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        NotebookActions.moveDown(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#moveDown()"],"updatePoint":{"line":1254,"column":48},"line":1254,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not wrap around to the top","suites":["@jupyterlab/notebook","NotebookActions","#moveDown()"],"updatePoint":{"line":1260,"column":43},"line":1260,"code":"      it('should not wrap around to the top', () => {\n        widget.activeCellIndex = widget.widgets.length - 1;\n        NotebookActions.moveDown(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#moveDown()"],"updatePoint":{"line":1266,"column":29},"line":1266,"code":"      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.value.text;\n        NotebookActions.moveDown(widget);\n        expect(widget.model!.cells.get(1).value.text).toBe(source);\n        NotebookActions.undo(widget);\n        expect(widget.model!.cells.get(0).value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should copy the selected cells to a utils.clipboard","suites":["@jupyterlab/notebook","NotebookActions","#copy()"],"updatePoint":{"line":1276,"column":61},"line":1276,"code":"      it('should copy the selected cells to a utils.clipboard', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.copy(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n        const data = utils.clipboard.getData(JUPYTER_CELL_MIME);\n        expect(data.length).toBe(2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#copy()"],"updatePoint":{"line":1285,"column":48},"line":1285,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.copy(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#copy()"],"updatePoint":{"line":1291,"column":39},"line":1291,"code":"      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.copy(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should delete metadata.deletable","suites":["@jupyterlab/notebook","NotebookActions","#copy()"],"updatePoint":{"line":1297,"column":42},"line":1297,"code":"      it('should delete metadata.deletable', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        next.model.metadata.set('deletable', false);\n        NotebookActions.copy(widget);\n        const data = utils.clipboard.getData(JUPYTER_CELL_MIME) as JSONArray;\n        data.map(cell => {\n          expect(\n            ((cell as JSONObject).metadata as JSONObject).deletable\n          ).toBeUndefined();\n        });\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should cut the selected cells to a utils.clipboard","suites":["@jupyterlab/notebook","NotebookActions","#cut()"],"updatePoint":{"line":1312,"column":60},"line":1312,"code":"      it('should cut the selected cells to a utils.clipboard', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#cut()"],"updatePoint":{"line":1320,"column":48},"line":1320,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.cut(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#cut()"],"updatePoint":{"line":1326,"column":39},"line":1326,"code":"      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.cut(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#cut()"],"updatePoint":{"line":1332,"column":29},"line":1332,"code":"      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.value.text;\n        NotebookActions.cut(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets[0].model.value.text).toBe(source);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add a new code cell if all cells were cut","suites":["@jupyterlab/notebook","NotebookActions","#cut()"],"updatePoint":{"line":1339,"column":58},"line":1339,"code":"      it('should add a new code cell if all cells were cut', async () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.cut(widget);\n        await sleep();\n        expect(widget.widgets.length).toBe(1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should paste cells from a utils.clipboard","suites":["@jupyterlab/notebook","NotebookActions","#paste()"],"updatePoint":{"line":1351,"column":51},"line":1351,"code":"      it('should paste cells from a utils.clipboard', () => {\n        const source = widget.activeCell!.model.value.text;\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        widget.activeCellIndex = 1;\n        NotebookActions.paste(widget);\n        expect(widget.widgets.length).toBe(count);\n        expect(widget.widgets[2].model.value.text).toBe(source);\n        expect(widget.activeCellIndex).toBe(3);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#paste()"],"updatePoint":{"line":1364,"column":48},"line":1364,"code":"      it('should be a no-op if there is no model', () => {\n        NotebookActions.copy(widget);\n        widget.model = null;\n        NotebookActions.paste(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no cell data on the utils.clipboard","suites":["@jupyterlab/notebook","NotebookActions","#paste()"],"updatePoint":{"line":1371,"column":75},"line":1371,"code":"      it('should be a no-op if there is no cell data on the utils.clipboard', () => {\n        const count = widget.widgets.length;\n        NotebookActions.paste(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode","suites":["@jupyterlab/notebook","NotebookActions","#paste()"],"updatePoint":{"line":1377,"column":39},"line":1377,"code":"      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.cut(widget);\n        NotebookActions.paste(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undo-able","suites":["@jupyterlab/notebook","NotebookActions","#paste()"],"updatePoint":{"line":1384,"column":29},"line":1384,"code":"      it('should be undo-able', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        widget.activeCellIndex = 1;\n        widget.model?.sharedModel.clearUndoHistory();\n        NotebookActions.paste(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should undo a cell action","suites":["@jupyterlab/notebook","NotebookActions","#undo()"],"updatePoint":{"line":1398,"column":35},"line":1398,"code":"      it('should undo a cell action', () => {\n        const count = widget.widgets.length;\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should switch the widget to command mode","suites":["@jupyterlab/notebook","NotebookActions","#undo()"],"updatePoint":{"line":1407,"column":50},"line":1407,"code":"      it('should switch the widget to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.undo(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#undo()"],"updatePoint":{"line":1413,"column":48},"line":1413,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.undo(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there are no cell actions to undo","suites":["@jupyterlab/notebook","NotebookActions","#undo()"],"updatePoint":{"line":1419,"column":64},"line":1419,"code":"      it('should be a no-op if there are no cell actions to undo', () => {\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        widget.model!.cells.clearUndo();\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count - 1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should redo a cell action","suites":["@jupyterlab/notebook","NotebookActions","#redo()"],"updatePoint":{"line":1429,"column":35},"line":1429,"code":"      it('should redo a cell action', () => {\n        const count = widget.widgets.length;\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        NotebookActions.redo(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should switch the widget to command mode","suites":["@jupyterlab/notebook","NotebookActions","#redo()"],"updatePoint":{"line":1439,"column":50},"line":1439,"code":"      it('should switch the widget to command mode', () => {\n        NotebookActions.undo(widget);\n        widget.mode = 'edit';\n        NotebookActions.redo(widget);\n        expect(widget.mode).toBe('command');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#redo()"],"updatePoint":{"line":1446,"column":48},"line":1446,"code":"      it('should be a no-op if there is no model', () => {\n        NotebookActions.undo(widget);\n        widget.model = null;\n        NotebookActions.redo(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there are no cell actions to redo","suites":["@jupyterlab/notebook","NotebookActions","#redo()"],"updatePoint":{"line":1453,"column":64},"line":1453,"code":"      it('should be a no-op if there are no cell actions to redo', () => {\n        const count = widget.widgets.length;\n        NotebookActions.redo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should toggle line numbers on all cells","suites":["@jupyterlab/notebook","NotebookActions","#toggleAllLineNumbers()"],"updatePoint":{"line":1461,"column":49},"line":1461,"code":"      it('should toggle line numbers on all cells', () => {\n        const state = widget.activeCell!.editor.getOption('lineNumbers');\n        NotebookActions.toggleAllLineNumbers(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const lineNumbers = widget.widgets[i].editor.getOption('lineNumbers');\n          expect(lineNumbers).toBe(!state);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be based on the state of the active cell","suites":["@jupyterlab/notebook","NotebookActions","#toggleAllLineNumbers()"],"updatePoint":{"line":1470,"column":57},"line":1470,"code":"      it('should be based on the state of the active cell', () => {\n        const state = widget.activeCell!.editor.getOption('lineNumbers');\n        for (let i = 1; i < widget.widgets.length; i++) {\n          widget.widgets[i].editor.setOption('lineNumbers', !state);\n        }\n        NotebookActions.toggleAllLineNumbers(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const lineNumbers = widget.widgets[i].editor.getOption('lineNumbers');\n          expect(lineNumbers).toBe(!state);\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#toggleAllLineNumbers()"],"updatePoint":{"line":1482,"column":41},"line":1482,"code":"      it('should preserve the widget mode', () => {\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#toggleAllLineNumbers()"],"updatePoint":{"line":1490,"column":48},"line":1490,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the outputs on the selected cells","suites":["@jupyterlab/notebook","NotebookActions","#clearOutputs()"],"updatePoint":{"line":1498,"column":56},"line":1498,"code":"      it('should clear the outputs on the selected cells', () => {\n        // Select the next code cell that has outputs.\n        let index = 0;\n        for (let i = 1; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          if (cell instanceof CodeCell && cell.model.outputs.length) {\n            widget.select(cell);\n            index = i;\n            break;\n          }\n        }\n        NotebookActions.clearOutputs(widget);\n        let cell = widget.widgets[0] as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n        cell = widget.widgets[index] as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#clearOutputs()"],"updatePoint":{"line":1516,"column":41},"line":1516,"code":"      it('should preserve the widget mode', () => {\n        NotebookActions.clearOutputs(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.clearOutputs(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#clearOutputs()"],"updatePoint":{"line":1524,"column":48},"line":1524,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.clearOutputs(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear the outputs on all cells","suites":["@jupyterlab/notebook","NotebookActions","#clearAllOutputs()"],"updatePoint":{"line":1532,"column":47},"line":1532,"code":"      it('should clear the outputs on all cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.clearAllOutputs(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          if (cell instanceof CodeCell) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(cell.model.outputs.length).toBe(0);\n          }\n        }\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve the widget mode","suites":["@jupyterlab/notebook","NotebookActions","#clearAllOutputs()"],"updatePoint":{"line":1545,"column":41},"line":1545,"code":"      it('should preserve the widget mode', () => {\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.mode).toBe('edit');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#clearAllOutputs()"],"updatePoint":{"line":1553,"column":48},"line":1553,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the markdown header level of selected cells","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1561,"column":64},"line":1561,"code":"      it('should set the markdown header level of selected cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell!.model.value.text.slice(0, 3)).toBe('## ');\n        expect(next.model.value.text.slice(0, 3)).toBe('## ');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should convert the cells to markdown type","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1569,"column":51},"line":1569,"code":"      it('should convert the cells to markdown type', () => {\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell).toBeInstanceOf(MarkdownCell);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be clamped between 1 and 6","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1574,"column":43},"line":1574,"code":"      it('should be clamped between 1 and 6', () => {\n        NotebookActions.setMarkdownHeader(widget, -1);\n        expect(widget.activeCell!.model.value.text.slice(0, 2)).toBe('# ');\n        NotebookActions.setMarkdownHeader(widget, 10);\n        expect(widget.activeCell!.model.value.text.slice(0, 7)).toBe('###### ');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if there is no model","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1581,"column":48},"line":1581,"code":"      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.setMarkdownHeader(widget, 1);\n        expect(widget.activeCellIndex).toBe(-1);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should replace an existing header","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1587,"column":43},"line":1587,"code":"      it('should replace an existing header', () => {\n        widget.activeCell!.model.value.text = '# foo';\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell!.model.value.text).toBe('## foo');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should replace leading white space","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1593,"column":44},"line":1593,"code":"      it('should replace leading white space', () => {\n        widget.activeCell!.model.value.text = '      foo';\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell!.model.value.text).toBe('## foo');\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should unrender the cells","suites":["@jupyterlab/notebook","NotebookActions","#setMarkdownHeader()"],"updatePoint":{"line":1599,"column":35},"line":1599,"code":"      it('should unrender the cells', () => {\n        NotebookActions.setMarkdownHeader(widget, 1);\n        expect((widget.activeCell as MarkdownCell).rendered).toBe(false);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should trust the notebook cells if the user accepts","suites":["@jupyterlab/notebook","NotebookActions","#trust()"],"updatePoint":{"line":1606,"column":61},"line":1606,"code":"      it('should trust the notebook cells if the user accepts', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = model.cells.get(0);\n        expect(cell.trusted).not.toBe(true);\n        const promise = NotebookActions.trust(widget);\n        await acceptDialog();\n        await promise;\n        expect(cell.trusted).toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not trust the notebook cells if the user aborts","suites":["@jupyterlab/notebook","NotebookActions","#trust()"],"updatePoint":{"line":1617,"column":64},"line":1617,"code":"      it('should not trust the notebook cells if the user aborts', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = model.cells.get(0);\n        expect(cell.trusted).not.toBe(true);\n        const promise = NotebookActions.trust(widget);\n        await dismissDialog();\n        await promise;\n        expect(cell.trusted).not.toBe(true);\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if the model is `null`","suites":["@jupyterlab/notebook","NotebookActions","#trust()"],"updatePoint":{"line":1628,"column":50},"line":1628,"code":"      it('should be a no-op if the model is `null`', async () => {\n        widget.model = null;\n        await expect(NotebookActions.trust(widget)).resolves.not.toThrow();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should show a dialog if all cells are trusted","suites":["@jupyterlab/notebook","NotebookActions","#trust()"],"updatePoint":{"line":1633,"column":55},"line":1633,"code":"      it('should show a dialog if all cells are trusted', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        for (let i = 0; i < model.cells.length; i++) {\n          const cell = model.cells.get(i);\n          cell.trusted = true;\n        }\n        const promise = NotebookActions.trust(widget);\n        await acceptDialog();\n        await expect(promise).resolves.not.toThrow();\n      });","file":"actions.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should save when clicked","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createSaveButton()"],"updatePoint":{"line":44,"column":36},"line":44,"code":"        it('should save when clicked', async () => {\n          const button = ToolbarItems.createSaveButton(panel);\n          Widget.attach(button, document.body);\n          const promise = signalToPromise(context.fileChanged);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await expect(promise).resolves.not.toThrow();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'save' icon","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createSaveButton()"],"updatePoint":{"line":54,"column":62},"line":54,"code":"        it(\"should add an inline svg node with the 'save' icon\", async () => {\n          const button = ToolbarItems.createSaveButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='save']\")\n          ).toBeDefined();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should insert below when clicked","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createInsertButton()"],"updatePoint":{"line":65,"column":44},"line":65,"code":"        it('should insert below when clicked', async () => {\n          const button = ToolbarItems.createInsertButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.activeCellIndex).toBe(1);\n          expect(panel.content.activeCell).toBeInstanceOf(CodeCell);\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'add' icon","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createInsertButton()"],"updatePoint":{"line":75,"column":61},"line":75,"code":"        it(\"should add an inline svg node with the 'add' icon\", async () => {\n          const button = ToolbarItems.createInsertButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='add']\")).toBeDefined();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should cut when clicked","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCutButton()"],"updatePoint":{"line":85,"column":35},"line":85,"code":"        it('should cut when clicked', async () => {\n          const button = ToolbarItems.createCutButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.widgets.length).toBe(count - 1);\n          expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'cut' icon","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCutButton()"],"updatePoint":{"line":96,"column":61},"line":96,"code":"        it(\"should add an inline svg node with the 'cut' icon\", async () => {\n          const button = ToolbarItems.createCutButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='cut']\")).toBeDefined();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should copy when clicked","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCopyButton()"],"updatePoint":{"line":106,"column":36},"line":106,"code":"        it('should copy when clicked', async () => {\n          const button = ToolbarItems.createCopyButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.widgets.length).toBe(count);\n          expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'copy' icon","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCopyButton()"],"updatePoint":{"line":117,"column":62},"line":117,"code":"        it(\"should add an inline svg node with the 'copy' icon\", async () => {\n          const button = ToolbarItems.createCopyButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='copy']\")\n          ).toBeDefined();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should paste when clicked","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createPasteButton()"],"updatePoint":{"line":129,"column":37},"line":129,"code":"        it('should paste when clicked', async () => {\n          const button = ToolbarItems.createPasteButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          NotebookActions.copy(panel.content);\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await sleep();\n          expect(panel.content.widgets.length).toBe(count + 1);\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'paste' icon","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createPasteButton()"],"updatePoint":{"line":141,"column":63},"line":141,"code":"        it(\"should add an inline svg node with the 'paste' icon\", async () => {\n          const button = ToolbarItems.createPasteButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='paste']\")\n          ).toBeDefined();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should track the cell type of the current cell","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCellTypeItem()"],"updatePoint":{"line":153,"column":58},"line":153,"code":"        it('should track the cell type of the current cell', async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          panel.content.activeCellIndex++;\n          await framePromise();\n          expect(node.value).toBe('markdown');\n          item.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should display `'-'` if multiple cell types are selected","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCellTypeItem()"],"updatePoint":{"line":167,"column":68},"line":167,"code":"        it(\"should display `'-'` if multiple cell types are selected\", async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          panel.content.select(panel.content.widgets[1]);\n          await framePromise();\n          expect(node.value).toBe('-');\n          item.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should display the active cell type if multiple cells of the same type are selected","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#createCellTypeItem()"],"updatePoint":{"line":181,"column":95},"line":181,"code":"        it('should display the active cell type if multiple cells of the same type are selected', async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          const cell = panel.model!.contentFactory.createCodeCell({});\n          panel.model!.cells.insert(1, cell);\n          panel.content.select(panel.content.widgets[1]);\n          await framePromise();\n          expect(node.value).toBe('code');\n          item.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should return the default items of the panel toolbar","suites":["@jupyterlab/notebook","ToolbarItems","noKernel","#getDefaultItems()"],"updatePoint":{"line":199,"column":64},"line":199,"code":"        it('should return the default items of the panel toolbar', () => {\n          const names = ToolbarItems.getDefaultItems(panel).map(item => {\n            const name = item.name;\n            item.widget.dispose();\n            return name;\n          });\n          expect(names).toEqual([\n            'save',\n            'insert',\n            'cut',\n            'copy',\n            'paste',\n            'run',\n            'interrupt',\n            'restart',\n            'restart-and-run',\n            'cellType',\n            'spacer',\n            'kernelName'\n          ]);\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should run and advance when clicked","suites":["@jupyterlab/notebook","ToolbarItems","kernelRequired","#createRunButton()"],"updatePoint":{"line":240,"column":47},"line":240,"code":"        it('should run and advance when clicked', async () => {\n          const button = ToolbarItems.createRunButton(panel);\n          const widget = panel.content;\n\n          // Clear and select the first two cells.\n          const codeCell = widget.widgets[0] as CodeCell;\n          codeCell.model.outputs.clear();\n          widget.select(codeCell);\n          const mdCell = widget.widgets[1] as MarkdownCell;\n          mdCell.rendered = false;\n          widget.select(mdCell);\n\n          Widget.attach(button, document.body);\n          await context.sessionContext.session!.kernel!.info;\n\n          const delegate = new PromiseDelegate();\n          panel.sessionContext.iopubMessage.connect((_, msg) => {\n            if (KernelMessage.isExecuteInputMsg(msg)) {\n              delegate.resolve(void 0);\n            }\n          });\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await expect(delegate.promise).resolves.not.toThrow();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'run' icon","suites":["@jupyterlab/notebook","ToolbarItems","kernelRequired","#createRunButton()"],"updatePoint":{"line":266,"column":61},"line":266,"code":"        it(\"should add an inline svg node with the 'run' icon\", async () => {\n          const button = ToolbarItems.createRunButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='run']\")).toBeDefined();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should restart and run all when clicked","suites":["@jupyterlab/notebook","ToolbarItems","kernelRequired","#createRestartRunAllButton()"],"updatePoint":{"line":275,"column":51},"line":275,"code":"        it('should restart and run all when clicked', async () => {\n          const button = ToolbarItems.createRestartRunAllButton(panel);\n          const widget = panel.content;\n\n          // Clear the first two cells.\n          const codeCell = widget.widgets[0] as CodeCell;\n          codeCell.model.outputs.clear();\n          const mdCell = widget.widgets[1] as MarkdownCell;\n          mdCell.rendered = false;\n\n          Widget.attach(button, document.body);\n          await panel.sessionContext.ready;\n          const delegate = new PromiseDelegate();\n          panel.sessionContext.iopubMessage.connect((_, msg) => {\n            if (KernelMessage.isExecuteInputMsg(msg)) {\n              delegate.resolve(void 0);\n            }\n          });\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await acceptDialog();\n          await expect(delegate.promise).resolves.not.toThrow();\n          button.dispose();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add an inline svg node with the 'fast-forward' icon","suites":["@jupyterlab/notebook","ToolbarItems","kernelRequired","#createRestartRunAllButton()"],"updatePoint":{"line":299,"column":70},"line":299,"code":"        it(\"should add an inline svg node with the 'fast-forward' icon\", async () => {\n          const button = ToolbarItems.createRestartRunAllButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='fast-forward']\")\n          ).toBeDefined();\n        });","file":"default-toolbar.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebook model","suites":["@jupyterlab/notebook","NotebookModel","#constructor()"],"updatePoint":{"line":15,"column":40},"line":15,"code":"      it('should create a notebook model', () => {\n        const model = new NotebookModel({});\n        expect(model).toBeInstanceOf(NotebookModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept an optional language preference","suites":["@jupyterlab/notebook","NotebookModel","#constructor()"],"updatePoint":{"line":20,"column":55},"line":20,"code":"      it('should accept an optional language preference', () => {\n        const model = new NotebookModel({ languagePreference: 'python' });\n        const lang = model.metadata.get(\n          'language_info'\n        ) as nbformat.ILanguageInfoMetadata;\n        expect(lang.name).toBe('python');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept an optional factory","suites":["@jupyterlab/notebook","NotebookModel","#constructor()"],"updatePoint":{"line":28,"column":43},"line":28,"code":"      it('should accept an optional factory', () => {\n        const contentFactory = new NotebookModel.ContentFactory({});\n        const model = new NotebookModel({ contentFactory });\n        expect(model.contentFactory.codeCellContentFactory).toBe(\n          contentFactory.codeCellContentFactory\n        );\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when a metadata field changes","suites":["@jupyterlab/notebook","NotebookModel","#metadataChanged"],"updatePoint":{"line":38,"column":57},"line":38,"code":"      it('should be emitted when a metadata field changes', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.metadata.changed.connect((sender, args) => {\n          expect(sender).toBe(model.metadata);\n          expect(args.key).toBe('foo');\n          expect(args.oldValue).toBeUndefined();\n          expect(args.newValue).toBe(1);\n          called = true;\n        });\n        model.metadata.set('foo', 1);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not be emitted when the value does not change","suites":["@jupyterlab/notebook","NotebookModel","#metadataChanged"],"updatePoint":{"line":52,"column":62},"line":52,"code":"      it('should not be emitted when the value does not change', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.metadata.set('foo', 1);\n        model.metadata.changed.connect(() => {\n          called = true;\n        });\n        model.metadata.set('foo', 1);\n        expect(called).toBe(false);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be reset when loading from disk","suites":["@jupyterlab/notebook","NotebookModel","#cells"],"updatePoint":{"line":65,"column":48},"line":65,"code":"      it('should be reset when loading from disk', () => {\n        const model = new NotebookModel();\n        const cell = model.contentFactory.createCodeCell({});\n        model.cells.push(cell);\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(ArrayExt.firstIndexOf(toArray(model.cells), cell)).toBe(-1);\n        expect(model.cells.length).toBe(7);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should allow undoing a change","suites":["@jupyterlab/notebook","NotebookModel","#cells"],"updatePoint":{"line":74,"column":39},"line":74,"code":"      it('should allow undoing a change', () => {\n        const model = new NotebookModel({\n          disableDocumentWideUndoRedo: true\n        });\n        const cell = model.contentFactory.createCodeCell({});\n        cell.value.text = 'foo';\n        const cellJSON = cell.toJSON();\n        model.cells.push(cell);\n        model.cells.clearUndo();\n        model.cells.remove(model.cells.length - 1);\n        model.cells.undo();\n        expect(model.cells.length).toBe(1);\n        expect(model.cells.get(0).value.text).toBe('foo');\n        // Previous model matches the restored model\n        expect(model.cells.get(0).toJSON()).toEqual(cellJSON);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit a `contentChanged` signal upon cell addition","suites":["@jupyterlab/notebook","NotebookModel","#cells","cells `changed` signal"],"updatePoint":{"line":92,"column":68},"line":92,"code":"        it('should emit a `contentChanged` signal upon cell addition', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.cells.push(cell);\n          expect(called).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit a `contentChanged` signal upon cell removal","suites":["@jupyterlab/notebook","NotebookModel","#cells","cells `changed` signal"],"updatePoint":{"line":103,"column":67},"line":103,"code":"        it('should emit a `contentChanged` signal upon cell removal', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          model.cells.push(cell);\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.cells.remove(0);\n          expect(called).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit a `contentChanged` signal upon cell move","suites":["@jupyterlab/notebook","NotebookModel","#cells","cells `changed` signal"],"updatePoint":{"line":115,"column":64},"line":115,"code":"        it('should emit a `contentChanged` signal upon cell move', () => {\n          const model = new NotebookModel();\n          const cell0 = model.contentFactory.createCodeCell({});\n          const cell1 = model.contentFactory.createCodeCell({});\n          model.cells.push(cell0);\n          model.cells.push(cell1);\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.cells.move(0, 1);\n          expect(called).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the dirty flag","suites":["@jupyterlab/notebook","NotebookModel","#cells","cells `changed` signal"],"updatePoint":{"line":129,"column":37},"line":129,"code":"        it('should set the dirty flag', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          model.cells.push(cell);\n          expect(model.dirty).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when a cell content changes","suites":["@jupyterlab/notebook","NotebookModel","#cells","cell `changed` signal"],"updatePoint":{"line":138,"column":56},"line":138,"code":"        it('should be called when a cell content changes', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          model.cells.push(cell);\n          expect(() => {\n            cell.value.text = 'foo';\n          }).not.toThrow();\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `contentChanged` signal","suites":["@jupyterlab/notebook","NotebookModel","#cells","cell `changed` signal"],"updatePoint":{"line":147,"column":51},"line":147,"code":"        it('should emit the `contentChanged` signal', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          model.cells.push(cell);\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.metadata.set('foo', 'bar');\n          expect(called).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the dirty flag","suites":["@jupyterlab/notebook","NotebookModel","#cells","cell `changed` signal"],"updatePoint":{"line":159,"column":37},"line":159,"code":"        it('should set the dirty flag', () => {\n          const model = new NotebookModel();\n          const cell = model.contentFactory.createCodeCell({});\n          model.cells.push(cell);\n          model.dirty = false;\n          cell.value.text = 'foo';\n          expect(model.dirty).toBe(true);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the cell model factory used by the model","suites":["@jupyterlab/notebook","NotebookModel","#contentFactory"],"updatePoint":{"line":171,"column":60},"line":171,"code":"      it('should be the cell model factory used by the model', () => {\n        const model = new NotebookModel();\n        expect(model.contentFactory.codeCellContentFactory).toBe(\n          NotebookModel.defaultContentFactory.codeCellContentFactory\n        );\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the major version number of the nbformat","suites":["@jupyterlab/notebook","NotebookModel","#nbformat"],"updatePoint":{"line":180,"column":61},"line":180,"code":"      it('should get the major version number of the nbformat', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.nbformat).toBe(utils.DEFAULT_CONTENT.nbformat);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should present a dialog when the format changes","suites":["@jupyterlab/notebook","NotebookModel","#nbformat"],"updatePoint":{"line":186,"column":57},"line":186,"code":"      it('should present a dialog when the format changes', () => {\n        const model = new NotebookModel();\n        const content = {\n          ...utils.DEFAULT_CONTENT,\n          metadata: {\n            ...utils.DEFAULT_CONTENT.metadata,\n            orig_nbformat: 1\n          }\n        };\n        model.fromJSON(content);\n        expect(model.nbformat).toBe(nbformat.MAJOR_VERSION);\n        return acceptDialog();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the minor version number of the nbformat","suites":["@jupyterlab/notebook","NotebookModel","#nbformatMinor"],"updatePoint":{"line":202,"column":61},"line":202,"code":"      it('should get the minor version number of the nbformat', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.nbformatMinor).toBe(nbformat.MINOR_VERSION);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the default kernel name of the document","suites":["@jupyterlab/notebook","NotebookModel","#defaultKernelName()"],"updatePoint":{"line":210,"column":60},"line":210,"code":"      it('should get the default kernel name of the document', () => {\n        const model = new NotebookModel();\n        model.metadata.set('kernelspec', { name: 'python3' });\n        expect(model.defaultKernelName).toBe('python3');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should default to an empty string","suites":["@jupyterlab/notebook","NotebookModel","#defaultKernelName()"],"updatePoint":{"line":216,"column":43},"line":216,"code":"      it('should default to an empty string', () => {\n        const model = new NotebookModel();\n        expect(model.defaultKernelName).toBe('');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the default kernel language of the document","suites":["@jupyterlab/notebook","NotebookModel","#defaultKernelLanguage"],"updatePoint":{"line":223,"column":64},"line":223,"code":"      it('should get the default kernel language of the document', () => {\n        const model = new NotebookModel();\n        model.metadata.set('language_info', { name: 'python' });\n        expect(model.defaultKernelLanguage).toBe('python');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should default to an empty string","suites":["@jupyterlab/notebook","NotebookModel","#defaultKernelLanguage"],"updatePoint":{"line":229,"column":43},"line":229,"code":"      it('should default to an empty string', () => {\n        const model = new NotebookModel();\n        expect(model.defaultKernelLanguage).toBe('');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be set from the constructor arg","suites":["@jupyterlab/notebook","NotebookModel","#defaultKernelLanguage"],"updatePoint":{"line":234,"column":48},"line":234,"code":"      it('should be set from the constructor arg', () => {\n        const model = new NotebookModel({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should dispose of the resources held by the model","suites":["@jupyterlab/notebook","NotebookModel","#dispose()"],"updatePoint":{"line":241,"column":59},"line":241,"code":"      it('should dispose of the resources held by the model', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        model.dispose();\n        expect(model.cells).toBeNull();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/notebook","NotebookModel","#dispose()"],"updatePoint":{"line":249,"column":47},"line":249,"code":"      it('should be safe to call multiple times', () => {\n        const model = new NotebookModel();\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize the model to a string","suites":["@jupyterlab/notebook","NotebookModel","#toString()"],"updatePoint":{"line":258,"column":48},"line":258,"code":"      it('should serialize the model to a string', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const text = model.toString();\n        const data = JSON.parse(text);\n        expect(data.cells.length).toBe(7);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deserialize the model from a string","suites":["@jupyterlab/notebook","NotebookModel","#fromString()"],"updatePoint":{"line":268,"column":52},"line":268,"code":"      it('should deserialize the model from a string', () => {\n        const model = new NotebookModel();\n        model.fromString(JSON.stringify(utils.DEFAULT_CONTENT));\n        expect(model.cells.length).toBe(7);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the dirty flag","suites":["@jupyterlab/notebook","NotebookModel","#fromString()"],"updatePoint":{"line":274,"column":35},"line":274,"code":"      it('should set the dirty flag', () => {\n        const model = new NotebookModel();\n        model.dirty = false;\n        model.fromString(JSON.stringify(utils.DEFAULT_CONTENT));\n        expect(model.dirty).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize the model to JSON","suites":["@jupyterlab/notebook","NotebookModel","#toJSON()"],"updatePoint":{"line":283,"column":44},"line":283,"code":"      it('should serialize the model to JSON', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const data = model.toJSON();\n        expect(data.cells.length).toBe(7);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize format 4.4 or earlier without cell ids","suites":["@jupyterlab/notebook","NotebookModel","#toJSON()"],"updatePoint":{"line":289,"column":65},"line":289,"code":"      it('should serialize format 4.4 or earlier without cell ids', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const data = model.toJSON();\n        expect(data.nbformat).toBe(4);\n        expect(data.nbformat_minor).toBeLessThanOrEqual(4);\n        expect(data.cells.length).toBe(7);\n        expect(data.cells[0].id).toBeUndefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize format 4.5 or later with cell ids","suites":["@jupyterlab/notebook","NotebookModel","#toJSON()"],"updatePoint":{"line":298,"column":60},"line":298,"code":"      it('should serialize format 4.5 or later with cell ids', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT_45);\n        const data = model.toJSON();\n        expect(data.cells.length).toBe(7);\n        expect(data.cells[0].id).toBe('cell_1');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize the model from format<=4.4 JSON","suites":["@jupyterlab/notebook","NotebookModel","#fromJSON()"],"updatePoint":{"line":308,"column":58},"line":308,"code":"      it('should serialize the model from format<=4.4 JSON', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.cells.length).toBe(7);\n        expect(model.nbformat).toBe(utils.DEFAULT_CONTENT.nbformat);\n        expect(model.nbformatMinor).toBe(nbformat.MINOR_VERSION);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should serialize the model from format 4.5 JSON","suites":["@jupyterlab/notebook","NotebookModel","#fromJSON()"],"updatePoint":{"line":316,"column":57},"line":316,"code":"      it('should serialize the model from format 4.5 JSON', () => {\n        const model = new NotebookModel();\n        const json = utils.DEFAULT_CONTENT_45;\n        model.fromJSON(json);\n        expect(model.cells.length).toBe(7);\n        expect(model.nbformat).toBe(json.nbformat);\n        expect(model.nbformatMinor).toBe(json.nbformat_minor);\n        expect(model.cells.get(0).id).toBe('cell_1');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the dirty flag","suites":["@jupyterlab/notebook","NotebookModel","#fromJSON()"],"updatePoint":{"line":326,"column":35},"line":326,"code":"      it('should set the dirty flag', () => {\n        const model = new NotebookModel();\n        model.dirty = false;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.dirty).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should have default values","suites":["@jupyterlab/notebook","NotebookModel","#metadata"],"updatePoint":{"line":335,"column":36},"line":335,"code":"      it('should have default values', () => {\n        const model = new NotebookModel();\n        const metadata = model.metadata;\n        expect(metadata.has('kernelspec')).toBeTruthy();\n        expect(metadata.has('language_info')).toBeTruthy();\n        expect(metadata.size).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the dirty flag when changed","suites":["@jupyterlab/notebook","NotebookModel","#metadata"],"updatePoint":{"line":343,"column":48},"line":343,"code":"      it('should set the dirty flag when changed', () => {\n        const model = new NotebookModel();\n        expect(model.dirty).toBe(false);\n        model.metadata.set('foo', 'bar');\n        expect(model.dirty).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `contentChanged` signal","suites":["@jupyterlab/notebook","NotebookModel","#metadata"],"updatePoint":{"line":350,"column":49},"line":350,"code":"      it('should emit the `contentChanged` signal', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        model.metadata.set('foo', 'bar');\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `metadataChanged` signal","suites":["@jupyterlab/notebook","NotebookModel","#metadata"],"updatePoint":{"line":360,"column":50},"line":360,"code":"      it('should emit the `metadataChanged` signal', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.metadata.changed.connect((sender, args) => {\n          expect(sender).toBe(model.metadata);\n          expect(args.key).toBe('foo');\n          expect(args.oldValue).toBeUndefined();\n          expect(args.newValue).toBe('bar');\n          called = true;\n        });\n        model.metadata.set('foo', 'bar');\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add one code cell if the model is empty","suites":["@jupyterlab/notebook","NotebookModel","#initialize()"],"updatePoint":{"line":376,"column":56},"line":376,"code":"      it('should add one code cell if the model is empty', () => {\n        const model = new NotebookModel();\n        expect(model.cells.length).toBe(0);\n        model.initialize();\n        expect(model.cells.length).toBe(1);\n        expect(model.cells.get(0).type).toBe('code');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clear undo state","suites":["@jupyterlab/notebook","NotebookModel","#initialize()"],"updatePoint":{"line":384,"column":33},"line":384,"code":"      it('should clear undo state', () => {\n        const model = new NotebookModel({\n          disableDocumentWideUndoRedo: true\n        });\n        const cell = model.contentFactory.createCodeCell({});\n        cell.value.text = 'foo';\n        model.cells.push(cell);\n        expect(model.cells.canUndo).toBe(true);\n        model.initialize();\n        expect(model.cells.canUndo).toBe(false);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a code cell content factory","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#codeCellContentFactory"],"updatePoint":{"line":401,"column":49},"line":401,"code":"        it('should be a code cell content factory', () => {\n          expect(factory.codeCellContentFactory).toBe(\n            CodeCellModel.defaultContentFactory\n          );\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be settable in the constructor","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#codeCellContentFactory"],"updatePoint":{"line":407,"column":49},"line":407,"code":"        it('should be settable in the constructor', () => {\n          const codeCellContentFactory = new CodeCellModel.ContentFactory();\n          factory = new NotebookModel.ContentFactory({\n            codeCellContentFactory\n          });\n          expect(factory.codeCellContentFactory).toBe(codeCellContentFactory);\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new code cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCell()"],"updatePoint":{"line":417,"column":41},"line":417,"code":"        it('should create a new code cell', () => {\n          const cell = factory.createCell('code', {});\n          expect(cell.type).toBe('code');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new markdown cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCell()"],"updatePoint":{"line":422,"column":45},"line":422,"code":"        it('should create a new markdown cell', () => {\n          const cell = factory.createCell('markdown', {});\n          expect(cell.type).toBe('markdown');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new raw cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCell()"],"updatePoint":{"line":427,"column":40},"line":427,"code":"        it('should create a new raw cell', () => {\n          const cell = factory.createCell('raw', {});\n          expect(cell.type).toBe('raw');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new code cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCodeCell()"],"updatePoint":{"line":434,"column":41},"line":434,"code":"        it('should create a new code cell', () => {\n          const cell = factory.createCodeCell({});\n          expect(cell.type).toBe('code');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing code cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCodeCell()"],"updatePoint":{"line":439,"column":46},"line":439,"code":"        it('should clone an existing code cell', () => {\n          const orig = factory.createCodeCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createCodeCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing raw cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createCodeCell()"],"updatePoint":{"line":447,"column":45},"line":447,"code":"        it('should clone an existing raw cell', () => {\n          const orig = factory.createRawCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createCodeCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new raw cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createRawCell()"],"updatePoint":{"line":457,"column":40},"line":457,"code":"        it('should create a new raw cell', () => {\n          const cell = factory.createRawCell({});\n          expect(cell.type).toBe('raw');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing raw cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createRawCell()"],"updatePoint":{"line":462,"column":45},"line":462,"code":"        it('should clone an existing raw cell', () => {\n          const orig = factory.createRawCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createRawCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing code cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createRawCell()"],"updatePoint":{"line":470,"column":46},"line":470,"code":"        it('should clone an existing code cell', () => {\n          const orig = factory.createCodeCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createRawCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new markdown cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createMarkdownCell()"],"updatePoint":{"line":480,"column":45},"line":480,"code":"        it('should create a new markdown cell', () => {\n          const cell = factory.createMarkdownCell({});\n          expect(cell.type).toBe('markdown');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing markdown cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createMarkdownCell()"],"updatePoint":{"line":485,"column":50},"line":485,"code":"        it('should clone an existing markdown cell', () => {\n          const orig = factory.createMarkdownCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createMarkdownCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone an existing raw cell","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#createMarkdownCell()"],"updatePoint":{"line":493,"column":45},"line":493,"code":"        it('should clone an existing raw cell', () => {\n          const orig = factory.createRawCell({});\n          orig.value.text = 'foo';\n          const cell = orig.toJSON();\n          const newCell = factory.createMarkdownCell({ cell });\n          expect(newCell.value.text).toBe('foo');\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be undefined by default","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#modelDB"],"updatePoint":{"line":503,"column":42},"line":503,"code":"        it('should be undefined by default', () => {\n          expect(factory.modelDB).toBeUndefined();\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new content factory with a new IModelDB","suites":["@jupyterlab/notebook","NotebookModel",".ContentFactory","#clone()"],"updatePoint":{"line":509,"column":67},"line":509,"code":"        it('should create a new content factory with a new IModelDB', () => {\n          const modelDB = new ModelDB();\n          const factory = new NotebookModel.ContentFactory({ modelDB });\n          expect(factory.modelDB).toBe(modelDB);\n          const newModelDB = new ModelDB();\n          const newFactory = factory.clone(newModelDB);\n          expect(newFactory.modelDB).toBe(newModelDB);\n          expect(newFactory.codeCellContentFactory).toBe(\n            factory.codeCellContentFactory\n          );\n        });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a ContentFactory","suites":["@jupyterlab/notebook","NotebookModel",".defaultContentFactory"],"updatePoint":{"line":524,"column":36},"line":524,"code":"      it('should be a ContentFactory', () => {\n        expect(NotebookModel.defaultContentFactory).toBeInstanceOf(\n          NotebookModel.ContentFactory\n        );\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new notebook model factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#constructor"],"updatePoint":{"line":10,"column":52},"line":10,"code":"      it('should create a new notebook model factory', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory).toBeInstanceOf(NotebookModelFactory);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept a code cell content factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#constructor"],"updatePoint":{"line":15,"column":51},"line":15,"code":"      it('should accept a code cell content factory', () => {\n        const codeCellContentFactory = new CodeCellModel.ContentFactory();\n        const factory = new NotebookModelFactory({ codeCellContentFactory });\n        expect(factory.contentFactory.codeCellContentFactory).toBe(\n          codeCellContentFactory\n        );\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept a notebook model content factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#constructor"],"updatePoint":{"line":23,"column":56},"line":23,"code":"      it('should accept a notebook model content factory', () => {\n        const contentFactory = new NotebookModel.ContentFactory({});\n        const factory = new NotebookModelFactory({ contentFactory });\n        expect(factory.contentFactory).toBe(contentFactory);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the content factory used by the model factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#contentFactory"],"updatePoint":{"line":31,"column":65},"line":31,"code":"      it('should be the content factory used by the model factory', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.contentFactory).toBeInstanceOf(\n          NotebookModel.ContentFactory\n        );\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the name of the model factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#name"],"updatePoint":{"line":40,"column":50},"line":40,"code":"      it('should get the name of the model factory', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.name).toBe('notebook');\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the file type","suites":["@jupyterlab/notebook","NotebookModelFactory","#contentType"],"updatePoint":{"line":47,"column":34},"line":47,"code":"      it('should get the file type', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.contentType).toBe('notebook');\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the file format","suites":["@jupyterlab/notebook","NotebookModelFactory","#fileFormat"],"updatePoint":{"line":54,"column":36},"line":54,"code":"      it('should get the file format', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.fileFormat).toBe('json');\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get whether the factory is disposed","suites":["@jupyterlab/notebook","NotebookModelFactory","#isDisposed"],"updatePoint":{"line":61,"column":52},"line":61,"code":"      it('should get whether the factory is disposed', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should dispose of the model factory","suites":["@jupyterlab/notebook","NotebookModelFactory","#dispose()"],"updatePoint":{"line":70,"column":45},"line":70,"code":"      it('should dispose of the model factory', () => {\n        const factory = new NotebookModelFactory({});\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/notebook","NotebookModelFactory","#dispose()"],"updatePoint":{"line":76,"column":47},"line":76,"code":"      it('should be safe to call multiple times', () => {\n        const factory = new NotebookModelFactory({});\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new model for a given path","suites":["@jupyterlab/notebook","NotebookModelFactory","#createNew()"],"updatePoint":{"line":85,"column":52},"line":85,"code":"      it('should create a new model for a given path', () => {\n        const factory = new NotebookModelFactory({});\n        const model = factory.createNew();\n        expect(model).toBeInstanceOf(NotebookModel);\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept a language preference","suites":["@jupyterlab/notebook","NotebookModelFactory","#createNew()"],"updatePoint":{"line":91,"column":45},"line":91,"code":"      it('should accept a language preference', () => {\n        const factory = new NotebookModelFactory({});\n        const model = factory.createNew('foo');\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should always return an empty string","suites":["@jupyterlab/notebook","NotebookModelFactory","#preferredLanguage()"],"updatePoint":{"line":99,"column":46},"line":99,"code":"      it('should always return an empty string', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.preferredLanguage('')).toBe('');\n        expect(factory.preferredLanguage('.ipynb')).toBe('');\n      });","file":"modelfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebooktools object","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#constructor()"],"updatePoint":{"line":145,"column":48},"line":145,"code":"        it('should create a notebooktools object', () => {\n          expect(notebookTools).toBeInstanceOf(NotebookTools);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the active notebook","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#activeNotebookPanel"],"updatePoint":{"line":151,"column":41},"line":151,"code":"        it('should be the active notebook', () => {\n          expect(notebookTools.activeNotebookPanel).toBe(panel1);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.activeNotebookPanel).toBe(panel0);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the active cell","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#activeCell"],"updatePoint":{"line":160,"column":37},"line":160,"code":"        it('should be the active cell', () => {\n          expect(notebookTools.activeCell).toBe(panel1.content.activeCell);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.activeCell).toBe(panel0.content.activeCell);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the currently selected cells","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#selectedCells"],"updatePoint":{"line":169,"column":50},"line":169,"code":"        it('should be the currently selected cells', () => {\n          expect(notebookTools.selectedCells).toEqual([\n            panel1.content.activeCell\n          ]);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.selectedCells).toEqual([\n            panel0.content.activeCell\n          ]);\n          panel0.content.select(panel0.content.widgets[1]);\n          expect(notebookTools.selectedCells.length).toBe(2);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add a cell tool item","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#addItem()"],"updatePoint":{"line":184,"column":39},"line":184,"code":"        it('should add a cell tool item', () => {\n          const tool = new NotebookTools.Tool();\n          expect(() => {\n            notebookTools.addItem({ tool });\n          }).not.toThrow();\n          tool.dispose();\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept a rank","suites":["@jupyterlab/notebook","notebooktools","NotebookTools","#addItem()"],"updatePoint":{"line":192,"column":32},"line":192,"code":"        it('should accept a rank', () => {\n          const tool = new NotebookTools.Tool();\n          expect(() => {\n            notebookTools.addItem({ tool, rank: 100 });\n          }).not.toThrow();\n          tool.dispose();\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new base tool","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#constructor"],"updatePoint":{"line":204,"column":41},"line":204,"code":"        it('should create a new base tool', () => {\n          const tool = new NotebookTools.Tool();\n          expect(tool).toBeInstanceOf(NotebookTools.Tool);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the notebooktools object used by the tool","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#parent"],"updatePoint":{"line":211,"column":63},"line":211,"code":"        it('should be the notebooktools object used by the tool', () => {\n          const tool = new NotebookTools.Tool({});\n          notebookTools.addItem({ tool });\n          expect(tool.notebookTools).toBe(notebookTools);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the active notebook panel changes","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#onActiveNotebookPanelChanged()"],"updatePoint":{"line":219,"column":67},"line":219,"code":"        it('should be called when the active notebook panel changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool });\n          tool.methods = [];\n          simulate(panel0.node, 'focus');\n          expect(tool.methods).toContain('onActiveNotebookPanelChanged');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the active cell changes","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#onActiveCellChanged()"],"updatePoint":{"line":229,"column":57},"line":229,"code":"        it('should be called when the active cell changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool });\n          tool.methods = [];\n          simulate(panel0.node, 'focus');\n          expect(tool.methods).toContain('onActiveCellChanged');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the selection changes","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#onSelectionChanged()"],"updatePoint":{"line":239,"column":55},"line":239,"code":"        it('should be called when the selection changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool });\n          tool.methods = [];\n          const current = tracker.currentWidget!;\n          current.content.select(current.content.widgets[1]);\n          expect(tool.methods).toContain('onSelectionChanged');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the active cell metadata changes","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#onActiveCellMetadataChanged()"],"updatePoint":{"line":250,"column":66},"line":250,"code":"        it('should be called when the active cell metadata changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool });\n          tool.methods = [];\n          const metadata = notebookTools.activeCell!.model.metadata;\n          metadata.set('foo', 1);\n          metadata.set('foo', 2);\n          expect(tool.methods).toContain('onActiveCellMetadataChanged');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the active notebook panel metadata changes","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.Tool","#onActiveNotebookPanelMetadataChanged()"],"updatePoint":{"line":262,"column":76},"line":262,"code":"        it('should be called when the active notebook panel metadata changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool });\n          tool.methods = [];\n          const metadata = notebookTools.activeNotebookPanel!.model!.metadata;\n          metadata.set('foo', 1);\n          metadata.set('foo', 2);\n          expect(tool.methods).toContain(\n            'onActiveNotebookPanelMetadataChanged'\n          );\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new active cell tool","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.ActiveCellTool"],"updatePoint":{"line":277,"column":46},"line":277,"code":"      it('should create a new active cell tool', () => {\n        const tool = new NotebookTools.ActiveCellTool();\n        notebookTools.addItem({ tool });\n        expect(tool).toBeInstanceOf(NotebookTools.ActiveCellTool);\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a change to the active cell","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.ActiveCellTool"],"updatePoint":{"line":283,"column":51},"line":283,"code":"      it('should handle a change to the active cell', () => {\n        const tool = new NotebookTools.ActiveCellTool();\n        notebookTools.addItem({ tool });\n        const widget = tracker.currentWidget!;\n        widget.content.activeCellIndex++;\n        widget.content.activeCell!.model.metadata.set('bar', 1);\n        expect(tool.node.querySelector('.jp-InputArea-editor')).toBeTruthy();\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new metadata editor tool","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.CellMetadataEditorTool"],"updatePoint":{"line":297,"column":50},"line":297,"code":"      it('should create a new metadata editor tool', () => {\n        const tool = new NotebookTools.CellMetadataEditorTool({\n          editorFactory\n        });\n        expect(tool).toBeInstanceOf(NotebookTools.CellMetadataEditorTool);\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a change to the active cell","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.CellMetadataEditorTool"],"updatePoint":{"line":304,"column":51},"line":304,"code":"      it('should handle a change to the active cell', () => {\n        const tool = new NotebookTools.CellMetadataEditorTool({\n          editorFactory\n        });\n        notebookTools.addItem({ tool });\n        const model = tool.editor.model;\n        expect(JSON.stringify(model.value.text)).toBeTruthy();\n        const widget = tracker.currentWidget!;\n        widget.content.activeCellIndex++;\n        widget.content.activeCell!.model.metadata.set('bar', 1);\n        expect(JSON.stringify(model.value.text)).toContain('bar');\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a change to the metadata","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.CellMetadataEditorTool"],"updatePoint":{"line":317,"column":48},"line":317,"code":"      it('should handle a change to the metadata', () => {\n        const tool = new NotebookTools.CellMetadataEditorTool({\n          editorFactory\n        });\n        notebookTools.addItem({ tool });\n        const model = tool.editor.model;\n        const previous = model.value.text;\n        const metadata = notebookTools.activeCell!.model.metadata;\n        metadata.set('foo', 1);\n        expect(model.value.text).not.toBe(previous);\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new metadata editor tool","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.NotebookMetadataEditorTool"],"updatePoint":{"line":334,"column":50},"line":334,"code":"      it('should create a new metadata editor tool', () => {\n        const tool = new NotebookTools.NotebookMetadataEditorTool({\n          editorFactory\n        });\n        expect(tool).toBeInstanceOf(NotebookTools.NotebookMetadataEditorTool);\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a change to the active notebook","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.NotebookMetadataEditorTool"],"updatePoint":{"line":341,"column":55},"line":341,"code":"      it('should handle a change to the active notebook', () => {\n        panel0.model!.metadata.set('panel0', 1);\n        panel1.model!.metadata.set('panel1', 1);\n        const tool = new NotebookTools.NotebookMetadataEditorTool({\n          editorFactory\n        });\n        notebookTools.addItem({ tool });\n        const model = tool.editor.model;\n        expect(JSON.stringify(model.value.text)).toBeTruthy();\n\n        simulate(panel0.node, 'focus');\n        expect(JSON.stringify(model.value.text)).toContain('panel0');\n        expect(JSON.stringify(model.value.text)).not.toContain('panel1');\n\n        simulate(panel1.node, 'focus');\n        expect(JSON.stringify(model.value.text)).not.toContain('panel0');\n        expect(JSON.stringify(model.value.text)).toContain('panel1');\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a change to the metadata","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.NotebookMetadataEditorTool"],"updatePoint":{"line":360,"column":48},"line":360,"code":"      it('should handle a change to the metadata', () => {\n        const tool = new NotebookTools.NotebookMetadataEditorTool({\n          editorFactory\n        });\n        notebookTools.addItem({ tool });\n        const model = tool.editor.model;\n        const widget = tracker.currentWidget!;\n        expect(JSON.stringify(model.value.text)).not.toContain('newvalue');\n        widget.content.model!.metadata.set('newvalue', 1);\n        expect(JSON.stringify(model.value.text)).toContain('newvalue');\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new key selector","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#constructor()"],"updatePoint":{"line":395,"column":44},"line":395,"code":"        it('should create a new key selector', () => {\n          expect(tool).toBeInstanceOf(NotebookTools.KeySelector);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the key used by the selector","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#key"],"updatePoint":{"line":401,"column":50},"line":401,"code":"        it('should be the key used by the selector', () => {\n          expect(tool.key).toBe('foo');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the select node","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#selectNode"],"updatePoint":{"line":407,"column":37},"line":407,"code":"        it('should be the select node', () => {\n          expect(tool.selectNode.localName).toBe('select');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the metadata","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#handleEvent()","change"],"updatePoint":{"line":414,"column":40},"line":414,"code":"          it('should update the metadata', () => {\n            const select = tool.selectNode;\n            simulate(select, 'focus');\n            select.selectedIndex = 1;\n            simulate(select, 'change');\n            expect(tool.events).toContain('change');\n            const metadata = notebookTools.activeCell!.model.metadata;\n            expect(metadata.get('foo')).toEqual([1, 2, 'a']);\n          });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add the focused class to the wrapper node","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#handleEvent()","focus"],"updatePoint":{"line":426,"column":62},"line":426,"code":"          it('should add the focused class to the wrapper node', () => {\n            const select = tool.selectNode;\n            simulate(select, 'focus');\n            const selector = '.jp-mod-focused';\n            expect(tool.node.querySelector(selector)).toBeTruthy();\n          });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should remove the focused class from the wrapper node","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#handleEvent()","blur"],"updatePoint":{"line":435,"column":67},"line":435,"code":"          it('should remove the focused class from the wrapper node', () => {\n            const select = tool.selectNode;\n            simulate(select, 'focus');\n            simulate(select, 'blur');\n            const selector = '.jp-mod-focused';\n            expect(tool.node.querySelector(selector)).toBeFalsy();\n          });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add event listeners","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#onAfterAttach()"],"updatePoint":{"line":446,"column":38},"line":446,"code":"        it('should add event listeners', () => {\n          const select = tool.selectNode;\n          expect(tool.methods).toContain('onAfterAttach');\n          simulate(select, 'focus');\n          simulate(select, 'blur');\n          select.selectedIndex = 0;\n          simulate(select, 'change');\n          expect(tool.events).toEqual(['change']);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should remove event listeners","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#onBeforeDetach()"],"updatePoint":{"line":458,"column":41},"line":458,"code":"        it('should remove event listeners', () => {\n          const select = tool.selectNode;\n          notebookTools.dispose();\n          expect(tool.methods).toContain('onBeforeDetach');\n          simulate(select, 'focus');\n          simulate(select, 'blur');\n          simulate(select, 'change');\n          expect(tool.events).toEqual([]);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the metadata","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#onValueChanged()"],"updatePoint":{"line":470,"column":38},"line":470,"code":"        it('should update the metadata', () => {\n          const select = tool.selectNode;\n          simulate(select, 'focus');\n          select.selectedIndex = 1;\n          simulate(select, 'change');\n          expect(tool.methods).toContain('onValueChanged');\n          const metadata = notebookTools.activeCell!.model.metadata;\n          expect(metadata.get('foo')).toEqual([1, 2, 'a']);\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the select value","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#onActiveCellChanged()"],"updatePoint":{"line":482,"column":42},"line":482,"code":"        it('should update the select value', () => {\n          const cell = panel0.content.model!.cells.get(1);\n          cell.metadata.set('foo', 1);\n          panel0.content.activeCellIndex = 1;\n          expect(tool.methods).toContain('onActiveCellChanged');\n          expect(tool.selectNode.value).toBe('1');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the select value","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.KeySelector","#onActiveCellMetadataChanged()"],"updatePoint":{"line":492,"column":42},"line":492,"code":"        it('should update the select value', () => {\n          const metadata = notebookTools.activeCell!.model.metadata;\n          metadata.set('foo', 1);\n          expect(tool.methods).toContain('onActiveCellMetadataChanged');\n          expect(tool.selectNode.value).toBe('1');\n        });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a slide show selector","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.createSlideShowSelector()"],"updatePoint":{"line":502,"column":45},"line":502,"code":"      it('should create a slide show selector', () => {\n        const tool = NotebookTools.createSlideShowSelector();\n        tool.selectNode.selectedIndex = -1;\n        notebookTools.addItem({ tool });\n        simulate(panel0.node, 'focus');\n        tabpanel.currentIndex = 2;\n        expect(tool).toBeInstanceOf(NotebookTools.KeySelector);\n        expect(tool.key).toBe('slideshow');\n        const select = tool.selectNode;\n        expect(select.value).toBe('');\n        const metadata = notebookTools.activeCell!.model.metadata;\n        expect(metadata.get('slideshow')).toBeUndefined();\n        simulate(select, 'focus');\n        tool.selectNode.selectedIndex = 1;\n        simulate(select, 'change');\n        expect(metadata.get('slideshow')).toEqual({\n          slide_type: 'slide'\n        });\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a raw mimetype selector","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.createNBConvertSelector()"],"updatePoint":{"line":524,"column":47},"line":524,"code":"      it('should create a raw mimetype selector', () => {\n        const optionValueArray: any = [\n          [null, '-'],\n          ['LaTeX', 'text/latex'],\n          ['reST', 'text/restructuredtext'],\n          ['HTML', 'text/html'],\n          ['Markdown', 'text/markdown'],\n          ['Python', 'text/x-python']\n        ];\n        optionValueArray.push(['None', '-']);\n        const tool = NotebookTools.createNBConvertSelector(optionValueArray);\n        tool.selectNode.selectedIndex = -1;\n        notebookTools.addItem({ tool });\n        simulate(panel0.node, 'focus');\n        NotebookActions.changeCellType(panel0.content, 'raw');\n        tabpanel.currentIndex = 2;\n        expect(tool).toBeInstanceOf(NotebookTools.KeySelector);\n        expect(tool.key).toBe('raw_mimetype');\n        const select = tool.selectNode;\n        expect(select.value).toBe('');\n\n        const metadata = notebookTools.activeCell!.model.metadata;\n        expect(metadata.get('raw_mimetype')).toBeUndefined();\n        simulate(select, 'focus');\n        tool.selectNode.selectedIndex = 2;\n        simulate(select, 'change');\n        expect(metadata.get('raw_mimetype')).toBe('text/restructuredtext');\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should have no effect on a code cell","suites":["@jupyterlab/notebook","notebooktools","NotebookTools.createNBConvertSelector()"],"updatePoint":{"line":553,"column":46},"line":553,"code":"      it('should have no effect on a code cell', () => {\n        const optionValueArray: any = [\n          ['None', '-'],\n          ['LaTeX', 'text/latex'],\n          ['reST', 'text/restructuredtext'],\n          ['HTML', 'text/html'],\n          ['Markdown', 'text/markdown'],\n          ['Python', 'text/x-python']\n        ];\n        const tool = NotebookTools.createNBConvertSelector(optionValueArray);\n        tool.selectNode.selectedIndex = -1;\n        notebookTools.addItem({ tool });\n        simulate(panel0.node, 'focus');\n        NotebookActions.changeCellType(panel0.content, 'code');\n\n        tabpanel.currentIndex = 2;\n        expect(tool).toBeInstanceOf(NotebookTools.KeySelector);\n        expect(tool.key).toBe('raw_mimetype');\n        const select = tool.selectNode;\n        expect(select.disabled).toBe(true);\n        expect(select.value).toBe('');\n      });","file":"notebooktools.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebook panel","suites":["@jupyterlab/notebook","NotebookPanel","#constructor()"],"updatePoint":{"line":40,"column":40},"line":40,"code":"      it('should create a notebook panel', () => {\n        const content = utils.createNotebook();\n        const panel = new NotebookPanel({ context, content });\n        expect(panel).toBeInstanceOf(NotebookPanel);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change notebook to edit mode if we have a single empty code cell","suites":["@jupyterlab/notebook","NotebookPanel","#constructor()"],"updatePoint":{"line":46,"column":81},"line":46,"code":"      it('should change notebook to edit mode if we have a single empty code cell', async () => {\n        const panel = utils.createNotebookPanel(context);\n        const model = panel.content.model;\n        expect(model).toBe(context.model);\n        await context.initialize(true);\n        await context.ready;\n        expect(panel.content.mode).toBe('edit');\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the toolbar used by the widget","suites":["@jupyterlab/notebook","NotebookPanel","#toolbar"],"updatePoint":{"line":57,"column":50},"line":57,"code":"      it('should be the toolbar used by the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.toolbar).toBeInstanceOf(Toolbar);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the notebook content widget","suites":["@jupyterlab/notebook","NotebookPanel","#content"],"updatePoint":{"line":64,"column":47},"line":64,"code":"      it('should be the notebook content widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.content).toBeInstanceOf(Notebook);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the document context for the widget","suites":["@jupyterlab/notebook","NotebookPanel","#context"],"updatePoint":{"line":71,"column":56},"line":71,"code":"      it('should get the document context for the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.context).toBe(context);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should dispose of the resources used by the widget","suites":["@jupyterlab/notebook","NotebookPanel","#dispose()"],"updatePoint":{"line":78,"column":60},"line":78,"code":"      it('should dispose of the resources used by the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be safe to call more than once","suites":["@jupyterlab/notebook","NotebookPanel","#dispose()"],"updatePoint":{"line":84,"column":47},"line":84,"code":"      it('should be safe to call more than once', () => {\n        const panel = utils.createNotebookPanel(context);\n        panel.dispose();\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new ContentFactory","suites":["@jupyterlab/notebook","NotebookPanel",".ContentFactory","#constructor"],"updatePoint":{"line":94,"column":46},"line":94,"code":"        it('should create a new ContentFactory', () => {\n          const factory = new NotebookPanel.ContentFactory({\n            editorFactory: utils.editorFactory\n          });\n          expect(factory).toBeInstanceOf(NotebookPanel.ContentFactory);\n        });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebook widget","suites":["@jupyterlab/notebook","NotebookPanel",".ContentFactory","#NBTestUtils.createNotebook()"],"updatePoint":{"line":103,"column":43},"line":103,"code":"        it('should create a notebook widget', () => {\n          const options = {\n            contentFactory: contentFactory,\n            rendermime: utils.defaultRenderMime(),\n            mimeTypeService: utils.mimeTypeService\n          };\n          expect(contentFactory.createNotebook(options)).toBeInstanceOf(\n            Notebook\n          );\n        });","file":"panel.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a NotebookTracker","suites":["@jupyterlab/notebook","NotebookTracker","#constructor()"],"updatePoint":{"line":46,"column":41},"line":46,"code":"      it('should create a NotebookTracker', () => {\n        const tracker = new NotebookTracker({ namespace });\n        expect(tracker).toBeInstanceOf(NotebookTracker);\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be `null` if there is no tracked notebook panel","suites":["@jupyterlab/notebook","NotebookTracker","#activeCell"],"updatePoint":{"line":53,"column":64},"line":53,"code":"      it('should be `null` if there is no tracked notebook panel', () => {\n        const tracker = new NotebookTracker({ namespace });\n        expect(tracker.activeCell).toBeNull();\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be `null` if a tracked notebook has no active cell","suites":["@jupyterlab/notebook","NotebookTracker","#activeCell"],"updatePoint":{"line":58,"column":67},"line":58,"code":"      it('should be `null` if a tracked notebook has no active cell', () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        panel.content.model!.cells.clear();\n        void tracker.add(panel);\n        expect(tracker.activeCell).toBeNull();\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the active cell if a tracked notebook has one","suites":["@jupyterlab/notebook","NotebookTracker","#activeCell"],"updatePoint":{"line":66,"column":65},"line":66,"code":"      it('should be the active cell if a tracked notebook has one', async () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        await tracker.add(panel);\n        panel.content.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(tracker.activeCell).toBeInstanceOf(Cell);\n        panel.dispose();\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit a signal when the active cell changes","suites":["@jupyterlab/notebook","NotebookTracker","#activeCellChanged"],"updatePoint":{"line":77,"column":59},"line":77,"code":"      it('should emit a signal when the active cell changes', async () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        let count = 0;\n        tracker.activeCellChanged.connect(() => {\n          count++;\n        });\n        panel.content.model!.fromJSON(utils.DEFAULT_CONTENT);\n        await tracker.add(panel);\n        expect(count).toBe(1);\n        panel.content.activeCellIndex = 1;\n        expect(count).toBe(2);\n        panel.dispose();\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the active cell changes","suites":["@jupyterlab/notebook","NotebookTracker","#onCurrentChanged()"],"updatePoint":{"line":94,"column":55},"line":94,"code":"      it('should be called when the active cell changes', async () => {\n        const tracker = new TestTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        await tracker.add(panel);\n        expect(tracker.methods).toEqual(\n          expect.arrayContaining(['onCurrentChanged'])\n        );\n      });","file":"tracker.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebook widget","suites":["@jupyter/notebook","StaticNotebook","#constructor()"],"updatePoint":{"line":171,"column":41},"line":171,"code":"      it('should create a notebook widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget).toBeInstanceOf(StaticNotebook);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add the `jp-Notebook` class","suites":["@jupyter/notebook","StaticNotebook","#constructor()"],"updatePoint":{"line":176,"column":44},"line":176,"code":"      it('should add the `jp-Notebook` class', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.hasClass('jp-Notebook')).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept an optional render","suites":["@jupyter/notebook","StaticNotebook","#constructor()"],"updatePoint":{"line":181,"column":42},"line":181,"code":"      it('should accept an optional render', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.contentFactory).toBe(contentFactory);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept an optional editor config","suites":["@jupyter/notebook","StaticNotebook","#constructor()"],"updatePoint":{"line":186,"column":49},"line":186,"code":"      it('should accept an optional editor config', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.editorConfig).toBe(editorConfig);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when the model changes","suites":["@jupyter/notebook","StaticNotebook","#modelChanged"],"updatePoint":{"line":193,"column":50},"line":193,"code":"      it('should be emitted when the model changes', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        let called = false;\n        widget.modelChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        widget.model = model;\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when a cell is added","suites":["@jupyter/notebook","StaticNotebook","#modelContentChanged"],"updatePoint":{"line":208,"column":48},"line":208,"code":"      it('should be emitted when a cell is added', () => {\n        const widget = new StaticNotebook(options);\n        widget.model = new NotebookModel();\n        let called = false;\n        widget.modelContentChanged.connect(() => {\n          called = true;\n        });\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.push(cell);\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when metadata is set","suites":["@jupyter/notebook","StaticNotebook","#modelContentChanged"],"updatePoint":{"line":220,"column":48},"line":220,"code":"      it('should be emitted when metadata is set', () => {\n        const widget = new StaticNotebook(options);\n        widget.model = new NotebookModel();\n        let called = false;\n        widget.modelContentChanged.connect(() => {\n          called = true;\n        });\n        widget.model!.metadata.set('foo', 1);\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the model for the widget","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":233,"column":45},"line":233,"code":"      it('should get the model for the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.model).toBeNull();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the model for the widget","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":238,"column":45},"line":238,"code":"      it('should set the model for the widget', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        expect(widget.model).toBe(model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `modelChanged` signal","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":245,"column":47},"line":245,"code":"      it('should emit the `modelChanged` signal', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        let called = false;\n        widget.modelChanged.connect(() => {\n          called = true;\n        });\n        widget.model = new NotebookModel();\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if the value does not change","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":257,"column":56},"line":257,"code":"      it('should be a no-op if the value does not change', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        let called = false;\n        widget.modelChanged.connect(() => {\n          called = true;\n        });\n        widget.model = model;\n        expect(called).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add the model cells to the layout","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":269,"column":50},"line":269,"code":"      it('should add the model cells to the layout', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        widget.model = model;\n        expect(widget.widgets.length).toBe(model.cells.length);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add a default cell if the notebook model is empty","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":277,"column":66},"line":277,"code":"      it('should add a default cell if the notebook model is empty', () => {\n        const widget = new LogStaticNotebook(options);\n        const model1 = new NotebookModel();\n        expect(model1.cells.length).toBe(0);\n        widget.model = model1;\n        expect(model1.cells.length).toBe(1);\n        expect(model1.cells.get(0).type).toBe('code');\n\n        widget.notebookConfig = {\n          ...widget.notebookConfig,\n          defaultCell: 'markdown'\n        };\n        const model2 = new NotebookModel();\n        expect(model2.cells.length).toBe(0);\n        widget.model = model2;\n        expect(model2.cells.length).toBe(1);\n        expect(model2.cells.get(0).type).toBe('markdown');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the mime types of the cell widgets","suites":["@jupyter/notebook","StaticNotebook","#model"],"updatePoint":{"line":296,"column":55},"line":296,"code":"      it('should set the mime types of the cell widgets', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        model.metadata.set('language_info', value);\n        widget.model = model;\n        const child = widget.widgets[0];\n        expect(child.model.mimeType).toBe('text/x-python');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle changes to the model cell list","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":318,"column":56},"line":318,"code":"        it('should handle changes to the model cell list', async () => {\n          widget = createWidget();\n          widget.model!.cells.clear();\n          await framePromise();\n          expect(widget.widgets.length).toBe(1);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a remove","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":325,"column":34},"line":325,"code":"        it('should handle a remove', () => {\n          const cell = widget.model!.cells.get(1);\n          const child = widget.widgets[1];\n          widget.model!.cells.removeValue(cell);\n          expect(cell.isDisposed).toBe(false);\n          expect(child.isDisposed).toBe(true);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle an add","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":333,"column":32},"line":333,"code":"        it('should handle an add', () => {\n          const cell = widget.model!.contentFactory.createCodeCell({});\n          widget.model!.cells.push(cell);\n          expect(widget.widgets.length).toBe(widget.model!.cells.length);\n          const child = widget.widgets[0];\n          expect(child.hasClass('jp-Notebook-cell')).toBe(true);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should initially render markdown cells with content","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":341,"column":63},"line":341,"code":"        it('should initially render markdown cells with content', () => {\n          const cell1 = widget.model!.contentFactory.createMarkdownCell({});\n          const cell2 = widget.model!.contentFactory.createMarkdownCell({});\n          cell1.value.text = '# Hello';\n          widget.model!.cells.push(cell1);\n          widget.model!.cells.push(cell2);\n          expect(widget.widgets.length).toBe(widget.model!.cells.length);\n          const child1 = widget.widgets[\n            widget.model!.cells.length - 2\n          ] as MarkdownCell;\n          const child2 = widget.widgets[\n            widget.model!.cells.length - 1\n          ] as MarkdownCell;\n          expect(child1.rendered).toBe(true);\n          expect(child2.rendered).toBe(false);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a move","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":358,"column":32},"line":358,"code":"        it('should handle a move', () => {\n          const child = widget.widgets[1];\n          widget.model!.cells.move(1, 2);\n          expect(widget.widgets[2]).toBe(child);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should handle a clear","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":364,"column":33},"line":364,"code":"        it('should handle a clear', () => {\n          const cell = widget.model!.contentFactory.createCodeCell({});\n          widget.model!.cells.push(cell);\n          widget.model!.cells.clear();\n          expect(widget.widgets.length).toBe(0);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add a new default cell when cells are cleared","suites":["@jupyter/notebook","StaticNotebook","#model","`cells.changed` signal"],"updatePoint":{"line":371,"column":64},"line":371,"code":"        it('should add a new default cell when cells are cleared', async () => {\n          const model = widget.model!;\n          widget.notebookConfig = {\n            ...widget.notebookConfig,\n            defaultCell: 'raw'\n          };\n          const promise = signalToPromise(model.cells.changed);\n          model.cells.clear();\n          await promise;\n          expect(model.cells.length).toBe(0);\n          await signalToPromise(model.cells.changed);\n          expect(model.cells.length).toBe(1);\n          expect(model.cells.get(0)).toBeInstanceOf(RawCellModel);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the rendermime instance used by the widget","suites":["@jupyter/notebook","StaticNotebook","#rendermime"],"updatePoint":{"line":389,"column":62},"line":389,"code":"      it('should be the rendermime instance used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.rendermime).toBe(rendermime);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the cell widget contentFactory used by the widget","suites":["@jupyter/notebook","StaticNotebook","#contentFactory"],"updatePoint":{"line":396,"column":69},"line":396,"code":"      it('should be the cell widget contentFactory used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.contentFactory).toBeInstanceOf(\n          StaticNotebook.ContentFactory\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the cell widget contentFactory used by the widget","suites":["@jupyter/notebook","StaticNotebook","#editorConfig"],"updatePoint":{"line":405,"column":69},"line":405,"code":"      it('should be the cell widget contentFactory used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.editorConfig).toBe(options.editorConfig);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be settable","suites":["@jupyter/notebook","StaticNotebook","#editorConfig"],"updatePoint":{"line":410,"column":28},"line":410,"code":"      it('should be settable', () => {\n        const widget = createWidget();\n        expect(widget.widgets[0].editor.getOption('autoClosingBrackets')).toBe(\n          false\n        );\n        const newConfig = {\n          raw: editorConfig.raw,\n          markdown: editorConfig.markdown,\n          code: {\n            ...editorConfig.code,\n            autoClosingBrackets: true\n          }\n        };\n        widget.editorConfig = newConfig;\n        expect(widget.widgets[0].editor.getOption('autoClosingBrackets')).toBe(\n          true\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the mime type for code cells","suites":["@jupyter/notebook","StaticNotebook","#codeMimetype"],"updatePoint":{"line":431,"column":49},"line":431,"code":"      it('should get the mime type for code cells', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.codeMimetype).toBe('text/plain');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be set from language metadata","suites":["@jupyter/notebook","StaticNotebook","#codeMimetype"],"updatePoint":{"line":436,"column":46},"line":436,"code":"      it('should be set from language metadata', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        model.metadata.set('language_info', value);\n        widget.model = model;\n        expect(widget.codeMimetype).toBe('text/x-python');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the child widget at a specified index","suites":["@jupyter/notebook","StaticNotebook","#widgets"],"updatePoint":{"line":447,"column":58},"line":447,"code":"      it('should get the child widget at a specified index', () => {\n        const widget = createWidget();\n        const child = widget.widgets[0];\n        expect(child).toBeInstanceOf(CodeCell);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should return `undefined` if out of range","suites":["@jupyter/notebook","StaticNotebook","#widgets"],"updatePoint":{"line":453,"column":51},"line":453,"code":"      it('should return `undefined` if out of range', () => {\n        const widget = createWidget();\n        const child = widget.widgets[1];\n        expect(child).toBeUndefined();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the number of child widgets","suites":["@jupyter/notebook","StaticNotebook","#widgets"],"updatePoint":{"line":459,"column":48},"line":459,"code":"      it('should get the number of child widgets', () => {\n        const widget = createWidget();\n        expect(widget.widgets.length).toBe(1);\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.widgets.length).toBe(utils.DEFAULT_CONTENT.cells.length);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should dispose of the resources held by the widget","suites":["@jupyter/notebook","StaticNotebook","#dispose()"],"updatePoint":{"line":468,"column":60},"line":468,"code":"      it('should dispose of the resources held by the widget', () => {\n        const widget = createWidget();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be safe to call multiple times","suites":["@jupyter/notebook","StaticNotebook","#dispose()"],"updatePoint":{"line":474,"column":47},"line":474,"code":"      it('should be safe to call multiple times', () => {\n        const widget = createWidget();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the model changes","suites":["@jupyter/notebook","StaticNotebook","#onModelChanged()"],"updatePoint":{"line":483,"column":49},"line":483,"code":"      it('should be called when the model changes', () => {\n        const widget = new LogStaticNotebook(options);\n        widget.model = new NotebookModel();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not be called if the model does not change","suites":["@jupyter/notebook","StaticNotebook","#onModelChanged()"],"updatePoint":{"line":491,"column":59},"line":491,"code":"      it('should not be called if the model does not change', () => {\n        const widget = createWidget();\n        widget.methods = [];\n        widget.model = widget.model; // eslint-disable-line\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onModelChanged'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when the metadata on the notebook changes","suites":["@jupyter/notebook","StaticNotebook","#onMetadataChanged()"],"updatePoint":{"line":502,"column":68},"line":502,"code":"      it('should be called when the metadata on the notebook changes', () => {\n        const widget = createWidget();\n        widget.model!.metadata.set('foo', 1);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the `codeMimetype`","suites":["@jupyter/notebook","StaticNotebook","#onMetadataChanged()"],"updatePoint":{"line":510,"column":42},"line":510,"code":"      it('should update the `codeMimetype`', () => {\n        const widget = createWidget();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        widget.model!.metadata.set('language_info', value);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n        expect(widget.codeMimetype).toBe('text/x-python');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the cell widget mimetype","suites":["@jupyter/notebook","StaticNotebook","#onMetadataChanged()"],"updatePoint":{"line":520,"column":48},"line":520,"code":"      it('should update the cell widget mimetype', () => {\n        const widget = createWidget();\n        const value = { name: 'python', mimetype: 'text/x-python' };\n        widget.model!.metadata.set('language_info', value);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n        const child = widget.widgets[0];\n        expect(child.model.mimeType).toBe('text/x-python');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when a cell is inserted","suites":["@jupyter/notebook","StaticNotebook","#onCellInserted()"],"updatePoint":{"line":533,"column":50},"line":533,"code":"      it('should be called when a cell is inserted', () => {\n        const widget = createWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellInserted'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when a cell is moved","suites":["@jupyter/notebook","StaticNotebook","#onCellMoved()"],"updatePoint":{"line":543,"column":47},"line":543,"code":"      it('should be called when a cell is moved', () => {\n        const widget = createWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.model!.cells.move(0, 1);\n        expect(widget.methods).toEqual(expect.arrayContaining(['onCellMoved']));\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be called when a cell is removed","suites":["@jupyter/notebook","StaticNotebook","#onCellRemoved()"],"updatePoint":{"line":552,"column":49},"line":552,"code":"      it('should be called when a cell is removed', () => {\n        const widget = createWidget();\n        const cell = widget.model!.cells.get(0);\n        widget.model!.cells.removeValue(cell);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellRemoved'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new ContentFactory","suites":["@jupyter/notebook","StaticNotebook",".ContentFactory","#constructor"],"updatePoint":{"line":564,"column":46},"line":564,"code":"        it('should create a new ContentFactory', () => {\n          const editorFactory = utils.editorFactory;\n          const factory = new StaticNotebook.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(StaticNotebook.ContentFactory);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a `CodeCell`","suites":["@jupyter/notebook","StaticNotebook",".ContentFactory","#createCodeCell({})"],"updatePoint":{"line":572,"column":38},"line":572,"code":"        it('should create a `CodeCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory();\n          const model = new CodeCellModel({});\n          const codeOptions = { model, rendermime, contentFactory };\n          const parent = new StaticNotebook(options);\n          const widget = contentFactory.createCodeCell(codeOptions, parent);\n          expect(widget).toBeInstanceOf(CodeCell);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a `MarkdownCell`","suites":["@jupyter/notebook","StaticNotebook",".ContentFactory","#createMarkdownCell({})"],"updatePoint":{"line":583,"column":42},"line":583,"code":"        it('should create a `MarkdownCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory();\n          const model = new MarkdownCellModel({});\n          const mdOptions = { model, rendermime, contentFactory };\n          const parent = new StaticNotebook(options);\n          const widget = contentFactory.createMarkdownCell(mdOptions, parent);\n          expect(widget).toBeInstanceOf(MarkdownCell);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a `RawCell`","suites":["@jupyter/notebook","StaticNotebook",".ContentFactory","#createRawCell()"],"updatePoint":{"line":594,"column":37},"line":594,"code":"        it('should create a `RawCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory();\n          const model = new RawCellModel({});\n          const rawOptions = { model, contentFactory };\n          const parent = new StaticNotebook(options);\n          const widget = contentFactory.createRawCell(rawOptions, parent);\n          expect(widget).toBeInstanceOf(RawCell);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when the state of the notebook changes","suites":["@jupyter/notebook","Notebook","#stateChanged"],"updatePoint":{"line":608,"column":66},"line":608,"code":"      it('should be emitted when the state of the notebook changes', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('mode');\n          expect(args.oldValue).toBe('command');\n          expect(args.newValue).toBe('edit');\n          called = true;\n        });\n        widget.mode = 'edit';\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when the active cell changes","suites":["@jupyter/notebook","Notebook","#activeCellChanged"],"updatePoint":{"line":624,"column":56},"line":624,"code":"      it('should be emitted when the active cell changes', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.activeCellChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBe(widget.activeCell);\n          called = true;\n        });\n        widget.activeCellIndex++;\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not be emitted when the active cell does not change","suites":["@jupyter/notebook","Notebook","#activeCellChanged"],"updatePoint":{"line":637,"column":68},"line":637,"code":"      it('should not be emitted when the active cell does not change', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.activeCellChanged.connect(() => {\n          called = true;\n        });\n        widget.activeCellIndex = widget.activeCellIndex; // eslint-disable-line\n        expect(called).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be emitted when the selection changes","suites":["@jupyter/notebook","Notebook","#selectionChanged"],"updatePoint":{"line":650,"column":54},"line":650,"code":"      it('should be emitted when the selection changes', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.selectionChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        widget.select(widget.widgets[1]);\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not be emitted when the selection does not change","suites":["@jupyter/notebook","Notebook","#selectionChanged"],"updatePoint":{"line":663,"column":66},"line":663,"code":"      it('should not be emitted when the selection does not change', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.select(widget.widgets[1]);\n        widget.selectionChanged.connect(() => {\n          called = true;\n        });\n        widget.select(widget.widgets[1]);\n        expect(called).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the interactivity mode of the notebook","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":677,"column":59},"line":677,"code":"      it('should get the interactivity mode of the notebook', () => {\n        const widget = createActiveWidget();\n        expect(widget.mode).toBe('command');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the interactivity mode of the notebook","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":682,"column":59},"line":682,"code":"      it('should set the interactivity mode of the notebook', () => {\n        const widget = createActiveWidget();\n        widget.mode = 'edit';\n        expect(widget.mode).toBe('edit');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `stateChanged` signal","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":688,"column":47},"line":688,"code":"      it('should emit the `stateChanged` signal', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('mode');\n          expect(args.oldValue).toBe('command');\n          expect(args.newValue).toBe('edit');\n          called = true;\n        });\n        widget.mode = 'edit';\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if the value does not change","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":702,"column":56},"line":702,"code":"      it('should be a no-op if the value does not change', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect(() => {\n          called = true;\n        });\n        widget.mode = 'command';\n        expect(called).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should post an update request","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":712,"column":39},"line":712,"code":"      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.mode = 'edit';\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deselect all cells if switching to edit mode","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":721,"column":61},"line":721,"code":"      it('should deselect all cells if switching to edit mode', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        widget.extendContiguousSelectionTo(widget.widgets.length - 1);\n        const selectedRange = Array.from(Array(widget.widgets.length).keys());\n        expect(selected(widget)).toEqual(selectedRange);\n        widget.mode = 'edit';\n        expect(selected(widget)).toEqual([]);\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should unrender a markdown cell when switching to edit mode","suites":["@jupyter/notebook","Notebook","#mode"],"updatePoint":{"line":734,"column":69},"line":734,"code":"      it('should unrender a markdown cell when switching to edit mode', () => {\n        const widget = createActiveWidget();\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        const cell = widget.model!.contentFactory.createMarkdownCell({});\n        cell.value.text = '# Hello'; // Should be rendered with content.\n        widget.model!.cells.push(cell);\n        const child = widget.widgets[widget.widgets.length - 1] as MarkdownCell;\n        expect(child.rendered).toBe(true);\n        widget.activeCellIndex = widget.widgets.length - 1;\n        widget.mode = 'edit';\n        expect(child.rendered).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the active cell index of the notebook","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":750,"column":58},"line":750,"code":"      it('should get the active cell index of the notebook', () => {\n        const widget = createActiveWidget();\n        expect(widget.activeCellIndex).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the active cell index of the notebook","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":755,"column":58},"line":755,"code":"      it('should set the active cell index of the notebook', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        expect(widget.activeCellIndex).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clamp the index to the bounds of the notebook cells","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":762,"column":68},"line":762,"code":"      it('should clamp the index to the bounds of the notebook cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = -2;\n        expect(widget.activeCellIndex).toBe(0);\n        widget.activeCellIndex = 100;\n        expect(widget.activeCellIndex).toBe(widget.model!.cells.length - 1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should emit the `stateChanged` signal","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":771,"column":47},"line":771,"code":"      it('should emit the `stateChanged` signal', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('activeCellIndex');\n          expect(args.oldValue).toBe(0);\n          expect(args.newValue).toBe(1);\n          called = true;\n        });\n        widget.activeCellIndex = 1;\n        expect(called).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if the value does not change","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":786,"column":56},"line":786,"code":"      it('should be a no-op if the value does not change', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.stateChanged.connect(() => {\n          called = true;\n        });\n        widget.activeCellIndex = 0;\n        expect(called).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should post an update request","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":797,"column":39},"line":797,"code":"      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        widget.activeCellIndex = 1;\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the active cell if necessary","suites":["@jupyter/notebook","Notebook","#activeCellIndex"],"updatePoint":{"line":807,"column":52},"line":807,"code":"      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        expect(widget.activeCell).toBe(widget.widgets[1]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get the active cell widget","suites":["@jupyter/notebook","Notebook","#activeCell"],"updatePoint":{"line":816,"column":43},"line":816,"code":"      it('should get the active cell widget', () => {\n        const widget = createActiveWidget();\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should select a cell widget","suites":["@jupyter/notebook","Notebook","#select()"],"updatePoint":{"line":823,"column":37},"line":823,"code":"      it('should select a cell widget', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = widget.widgets[0];\n        widget.select(cell);\n        expect(widget.isSelected(cell)).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should allow multiple widgets to be selected","suites":["@jupyter/notebook","Notebook","#select()"],"updatePoint":{"line":831,"column":54},"line":831,"code":"      it('should allow multiple widgets to be selected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.widgets.forEach(cell => {\n          widget.select(cell);\n        });\n        const expectSelected = Array.from(Array(widget.widgets.length).keys());\n        expect(selected(widget)).toEqual(expectSelected);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deselect a cell","suites":["@jupyter/notebook","Notebook","#deselect()"],"updatePoint":{"line":843,"column":32},"line":843,"code":"      it('should deselect a cell', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          widget.select(cell);\n          expect(widget.isSelected(cell)).toBe(true);\n          widget.deselect(cell);\n          expect(widget.isSelected(cell)).toBe(false);\n        }\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should const the active cell be deselected","suites":["@jupyter/notebook","Notebook","#deselect()"],"updatePoint":{"line":855,"column":52},"line":855,"code":"      it('should const the active cell be deselected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = widget.activeCell!;\n        widget.select(cell);\n        expect(widget.isSelected(cell)).toBe(true);\n        widget.deselect(cell);\n        expect(widget.isSelected(cell)).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get whether the cell is selected","suites":["@jupyter/notebook","Notebook","#isSelected()"],"updatePoint":{"line":867,"column":49},"line":867,"code":"      it('should get whether the cell is selected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.select(widget.widgets[0]);\n        widget.select(widget.widgets[2]);\n        expect(selected(widget)).toEqual([0, 2]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"reports selection whether or not cell is active","suites":["@jupyter/notebook","Notebook","#isSelected()"],"updatePoint":{"line":875,"column":57},"line":875,"code":"      it('reports selection whether or not cell is active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(selected(widget)).toEqual([]);\n        widget.select(widget.activeCell!);\n        expect(selected(widget)).toEqual([widget.activeCellIndex]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should deselect all cells","suites":["@jupyter/notebook","Notebook","#deselectAll()"],"updatePoint":{"line":885,"column":35},"line":885,"code":"      it('should deselect all cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.select(widget.widgets[0]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.select(widget.widgets[4]);\n        expect(selected(widget)).toEqual([0, 2, 3, 4]);\n        widget.deselectAll();\n        expect(selected(widget)).toEqual([]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should work in each permutation of anchor, head, and index","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1000,"column":68},"line":1000,"code":"      it('should work in each permutation of anchor, head, and index', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], p[2]);\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should work when we only have an active cell, with no existing selection","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1011,"column":82},"line":1011,"code":"      it('should work when we only have an active cell, with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(widget, p[0], p[1], p[2], false);\n            }\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clip when the index is greater than the last index","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1024,"column":67},"line":1024,"code":"      it('should clip when the index is greater than the last index', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], Number.MAX_SAFE_INTEGER);\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clip when the index is greater than the last index with no existing selection","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1035,"column":94},"line":1035,"code":"      it('should clip when the index is greater than the last index with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(\n                widget,\n                p[0],\n                p[1],\n                Number.MAX_SAFE_INTEGER,\n                false\n              );\n            }\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clip when the index is less than 0","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1054,"column":51},"line":1054,"code":"      it('should clip when the index is less than 0', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], -10);\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clip when the index is less than 0 with no existing selection","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1065,"column":78},"line":1065,"code":"      it('should clip when the index is less than 0 with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(widget, p[0], p[1], -10, false);\n            }\n          });\n        }).not.toThrow();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"handles the case of no cells","suites":["@jupyter/notebook","Notebook","#extendContiguousSelectionTo()"],"updatePoint":{"line":1078,"column":38},"line":1078,"code":"      it('handles the case of no cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.cells.clear();\n        expect(widget.widgets.length).toBe(0);\n\n        // Set up a selection event listener.\n        let selectionChanged = 0;\n        widget.selectionChanged.connect((sender, args) => {\n          selectionChanged += 1;\n        });\n\n        widget.extendContiguousSelectionTo(3);\n\n        expect(widget.activeCellIndex).toBe(-1);\n        expect(selectionChanged).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"throws an error when the selection is not contiguous","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1097,"column":62},"line":1097,"code":"      it('throws an error when the selection is not contiguous', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        expect(() => widget.getContiguousSelection()).toThrowError(\n          /Selection not contiguous/\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"throws an error if the active cell is not at an endpoint","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1110,"column":66},"line":1110,"code":"      it('throws an error if the active cell is not at an endpoint', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n\n        // Check if active cell is outside selection.\n        widget.activeCellIndex = 0;\n        expect(() => widget.getContiguousSelection()).toThrowError(\n          /Active cell not at endpoint of selection/\n        );\n\n        // Check if active cell is inside selection.\n        widget.activeCellIndex = 2;\n        expect(() => widget.getContiguousSelection()).toThrowError(\n          /Active cell not at endpoint of selection/\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"returns null values if there is no selection","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1131,"column":54},"line":1131,"code":"      it('returns null values if there is no selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: null, anchor: null });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"handles the case of no cells","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1139,"column":38},"line":1139,"code":"      it('handles the case of no cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.cells.clear();\n        expect(widget.widgets.length).toBe(0);\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: null, anchor: null });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"works if head is before the anchor","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1148,"column":44},"line":1148,"code":"      it('works if head is before the anchor', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 1;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 1, anchor: 3 });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"works if head is after the anchor","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1161,"column":43},"line":1161,"code":"      it('works if head is after the anchor', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 3, anchor: 1 });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"works if head and anchor are the same","suites":["@jupyter/notebook","Notebook","#getContiguousSelection()"],"updatePoint":{"line":1174,"column":47},"line":1174,"code":"      it('works if head and anchor are the same', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 3, anchor: 3 });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the active cell index","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1201,"column":44},"line":1201,"code":"        it('should set the active cell index', () => {\n          const child = widget.widgets[1];\n          simulate(child.node, 'mousedown');\n          expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n          expect(widget.isSelected(widget.widgets[0])).toBe(false);\n          expect(widget.activeCellIndex).toBe(1);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be a no-op if not not a cell","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1209,"column":47},"line":1209,"code":"        it('should be a no-op if not not a cell', () => {\n          simulate(widget.node, 'mousedown');\n          expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n          expect(widget.activeCellIndex).toBe(0);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should preserve \"command\" mode if in a markdown cell","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1215,"column":64},"line":1215,"code":"        it('should preserve \"command\" mode if in a markdown cell', () => {\n          const cell = widget.model!.contentFactory.createMarkdownCell({});\n          cell.value.text = '# Hello'; // Should be rendered with content.\n          widget.model!.cells.push(cell);\n          const count = widget.widgets.length;\n          const child = widget.widgets[count - 1] as MarkdownCell;\n          expect(child.rendered).toBe(true);\n          simulate(child.node, 'mousedown');\n          expect(child.rendered).toBe(true);\n          expect(widget.activeCell).toBe(child);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should extend selection if invoked with shift","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1227,"column":57},"line":1227,"code":"        it('should extend selection if invoked with shift', () => {\n          widget.activeCellIndex = 3;\n\n          // shift click below\n          simulate(widget.widgets[4].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(4);\n          expect(selected(widget)).toEqual([3, 4]);\n\n          // shift click above\n          simulate(widget.widgets[1].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(1);\n          expect(selected(widget)).toEqual([1, 2, 3]);\n\n          // shift click expand\n          simulate(widget.widgets[0].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(0);\n          expect(selected(widget)).toEqual([0, 1, 2, 3]);\n\n          // shift click contract\n          simulate(widget.widgets[2].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(2);\n          expect(selected(widget)).toEqual([2, 3]);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should not extend a selection if there is text selected in the output","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1251,"column":81},"line":1251,"code":"        it('should not extend a selection if there is text selected in the output', () => {\n          const codeCellIndex = 3;\n          widget.activeCellIndex = codeCellIndex;\n\n          // Set a selection in the active cell outputs.\n          const selection = window.getSelection()!;\n          selection.selectAllChildren(\n            (widget.activeCell as CodeCell).outputArea.node\n          );\n\n          // Shift click below, which should not extend cells selection.\n          simulate(widget.widgets[codeCellIndex + 2].node, 'mousedown', {\n            shiftKey: true\n          });\n          expect(widget.activeCellIndex).toBe(codeCellIndex);\n          expect(selected(widget)).toEqual([]);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should leave a markdown cell rendered","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1269,"column":49},"line":1269,"code":"        it('should leave a markdown cell rendered', () => {\n          const code = widget.model!.contentFactory.createCodeCell({});\n          const md = widget.model!.contentFactory.createMarkdownCell({});\n          md.value.text = '# Hello'; // Should be rendered with content.\n          widget.model!.cells.push(code);\n          widget.model!.cells.push(md);\n          const count = widget.widgets.length;\n          const codeChild = widget.widgets[count - 2];\n          const mdChild = widget.widgets[count - 1] as MarkdownCell;\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = count - 2;\n          expect(mdChild.rendered).toBe(true);\n          simulate(codeChild.editorWidget.node, 'mousedown');\n          simulate(codeChild.editorWidget.node, 'focusin');\n          expect(mdChild.rendered).toBe(true);\n          expect(widget.activeCell).toBe(codeChild);\n          expect(widget.mode).toBe('edit');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should remove selection and switch to command mode","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1289,"column":62},"line":1289,"code":"        it('should remove selection and switch to command mode', () => {\n          const code = widget.model!.contentFactory.createCodeCell({});\n          const md = widget.model!.contentFactory.createMarkdownCell({});\n          widget.model!.cells.push(code);\n          widget.model!.cells.push(md);\n          const count = widget.widgets.length;\n          const codeChild = widget.widgets[count - 2];\n          const mdChild = widget.widgets[count - 1] as MarkdownCell;\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = count - 2;\n          simulate(codeChild.editorWidget.node, 'mousedown');\n          simulate(codeChild.editorWidget.node, 'focusin');\n          expect(widget.mode).toBe('edit');\n          simulate(codeChild.editorWidget.node, 'mousedown', { button: 2 });\n          expect(widget.isSelected(mdChild)).toBe(false);\n          expect(widget.mode).toBe('command');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should have no effect on shift right click","suites":["@jupyter/notebook","Notebook","#handleEvent()","mousedown"],"updatePoint":{"line":1308,"column":54},"line":1308,"code":"        it('should have no effect on shift right click', () => {\n          const code = widget.model!.contentFactory.createCodeCell({});\n          const md = widget.model!.contentFactory.createMarkdownCell({});\n          widget.model!.cells.push(code);\n          widget.model!.cells.push(md);\n          const count = widget.widgets.length;\n          const codeChild = widget.widgets[count - 2];\n          const mdChild = widget.widgets[count - 1] as MarkdownCell;\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = count - 2;\n          simulate(codeChild.editorWidget.node, 'mousedown', {\n            shiftKey: true,\n            button: 2\n          });\n          expect(widget.isSelected(mdChild)).toBe(true);\n          expect(widget.mode).toBe('command');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should unrender a markdown cell","suites":["@jupyter/notebook","Notebook","#handleEvent()","dblclick"],"updatePoint":{"line":1329,"column":43},"line":1329,"code":"        it('should unrender a markdown cell', () => {\n          const cell = widget.model!.contentFactory.createMarkdownCell({});\n          cell.value.text = '# Hello'; // Should be rendered with content.\n          widget.model!.cells.push(cell);\n          const child = widget.widgets[\n            widget.widgets.length - 1\n          ] as MarkdownCell;\n          expect(child.rendered).toBe(true);\n          expect(widget.mode).toBe('command');\n          simulate(child.node, 'dblclick');\n          expect(widget.mode).toBe('command');\n          expect(child.rendered).toBe(false);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to edit mode if a child cell takes focus","suites":["@jupyter/notebook","Notebook","#handleEvent()","focusin"],"updatePoint":{"line":1345,"column":66},"line":1345,"code":"        it('should change to edit mode if a child cell takes focus', () => {\n          const child = widget.widgets[0];\n          simulate(child.editorWidget.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('edit');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should change to command mode if the widget takes focus","suites":["@jupyter/notebook","Notebook","#handleEvent()","focusin"],"updatePoint":{"line":1352,"column":67},"line":1352,"code":"        it('should change to command mode if the widget takes focus', () => {\n          const child = widget.widgets[0];\n          simulate(child.editorWidget.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('edit');\n          widget.events = [];\n          simulate(widget.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('command');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should switch to command mode","suites":["@jupyter/notebook","Notebook","#handleEvent()","focusout"],"updatePoint":{"line":1365,"column":41},"line":1365,"code":"        it('should switch to command mode', () => {\n          simulate(widget.node, 'focusin');\n          widget.mode = 'edit';\n          const event = generate('focusout');\n          (event as any).relatedTarget = document.body;\n          widget.node.dispatchEvent(event);\n          expect(widget.mode).toBe('command');\n          MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n          expect(widget.mode).toBe('command');\n          expect(widget.activeCell!.editor.hasFocus()).toBe(false);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set command mode","suites":["@jupyter/notebook","Notebook","#handleEvent()","focusout"],"updatePoint":{"line":1377,"column":35},"line":1377,"code":"        it('should set command mode', () => {\n          simulate(widget.node, 'focusin');\n          widget.mode = 'edit';\n          const evt = generate('focusout');\n          (evt as any).relatedTarget = widget.activeCell!.node;\n          widget.node.dispatchEvent(evt);\n          expect(widget.mode).toBe('command');\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add event listeners","suites":["@jupyter/notebook","Notebook","#onAfterAttach()"],"updatePoint":{"line":1389,"column":36},"line":1389,"code":"      it('should add event listeners', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        const child = widget.widgets[0];\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n        simulate(widget.node, 'dblclick');\n        expect(widget.events).toEqual(expect.arrayContaining(['dblclick']));\n        simulate(child.node, 'focusin');\n        expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should post an update request","suites":["@jupyter/notebook","Notebook","#onAfterAttach()"],"updatePoint":{"line":1407,"column":39},"line":1407,"code":"      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should remove event listeners","suites":["@jupyter/notebook","Notebook","#onBeforeDetach()"],"updatePoint":{"line":1424,"column":39},"line":1424,"code":"      it('should remove event listeners', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        const child = widget.widgets[0];\n        await framePromise();\n        Widget.detach(widget);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onBeforeDetach'])\n        );\n        widget.events = [];\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).toEqual(\n          expect.not.arrayContaining(['mousedown'])\n        );\n        simulate(widget.node, 'dblclick');\n        expect(widget.events).toEqual(expect.not.arrayContaining(['dblclick']));\n        simulate(child.node, 'focusin');\n        expect(widget.events).toEqual(expect.not.arrayContaining(['focusin']));\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should focus the node after an update","suites":["@jupyter/notebook","Notebook","#onActivateRequest()"],"updatePoint":{"line":1448,"column":47},"line":1448,"code":"      it('should focus the node after an update', async () => {\n        const widget = createActiveWidget();\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onActivateRequest'])\n        );\n        await framePromise();\n        expect(document.activeElement).toBe(widget.node);\n        widget.dispose();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should apply the command class if in command mode","suites":["@jupyter/notebook","Notebook","#onUpdateRequest()"],"updatePoint":{"line":1475,"column":59},"line":1475,"code":"      it('should apply the command class if in command mode', () => {\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        expect(widget.hasClass('jp-mod-commandMode')).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should apply the edit class if in edit mode","suites":["@jupyter/notebook","Notebook","#onUpdateRequest()"],"updatePoint":{"line":1482,"column":53},"line":1482,"code":"      it('should apply the edit class if in edit mode', async () => {\n        widget.mode = 'edit';\n        await framePromise();\n        expect(widget.hasClass('jp-mod-editMode')).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add the active class to the active widget","suites":["@jupyter/notebook","Notebook","#onUpdateRequest()"],"updatePoint":{"line":1488,"column":58},"line":1488,"code":"      it('should add the active class to the active widget', () => {\n        const cell = widget.widgets[widget.activeCellIndex];\n        expect(cell.hasClass('jp-mod-active')).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should set the selected class on the selected widgets","suites":["@jupyter/notebook","Notebook","#onUpdateRequest()"],"updatePoint":{"line":1493,"column":63},"line":1493,"code":"      it('should set the selected class on the selected widgets', async () => {\n        widget.select(widget.widgets[1]);\n        await framePromise();\n        for (let i = 0; i < 2; i++) {\n          const cell = widget.widgets[i];\n          expect(cell.hasClass('jp-mod-selected')).toBe(true);\n        }\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should add the multi select class if there is more than one widget","suites":["@jupyter/notebook","Notebook","#onUpdateRequest()"],"updatePoint":{"line":1502,"column":76},"line":1502,"code":"      it('should add the multi select class if there is more than one widget', async () => {\n        widget.select(widget.widgets[1]);\n        expect(widget.hasClass('jp-mod-multSelected')).toBe(false);\n        await framePromise();\n        expect(widget.hasClass('jp-mod-multSelected')).toBe(false);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should post an `update-request","suites":["@jupyter/notebook","Notebook","#onCellInserted()"],"updatePoint":{"line":1511,"column":40},"line":1511,"code":"      it('should post an `update-request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellInserted'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the active cell if necessary","suites":["@jupyter/notebook","Notebook","#onCellInserted()"],"updatePoint":{"line":1523,"column":52},"line":1523,"code":"      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should keep the currently active cell active","suites":["@jupyter/notebook","Notebook","#onCellInserted()"],"updatePoint":{"line":1529,"column":54},"line":1529,"code":"      it('should keep the currently active cell active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        const cell = widget.model!.contentFactory.createCodeCell({});\n        widget.model!.cells.insert(1, cell);\n        expect(widget.activeCell).toBe(widget.widgets[2]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the previous cell if top is requested","suites":["@jupyter/notebook","Notebook","#onCellInserted()","`edgeRequested` signal"],"updatePoint":{"line":1539,"column":65},"line":1539,"code":"        it('should activate the previous cell if top is requested', () => {\n          const widget = createActiveWidget();\n          widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n          widget.activeCellIndex = 1;\n          const child = widget.widgets[widget.activeCellIndex];\n          (child.editor.edgeRequested as any).emit('top');\n          expect(widget.activeCellIndex).toBe(0);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should activate the next cell if bottom is requested","suites":["@jupyter/notebook","Notebook","#onCellInserted()","`edgeRequested` signal"],"updatePoint":{"line":1548,"column":64},"line":1548,"code":"        it('should activate the next cell if bottom is requested', () => {\n          const widget = createActiveWidget();\n          widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n          const child = widget.widgets[widget.activeCellIndex];\n          (child.editor.edgeRequested as any).emit('bottom');\n          expect(widget.activeCellIndex).toBe(1);\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the active cell index if necessary","suites":["@jupyter/notebook","Notebook","#onCellMoved()"],"updatePoint":{"line":1559,"column":58},"line":1559,"code":"      it('should update the active cell index if necessary', () => {\n        const widget = createActiveWidget();\n\n        // [fromIndex, toIndex, activeIndex], starting with activeIndex=3.\n        const moves = [\n          [0, 2, 3],\n          [0, 3, 2],\n          [0, 4, 2],\n          [3, 2, 2],\n          [3, 3, 3],\n          [3, 4, 4],\n          [4, 2, 4],\n          [4, 3, 4],\n          [4, 5, 3]\n        ];\n\n        moves.forEach(m => {\n          const [fromIndex, toIndex, activeIndex] = m;\n          widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n          const cell = widget.widgets[3];\n          widget.activeCellIndex = 3;\n          widget.model!.cells.move(fromIndex, toIndex);\n          expect(widget.activeCellIndex).toBe(activeIndex);\n          expect(widget.widgets[activeIndex]).toBe(cell);\n        });\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should post an `update-request","suites":["@jupyter/notebook","Notebook","#onCellRemoved()"],"updatePoint":{"line":1588,"column":40},"line":1588,"code":"      it('should post an `update-request', async () => {\n        const widget = createActiveWidget();\n        const cell = widget.model!.cells.get(0);\n        widget.model!.cells.removeValue(cell);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellRemoved'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should update the active cell if necessary","suites":["@jupyter/notebook","Notebook","#onCellRemoved()"],"updatePoint":{"line":1601,"column":52},"line":1601,"code":"      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.model!.cells.remove(0);\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should keep the currently active cell active","suites":["@jupyter/notebook","Notebook","#onCellRemoved()"],"updatePoint":{"line":1608,"column":54},"line":1608,"code":"      it('should keep the currently active cell active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 2;\n        widget.model!.cells.remove(1);\n        expect(widget.activeCell).toBe(widget.widgets[1]);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should render the last cell widget","suites":["@jupyter/notebook","Notebook","#virtualNotebook()"],"updatePoint":{"line":1619,"column":44},"line":1619,"code":"      it('should render the last cell widget', () => {\n        const model = new NotebookModel();\n        const widget = new StaticNotebook(options);\n        widget.model = model;\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = widget.widgets[5];\n        expect(\n          cell.inputArea.editorWidget.model.value.text.startsWith(\n            'from IPython.display import Latex'\n          )\n        ).toBe(true);\n        console.log();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a notebook widget factory","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#constructor()"],"updatePoint":{"line":38,"column":49},"line":38,"code":"      it('should create a notebook widget factory', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory).toBeInstanceOf(NotebookWidgetFactory);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should get whether the factory has been disposed","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#isDisposed"],"updatePoint":{"line":45,"column":58},"line":45,"code":"      it('should get whether the factory has been disposed', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should dispose of the resources held by the factory","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#dispose()"],"updatePoint":{"line":54,"column":61},"line":54,"code":"      it('should dispose of the resources held by the factory', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#dispose()"],"updatePoint":{"line":60,"column":47},"line":60,"code":"      it('should be safe to call multiple times', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be the editor config passed into the constructor","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#editorConfig"],"updatePoint":{"line":69,"column":65},"line":69,"code":"      it('should be the editor config passed into the constructor', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory.editorConfig).toBe(utils.defaultEditorConfig);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should be settable","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#editorConfig"],"updatePoint":{"line":74,"column":28},"line":74,"code":"      it('should be settable', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const newConfig = { ...utils.defaultEditorConfig };\n        factory.editorConfig = newConfig;\n        expect(factory.editorConfig).toBe(newConfig);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a new `NotebookPanel` widget","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":83,"column":52},"line":83,"code":"      it('should create a new `NotebookPanel` widget', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel).toBeInstanceOf(NotebookPanel);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should create a clone of the rendermime","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":89,"column":49},"line":89,"code":"      it('should create a clone of the rendermime', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel.content.rendermime).not.toBe(rendermime);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should pass the editor config to the notebook","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":95,"column":55},"line":95,"code":"      it('should pass the editor config to the notebook', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel.content.editorConfig).toBe(utils.defaultEditorConfig);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should populate the default toolbar items","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":101,"column":51},"line":101,"code":"      it('should populate the default toolbar items', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        const items = toArray(panel.toolbar.names());\n        expect(items).toEqual(expect.arrayContaining(['save']));\n        expect(items).toEqual(expect.arrayContaining(['restart']));\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should populate the customized toolbar items","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":109,"column":54},"line":109,"code":"      it('should populate the customized toolbar items', () => {\n        const toolbarFactory = () => [\n          { name: 'foo', widget: new ToolbarButton() },\n          { name: 'bar', widget: new ToolbarButton() }\n        ];\n        const factory = utils.createNotebookWidgetFactory(toolbarFactory);\n        const panel = factory.createNew(context);\n        const panel2 = factory.createNew(context);\n        expect(toArray(panel.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(toArray(panel2.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(toArray(panel.toolbar.children()).length).toBe(3);\n        expect(toArray(panel2.toolbar.children()).length).toBe(3);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should clone from the optional source widget","suites":["@jupyterlab/notebook","NotebookWidgetFactory","#createNew()"],"updatePoint":{"line":131,"column":54},"line":131,"code":"      it('should clone from the optional source widget', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        const clone = factory.createNew(panel.context, panel);\n        expect(clone).toBeInstanceOf(NotebookPanel);\n        expect(clone.content.rendermime).toBe(panel.content.rendermime);\n        expect(clone.content.editorConfig).toBe(panel.content.editorConfig);\n        expect(clone.content.notebookConfig).toBe(panel.content.notebookConfig);\n      });","file":"widgetfactory.spec.ts","skipped":false,"dir":"packages/notebook/test"},{"name":"should accept no arguments","suites":["@jupyterlab/observables","ObservableValue","#constructor"],"updatePoint":{"line":16,"column":36},"line":16,"code":"      it('should accept no arguments', () => {\n        const value = new ObservableValue();\n        expect(value instanceof ObservableValue).toBe(true);\n        expect(value.get()).toBeNull();\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept an initial JSON value","suites":["@jupyterlab/observables","ObservableValue","#constructor"],"updatePoint":{"line":22,"column":45},"line":22,"code":"      it('should accept an initial JSON value', () => {\n        const value = new ObservableValue('value');\n        expect(value instanceof ObservableValue).toBe(true);\n        const value2 = new ObservableValue({ one: 'one', two: 2 });\n        expect(value2 instanceof ObservableValue).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `Value`","suites":["@jupyterlab/observables","ObservableValue","#type"],"updatePoint":{"line":31,"column":31},"line":31,"code":"      it('should return `Value`', () => {\n        const value = new ObservableValue();\n        expect(value.type).toBe('Value');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should test whether the value is disposed","suites":["@jupyterlab/observables","ObservableValue","#isDisposed"],"updatePoint":{"line":38,"column":51},"line":38,"code":"      it('should test whether the value is disposed', () => {\n        const value = new ObservableValue();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be emitted when the map changes state","suites":["@jupyterlab/observables","ObservableValue","#changed"],"updatePoint":{"line":47,"column":54},"line":47,"code":"      it('should be emitted when the map changes state', () => {\n        let called = false;\n        const value = new ObservableValue();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.set('set');\n        expect(called).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should have value changed args","suites":["@jupyterlab/observables","ObservableValue","#changed"],"updatePoint":{"line":57,"column":40},"line":57,"code":"      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableValue();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.newValue).toBe('set');\n          expect(args.oldValue).toBeNull();\n          called = true;\n        });\n        value.set('set');\n        expect(called).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should get the value of the object","suites":["@jupyterlab/observables","ObservableValue","#get"],"updatePoint":{"line":72,"column":44},"line":72,"code":"      it('should get the value of the object', () => {\n        const value = new ObservableValue('value');\n        expect(value.get()).toBe('value');\n        const value2 = new ObservableValue({ one: 'one', two: 2 });\n        expect(JSONExt.deepEqual(value2.get(), { one: 'one', two: 2 })).toBe(\n          true\n        );\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set the value of the object","suites":["@jupyterlab/observables","ObservableValue","#set"],"updatePoint":{"line":83,"column":44},"line":83,"code":"      it('should set the value of the object', () => {\n        const value = new ObservableValue();\n        value.set('value');\n        expect(value.get()).toBe('value');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept no arguments","suites":["@jupyterlab/observables","ModelDB","#constructor()"],"updatePoint":{"line":93,"column":36},"line":93,"code":"      it('should accept no arguments', () => {\n        const db = new ModelDB();\n        expect(db instanceof ModelDB).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept a basePath","suites":["@jupyterlab/observables","ModelDB","#constructor()"],"updatePoint":{"line":98,"column":34},"line":98,"code":"      it('should accept a basePath', () => {\n        const db = new ModelDB({ basePath: 'base' });\n        expect(db instanceof ModelDB).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept a baseDB","suites":["@jupyterlab/observables","ModelDB","#constructor()"],"updatePoint":{"line":103,"column":32},"line":103,"code":"      it('should accept a baseDB', () => {\n        const base = new ModelDB();\n        const db = new ModelDB({ baseDB: base });\n        expect(db instanceof ModelDB).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should test whether it is disposed","suites":["@jupyterlab/observables","ModelDB","#isDisposed"],"updatePoint":{"line":111,"column":44},"line":111,"code":"      it('should test whether it is disposed', () => {\n        const db = new ModelDB();\n        expect(db.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return an empty string for a model without a baseDB","suites":["@jupyterlab/observables","ModelDB","#basePath"],"updatePoint":{"line":120,"column":68},"line":120,"code":"      it('should return an empty string for a model without a baseDB', () => {\n        const db = new ModelDB();\n        expect(db.basePath).toBe('');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the base path","suites":["@jupyterlab/observables","ModelDB","#basePath"],"updatePoint":{"line":125,"column":37},"line":125,"code":"      it('should return the base path', () => {\n        const db = new ModelDB({ basePath: 'base' });\n        expect(db.basePath).toBe('base');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return false for an in-memory database","suites":["@jupyterlab/observables","ModelDB","#isPrepopulated"],"updatePoint":{"line":132,"column":55},"line":132,"code":"      it('should return false for an in-memory database', () => {\n        const db = new ModelDB();\n        expect(db.isPrepopulated).toBe(false);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return false for an in-memory database","suites":["@jupyterlab/observables","ModelDB","#isCollaborative"],"updatePoint":{"line":139,"column":55},"line":139,"code":"      it('should return false for an in-memory database', () => {\n        const db = new ModelDB();\n        expect(db.isCollaborative).toBe(false);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should resolve immediately for an in-memory database","suites":["@jupyterlab/observables","ModelDB","#connected"],"updatePoint":{"line":146,"column":62},"line":146,"code":"      it('should resolve immediately for an in-memory database', async () => {\n        const db = new ModelDB();\n        await expect(db.connected).resolves.not.toThrow();\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should get a value that exists at a path","suites":["@jupyterlab/observables","ModelDB","#get"],"updatePoint":{"line":153,"column":50},"line":153,"code":"      it('should get a value that exists at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        const value2 = db.get('value');\n        expect(value2).toBe(value);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return undefined for a value that does not exist","suites":["@jupyterlab/observables","ModelDB","#get"],"updatePoint":{"line":160,"column":65},"line":160,"code":"      it('should return undefined for a value that does not exist', () => {\n        const db = new ModelDB();\n        expect(db.get('value')).toBeUndefined();\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return true if a value exists at a path","suites":["@jupyterlab/observables","ModelDB","#has"],"updatePoint":{"line":167,"column":56},"line":167,"code":"      it('should return true if a value exists at a path', () => {\n        const db = new ModelDB();\n        db.createValue('value');\n        expect(db.has('value')).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return false for a value that does not exist","suites":["@jupyterlab/observables","ModelDB","#has"],"updatePoint":{"line":173,"column":61},"line":173,"code":"      it('should return false for a value that does not exist', () => {\n        const db = new ModelDB();\n        expect(db.has('value')).toBe(false);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an ObservableString`","suites":["@jupyterlab/observables","ModelDB","#createString"],"updatePoint":{"line":180,"column":44},"line":180,"code":"      it('should create an ObservableString`', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        expect(str instanceof ObservableString).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be able to retrieve that string using `get`","suites":["@jupyterlab/observables","ModelDB","#createString"],"updatePoint":{"line":186,"column":60},"line":186,"code":"      it('should be able to retrieve that string using `get`', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        expect(db.get('str')).toBe(str);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an ObservableUndoableList`","suites":["@jupyterlab/observables","ModelDB","#createList"],"updatePoint":{"line":194,"column":50},"line":194,"code":"      it('should create an ObservableUndoableList`', () => {\n        const db = new ModelDB();\n        const str = db.createList('vec');\n        expect(str instanceof ObservableUndoableList).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be able to retrieve that vector using `get`","suites":["@jupyterlab/observables","ModelDB","#createList"],"updatePoint":{"line":200,"column":60},"line":200,"code":"      it('should be able to retrieve that vector using `get`', () => {\n        const db = new ModelDB();\n        const vec = db.createList('vec');\n        expect(db.get('vec')).toBe(vec);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an ObservableMap`","suites":["@jupyterlab/observables","ModelDB","#createMap"],"updatePoint":{"line":208,"column":41},"line":208,"code":"      it('should create an ObservableMap`', () => {\n        const db = new ModelDB();\n        const map = db.createMap('map');\n        expect(map instanceof ObservableJSON).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be able to retrieve that map using `get`","suites":["@jupyterlab/observables","ModelDB","#createMap"],"updatePoint":{"line":214,"column":57},"line":214,"code":"      it('should be able to retrieve that map using `get`', () => {\n        const db = new ModelDB();\n        const map = db.createMap('map');\n        expect(db.get('map')).toBe(map);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an ObservableValue`","suites":["@jupyterlab/observables","ModelDB","#createValue"],"updatePoint":{"line":222,"column":43},"line":222,"code":"      it('should create an ObservableValue`', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        expect(value instanceof ObservableValue).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be able to retrieve that value using `get`","suites":["@jupyterlab/observables","ModelDB","#createValue"],"updatePoint":{"line":228,"column":59},"line":228,"code":"      it('should be able to retrieve that value using `get`', () => {\n        const db = new ModelDB();\n        const value = db.createString('value');\n        expect(db.get('value')).toBe(value);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set a value at a path","suites":["@jupyterlab/observables","ModelDB","#setValue"],"updatePoint":{"line":236,"column":38},"line":236,"code":"      it('should set a value at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        db.setValue('value', 'set');\n        expect(value.get()).toBe('set');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should get a value at a path","suites":["@jupyterlab/observables","ModelDB","#getValue"],"updatePoint":{"line":245,"column":38},"line":245,"code":"      it('should get a value at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        value.set('set');\n        expect(db.getValue('value')).toBe('set');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should should return a ModelDB","suites":["@jupyterlab/observables","ModelDB","#view"],"updatePoint":{"line":254,"column":40},"line":254,"code":"      it('should should return a ModelDB', () => {\n        const db = new ModelDB();\n        const view = db.view('');\n        expect(view instanceof ModelDB).toBe(true);\n        expect(view === db).toBe(false);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set the baseDB path on the view","suites":["@jupyterlab/observables","ModelDB","#view"],"updatePoint":{"line":261,"column":48},"line":261,"code":"      it('should set the baseDB path on the view', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n        expect(view.basePath).toBe('base');\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return a view onto the base ModelDB","suites":["@jupyterlab/observables","ModelDB","#view"],"updatePoint":{"line":267,"column":52},"line":267,"code":"      it('should return a view onto the base ModelDB', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n\n        db.createString('base.str1');\n        expect(db.get('base.str1')).toBe(view.get('str1'));\n\n        view.createString('str2');\n        expect(db.get('base.str2')).toBe(view.get('str2'));\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be stackable","suites":["@jupyterlab/observables","ModelDB","#view"],"updatePoint":{"line":278,"column":29},"line":278,"code":"      it('should be stackable', () => {\n        const db = new ModelDB();\n        const view = db.view('one');\n        const viewView = view.view('two');\n\n        expect(view.basePath).toBe('one');\n        expect(viewView.basePath).toBe('two');\n\n        viewView.createString('str');\n        expect(viewView.get('str')).toBe(view.get('two.str'));\n        expect(viewView.get('str')).toBe(db.get('one.two.str'));\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should dispose of the resources used by the model","suites":["@jupyterlab/observables","ModelDB","#dispose"],"updatePoint":{"line":293,"column":59},"line":293,"code":"      it('should dispose of the resources used by the model', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        const view = db.view('base');\n        const str2 = view.createString('str');\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n        expect(view.isDisposed).toBe(false);\n        expect(str2.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n        expect(str.isDisposed).toBe(true);\n        expect(view.isDisposed).toBe(true);\n        expect(str2.isDisposed).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should not dispose of resources in base databases","suites":["@jupyterlab/observables","ModelDB","#dispose"],"updatePoint":{"line":309,"column":59},"line":309,"code":"      it('should not dispose of resources in base databases', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n        const str = db.createString('str');\n        const str2 = view.createString('str');\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n        expect(view.isDisposed).toBe(false);\n        expect(str2.isDisposed).toBe(false);\n        view.dispose();\n        expect(view.isDisposed).toBe(true);\n        expect(str2.isDisposed).toBe(true);\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be safe to call more than once","suites":["@jupyterlab/observables","ModelDB","#dispose"],"updatePoint":{"line":325,"column":47},"line":325,"code":"      it('should be safe to call more than once', () => {\n        const db = new ModelDB();\n        expect(db.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n      });","file":"modeldb.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an observable JSON object","suites":["@jupyterlab/observables","ObservableJSON","#constructor()"],"updatePoint":{"line":9,"column":49},"line":9,"code":"      it('should create an observable JSON object', () => {\n        const item = new ObservableJSON();\n        expect(item).toBeInstanceOf(ObservableJSON);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept initial values","suites":["@jupyterlab/observables","ObservableJSON","#constructor()"],"updatePoint":{"line":14,"column":38},"line":14,"code":"      it('should accept initial values', () => {\n        const item = new ObservableJSON({\n          values: { foo: 1, bar: 'baz' }\n        });\n        expect(item).toBeInstanceOf(ObservableJSON);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should serialize the model to JSON","suites":["@jupyterlab/observables","ObservableJSON","#toJSON()"],"updatePoint":{"line":23,"column":44},"line":23,"code":"      it('should serialize the model to JSON', () => {\n        const item = new ObservableJSON();\n        item.set('foo', 1);\n        expect(item.toJSON()['foo']).toBe(1);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return a copy of the data","suites":["@jupyterlab/observables","ObservableJSON","#toJSON()"],"updatePoint":{"line":29,"column":42},"line":29,"code":"      it('should return a copy of the data', () => {\n        const item = new ObservableJSON();\n        item.set('foo', { bar: 1 });\n        const value = item.toJSON();\n        value['bar'] = 2;\n        expect((item.get('foo') as any)['bar']).toBe(1);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create a new message","suites":["@jupyterlab/observables","ObservableJSON.ChangeMessage","#constructor()"],"updatePoint":{"line":41,"column":37},"line":41,"code":"      it('should create a new message', () => {\n        const message = new ObservableJSON.ChangeMessage('jsonvalue-changed', {\n          key: 'foo',\n          type: 'add',\n          oldValue: 1,\n          newValue: 2\n        });\n        expect(message).toBeInstanceOf(ObservableJSON.ChangeMessage);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be the args of the message","suites":["@jupyterlab/observables","ObservableJSON.ChangeMessage","#args"],"updatePoint":{"line":53,"column":43},"line":53,"code":"      it('should be the args of the message', () => {\n        const args: IObservableJSON.IChangedArgs = {\n          key: 'foo',\n          type: 'add',\n          oldValue: 'ho',\n          newValue: 'hi'\n        };\n        const message = new ObservableJSON.ChangeMessage(\n          'jsonvalue-changed',\n          args\n        );\n        expect(message.args).toBe(args);\n      });","file":"observablejson.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept no arguments","suites":["@jupyterlab/observables","ObservableList","#constructor()"],"updatePoint":{"line":10,"column":36},"line":10,"code":"      it('should accept no arguments', () => {\n        const value = new ObservableList<number>();\n        expect(value instanceof ObservableList).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept an array argument","suites":["@jupyterlab/observables","ObservableList","#constructor()"],"updatePoint":{"line":15,"column":41},"line":15,"code":"      it('should accept an array argument', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value instanceof ObservableList).toBe(true);\n        expect(toArray(value)).toEqual([1, 2, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `List`","suites":["@jupyterlab/observables","ObservableList","#type"],"updatePoint":{"line":23,"column":30},"line":23,"code":"      it('should return `List`', () => {\n        const value = new ObservableList<number>();\n        expect(value.type).toBe('List');\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be emitted when the list changes state","suites":["@jupyterlab/observables","ObservableList","#changed"],"updatePoint":{"line":30,"column":55},"line":30,"code":"      it('should be emitted when the list changes state', () => {\n        let called = false;\n        const value = new ObservableList<number>();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.insert(0, 1);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should have value changed args","suites":["@jupyterlab/observables","ObservableList","#changed"],"updatePoint":{"line":40,"column":40},"line":40,"code":"      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableList<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(0);\n          expect(args.oldIndex).toBe(-1);\n          expect(args.newValues[0]).toBe(1);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.push(1);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should test whether the list is disposed","suites":["@jupyterlab/observables","ObservableList","#isDisposed"],"updatePoint":{"line":58,"column":50},"line":58,"code":"      it('should test whether the list is disposed', () => {\n        const value = new ObservableList<number>();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should dispose of the resources held by the list","suites":["@jupyterlab/observables","ObservableList","#dispose()"],"updatePoint":{"line":67,"column":58},"line":67,"code":"      it('should dispose of the resources held by the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should get the value at the specified index","suites":["@jupyterlab/observables","ObservableList","#get()"],"updatePoint":{"line":75,"column":53},"line":75,"code":"      it('should get the value at the specified index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.get(1)).toBe(2);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set the item at a specific index","suites":["@jupyterlab/observables","ObservableList","#set()"],"updatePoint":{"line":82,"column":49},"line":82,"code":"      it('should set the item at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.set(1, 4);\n        expect(toArray(value)).toEqual([1, 4, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#set()"],"updatePoint":{"line":88,"column":41},"line":88,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.set(1, 4);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should add an item to the end of the list","suites":["@jupyterlab/observables","ObservableList","#push()"],"updatePoint":{"line":106,"column":51},"line":106,"code":"      it('should add an item to the end of the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.push(4);\n        expect(toArray(value)).toEqual([1, 2, 3, 4]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the new length of the list","suites":["@jupyterlab/observables","ObservableList","#push()"],"updatePoint":{"line":112,"column":50},"line":112,"code":"      it('should return the new length of the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.push(4)).toBe(4);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#push()"],"updatePoint":{"line":117,"column":41},"line":117,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(3);\n          expect(args.oldIndex).toBe(-1);\n          expect(args.oldValues.length).toBe(0);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.push(4);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should insert an item into the list at a specific index","suites":["@jupyterlab/observables","ObservableList","#insert()"],"updatePoint":{"line":135,"column":65},"line":135,"code":"      it('should insert an item into the list at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.insert(1, 4);\n        expect(toArray(value)).toEqual([1, 4, 2, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#insert()"],"updatePoint":{"line":141,"column":41},"line":141,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(-2);\n          expect(args.oldValues.length).toBe(0);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.insert(1, 4);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should move an item from one index to another","suites":["@jupyterlab/observables","ObservableList","#move()"],"updatePoint":{"line":159,"column":55},"line":159,"code":"      it('should move an item from one index to another', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.move(1, 2);\n        expect(toArray(value)).toEqual([1, 3, 2]);\n        value.move(2, 0);\n        expect(toArray(value)).toEqual([2, 1, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#move()"],"updatePoint":{"line":167,"column":41},"line":167,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('move');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(0);\n          expect(args.oldValues[0]).toBe(1);\n          expect(args.newValues[0]).toBe(1);\n          called = true;\n        });\n        value.move(0, 1);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove the first occurrence of a specific item from the list","suites":["@jupyterlab/observables","ObservableList","#removeValue()"],"updatePoint":{"line":186,"column":77},"line":186,"code":"      it('should remove the first occurrence of a specific item from the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.removeValue(1);\n        expect(toArray(value)).toEqual([2, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the index occupied by the item","suites":["@jupyterlab/observables","ObservableList","#removeValue()"],"updatePoint":{"line":192,"column":54},"line":192,"code":"      it('should return the index occupied by the item', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.removeValue(1)).toBe(0);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `-1` if the item is not in the list","suites":["@jupyterlab/observables","ObservableList","#removeValue()"],"updatePoint":{"line":197,"column":59},"line":197,"code":"      it('should return `-1` if the item is not in the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.removeValue(10)).toBe(-1);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#removeValue()"],"updatePoint":{"line":202,"column":41},"line":202,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.removeValue(2);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove the item at a specific index","suites":["@jupyterlab/observables","ObservableList","#remove()"],"updatePoint":{"line":221,"column":52},"line":221,"code":"      it('should remove the item at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.remove(1);\n        expect(toArray(value)).toEqual([1, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the item at the specified index","suites":["@jupyterlab/observables","ObservableList","#remove()"],"updatePoint":{"line":227,"column":55},"line":227,"code":"      it('should return the item at the specified index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.remove(1)).toBe(2);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `undefined` if the index is out of range","suites":["@jupyterlab/observables","ObservableList","#remove()"],"updatePoint":{"line":232,"column":64},"line":232,"code":"      it('should return `undefined` if the index is out of range', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.remove(10)).toBeUndefined();\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#remove()"],"updatePoint":{"line":237,"column":41},"line":237,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.remove(1);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove all items from the list","suites":["@jupyterlab/observables","ObservableList","#clear()"],"updatePoint":{"line":256,"column":47},"line":256,"code":"      it('should remove all items from the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.clear();\n        expect(value.length).toBe(0);\n        value.clear();\n        expect(value.length).toBe(0);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#clear()"],"updatePoint":{"line":265,"column":41},"line":265,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(0);\n          expect(args.oldIndex).toBe(0);\n          expect(toArray(args.oldValues)).toEqual(values);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should push an array of items to the end of the list","suites":["@jupyterlab/observables","ObservableList","#pushAll()"],"updatePoint":{"line":284,"column":62},"line":284,"code":"      it('should push an array of items to the end of the list', () => {\n        const value = new ObservableList<number>({ values: [1] });\n        value.pushAll([2, 3, 4]);\n        expect(toArray(value)).toEqual([1, 2, 3, 4]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the new length of the list","suites":["@jupyterlab/observables","ObservableList","#pushAll()"],"updatePoint":{"line":290,"column":50},"line":290,"code":"      it('should return the new length of the list', () => {\n        const value = new ObservableList<number>({ values: [1] });\n        expect(value.pushAll([2, 3, 4])).toBe(4);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#pushAll()"],"updatePoint":{"line":295,"column":41},"line":295,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(3);\n          expect(args.oldIndex).toBe(-1);\n          expect(toArray(args.newValues)).toEqual([4, 5, 6]);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.pushAll([4, 5, 6]);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should push an array of items into a list","suites":["@jupyterlab/observables","ObservableList","#insertAll()"],"updatePoint":{"line":313,"column":51},"line":313,"code":"      it('should push an array of items into a list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.insertAll(1, [2, 3, 4]);\n        expect(toArray(value)).toEqual([1, 2, 3, 4, 2, 3]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#insertAll()"],"updatePoint":{"line":319,"column":41},"line":319,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(-2);\n          expect(toArray(args.newValues)).toEqual([4, 5, 6]);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.insertAll(1, [4, 5, 6]);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove a range of items from the list","suites":["@jupyterlab/observables","ObservableList","#removeRange()"],"updatePoint":{"line":337,"column":54},"line":337,"code":"      it('should remove a range of items from the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.removeRange(1, 3);\n        expect(toArray(value)).toEqual([1, 4, 5, 6]);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the new length of the list","suites":["@jupyterlab/observables","ObservableList","#removeRange()"],"updatePoint":{"line":344,"column":50},"line":344,"code":"      it('should return the new length of the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        expect(value.removeRange(1, 3)).toBe(4);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableList","#removeRange()"],"updatePoint":{"line":350,"column":41},"line":350,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(toArray(args.oldValues)).toEqual([2, 3]);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.removeRange(1, 3);\n        expect(called).toBe(true);\n      });","file":"observablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept no arguments","suites":["@jupyterlab/observables","ObservableMap","#constructor()"],"updatePoint":{"line":9,"column":36},"line":9,"code":"      it('should accept no arguments', () => {\n        const value = new ObservableMap<number>();\n        expect(value instanceof ObservableMap).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `Map`","suites":["@jupyterlab/observables","ObservableMap","#type"],"updatePoint":{"line":16,"column":29},"line":16,"code":"      it('should return `Map`', () => {\n        const value = new ObservableMap<number>();\n        expect(value.type).toBe('Map');\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the number of entries in the map","suites":["@jupyterlab/observables","ObservableMap","#size"],"updatePoint":{"line":23,"column":56},"line":23,"code":"      it('should return the number of entries in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        expect(value.size).toBe(2);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be emitted when the map changes state","suites":["@jupyterlab/observables","ObservableMap","#changed"],"updatePoint":{"line":32,"column":54},"line":32,"code":"      it('should be emitted when the map changes state', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.set('entry', 1);\n        expect(called).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should have value changed args","suites":["@jupyterlab/observables","ObservableMap","#changed"],"updatePoint":{"line":42,"column":40},"line":42,"code":"      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newValue).toBe(0);\n          expect(args.oldValue).toBeUndefined();\n          expect(args.key).toBe('entry');\n          called = true;\n        });\n        value.set('entry', 0);\n        expect(called).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should test whether the map is disposed","suites":["@jupyterlab/observables","ObservableMap","#isDisposed"],"updatePoint":{"line":59,"column":49},"line":59,"code":"      it('should test whether the map is disposed', () => {\n        const value = new ObservableMap<number>();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should dispose of the resources held by the map","suites":["@jupyterlab/observables","ObservableMap","#dispose()"],"updatePoint":{"line":68,"column":57},"line":68,"code":"      it('should dispose of the resources held by the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set the item at a specific key","suites":["@jupyterlab/observables","ObservableMap","#set()"],"updatePoint":{"line":78,"column":47},"line":78,"code":"      it('should set the item at a specific key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('one')).toBe(1);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the old value for that key","suites":["@jupyterlab/observables","ObservableMap","#set()"],"updatePoint":{"line":84,"column":50},"line":84,"code":"      it('should return the old value for that key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        const x = value.set('one', 1.01);\n        expect(x).toBe(1);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableMap","#set()"],"updatePoint":{"line":91,"column":41},"line":91,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newValue).toBe(1);\n          expect(args.oldValue).toBeUndefined();\n          expect(args.key).toBe('one');\n          called = true;\n        });\n        value.set('one', 1);\n        expect(called).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should get the value for a key","suites":["@jupyterlab/observables","ObservableMap","#get()"],"updatePoint":{"line":108,"column":40},"line":108,"code":"      it('should get the value for a key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('one')).toBe(1);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return undefined if the key does not exist","suites":["@jupyterlab/observables","ObservableMap","#get()"],"updatePoint":{"line":114,"column":59},"line":114,"code":"      it('should return undefined if the key does not exist', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('two')).toBeUndefined();\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should whether the key exists in a map","suites":["@jupyterlab/observables","ObservableMap","#has()"],"updatePoint":{"line":122,"column":48},"line":122,"code":"      it('should whether the key exists in a map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.has('one')).toBe(true);\n        expect(value.has('two')).toBe(false);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return a list of the keys in the map","suites":["@jupyterlab/observables","ObservableMap","#keys()"],"updatePoint":{"line":131,"column":53},"line":131,"code":"      it('should return a list of the keys in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        const keys = value.keys();\n        expect(keys).toEqual(['one', 'two', 'three']);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return a list of the values in the map","suites":["@jupyterlab/observables","ObservableMap","#values()"],"updatePoint":{"line":142,"column":55},"line":142,"code":"      it('should return a list of the values in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        const keys = value.values();\n        expect(keys).toEqual([1, 2, 3]);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove an item from the map","suites":["@jupyterlab/observables","ObservableMap","#delete()"],"updatePoint":{"line":153,"column":44},"line":153,"code":"      it('should remove an item from the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        expect(value.get('two')).toBe(2);\n        value.delete('two');\n        expect(value.get('two')).toBeUndefined();\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return the value of the key it removed","suites":["@jupyterlab/observables","ObservableMap","#delete()"],"updatePoint":{"line":163,"column":55},"line":163,"code":"      it('should return the value of the key it removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.delete('one')).toBe(1);\n        expect(value.delete('one')).toBeUndefined();\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal if actually removed","suites":["@jupyterlab/observables","ObservableMap","#delete()"],"updatePoint":{"line":170,"column":61},"line":170,"code":"      it('should trigger a changed signal if actually removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        let called = false;\n\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('two');\n          expect(args.oldValue).toBe(2);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n        value.delete('two');\n        expect(called).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should not trigger a changed signal if not actually removed","suites":["@jupyterlab/observables","ObservableMap","#delete()"],"updatePoint":{"line":189,"column":69},"line":189,"code":"      it('should not trigger a changed signal if not actually removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('three', 3);\n        let called = false;\n\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('two');\n          expect(args.oldValue).toBe(2);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n\n        // 'two' is not in the map\n        value.delete('two');\n        expect(called).toBe(false);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove all items from the map","suites":["@jupyterlab/observables","ObservableMap","#clear()"],"updatePoint":{"line":211,"column":46},"line":211,"code":"      it('should remove all items from the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        value.clear();\n        expect(value.size).toBe(0);\n        value.clear();\n        expect(value.size).toBe(0);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableMap","#clear()"],"updatePoint":{"line":222,"column":41},"line":222,"code":"      it('should trigger a changed signal', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        let called = false;\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('one');\n          expect(args.oldValue).toBe(1);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });","file":"observablemap.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept no arguments","suites":["@jupyterlab/observables","ObservableString","#constructor()"],"updatePoint":{"line":9,"column":36},"line":9,"code":"      it('should accept no arguments', () => {\n        const value = new ObservableString();\n        expect(value instanceof ObservableString).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should accept a string argument","suites":["@jupyterlab/observables","ObservableString","#constructor()"],"updatePoint":{"line":14,"column":41},"line":14,"code":"      it('should accept a string argument', () => {\n        const value = new ObservableString('hello');\n        expect(value instanceof ObservableString).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should initialize the string value","suites":["@jupyterlab/observables","ObservableString","#constructor()"],"updatePoint":{"line":19,"column":44},"line":19,"code":"      it('should initialize the string value', () => {\n        const value = new ObservableString('hello');\n        expect(value.text).toEqual('hello');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return `String`","suites":["@jupyterlab/observables","ObservableString","#type"],"updatePoint":{"line":26,"column":32},"line":26,"code":"      it('should return `String`', () => {\n        const value = new ObservableString();\n        expect(value.type).toBe('String');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should be emitted when the string changes","suites":["@jupyterlab/observables","ObservableString","#changed"],"updatePoint":{"line":33,"column":51},"line":33,"code":"      it('should be emitted when the string changes', () => {\n        let called = false;\n        const value = new ObservableString();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.text = 'change';\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should have value changed args","suites":["@jupyterlab/observables","ObservableString","#changed"],"updatePoint":{"line":43,"column":40},"line":43,"code":"      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableString();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(3);\n          expect(args.value).toBe('new');\n          called = true;\n        });\n        value.text = 'new';\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should test whether the string is disposed","suites":["@jupyterlab/observables","ObservableString","#isDisposed"],"updatePoint":{"line":60,"column":52},"line":60,"code":"      it('should test whether the string is disposed', () => {\n        const value = new ObservableString();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should set the item at a specific index","suites":["@jupyterlab/observables","ObservableString","#setter()"],"updatePoint":{"line":69,"column":49},"line":69,"code":"      it('should set the item at a specific index', () => {\n        const value = new ObservableString('old');\n        value.text = 'new';\n        expect(value.text).toEqual('new');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableString","#setter()"],"updatePoint":{"line":75,"column":41},"line":75,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('old');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(3);\n          expect(args.value).toBe('new');\n          called = true;\n        });\n        value.text = 'new';\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should insert an substring into the string at a specific index","suites":["@jupyterlab/observables","ObservableString","#insert()"],"updatePoint":{"line":92,"column":72},"line":92,"code":"      it('should insert an substring into the string at a specific index', () => {\n        const value = new ObservableString('one three');\n        value.insert(4, 'two ');\n        expect(value.text).toEqual('one two three');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableString","#insert()"],"updatePoint":{"line":98,"column":41},"line":98,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('one three');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('insert');\n          expect(args.start).toBe(4);\n          expect(args.end).toBe(8);\n          expect(args.value).toBe('two ');\n          called = true;\n        });\n        value.insert(4, 'two ');\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should remove a substring from the string","suites":["@jupyterlab/observables","ObservableString","#remove()"],"updatePoint":{"line":115,"column":51},"line":115,"code":"      it('should remove a substring from the string', () => {\n        const value = new ObservableString('one two two three');\n        value.remove(4, 8);\n        expect(value.text).toEqual('one two three');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableString","#remove()"],"updatePoint":{"line":121,"column":41},"line":121,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('one two two three');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.start).toBe(4);\n          expect(args.end).toBe(8);\n          expect(args.value).toBe('two ');\n          called = true;\n        });\n        value.remove(4, 8);\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should empty the string","suites":["@jupyterlab/observables","ObservableString","#clear()"],"updatePoint":{"line":138,"column":33},"line":138,"code":"      it('should empty the string', () => {\n        const value = new ObservableString('full');\n        value.clear();\n        expect(value.text.length).toBe(0);\n        expect(value.text).toBe('');\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should trigger a changed signal","suites":["@jupyterlab/observables","ObservableString","#clear()"],"updatePoint":{"line":145,"column":41},"line":145,"code":"      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('full');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(0);\n          expect(args.value).toBe('');\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });","file":"observablestring.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create a new ObservableUndoableList","suites":["@jupyterlab/observables","ObservableUndoableList","#constructor"],"updatePoint":{"line":38,"column":52},"line":38,"code":"      it('should create a new ObservableUndoableList', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list).toBeInstanceOf(ObservableUndoableList);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return false if there is no history","suites":["@jupyterlab/observables","ObservableUndoableList","#canRedo"],"updatePoint":{"line":45,"column":52},"line":45,"code":"      it('should return false if there is no history', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list.canRedo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return true if there is an undo that can be redone","suites":["@jupyterlab/observables","ObservableUndoableList","#canRedo"],"updatePoint":{"line":50,"column":67},"line":50,"code":"      it('should return true if there is an undo that can be redone', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(new Test(value));\n        list.undo();\n        expect(list.canRedo).toBe(true);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return false if there is no history","suites":["@jupyterlab/observables","ObservableUndoableList","#canUndo"],"updatePoint":{"line":59,"column":52},"line":59,"code":"      it('should return false if there is no history', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list.canUndo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should return true if there is a change that can be undone","suites":["@jupyterlab/observables","ObservableUndoableList","#canUndo"],"updatePoint":{"line":64,"column":68},"line":64,"code":"      it('should return true if there is a change that can be undone', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        expect(list.canUndo).toBe(true);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should dispose of the resources used by the list","suites":["@jupyterlab/observables","ObservableUndoableList","#dispose()"],"updatePoint":{"line":72,"column":58},"line":72,"code":"      it('should dispose of the resources used by the list', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.dispose();\n        expect(list.isDisposed).toBe(true);\n        list.dispose();\n        expect(list.isDisposed).toBe(true);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should begin a compound operation","suites":["@jupyterlab/observables","ObservableUndoableList","#beginCompoundOperation()"],"updatePoint":{"line":82,"column":43},"line":82,"code":"      it('should begin a compound operation', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation();\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(true);\n        list.undo();\n        expect(list.canUndo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should not be undoable if isUndoAble is set to false","suites":["@jupyterlab/observables","ObservableUndoableList","#beginCompoundOperation()"],"updatePoint":{"line":93,"column":62},"line":93,"code":"      it('should not be undoable if isUndoAble is set to false', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation(false);\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should end a compound operation","suites":["@jupyterlab/observables","ObservableUndoableList","#endCompoundOperation()"],"updatePoint":{"line":104,"column":41},"line":104,"code":"      it('should end a compound operation', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation();\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(true);\n        list.undo();\n        expect(list.canUndo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a push","suites":["@jupyterlab/observables","ObservableUndoableList","#undo()"],"updatePoint":{"line":117,"column":28},"line":117,"code":"      it('should undo a push', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.undo();\n        expect(list.length).toBe(0);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a pushAll","suites":["@jupyterlab/observables","ObservableUndoableList","#undo()"],"updatePoint":{"line":124,"column":31},"line":124,"code":"      it('should undo a pushAll', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.undo();\n        expect(list.length).toBe(0);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a remove","suites":["@jupyterlab/observables","ObservableUndoableList","#undo()"],"updatePoint":{"line":131,"column":30},"line":131,"code":"      it('should undo a remove', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.remove(0);\n        list.undo();\n        expect(list.length).toBe(2);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a removeRange","suites":["@jupyterlab/observables","ObservableUndoableList","#undo()"],"updatePoint":{"line":139,"column":35},"line":139,"code":"      it('should undo a removeRange', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ]);\n        list.removeRange(1, 3);\n        list.undo();\n        expect(list.length).toBe(6);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a move","suites":["@jupyterlab/observables","ObservableUndoableList","#undo()"],"updatePoint":{"line":154,"column":28},"line":154,"code":"      it('should undo a move', () => {\n        const items = [\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ];\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll(items);\n        list.move(1, 2);\n        list.undo();\n        expect((list.get(1) as any)['count']).toBe((items[1] as any)['count']);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should redo a push","suites":["@jupyterlab/observables","ObservableUndoableList","#redo()"],"updatePoint":{"line":169,"column":28},"line":169,"code":"      it('should redo a push', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(1);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should redo a pushAll","suites":["@jupyterlab/observables","ObservableUndoableList","#redo()"],"updatePoint":{"line":177,"column":31},"line":177,"code":"      it('should redo a pushAll', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(2);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should redo a remove","suites":["@jupyterlab/observables","ObservableUndoableList","#redo()"],"updatePoint":{"line":185,"column":30},"line":185,"code":"      it('should redo a remove', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.remove(0);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(1);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should redo a removeRange","suites":["@jupyterlab/observables","ObservableUndoableList","#redo()"],"updatePoint":{"line":194,"column":35},"line":194,"code":"      it('should redo a removeRange', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ]);\n        list.removeRange(1, 3);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(4);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should undo a move","suites":["@jupyterlab/observables","ObservableUndoableList","#redo()"],"updatePoint":{"line":210,"column":28},"line":210,"code":"      it('should undo a move', () => {\n        const items = [\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ];\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll(items);\n        list.move(1, 2);\n        list.undo();\n        list.redo();\n        expect((list.get(2) as any)['count']).toBe((items[1] as any)['count']);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should clear the undo stack","suites":["@jupyterlab/observables","ObservableUndoableList","#clearUndo()"],"updatePoint":{"line":226,"column":37},"line":226,"code":"      it('should clear the undo stack', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.clearUndo();\n        expect(list.canUndo).toBe(false);\n      });","file":"undoablelist.spec.ts","skipped":false,"dir":"packages/observables/test"},{"name":"should create an output area model","suites":["outputarea/model","OutputAreaModel","#constructor()"],"updatePoint":{"line":21,"column":44},"line":21,"code":"      it('should create an output area model', () => {\n        expect(model).toBeInstanceOf(OutputAreaModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should accept options","suites":["outputarea/model","OutputAreaModel","#constructor()"],"updatePoint":{"line":25,"column":31},"line":25,"code":"      it('should accept options', () => {\n        const contentFactory = new OutputAreaModel.ContentFactory();\n        model = new OutputAreaModel({\n          values: NBTestUtils.DEFAULT_OUTPUTS,\n          contentFactory,\n          trusted: true\n        });\n        expect(model.contentFactory).toBe(contentFactory);\n        expect(model.trusted).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be emitted when the model changes","suites":["outputarea/model","OutputAreaModel","#changed"],"updatePoint":{"line":38,"column":50},"line":38,"code":"      it('should be emitted when the model changes', () => {\n        let called = false;\n        model.changed.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('add');\n          expect(args.oldIndex).toBe(-1);\n          expect(args.newIndex).toBe(0);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be emitted when an item changes","suites":["outputarea/model","OutputAreaModel","#stateChanged"],"updatePoint":{"line":54,"column":48},"line":54,"code":"      it('should be emitted when an item changes', () => {\n        let called = false;\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        const output = model.get(0);\n        output.setData({ ...output.data });\n        expect(called).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should get the length of the items in the model","suites":["outputarea/model","OutputAreaModel","#length"],"updatePoint":{"line":69,"column":57},"line":69,"code":"      it('should get the length of the items in the model', () => {\n        expect(model.length).toBe(0);\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(model.length).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be the trusted state of the model","suites":["outputarea/model","OutputAreaModel","#trusted"],"updatePoint":{"line":77,"column":50},"line":77,"code":"      it('should be the trusted state of the model', () => {\n        expect(model.trusted).toBe(false);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should cause all of the cells to `set`","suites":["outputarea/model","OutputAreaModel","#trusted"],"updatePoint":{"line":81,"column":48},"line":81,"code":"      it('should cause all of the cells to `set`', () => {\n        let called = 0;\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[1]);\n        model.changed.connect(() => {\n          called++;\n        });\n        model.trusted = true;\n        expect(called).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be the content factory used by the model","suites":["outputarea/model","OutputAreaModel","#contentFactory"],"updatePoint":{"line":94,"column":57},"line":94,"code":"      it('should be the content factory used by the model', () => {\n        expect(model.contentFactory).toBe(\n          OutputAreaModel.defaultContentFactory\n        );\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should test whether the model is disposed","suites":["outputarea/model","OutputAreaModel","#isDisposed"],"updatePoint":{"line":102,"column":51},"line":102,"code":"      it('should test whether the model is disposed', () => {\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should dispose of the resources used by the model","suites":["outputarea/model","OutputAreaModel","#dispose()"],"updatePoint":{"line":110,"column":59},"line":110,"code":"      it('should dispose of the resources used by the model', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n        expect(model.length).toBe(0);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be safe to call more than once","suites":["outputarea/model","OutputAreaModel","#dispose()"],"updatePoint":{"line":117,"column":47},"line":117,"code":"      it('should be safe to call more than once', () => {\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should get the item at the specified index","suites":["outputarea/model","OutputAreaModel","#get()"],"updatePoint":{"line":125,"column":52},"line":125,"code":"      it('should get the item at the specified index', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        const output = model.get(0);\n        expect(output.type).toBe(NBTestUtils.DEFAULT_OUTPUTS[0].output_type);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should return `undefined` if out of range","suites":["outputarea/model","OutputAreaModel","#get()"],"updatePoint":{"line":131,"column":51},"line":131,"code":"      it('should return `undefined` if out of range', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(model.get(1)).toBeUndefined();\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should add an output","suites":["outputarea/model","OutputAreaModel","#add()"],"updatePoint":{"line":138,"column":30},"line":138,"code":"      it('should add an output', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(model.length).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should consolidate consecutive stream outputs of the same kind","suites":["outputarea/model","OutputAreaModel","#add()"],"updatePoint":{"line":143,"column":72},"line":143,"code":"      it('should consolidate consecutive stream outputs of the same kind', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[1]);\n        expect(model.length).toBe(2);\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[2]);\n        expect(model.length).toBe(2);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should remove carriage returns and backspaces from streams","suites":["outputarea/model","OutputAreaModel","#add()"],"updatePoint":{"line":151,"column":68},"line":151,"code":"      it('should remove carriage returns and backspaces from streams', () => {\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['Jupyter\\rj']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter');\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['\\njj\\bupyter']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter\\njupyter');\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['\\r\\r\\njupyter']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter\\njupyter\\njupyter');\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should clear all of the output","suites":["outputarea/model","OutputAreaModel","#clear()"],"updatePoint":{"line":174,"column":40},"line":174,"code":"      it('should clear all of the output', () => {\n        for (const output of NBTestUtils.DEFAULT_OUTPUTS) {\n          model.add(output);\n        }\n        model.clear();\n        expect(model.length).toBe(0);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should wait for next add if requested","suites":["outputarea/model","OutputAreaModel","#clear()"],"updatePoint":{"line":182,"column":47},"line":182,"code":"      it('should wait for next add if requested', () => {\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        model.clear(true);\n        expect(model.length).toBe(1);\n        model.add(NBTestUtils.DEFAULT_OUTPUTS[1]);\n        expect(model.length).toBe(1);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should deserialize the model from JSON","suites":["outputarea/model","OutputAreaModel","#fromJSON()"],"updatePoint":{"line":192,"column":48},"line":192,"code":"      it('should deserialize the model from JSON', () => {\n        model.clear();\n        model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);\n        expect(model.toJSON().length).toBe(5);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should serialize the model to JSON","suites":["outputarea/model","OutputAreaModel","#toJSON()"],"updatePoint":{"line":200,"column":44},"line":200,"code":"      it('should serialize the model to JSON', () => {\n        expect(model.toJSON()).toEqual([]);\n        model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);\n        expect(model.toJSON().length).toBe(5);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should create an output model","suites":["outputarea/model",".ContentFactory","#createOutputModel()"],"updatePoint":{"line":210,"column":39},"line":210,"code":"      it('should create an output model', () => {\n        const factory = new OutputAreaModel.ContentFactory();\n        const model = factory.createOutputModel({\n          value: NBTestUtils.DEFAULT_OUTPUTS[0]\n        });\n        expect(model).toBeInstanceOf(OutputModel);\n      });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be an instance of ContentFactory","suites":["outputarea/model",".defaultContentFactory"],"updatePoint":{"line":221,"column":47},"line":221,"code":"    it('should be an instance of ContentFactory', () => {\n      expect(OutputAreaModel.defaultContentFactory).toBeInstanceOf(\n        OutputAreaModel.ContentFactory\n      );\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should create an output area widget","suites":["outputarea/widget","OutputArea","#constructor()"],"updatePoint":{"line":75,"column":45},"line":75,"code":"      it('should create an output area widget', () => {\n        expect(widget).toBeInstanceOf(OutputArea);\n        expect(widget.hasClass('jp-OutputArea')).toBe(true);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should take an optional contentFactory","suites":["outputarea/widget","OutputArea","#constructor()"],"updatePoint":{"line":80,"column":48},"line":80,"code":"      it('should take an optional contentFactory', () => {\n        const contentFactory = Object.create(OutputArea.defaultContentFactory);\n        const widget = new OutputArea({ rendermime, contentFactory, model });\n        expect(widget.contentFactory).toBe(contentFactory);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be the model used by the widget","suites":["outputarea/widget","OutputArea","#model"],"updatePoint":{"line":88,"column":48},"line":88,"code":"      it('should be the model used by the widget', () => {\n        expect(widget.model).toBe(model);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be the rendermime instance used by the widget","suites":["outputarea/widget","OutputArea","#rendermime"],"updatePoint":{"line":94,"column":62},"line":94,"code":"      it('should be the rendermime instance used by the widget', () => {\n        expect(widget.rendermime).toBe(rendermime);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be the contentFactory used by the widget","suites":["outputarea/widget","OutputArea","#contentFactory"],"updatePoint":{"line":100,"column":57},"line":100,"code":"      it('should be the contentFactory used by the widget', () => {\n        expect(widget.contentFactory).toBe(OutputArea.defaultContentFactory);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should get the child widget at the specified index","suites":["outputarea/widget","OutputArea","#widgets"],"updatePoint":{"line":106,"column":60},"line":106,"code":"      it('should get the child widget at the specified index', () => {\n        expect(widget.widgets[0]).toBeInstanceOf(Widget);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should get the number of child widgets","suites":["outputarea/widget","OutputArea","#widgets"],"updatePoint":{"line":110,"column":48},"line":110,"code":"      it('should get the number of child widgets', () => {\n        expect(widget.widgets.length).toBe(\n          NBTestUtils.DEFAULT_OUTPUTS.length - 1\n        );\n        widget.model.clear();\n        expect(widget.widgets.length).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should execute code on a kernel and send outputs to the model","suites":["outputarea/widget","OutputArea","#future"],"updatePoint":{"line":133,"column":71},"line":133,"code":"      it('should execute code on a kernel and send outputs to the model', async () => {\n        const future = sessionContext.session!.kernel!.requestExecute({\n          code: CODE\n        });\n        widget.future = future;\n        const reply = await future.done;\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(reply!.content.status).toBe('ok');\n        expect(model.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should clear existing outputs","suites":["outputarea/widget","OutputArea","#future"],"updatePoint":{"line":144,"column":39},"line":144,"code":"      it('should clear existing outputs', async () => {\n        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);\n        const future = sessionContext.session!.kernel!.requestExecute({\n          code: CODE\n        });\n        widget.future = future;\n        const reply = await future.done;\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(model.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should handle an added output","suites":["outputarea/widget","OutputArea","#onModelChanged()"],"updatePoint":{"line":157,"column":39},"line":157,"code":"      it('should handle an added output', () => {\n        widget.model.clear();\n        widget.methods = [];\n        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should handle a clear","suites":["outputarea/widget","OutputArea","#onModelChanged()"],"updatePoint":{"line":167,"column":31},"line":167,"code":"      it('should handle a clear', () => {\n        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);\n        widget.methods = [];\n        widget.model.clear();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(0);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should handle a set","suites":["outputarea/widget","OutputArea","#onModelChanged()"],"updatePoint":{"line":177,"column":29},"line":177,"code":"      it('should handle a set', () => {\n        widget.model.clear();\n        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        widget.methods = [];\n        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should rerender when preferred mimetype changes","suites":["outputarea/widget","OutputArea","#onModelChanged()"],"updatePoint":{"line":188,"column":57},"line":188,"code":"      it('should rerender when preferred mimetype changes', () => {\n        // Add output with both safe and unsafe types\n        widget.model.clear();\n        widget.model.add({\n          output_type: 'display_data',\n          data: {\n            'image/svg+xml':\n              '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\"></svg>',\n            'text/plain': 'hello, world'\n          },\n          metadata: {}\n        });\n        expect(widget.node.innerHTML).toContain('<img src=\"data:image/svg+xml');\n        widget.model.trusted = !widget.model.trusted;\n        expect(widget.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['<img src=\"data:image/svg+xml'])\n        );\n        widget.model.trusted = !widget.model.trusted;\n        expect(widget.node.innerHTML).toContain('<img src=\"data:image/svg+xml');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should rerender when isolation changes","suites":["outputarea/widget","OutputArea","#onModelChanged()"],"updatePoint":{"line":209,"column":48},"line":209,"code":"      it('should rerender when isolation changes', () => {\n        // Add output with both safe and unsafe types\n        widget.model.clear();\n        widget.model.add({\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          }\n        });\n        expect(widget.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['<iframe'])\n        );\n        widget.model.set(0, {\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          },\n          metadata: {\n            isolated: true\n          }\n        });\n        expect(widget.node.innerHTML).toContain('<iframe');\n        widget.model.set(0, {\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          }\n        });\n        expect(widget.node.innerHTML).not.toContain('<iframe');\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should execute code on a kernel and send outputs to the model","suites":["outputarea/widget","OutputArea",".execute()"],"updatePoint":{"line":255,"column":71},"line":255,"code":"      it('should execute code on a kernel and send outputs to the model', async () => {\n        const reply = await OutputArea.execute(CODE, widget, sessionContext);\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(reply!.content.status).toBe('ok');\n        expect(model.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should clear existing outputs","suites":["outputarea/widget","OutputArea",".execute()"],"updatePoint":{"line":262,"column":39},"line":262,"code":"      it('should clear existing outputs', async () => {\n        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);\n        const reply = await OutputArea.execute(CODE, widget, sessionContext);\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(model.length).toBe(1);\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should handle routing of display messages","suites":["outputarea/widget","OutputArea",".execute()"],"updatePoint":{"line":269,"column":51},"line":269,"code":"      it('should handle routing of display messages', async () => {\n        const model0 = new OutputAreaModel({ trusted: true });\n        const widget0 = new LogOutputArea({ rendermime, model: model0 });\n        const model1 = new OutputAreaModel({ trusted: true });\n        const widget1 = new LogOutputArea({ rendermime, model: model1 });\n        const model2 = new OutputAreaModel({ trusted: true });\n        const widget2 = new LogOutputArea({ rendermime, model: model2 });\n\n        const code0 = [\n          'ip = get_ipython()',\n          'from IPython.display import display',\n          'def display_with_id(obj, display_id, update=False):',\n          '  iopub = ip.kernel.iopub_socket',\n          '  session = get_ipython().kernel.session',\n          '  data, md = ip.display_formatter.format(obj)',\n          '  transient = {\"display_id\": display_id}',\n          '  content = {\"data\": data, \"metadata\": md, \"transient\": transient}',\n          '  msg_type = \"update_display_data\" if update else \"display_data\"',\n          '  session.send(iopub, msg_type, content, parent=ip.parent_header)'\n        ].join('\\n');\n        const code1 = [\n          'display(\"above\")',\n          'display_with_id(1, \"here\")',\n          'display(\"below\")'\n        ].join('\\n');\n        const code2 = [\n          'display_with_id(2, \"here\")',\n          'display_with_id(3, \"there\")',\n          'display_with_id(4, \"here\")'\n        ].join('\\n');\n\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const promise0 = OutputArea.execute(code0, widget0, ipySessionContext);\n        const promise1 = OutputArea.execute(code1, widget1, ipySessionContext);\n        await Promise.all([promise0, promise1]);\n        expect(model1.length).toBe(3);\n        expect(model1.toJSON()[1].data).toEqual({ 'text/plain': '1' });\n        await OutputArea.execute(code2, widget2, ipySessionContext);\n\n        expect(model1.length).toBe(3);\n        expect(model1.toJSON()[1].data).toEqual({ 'text/plain': '4' });\n        expect(model2.length).toBe(3);\n        const outputs = model2.toJSON();\n        expect(outputs[0].data).toEqual({ 'text/plain': '4' });\n        expect(outputs[1].data).toEqual({ 'text/plain': '3' });\n        expect(outputs[2].data).toEqual({ 'text/plain': '4' });\n        await ipySessionContext.shutdown();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should stop on an error","suites":["outputarea/widget","OutputArea",".execute()"],"updatePoint":{"line":322,"column":33},"line":322,"code":"      it('should stop on an error', async () => {\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const widget1 = new LogOutputArea({ rendermime, model });\n        const future1 = OutputArea.execute('a++1', widget, ipySessionContext);\n        const future2 = OutputArea.execute('a=1', widget1, ipySessionContext);\n        const reply = await future1;\n        const reply2 = await future2;\n        expect(reply!.content.status).toBe('error');\n        expect(reply2!.content.status).toBe('aborted');\n        expect(model.length).toBe(1);\n        widget1.dispose();\n        await ipySessionContext.shutdown();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should allow an error given \"raises-exception\" metadata tag","suites":["outputarea/widget","OutputArea",".execute()"],"updatePoint":{"line":340,"column":69},"line":340,"code":"      it('should allow an error given \"raises-exception\" metadata tag', async () => {\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const widget1 = new LogOutputArea({ rendermime, model });\n        const metadata = { tags: ['raises-exception'] };\n        const future1 = OutputArea.execute(\n          'a++1',\n          widget,\n          ipySessionContext,\n          metadata\n        );\n        const future2 = OutputArea.execute('a=1', widget1, ipySessionContext);\n        const reply = await future1;\n        const reply2 = await future2;\n        expect(reply!.content.status).toBe('error');\n        expect(reply2!.content.status).toBe('ok');\n        widget1.dispose();\n        await ipySessionContext.shutdown();\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should create an output prompt","suites":["outputarea/widget","OutputArea",".ContentFactory","#createOutputPrompt()"],"updatePoint":{"line":366,"column":42},"line":366,"code":"        it('should create an output prompt', () => {\n          const factory = new OutputArea.ContentFactory();\n          expect(factory.createOutputPrompt().executionCount).toBeNull();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should create a stdin widget","suites":["outputarea/widget","OutputArea",".ContentFactory","#createStdin()"],"updatePoint":{"line":373,"column":40},"line":373,"code":"        it('should create a stdin widget', async () => {\n          const manager = new KernelManager();\n          const kernel = await manager.startNew();\n          const factory = new OutputArea.ContentFactory();\n          const future = kernel.requestExecute({ code: CODE });\n          const options = {\n            prompt: 'hello',\n            password: false,\n            future\n          };\n          expect(factory.createStdin(options)).toBeInstanceOf(Widget);\n          await kernel.shutdown();\n          kernel.dispose();\n        });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should be a `contentFactory` instance","suites":["outputarea/widget","OutputArea",".defaultContentFactory"],"updatePoint":{"line":391,"column":47},"line":391,"code":"      it('should be a `contentFactory` instance', () => {\n        expect(OutputArea.defaultContentFactory).toBeInstanceOf(\n          OutputArea.ContentFactory\n        );\n      });","file":"widget.spec.ts","skipped":false,"dir":"packages/outputarea/test"},{"name":"should have text related mimeTypes","suites":["rendermime/factories","textRendererFactory","#mimeTypes"],"updatePoint":{"line":44,"column":44},"line":44,"code":"      it('should have text related mimeTypes', () => {\n        const mimeTypes = [\n          'text/plain',\n          'application/vnd.jupyter.stdout',\n          'application/vnd.jupyter.stderr'\n        ];\n        expect(textRendererFactory.mimeTypes).toEqual(mimeTypes);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be safe","suites":["rendermime/factories","textRendererFactory","#safe"],"updatePoint":{"line":55,"column":24},"line":55,"code":"      it('should be safe', () => {\n        expect(textRendererFactory.safe).toBe(true);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should output the correct HTML","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"updatePoint":{"line":61,"column":40},"line":61,"code":"      it('should output the correct HTML', async () => {\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, 'x = 2 ** a');\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be re-renderable","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"updatePoint":{"line":70,"column":33},"line":70,"code":"      it('should be re-renderable', async () => {\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, 'x = 2 ** a');\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should output the correct HTML with ansi colors","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"line":80,"code":"      it.each([\n        [\n          'There is no text but \\x1b[01;41;32mtext\\x1b[00m.\\nWoo.',\n          '<pre>There is no text but <span class=\"ansi-green-intense-fg ansi-red-bg ansi-bold\">text</span>.\\nWoo.</pre>'\n        ],\n        [\n          '\\x1b[48;2;185;0;129mwww.example.\\x1b[0m\\x1b[48;2;113;0;119mcom\\x1b[0m',\n          '<pre><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\"><span style=\"background-color:rgb(185,0,129)\">www.example.</span><span style=\"background-color:rgb(113,0,119)\">com</span></a></pre>'\n        ]\n      ])(\n        'should output the correct HTML with ansi colors',\n        async (source, expected) => {\n          const f = textRendererFactory;\n          const mimeType = 'application/vnd.jupyter.console-text';\n          const model = createModel(mimeType, source);\n          const w = f.createRenderer({ mimeType, ...defaultOptions });\n          await w.renderModel(model);\n          expect(w.node.innerHTML).toBe(expected);\n        }\n      );","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should escape inline html","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"updatePoint":{"line":101,"column":35},"line":101,"code":"      it('should escape inline html', async () => {\n        const f = textRendererFactory;\n        const source =\n          'There is no text <script>window.x=1</script> but \\x1b[01;41;32mtext\\x1b[00m.\\nWoo.';\n        const mimeType = 'application/vnd.jupyter.console-text';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(\n          '<pre>There is no text &lt;script&gt;window.x=1&lt;/script&gt; but <span class=\"ansi-green-intense-fg ansi-red-bg ansi-bold\">text</span>.\\nWoo.</pre>'\n        );\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should autolink single URL","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"updatePoint":{"line":114,"column":36},"line":114,"code":"      it('should autolink single URL', async () => {\n        const f = textRendererFactory;\n        const urls = [\n          ['https://example.com', '', ''],\n          ['https://example.com#', '', ''],\n          ['https://example.com/', '', ''],\n          ['www.example.com/', '', ''],\n          ['http://www.quotes.com/foo/', '\"', '\"'],\n          ['http://www.quotes.com/foo/', \"'\", \"'\"],\n          ['http://www.brackets.com/foo', '(', ')'],\n          ['http://www.brackets.com/foo', '{', '}'],\n          ['http://www.brackets.com/foo', '[', ']'],\n          ['http://www.brackets.com/foo', '<', '>'],\n          ['https://ends.with/&gt', '', ''],\n          ['http://www.brackets.com/inv', ')', '('],\n          ['http://www.brackets.com/inv', '}', '{'],\n          ['http://www.brackets.com/inv', ']', '['],\n          ['http://www.brackets.com/inv', '>', '<'],\n          ['https://ends.with/&lt', '', ''],\n          ['http://www.punctuation.com', '', ','],\n          ['http://www.punctuation.com', '', ':'],\n          ['http://www.punctuation.com', '', ';'],\n          ['http://www.punctuation.com', '', '.'],\n          ['http://www.punctuation.com', '', '!'],\n          ['http://www.punctuation.com', '', '?'],\n          ['https://example.com#anchor', '', ''],\n          ['http://localhost:9090/app', '', ''],\n          ['http://localhost:9090/app/', '', ''],\n          ['http://127.0.0.1/test?query=string', '', ''],\n          ['http://127.0.0.1/test?query=string&param=42', '', '']\n        ];\n        await Promise.all(\n          urls.map(async u => {\n            const [url, before, after] = u;\n            const source = `Text with the URL ${before}${url}${after} inside.`;\n            const mimeType = 'text/plain';\n            const model = createModel(mimeType, source);\n            const w = f.createRenderer({ mimeType, ...defaultOptions });\n            const [urlEncoded, beforeEncoded, afterEncoded] = [\n              url,\n              before,\n              after\n            ].map(encodeChars);\n            const prefixedUrl = urlEncoded.startsWith('www.')\n              ? 'https://' + urlEncoded\n              : urlEncoded;\n            await w.renderModel(model);\n            expect(w.node.innerHTML).toBe(\n              `<pre>Text with the URL ${beforeEncoded}<a href=\"${prefixedUrl}\" rel=\"noopener\" target=\"_blank\">${urlEncoded}</a>${afterEncoded} inside.</pre>`\n            );\n          })\n        );\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should autolink multiple URLs","suites":["rendermime/factories","textRendererFactory","#createRenderer()"],"updatePoint":{"line":169,"column":37},"line":169,"code":"    it('should autolink multiple URLs', async () => {\n      const source = 'www.example.com\\nwww.python.org';\n      const expected =\n        '<pre><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\">www.example.com</a>\\n<a href=\"https://www.python.org\" rel=\"noopener\" target=\"_blank\">www.python.org</a></pre>';\n      const f = textRendererFactory;\n      const mimeType = 'text/plain';\n      const model = createModel(mimeType, source);\n      const w = f.createRenderer({ mimeType, ...defaultOptions });\n      await w.renderModel(model);\n      expect(w.node.innerHTML).toBe(expected);\n    });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should have the text/latex mimeType","suites":["rendermime/factories","latexRendererFactory","#mimeTypes"],"updatePoint":{"line":184,"column":45},"line":184,"code":"      it('should have the text/latex mimeType', () => {\n        expect(latexRendererFactory.mimeTypes).toEqual(['text/latex']);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be safe","suites":["rendermime/factories","latexRendererFactory","#safe"],"updatePoint":{"line":190,"column":24},"line":190,"code":"      it('should be safe', () => {\n        expect(latexRendererFactory.safe).toBe(true);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should set the textContent of the widget","suites":["rendermime/factories","latexRendererFactory","#createRenderer()"],"updatePoint":{"line":196,"column":50},"line":196,"code":"      it('should set the textContent of the widget', async () => {\n        const source = 'sumlimits_{i=0}^{infty} \\frac{1}{n^2}';\n        const f = latexRendererFactory;\n        const mimeType = 'text/latex';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.textContent).toBe(source);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be re-renderable","suites":["rendermime/factories","latexRendererFactory","#createRenderer()"],"updatePoint":{"line":206,"column":33},"line":206,"code":"      it('should be re-renderable', async () => {\n        const source = 'sumlimits_{i=0}^{infty} \\frac{1}{n^2}';\n        const f = latexRendererFactory;\n        const mimeType = 'text/latex';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.textContent).toBe(source);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should have the image/svg+xml mimeType","suites":["rendermime/factories","svgRendererFactory","#mimeTypes"],"updatePoint":{"line":221,"column":48},"line":221,"code":"      it('should have the image/svg+xml mimeType', () => {\n        expect(svgRendererFactory.mimeTypes).toEqual(['image/svg+xml']);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should not be safe","suites":["rendermime/factories","svgRendererFactory","#safe"],"updatePoint":{"line":227,"column":28},"line":227,"code":"      it('should not be safe', () => {\n        expect(svgRendererFactory.safe).toBe(false);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create an img element with the uri encoded svg inline","suites":["rendermime/factories","svgRendererFactory","#createRenderer()"],"updatePoint":{"line":233,"column":70},"line":233,"code":"      it('should create an img element with the uri encoded svg inline', async () => {\n        const source = '<svg></svg>';\n        const displaySource = '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n        const f = svgRendererFactory;\n        const mimeType = 'image/svg+xml';\n        const model = createModel(mimeType, source, true);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        const imgEl = w.node.getElementsByTagName('img')[0];\n        expect(imgEl).toBeTruthy();\n        expect(imgEl.src).toContain(encodeURIComponent(displaySource));\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should have the text/markdown mimeType","suites":["rendermime/factories","markdownRendererFactory","#mimeTypes"],"updatePoint":{"line":250,"column":48},"line":250,"code":"      it('should have the text/markdown mimeType', function () {\n        expect(markdownRendererFactory.mimeTypes).toEqual(['text/markdown']);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be safe","suites":["rendermime/factories","markdownRendererFactory","#safe"],"updatePoint":{"line":256,"column":24},"line":256,"code":"      it('should be safe', () => {\n        expect(markdownRendererFactory.safe).toBe(true);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should set the inner html","suites":["rendermime/factories","markdownRendererFactory","#createRenderer()"],"updatePoint":{"line":262,"column":35},"line":262,"code":"      it('should set the inner html', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(source);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be re-renderable","suites":["rendermime/factories","markdownRendererFactory","#createRenderer()"],"updatePoint":{"line":272,"column":33},"line":272,"code":"      it('should be re-renderable', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(source);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should add header anchors","suites":["rendermime/factories","markdownRendererFactory","#createRenderer()"],"updatePoint":{"line":283,"column":35},"line":283,"code":"      it('should add header anchors', async () => {\n        const f = markdownRendererFactory;\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, sampleData);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        Widget.attach(w, document.body);\n        const node = document.getElementById('Title-third-level')!;\n        expect(node.localName).toBe('h3');\n        const anchor = node.firstChild!.nextSibling as HTMLAnchorElement;\n        expect(anchor.href).toContain('#Title-third-level');\n        expect(anchor.target).toBe('_self');\n        expect(anchor.className).toContain('jp-InternalAnchorLink');\n        expect(anchor.textContent).toBe('Â¶');\n        Widget.detach(w);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should sanitize the html","suites":["rendermime/factories","markdownRendererFactory","#createRenderer()"],"updatePoint":{"line":300,"column":34},"line":300,"code":"      it('should sanitize the html', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p><script>alert(\"foo\")</script>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['script'])\n        );\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should have the text/html mimeType","suites":["rendermime/factories","htmlRendererFactory","#mimeTypes"],"updatePoint":{"line":316,"column":44},"line":316,"code":"      it('should have the text/html mimeType', () => {\n        expect(htmlRendererFactory.mimeTypes).toEqual(['text/html']);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be safe","suites":["rendermime/factories","htmlRendererFactory","#safe"],"updatePoint":{"line":322,"column":24},"line":322,"code":"      it('should be safe', () => {\n        expect(htmlRendererFactory.safe).toBe(true);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should set the inner HTML","suites":["rendermime/factories","htmlRendererFactory","#createRenderer()"],"updatePoint":{"line":328,"column":35},"line":328,"code":"      it('should set the inner HTML', async () => {\n        const f = htmlRendererFactory;\n        const source = '<h1>This is great</h1>';\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<h1>This is great</h1>');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be re-renderable","suites":["rendermime/factories","htmlRendererFactory","#createRenderer()"],"updatePoint":{"line":338,"column":33},"line":338,"code":"      it('should be re-renderable', async () => {\n        const f = htmlRendererFactory;\n        const source = '<h1>This is great</h1>';\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<h1>This is great</h1>');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should execute a script tag when attached","suites":["rendermime/factories","htmlRendererFactory","#createRenderer()"],"line":350,"code":"      it.skip('should execute a script tag when attached', () => {","file":"factories.spec.ts","skipped":true,"dir":"packages/rendermime/test"},{"name":"should sanitize when untrusted","suites":["rendermime/factories","htmlRendererFactory","#createRenderer()"],"updatePoint":{"line":364,"column":40},"line":364,"code":"      it('should sanitize when untrusted', async () => {\n        const source = '<pre><script>window.y=3;</script></pre>';\n        const f = htmlRendererFactory;\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre></pre>');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should sanitize html","suites":["rendermime/factories","htmlRendererFactory","#createRenderer()"],"updatePoint":{"line":375,"column":28},"line":375,"code":"    it('should sanitize html', async () => {\n      const model = createModel(\n        'text/html',\n        '<h1>foo <script>window.x=1></scrip></h1>'\n      );\n      const f = htmlRendererFactory;\n      const mimeType = 'text/html';\n      const w = f.createRenderer({ mimeType, ...defaultOptions });\n      await w.renderModel(model);\n      expect(w.node.innerHTML).toBe('<h1>foo </h1>');\n    });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should support multiple mimeTypes","suites":["rendermime/factories","imageRendererFactory","#mimeTypes"],"updatePoint":{"line":390,"column":43},"line":390,"code":"      it('should support multiple mimeTypes', () => {\n        expect(imageRendererFactory.mimeTypes).toEqual([\n          'image/bmp',\n          'image/png',\n          'image/jpeg',\n          'image/gif'\n        ]);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be safe","suites":["rendermime/factories","imageRendererFactory","#safe"],"updatePoint":{"line":401,"column":24},"line":401,"code":"      it('should be safe', () => {\n        expect(imageRendererFactory.safe).toBe(true);\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create an <img> with the right mimeType","suites":["rendermime/factories","imageRendererFactory","#createRenderer()"],"updatePoint":{"line":407,"column":56},"line":407,"code":"      it('should create an <img> with the right mimeType', async () => {\n        let source = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n        const f = imageRendererFactory;\n        let mimeType = 'image/png';\n        let model = createModel(mimeType, source);\n        let w = f.createRenderer({ mimeType, ...defaultOptions });\n\n        await w.renderModel(model);\n        let el = w.node.firstChild as HTMLImageElement;\n        expect(el.src).toBe('data:image/png;base64,' + source);\n        expect(el.localName).toBe('img');\n        expect(el.innerHTML).toBe('');\n\n        source = 'R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=';\n        mimeType = 'image/gif';\n        model = createModel(mimeType, source);\n        w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        el = w.node.firstChild as HTMLImageElement;\n        expect(el.src).toBe('data:image/gif;base64,' + source);\n        expect(el.localName).toBe('img');\n        expect(el.innerHTML).toBe('');\n      });","file":"factories.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should split the text into text and math","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":8,"column":48},"line":8,"code":"    it('should split the text into text and math', () => {\n      const input = 'hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha $']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle code spans","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":15,"column":32},"line":15,"code":"    it('should handle code spans', () => {\n      const input = '`$foo` and `$bar` are variables';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle fenced code blocks","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":22,"column":40},"line":22,"code":"    it('should handle fenced code blocks', () => {\n      const input = '```\\n$foo\\n$bar\\n```';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle tilde fenced code blocks","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":29,"column":46},"line":29,"code":"    it('should handle tilde fenced code blocks', () => {\n      const input = '~~~\\n$foo\\n$bar\\n~~~';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle long fenced code blocks","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":36,"column":45},"line":36,"code":"    it('should handle long fenced code blocks', () => {\n      const input = '````\\n$foo\\n$bar\\n```\\n``````';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle fenced code blocks with info string","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":43,"column":57},"line":43,"code":"    it('should handle fenced code blocks with info string', () => {\n      const input = '```R\\ndata[data$foo > 1 & data$bar < 2,]\\n```';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle math markers","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":50,"column":34},"line":50,"code":"    it('should handle math markers', () => {\n      const input = ' @@0@@ hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(' @@0@@ hello, @@1@@, there');\n      expect(math).toEqual(['@@0@@', '$ /alpha $']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle unbalanced braces","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":57,"column":39},"line":57,"code":"    it('should handle unbalanced braces', () => {\n      const input = 'hello, $ /alpha { $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha { $']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle balanced braces","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":64,"column":37},"line":64,"code":"    it('should handle balanced braces', () => {\n      const input = 'hello, $ /alpha { } $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha { } $']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle math blocks","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":71,"column":33},"line":71,"code":"    it('should handle math blocks', () => {\n      const input = 'hello, $$\\nfoo\\n$$, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$$\\nfoo\\n$$']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle begin statements","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":78,"column":38},"line":78,"code":"    it('should handle begin statements', () => {\n      const input = 'hello, \\\\begin{align} \\\\end{align}, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\begin{align} \\\\end{align}']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle `\\(` delimiters in GFM","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":85,"column":45},"line":85,"code":"    it('should handle `\\\\(` delimiters in GFM', () => {\n      const input = `\n      \\`\\`\\`\n        Some \\\\(text\n        \\'\\'\\'\n        **bold**\n        ## header\n      `;\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle `\\\\(` delimiters for math","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":98,"column":49},"line":98,"code":"    it('should handle `\\\\\\\\(` delimiters for math', () => {\n      const input = `hello, \\\\\\\\\\(\n          /alpha\n      \\\\\\\\\\), there`;\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\\\\\(\\n          /alpha\\n      \\\\\\\\)']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle `\\\\[` delimiters for math","suites":["jupyter-ui","removeMath()"],"updatePoint":{"line":107,"column":49},"line":107,"code":"    it('should handle `\\\\\\\\[` delimiters for math', () => {\n      const input = `hello, \\\\\\\\\\[\n          /alpha\n      \\\\\\\\\\], there`;\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\\\\\[\\n          /alpha\\n      \\\\\\\\]']);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should recombine text split with removeMath","suites":["jupyter-ui","replaceMath()"],"updatePoint":{"line":118,"column":51},"line":118,"code":"    it('should recombine text split with removeMath', () => {\n      const input = 'hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(replaceMath(text, math)).toBe(input);\n    });","file":"latex.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create a new mime model","suites":["rendermime/mimemodel","MimeModel","#constructor()"],"updatePoint":{"line":9,"column":40},"line":9,"code":"      it('should create a new mime model', () => {\n        const model = new MimeModel();\n        expect(model).toBeInstanceOf(MimeModel);\n      });","file":"mimemodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should accept arguments","suites":["rendermime/mimemodel","MimeModel","#constructor()"],"updatePoint":{"line":14,"column":33},"line":14,"code":"      it('should accept arguments', () => {\n        const model = new MimeModel({\n          data: { foo: 1 },\n          metadata: { bar: 'baz' }\n        });\n        expect(model).toBeInstanceOf(MimeModel);\n      });","file":"mimemodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the data observable map","suites":["rendermime/mimemodel","MimeModel","#data"],"updatePoint":{"line":24,"column":43},"line":24,"code":"      it('should be the data observable map', () => {\n        const model = new MimeModel({\n          data: { bar: 'baz' }\n        });\n        expect(model.data['bar']).toBe('baz');\n      });","file":"mimemodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the metadata observable map","suites":["rendermime/mimemodel","MimeModel","#metadata"],"updatePoint":{"line":33,"column":47},"line":33,"code":"      it('should be the metadata observable map', () => {\n        const model = new MimeModel({\n          metadata: { bar: 'baz' }\n        });\n        expect(model.metadata['bar']).toBe('baz');\n      });","file":"mimemodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create a new output model","suites":["rendermime/outputmodel","OutputModel","#constructor()"],"updatePoint":{"line":27,"column":42},"line":27,"code":"      it('should create a new output model', () => {\n        const value = DEFAULT_EXECUTE;\n        let model = new OutputModel({ value });\n        expect(model).toBeInstanceOf(OutputModel);\n        model = new OutputModel({ value, trusted: true });\n        expect(model).toBeInstanceOf(OutputModel);\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the output type","suites":["rendermime/outputmodel","OutputModel","#type"],"updatePoint":{"line":37,"column":35},"line":37,"code":"      it('should be the output type', () => {\n        let model = new OutputModel({ value: DEFAULT_EXECUTE });\n        expect(model.type).toBe(DEFAULT_EXECUTE.output_type);\n        model = new OutputModel({ value: DEFAULT_STREAM });\n        expect(model.type).toBe(DEFAULT_STREAM.output_type);\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the execution count of an execution result","suites":["rendermime/outputmodel","OutputModel","#executionCount"],"updatePoint":{"line":46,"column":62},"line":46,"code":"      it('should be the execution count of an execution result', () => {\n        const model = new OutputModel({ value: DEFAULT_EXECUTE });\n        expect(model.executionCount).toBe(1);\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be null for non-execution results","suites":["rendermime/outputmodel","OutputModel","#executionCount"],"updatePoint":{"line":51,"column":50},"line":51,"code":"      it('should be null for non-execution results', () => {\n        const model = new OutputModel({ value: DEFAULT_STREAM });\n        expect(model.executionCount).toBeNull();\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should yield the raw value","suites":["rendermime/outputmodel","OutputModel","#toJSON()"],"updatePoint":{"line":58,"column":36},"line":58,"code":"      it('should yield the raw value', () => {\n        const model = new OutputModel({ value: DEFAULT_EXECUTE });\n        expect(model.toJSON()).toEqual(DEFAULT_EXECUTE);\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle all bundle types","suites":["rendermime/outputmodel","OutputModel",".getData()"],"updatePoint":{"line":65,"column":40},"line":65,"code":"      it('should handle all bundle types', () => {\n        for (let i = 0; i < NBTestUtils.DEFAULT_OUTPUTS.length; i++) {\n          const output = NBTestUtils.DEFAULT_OUTPUTS[i];\n          const bundle = OutputModel.getData(output);\n          expect(Object.keys(bundle).length).not.toBe(0);\n        }\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should get the metadata from the bundle","suites":["rendermime/outputmodel","OutputModel",".getMetadata()"],"updatePoint":{"line":75,"column":49},"line":75,"code":"      it('should get the metadata from the bundle', () => {\n        const metadata = OutputModel.getMetadata(DEFAULT_EXECUTE);\n        expect(metadata['foo']).toBe(1);\n        expect(metadata['bar']).toBe('baz');\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should handle output with no metadata field","suites":["rendermime/outputmodel","OutputModel",".getMetadata()"],"updatePoint":{"line":81,"column":53},"line":81,"code":"      it('should handle output with no metadata field', () => {\n        const metadata = OutputModel.getMetadata(DEFAULT_STREAM);\n        expect(Object.keys(metadata).length).toBe(0);\n      });","file":"outputmodel.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create a new rendermime instance","suites":["rendermime/registry","RenderMimeRegistry","#constructor()"],"updatePoint":{"line":71,"column":49},"line":71,"code":"      it('should create a new rendermime instance', () => {\n        expect(r instanceof RenderMimeRegistry).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the resolver used by the rendermime","suites":["rendermime/registry","RenderMimeRegistry","#resolver"],"updatePoint":{"line":77,"column":55},"line":77,"code":"      it('should be the resolver used by the rendermime', () => {\n        expect(r.resolver).toBeNull();\n        const clone = r.clone({ resolver: RESOLVER });\n        expect(clone.resolver).toBe(RESOLVER);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the link handler used by the rendermime","suites":["rendermime/registry","RenderMimeRegistry","#linkHandler"],"updatePoint":{"line":85,"column":59},"line":85,"code":"      it('should be the link handler used by the rendermime', () => {\n        expect(r.linkHandler).toBeNull();\n        const handler = {\n          handleLink: () => {\n            /* no-op */\n          }\n        };\n        const clone = r.clone({ linkHandler: handler });\n        expect(clone.linkHandler).toBe(handler);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be the null typesetter by default","suites":["rendermime/registry","RenderMimeRegistry","#latexTypesetter"],"updatePoint":{"line":98,"column":50},"line":98,"code":"      it('should be the null typesetter by default', () => {\n        expect(r.latexTypesetter).toBeNull();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be clonable","suites":["rendermime/registry","RenderMimeRegistry","#latexTypesetter"],"updatePoint":{"line":102,"column":28},"line":102,"code":"      it('should be clonable', () => {\n        const args = {\n          url: PageConfig.getOption('mathjaxUrl'),\n          config: PageConfig.getOption('mathjaxConfig')\n        };\n        const typesetter1 = new MathJaxTypesetter(args);\n        const clone1 = r.clone({ latexTypesetter: typesetter1 });\n        expect(clone1.latexTypesetter).toBe(typesetter1);\n        const typesetter2 = new MathJaxTypesetter(args);\n        const clone2 = r.clone({ latexTypesetter: typesetter2 });\n        expect(clone2.latexTypesetter).toBe(typesetter2);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create a mime renderer","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":117,"column":39},"line":117,"code":"      it('should create a mime renderer', () => {\n        const w = r.createRenderer('text/plain');\n        expect(w instanceof Widget).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should raise an error for an unregistered mime type","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":122,"column":61},"line":122,"code":"      it('should raise an error for an unregistered mime type', () => {\n        expect(() => {\n          r.createRenderer('text/fizz');\n        }).toThrowError();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should render json data","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":128,"column":33},"line":128,"code":"      it('should render json data', async () => {\n        const model = createModel({\n          'application/json': { foo: 1 }\n        });\n        const w = r.createRenderer('application/json');\n        await w.renderModel(model);\n        expect(w.node.textContent).toBe('{\\n  \"foo\": 1\\n}');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should send a url resolver","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":137,"column":36},"line":137,"code":"      it('should send a url resolver', async () => {\n        const model = createModel({\n          'text/html': '<img src=\"./foo%2520\">foo</img>'\n        });\n        let called0 = false;\n        let called1 = false;\n        r = r.clone({\n          resolver: {\n            resolveUrl: (url: string) => {\n              called0 = true;\n              return Promise.resolve(url);\n            },\n            getDownloadUrl: (url: string) => {\n              expect(called0).toBe(true);\n              called1 = true;\n              expect(url).toBe('./foo%2520');\n              return Promise.resolve(url);\n            }\n          }\n        });\n        const w = r.createRenderer('text/html');\n        await w.renderModel(model);\n        expect(called1).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should send a link handler","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":162,"column":36},"line":162,"code":"      it('should send a link handler', async () => {\n        const model = createModel({\n          'text/html': '<a href=\"./foo/bar.txt\">foo</a>'\n        });\n        let called = false;\n        r = r.clone({\n          resolver: RESOLVER,\n          linkHandler: {\n            handleLink: (node: HTMLElement, url: string) => {\n              expect(url).toContain('foo/bar.txt');\n              called = true;\n            }\n          }\n        });\n        const w = r.createRenderer('text/html');\n        await w.renderModel(model);\n        expect(called).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should send decoded paths to link handler","suites":["rendermime/registry","RenderMimeRegistry","#createRenderer()"],"updatePoint":{"line":181,"column":51},"line":181,"code":"      it('should send decoded paths to link handler', async () => {\n        const model = createModel({\n          'text/html': '<a href=\"foo%2520/b%C3%A5r.txt\">foo</a>'\n        });\n        let called = false;\n        r = r.clone({\n          resolver: RESOLVER,\n          linkHandler: {\n            handleLink: (node: HTMLElement, path: string) => {\n              expect(path).toContain('foo%20/bÃ¥r.txt');\n              called = true;\n            }\n          }\n        });\n        const w = r.createRenderer('text/html');\n        await w.renderModel(model);\n        expect(called).toBe(true);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should find the preferred mimeType in a bundle","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":202,"column":56},"line":202,"code":"      it('should find the preferred mimeType in a bundle', () => {\n        const model = createModel({\n          'text/plain': 'foo',\n          'text/html': '<h1>foo</h1>'\n        });\n        expect(r.preferredMimeType(model.data, 'any')).toBe('text/html');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return `undefined` if there are no registered mimeTypes","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":210,"column":72},"line":210,"code":"      it('should return `undefined` if there are no registered mimeTypes', () => {\n        const model = createModel({ 'text/fizz': 'buzz' });\n        expect(r.preferredMimeType(model.data, 'any')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should select the mimeType that is safe","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":215,"column":49},"line":215,"code":"      it('should select the mimeType that is safe', () => {\n        const model = createModel({\n          'text/plain': 'foo',\n          'text/javascript': 'window.x = 1',\n          'image/png':\n            'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\n        });\n        expect(r.preferredMimeType(model.data)).toBe('image/png');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should render the mimeType that is sanitizable","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":225,"column":56},"line":225,"code":"      it('should render the mimeType that is sanitizable', () => {\n        const model = createModel({\n          'text/plain': 'foo',\n          'text/html': '<h1>foo</h1>'\n        });\n        expect(r.preferredMimeType(model.data)).toBe('text/html');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return `undefined` if only unsafe options with default `ensure`","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":233,"column":80},"line":233,"code":"      it('should return `undefined` if only unsafe options with default `ensure`', () => {\n        const model = createModel({\n          'image/svg+xml': ''\n        });\n        expect(r.preferredMimeType(model.data)).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return `undefined` if only unsafe options with `ensure`","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":240,"column":72},"line":240,"code":"      it('should return `undefined` if only unsafe options with `ensure`', () => {\n        const model = createModel({\n          'image/svg+xml': ''\n        });\n        expect(r.preferredMimeType(model.data, 'ensure')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return safe option if called with `prefer`","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":247,"column":59},"line":247,"code":"      it('should return safe option if called with `prefer`', () => {\n        const model = createModel({\n          'image/svg+xml': '',\n          'text/plain': ''\n        });\n        expect(r.preferredMimeType(model.data, 'prefer')).toBe('text/plain');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return unsafe option if called with `prefer`, and no safe alternative","suites":["rendermime/registry","RenderMimeRegistry","#preferredMimeType()"],"updatePoint":{"line":255,"column":86},"line":255,"code":"      it('should return unsafe option if called with `prefer`, and no safe alternative', () => {\n        const model = createModel({\n          'image/svg+xml': ''\n        });\n        expect(r.preferredMimeType(model.data, 'prefer')).toBe('image/svg+xml');\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should clone the rendermime instance with shallow copies of data","suites":["rendermime/registry","RenderMimeRegistry","#clone()"],"updatePoint":{"line":264,"column":74},"line":264,"code":"      it('should clone the rendermime instance with shallow copies of data', () => {\n        const c = r.clone();\n        expect(toArray(c.mimeTypes)).toEqual(r.mimeTypes);\n        c.addFactory(fooFactory);\n        expect(r).not.toBe(c);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should add a factory","suites":["rendermime/registry","RenderMimeRegistry","#addFactory()"],"updatePoint":{"line":273,"column":30},"line":273,"code":"      it('should add a factory', () => {\n        r.addFactory(fooFactory);\n        const index = r.mimeTypes.indexOf('text/foo');\n        expect(index).toBe(r.mimeTypes.length - 1);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should take an optional rank","suites":["rendermime/registry","RenderMimeRegistry","#addFactory()"],"updatePoint":{"line":279,"column":38},"line":279,"code":"      it('should take an optional rank', () => {\n        const len = r.mimeTypes.length;\n        r.addFactory(fooFactory, 0);\n        const index = r.mimeTypes.indexOf('text/foo');\n        expect(index).toBe(0);\n        expect(r.mimeTypes.length).toBe(len + 1);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should remove a factory by mimeType","suites":["rendermime/registry","RenderMimeRegistry","#removeMimeType()"],"updatePoint":{"line":289,"column":45},"line":289,"code":"      it('should remove a factory by mimeType', () => {\n        r.removeMimeType('text/html');\n        const model = createModel({ 'text/html': '<h1>foo</h1>' });\n        expect(r.preferredMimeType(model.data, 'any')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should be a no-op if the mimeType is not registered","suites":["rendermime/registry","RenderMimeRegistry","#removeMimeType()"],"updatePoint":{"line":295,"column":61},"line":295,"code":"      it('should be a no-op if the mimeType is not registered', () => {\n        expect(() => {\n          r.removeMimeType('text/foo');\n        }).not.toThrow();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should get a factory by mimeType","suites":["rendermime/registry","RenderMimeRegistry","#getFactory()"],"updatePoint":{"line":303,"column":42},"line":303,"code":"      it('should get a factory by mimeType', () => {\n        const f = r.getFactory('text/plain')!;\n        expect(f.mimeTypes).toEqual(expect.arrayContaining(['text/plain']));\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return undefined for missing mimeType","suites":["rendermime/registry","RenderMimeRegistry","#getFactory()"],"updatePoint":{"line":308,"column":54},"line":308,"code":"      it('should return undefined for missing mimeType', () => {\n        expect(r.getFactory('hello/world')).toBeUndefined();\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should get the ordered list of mimeTypes","suites":["rendermime/registry","RenderMimeRegistry","#mimeTypes"],"updatePoint":{"line":314,"column":50},"line":314,"code":"      it('should get the ordered list of mimeTypes', () => {\n        expect(r.mimeTypes.indexOf('text/html')).not.toBe(-1);\n      });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should create a UrlResolver instance","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#constructor"],"updatePoint":{"line":355,"column":48},"line":355,"code":"        it('should create a UrlResolver instance', () => {\n          expect(resolverSession).toBeInstanceOf(\n            RenderMimeRegistry.UrlResolver\n          );\n          expect(resolverPath).toBeInstanceOf(RenderMimeRegistry.UrlResolver);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should give precedence to the explicit path over the session","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver",".path"],"updatePoint":{"line":364,"column":72},"line":364,"code":"        it('should give precedence to the explicit path over the session', async () => {\n          const resolver = new RenderMimeRegistry.UrlResolver({\n            session: new SessionContext({\n              sessionManager: manager.sessions,\n              specsManager: manager.kernelspecs,\n              path: pathParent + '/pr%25 ' + UUID.uuid4(),\n              kernelPreference: { canStart: false, shouldStart: false }\n            }),\n            contents: manager.contents,\n            path: '/some/path/file.txt'\n          });\n          expect(await resolver.resolveUrl('./foo')).toContain('some/path/foo');\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should fall back to the session path if only the session is given","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver",".path"],"updatePoint":{"line":378,"column":77},"line":378,"code":"        it('should fall back to the session path if only the session is given', () => {\n          expect(resolverSession.path).toBe(path);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should allow the path to be changed","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver",".path"],"updatePoint":{"line":382,"column":47},"line":382,"code":"        it('should allow the path to be changed', async () => {\n          const resolver = new RenderMimeRegistry.UrlResolver({\n            session: new SessionContext({\n              sessionManager: manager.sessions,\n              specsManager: manager.kernelspecs,\n              path: pathParent + '/pr%25 ' + UUID.uuid4(),\n              kernelPreference: { canStart: false, shouldStart: false }\n            }),\n            contents: manager.contents\n          });\n          resolver.path = '/some/path/file.txt';\n          expect(await resolver.resolveUrl('./foo')).toContain('some/path/foo');\n          const resolver2 = new RenderMimeRegistry.UrlResolver({\n            path: '/some/path/file.txt',\n            contents: manager.contents\n          });\n          resolver2.path = '/other/path/file.txt';\n          expect(await resolver2.resolveUrl('./foo')).toContain(\n            'other/path/foo'\n          );\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should resolve a relative url","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#resolveUrl()"],"updatePoint":{"line":406,"column":41},"line":406,"code":"        it('should resolve a relative url', async () => {\n          expect(await resolverSession.resolveUrl('./foo')).toContain(\n            urlParent + '/foo'\n          );\n          expect(await resolverPath.resolveUrl('./foo')).toContain(\n            urlParent + '/foo'\n          );\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should resolve a relative url with no active session","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#resolveUrl()"],"updatePoint":{"line":415,"column":64},"line":415,"code":"        it('should resolve a relative url with no active session', async () => {\n          const resolver = new RenderMimeRegistry.UrlResolver({\n            session: new SessionContext({\n              sessionManager: manager.sessions,\n              specsManager: manager.kernelspecs,\n              path: pathParent + '/pr%25 ' + UUID.uuid4(),\n              kernelPreference: { canStart: false, shouldStart: false }\n            }),\n            contents: manager.contents\n          });\n          const path = await resolver.resolveUrl('./foo');\n          expect(path).toContain(urlParent + '/foo');\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should ignore urls that have a protocol","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#resolveUrl()"],"updatePoint":{"line":429,"column":51},"line":429,"code":"        it('should ignore urls that have a protocol', async () => {\n          expect(await resolverSession.resolveUrl('http://foo')).toContain(\n            'http://foo'\n          );\n          expect(await resolverPath.resolveUrl('http://foo')).toContain(\n            'http://foo'\n          );\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should resolve URLs with escapes","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#resolveUrl()"],"updatePoint":{"line":438,"column":44},"line":438,"code":"        it('should resolve URLs with escapes', async () => {\n          expect(\n            await resolverSession.resolveUrl('has%20space%23hash')\n          ).toContain(urlParent + '/has%20space%23hash');\n          expect(await resolverPath.resolveUrl('has%20space%23hash')).toContain(\n            urlParent + '/has%20space%23hash'\n          );\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should resolve an absolute server url to a download url","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#getDownloadUrl()"],"updatePoint":{"line":449,"column":67},"line":449,"code":"        it('should resolve an absolute server url to a download url', async () => {\n          const contextPromise = resolverPath.getDownloadUrl('foo');\n          const contentsPromise = contents.getDownloadUrl('foo');\n          const values = await Promise.all([contextPromise, contentsPromise]);\n          expect(values[0]).toBe(values[1]);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should resolve escapes correctly","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#getDownloadUrl()"],"updatePoint":{"line":456,"column":44},"line":456,"code":"        it('should resolve escapes correctly', async () => {\n          const contextPromise = resolverPath.getDownloadUrl(\n            'foo%20%23%2520test'\n          );\n          const contentsPromise = contents.getDownloadUrl('foo #%20test');\n          const values = await Promise.all([contextPromise, contentsPromise]);\n          expect(values[0]).toBe(values[1]);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should ignore urls that have a protocol","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#getDownloadUrl()"],"updatePoint":{"line":465,"column":51},"line":465,"code":"        it('should ignore urls that have a protocol', async () => {\n          const path = await resolverPath.getDownloadUrl('http://foo');\n          expect(path).toBe('http://foo');\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return true for a registered IDrive`","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#isLocal"],"updatePoint":{"line":472,"column":55},"line":472,"code":"        it('should return true for a registered IDrive`', () => {\n          expect(resolverPath.isLocal('extra:path/to/file')).toBe(true);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return false for an unrecognized Drive`","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#isLocal"],"updatePoint":{"line":476,"column":58},"line":476,"code":"        it('should return false for an unrecognized Drive`', () => {\n          expect(resolverPath.isLocal('unregistered:path/to/file')).toBe(false);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return true for a normal filesystem-like path`","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#isLocal"],"updatePoint":{"line":480,"column":65},"line":480,"code":"        it('should return true for a normal filesystem-like path`', () => {\n          expect(resolverPath.isLocal('path/to/file')).toBe(true);\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should return false for malformed URLs","suites":["rendermime/registry","RenderMimeRegistry",".UrlResolver","#isLocal"],"updatePoint":{"line":484,"column":50},"line":484,"code":"        it('should return false for malformed URLs', () => {\n          expect(resolverPath.isLocal('http://www.example.com%bad')).toBe(\n            false\n          );\n        });","file":"registry.spec.ts","skipped":false,"dir":"packages/rendermime/test"},{"name":"should load a config","suites":["config","ConfigSection.create()"],"updatePoint":{"line":33,"column":28},"line":33,"code":"    it('should load a config', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      expect(Object.keys(config.data).length).toBe(0);\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["config","ConfigSection.create()"],"updatePoint":{"line":38,"column":37},"line":38,"code":"    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const config = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      expect(Object.keys(config.data).length).toBe(0);\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["config","ConfigSection.create()"],"updatePoint":{"line":47,"column":45},"line":47,"code":"    it('should fail for an incorrect response', async () => {\n      const serverSettings = getRequestHandler(201, {});\n      const configPromise = ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      await expect(configPromise).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update a config","suites":["config","#update()"],"updatePoint":{"line":60,"column":30},"line":60,"code":"    it('should update a config', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      const data: any = await config.update({ foo: 'baz', spam: 'eggs' });\n      expect(data.foo).toBe('baz');\n      expect(config.data['foo']).toBe('baz');\n      expect(data['spam']).toBe('eggs');\n      expect(config.data['spam']).toBe('eggs');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["config","#update()"],"updatePoint":{"line":69,"column":37},"line":69,"code":"    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const config = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      const data: any = await config.update({ foo: 'baz', spam: 'eggs' });\n      expect(data.foo).toBe('baz');\n      expect(config.data['foo']).toBe('baz');\n      expect(data['spam']).toBe('eggs');\n      expect(config.data['spam']).toBe('eggs');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["config","#update()"],"updatePoint":{"line":82,"column":45},"line":82,"code":"    it('should fail for an incorrect response', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      handleRequest(config, 201, {});\n      const update = config.update({ foo: 'baz' });\n      await expect(update).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should complete properly","suites":["jupyter.services - ConfigWithDefaults","#constructor()"],"updatePoint":{"line":93,"column":32},"line":93,"code":"    it('should complete properly', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      expect(config).toBeInstanceOf(ConfigWithDefaults);\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a new config value","suites":["jupyter.services - ConfigWithDefaults","#get()"],"updatePoint":{"line":109,"column":37},"line":109,"code":"    it('should get a new config value', async () => {\n      const defaults: JSONObject = { foo: 'bar' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('foo');\n      expect(data).toBe('bar');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a default config value","suites":["jupyter.services - ConfigWithDefaults","#get()"],"updatePoint":{"line":124,"column":41},"line":124,"code":"    it('should get a default config value', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('spam');\n      expect(data).toBe('eggs');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a default config value with no class","suites":["jupyter.services - ConfigWithDefaults","#get()"],"updatePoint":{"line":139,"column":55},"line":139,"code":"    it('should get a default config value with no class', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('spam');\n      expect(data).toBe('eggs');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a falsey value","suites":["jupyter.services - ConfigWithDefaults","#get()"],"updatePoint":{"line":154,"column":33},"line":154,"code":"    it('should get a falsey value', async () => {\n      const defaults: JSONObject = { foo: true };\n      const className = 'testclass';\n      const serverSettings = getRequestHandler(200, { foo: false });\n      const section = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('foo');\n      expect(data).toBeFalsy();\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should set a value in a class immediately","suites":["jupyter.services - ConfigWithDefaults","#set()"],"updatePoint":{"line":173,"column":49},"line":173,"code":"    it('should set a value in a class immediately', async () => {\n      const className = 'testclass';\n      const section = await ConfigSection.create({ name: randomName() });\n      const config = new ConfigWithDefaults({ section, className });\n      let data: any = await config.set('foo', 'bar');\n      data = section.data['testclass'] as JSONObject;\n      expect(data['foo']).toBe('bar');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should set a top level value","suites":["jupyter.services - ConfigWithDefaults","#set()"],"updatePoint":{"line":182,"column":36},"line":182,"code":"    it('should set a top level value', async () => {\n      const section = await ConfigSection.create({ name: randomName() });\n      const config = new ConfigWithDefaults({ section });\n      const set = config.set('foo', 'bar');\n      expect(section.data['foo']).toBe('bar');\n      await set;\n      expect(section.data['foo']).toBe('bar');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an invalid response","suites":["jupyter.services - ConfigWithDefaults","#set()"],"updatePoint":{"line":191,"column":43},"line":191,"code":"    it('should fail for an invalid response', async () => {\n      const serverSettings = getRequestHandler(200, {});\n      const section = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      handleRequest(section, 201, { foo: 'bar' });\n      const config = new ConfigWithDefaults({ section });\n      const set = config.set('foo', 'bar');\n      expect(section.data['foo']).toBe('bar');\n      await expectFailure(set, 'Invalid response: 201 Created');\n    });","file":"config/config.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept no options","suites":["contents","#constructor()"],"updatePoint":{"line":52,"column":32},"line":52,"code":"    it('should accept no options', () => {\n      const contents = new ContentsManager();\n      expect(contents).toBeInstanceOf(ContentsManager);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept options","suites":["contents","#constructor()"],"updatePoint":{"line":57,"column":29},"line":57,"code":"    it('should accept options', () => {\n      const contents = new ContentsManager({\n        defaultDrive: new Drive()\n      });\n      expect(contents).toBeInstanceOf(ContentsManager);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a file changes","suites":["contents","#fileChanged"],"updatePoint":{"line":66,"column":45},"line":66,"code":"    it('should be emitted when a file changes', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(sender).toBe(contents);\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled();\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should include the full path for additional drives","suites":["contents","#fileChanged"],"updatePoint":{"line":80,"column":58},"line":80,"code":"    it('should include the full path for additional drives', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.newValue!.path).toBe('other:' + DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled({ path: 'other:' });\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is disposed","suites":["contents","#isDisposed"],"updatePoint":{"line":95,"column":51},"line":95,"code":"    it('should test whether the manager is disposed', () => {\n      expect(contents.isDisposed).toBe(false);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources used by the manager","suites":["contents","#dispose()"],"updatePoint":{"line":103,"column":59},"line":103,"code":"    it('should dispose of the resources used by the manager', () => {\n      expect(contents.isDisposed).toBe(false);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should add a new drive to the manager","suites":["contents","#addDrive()"],"updatePoint":{"line":113,"column":45},"line":113,"code":"    it('should add a new drive to the manager', async () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      handleRequest(contents, 200, DEFAULT_FILE);\n      await expect(contents.get('other:')).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should parse the local part of a path","suites":["contents","#localPath()"],"updatePoint":{"line":121,"column":45},"line":121,"code":"    it('should parse the local part of a path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      contents.addDrive(new Drive({ name: 'alternative' }));\n\n      expect(contents.localPath('other:foo/bar/example.txt')).toBe(\n        'foo/bar/example.txt'\n      );\n\n      expect(contents.localPath('alternative:/foo/bar/example.txt')).toBe(\n        'foo/bar/example.txt'\n      );\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should allow the \":\" character in other parts of the path","suites":["contents","#localPath()"],"updatePoint":{"line":134,"column":65},"line":134,"code":"    it('should allow the \":\" character in other parts of the path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.localPath('other:foo/odd:directory/example:file.txt')\n      ).toBe('foo/odd:directory/example:file.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should leave alone names with \":\" that are not drive names","suites":["contents","#localPath()"],"updatePoint":{"line":142,"column":66},"line":142,"code":"    it('should leave alone names with \":\" that are not drive names', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.localPath('which:foo/odd:directory/example:file.txt')\n      ).toBe('which:foo/odd:directory/example:file.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not prepend root path to an absolute path","suites":["contents","#resolvePath"],"updatePoint":{"line":162,"column":56},"line":162,"code":"    it('should not prepend root path to an absolute path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(root, testPathAbs);\n      expect(result).toBe(testPath);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not have any affect on path relative to empty root","suites":["contents","#resolvePath"],"updatePoint":{"line":169,"column":65},"line":169,"code":"    it('should not have any affect on path relative to empty root', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootEmpty, testPath);\n      expect(result).toBe(testPath);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not have any affect on path relative to \"/\"","suites":["contents","#resolvePath"],"updatePoint":{"line":176,"column":58},"line":176,"code":"    it('should not have any affect on path relative to \"/\"', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootSlash, testPath);\n      expect(result).toBe(testPath);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should join root drive, root path, and path","suites":["contents","#resolvePath"],"updatePoint":{"line":183,"column":51},"line":183,"code":"    it('should join root drive, root path, and path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootDrive, testPath);\n      expect(result).toBe(`${rootDrive}/${testPath}`);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should remove all leading slashes from result path","suites":["contents","#resolvePath"],"updatePoint":{"line":190,"column":58},"line":190,"code":"    it('should remove all leading slashes from result path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootDriveAbs, testPath);\n      expect(result).toBe(`${rootDrive}/${testPath}`);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should parse the drive name a path","suites":["contents","#driveName()"],"updatePoint":{"line":199,"column":42},"line":199,"code":"    it('should parse the drive name a path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      contents.addDrive(new Drive({ name: 'alternative' }));\n\n      expect(contents.driveName('other:foo/bar/example.txt')).toBe('other');\n\n      expect(contents.driveName('alternative:/foo/bar/example.txt')).toBe(\n        'alternative'\n      );\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should allow the \":\" character in other parts of the path","suites":["contents","#driveName()"],"updatePoint":{"line":210,"column":65},"line":210,"code":"    it('should allow the \":\" character in other parts of the path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.driveName('other:foo/odd:directory/example:file.txt')\n      ).toBe('other');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should leave alone names with \":\" that are not drive names","suites":["contents","#driveName()"],"updatePoint":{"line":218,"column":66},"line":218,"code":"    it('should leave alone names with \":\" that are not drive names', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.driveName('which:foo/odd:directory/example:file.txt')\n      ).toBe('');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a file","suites":["contents","#get()"],"updatePoint":{"line":228,"column":25},"line":228,"code":"    it('should get a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const model = await contents.get('/foo', options);\n      expect(model.path).toBe('foo');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a directory","suites":["contents","#get()"],"updatePoint":{"line":235,"column":30},"line":235,"code":"    it('should get a directory', async () => {\n      handleRequest(contents, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const model = await contents.get('/foo', options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a file from an additional drive","suites":["contents","#get()"],"updatePoint":{"line":242,"column":50},"line":242,"code":"    it('should get a file from an additional drive', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.path).toBe('other:foo');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a directory from an additional drive","suites":["contents","#get()"],"updatePoint":{"line":251,"column":55},"line":251,"code":"    it('should get a directory from an additional drive', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.content[0].path).toBe('other:foo/bar/buzz.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#get()"],"updatePoint":{"line":260,"column":45},"line":260,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, DEFAULT_DIR);\n      const get = contents.get('/foo');\n      await expect(get).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the url of a file","suites":["contents","#getDownloadUrl()"],"updatePoint":{"line":272,"column":36},"line":272,"code":"    it('should get the url of a file', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const test1 = contents.getDownloadUrl('bar.txt');\n      const test2 = contents.getDownloadUrl('fizz/buzz/bar.txt');\n      const test3 = contents.getDownloadUrl('/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should encode characters","suites":["contents","#getDownloadUrl()"],"updatePoint":{"line":284,"column":32},"line":284,"code":"    it('should encode characters', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const url = await contents.getDownloadUrl('b ar?3.txt');\n      expect(url).toBe('http://foo/files/b%20ar%3F3.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle relative paths","suites":["contents","#getDownloadUrl()"],"updatePoint":{"line":291,"column":36},"line":291,"code":"    it('should handle relative paths', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const url = await contents.getDownloadUrl('fizz/../bar.txt');\n      expect(url).toBe('http://foo/files/bar.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the url of a file from an additional drive","suites":["contents","#getDownloadUrl()"],"updatePoint":{"line":298,"column":61},"line":298,"code":"    it('should get the url of a file from an additional drive', async () => {\n      const contents = new ContentsManager();\n      const other = new Drive({ name: 'other', serverSettings: settings });\n      contents.addDrive(other);\n      const test1 = contents.getDownloadUrl('other:bar.txt');\n      const test2 = contents.getDownloadUrl('other:fizz/buzz/bar.txt');\n      const test3 = contents.getDownloadUrl('other:/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a file","suites":["contents","#newUntitled()"],"updatePoint":{"line":313,"column":28},"line":313,"code":"    it('should create a file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const model = await contents.newUntitled({ path: '/foo' });\n      expect(model.path).toBe('foo/test');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a directory","suites":["contents","#newUntitled()"],"updatePoint":{"line":319,"column":33},"line":319,"code":"    it('should create a directory', async () => {\n      handleRequest(contents, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'directory'\n      };\n      const model = await contents.newUntitled(options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a file on an additional drive","suites":["contents","#newUntitled()"],"updatePoint":{"line":329,"column":51},"line":329,"code":"    it('should create a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_FILE);\n      const model = await contents.newUntitled({ path: 'other:/foo' });\n      expect(model.path).toBe('other:foo/test');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a directory on an additional drive","suites":["contents","#newUntitled()"],"updatePoint":{"line":337,"column":56},"line":337,"code":"    it('should create a directory on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: 'other:/foo',\n        type: 'directory'\n      };\n      const model = await contents.newUntitled(options);\n      expect(model.path).toBe('other:' + DEFAULT_DIR.path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["contents","#newUntitled()"],"updatePoint":{"line":349,"column":42},"line":349,"code":"    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled({ type: 'file', ext: 'test' });\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#newUntitled()"],"updatePoint":{"line":362,"column":42},"line":362,"code":"    it('should fail for an incorrect model', async () => {\n      const dir = JSON.parse(JSON.stringify(DEFAULT_DIR));\n      dir.name = 1;\n      handleRequest(contents, 201, dir);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'py'\n      };\n      const newFile = contents.newUntitled(options);\n      await expect(newFile).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#newUntitled()"],"updatePoint":{"line":375,"column":45},"line":375,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_DIR);\n      const newDir = contents.newUntitled();\n      await expect(newDir).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a file","suites":["contents","#delete()"],"updatePoint":{"line":383,"column":28},"line":383,"code":"    it('should delete a file', async () => {\n      handleRequest(contents, 204, {});\n      await expect(contents.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a file on an additional drive","suites":["contents","#delete()"],"updatePoint":{"line":388,"column":51},"line":388,"code":"    it('should delete a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      await expect(\n        contents.delete('other:/foo/bar.txt')\n      ).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["contents","#delete()"],"updatePoint":{"line":397,"column":42},"line":397,"code":"    it('should emit the fileChanged signal', async () => {\n      const path = '/foo/bar.txt';\n      handleRequest(contents, 204, { path });\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('delete');\n        expect(args.oldValue!.path).toBe('foo/bar.txt');\n        called = true;\n      });\n      await contents.delete(path);\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#delete()"],"updatePoint":{"line":410,"column":45},"line":410,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const del = contents.delete('/foo/bar.txt');\n      await expect(del).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw a specific error","suites":["contents","#delete()"],"updatePoint":{"line":416,"column":37},"line":416,"code":"    it('should throw a specific error', async () => {\n      handleRequest(contents, 400, {});\n      const del = contents.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw a general error","suites":["contents","#delete()"],"updatePoint":{"line":422,"column":36},"line":422,"code":"    it('should throw a general error', async () => {\n      handleRequest(contents, 500, {});\n      const del = contents.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should rename a file","suites":["contents","#rename()"],"updatePoint":{"line":430,"column":28},"line":430,"code":"    it('should rename a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should rename a file on an additional drive","suites":["contents","#rename()"],"updatePoint":{"line":437,"column":51},"line":437,"code":"    it('should rename a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 200, DEFAULT_FILE);\n      const rename = contents.rename(\n        'other:/foo/bar.txt',\n        'other:/foo/baz.txt'\n      );\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["contents","#rename()"],"updatePoint":{"line":449,"column":42},"line":449,"code":"    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('rename');\n        expect(args.oldValue!.path).toBe('foo/bar.txt');\n        expect(args.newValue!.path).toBe('foo/test');\n        called = true;\n      });\n      await contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#rename()"],"updatePoint":{"line":462,"column":42},"line":462,"code":"    it('should fail for an incorrect model', async () => {\n      const dir = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete dir.path;\n      handleRequest(contents, 200, dir);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#rename()"],"updatePoint":{"line":470,"column":45},"line":470,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should save a file","suites":["contents","#save()"],"updatePoint":{"line":478,"column":26},"line":478,"code":"    it('should save a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should save a file on an additional drive","suites":["contents","#save()"],"updatePoint":{"line":485,"column":49},"line":485,"code":"    it('should save a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const save = contents.save('other:/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.path).toBe('other:foo');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new file","suites":["contents","#save()"],"updatePoint":{"line":494,"column":32},"line":494,"code":"    it('should create a new file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["contents","#save()"],"updatePoint":{"line":501,"column":42},"line":501,"code":"    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('save');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.save('/foo', { type: 'file', name: 'test' });\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#save()"],"updatePoint":{"line":514,"column":42},"line":514,"code":"    it('should fail for an incorrect model', async () => {\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.format;\n      handleRequest(contents, 200, file);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#save()"],"updatePoint":{"line":522,"column":45},"line":522,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 204, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow(/Invalid response: 204 No Content/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should copy a file","suites":["contents","#copy()"],"updatePoint":{"line":530,"column":26},"line":530,"code":"    it('should copy a file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const model = await contents.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should copy a file on an additional drive","suites":["contents","#copy()"],"updatePoint":{"line":536,"column":49},"line":536,"code":"    it('should copy a file on an additional drive', async () => {\n      const other = new Drive({ serverSettings, name: 'other' });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_FILE);\n      const model = await contents.copy('other:/foo/test', 'other:/baz');\n      expect(model.path).toBe('other:foo/test');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["contents","#copy()"],"updatePoint":{"line":544,"column":42},"line":544,"code":"    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.copy('/foo/bar.txt', '/baz');\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#copy()"],"updatePoint":{"line":557,"column":42},"line":557,"code":"    it('should fail for an incorrect model', async () => {\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.type;\n      handleRequest(contents, 201, file);\n      const copy = contents.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#copy()"],"updatePoint":{"line":565,"column":45},"line":565,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const copy = contents.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a checkpoint","suites":["contents","#createCheckpoint()"],"updatePoint":{"line":573,"column":34},"line":573,"code":"    it('should create a checkpoint', async () => {\n      handleRequest(contents, 201, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a checkpoint on an additional drive","suites":["contents","#createCheckpoint()"],"updatePoint":{"line":580,"column":57},"line":580,"code":"    it('should create a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('other:/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#createCheckpoint()"],"updatePoint":{"line":589,"column":42},"line":589,"code":"    it('should fail for an incorrect model', async () => {\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.last_modified;\n      handleRequest(contents, 201, cp);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#createCheckpoint()"],"updatePoint":{"line":597,"column":45},"line":597,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should list the checkpoints","suites":["contents","#listCheckpoints()"],"updatePoint":{"line":605,"column":35},"line":605,"code":"    it('should list the checkpoints', async () => {\n      handleRequest(contents, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should list the checkpoints on an additional drive","suites":["contents","#listCheckpoints()"],"updatePoint":{"line":612,"column":58},"line":612,"code":"    it('should list the checkpoints on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('other:/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["contents","#listCheckpoints()"],"updatePoint":{"line":621,"column":42},"line":621,"code":"    it('should fail for an incorrect model', async () => {\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.id;\n      handleRequest(contents, 200, [cp, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expectFailure(checkpoints);\n      handleRequest(contents, 200, DEFAULT_CP);\n      const newCheckpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expect(newCheckpoints).rejects.toThrow(/Invalid Checkpoint list/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#listCheckpoints()"],"updatePoint":{"line":632,"column":45},"line":632,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, {});\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expect(checkpoints).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should restore a checkpoint","suites":["contents","#restoreCheckpoint()"],"updatePoint":{"line":642,"column":35},"line":642,"code":"    it('should restore a checkpoint', async () => {\n      handleRequest(contents, 204, {});\n      const checkpoint = contents.restoreCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should restore a checkpoint on an additional drive","suites":["contents","#restoreCheckpoint()"],"updatePoint":{"line":651,"column":58},"line":651,"code":"    it('should restore a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      const checkpoint = contents.restoreCheckpoint(\n        'other:/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#restoreCheckpoint()"],"updatePoint":{"line":662,"column":45},"line":662,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const checkpoint = contents.restoreCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a checkpoint","suites":["contents","#deleteCheckpoint()"],"updatePoint":{"line":673,"column":34},"line":673,"code":"    it('should delete a checkpoint', async () => {\n      handleRequest(contents, 204, {});\n      await expect(\n        contents.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a checkpoint on an additional drive","suites":["contents","#deleteCheckpoint()"],"updatePoint":{"line":680,"column":57},"line":680,"code":"    it('should delete a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      await expect(\n        contents.deleteCheckpoint('other:/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["contents","#deleteCheckpoint()"],"updatePoint":{"line":689,"column":45},"line":689,"code":"    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const checkpoint = contents.deleteCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept no options","suites":["drive","#constructor()"],"updatePoint":{"line":715,"column":32},"line":715,"code":"    it('should accept no options', () => {\n      const drive = new Drive();\n      expect(drive).toBeInstanceOf(Drive);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept options","suites":["drive","#constructor()"],"updatePoint":{"line":720,"column":29},"line":720,"code":"    it('should accept options', () => {\n      const drive = new Drive({\n        name: 'name'\n      });\n      expect(drive).toBeInstanceOf(Drive);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should return the name of the drive","suites":["drive","#name"],"updatePoint":{"line":729,"column":43},"line":729,"code":"    it('should return the name of the drive', () => {\n      const drive = new Drive({\n        name: 'name'\n      });\n      expect(drive.name).toBe('name');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a file changes","suites":["drive","#fileChanged"],"updatePoint":{"line":738,"column":45},"line":738,"code":"    it('should be emitted when a file changes', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(sender).toBe(drive);\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.newUntitled();\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the drive is disposed","suites":["drive","#isDisposed"],"updatePoint":{"line":755,"column":49},"line":755,"code":"    it('should test whether the drive is disposed', () => {\n      const drive = new Drive();\n      expect(drive.isDisposed).toBe(false);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources used by the drive","suites":["drive","#dispose()"],"updatePoint":{"line":764,"column":57},"line":764,"code":"    it('should dispose of the resources used by the drive', () => {\n      const drive = new Drive();\n      expect(drive.isDisposed).toBe(false);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a file","suites":["drive","#get()"],"updatePoint":{"line":775,"column":25},"line":775,"code":"    it('should get a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.path).toBe(DEFAULT_FILE.path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a directory","suites":["drive","#get()"],"updatePoint":{"line":784,"column":30},"line":784,"code":"    it('should get a directory', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#get()"],"updatePoint":{"line":793,"column":37},"line":793,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#get()"],"updatePoint":{"line":802,"column":45},"line":802,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const get = drive.get('/foo');\n      await expect(get).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the url of a file","suites":["drive","#getDownloadUrl()"],"updatePoint":{"line":815,"column":36},"line":815,"code":"    it('should get the url of a file', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const test1 = drive.getDownloadUrl('bar.txt');\n      const test2 = drive.getDownloadUrl('fizz/buzz/bar.txt');\n      const test3 = drive.getDownloadUrl('/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should encode characters","suites":["drive","#getDownloadUrl()"],"updatePoint":{"line":826,"column":32},"line":826,"code":"    it('should encode characters', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const url = await drive.getDownloadUrl('b ar?3.txt');\n      expect(url).toBe('http://foo/files/b%20ar%3F3.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle relative paths","suites":["drive","#getDownloadUrl()"],"updatePoint":{"line":832,"column":36},"line":832,"code":"    it('should handle relative paths', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const url = await drive.getDownloadUrl('fizz/../bar.txt');\n      expect(url).toBe('http://foo/files/bar.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a file","suites":["drive","#newUntitled()"],"updatePoint":{"line":840,"column":28},"line":840,"code":"    it('should create a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.newUntitled({ path: '/foo' });\n      expect(model.path).toBe(DEFAULT_FILE.path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a directory","suites":["drive","#newUntitled()"],"updatePoint":{"line":847,"column":33},"line":847,"code":"    it('should create a directory', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'directory'\n      };\n      const newDir = drive.newUntitled(options);\n      const model = await newDir;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["drive","#newUntitled()"],"updatePoint":{"line":859,"column":42},"line":859,"code":"    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.newUntitled({ type: 'file', ext: 'test' });\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#newUntitled()"],"updatePoint":{"line":873,"column":37},"line":873,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'txt'\n      };\n      const model = await drive.newUntitled(options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#newUntitled()"],"updatePoint":{"line":885,"column":42},"line":885,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const dir = JSON.parse(JSON.stringify(DEFAULT_DIR));\n      dir.name = 1;\n      handleRequest(drive, 201, dir);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'py'\n      };\n      const newFile = drive.newUntitled(options);\n      await expect(newFile).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#newUntitled()"],"updatePoint":{"line":899,"column":45},"line":899,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const newDir = drive.newUntitled();\n      await expect(newDir).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a file","suites":["drive","#delete()"],"updatePoint":{"line":908,"column":28},"line":908,"code":"    it('should delete a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      await expect(drive.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["drive","#delete()"],"updatePoint":{"line":914,"column":42},"line":914,"code":"    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      const path = '/foo/bar.txt';\n      handleRequest(drive, 204, { path });\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('delete');\n        expect(args.oldValue!.path).toBe('/foo/bar.txt');\n        called = true;\n      });\n      await drive.delete(path);\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#delete()"],"updatePoint":{"line":928,"column":37},"line":928,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      await expect(drive.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#delete()"],"updatePoint":{"line":934,"column":45},"line":934,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const del = drive.delete('/foo/bar.txt');\n      await expect(del).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw a specific error","suites":["drive","#delete()"],"updatePoint":{"line":941,"column":37},"line":941,"code":"    it('should throw a specific error', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 400, {});\n      const del = drive.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw a general error","suites":["drive","#delete()"],"updatePoint":{"line":948,"column":36},"line":948,"code":"    it('should throw a general error', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 500, {});\n      const del = drive.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should rename a file","suites":["drive","#rename()"],"updatePoint":{"line":957,"column":28},"line":957,"code":"    it('should rename a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["drive","#rename()"],"updatePoint":{"line":965,"column":42},"line":965,"code":"    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('rename');\n        expect(args.oldValue!.path).toBe('/foo/bar.txt');\n        expect(args.newValue!.path).toBe('foo/test');\n        called = true;\n      });\n      await drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#rename()"],"updatePoint":{"line":979,"column":37},"line":979,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#rename()"],"updatePoint":{"line":987,"column":42},"line":987,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const dir = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete dir.path;\n      handleRequest(drive, 200, dir);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#rename()"],"updatePoint":{"line":996,"column":45},"line":996,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should save a file","suites":["drive","#save()"],"updatePoint":{"line":1005,"column":26},"line":1005,"code":"    it('should save a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new file","suites":["drive","#save()"],"updatePoint":{"line":1013,"column":32},"line":1013,"code":"    it('should create a new file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["drive","#save()"],"updatePoint":{"line":1021,"column":42},"line":1021,"code":"    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('save');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.save('/foo', { type: 'file', name: 'test' });\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#save()"],"updatePoint":{"line":1035,"column":37},"line":1035,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#save()"],"updatePoint":{"line":1043,"column":42},"line":1043,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.format;\n      handleRequest(drive, 200, file);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#save()"],"updatePoint":{"line":1052,"column":45},"line":1052,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow(/Invalid response: 204 No Content/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should copy a file","suites":["drive","#copy()"],"updatePoint":{"line":1061,"column":26},"line":1061,"code":"    it('should copy a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit the fileChanged signal","suites":["drive","#copy()"],"updatePoint":{"line":1068,"column":42},"line":1068,"code":"    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.copy('/foo/bar.txt', '/baz');\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#copy()"],"updatePoint":{"line":1082,"column":37},"line":1082,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#copy()"],"updatePoint":{"line":1089,"column":42},"line":1089,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.type;\n      handleRequest(drive, 201, file);\n      const copy = drive.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#copy()"],"updatePoint":{"line":1098,"column":45},"line":1098,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const copy = drive.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a checkpoint","suites":["drive","#createCheckpoint()"],"updatePoint":{"line":1107,"column":34},"line":1107,"code":"    it('should create a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#createCheckpoint()"],"updatePoint":{"line":1115,"column":37},"line":1115,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#createCheckpoint()"],"updatePoint":{"line":1123,"column":42},"line":1123,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.last_modified;\n      handleRequest(drive, 201, cp);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#createCheckpoint()"],"updatePoint":{"line":1132,"column":45},"line":1132,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should list the checkpoints","suites":["drive","#listCheckpoints()"],"updatePoint":{"line":1141,"column":35},"line":1141,"code":"    it('should list the checkpoints', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#listCheckpoints()"],"updatePoint":{"line":1149,"column":37},"line":1149,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect model","suites":["drive","#listCheckpoints()"],"updatePoint":{"line":1157,"column":42},"line":1157,"code":"    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.id;\n      handleRequest(drive, 200, [cp, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expectFailure(checkpoints);\n      handleRequest(drive, 200, DEFAULT_CP);\n      const newCheckpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expect(newCheckpoints).rejects.toThrow(/Invalid Checkpoint list/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#listCheckpoints()"],"updatePoint":{"line":1169,"column":45},"line":1169,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, {});\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expect(checkpoints).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should restore a checkpoint","suites":["drive","#restoreCheckpoint()"],"updatePoint":{"line":1180,"column":35},"line":1180,"code":"    it('should restore a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#restoreCheckpoint()"],"updatePoint":{"line":1187,"column":37},"line":1187,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#restoreCheckpoint()"],"updatePoint":{"line":1194,"column":45},"line":1194,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should delete a checkpoint","suites":["drive","#deleteCheckpoint()"],"updatePoint":{"line":1203,"column":34},"line":1203,"code":"    it('should delete a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      await expect(\n        drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["drive","#deleteCheckpoint()"],"updatePoint":{"line":1211,"column":37},"line":1211,"code":"    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      await expect(\n        drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response","suites":["drive","#deleteCheckpoint()"],"updatePoint":{"line":1219,"column":45},"line":1219,"code":"    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const checkpoint = drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should list a directory and get the file contents","suites":["drive","integration tests"],"updatePoint":{"line":1228,"column":57},"line":1228,"code":"    it('should list a directory and get the file contents', async () => {\n      let content: Contents.IModel[];\n      let path = '';\n      const listing = await contents.get('src');\n      content = listing.content as Contents.IModel[];\n      let called = false;\n      for (let i = 0; i < content.length; i++) {\n        if (content[i].type === 'file') {\n          path = content[i].path;\n          const msg = await contents.get(path, { type: 'file' });\n          // eslint-disable-next-line jest/no-conditional-expect\n          expect(msg.path).toBe(path);\n          called = true;\n        }\n      }\n      expect(called).toBe(true);\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new file, rename it, and delete it","suites":["drive","integration tests"],"updatePoint":{"line":1246,"column":58},"line":1246,"code":"    it('should create a new file, rename it, and delete it', async () => {\n      const options: Contents.ICreateOptions = { type: 'file', ext: '.ipynb' };\n      const model0 = await contents.newUntitled(options);\n      const model1 = await contents.rename(model0.path, 'foo.ipynb');\n      expect(model1.path).toBe('foo.ipynb');\n      return contents.delete('foo.ipynb');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a file by name and delete it","suites":["drive","integration tests"],"updatePoint":{"line":1254,"column":50},"line":1254,"code":"    it('should create a file by name and delete it', async () => {\n      const options: Partial<Contents.IModel> = {\n        type: 'file',\n        content: '',\n        format: 'text'\n      };\n      await contents.save('baz.txt', options);\n      await expect(contents.delete('baz.txt')).resolves.not.toThrow();\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should exercise the checkpoint API","suites":["drive","integration tests"],"updatePoint":{"line":1264,"column":42},"line":1264,"code":"    it('should exercise the checkpoint API', async () => {\n      const options: Partial<Contents.IModel> = {\n        type: 'file',\n        format: 'text',\n        content: 'foo'\n      };\n      let checkpoint: Contents.ICheckpointModel;\n      const model0 = await contents.save('baz.txt', options);\n      expect(model0.name).toBe('baz.txt');\n      const value = await contents.createCheckpoint('baz.txt');\n      checkpoint = value;\n      const checkpoints = await contents.listCheckpoints('baz.txt');\n      expect(checkpoints[0]).toEqual(checkpoint);\n      await contents.restoreCheckpoint('baz.txt', checkpoint.id);\n      await contents.deleteCheckpoint('baz.txt', checkpoint.id);\n      await contents.delete('baz.txt');\n    });","file":"contents/index.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass with valid data","suites":["validate","validateContentsModel()"],"updatePoint":{"line":12,"column":35},"line":12,"code":"    it('should pass with valid data', () => {\n      expect(() => {\n        validateContentsModel(DEFAULT_FILE);\n      }).not.toThrow();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on missing data","suites":["validate","validateContentsModel()"],"updatePoint":{"line":18,"column":35},"line":18,"code":"    it('should fail on missing data', () => {\n      const model = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete model['path'];\n      expect(() => validateContentsModel(model)).toThrowError();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on incorrect data","suites":["validate","validateContentsModel()"],"updatePoint":{"line":24,"column":37},"line":24,"code":"    it('should fail on incorrect data', () => {\n      const model = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      model.type = 1;\n      expect(() => validateContentsModel(model)).toThrowError();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass with valid data","suites":["validate","validateCheckpointModel()"],"updatePoint":{"line":32,"column":35},"line":32,"code":"    it('should pass with valid data', () => {\n      expect(() => {\n        validateCheckpointModel({ id: 'foo', last_modified: 'yesterday ' });\n      }).not.toThrow();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on missing data","suites":["validate","validateCheckpointModel()"],"updatePoint":{"line":38,"column":35},"line":38,"code":"    it('should fail on missing data', () => {\n      const model = { id: 'foo' };\n      expect(() => validateCheckpointModel(model as any)).toThrowError();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on incorrect data","suites":["validate","validateCheckpointModel()"],"updatePoint":{"line":43,"column":37},"line":43,"code":"    it('should fail on incorrect data', () => {\n      const model = { id: 1, last_modified: '1' };\n      expect(() => validateCheckpointModel(model as any)).toThrowError();\n    });","file":"contents/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create an instance of IComm","suites":["jupyter.services - Comm","Kernel","#createComm()"],"updatePoint":{"line":82,"column":44},"line":82,"code":"      it('should create an instance of IComm', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.targetName).toBe('test');\n        expect(typeof comm.commId).toBe('string');\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should use the given id","suites":["jupyter.services - Comm","Kernel","#createComm()"],"updatePoint":{"line":88,"column":33},"line":88,"code":"      it('should use the given id', () => {\n        const comm = kernel.createComm('test', '1234');\n        expect(comm.targetName).toBe('test');\n        expect(comm.commId).toBe('1234');\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error if there is an existing comm","suites":["jupyter.services - Comm","Kernel","#createComm()"],"updatePoint":{"line":94,"column":60},"line":94,"code":"      it('should throw an error if there is an existing comm', () => {\n        expect(() => kernel.createComm('test', '1234')).toThrowError();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error when the kernel does not handle comms","suites":["jupyter.services - Comm","Kernel","#createComm()"],"updatePoint":{"line":98,"column":69},"line":98,"code":"      it('should throw an error when the kernel does not handle comms', async () => {\n        const kernel2 = await kernelManager.startNew(\n          { name: 'ipython' },\n          { handleComms: false }\n        );\n        expect(kernel2.handleComms).toBe(false);\n        expect(() => kernel2.createComm('test', '1234')).toThrowError();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test if there is a registered comm","suites":["jupyter.services - Comm","Kernel","#hasComm()"],"updatePoint":{"line":109,"column":51},"line":109,"code":"      it('should test if there is a registered comm', () => {\n        expect(kernel.hasComm('test comm')).toBe(false);\n        const comm = kernel.createComm('test', 'test comm');\n        expect(kernel.hasComm('test comm')).toBe(true);\n        comm.dispose();\n        expect(kernel.hasComm('test comm')).toBe(false);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should call the provided callback","suites":["jupyter.services - Comm","Kernel","#registerCommTarget()"],"updatePoint":{"line":119,"column":43},"line":119,"code":"      it('should call the provided callback', async () => {\n        const promise = new PromiseDelegate<\n          [Kernel.IComm, KernelMessage.ICommOpenMsg]\n        >();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          promise.resolve([comm, msg]);\n        };\n        kernel.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel.requestExecute({ code: SEND }, true).done;\n\n        // Get the comm.\n        const [comm, msg] = await promise.promise;\n        expect(msg.content.data).toBe('hello');\n\n        // Clean up\n        kernel.removeCommTarget('test', hook);\n        comm.dispose();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should do nothing if the kernel does not handle comms","suites":["jupyter.services - Comm","Kernel","#registerCommTarget()"],"updatePoint":{"line":140,"column":63},"line":140,"code":"      it('should do nothing if the kernel does not handle comms', async () => {\n        const promise = new PromiseDelegate<\n          [Kernel.IComm, KernelMessage.ICommOpenMsg]\n        >();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          promise.resolve([comm, msg]);\n        };\n        const kernel2 = await kernelManager.startNew(\n          { name: 'ipython' },\n          { handleComms: false }\n        );\n        kernel2.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel2.requestExecute({ code: SEND }, true).done;\n\n        // The promise above should not be fulfilled, even after a short delay.\n        expect(await isFulfilled(promise.promise, 300)).toBe(false);\n\n        // The kernel comm has not been closed - we just completely ignored it.\n        const reply = await kernel2.requestExecute(\n          { code: `assert comm._closed is False` },\n          true\n        ).done;\n        // If the assert was false, we would get an 'error' status\n        expect(reply!.content.status).toBe('ok');\n\n        // Clean up\n        kernel2.removeCommTarget('test', hook);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the comm info","suites":["jupyter.services - Comm","Kernel","#commInfo()"],"updatePoint":{"line":173,"column":34},"line":173,"code":"      it('should get the comm info', async () => {\n        const commPromise = new PromiseDelegate<Kernel.IComm>();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          commPromise.resolve(comm);\n        };\n        kernel.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel.requestExecute({ code: SEND }, true).done;\n\n        // Get the comm.\n        const comm = await commPromise.promise;\n\n        // Ask the kernel for the list of current comms.\n        const msg = await kernel.requestCommInfo({});\n\n        if (msg.content.status !== 'ok') {\n          throw new Error('Message error');\n        }\n\n        // Test to make sure the comm we just created is listed.\n        const comms = msg.content.comms;\n        expect(comms[comm.commId].target_name).toBe('test');\n\n        // Clean up\n        kernel.removeCommTarget('test', hook);\n        comm.dispose();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should allow an optional target name","suites":["jupyter.services - Comm","Kernel","#commInfo()"],"updatePoint":{"line":202,"column":46},"line":202,"code":"      it('should allow an optional target name', async () => {\n        await kernel.requestExecute({ code: SEND }, true).done;\n        const msg = await kernel.requestCommInfo({ target_name: 'test' });\n        if (msg.content.status !== 'ok') {\n          throw new Error('Message error');\n        }\n        const comms = msg.content.comms;\n        for (const id in comms) {\n          expect(comms[id].target_name).toBe('test');\n        }\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be true after we dispose of the comm","suites":["jupyter.services - Comm","Kernel","#isDisposed"],"updatePoint":{"line":216,"column":53},"line":216,"code":"      it('should be true after we dispose of the comm', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.isDisposed).toBe(false);\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call multiple times","suites":["jupyter.services - Comm","Kernel","#isDisposed"],"updatePoint":{"line":223,"column":47},"line":223,"code":"      it('should be safe to call multiple times', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.isDisposed).toBe(false);\n        expect(comm.isDisposed).toBe(false);\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n        expect(comm.isDisposed).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources held by the comm","suites":["jupyter.services - Comm","Kernel","#dispose()"],"updatePoint":{"line":234,"column":58},"line":234,"code":"      it('should dispose of the resources held by the comm', () => {\n        const comm = kernel.createComm('foo');\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["jupyter.services - Comm","IComm","#id"],"updatePoint":{"line":250,"column":28},"line":250,"code":"      it('should be a string', () => {\n        expect(typeof comm.commId).toBe('string');\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["jupyter.services - Comm","IComm","#name"],"updatePoint":{"line":256,"column":28},"line":256,"code":"      it('should be a string', () => {\n        expect(comm.targetName).toBe('test');\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be readable and writable function","suites":["jupyter.services - Comm","IComm","#onClose"],"updatePoint":{"line":262,"column":50},"line":262,"code":"      it('should be readable and writable function', async () => {\n        expect(comm.onClose).toBeUndefined();\n        let called = false;\n        comm.onClose = msg => {\n          called = true;\n        };\n        await comm.close().done;\n        expect(called).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be called when the server side closes","suites":["jupyter.services - Comm","IComm","#onClose"],"updatePoint":{"line":272,"column":54},"line":272,"code":"      it('should be called when the server side closes', async () => {\n        const promise = new PromiseDelegate<void>();\n        kernel.registerCommTarget('test', (comm, msg) => {\n          comm.onClose = data => {\n            promise.resolve(void 0);\n          };\n          comm.send('quit');\n        });\n        await kernel.requestExecute({ code: SEND }, true).done;\n        await expect(promise.promise).resolves.not.toThrow();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be readable and writable function","suites":["jupyter.services - Comm","IComm","#onMsg"],"updatePoint":{"line":286,"column":50},"line":286,"code":"      it('should be readable and writable function', async () => {\n        let called = false;\n        comm.onMsg = msg => {\n          called = true;\n        };\n        expect(typeof comm.onMsg).toBe('function');\n        const msg = KernelMessage.createMessage({\n          msgType: 'comm_msg',\n          channel: 'iopub',\n          username: kernel.username,\n          session: kernel.clientId,\n          content: {\n            comm_id: 'abcd',\n            data: {}\n          }\n        });\n        await comm.onMsg(msg);\n        expect(called).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be called when the server side sends a message","suites":["jupyter.services - Comm","IComm","#onMsg"],"updatePoint":{"line":306,"column":63},"line":306,"code":"      it('should be called when the server side sends a message', async () => {\n        let called = false;\n        kernel.registerCommTarget('test', (comm, msg) => {\n          comm.onMsg = msg => {\n            expect(msg.content.data).toBe('hello');\n            called = true;\n          };\n        });\n        await kernel.requestExecute({ code: BLIP }, true).done;\n        expect(called).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a message to the server","suites":["jupyter.services - Comm","IComm","#open()"],"updatePoint":{"line":320,"column":45},"line":320,"code":"      it('should send a message to the server', async () => {\n        const future = kernel.requestExecute({ code: TARGET });\n        await future.done;\n        const encoder = new TextEncoder();\n        const data = encoder.encode('hello');\n        const future2 = comm.open({ foo: 'bar' }, { fizz: 'buzz' }, [\n          data,\n          data.buffer\n        ]);\n        await expect(future2.done).resolves.not.toThrow();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a message to the server","suites":["jupyter.services - Comm","IComm","#send()"],"updatePoint":{"line":334,"column":45},"line":334,"code":"      it('should send a message to the server', async () => {\n        await comm.open().done;\n        const future = comm.send({ foo: 'bar' }, { fizz: 'buzz' });\n        await expect(future.done).resolves.not.toThrow();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass through a buffers field","suites":["jupyter.services - Comm","IComm","#send()"],"updatePoint":{"line":340,"column":45},"line":340,"code":"      it('should pass through a buffers field', async () => {\n        await comm.open().done;\n        const future = comm.send({ buffers: 'bar' });\n        await expect(future.done).resolves.not.toThrow();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a message to the server","suites":["jupyter.services - Comm","IComm","#close()"],"updatePoint":{"line":348,"column":45},"line":348,"code":"      it('should send a message to the server', async () => {\n        await comm.open().done;\n        const encoder = new TextEncoder();\n        const data = encoder.encode('hello');\n        const future = comm.close({ foo: 'bar' }, {}, [data, data.buffer]);\n        await expect(future.done).resolves.not.toThrow();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should trigger an onClose","suites":["jupyter.services - Comm","IComm","#close()"],"updatePoint":{"line":356,"column":35},"line":356,"code":"      it('should trigger an onClose', async () => {\n        await comm.open().done;\n        let called = false;\n        comm.onClose = (msg: KernelMessage.ICommCloseMsg) => {\n          expect(msg.content.data).toEqual({ foo: 'bar' });\n          called = true;\n        };\n        const future = comm.close({ foo: 'bar' });\n        await future.done;\n        expect(called).toBe(true);\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not send subsequent messages","suites":["jupyter.services - Comm","IComm","#close()"],"updatePoint":{"line":368,"column":45},"line":368,"code":"      it('should not send subsequent messages', async () => {\n        await comm.open().done;\n        await comm.close({ foo: 'bar' }).done;\n        expect(() => {\n          comm.send('test');\n        }).toThrowError();\n      });","file":"kernel/comm.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should have a msg attribute","suites":["Kernel.IShellFuture"],"updatePoint":{"line":37,"column":33},"line":37,"code":"  it('should have a msg attribute', async () => {\n    const kernel = await kernelManager.startNew();\n    await kernel.info;\n    const future = kernel.requestExecute({ code: 'print(\"hello\")' });\n    expect(typeof future.msg.header.msg_id).toBe('string');\n    await future.done;\n    await kernel.shutdown();\n  });","file":"kernel/ifuture.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should have the most recently registered hook run first","suites":["Kernel.IShellFuture","Message hooks"],"updatePoint":{"line":47,"column":63},"line":47,"code":"    it('should have the most recently registered hook run first', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push('last');\n          return true;\n        });\n\n        future.registerMessageHook(msg => {\n          calls.push('first');\n          // Check to make sure we actually got the messages we expected.\n          if (msg.header.msg_type === 'stream') {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect((msg as KernelMessage.IStreamMsg).content.text).toBe('foo');\n          } else {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(\n              (msg as KernelMessage.IStatusMsg).content.execution_state\n            ).toBe('idle');\n          }\n          // not returning should also continue handling\n          return void 0 as any;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual([\n        'first',\n        'last',\n        'iopub',\n        'first',\n        'last',\n        'iopub'\n      ]);\n    });","file":"kernel/ifuture.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should abort processing if a hook returns false, but the done logic should still work","suites":["Kernel.IShellFuture","Message hooks"],"updatePoint":{"line":140,"column":93},"line":140,"code":"    it('should abort processing if a hook returns false, but the done logic should still work', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(msg => {\n          calls.push('last');\n          return true;\n        });\n\n        future.registerMessageHook(async msg => {\n          calls.push('first');\n          return false;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual(['first', 'first']);\n    });","file":"kernel/ifuture.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should process additions on the next run","suites":["Kernel.IShellFuture","Message hooks"],"updatePoint":{"line":213,"column":48},"line":213,"code":"    it('should process additions on the next run', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(msg => {\n          calls.push('last');\n          future.registerMessageHook(msg => {\n            calls.push('first');\n            return true;\n          });\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['last', 'iopub', 'first', 'last', 'iopub']);\n    });","file":"kernel/ifuture.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should deactivate message hooks immediately on removal","suites":["Kernel.IShellFuture","Message hooks"],"updatePoint":{"line":283,"column":62},"line":283,"code":"    it('should deactivate message hooks immediately on removal', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n\n      const toDelete = (msg: KernelMessage.IIOPubMessage) => {\n        calls.push('delete');\n        return true;\n      };\n      const first = (msg: KernelMessage.IIOPubMessage) => {\n        if (calls.length > 0) {\n          // delete the hook the second time around\n          future.removeMessageHook(toDelete);\n        }\n        calls.push('first');\n        return true;\n      };\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(toDelete);\n        future.registerMessageHook(first);\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n\n      expect(calls).toEqual(['first', 'delete', 'iopub', 'first', 'iopub']);\n      future.dispose();\n      future.removeMessageHook(first);\n    });","file":"kernel/ifuture.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the kernel is disposed","suites":["Kernel.IKernel","#disposed"],"updatePoint":{"line":56,"column":53},"line":56,"code":"    it('should be emitted when the kernel is disposed', async () => {\n      await defaultKernel.info;\n      let called = false;\n      defaultKernel.disposed.connect((sender, args) => {\n        expect(sender).toBe(defaultKernel);\n        expect(args).toBeUndefined();\n        called = true;\n      });\n      defaultKernel.dispose();\n      expect(called).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the kernel is shut down","suites":["Kernel.IKernel","#disposed"],"updatePoint":{"line":68,"column":54},"line":68,"code":"    it('should be emitted when the kernel is shut down', async () => {\n      await defaultKernel.info;\n      let called = false;\n      defaultKernel.disposed.connect((sender, args) => {\n        expect(sender).toBe(defaultKernel);\n        expect(args).toBeUndefined();\n        called = true;\n      });\n      await defaultKernel.shutdown();\n      expect(called).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a signal following the Kernel status","suites":["Kernel.IKernel","#statusChanged"],"updatePoint":{"line":82,"column":54},"line":82,"code":"    it('should be a signal following the Kernel status', async () => {\n      let called = false;\n      defaultKernel.statusChanged.connect(() => {\n        if (defaultKernel.status === 'busy') {\n          called = true;\n        }\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      expect(called).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a signal following input request","suites":["Kernel.IKernel","#pendingInput"],"updatePoint":{"line":95,"column":50},"line":95,"code":"    it('should be a signal following input request', async () => {\n      let called = false;\n      defaultKernel.pendingInput.connect((sender, args) => {\n        if (!called) {\n          called = true;\n          defaultKernel.sendInputReply({ status: 'ok', value: 'foo' });\n        }\n      });\n      const code = `input(\"Input something\")`;\n      await defaultKernel.requestExecute(\n        {\n          code: code,\n          allow_stdin: true\n        },\n        true\n      ).done;\n      expect(called).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an iopub message","suites":["Kernel.IKernel","#iopubMessage"],"updatePoint":{"line":116,"column":46},"line":116,"code":"    it('should be emitted for an iopub message', async () => {\n      let called = false;\n      defaultKernel.iopubMessage.connect((k, msg) => {\n        called = true;\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      expect(called).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted regardless of the sender","suites":["Kernel.IKernel","#iopubMessage"],"updatePoint":{"line":125,"column":50},"line":125,"code":"    it('should be emitted regardless of the sender', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.iopubMessage, {\n        find: (k, msg) => msg.header.msg_id === msgId\n      });\n      const msg = KernelMessage.createMessage({\n        msgType: 'status',\n        channel: 'iopub',\n        session: tester.serverSessionId,\n        msgId,\n        content: {\n          execution_state: 'idle'\n        }\n      });\n      tester.send(msg);\n      await emission;\n      await expect(tester.shutdown()).resolves.not.toThrow();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an unhandled message","suites":["Kernel.IKernel","#unhandledMessage"],"updatePoint":{"line":158,"column":50},"line":158,"code":"    it('should be emitted for an unhandled message', async () => {\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.unhandledMessage, {\n        find: (k, msg) => msg.header.msg_id === msgId\n      });\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n      await expect(emission).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not be emitted for an iopub signal","suites":["Kernel.IKernel","#unhandledMessage"],"updatePoint":{"line":176,"column":49},"line":176,"code":"    it('should not be emitted for an iopub signal', async () => {\n      const kernel = await tester.start();\n\n      // We'll send two messages, first an iopub message, then a shell message.\n      // The unhandledMessage signal should only emit once for the shell message.\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.unhandledMessage, {\n        test: (k, msg) => {\n          expect(msg.header.msg_id).toBe(msgId);\n        }\n      });\n\n      // Send an iopub message.\n      tester.sendStatus(UUID.uuid4(), 'idle');\n\n      // Send a shell message.\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n\n      await emission;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not be emitted for a different client session","suites":["Kernel.IKernel","#unhandledMessage"],"updatePoint":{"line":205,"column":60},"line":205,"code":"    it('should not be emitted for a different client session', async () => {\n      const kernel = await tester.start();\n\n      // We'll send two messages, first a message with a different session, then\n      // one with the current client session. The unhandledMessage signal should\n      // only emit once for the current session message.\n      const msgId = 'message from right session';\n      const emission = testEmission(kernel.unhandledMessage, {\n        test: (k, msg) => {\n          expect((msg.parent_header as KernelMessage.IHeader).session).toBe(\n            kernel.clientId\n          );\n          expect(msg.header.msg_id).toBe(msgId);\n        }\n      });\n\n      // Send a shell message with the wrong client (parent) session.\n      const msg1 = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId: 'message from wrong session',\n        content: {}\n      });\n      msg1.parent_header = { session: 'wrong session' } as any;\n      tester.send(msg1);\n\n      // Send a shell message with the right client (parent) session.\n      const msg2 = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId: msgId,\n        content: {}\n      });\n      msg2.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg2);\n\n      await emission;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an unhandled message","suites":["Kernel.IKernel","#anyMessage"],"updatePoint":{"line":257,"column":50},"line":257,"code":"    it('should be emitted for an unhandled message', async () => {\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, args) => {\n          expect(args.msg.header.msg_id).toBe(msgId);\n          expect(args.msg.header.msg_type).toBe('kernel_info_request');\n          expect(args.direction).toBe('recv');\n        }\n      });\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n      await emission;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an iopub message","suites":["Kernel.IKernel","#anyMessage"],"updatePoint":{"line":281,"column":46},"line":281,"code":"    it('should be emitted for an iopub message', async () => {\n      const kernel = await tester.start();\n      const msgId = 'idle status';\n\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, args) => {\n          expect((args.msg.header as any).msg_id).toBe(msgId);\n          expect(args.direction).toBe('recv');\n        }\n      });\n      tester.sendStatus(msgId, 'idle');\n      await emission;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an stdin message","suites":["Kernel.IKernel","#anyMessage"],"updatePoint":{"line":295,"column":46},"line":295,"code":"    it('should be emitted for an stdin message', async () => {\n      const kernel = await tester.start();\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, { msg, direction }) => {\n          if (!KernelMessage.isInputReplyMsg(msg)) {\n            throw new Error('Unexpected message');\n          }\n          if (msg.content.status !== 'ok') {\n            throw new Error('Message has been changed');\n          }\n          expect(msg.content.value).toBe('foo');\n          expect(direction).toBe('send');\n        }\n      });\n      kernel.sendInputReply({ status: 'ok', value: 'foo' });\n      await emission;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["Kernel.IKernel","#id"],"updatePoint":{"line":315,"column":26},"line":315,"code":"    it('should be a string', () => {\n      expect(typeof defaultKernel.id).toBe('string');\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["Kernel.IKernel","#name"],"updatePoint":{"line":321,"column":26},"line":321,"code":"    it('should be a string', () => {\n      expect(typeof defaultKernel.name).toBe('string');\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["Kernel.IKernel","#username"],"updatePoint":{"line":327,"column":26},"line":327,"code":"    it('should be a string', () => {\n      expect(typeof defaultKernel.username).toBe('string');\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the server settings","suites":["Kernel.IKernel","#serverSettings"],"updatePoint":{"line":333,"column":37},"line":333,"code":"    it('should be the server settings', () => {\n      expect(defaultKernel.serverSettings.baseUrl).toBe(\n        PageConfig.getBaseUrl()\n      );\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["Kernel.IKernel","#clientId"],"updatePoint":{"line":341,"column":26},"line":341,"code":"    it('should be a string', () => {\n      expect(typeof defaultKernel.clientId).toBe('string');\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get an idle status","suites":["Kernel.IKernel","#status"],"updatePoint":{"line":351,"column":33},"line":351,"code":"    it('should get an idle status', async () => {\n      const emission = testEmission(defaultKernel.statusChanged, {\n        find: () => defaultKernel.status === 'idle'\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }).done;\n      await expect(emission).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a restarting status","suites":["Kernel.IKernel","#status"],"updatePoint":{"line":359,"column":38},"line":359,"code":"    it('should get a restarting status', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      const emission = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'restarting'\n      });\n      await kernel.requestKernelInfo();\n      await kernel.restart();\n      await expect(emission).resolves.not.toThrow();\n      await kernel.requestKernelInfo();\n      await kernel.shutdown();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a busy status","suites":["Kernel.IKernel","#status"],"updatePoint":{"line":372,"column":32},"line":372,"code":"    it('should get a busy status', async () => {\n      const emission = testEmission(defaultKernel.statusChanged, {\n        find: () => defaultKernel.status === 'busy'\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      await expect(emission).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get an unknown status while disconnected","suites":["Kernel.IKernel","#status"],"updatePoint":{"line":380,"column":55},"line":380,"code":"    it('should get an unknown status while disconnected', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const emission = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'unknown'\n      });\n\n      await tester.close();\n      await expect(emission).resolves.not.toThrow();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get a dead status","suites":["Kernel.IKernel","#status"],"updatePoint":{"line":392,"column":32},"line":392,"code":"    it('should get a dead status', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      await kernel.info;\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await expect(dead).resolves.not.toThrow();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the kernel info","suites":["Kernel.IKernel","#info"],"updatePoint":{"line":406,"column":34},"line":406,"code":"    it('should get the kernel info', async () => {\n      const name = (await defaultKernel.info).language_info.name;\n      const defaultSpecs = specs.kernelspecs[specs.default]!;\n      expect(name).toBe(defaultSpecs.language);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve with the spec","suites":["Kernel.IKernel","#spec"],"updatePoint":{"line":414,"column":36},"line":414,"code":"    it('should resolve with the spec', async () => {\n      const spec = await defaultKernel.spec;\n      expect(spec!.name).toBe(specs.default);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be true after we dispose of the kernel","suites":["Kernel.IKernel","#isDisposed"],"updatePoint":{"line":421,"column":53},"line":421,"code":"    it('should be true after we dispose of the kernel', async () => {\n      const kernel = defaultKernel.clone();\n      expect(kernel.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(kernel.isDisposed).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call multiple times","suites":["Kernel.IKernel","#isDisposed"],"updatePoint":{"line":428,"column":45},"line":428,"code":"    it('should be safe to call multiple times', async () => {\n      const kernel = defaultKernel.clone();\n      expect(kernel.isDisposed).toBe(false);\n      expect(kernel.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(kernel.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources held by the kernel","suites":["Kernel.IKernel","#dispose()"],"updatePoint":{"line":439,"column":58},"line":439,"code":"    it('should dispose of the resources held by the kernel', async () => {\n      const kernel = defaultKernel.clone();\n      const future = kernel.requestExecute({ code: 'foo' });\n      expect(future.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call twice","suites":["Kernel.IKernel","#dispose()"],"updatePoint":{"line":447,"column":36},"line":447,"code":"    it('should be safe to call twice', async () => {\n      const kernel = defaultKernel.clone();\n      const future = kernel.requestExecute({ code: 'foo' });\n      expect(future.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a message to the kernel","suites":["Kernel.IKernel","#sendShellMessage()"],"updatePoint":{"line":474,"column":43},"line":474,"code":"    it('should send a message to the kernel', async () => {\n      const done = new PromiseDelegate<void>();\n      const msgId = UUID.uuid4();\n\n      tester.onMessage(msg => {\n        try {\n          expect(msg.header.msg_id).toBe(msgId);\n        } catch (e) {\n          done.reject(e);\n          throw e;\n        }\n        done.resolve();\n      });\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        msgId,\n        content: {}\n      });\n      kernel.sendShellMessage(msg, true);\n      await done.promise;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a binary message","suites":["Kernel.IKernel","#sendShellMessage()"],"updatePoint":{"line":500,"column":36},"line":500,"code":"    it('should send a binary message', async () => {\n      const done = new PromiseDelegate<void>();\n      const msgId = UUID.uuid4();\n\n      tester.onMessage(msg => {\n        try {\n          const decoder = new TextDecoder('utf8');\n          const item = msg.buffers![0] as DataView;\n          expect(decoder.decode(item)).toBe('hello');\n        } catch (e) {\n          done.reject(e);\n          throw e;\n        }\n        done.resolve();\n      });\n\n      const encoder = new TextEncoder();\n      const data = encoder.encode('hello');\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        msgId,\n        content: {},\n        buffers: [data, data.buffer]\n      });\n      kernel.sendShellMessage(msg, true);\n      await done.promise;\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the kernel is dead","suites":["Kernel.IKernel","#sendShellMessage()"],"updatePoint":{"line":531,"column":41},"line":531,"code":"    it('should fail if the kernel is dead', async () => {\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      expect(kernel.status).toBe('dead');\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        content: {}\n      });\n      expect(() => {\n        kernel.sendShellMessage(msg, true);\n      }).toThrowError(/Kernel is dead/);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle out of order messages","suites":["Kernel.IKernel","#sendShellMessage()"],"updatePoint":{"line":552,"column":43},"line":552,"code":"    it('should handle out of order messages', async () => {\n      // This test that a future.done promise resolves when a status idle and\n      // reply come through, even if the status comes first.\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        content: {}\n      });\n      const future = kernel.sendShellMessage(msg, true);\n\n      tester.onMessage(msg => {\n        // trigger onDone\n        tester.send(\n          KernelMessage.createMessage({\n            msgType: 'status',\n            channel: 'iopub',\n            username: kernel.username,\n            session: kernel.clientId,\n            content: { execution_state: 'idle' },\n            parentHeader: msg.header\n          })\n        );\n\n        future.onIOPub = () => {\n          tester.send(\n            KernelMessage.createMessage({\n              msgType: 'comm_open',\n              channel: 'shell',\n              username: kernel.username,\n              session: kernel.clientId,\n              content: {\n                comm_id: 'abcd',\n                target_name: 'target',\n                data: {}\n              },\n              parentHeader: msg.header\n            })\n          );\n        };\n      });\n      await expect(future.done).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should interrupt and resolve with a valid server response","suites":["Kernel.IKernel","#interrupt()"],"updatePoint":{"line":600,"column":65},"line":600,"code":"    it('should interrupt and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await expect(kernel.interrupt()).resolves.not.toThrow();\n      await kernel.shutdown();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["Kernel.IKernel","#interrupt()"],"updatePoint":{"line":606,"column":53},"line":606,"code":"    it('should throw an error for an invalid response', async () => {\n      handleRequest(defaultKernel, 200, {\n        id: defaultKernel.id,\n        name: defaultKernel.name\n      });\n      const interrupt = defaultKernel.interrupt();\n      await expect(interrupt).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an error response","suites":["Kernel.IKernel","#interrupt()"],"updatePoint":{"line":615,"column":51},"line":615,"code":"    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const interrupt = defaultKernel.interrupt();\n      await expect(interrupt).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the kernel is dead","suites":["Kernel.IKernel","#interrupt()"],"updatePoint":{"line":621,"column":41},"line":621,"code":"    it('should fail if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.interrupt()).rejects.toThrow(/Kernel is dead/);\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should restart and resolve with a valid server response","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":641,"column":63},"line":641,"code":"    it('should restart and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      await kernel.requestKernelInfo();\n      await kernel.restart();\n      await expect(kernel.requestKernelInfo()).resolves.not.toThrow();\n      await kernel.shutdown();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the kernel does not restart","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":650,"column":50},"line":650,"code":"    it('should fail if the kernel does not restart', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":656,"column":53},"line":656,"code":"    it('should throw an error for an invalid response', async () => {\n      const { id, name } = defaultKernel;\n      handleRequest(defaultKernel, 205, { id, name });\n      await expect(defaultKernel.restart()).rejects.toThrow(\n        /Invalid response: 205 Reset Content/\n      );\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an error response","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":664,"column":51},"line":664,"code":"    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid id","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":670,"column":47},"line":670,"code":"    it('should throw an error for an invalid id', async () => {\n      handleRequest(defaultKernel, 200, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of existing comm and future objects","suites":["Kernel.IKernel","#restart()"],"updatePoint":{"line":676,"column":58},"line":676,"code":"    it('should dispose of existing comm and future objects', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      await kernel.requestKernelInfo();\n      const comm = kernel.createComm('test');\n      const future = kernel.requestExecute({ code: 'foo' });\n      await kernel.restart();\n      await kernel.requestKernelInfo();\n      expect(future.isDisposed).toBe(true);\n      expect(comm.isDisposed).toBe(true);\n      await kernel.shutdown();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new websocket and resolve the returned promise","suites":["Kernel.IKernel","#reconnect()"],"updatePoint":{"line":691,"column":70},"line":691,"code":"    it('should create a new websocket and resolve the returned promise', async () => {\n      const oldWS = (defaultKernel as any)._ws;\n      await defaultKernel.reconnect();\n      expect((defaultKernel as any)._ws).not.toBe(oldWS);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit `\"connecting\"`, then `\"connected\"` status","suites":["Kernel.IKernel","#reconnect()"],"updatePoint":{"line":697,"column":61},"line":697,"code":"    it('should emit `\"connecting\"`, then `\"connected\"` status', async () => {\n      const emission = testEmission(defaultKernel.connectionStatusChanged, {\n        find: () => defaultKernel.connectionStatus === 'connecting',\n        test: async () => {\n          await testEmission(defaultKernel.connectionStatusChanged, {\n            find: () => defaultKernel.connectionStatus === 'connected'\n          });\n        }\n      });\n      await defaultKernel.reconnect();\n      await expect(emission).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"return promise should reject if the kernel is disposed or disconnected","suites":["Kernel.IKernel","#reconnect()"],"updatePoint":{"line":710,"column":78},"line":710,"code":"    it('return promise should reject if the kernel is disposed or disconnected', async () => {\n      const connection = defaultKernel.reconnect();\n      defaultKernel.dispose();\n      await expect(connection).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down and resolve with a valid server response","suites":["Kernel.IKernel","#shutdown()"],"updatePoint":{"line":718,"column":65},"line":718,"code":"    it('should shut down and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["Kernel.IKernel","#shutdown()"],"updatePoint":{"line":723,"column":53},"line":723,"code":"    it('should throw an error for an invalid response', async () => {\n      handleRequest(defaultKernel, 200, {\n        id: UUID.uuid4(),\n        name: 'foo'\n      });\n      const shutdown = defaultKernel.shutdown();\n      await expect(shutdown).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a 404 error","suites":["Kernel.IKernel","#shutdown()"],"updatePoint":{"line":732,"column":33},"line":732,"code":"    it('should handle a 404 error', async () => {\n      const kernel = await kernelManager.startNew();\n      handleRequest(kernel, 404, {});\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an error response","suites":["Kernel.IKernel","#shutdown()"],"updatePoint":{"line":738,"column":51},"line":738,"code":"    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const shutdown = defaultKernel.shutdown();\n      await expect(shutdown).rejects.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should still pass if the kernel is dead","suites":["Kernel.IKernel","#shutdown()"],"updatePoint":{"line":744,"column":47},"line":744,"code":"    it('should still pass if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve the promise","suites":["Kernel.IKernel","#requestKernelInfo()"],"updatePoint":{"line":760,"column":34},"line":760,"code":"    it('should resolve the promise', async () => {\n      const msg = (await defaultKernel.requestKernelInfo())!;\n      if (msg.content.status !== 'ok') {\n        throw new Error('Message error');\n      }\n      const name = msg.content.language_info.name;\n      expect(name).toBeTruthy();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve the promise","suites":["Kernel.IKernel","#requestComplete()"],"updatePoint":{"line":771,"column":34},"line":771,"code":"    it('should resolve the promise', async () => {\n      const options: KernelMessage.ICompleteRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4\n      };\n      await expect(\n        defaultKernel.requestComplete(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should reject the promise if the kernel is dead","suites":["Kernel.IKernel","#requestComplete()"],"updatePoint":{"line":781,"column":55},"line":781,"code":"    it('should reject the promise if the kernel is dead', async () => {\n      const options: KernelMessage.ICompleteRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4\n      };\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.requestComplete(options)).rejects.toThrow(\n        /Kernel is dead/\n      );\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve the promise","suites":["Kernel.IKernel","#requestInspect()"],"updatePoint":{"line":803,"column":34},"line":803,"code":"    it('should resolve the promise', async () => {\n      const options: KernelMessage.IInspectRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4,\n        detail_level: 0\n      };\n      await expect(\n        defaultKernel.requestInspect(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve the promise","suites":["Kernel.IKernel","#requestIsComplete()"],"updatePoint":{"line":816,"column":34},"line":816,"code":"    it('should resolve the promise', async () => {\n      const options: KernelMessage.IIsCompleteRequestMsg['content'] = {\n        code: 'hello'\n      };\n      await expect(\n        defaultKernel.requestIsComplete(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"range messages should resolve the promise","suites":["Kernel.IKernel","#requestHistory()"],"updatePoint":{"line":827,"column":49},"line":827,"code":"    it('range messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'range',\n        session: 0,\n        start: 1,\n        stop: 2\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"tail messages should resolve the promise","suites":["Kernel.IKernel","#requestHistory()"],"updatePoint":{"line":841,"column":48},"line":841,"code":"    it('tail messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'tail',\n        n: 1\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"search messages should resolve the promise","suites":["Kernel.IKernel","#requestHistory()"],"updatePoint":{"line":853,"column":50},"line":853,"code":"    it('search messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'search',\n        n: 1,\n        pattern: '*',\n        unique: true\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send an input_reply message","suites":["Kernel.IKernel","#sendInputReply()"],"updatePoint":{"line":869,"column":42},"line":869,"code":"    it('should send an input_reply message', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const done = new PromiseDelegate<void>();\n      tester.onMessage(msg => {\n        expect(msg.header.msg_type).toBe('input_reply');\n        done.resolve(undefined);\n      });\n      kernel.sendInputReply({ status: 'ok', value: 'test' });\n      await done.promise;\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the kernel is dead","suites":["Kernel.IKernel","#sendInputReply()"],"updatePoint":{"line":883,"column":41},"line":883,"code":"    it('should fail if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      expect(() => {\n        kernel.sendInputReply({ status: 'ok', value: 'test' });\n      }).toThrowError(/Kernel is dead/);\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send and handle incoming messages","suites":["Kernel.IKernel","#requestExecute()"],"updatePoint":{"line":901,"column":48},"line":901,"code":"    it('should send and handle incoming messages', async () => {\n      const content: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n\n      const options = {\n        username: defaultKernel.username,\n        session: defaultKernel.clientId\n      };\n\n      let future: Kernel.IShellFuture;\n      const tester = new KernelTester();\n\n      tester.onMessage(msg => {\n        expect(msg.channel).toBe('shell');\n\n        // send a reply\n        tester.send(\n          KernelMessage.createMessage<KernelMessage.IExecuteReplyMsg>({\n            ...options,\n            msgType: 'execute_reply',\n            channel: 'shell',\n            content: {\n              execution_count: 1,\n              status: 'ok',\n              user_expressions: {}\n            },\n            parentHeader: msg.header as KernelMessage.IExecuteRequestMsg['header']\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onStdin\n          tester.send(\n            KernelMessage.createMessage({\n              ...options,\n              channel: 'stdin',\n              msgType: 'input_request',\n              content: {\n                prompt: 'prompt',\n                password: false\n              },\n              parentHeader: msg.header\n            })\n          );\n        };\n\n        future.onStdin = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage<KernelMessage.IStreamMsg>({\n              ...options,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: '' },\n              parentHeader: msg.header\n            })\n          );\n        };\n\n        future.onIOPub = ioMsg => {\n          if (ioMsg.header.msg_type === 'stream') {\n            // trigger onDone\n            tester.send(\n              KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n                ...options,\n                channel: 'iopub',\n                msgType: 'status',\n                content: {\n                  execution_state: 'idle'\n                },\n                parentHeader: msg.header\n              })\n            );\n          }\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(content);\n      await future.done;\n      expect(future.isDisposed).toBe(true);\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should not dispose of KernelFuture when disposeOnDone=false","suites":["Kernel.IKernel","#requestExecute()"],"updatePoint":{"line":992,"column":67},"line":992,"code":"    it('should not dispose of KernelFuture when disposeOnDone=false', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const future = defaultKernel.requestExecute(options, false);\n      await future.done;\n      expect(future.isDisposed).toBe(false);\n      future.dispose();\n      expect(future.isDisposed).toBe(true);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept cell metadata as part of request","suites":["Kernel.IKernel","#checkExecuteMetadata()"],"updatePoint":{"line":1010,"column":54},"line":1010,"code":"    it('should accept cell metadata as part of request', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const metadata = { cellId: 'test' };\n      const future = defaultKernel.requestExecute(options, false, metadata);\n      await future.done;\n      expect(future.msg.metadata).toEqual(metadata);\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should have the most recently registered hook run first","suites":["Kernel.IKernel","#registerMessageHook()"],"updatePoint":{"line":1027,"column":63},"line":1027,"code":"    it('should have the most recently registered hook run first', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      let future: Kernel.IShellFuture;\n\n      let kernel: Kernel.IKernelConnection;\n\n      const tester = new KernelTester();\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, async msg => {\n          // Make this hook call asynchronous\n          // tslint:disable-next-line:await-promise\n          await calls.push('last');\n          return true;\n        });\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('first');\n          // not returning should also continue handling\n          return void 0 as any;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual([\n        'first',\n        'last',\n        'iopub',\n        'first',\n        'last',\n        'iopub'\n      ]);\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should abort processing if a hook returns false, but the done logic should still work","suites":["Kernel.IKernel","#registerMessageHook()"],"updatePoint":{"line":1113,"column":93},"line":1113,"code":"    it('should abort processing if a hook returns false, but the done logic should still work', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('last');\n          return true;\n        });\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('first');\n          return false;\n        });\n\n        future.onIOPub = async () => {\n          // tslint:disable-next-line:await-promise\n          await calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual(['first', 'first']);\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should process additions on the next run","suites":["Kernel.IKernel","#registerMessageHook()"],"updatePoint":{"line":1190,"column":48},"line":1190,"code":"    it('should process additions on the next run', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('last');\n          kernel.registerMessageHook(parentHeader.msg_id, msg => {\n            calls.push('first');\n            return true;\n          });\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['last', 'iopub', 'first', 'last', 'iopub']);\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should deactivate a hook immediately on removal","suites":["Kernel.IKernel","#registerMessageHook()"],"updatePoint":{"line":1263,"column":55},"line":1263,"code":"    it('should deactivate a hook immediately on removal', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        const toDelete = (msg: KernelMessage.IIOPubMessage) => {\n          calls.push('delete');\n          return true;\n        };\n        kernel.registerMessageHook(parentHeader.msg_id, toDelete);\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          if (calls.length > 0) {\n            // delete the hook the second time around\n            kernel.removeMessageHook(parentHeader.msg_id, toDelete);\n          }\n          calls.push('first');\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['first', 'delete', 'iopub', 'first', 'iopub']);\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should run handlers in order","suites":["Kernel.IKernel","handles messages asynchronously"],"updatePoint":{"line":1347,"column":36},"line":1347,"code":"    it('should run handlers in order', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: true,\n        stop_on_error: false\n      };\n\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const future = kernel.requestExecute(options, false);\n\n      // The list of emissions from the anyMessage signal.\n      const msgSignal: string[][] = [];\n      const msgSignalExpected: string[][] = [];\n\n      // The list of message processing calls\n      const calls: string[][] = [];\n      const callsExpected: string[][] = [];\n\n      function pushIopub(msgId: string) {\n        callsExpected.push([msgId, 'future hook a']);\n        callsExpected.push([msgId, 'future hook b']);\n        callsExpected.push([msgId, 'kernel hook a']);\n        callsExpected.push([msgId, 'kernel hook b']);\n        callsExpected.push([msgId, 'iopub']);\n        msgSignalExpected.push([msgId, 'iopub']);\n      }\n\n      function pushCommOpen(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm open']);\n      }\n\n      function pushCommMsg(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm msg']);\n      }\n\n      function pushCommClose(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm close']);\n      }\n\n      function pushStdin(msgId: string) {\n        callsExpected.push([msgId, 'stdin']);\n        msgSignalExpected.push([msgId, 'stdin']);\n      }\n\n      function pushReply(msgId: string) {\n        callsExpected.push([msgId, 'reply']);\n        msgSignalExpected.push([msgId, 'shell']);\n      }\n\n      const anyMessageDone = new PromiseDelegate();\n      const handlingBlock = new PromiseDelegate();\n\n      tester.onMessage(message => {\n        tester.onMessage(() => {\n          return;\n        });\n        tester.parentHeader = message.header;\n\n        pushIopub(tester.sendStatus('busy', 'busy'));\n        pushIopub(tester.sendStream('stdout', { name: 'stdout', text: 'foo' }));\n        pushCommOpen(\n          tester.sendCommOpen('comm open', {\n            target_name: 'commtarget',\n            comm_id: 'commid',\n            data: {}\n          })\n        );\n        pushIopub(\n          tester.sendDisplayData('display 1', { data: {}, metadata: {} })\n        );\n        pushCommMsg(\n          tester.sendCommMsg('comm 1', { comm_id: 'commid', data: {} })\n        );\n        pushCommMsg(\n          tester.sendCommMsg('comm 2', { comm_id: 'commid', data: {} })\n        );\n        pushCommClose(\n          tester.sendCommClose('comm close', { comm_id: 'commid', data: {} })\n        );\n        pushStdin(\n          tester.sendInputRequest('stdin', { prompt: '', password: false })\n        );\n        pushIopub(\n          tester.sendDisplayData('display 2', {\n            data: {},\n            metadata: {},\n            transient: { display_id: 'displayid' }\n          })\n        );\n        pushIopub(\n          tester.sendUpdateDisplayData('update display', {\n            data: {},\n            metadata: {},\n            transient: { display_id: 'displayid' }\n          })\n        );\n        pushIopub(\n          tester.sendExecuteResult('execute result', {\n            execution_count: 1,\n            data: {},\n            metadata: {}\n          })\n        );\n        pushIopub(tester.sendStatus('idle', 'idle'));\n        pushReply(\n          tester.sendExecuteReply('execute reply', {\n            status: 'ok',\n            execution_count: 1,\n            user_expressions: {}\n          })\n        );\n\n        tester.parentHeader = undefined;\n      });\n\n      kernel.anyMessage.connect((k, args) => {\n        msgSignal.push([args.msg.header.msg_id, args.msg.channel]);\n        if (args.msg.header.msg_id === 'execute reply') {\n          anyMessageDone.resolve(undefined);\n        }\n      });\n\n      kernel.registerMessageHook(future.msg.header.msg_id, async msg => {\n        // Make this hook call asynchronous\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'kernel hook b']);\n        return true;\n      });\n\n      kernel.registerMessageHook(future.msg.header.msg_id, async msg => {\n        calls.push([msg.header.msg_id, 'kernel hook a']);\n        return true;\n      });\n\n      kernel.registerCommTarget('commtarget', async (comm, msg) => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'comm open']);\n\n        comm.onMsg = async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push([msg.header.msg_id, 'comm msg']);\n        };\n        comm.onClose = async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push([msg.header.msg_id, 'comm close']);\n        };\n      });\n\n      future.registerMessageHook(async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'future hook b']);\n        return true;\n      });\n\n      future.registerMessageHook(async msg => {\n        // Delay processing until after we've checked the anyMessage results.\n        await handlingBlock.promise;\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'future hook a']);\n        return true;\n      });\n\n      future.onIOPub = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'iopub']);\n      };\n\n      future.onStdin = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'stdin']);\n      };\n\n      future.onReply = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'reply']);\n      };\n\n      // Give the kernel time to receive and queue up the messages.\n      await anyMessageDone.promise;\n\n      // At this point, the synchronous anyMessage signal should have been\n      // emitted for every message, but no actual message handling should have\n      // happened.\n      expect(msgSignal).toEqual(msgSignalExpected);\n      expect(calls).toEqual([]);\n\n      // Release the lock on message processing.\n      handlingBlock.resolve(undefined);\n      await future.done;\n      expect(calls).toEqual(callsExpected);\n\n      await tester.shutdown();\n      tester.dispose();\n    });","file":"kernel/ikernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should yield a list of valid kernel ids","suites":["kernel","Kernel.listRunning()"],"updatePoint":{"line":45,"column":47},"line":45,"code":"    it('should yield a list of valid kernel ids', async () => {\n      const kernel = await KernelAPI.startNew();\n      expect(toArray(await KernelAPI.listRunning()).length).toBeGreaterThan(0);\n      await KernelAPI.shutdownKernel(kernel.id);\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept server settings","suites":["kernel","Kernel.listRunning()"],"updatePoint":{"line":51,"column":37},"line":51,"code":"    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const k = await KernelAPI.startNew({}, serverSettings);\n      const response = await KernelAPI.listRunning(serverSettings);\n      expect(toArray(response).length).toBeGreaterThan(0);\n      await KernelAPI.shutdownKernel(k.id);\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid model","suites":["kernel","Kernel.listRunning()"],"updatePoint":{"line":59,"column":50},"line":59,"code":"    it('should throw an error for an invalid model', async () => {\n      const data = { id: UUID.uuid4(), name: 'test' };\n      const settings = getRequestHandler(200, data);\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow(/Invalid kernel list/);\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["kernel","Kernel.listRunning()"],"updatePoint":{"line":66,"column":53},"line":66,"code":"    it('should throw an error for an invalid response', async () => {\n      const settings = getRequestHandler(201, {});\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an error response","suites":["kernel","Kernel.listRunning()"],"updatePoint":{"line":72,"column":51},"line":72,"code":"    it('should throw an error for an error response', async () => {\n      const settings = getRequestHandler(500, {});\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept ajax options","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":80,"column":34},"line":80,"code":"    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      const k = await KernelAPI.startNew({}, serverSettings);\n      await expect(KernelAPI.shutdownKernel(k.id)).resolves.not.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should still construct connection if the kernel dies","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":86,"column":60},"line":86,"code":"    it('should still construct connection if the kernel dies', async () => {\n      // If a kernel dies immediately, the kernel connection should still send\n      // out the status signal, then dispose the connection.\n      tester = new KernelTester();\n      tester.initialStatus = 'dead';\n      const kernel = await tester.start();\n      const dead = testEmission(kernel.statusChanged, {\n        test: (sender, state) => state === 'dead'\n      });\n      await dead;\n      expect(kernel.isDisposed).toBe(true);\n      expect(kernel.status).toBe('dead');\n      tester.dispose();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid kernel id","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":101,"column":54},"line":101,"code":"    it('should throw an error for an invalid kernel id', async () => {\n      const serverSettings = getRequestHandler(201, { id: UUID.uuid4() });\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for another invalid kernel id","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":107,"column":59},"line":107,"code":"    it('should throw an error for another invalid kernel id', async () => {\n      const serverSettings = getRequestHandler(201, {\n        id: UUID.uuid4(),\n        name: 1\n      });\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":116,"column":53},"line":116,"code":"    it('should throw an error for an invalid response', async () => {\n      const data = { id: UUID.uuid4(), name: 'foo' };\n      const serverSettings = getRequestHandler(200, data);\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow(/Invalid response: 200 OK/);\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an error response","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":123,"column":51},"line":123,"code":"    it('should throw an error for an error response', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should auto-reconnect on websocket error","suites":["kernel","KernelAPI.startNew()"],"updatePoint":{"line":129,"column":48},"line":129,"code":"    it('should auto-reconnect on websocket error', async () => {\n      tester = new KernelTester();\n      const kernel = await tester.start();\n      await kernel.info;\n\n      const emission = testEmission(kernel.connectionStatusChanged, {\n        find: (k, status) => status === 'connecting'\n      });\n      await tester.close();\n      await expect(emission).resolves.not.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down a kernel by id","suites":["kernel","Kernel.shutdown()"],"updatePoint":{"line":143,"column":39},"line":143,"code":"    it('should shut down a kernel by id', async () => {\n      const kernel = await KernelAPI.startNew();\n      await KernelAPI.shutdownKernel(kernel.id);\n      const kernels = await KernelAPI.listRunning();\n      expect(kernels.find(k => k.id === kernel.id)).toBeUndefined();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a 404 error","suites":["kernel","Kernel.shutdown()"],"updatePoint":{"line":150,"column":33},"line":150,"code":"    it('should handle a 404 error', async () => {\n      await expect(\n        KernelAPI.shutdownKernel(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });","file":"kernel/kernel.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should take the options as an argument","suites":["kernel/manager","KernelManager","#constructor()"],"updatePoint":{"line":50,"column":48},"line":50,"code":"      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new KernelManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        expect(manager instanceof KernelManager).toBe(true);\n        await manager.ready;\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["kernel/manager","KernelManager","#serverSettings"],"updatePoint":{"line":62,"column":40},"line":62,"code":"      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelManager({ serverSettings, standby });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the running sessions","suites":["kernel/manager","KernelManager","#running()"],"updatePoint":{"line":74,"column":41},"line":74,"code":"      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toBeGreaterThan(0);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted in refreshRunning when the running kernels changed","suites":["kernel/manager","KernelManager","#runningChanged"],"updatePoint":{"line":80,"column":78},"line":80,"code":"      it('should be emitted in refreshRunning when the running kernels changed', async () => {\n        let called = false;\n        manager.runningChanged.connect((sender, args) => {\n          expect(sender).toBe(manager);\n          expect(toArray(args).length).toBeGreaterThan(0);\n          called = true;\n        });\n        await KernelAPI.startNew();\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a kernel is shut down","suites":["kernel/manager","KernelManager","#runningChanged"],"updatePoint":{"line":92,"column":54},"line":92,"code":"      it('should be emitted when a kernel is shut down', async () => {\n        const kernel = await manager.startNew();\n        await kernel.info;\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.shutdown(kernel.id);\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is ready","suites":["kernel/manager","KernelManager","#isReady"],"updatePoint":{"line":106,"column":50},"line":106,"code":"      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new KernelManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve when the manager is ready","suites":["kernel/manager","KernelManager","#ready"],"updatePoint":{"line":116,"column":50},"line":116,"code":"      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running kernels","suites":["kernel/manager","KernelManager","#refreshRunning()"],"updatePoint":{"line":122,"column":43},"line":122,"code":"      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toBeGreaterThan(0);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running kernels when one is shut down","suites":["kernel/manager","KernelManager","#refreshRunning()"],"updatePoint":{"line":127,"column":65},"line":127,"code":"      it('should update the running kernels when one is shut down', async () => {\n        const old = toArray(manager.running()).length;\n        await KernelAPI.startNew();\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toBeGreaterThan(old);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should start a new kernel","suites":["kernel/manager","KernelManager","#startNew()"],"updatePoint":{"line":136,"column":35},"line":136,"code":"      it('should start a new kernel', async () => {\n        await expect(manager.startNew()).resolves.not.toThrow();\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["kernel/manager","KernelManager","#startNew()"],"updatePoint":{"line":140,"column":45},"line":140,"code":"      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        const kernel = await manager.startNew();\n        await kernel.info;\n        expect(called).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should find an existing kernel by id","suites":["kernel/manager","KernelManager","#findById()"],"updatePoint":{"line":152,"column":46},"line":152,"code":"      it('should find an existing kernel by id', async () => {\n        const id = kernel.id;\n        const model = await manager.findById(id);\n        expect(model!.id).toBe(id);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should connect to an existing kernel","suites":["kernel/manager","KernelManager","#connectTo()"],"updatePoint":{"line":160,"column":46},"line":160,"code":"      it('should connect to an existing kernel', () => {\n        const id = kernel.id;\n        const newConnection = manager.connectTo({ model: kernel });\n        expect(newConnection.model.id).toBe(id);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down a kernel by id","suites":["kernel/manager","KernelManager","shutdown()"],"updatePoint":{"line":168,"column":41},"line":168,"code":"      it('should shut down a kernel by id', async () => {\n        const kernel = await manager.startNew();\n        await kernel.info;\n        await manager.shutdown(kernel.id);\n        expect(kernel.isDisposed).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["kernel/manager","KernelManager","shutdown()"],"updatePoint":{"line":175,"column":45},"line":175,"code":"      it('should emit a runningChanged signal', async () => {\n        const kernel = await manager.startNew();\n        const emission = testEmission(manager.runningChanged, {\n          test: () => {\n            expect(kernel.isDisposed).toBe(false);\n          }\n        });\n        await kernel.info;\n        await manager.shutdown(kernel.id);\n        await emission;\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of all relevant kernel connections","suites":["kernel/manager","KernelManager","shutdown()"],"updatePoint":{"line":187,"column":59},"line":187,"code":"      it('should dispose of all relevant kernel connections', async () => {\n        const kernel0 = await manager.startNew();\n        const kernel1 = manager.connectTo({ model: kernel0.model });\n        await kernel0.info;\n        await kernel1.info;\n        await manager.refreshRunning();\n        await kernel0.shutdown();\n        expect(kernel0.status).toBe('dead');\n        expect(kernel0.isDisposed).toBe(true);\n\n        // Wait for the round trip to the server to update the connections.\n        await sleep(100);\n        expect(kernel1.status).toBe('dead');\n        expect(kernel1.isDisposed).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should take the options as an argument","suites":["kernel/manager","NoopManager","#constructor()"],"updatePoint":{"line":218,"column":48},"line":218,"code":"      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new KernelManager.NoopManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof KernelManager.NoopManager).toBe(true);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["kernel/manager","NoopManager","#serverSettings"],"updatePoint":{"line":230,"column":40},"line":230,"code":"      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelManager.NoopManager({ serverSettings, standby });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the running sessions","suites":["kernel/manager","NoopManager","#running()"],"updatePoint":{"line":242,"column":41},"line":242,"code":"      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running kernels","suites":["kernel/manager","NoopManager","#refreshRunning()"],"updatePoint":{"line":249,"column":43},"line":249,"code":"      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["kernel/manager","NoopManager","#startNew()"],"updatePoint":{"line":256,"column":31},"line":256,"code":"      it('should throw an error', () => {\n        return expect(manager.startNew()).rejects.toThrow();\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["kernel/manager","NoopManager","#connectTo()"],"updatePoint":{"line":262,"column":31},"line":262,"code":"      it('should throw an error', () => {\n        return expect(() => {\n          manager.connectTo({ model: kernel });\n        }).toThrow();\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["kernel/manager","NoopManager","shutdown()"],"updatePoint":{"line":270,"column":31},"line":270,"code":"      it('should throw an error', () => {\n        return expect(manager.shutdown(kernel.id)).rejects.toThrow();\n      });","file":"kernel/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a stream message type","suites":["kernel/messages","KernelMessage.isStreamMsg()"],"updatePoint":{"line":17,"column":46},"line":17,"code":"    it('should check for a stream message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IStreamMsg>({\n        msgType: 'stream',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          name: 'stdout',\n          text: 'hello world'\n        }\n      });\n      expect(KernelMessage.isStreamMsg(msg)).toBe(true);\n      expect(KernelMessage.isStreamMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a display data message type","suites":["kernel/messages","KernelMessage.isDisplayDataMsg()"],"updatePoint":{"line":33,"column":52},"line":33,"code":"    it('should check for a display data message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IDisplayDataMsg>({\n        msgType: 'display_data',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          data: {},\n          metadata: {}\n        }\n      });\n      expect(KernelMessage.isDisplayDataMsg(msg)).toBe(true);\n      expect(KernelMessage.isDisplayDataMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a execute input message type","suites":["kernel/messages","KernelMessage.isExecuteInputMsg()"],"updatePoint":{"line":49,"column":53},"line":49,"code":"    it('should check for a execute input message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IExecuteInputMsg>({\n        msgType: 'execute_input',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          code: '',\n          execution_count: 1\n        }\n      });\n      expect(KernelMessage.isExecuteInputMsg(msg)).toBe(true);\n      expect(KernelMessage.isExecuteInputMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for an execute result message type","suites":["kernel/messages","KernelMessage.isExecuteResultMsg()"],"updatePoint":{"line":65,"column":55},"line":65,"code":"    it('should check for an execute result message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'execute_result',\n        channel: 'iopub',\n        session: 'baz',\n        content: { data: {}, execution_count: 1, metadata: {} }\n      });\n      expect(KernelMessage.isExecuteResultMsg(msg)).toBe(true);\n      expect(KernelMessage.isExecuteResultMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a status message type","suites":["kernel/messages","KernelMessage.isStatusMsg()"],"updatePoint":{"line":78,"column":46},"line":78,"code":"    it('should check for a status message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'status',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          execution_state: 'idle'\n        }\n      });\n      expect(KernelMessage.isStatusMsg(msg)).toBe(true);\n      const msg2 = KernelMessage.createMessage<KernelMessage.IExecuteInputMsg>({\n        msgType: 'execute_input',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          code: '',\n          execution_count: 1\n        }\n      });\n      expect(KernelMessage.isStatusMsg(msg2)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a clear output message type","suites":["kernel/messages","KernelMessage.isClearOutputMsg()"],"updatePoint":{"line":102,"column":52},"line":102,"code":"    it('should check for a clear output message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'clear_output',\n        channel: 'iopub',\n        session: 'baz',\n        content: { wait: true }\n      });\n      expect(KernelMessage.isClearOutputMsg(msg)).toBe(true);\n      expect(KernelMessage.isClearOutputMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for a comm open message type","suites":["kernel/messages","KernelMessage.isCommOpenMsg()"],"updatePoint":{"line":115,"column":49},"line":115,"code":"    it('should check for a comm open message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_open',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          comm_id: 'id',\n          data: {},\n          target_name: 'target'\n        }\n      });\n      expect(KernelMessage.isCommOpenMsg(msg)).toBe(true);\n      expect(KernelMessage.isCommOpenMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for an message type","suites":["kernel/messages","KernelMessage.isErrorMsg()"],"updatePoint":{"line":132,"column":40},"line":132,"code":"    it('should check for an message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'error',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          ename: '',\n          evalue: '',\n          traceback: []\n        }\n      });\n      expect(KernelMessage.isErrorMsg(msg)).toBe(true);\n      expect(KernelMessage.isErrorMsg(iopubStatusMsg)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should check for an input_request message type","suites":["kernel/messages","KernelMessage.isInputRequestMsg()"],"updatePoint":{"line":149,"column":54},"line":149,"code":"    it('should check for an input_request message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'input_request',\n        channel: 'stdin',\n        session: 'baz',\n        content: { prompt: '', password: false }\n      });\n      expect(KernelMessage.isInputRequestMsg(msg)).toBe(true);\n      const msg2 = KernelMessage.createMessage<KernelMessage.IInputReplyMsg>({\n        msgType: 'input_reply',\n        channel: 'stdin',\n        session: 'baz',\n        content: {\n          status: 'ok',\n          value: ''\n        }\n      });\n      expect(KernelMessage.isInputRequestMsg(msg2)).toBe(false);\n    });","file":"kernel/messages.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass a valid message","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":9,"column":35},"line":9,"code":"    it('should pass a valid message', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'foo',\n        content: { comm_id: 'foo', data: {} }\n      });\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw if missing a field","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":21,"column":39},"line":21,"code":"    it('should throw if missing a field', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      delete (msg as any).channel;\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw if a field is invalid","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":32,"column":42},"line":32,"code":"    it('should throw if a field is invalid', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      (msg as any).header.username = 1;\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw if the parent header is given an invalid","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":43,"column":61},"line":43,"code":"    it('should throw if the parent header is given an invalid', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      msg.parent_header = msg.header;\n      (msg as any).parent_header.username = 1;\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw if the channel is not a string","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":55,"column":51},"line":55,"code":"    it('should throw if the channel is not a string', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      (msg as any).channel = 1;\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should validate an iopub message","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":66,"column":40},"line":66,"code":"    it('should validate an iopub message', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_close',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should ignore on an unknown iopub message type","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":78,"column":54},"line":78,"code":"    it('should ignore on an unknown iopub message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'foo',\n        channel: 'iopub',\n        session: 'baz',\n        content: {}\n      } as any);\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw on missing iopub message content","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":90,"column":53},"line":90,"code":"    it('should throw on missing iopub message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IErrorMsg>({\n        msgType: 'error',\n        channel: 'iopub',\n        session: 'baz',\n        content: {} as any\n      } as any);\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw on invalid iopub message content","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":100,"column":53},"line":100,"code":"    it('should throw on invalid iopub message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IClearOutputMsg>({\n        msgType: 'clear_output',\n        channel: 'iopub',\n        session: 'baz',\n        content: { wait: 1 as any }\n      });\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw on invalid iopub status message content","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":110,"column":60},"line":110,"code":"    it('should throw on invalid iopub status message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n        msgType: 'status',\n        channel: 'iopub',\n        session: 'baz',\n        content: { execution_state: 'invalid-status' as Kernel.Status }\n      });\n      expect(() => validateMessage(msg)).toThrowError();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle no buffers field","suites":["kernel/validate","validateMessage"],"updatePoint":{"line":120,"column":38},"line":120,"code":"    it('should handle no buffers field', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'foo',\n        content: { comm_id: 'foo', data: {} }\n      });\n      delete msg['buffers'];\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass a valid id","suites":["kernel/validate","#validateModel()"],"updatePoint":{"line":135,"column":30},"line":135,"code":"    it('should pass a valid id', () => {\n      const id: Kernel.IModel = { name: 'foo', id: 'baz' };\n      expect(() => {\n        validateModel(id);\n      }).not.toThrow();\n    });","file":"kernel/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should load the kernelspecs","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":24,"column":35},"line":24,"code":"    it('should load the kernelspecs', async () => {\n      const specs = await KernelSpecAPI.getSpecs();\n      expect(specs.default).toBeTruthy();\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept ajax options","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":29,"column":34},"line":29,"code":"    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBeTruthy();\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a missing default parameter","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":35,"column":49},"line":35,"code":"    it('should handle a missing default parameter', async () => {\n      const serverSettings = getRequestHandler(200, {\n        kernelspecs: { python: PYTHON_SPEC }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBeTruthy();\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw for a missing kernelspecs parameter","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":43,"column":56},"line":43,"code":"    it('should throw for a missing kernelspecs parameter', async () => {\n      const serverSettings = getRequestHandler(200, {\n        default: PYTHON_SPEC.name\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should omit an invalid kernelspec","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":51,"column":41},"line":51,"code":"    it('should omit an invalid kernelspec', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.name = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: {\n          R: R_SPEC,\n          python: PYTHON_SPEC\n        }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBe('python');\n      expect(specs.kernelspecs['R']).toBeUndefined();\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle an improper name","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":66,"column":38},"line":66,"code":"    it('should handle an improper name', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.name = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle an improper language","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":77,"column":42},"line":77,"code":"    it('should handle an improper language', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.language = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle an improper argv","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":88,"column":38},"line":88,"code":"    it('should handle an improper argv', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.argv = 'hello';\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle an improper display_name","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":99,"column":46},"line":99,"code":"    it('should handle an improper display_name', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.display_name = ['hello'];\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle missing resources","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":110,"column":39},"line":110,"code":"    it('should handle missing resources', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      delete R_SPEC.resources;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid response","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":121,"column":53},"line":121,"code":"    it('should throw an error for an invalid response', async () => {\n      const serverSettings = getRequestHandler(201, {});\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/Invalid response: 201 Created/);\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle metadata","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":127,"column":30},"line":127,"code":"    it('should handle metadata', async () => {\n      const PYTHON_SPEC_W_MD = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      // eslint-disable-next-line camelcase\n      PYTHON_SPEC_W_MD.spec.metadata = { some_application: { key: 'value' } };\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: { python: PYTHON_SPEC_W_MD }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n\n      expect(specs.kernelspecs['python']).toHaveProperty('metadata');\n      const metadata = specs.kernelspecs['python']!.metadata;\n      expect(metadata).toHaveProperty('some_application');\n      expect((metadata as any).some_application).toHaveProperty('key', 'value');\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle env values","suites":["kernel","KernelSpec.getSpecs()"],"updatePoint":{"line":143,"column":32},"line":143,"code":"    it('should handle env values', async () => {\n      const PYTHON_SPEC_W_ENV = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      PYTHON_SPEC_W_ENV.spec.env = {\n        SOME_ENV: 'some_value',\n        LANG: 'en_US.UTF-8'\n      };\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: { python: PYTHON_SPEC_W_ENV }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n\n      expect(specs.kernelspecs['python']).toHaveProperty('env');\n      const env = specs.kernelspecs['python']!.env;\n      expect(env).toHaveProperty('SOME_ENV', 'some_value');\n      expect(env).toHaveProperty('LANG', 'en_US.UTF-8');\n    });","file":"kernelspec/kernelspec.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should take the options as an argument","suites":["kernel/manager","KernelSpecManager","#constructor()"],"updatePoint":{"line":52,"column":48},"line":52,"code":"      it('should take the options as an argument', () => {\n        manager.dispose();\n        manager = new KernelSpecManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        expect(manager instanceof KernelSpecManager).toBe(true);\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["kernel/manager","KernelSpecManager","#serverSettings"],"updatePoint":{"line":63,"column":40},"line":63,"code":"      it('should get the server settings', () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelSpecManager({ serverSettings, standby });\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the kernel specs","suites":["kernel/manager","KernelSpecManager","#specs"],"updatePoint":{"line":74,"column":37},"line":74,"code":"      it('should get the kernel specs', async () => {\n        await manager.ready;\n        expect(manager.specs!.default).toBeTruthy();\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the specs change","suites":["kernel/manager","KernelSpecManager","#specsChanged"],"updatePoint":{"line":81,"column":49},"line":81,"code":"      it('should be emitted when the specs change', async () => {\n        const manager = new TestManager({ standby: 'never' });\n        const specs = JSONExt.deepCopy(KERNELSPECS) as KernelSpec.ISpecModels;\n        let called = false;\n        manager.specsChanged.connect(() => {\n          called = true;\n        });\n        await manager.ready;\n        expect(manager.specs!.default).toBe('echo');\n        specs.default = 'shell';\n        manager.intercept = specs;\n        await manager.refreshSpecs();\n        expect(manager.specs!.default).toBe('shell');\n        expect(called).toBe(true);\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is ready","suites":["kernel/manager","KernelSpecManager","#isReady"],"updatePoint":{"line":99,"column":50},"line":99,"code":"      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new KernelSpecManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve when the manager is ready","suites":["kernel/manager","KernelSpecManager","#ready"],"updatePoint":{"line":109,"column":50},"line":109,"code":"      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update list of kernel specs","suites":["kernel/manager","KernelSpecManager","#refreshSpecs()"],"updatePoint":{"line":115,"column":44},"line":115,"code":"      it('should update list of kernel specs', async () => {\n        const manager = new TestManager({ standby: 'never' });\n        const specs = JSONExt.deepCopy(KERNELSPECS) as KernelSpec.ISpecModels;\n        await manager.ready;\n        specs.default = 'shell';\n        manager.intercept = specs;\n        expect(manager.specs!.default).not.toBe('shell');\n        await manager.refreshSpecs();\n        expect(manager.specs!.default).toBe('shell');\n      });","file":"kernelspec/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass with valid data","suites":["kernelspec/validate","#validateSpecModel"],"updatePoint":{"line":13,"column":35},"line":13,"code":"    it('should pass with valid data', () => {\n      expect(() => {\n        validateSpecModel(PYTHON_SPEC);\n      }).not.toThrow();\n    });","file":"kernelspec/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on missing data","suites":["kernelspec/validate","#validateSpecModel"],"updatePoint":{"line":19,"column":35},"line":19,"code":"    it('should fail on missing data', () => {\n      const spec = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      delete spec['name'];\n      expect(() => validateSpecModel(spec)).toThrowError();\n    });","file":"kernelspec/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on incorrect data","suites":["kernelspec/validate","#validateSpecModel"],"updatePoint":{"line":25,"column":37},"line":25,"code":"    it('should fail on incorrect data', () => {\n      const spec = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      spec.spec.language = 1;\n      expect(() => validateSpecModel(spec)).toThrowError();\n    });","file":"kernelspec/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass with valid data","suites":["kernelspec/validate","#validateSpecModels"],"updatePoint":{"line":33,"column":35},"line":33,"code":"    it('should pass with valid data', () => {\n      const model: JSONObject = {\n        default: 'python',\n        kernelspecs: {\n          python: PYTHON_SPEC\n        }\n      };\n      expect(() => {\n        validateSpecModels(model);\n      }).not.toThrow();\n    });","file":"kernelspec/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on missing data","suites":["kernelspec/validate","#validateSpecModels"],"updatePoint":{"line":45,"column":35},"line":45,"code":"    it('should fail on missing data', () => {\n      const model: any = {\n        default: 'python'\n      };\n      expect(() => validateSpecModels(model)).toThrowError();\n    });","file":"kernelspec/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new service manager","suites":["manager","ServiceManager","#constructor()"],"updatePoint":{"line":38,"column":45},"line":38,"code":"      it('should create a new service manager', () => {\n        expect(manager).toBeInstanceOf(ServiceManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the sessions manager instance","suites":["manager","ServiceManager","#sessions"],"updatePoint":{"line":44,"column":49},"line":44,"code":"      it('should be the sessions manager instance', () => {\n        expect(manager.sessions).toBeInstanceOf(SessionManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the setting manager instance","suites":["manager","ServiceManager","#settings"],"updatePoint":{"line":50,"column":48},"line":50,"code":"      it('should be the setting manager instance', () => {\n        expect(manager.settings).toBeInstanceOf(SettingManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the content manager instance","suites":["manager","ServiceManager","#contents"],"updatePoint":{"line":56,"column":48},"line":56,"code":"      it('should be the content manager instance', () => {\n        expect(manager.contents).toBeInstanceOf(ContentsManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the terminal manager instance","suites":["manager","ServiceManager","#terminals"],"updatePoint":{"line":62,"column":49},"line":62,"code":"      it('should be the terminal manager instance', () => {\n        expect(manager.terminals).toBeInstanceOf(TerminalManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the workspace manager instance","suites":["manager","ServiceManager","#workspaces"],"updatePoint":{"line":68,"column":50},"line":68,"code":"      it('should be the workspace manager instance', () => {\n        expect(manager.workspaces).toBeInstanceOf(WorkspaceManager);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is ready","suites":["manager","ServiceManager","#isReady"],"updatePoint":{"line":74,"column":50},"line":74,"code":"      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new ServiceManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });","file":"manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should make a request to the server","suites":["ServerConnection",".makeRequest()"],"updatePoint":{"line":21,"column":43},"line":21,"code":"    it('should make a request to the server', async () => {\n      const settings = getRequestHandler(200, 'hello');\n      const response = await ServerConnection.makeRequest(\n        settings.baseUrl,\n        {},\n        settings\n      );\n      expect(response.statusText).toBe('OK');\n      const data = await response.json();\n      expect(data).toBe('hello');\n    });","file":"serverconnection.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should use default settings","suites":["ServerConnection",".makeSettings()"],"updatePoint":{"line":35,"column":35},"line":35,"code":"    it('should use default settings', () => {\n      const settings = ServerConnection.makeSettings();\n      expect(settings.baseUrl).toBe(PageConfig.getBaseUrl());\n      expect(settings.wsUrl).toBe(PageConfig.getWsUrl());\n      expect(settings.token).toBe(PageConfig.getOption('token'));\n    });","file":"serverconnection.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should use baseUrl for wsUrl","suites":["ServerConnection",".makeSettings()"],"updatePoint":{"line":42,"column":36},"line":42,"code":"    it('should use baseUrl for wsUrl', () => {\n      const conf: Partial<ServerConnection.ISettings> = {\n        baseUrl: 'https://host/path'\n      };\n      const settings = ServerConnection.makeSettings(conf);\n      expect(settings.baseUrl).toBe(conf.baseUrl);\n      expect(settings.wsUrl).toBe('wss://host/path');\n    });","file":"serverconnection.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle overrides","suites":["ServerConnection",".makeSettings()"],"updatePoint":{"line":51,"column":31},"line":51,"code":"    it('should handle overrides', () => {\n      const defaults: Partial<ServerConnection.ISettings> = {\n        baseUrl: 'http://localhost/foo',\n        wsUrl: 'http://localhost/bar',\n        init: {\n          credentials: 'same-origin'\n        },\n        token: 'baz'\n      };\n      const settings = ServerConnection.makeSettings(defaults);\n      expect(settings.baseUrl).toBe(defaults.baseUrl);\n      expect(settings.wsUrl).toBe(defaults.wsUrl);\n      expect(settings.token).toBe(defaults.token);\n      expect(settings.init.credentials).toBe(defaults.init!.credentials);\n    });","file":"serverconnection.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a server error from a server response","suites":["ServerConnection",".makeError()"],"updatePoint":{"line":69,"column":59},"line":69,"code":"    it('should create a server error from a server response', async () => {\n      const settings = getRequestHandler(200, 'hi');\n      const init = { body: 'hi', method: 'POST' };\n      const response = await ServerConnection.makeRequest(\n        settings.baseUrl,\n        init,\n        settings\n      );\n      const err = new ServerConnection.ResponseError(response);\n      expect(err.message).toBe('Invalid response: 200 OK');\n    });","file":"serverconnection.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit when the session is disposed","suites":["session","Session.DefaultSession","#disposed"],"updatePoint":{"line":71,"column":50},"line":71,"code":"      it('should emit when the session is disposed', async () => {\n        let called = false;\n        session = await startNew();\n        session.disposed.connect(() => {\n          called = true;\n        });\n        await session.shutdown();\n        session.dispose();\n        expect(called).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit when the kernel changes","suites":["session","Session.DefaultSession","#kernelChanged"],"updatePoint":{"line":84,"column":45},"line":84,"code":"      it('should emit when the kernel changes', async () => {\n        let called: Session.ISessionConnection.IKernelChangedArgs | null = null;\n        const object = {};\n        await defaultSession.kernel?.requestKernelInfo();\n        defaultSession.kernelChanged.connect((s, args) => {\n          called = args;\n          Signal.disconnectReceiver(object);\n        }, object);\n        const original = defaultSession.kernel!;\n        // Create a new kernel with the same kernel name (same type)\n        await defaultSession.changeKernel({ name: original.name });\n        expect(original).not.toBe(defaultSession.kernel);\n        expect(called).toEqual({\n          name: 'kernel',\n          oldValue: original,\n          newValue: defaultSession.kernel\n        });\n        original.dispose();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit when the kernel status changes","suites":["session","Session.DefaultSession","#statusChanged"],"updatePoint":{"line":106,"column":52},"line":106,"code":"      it('should emit when the kernel status changes', async () => {\n        let called = false;\n        defaultSession.statusChanged.connect((s, status) => {\n          if (status === 'busy') {\n            called = true;\n          }\n        });\n        await defaultSession.kernel!.requestKernelInfo();\n        expect(called).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an iopub message","suites":["session","Session.DefaultSession","#iopubMessage"],"updatePoint":{"line":119,"column":48},"line":119,"code":"      it('should be emitted for an iopub message', async () => {\n        let called = false;\n        defaultSession.iopubMessage.connect((s, msg) => {\n          if (msg.header.msg_type === 'status') {\n            called = true;\n          }\n        });\n        await defaultSession.kernel!.requestExecute({ code: 'a=1' }, true).done;\n        expect(called).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted for an unhandled message","suites":["session","Session.DefaultSession","#unhandledMessage"],"updatePoint":{"line":142,"column":52},"line":142,"code":"      it('should be emitted for an unhandled message', async () => {\n        const session = await tester.startSession();\n        const msgId = UUID.uuid4();\n        const emission = testEmission(session.unhandledMessage, {\n          find: (k, msg) => msg.header.msg_id === msgId\n        });\n        const msg = KernelMessage.createMessage({\n          msgType: 'kernel_info_request',\n          channel: 'shell',\n          session: tester.serverSessionId,\n          msgId,\n          content: {}\n        });\n        msg.parent_header = { session: session.kernel!.clientId } as any;\n        tester.send(msg);\n        await emission;\n        await expect(tester.shutdown()).resolves.not.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the session path changes","suites":["session","Session.DefaultSession","#propertyChanged"],"updatePoint":{"line":163,"column":57},"line":163,"code":"      it('should be emitted when the session path changes', async () => {\n        const newPath = UUID.uuid4();\n        let called = false;\n        const object = {};\n        defaultSession.propertyChanged.connect((s, type) => {\n          expect(defaultSession.path).toBe(newPath);\n          expect(type).toBe('path');\n          called = true;\n          Signal.disconnectReceiver(object);\n        }, object);\n        await defaultSession.setPath(newPath);\n        expect(called).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["session","Session.DefaultSession","#id"],"updatePoint":{"line":179,"column":28},"line":179,"code":"      it('should be a string', () => {\n        expect(typeof defaultSession.id).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["session","Session.DefaultSession","#path"],"updatePoint":{"line":185,"column":28},"line":185,"code":"      it('should be a string', () => {\n        expect(typeof defaultSession.path).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["session","Session.DefaultSession","#name"],"updatePoint":{"line":191,"column":28},"line":191,"code":"      it('should be a string', () => {\n        expect(typeof defaultSession.name).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be a string","suites":["session","Session.DefaultSession","#type"],"updatePoint":{"line":197,"column":28},"line":197,"code":"      it('should be a string', () => {\n        expect(typeof defaultSession.name).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be an IModel","suites":["session","Session.DefaultSession","#model"],"updatePoint":{"line":203,"column":29},"line":203,"code":"      it('should be an IModel', () => {\n        const model = defaultSession.model;\n        expect(typeof model.id).toBe('string');\n        expect(typeof model.path).toBe('string');\n        expect(typeof model.kernel!.name).toBe('string');\n        expect(typeof model.kernel!.id).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be an IKernel object","suites":["session","Session.DefaultSession","#kernel"],"updatePoint":{"line":213,"column":37},"line":213,"code":"      it('should be an IKernel object', () => {\n        expect(typeof defaultSession.kernel!.id).toBe('string');\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the serverSettings","suites":["session","Session.DefaultSession","#serverSettings"],"updatePoint":{"line":219,"column":38},"line":219,"code":"      it('should be the serverSettings', () => {\n        expect(defaultSession.serverSettings.baseUrl).toBe(\n          PageConfig.getBaseUrl()\n        );\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be true after we dispose of the session","suites":["session","Session.DefaultSession","#isDisposed"],"updatePoint":{"line":227,"column":56},"line":227,"code":"      it('should be true after we dispose of the session', async () => {\n        const session = await startNew();\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call multiple times","suites":["session","Session.DefaultSession","#isDisposed"],"updatePoint":{"line":234,"column":47},"line":234,"code":"      it('should be safe to call multiple times', async () => {\n        const session = await startNew();\n        expect(session.isDisposed).toBe(false);\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources held by the session","suites":["session","Session.DefaultSession","#dispose()"],"updatePoint":{"line":245,"column":61},"line":245,"code":"      it('should dispose of the resources held by the session', async () => {\n        const session = await startNew();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call twice","suites":["session","Session.DefaultSession","#dispose()"],"updatePoint":{"line":251,"column":38},"line":251,"code":"      it('should be safe to call twice', async () => {\n        const session = await startNew();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call if the kernel is disposed","suites":["session","Session.DefaultSession","#dispose()"],"updatePoint":{"line":259,"column":58},"line":259,"code":"      it('should be safe to call if the kernel is disposed', async () => {\n        const session = await startNew();\n        session.kernel!.dispose();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should set the path of the session","suites":["session","Session.DefaultSession","#setPath()"],"updatePoint":{"line":268,"column":44},"line":268,"code":"      it('should set the path of the session', async () => {\n        const newPath = UUID.uuid4();\n        await defaultSession.setPath(newPath);\n        expect(defaultSession.path).toBe(newPath);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper response status","suites":["session","Session.DefaultSession","#setPath()"],"updatePoint":{"line":274,"column":50},"line":274,"code":"      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for error response status","suites":["session","Session.DefaultSession","#setPath()"],"updatePoint":{"line":279,"column":47},"line":279,"code":"      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper model","suites":["session","Session.DefaultSession","#setPath()"],"updatePoint":{"line":284,"column":40},"line":284,"code":"      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the session is disposed","suites":["session","Session.DefaultSession","#setPath()"],"updatePoint":{"line":289,"column":48},"line":289,"code":"      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should set the type of the session","suites":["session","Session.DefaultSession","#setType()"],"updatePoint":{"line":300,"column":44},"line":300,"code":"      it('should set the type of the session', async () => {\n        const session = await startNew();\n        const type = UUID.uuid4();\n        await session.setType(type);\n        expect(session.type).toBe(type);\n        await session.shutdown();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper response status","suites":["session","Session.DefaultSession","#setType()"],"updatePoint":{"line":308,"column":50},"line":308,"code":"      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for error response status","suites":["session","Session.DefaultSession","#setType()"],"updatePoint":{"line":313,"column":47},"line":313,"code":"      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper model","suites":["session","Session.DefaultSession","#setType()"],"updatePoint":{"line":318,"column":40},"line":318,"code":"      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the session is disposed","suites":["session","Session.DefaultSession","#setType()"],"updatePoint":{"line":323,"column":48},"line":323,"code":"      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should set the name of the session","suites":["session","Session.DefaultSession","#setName()"],"updatePoint":{"line":334,"column":44},"line":334,"code":"      it('should set the name of the session', async () => {\n        const name = UUID.uuid4();\n        await defaultSession.setName(name);\n        expect(defaultSession.name).toBe(name);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper response status","suites":["session","Session.DefaultSession","#setName()"],"updatePoint":{"line":340,"column":50},"line":340,"code":"      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for error response status","suites":["session","Session.DefaultSession","#setName()"],"updatePoint":{"line":345,"column":47},"line":345,"code":"      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for improper model","suites":["session","Session.DefaultSession","#setName()"],"updatePoint":{"line":350,"column":40},"line":350,"code":"      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the session is disposed","suites":["session","Session.DefaultSession","#setName()"],"updatePoint":{"line":355,"column":48},"line":355,"code":"      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new kernel with the new name","suites":["session","Session.DefaultSession","#changeKernel()"],"updatePoint":{"line":366,"column":54},"line":366,"code":"      it('should create a new kernel with the new name', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        await session.changeKernel({ name: previous.name });\n        expect(session.kernel!.name).toBe(previous.name);\n        expect(session.kernel!.id).not.toBe(previous.id);\n        expect(session.kernel).not.toBe(previous);\n        previous.dispose();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept the id of the new kernel","suites":["session","Session.DefaultSession","#changeKernel()"],"updatePoint":{"line":377,"column":48},"line":377,"code":"      it('should accept the id of the new kernel', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        const kernel = await KernelAPI.startNew();\n        await session.changeKernel({ id: kernel.id });\n        expect(session.kernel!.id).toBe(kernel.id);\n        expect(session.kernel).not.toBe(previous);\n        expect(session.kernel).not.toBe(kernel);\n        previous.dispose();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the session path if it has changed","suites":["session","Session.DefaultSession","#changeKernel()"],"updatePoint":{"line":389,"column":58},"line":389,"code":"      it('should update the session path if it has changed', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        const path = UUID.uuid4() + '.ipynb';\n        const model = { ...session.model, path };\n        handleRequest(session, 200, model);\n        await session.changeKernel({ name: previous.name });\n        expect(session.kernel!.name).toBe(previous.name);\n        expect(session.path).toBe(model.path);\n        previous.dispose();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down properly","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":404,"column":35},"line":404,"code":"      it('should shut down properly', async () => {\n        session = await startNew();\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a disposed signal","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":409,"column":39},"line":409,"code":"      it('should emit a disposed signal', async () => {\n        let called = false;\n        session = await startNew();\n        session.disposed.connect(() => {\n          called = true;\n        });\n        await session.shutdown();\n        expect(called).toBe(true);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an incorrect response status","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":419,"column":54},"line":419,"code":"      it('should fail for an incorrect response status', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.shutdown()).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a 404 status","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":424,"column":36},"line":424,"code":"      it('should handle a 404 status', async () => {\n        session = await startNew();\n        handleRequest(session, 404, {});\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a specific error status","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":430,"column":47},"line":430,"code":"      it('should handle a specific error status', async () => {\n        handleRequest(defaultSession, 410, {});\n        const promise = defaultSession.shutdown();\n        await expect(promise).rejects.toThrow(\n          'The kernel was deleted but the session was not'\n        );\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for an error response status","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":438,"column":50},"line":438,"code":"      it('should fail for an error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.shutdown()).rejects.toThrow();\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail if the session is disposed","suites":["session","Session.DefaultSession","#shutdown()"],"updatePoint":{"line":443,"column":48},"line":443,"code":"      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        await expect(session.shutdown()).rejects.toThrow(/Session is disposed/);\n      });","file":"session/isession.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new session manager","suites":["session/manager","SessionManager","#constructor()"],"updatePoint":{"line":71,"column":45},"line":71,"code":"      it('should create a new session manager', () => {\n        expect(manager instanceof SessionManager).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["session/manager","SessionManager","#serverSettings"],"updatePoint":{"line":77,"column":40},"line":77,"code":"      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const token = serverSettings.token;\n        manager = new SessionManager({ kernelManager, serverSettings });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is ready","suites":["session/manager","SessionManager","#isReady"],"updatePoint":{"line":88,"column":50},"line":88,"code":"      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new SessionManager({ kernelManager });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve when the manager is ready","suites":["session/manager","SessionManager","#ready"],"updatePoint":{"line":98,"column":50},"line":98,"code":"      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the running sessions","suites":["session/manager","SessionManager","#running()"],"updatePoint":{"line":104,"column":41},"line":104,"code":"      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        const running = toArray(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the running sessions changed","suites":["session/manager","SessionManager","#runningChanged"],"updatePoint":{"line":112,"column":61},"line":112,"code":"      it('should be emitted when the running sessions changed', async () => {\n        const promise = testEmission(manager.runningChanged, {\n          test: (sender, args) => {\n            expect(sender).toBe(manager);\n            expect(toArray(args).length).toBeGreaterThan(0);\n          }\n        });\n        await startNew(manager);\n        await promise;\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a session is shut down","suites":["session/manager","SessionManager","#runningChanged"],"updatePoint":{"line":123,"column":55},"line":123,"code":"      it('should be emitted when a session is shut down', async () => {\n        let called = false;\n        const s = await startNew(manager);\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await s.shutdown();\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a session is renamed","suites":["session/manager","SessionManager","#runningChanged"],"updatePoint":{"line":134,"column":53},"line":134,"code":"      it('should be emitted when a session is renamed', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await session.setPath(UUID.uuid4());\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a session changes kernels","suites":["session/manager","SessionManager","#runningChanged"],"updatePoint":{"line":144,"column":58},"line":144,"code":"      it('should be emitted when a session changes kernels', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await session.changeKernel({ name: session.kernel!.name });\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should refresh the list of session ids","suites":["session/manager","SessionManager","#refreshRunning()"],"updatePoint":{"line":158,"column":48},"line":158,"code":"      it('should refresh the list of session ids', async () => {\n        await manager.refreshRunning();\n        const running = toArray(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should start a session","suites":["session/manager","SessionManager","#startNew()"],"updatePoint":{"line":166,"column":32},"line":166,"code":"      it('should start a session', async () => {\n        const session = await startNew(manager);\n        expect(session.id).toBeTruthy();\n        return session.shutdown();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["session/manager","SessionManager","#startNew()"],"updatePoint":{"line":172,"column":45},"line":172,"code":"      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await startNew(manager);\n        expect(called).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should find an existing session by path","suites":["session/manager","SessionManager","#findByPath()"],"updatePoint":{"line":183,"column":49},"line":183,"code":"      it('should find an existing session by path', async () => {\n        const newModel = await manager.findByPath(session.path);\n        expect(newModel!.id).toBe(session.id);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should find an existing session by id","suites":["session/manager","SessionManager","#findById()"],"updatePoint":{"line":190,"column":47},"line":190,"code":"      it('should find an existing session by id', async () => {\n        const newModel = await manager.findById(session.id);\n        expect(newModel!.id).toBe(session.id);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should connect to a running session","suites":["session/manager","SessionManager","#connectTo()"],"updatePoint":{"line":197,"column":45},"line":197,"code":"      it('should connect to a running session', () => {\n        const newSession = manager.connectTo({ model: session.model });\n        expect(newSession.id).toBe(session.id);\n        expect(newSession.kernel!.id).toBe(session.kernel!.id);\n        expect(newSession).not.toBe(session);\n        expect(newSession.kernel).not.toBe(session.kernel);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down a session by id","suites":["session/manager","SessionManager","shutdown()"],"updatePoint":{"line":207,"column":42},"line":207,"code":"      it('should shut down a session by id', async () => {\n        const temp = await startNew(manager);\n        await manager.shutdown(temp.id);\n        expect(temp.isDisposed).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["session/manager","SessionManager","shutdown()"],"updatePoint":{"line":213,"column":45},"line":213,"code":"      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        const session = await startNew(manager);\n        manager.runningChanged.connect((sender, sessions) => {\n          // Make sure the sessions list does not have our shutdown session in it.\n          if (!sessions.find(s => s.id === session.id)) {\n            called = true;\n          }\n        });\n\n        await manager.shutdown(session.id);\n        expect(called).toBe(true);\n        expect(session.isDisposed).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of all session instances asynchronously","suites":["session/manager","SessionManager","shutdown()"],"updatePoint":{"line":228,"column":64},"line":228,"code":"      it('should dispose of all session instances asynchronously', async () => {\n        const session0 = await startNew(manager);\n        const session1 = manager.connectTo({ model: session0.model });\n        const emission = testEmission(session1.disposed);\n        await session0.shutdown();\n        await expect(emission).resolves.not.toThrow();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should take the options as an argument","suites":["session/manager","NoopManager","#constructor()"],"updatePoint":{"line":257,"column":48},"line":257,"code":"      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new SessionManager.NoopManager({\n          kernelManager,\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof SessionManager.NoopManager).toBe(true);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["session/manager","NoopManager","#serverSettings"],"updatePoint":{"line":269,"column":40},"line":269,"code":"      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new SessionManager.NoopManager({\n          kernelManager,\n          serverSettings,\n          standby\n        });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the running sessions","suites":["session/manager","NoopManager","#running()"],"updatePoint":{"line":285,"column":41},"line":285,"code":"      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running kernels","suites":["session/manager","NoopManager","#refreshRunning()"],"updatePoint":{"line":292,"column":43},"line":292,"code":"      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["session/manager","NoopManager","#startNew()"],"updatePoint":{"line":299,"column":31},"line":299,"code":"      it('should throw an error', () => {\n        return expect(startNew(manager)).rejects.toThrow();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["session/manager","NoopManager","#connectTo()"],"updatePoint":{"line":305,"column":31},"line":305,"code":"      it('should throw an error', () => {\n        const model = {\n          id: UUID.uuid4(),\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'MYTEST',\n          kernel: { name: 'foo', id: UUID.uuid4() }\n        };\n        return expect(() => {\n          manager.connectTo({ model });\n        }).toThrow();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["session/manager","NoopManager","shutdown()"],"updatePoint":{"line":320,"column":31},"line":320,"code":"      it('should throw an error', () => {\n        return expect(manager.shutdown(UUID.uuid4())).rejects.toThrow();\n      });","file":"session/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should yield a list of valid session models","suites":["session","Session.listRunning()"],"updatePoint":{"line":41,"column":51},"line":41,"code":"    it('should yield a list of valid session models', async () => {\n      expect(toArray(await SessionAPI.listRunning()).length).toBe(0);\n      const session = await SessionAPI.startSession({\n        name: UUID.uuid4(),\n        path: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(toArray(await SessionAPI.listRunning())).toEqual([session]);\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for an invalid model","suites":["session","Session.listRunning()"],"updatePoint":{"line":51,"column":50},"line":51,"code":"    it('should throw an error for an invalid model', async () => {\n      const data = { id: '1234', path: 'test' };\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error for another invalid model","suites":["session","Session.listRunning()"],"updatePoint":{"line":57,"column":55},"line":57,"code":"    it('should throw an error for another invalid model', async () => {\n      const data = [{ id: '1234', kernel: { id: '', name: '' }, path: '' }];\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for wrong response status","suites":["session","Session.listRunning()"],"updatePoint":{"line":63,"column":45},"line":63,"code":"    it('should fail for wrong response status', async () => {\n      const serverSettings = getRequestHandler(201, [createSessionModel()]);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for error response status","suites":["session","Session.listRunning()"],"updatePoint":{"line":68,"column":45},"line":68,"code":"    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should start a session","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":75,"column":30},"line":75,"code":"    it('should start a session', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(session.id).toBeTruthy();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept ajax options","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":84,"column":34},"line":84,"code":"    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      session = await SessionAPI.startSession(\n        {\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'test'\n        },\n        serverSettings\n      );\n      expect(session.id).toBeTruthy();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for wrong response status","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":97,"column":45},"line":97,"code":"    it('should fail for wrong response status', async () => {\n      const sessionModel = createSessionModel();\n      const serverSettings = getRequestHandler(200, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for error response status","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":105,"column":45},"line":105,"code":"    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const sessionModel = createSessionModel();\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail for wrong response model","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":113,"column":44},"line":113,"code":"    it('should fail for wrong response model', async () => {\n      const sessionModel = createSessionModel();\n      (sessionModel as any).path = 1;\n      const serverSettings = getRequestHandler(201, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow(/Property 'path' is not of type 'string'/);\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a deprecated response model","suites":["session","SessionAPI.startNew"],"updatePoint":{"line":122,"column":49},"line":122,"code":"    it('should handle a deprecated response model', async () => {\n      const sessionModel = createSessionModel();\n      const data = {\n        id: sessionModel.id,\n        kernel: sessionModel.kernel,\n        notebook: { path: sessionModel.path }\n      };\n      const serverSettings = getRequestHandler(201, data);\n      const model = await SessionAPI.startSession(\n        sessionModel as any,\n        serverSettings\n      );\n      expect(model).toHaveProperty('id');\n      expect(model.path).toBeTruthy();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down a kernel by id","suites":["session","Session.shutdown()"],"updatePoint":{"line":140,"column":39},"line":140,"code":"    it('should shut down a kernel by id', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      await expect(\n        SessionAPI.shutdownSession(session.id)\n      ).resolves.not.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a 404 status","suites":["session","Session.shutdown()"],"updatePoint":{"line":151,"column":34},"line":151,"code":"    it('should handle a 404 status', async () => {\n      await expect(\n        SessionAPI.shutdownSession(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });","file":"session/session.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should pass a valid model","suites":["session/validate","#validateModel()"],"updatePoint":{"line":12,"column":33},"line":12,"code":"    it('should pass a valid model', () => {\n      const model: Session.IModel = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        path: 'bar',\n        name: '',\n        type: ''\n      };\n      expect(() => {\n        validateModel(model);\n      }).not.toThrow();\n    });","file":"session/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fail on missing data","suites":["session/validate","#validateModel()"],"updatePoint":{"line":25,"column":35},"line":25,"code":"    it('should fail on missing data', () => {\n      const model: any = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        path: 'bar',\n        name: ''\n      };\n      expect(() => validateModel(model)).toThrowError();\n    });","file":"session/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update a deprecated model","suites":["session/validate","#updateLegacySessionModel()"],"updatePoint":{"line":37,"column":40},"line":37,"code":"    it('should update a deprecated model', () => {\n      const model = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        notebook: {\n          path: 'bar'\n        }\n      };\n      updateLegacySessionModel(model);\n      expect(() => {\n        validateModel(model);\n      }).not.toThrow();\n    });","file":"session/validate.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept no options","suites":["setting","SettingManager","#constructor()"],"updatePoint":{"line":32,"column":34},"line":32,"code":"      it('should accept no options', () => {\n        const manager = new SettingManager();\n        expect(manager).toBeInstanceOf(SettingManager);\n      });","file":"setting/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept options","suites":["setting","SettingManager","#constructor()"],"updatePoint":{"line":37,"column":31},"line":37,"code":"      it('should accept options', () => {\n        const manager = new SettingManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(SettingManager);\n      });","file":"setting/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the server settings","suites":["setting","SettingManager","#serverSettings"],"updatePoint":{"line":46,"column":39},"line":46,"code":"      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new SettingManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });","file":"setting/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fetch settings for an extension","suites":["setting","SettingManager","#fetch()"],"updatePoint":{"line":55,"column":48},"line":55,"code":"      it('should fetch settings for an extension', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n\n        expect((await manager.fetch(id)).id).toBe(id);\n      });","file":"setting/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should save a setting","suites":["setting","SettingManager","#save()"],"updatePoint":{"line":63,"column":31},"line":63,"code":"      it('should save a setting', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n        const theme = 'Foo Theme';\n        const raw = `{\"theme\": \"${theme}\"}`;\n\n        await manager.save(id, raw);\n        expect(JSON.parse((await manager.fetch(id)).raw).theme).toBe(theme);\n      });","file":"setting/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept no options","suites":["terminal","TerminalManager","#constructor()"],"updatePoint":{"line":42,"column":34},"line":42,"code":"      it('should accept no options', async () => {\n        const manager = new TerminalManager({ standby: 'never' });\n        await manager.ready;\n        expect(manager).toBeInstanceOf(TerminalManager);\n        manager.dispose();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept options","suites":["terminal","TerminalManager","#constructor()"],"updatePoint":{"line":49,"column":31},"line":49,"code":"      it('should accept options', async () => {\n        const manager = new TerminalManager({\n          serverSettings: ServerConnection.makeSettings(),\n          standby: 'never'\n        });\n        await manager.ready;\n        expect(manager).toBeInstanceOf(TerminalManager);\n        manager.dispose();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["terminal","TerminalManager","#serverSettings"],"updatePoint":{"line":61,"column":40},"line":61,"code":"      it('should get the server settings', async () => {\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        const manager = new TerminalManager({ serverSettings, standby });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n        manager.dispose();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the manager is ready","suites":["terminal","TerminalManager","#isReady"],"updatePoint":{"line":73,"column":50},"line":73,"code":"      it('should test whether the manager is ready', async () => {\n        const manager = new TerminalManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n        manager.dispose();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve when the manager is ready","suites":["terminal","TerminalManager","#ready"],"updatePoint":{"line":83,"column":50},"line":83,"code":"      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether terminal sessions are available","suites":["terminal","TerminalManager","#isAvailable()"],"updatePoint":{"line":89,"column":61},"line":89,"code":"      it('should test whether terminal sessions are available', () => {\n        expect(Terminal.isAvailable()).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should give an iterator over the list of running models","suites":["terminal","TerminalManager","#running()"],"updatePoint":{"line":95,"column":65},"line":95,"code":"      it('should give an iterator over the list of running models', async () => {\n        await TerminalAPI.startNew();\n        await manager.refreshRunning();\n        const running = toArray(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should startNew a new terminal session","suites":["terminal","TerminalManager","#startNew()"],"updatePoint":{"line":104,"column":48},"line":104,"code":"      it('should startNew a new terminal session', async () => {\n        const session = await manager.startNew();\n        expect(session.name).toBeTruthy();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["terminal","TerminalManager","#startNew()"],"updatePoint":{"line":109,"column":45},"line":109,"code":"      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.startNew();\n        expect(called).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should connect to an existing session","suites":["terminal","TerminalManager","#connectTo()"],"updatePoint":{"line":120,"column":47},"line":120,"code":"      it('should connect to an existing session', async () => {\n        const session = await manager.startNew();\n        const session2 = manager.connectTo({ model: session.model });\n        expect(session).not.toBe(session2);\n        expect(session2.name).toBe(session.name);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down a session by id","suites":["terminal","TerminalManager","#shutdown()"],"updatePoint":{"line":129,"column":42},"line":129,"code":"      it('should shut down a session by id', async () => {\n        const temp = await manager.startNew();\n        await manager.shutdown(temp.name);\n        expect(temp.isDisposed).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should emit a runningChanged signal","suites":["terminal","TerminalManager","#shutdown()"],"updatePoint":{"line":135,"column":45},"line":135,"code":"      it('should emit a runningChanged signal', async () => {\n        const session = await manager.startNew();\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.shutdown(session.name);\n        expect(called).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when the running terminals changed","suites":["terminal","TerminalManager","#runningChanged"],"updatePoint":{"line":147,"column":62},"line":147,"code":"      it('should be emitted when the running terminals changed', async () => {\n        const emission = testEmission(manager.runningChanged, {\n          test: (sender, args) => {\n            expect(sender).toBe(manager);\n            expect(toArray(args).length).toBeGreaterThan(0);\n          }\n        });\n        await manager.startNew();\n        await emission;\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running session models","suites":["terminal","TerminalManager","#refreshRunning()"],"updatePoint":{"line":160,"column":50},"line":160,"code":"      it('should update the running session models', async () => {\n        const before = toArray(manager.running()).length;\n        const model = await TerminalAPI.startNew();\n        await manager.refreshRunning();\n        const running = toArray(manager.running());\n        expect(running.length).toBe(before + 1);\n        let found = false;\n        running.map(m => {\n          if (m.name === model.name) {\n            found = true;\n          }\n        });\n        expect(found).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should take the options as an argument","suites":["terminal","NoopManager","#constructor()"],"updatePoint":{"line":190,"column":48},"line":190,"code":"      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new TerminalManager.NoopManager({\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof TerminalManager.NoopManager).toBe(true);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the server settings","suites":["terminal","NoopManager","#serverSettings"],"updatePoint":{"line":201,"column":40},"line":201,"code":"      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new TerminalManager.NoopManager({ serverSettings, standby });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should get the running sessions","suites":["terminal","NoopManager","#running()"],"updatePoint":{"line":213,"column":41},"line":213,"code":"      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should update the running kernels","suites":["terminal","NoopManager","#refreshRunning()"],"updatePoint":{"line":220,"column":43},"line":220,"code":"      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(toArray(manager.running()).length).toEqual(0);\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["terminal","NoopManager","#startNew()"],"updatePoint":{"line":227,"column":31},"line":227,"code":"      it('should throw an error', () => {\n        return expect(manager.startNew()).rejects.toThrow();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["terminal","NoopManager","#connectTo()"],"updatePoint":{"line":233,"column":31},"line":233,"code":"      it('should throw an error', () => {\n        return expect(() => {\n          manager.connectTo({ model: { name: 'abcd' } });\n        }).toThrow();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should throw an error","suites":["terminal","NoopManager","shutdown()"],"updatePoint":{"line":241,"column":31},"line":241,"code":"      it('should throw an error', () => {\n        return expect(manager.shutdown('1234')).rejects.toThrow();\n      });","file":"terminal/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether terminal sessions are available","suites":["terminal","Terminal",".isAvailable()"],"updatePoint":{"line":37,"column":61},"line":37,"code":"      it('should test whether terminal sessions are available', () => {\n        expect(Terminal.isAvailable()).toBe(true);\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be emitted when a message is received","suites":["terminal",".ITerminalConnection","#messageReceived"],"updatePoint":{"line":45,"column":54},"line":45,"code":"      it('should be emitted when a message is received', async () => {\n        session = await manager.startNew();\n        const emission = testEmission(session.messageReceived, {\n          test: (sender, msg) => {\n            return msg.type === 'stdout';\n          }\n        });\n        session.send({ type: 'stdin', content: ['cd\\r'] });\n        await expect(emission).resolves.not.toThrow();\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the name of the session","suites":["terminal",".ITerminalConnection","#name"],"updatePoint":{"line":58,"column":43},"line":58,"code":"      it('should be the name of the session', () => {\n        expect(defaultSession.name).toBeTruthy();\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the server settings of the server","suites":["terminal",".ITerminalConnection","#serverSettings"],"updatePoint":{"line":64,"column":53},"line":64,"code":"      it('should be the server settings of the server', () => {\n        expect(defaultSession.serverSettings.baseUrl).toBe(\n          PageConfig.getBaseUrl()\n        );\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should test whether the object is disposed","suites":["terminal",".ITerminalConnection","#isDisposed"],"updatePoint":{"line":72,"column":52},"line":72,"code":"      it('should test whether the object is disposed', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should dispose of the resources used by the session","suites":["terminal",".ITerminalConnection","#dispose()"],"updatePoint":{"line":83,"column":61},"line":83,"code":"      it('should dispose of the resources used by the session', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be safe to call more than once","suites":["terminal",".ITerminalConnection","#dispose()"],"updatePoint":{"line":91,"column":47},"line":91,"code":"      it('should be safe to call more than once', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        session.dispose();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should send a message to the socket","suites":["terminal",".ITerminalConnection","#send()"],"updatePoint":{"line":102,"column":45},"line":102,"code":"      it('should send a message to the socket', () => {\n        expect(() => {\n          session.send({ type: 'stdin', content: [1, 2] });\n        }).not.toThrow();\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should reconnect to the socket","suites":["terminal",".ITerminalConnection","#reconnect()"],"updatePoint":{"line":110,"column":40},"line":110,"code":"      it('should reconnect to the socket', async () => {\n        const session = await manager.startNew();\n        const promise = session.reconnect();\n        expect(session.connectionStatus).toBe('connecting');\n        await promise;\n        expect(session.connectionStatus).toBe('connected');\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should shut down the terminal session","suites":["terminal",".ITerminalConnection","#shutdown()"],"updatePoint":{"line":120,"column":47},"line":120,"code":"      it('should shut down the terminal session', async () => {\n        session = await manager.startNew();\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should handle a 404 status","suites":["terminal",".ITerminalConnection","#shutdown()"],"updatePoint":{"line":125,"column":36},"line":125,"code":"      it('should handle a 404 status', async () => {\n        handleRequest(defaultSession, 404, {});\n        await expect(defaultSession.shutdown()).resolves.not.toThrow();\n      });","file":"terminal/terminal.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve to the given value","suites":["test/utils","testEmission"],"updatePoint":{"line":14,"column":41},"line":14,"code":"    it('should resolve to the given value', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await emission).toBe('done');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should find the given emission","suites":["test/utils","testEmission"],"updatePoint":{"line":24,"column":38},"line":24,"code":"    it('should find the given emission', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      expect(await emission).toBe('done');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should reject if the test throws an error","suites":["test/utils","testEmission"],"updatePoint":{"line":37,"column":49},"line":37,"code":"    it('should reject if the test throws an error', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        test: (a, b) => {\n          throw new Error('my error');\n        },\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      await expectFailure(emission, 'my error');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve if the test succeeds","suites":["test/utils","testEmission"],"updatePoint":{"line":53,"column":43},"line":53,"code":"    it('should resolve if the test succeeds', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        test: (a, b) => {\n          expect(b).toBe(1);\n        },\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      expect(await emission).toBe('done');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve to true only after a promise is fulfilled","suites":["test/utils","isFulfilled"],"updatePoint":{"line":71,"column":64},"line":71,"code":"    it('should resolve to true only after a promise is fulfilled', async () => {\n      const p = new PromiseDelegate<number>();\n      expect(await isFulfilled(p.promise)).toBe(false);\n      p.resolve(10);\n      expect(await isFulfilled(p.promise)).toBe(true);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should resolve to true even if the promise is rejected","suites":["test/utils","isFulfilled"],"updatePoint":{"line":78,"column":62},"line":78,"code":"    it('should resolve to true even if the promise is rejected', async () => {\n      const p = new PromiseDelegate<number>();\n      expect(await isFulfilled(p.promise)).toBe(false);\n      p.reject(new Error('my error'));\n      expect(await isFulfilled(p.promise)).toBe(true);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept no options","suites":["workspace","WorkspaceManager","#constructor()"],"updatePoint":{"line":32,"column":34},"line":32,"code":"      it('should accept no options', () => {\n        const manager = new WorkspaceManager();\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should accept options","suites":["workspace","WorkspaceManager","#constructor()"],"updatePoint":{"line":37,"column":31},"line":37,"code":"      it('should accept options', () => {\n        const manager = new WorkspaceManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should be the server settings","suites":["workspace","WorkspaceManager","#serverSettings"],"updatePoint":{"line":46,"column":39},"line":46,"code":"      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new WorkspaceManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fetch a saved workspace","suites":["workspace","WorkspaceManager","#fetch()"],"updatePoint":{"line":55,"column":40},"line":55,"code":"      it('should fetch a saved workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should fetch a workspace list supporting arbitrary IDs","suites":["workspace","WorkspaceManager","#list()"],"updatePoint":{"line":65,"column":64},"line":65,"code":"      it('should fetch a workspace list supporting arbitrary IDs', async () => {\n        const ids = ['foo', 'bar', 'baz', 'f/o/o', 'b/a/r', 'b/a/z'];\n        const promises = ids.map(id =>\n          manager.save(id, { data: {}, metadata: { id } })\n        );\n\n        await Promise.all(promises);\n        expect((await manager.list()).ids.sort()).toEqual(ids.sort());\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should remove a workspace","suites":["workspace","WorkspaceManager","#remove()"],"updatePoint":{"line":77,"column":35},"line":77,"code":"      it('should remove a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should save a workspace","suites":["workspace","WorkspaceManager","#save()"],"updatePoint":{"line":87,"column":33},"line":87,"code":"      it('should save a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });","file":"workspace/manager.spec.ts","skipped":false,"dir":"packages/services/test"},{"name":"should create a new schema validator","suites":["@jupyterlab/settingregistry","DefaultSchemaValidator","#constructor()"],"updatePoint":{"line":41,"column":46},"line":41,"code":"      it('should create a new schema validator', () => {\n        const validator = new DefaultSchemaValidator();\n\n        expect(validator).toBeInstanceOf(DefaultSchemaValidator);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should validate data against a schema","suites":["@jupyterlab/settingregistry","DefaultSchemaValidator","#validateData()"],"updatePoint":{"line":49,"column":47},"line":49,"code":"      it('should validate data against a schema', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string' }\n          },\n          type: 'object'\n        };\n        const composite = {};\n        const user = {};\n        const raw = '{ \"bar\": \"baz\" }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).toBe(null);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should return errors if the data fails to validate","suites":["@jupyterlab/settingregistry","DefaultSchemaValidator","#validateData()"],"updatePoint":{"line":69,"column":60},"line":69,"code":"      it('should return errors if the data fails to validate', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string' }\n          },\n          type: 'object'\n        };\n        const composite = {};\n        const user = {};\n        const raw = '{ \"baz\": \"qux\" }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).not.toBe(null);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should populate the composite data","suites":["@jupyterlab/settingregistry","DefaultSchemaValidator","#validateData()"],"updatePoint":{"line":89,"column":44},"line":89,"code":"      it('should populate the composite data', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string', default: 'baz' }\n          },\n          type: 'object'\n        };\n        const composite = {} as JSONObject;\n        const user = {} as JSONObject;\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).toBe(null);\n        expect(plugin.data.user.bar).toBeUndefined();\n        expect(plugin.data.composite.bar).toBe(schema.properties!.bar.default);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should create a new setting registry","suites":["@jupyterlab/settingregistry","SettingRegistry","#constructor()"],"updatePoint":{"line":128,"column":46},"line":128,"code":"      it('should create a new setting registry', () => {\n        expect(registry).toBeInstanceOf(SettingRegistry);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should emit when a plugin changes","suites":["@jupyterlab/settingregistry","SettingRegistry","#pluginChanged"],"updatePoint":{"line":134,"column":43},"line":134,"code":"      it('should emit when a plugin changes', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        let called = false;\n        registry.pluginChanged.connect((sender: any, plugin: string) => {\n          expect(id).toBe(plugin);\n          called = true;\n        });\n        await registry.load(id);\n        await registry.set(id, key, value);\n        expect(called).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should return a list of registered plugins in registry","suites":["@jupyterlab/settingregistry","SettingRegistry","#plugins"],"updatePoint":{"line":152,"column":64},"line":152,"code":"      it('should return a list of registered plugins in registry', async () => {\n        const one = 'foo';\n        const two = 'bar';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[one] = { type: 'object' };\n        connector.schemas[two] = { type: 'object' };\n        await registry.load(one);\n        expect(Object.keys(registry.plugins)).toHaveLength(1);\n        await registry.load(two);\n        expect(Object.keys(registry.plugins)).toHaveLength(2);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should get a setting item from a loaded plugin","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":167,"column":56},"line":167,"code":"      it('should get a setting item from a loaded plugin', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        (await registry.load(id)) as Settings;\n        const saved = await registry.get(id, key);\n        expect(saved.user).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should get a setting item from a plugin that is not loaded","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":179,"column":68},"line":179,"code":"      it('should get a setting item from a plugin that is not loaded', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should use schema default if user data not available","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":190,"column":62},"line":190,"code":"      it('should use schema default if user data not available', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(schema.properties![key].default);\n        expect(saved.composite).not.toBe(saved.user);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should let user value override schema default","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":209,"column":55},"line":209,"code":"      it('should let user value override schema default', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(value);\n        expect(saved.user).toBe(value);\n        expect(saved.composite).not.toBe(schema.properties![key].default);\n        expect(saved.user).not.toBe(schema.properties![key].default);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should reject if a plugin does not exist","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":231,"column":50},"line":231,"code":"      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.get('foo', 'bar');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should resolve `undefined` if a key does not exist","suites":["@jupyterlab/settingregistry","SettingRegistry","#get()"],"updatePoint":{"line":241,"column":60},"line":241,"code":"      it('should resolve `undefined` if a key does not exist', async () => {\n        const id = 'foo';\n        const key = 'bar';\n\n        connector.schemas[id] = { type: 'object' };\n\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should resolve a registered plugin's settings","suites":["@jupyterlab/settingregistry","SettingRegistry","#load()"],"updatePoint":{"line":254,"column":55},"line":254,"code":"      it(`should resolve a registered plugin's settings`, async () => {\n        const id = 'foo';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object' };\n        const settings = (await registry.load(id)) as Settings;\n        expect(settings.id).toBe(id);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should reject if a plugin transformation times out","suites":["@jupyterlab/settingregistry","SettingRegistry","#load()"],"updatePoint":{"line":263,"column":60},"line":263,"code":"      it(`should reject if a plugin transformation times out`, async () => {\n        const id = 'foo';\n        let failed = false;\n\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n\n        try {\n          await registry.load(id);\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should reject if a plugin does not exist","suites":["@jupyterlab/settingregistry","SettingRegistry","#load()"],"updatePoint":{"line":280,"column":50},"line":280,"code":"      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.load('foo');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should load a registered plugin's settings","suites":["@jupyterlab/settingregistry","SettingRegistry","#reload()"],"updatePoint":{"line":292,"column":52},"line":292,"code":"      it(`should load a registered plugin's settings`, async () => {\n        const id = 'foo';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object' };\n        const settings = await registry.reload(id);\n        expect(settings.id).toBe(id);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should replace a registered plugin's settings","suites":["@jupyterlab/settingregistry","SettingRegistry","#reload()"],"updatePoint":{"line":301,"column":55},"line":301,"code":"      it(`should replace a registered plugin's settings`, async () => {\n        const id = 'foo';\n        const first = 'Foo';\n        const second = 'Bar';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object', title: first };\n        let settings = await registry.reload(id);\n        expect(settings.schema.title).toBe(first);\n        await Promise.resolve(undefined);\n        connector.schemas[id].title = second;\n        settings = await registry.reload(id);\n        expect(settings.schema.title).toBe(second);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should reject if a plugin does not exist","suites":["@jupyterlab/settingregistry","SettingRegistry","#reload()"],"updatePoint":{"line":316,"column":50},"line":316,"code":"      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.reload('foo');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should transform a plugin during the fetch phase","suites":["@jupyterlab/settingregistry","SettingRegistry","#transform()"],"updatePoint":{"line":328,"column":58},"line":328,"code":"      it(`should transform a plugin during the fetch phase`, async () => {\n        const id = 'foo';\n        const version = 'transform-test';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          fetch: plugin => {\n            plugin.version = version;\n            return plugin;\n          }\n        });\n        expect((await registry.load(id)).version).toBe(version);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should transform a plugin during the compose phase","suites":["@jupyterlab/settingregistry","SettingRegistry","#transform()"],"updatePoint":{"line":346,"column":60},"line":346,"code":"      it(`should transform a plugin during the compose phase`, async () => {\n        const id = 'foo';\n        const composite = { a: 1 };\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          compose: plugin => {\n            plugin.data = { user: plugin.data.user, composite };\n            return plugin;\n          }\n        });\n        expect((await registry.load(id)).composite).toEqual(composite);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should disallow a transform that changes the plugin ID","suites":["@jupyterlab/settingregistry","SettingRegistry","#transform()"],"updatePoint":{"line":364,"column":64},"line":364,"code":"      it(`should disallow a transform that changes the plugin ID`, async () => {\n        const id = 'foo';\n        let failed = false;\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          compose: plugin => {\n            plugin.id = 'bar';\n            return plugin;\n          }\n        });\n        try {\n          await registry.load(id);\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should merge menu tree","suites":["@jupyterlab/settingregistry","reconcileMenus"],"updatePoint":{"line":390,"column":30},"line":390,"code":"    it('should merge menu tree', () => {\n      const a: ISettingRegistry.IMenu[] = [\n        {\n          id: '1',\n          items: [{ command: 'a' }]\n        },\n        {\n          id: '2',\n          items: [{ command: 'b' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [{ command: 'sub-1' }]\n              }\n            }\n          ]\n        }\n      ];\n      const b: ISettingRegistry.IMenu[] = [\n        {\n          id: '2',\n          items: [\n            { command: 'b', disabled: true },\n            { command: 'b', args: { input: 'hello' } },\n            { command: 'b', args: { input: 'world' } },\n            { command: 'c' }\n          ]\n        },\n        {\n          id: '3',\n          items: [{ command: 'd' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [\n                  { command: 'sub-1', disabled: true },\n                  { command: 'sub-2' }\n                ]\n              }\n            }\n          ]\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileMenus(a, b);\n      expect(merged).toHaveLength(4);\n      expect(merged[0].id).toEqual('1');\n      expect(merged[0].items).toHaveLength(1);\n      expect(merged[1].id).toEqual('2');\n      expect(merged[1].items).toHaveLength(4);\n      expect(merged[1].items![0].command).toEqual('b');\n      expect(merged[1].items![0].args).toBeUndefined();\n      expect(merged[1].items![0].disabled).toEqual(true);\n      expect(merged[1].items![1].command).toEqual('b');\n      expect(merged[1].items![1].args?.input).toEqual('hello');\n      expect(merged[1].items![2].command).toEqual('b');\n      expect(merged[1].items![2].args?.input).toEqual('world');\n      expect(merged[2].id).toEqual('4');\n      expect(merged[2].items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items).toHaveLength(2);\n      expect(merged[2].items![0].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged[2].items![0].submenu?.items![0].disabled).toEqual(true);\n      expect(merged[3].id).toEqual('3');\n      expect(merged[3].items).toHaveLength(1);\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should merge menu tree without adding new items","suites":["@jupyterlab/settingregistry","reconcileMenus"],"updatePoint":{"line":466,"column":55},"line":466,"code":"    it('should merge menu tree without adding new items', () => {\n      const a: ISettingRegistry.IMenu[] = [\n        {\n          id: '1',\n          items: [{ command: 'a' }]\n        },\n        {\n          id: '2',\n          items: [{ command: 'b' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [{ command: 'sub-1' }]\n              }\n            }\n          ]\n        }\n      ];\n      const b: ISettingRegistry.IMenu[] = [\n        {\n          id: '2',\n          items: [\n            { command: 'b', disabled: true },\n            { command: 'b', args: { input: 'hello' } },\n            { command: 'b', args: { input: 'world' } },\n            { command: 'c' }\n          ]\n        },\n        {\n          id: '3',\n          items: [{ command: 'd' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [\n                  { command: 'sub-1', disabled: true },\n                  { command: 'sub-2' }\n                ]\n              }\n            }\n          ],\n          disabled: true\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileMenus(a, b, false, false);\n      expect(merged).toHaveLength(3);\n      expect(merged![0].id).toEqual('1');\n      expect(merged![0].items).toHaveLength(1);\n      expect(merged![1].id).toEqual('2');\n      expect(merged![1].items).toHaveLength(1);\n      expect(merged[1].items![0].command).toEqual('b');\n      expect(merged[1].items![0].args).toBeUndefined();\n      expect(merged[1].items![0].disabled).toEqual(true);\n      expect(merged[2].id).toEqual('4');\n      expect(merged[2].items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged[2].items![0].submenu?.items![0].disabled).toEqual(true);\n      expect(merged[2].disabled).toEqual(true);\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should merge items list","suites":["@jupyterlab/settingregistry","reconcileItems"],"updatePoint":{"line":540,"column":31},"line":540,"code":"    it('should merge items list', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { command: 'b', selector: '.b' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1' }]\n          },\n          selector: '.sub'\n        }\n      ];\n      const b: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'b', selector: '.b', disabled: true },\n        { command: 'b', selector: '.bb' },\n        { command: 'b', selector: '.b1', args: { input: 'hello' } },\n        { command: 'b', selector: '.b2', args: { input: 'world' } },\n        { command: 'c', selector: '.c' },\n        { command: 'd', selector: '.d' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileItems(a, b);\n      expect(merged).toHaveLength(8);\n      expect(merged![1].command).toEqual('b');\n      expect(merged![1].selector).toEqual('.b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].submenu?.items).toHaveLength(2);\n      expect(merged![3].command).toEqual('b');\n      expect(merged![3].selector).toEqual('.bb');\n      expect(merged![4].command).toEqual('b');\n      expect(merged![4].args?.input).toEqual('hello');\n      expect(merged![5].command).toEqual('b');\n      expect(merged![5].args?.input).toEqual('world');\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should merge items list without adding new ones","suites":["@jupyterlab/settingregistry","reconcileItems"],"updatePoint":{"line":584,"column":55},"line":584,"code":"    it('should merge items list without adding new ones', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { command: 'b', selector: '.b' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1' }]\n          },\n          selector: '.sub'\n        }\n      ];\n      const b: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'b', selector: '.b', disabled: true },\n        { command: 'b', selector: '.b1', args: { input: 'hello' } },\n        { command: 'b', selector: '.b2', args: { input: 'world' } },\n        { command: 'c', selector: '.c' },\n        { command: 'd', selector: '.d' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileItems(a, b, false, false);\n      expect(merged).toHaveLength(3);\n      expect(merged![1].command).toEqual('b');\n      expect(merged![1].selector).toEqual('.b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].submenu?.items).toHaveLength(1);\n      expect(merged![2].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged![2].submenu?.items![0].disabled).toEqual(true);\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should merge toolbar items list","suites":["@jupyterlab/settingregistry","reconcileToolbarItems"],"updatePoint":{"line":625,"column":39},"line":625,"code":"    it('should merge toolbar items list', () => {\n      const a: ISettingRegistry.IToolbarItem[] = [\n        { name: 'a' },\n        { name: 'b', command: 'command-b' }\n      ];\n      const b: ISettingRegistry.IToolbarItem[] = [\n        { name: 'b', disabled: true },\n        { name: 'c', type: 'spacer' },\n        { name: 'd', command: 'command-d' }\n      ];\n\n      const merged = SettingRegistry.reconcileToolbarItems(a, b);\n      expect(merged).toHaveLength(4);\n      expect(merged![0].name).toEqual('a');\n      expect(merged![1].name).toEqual('b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].name).toEqual('c');\n      expect(merged![2].type).toEqual('spacer');\n      expect(merged![3].name).toEqual('d');\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should remove disabled menu item","suites":["@jupyterlab/settingregistry","filterDisabledItems"],"updatePoint":{"line":648,"column":40},"line":648,"code":"    it('should remove disabled menu item', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { type: 'separator', selector: '.a' },\n        { command: 'b', disabled: true, selector: '.a' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const filtered = SettingRegistry.filterDisabledItems(a);\n      expect(filtered).toHaveLength(3);\n      expect(filtered[0]?.command).toEqual('a');\n      expect(filtered[1]?.type).toEqual('separator');\n      expect(filtered[2]?.type).toEqual('submenu');\n      expect(filtered[2]?.submenu?.items).toHaveLength(1);\n      expect(filtered[2]?.submenu?.items![0].command).toEqual('sub-2');\n    });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should create a new settings object for a plugin","suites":["@jupyterlab/settingregistry","Settings","#constructor()"],"updatePoint":{"line":692,"column":58},"line":692,"code":"      it('should create a new settings object for a plugin', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings).toBeInstanceOf(Settings);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should emit when a plugin changes","suites":["@jupyterlab/settingregistry","Settings","#changed"],"updatePoint":{"line":706,"column":43},"line":706,"code":"      it('should emit when a plugin changes', async () => {\n        const id = 'alpha';\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        const promise = signalToPromise(settings.changed);\n        await settings.set('foo', 'bar');\n        await expect(promise).resolves.toContain(settings);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should contain the merged user and default data","suites":["@jupyterlab/settingregistry","Settings","#composite"],"updatePoint":{"line":719,"column":57},"line":719,"code":"      it('should contain the merged user and default data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.composite[key]).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should privilege user data","suites":["@jupyterlab/settingregistry","Settings","#composite"],"updatePoint":{"line":738,"column":36},"line":738,"code":"      it('should privilege user data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        await settings.set(key, value);\n        expect(settings.composite[key]).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should expose the plugin ID","suites":["@jupyterlab/settingregistry","Settings","#id"],"updatePoint":{"line":760,"column":37},"line":760,"code":"      it('should expose the plugin ID', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.id).toBe(id);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should test whether the settings object is disposed","suites":["@jupyterlab/settingregistry","Settings","#isDisposed"],"updatePoint":{"line":774,"column":61},"line":774,"code":"      it('should test whether the settings object is disposed', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.isDisposed).toBe(false);\n        settings.dispose();\n        expect(settings.isDisposed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should expose the plugin schema","suites":["@jupyterlab/settingregistry","Settings","#schema"],"updatePoint":{"line":790,"column":41},"line":790,"code":"      it('should expose the plugin schema', async () => {\n        const id = 'alpha';\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.schema).toEqual(schema);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should privilege user data","suites":["@jupyterlab/settingregistry","Settings","#user"],"updatePoint":{"line":801,"column":36},"line":801,"code":"      it('should privilege user data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        await settings.set(key, value);\n        expect(settings.user[key]).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should expose the setting registry","suites":["@jupyterlab/settingregistry","Settings","#registry"],"updatePoint":{"line":823,"column":44},"line":823,"code":"      it('should expose the setting registry', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.registry).toBe(registry);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should dispose the settings object","suites":["@jupyterlab/settingregistry","Settings","#dispose()"],"updatePoint":{"line":837,"column":44},"line":837,"code":"      it('should dispose the settings object', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.isDisposed).toBe(false);\n        settings.dispose();\n        expect(settings.isDisposed).toBe(true);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should return a fully extrapolated schema default","suites":["@jupyterlab/settingregistry","Settings","#default()"],"updatePoint":{"line":853,"column":59},"line":853,"code":"      it('should return a fully extrapolated schema default', async () => {\n        const id = 'omicron';\n        const defaults = {\n          foo: 'one',\n          bar: 100,\n          baz: {\n            qux: 'two',\n            quux: 'three',\n            quuz: {\n              corge: { grault: 200 }\n            }\n          }\n        };\n\n        connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            foo: { type: 'string', default: defaults.foo },\n            bar: { type: 'number', default: defaults.bar },\n            baz: {\n              type: 'object',\n              default: {},\n              properties: {\n                qux: { type: 'string', default: defaults.baz.qux },\n                quux: { type: 'string', default: defaults.baz.quux },\n                quuz: {\n                  type: 'object',\n                  default: {},\n                  properties: {\n                    corge: {\n                      type: 'object',\n                      default: {},\n                      properties: {\n                        grault: {\n                          type: 'number',\n                          default: defaults.baz.quuz.corge.grault\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            'nonexistent-default': { type: 'string' }\n          }\n        };\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.default('nonexistent-key')).toBeUndefined();\n        expect(settings.default('foo')).toBe(defaults.foo);\n        expect(settings.default('bar')).toBe(defaults.bar);\n        expect(settings.default('baz')).toEqual(defaults.baz);\n        expect(settings.default('nonexistent-default')).toBeUndefined();\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should get a setting item","suites":["@jupyterlab/settingregistry","Settings","#get()"],"updatePoint":{"line":909,"column":35},"line":909,"code":"      it('should get a setting item', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.user).toBe(value);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should use schema default if user data not available","suites":["@jupyterlab/settingregistry","Settings","#get()"],"updatePoint":{"line":921,"column":62},"line":921,"code":"      it('should use schema default if user data not available', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n\n        expect(saved.composite).toBe(schema.properties![key].default);\n        expect(saved.composite).not.toBe(saved.user);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should let user value override schema default","suites":["@jupyterlab/settingregistry","Settings","#get()"],"updatePoint":{"line":942,"column":55},"line":942,"code":"      it('should let user value override schema default', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.composite).toBe(value);\n        expect(saved.user).toBe(value);\n        expect(saved.composite).not.toBe(schema.properties![key].default);\n        expect(saved.user).not.toBe(schema.properties![key].default);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should be `undefined` if a key does not exist","suites":["@jupyterlab/settingregistry","Settings","#get()"],"updatePoint":{"line":965,"column":55},"line":965,"code":"      it('should be `undefined` if a key does not exist', async () => {\n        const id = 'foo';\n        const key = 'bar';\n\n        connector.schemas[id] = { type: 'object' };\n\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should remove a setting item","suites":["@jupyterlab/settingregistry","Settings","#remove()"],"updatePoint":{"line":979,"column":38},"line":979,"code":"      it('should remove a setting item', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        let saved = settings.get(key);\n        expect(saved.user).toBe(value);\n        await settings.remove(key);\n        saved = settings.get(key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should save user setting data","suites":["@jupyterlab/settingregistry","Settings","#save()"],"updatePoint":{"line":997,"column":39},"line":997,"code":"      it('should save user setting data', async () => {\n        const id = 'foo';\n        const one = 'one';\n        const two = 'two';\n\n        connector.schemas[id] = { type: 'object' };\n        settings = (await registry.load(id)) as Settings;\n        await settings.save(JSON.stringify({ one, two }));\n        let saved = settings.get('one');\n        expect(saved.composite).toBe(one);\n        expect(saved.user).toBe(one);\n\n        saved = settings.get('two');\n\n        expect(saved.composite).toBe(two);\n        expect(saved.user).toBe(two);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should set a user setting item","suites":["@jupyterlab/settingregistry","Settings","#set()"],"updatePoint":{"line":1017,"column":40},"line":1017,"code":"      it('should set a user setting item', async () => {\n        const id = 'foo';\n        const one = 'one';\n\n        connector.schemas[id] = { type: 'object' };\n        settings = (await registry.load(id)) as Settings;\n        await settings.set('one', one);\n        const saved = settings.get('one');\n        expect(saved.composite).toBe(one);\n        expect(saved.user).toBe(one);\n      });","file":"settingregistry.spec.ts","skipped":false,"dir":"packages/settingregistry/test"},{"name":"should create a notebook","suites":["@jupyterlab/shared-models","ynotebook"],"updatePoint":{"line":8,"column":32},"line":8,"code":"    it('should create a notebook', () => {\n      const notebook = YNotebook.create(false);\n      expect(notebook.cells.length).toBe(0);\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should update metadata","suites":["@jupyterlab/shared-models","ynotebook metadata"],"updatePoint":{"line":15,"column":30},"line":15,"code":"    it('should update metadata', () => {\n      const notebook = YNotebook.create(false);\n      const metadata = notebook.getMetadata();\n      expect(metadata).toBeTruthy();\n      metadata.orig_nbformat = 1;\n      metadata.kernelspec = {\n        display_name: 'python',\n        name: 'python'\n      };\n      notebook.setMetadata(metadata);\n      {\n        const metadata = notebook.getMetadata();\n        expect(metadata.kernelspec!.name).toBe('python');\n        expect(metadata.orig_nbformat).toBe(1);\n      }\n      notebook.updateMetadata({\n        orig_nbformat: 2\n      });\n      {\n        const metadata = notebook.getMetadata();\n        expect(metadata.kernelspec!.name).toBe('python');\n        expect(metadata.orig_nbformat).toBe(2);\n      }\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should insert a cell","suites":["@jupyterlab/shared-models","ycell shared"],"updatePoint":{"line":42,"column":28},"line":42,"code":"    it('should insert a cell', () => {\n      const notebook = YNotebook.create(false);\n      const codeCell = YCodeCell.create();\n      notebook.insertCell(0, codeCell);\n      expect(notebook.cells.length).toBe(1);\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should set cell source","suites":["@jupyterlab/shared-models","ycell shared"],"updatePoint":{"line":48,"column":30},"line":48,"code":"    it('should set cell source', () => {\n      const notebook = YNotebook.create(false);\n      const codeCell = YCodeCell.create();\n      notebook.insertCell(0, codeCell);\n      codeCell.setSource('test');\n      expect(notebook.cells[0].getSource()).toBe('test');\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should update source","suites":["@jupyterlab/shared-models","ycell shared"],"updatePoint":{"line":55,"column":28},"line":55,"code":"    it('should update source', () => {\n      const notebook = YNotebook.create(false);\n      const codeCell = YCodeCell.create();\n      notebook.insertCell(0, codeCell);\n      codeCell.setSource('test');\n      codeCell.updateSource(0, 0, 'hello');\n      expect(codeCell.getSource()).toBe('hellotest');\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should not insert a standalone cell","suites":["@jupyterlab/shared-models","ycell standalone"],"updatePoint":{"line":66,"column":43},"line":66,"code":"    it('should not insert a standalone cell', () => {\n      const notebook = YNotebook.create(false);\n      const codeCell = YCodeCell.createStandalone();\n      let failed = false;\n      try {\n        notebook.insertCell(0, codeCell);\n      } catch (error) {\n        failed = true;\n      }\n      expect(failed).toBe(true);\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should set source","suites":["@jupyterlab/shared-models","ycell standalone"],"updatePoint":{"line":77,"column":25},"line":77,"code":"    it('should set source', () => {\n      const codeCell = YCodeCell.createStandalone();\n      codeCell.setSource('test');\n      expect(codeCell.getSource()).toBe('test');\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should update source","suites":["@jupyterlab/shared-models","ycell standalone"],"updatePoint":{"line":82,"column":28},"line":82,"code":"    it('should update source', () => {\n      const codeCell = YCodeCell.createStandalone();\n      codeCell.setSource('test');\n      codeCell.updateSource(0, 0, 'hello');\n      expect(codeCell.getSource()).toBe('hellotest');\n    });","file":"ymodels.spec.ts","skipped":false,"dir":"packages/shared-models/test"},{"name":"should create a RestorablePool","suites":["@jupyterlab/coreutils","RestorablePool","#constructor()"],"updatePoint":{"line":50,"column":40},"line":50,"code":"      it('should create a RestorablePool', () => {\n        expect(pool).toBeInstanceOf(RestorablePool);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should emit when an instance has been added","suites":["@jupyterlab/coreutils","RestorablePool","#added"],"updatePoint":{"line":56,"column":53},"line":56,"code":"      it('should emit when an instance has been added', async () => {\n        const instance = new ObservableDisposable();\n        const promise = signalToPromise(pool.added);\n        await pool.add(instance);\n        const [sender, args] = await promise;\n        expect(sender).toBe(pool);\n        expect(args).toBe(instance);\n        instance.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should default to null","suites":["@jupyterlab/coreutils","RestorablePool","#current"],"updatePoint":{"line":67,"column":32},"line":67,"code":"      it('should default to null', () => {\n        expect(pool.current).toBeNull();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should be settable by client code","suites":["@jupyterlab/coreutils","RestorablePool","#current"],"updatePoint":{"line":71,"column":43},"line":71,"code":"      it('should be settable by client code', async () => {\n        const instance = new ObservableDisposable();\n        void pool.add(instance);\n        expect(pool.current).toBe(null);\n        pool.current = instance;\n        expect(pool.current).toBe(instance);\n        instance.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should be a no-op if set to an untracked instance","suites":["@jupyterlab/coreutils","RestorablePool","#current"],"updatePoint":{"line":80,"column":59},"line":80,"code":"      it('should be a no-op if set to an untracked instance', async () => {\n        const instance = new ObservableDisposable();\n        expect(pool.current).toBe(null);\n        pool.current = instance;\n        expect(pool.current).toBe(null);\n        instance.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should emit when the current object has been updated","suites":["@jupyterlab/coreutils","RestorablePool","#currentChanged"],"updatePoint":{"line":100,"column":62},"line":100,"code":"      it('should emit when the current object has been updated', async () => {\n        const promise = signalToPromise(pool.currentChanged);\n        void pool.add(instance);\n        pool.current = instance;\n        await expect(promise).resolves.not.toThrow();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should test whether the pool is disposed","suites":["@jupyterlab/coreutils","RestorablePool","#isDisposed"],"updatePoint":{"line":109,"column":50},"line":109,"code":"      it('should test whether the pool is disposed', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should add an instance to the pool","suites":["@jupyterlab/coreutils","RestorablePool","#add()"],"updatePoint":{"line":117,"column":44},"line":117,"code":"      it('should add an instance to the pool', async () => {\n        const instance = new ObservableDisposable();\n        expect(pool.has(instance)).toBe(false);\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should reject an instance that already exists","suites":["@jupyterlab/coreutils","RestorablePool","#add()"],"updatePoint":{"line":124,"column":55},"line":124,"code":"      it('should reject an instance that already exists', async () => {\n        const instance = new ObservableDisposable();\n        let failed = false;\n        expect(pool.has(instance)).toBe(false);\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n        try {\n          await pool.add(instance);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should reject an instance that is disposed","suites":["@jupyterlab/coreutils","RestorablePool","#add()"],"updatePoint":{"line":138,"column":52},"line":138,"code":"      it('should reject an instance that is disposed', async () => {\n        const instance = new ObservableDisposable();\n        let failed = false;\n        expect(pool.has(instance)).toBe(false);\n        instance.dispose();\n        try {\n          await pool.add(instance);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should remove an added instance if it is disposed","suites":["@jupyterlab/coreutils","RestorablePool","#add()"],"updatePoint":{"line":151,"column":59},"line":151,"code":"      it('should remove an added instance if it is disposed', async () => {\n        const instance = new ObservableDisposable();\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n        instance.dispose();\n        expect(pool.has(instance)).toBe(false);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should dispose of the resources used by the pool","suites":["@jupyterlab/coreutils","RestorablePool","#dispose()"],"updatePoint":{"line":161,"column":58},"line":161,"code":"      it('should dispose of the resources used by the pool', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should be safe to call multiple times","suites":["@jupyterlab/coreutils","RestorablePool","#dispose()"],"updatePoint":{"line":167,"column":47},"line":167,"code":"      it('should be safe to call multiple times', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should find a tracked item that matches a filter function","suites":["@jupyterlab/coreutils","RestorablePool","#find()"],"updatePoint":{"line":176,"column":67},"line":176,"code":"      it('should find a tracked item that matches a filter function', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.find(obj => obj.id === 'B')).toBe(instanceB);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should return a void if no item is found","suites":["@jupyterlab/coreutils","RestorablePool","#find()"],"updatePoint":{"line":189,"column":50},"line":189,"code":"      it('should return a void if no item is found', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.find(widget => widget.id === 'D')).toBeFalsy();\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should filter according to a predicate function","suites":["@jupyterlab/coreutils","RestorablePool","#filter()"],"updatePoint":{"line":204,"column":57},"line":204,"code":"      it('should filter according to a predicate function', () => {\n        const instanceA = new ObservableDisposable('include-A');\n        const instanceB = new ObservableDisposable('include-B');\n        const instanceC = new ObservableDisposable('exclude-C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        const list = pool.filter(obj => obj.id.indexOf('include') !== -1);\n        expect(list.length).toBe(2);\n        expect(list[0]).toBe(instanceA);\n        expect(list[1]).toBe(instanceB);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should return an empty array if no item is found","suites":["@jupyterlab/coreutils","RestorablePool","#filter()"],"updatePoint":{"line":220,"column":58},"line":220,"code":"      it('should return an empty array if no item is found', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.filter(widget => widget.id === 'D').length).toBe(0);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should iterate through all the tracked items","suites":["@jupyterlab/coreutils","RestorablePool","#forEach()"],"updatePoint":{"line":235,"column":54},"line":235,"code":"      it('should iterate through all the tracked items', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        let visited = '';\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        pool.forEach(obj => {\n          visited += obj.id;\n        });\n        expect(visited).toBe('ABC');\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should return `true` if an item exists in the pool","suites":["@jupyterlab/coreutils","RestorablePool","#has()"],"updatePoint":{"line":251,"column":60},"line":251,"code":"      it('should return `true` if an item exists in the pool', () => {\n        const instance = new ObservableDisposable();\n        expect(pool.has(instance)).toBe(false);\n        void pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n      });","file":"restorablepool.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should create a state database","suites":["StateDB","#constructor()"],"updatePoint":{"line":9,"column":38},"line":9,"code":"    it('should create a state database', () => {\n      const db = new StateDB();\n      expect(db).toBeInstanceOf(StateDB);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should allow an overwrite data transformation","suites":["StateDB","#constructor()"],"updatePoint":{"line":14,"column":53},"line":14,"code":"    it('should allow an overwrite data transformation', async () => {\n      const connector = new StateDB.Connector();\n      const key = 'foo';\n      const correct = 'bar';\n      const incorrect = 'baz';\n\n      expect(await connector.fetch(key)).toBeUndefined();\n      await connector.save(key, `{ \"v\": \"${incorrect}\"}`);\n      expect(JSON.parse(await connector.fetch(key)).v).toBe(incorrect);\n\n      const transform = new PromiseDelegate<StateDB.DataTransform>();\n      const db = new StateDB({ connector, transform: transform.promise });\n      const transformation: StateDB.DataTransform = {\n        type: 'overwrite',\n        contents: { [key]: correct }\n      };\n\n      transform.resolve(transformation);\n      await transform.promise;\n      expect(await db.fetch(key)).toBe(correct);\n      expect(JSON.parse(await connector.fetch(key)).v).toBe(correct);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should allow a merge data transformation","suites":["StateDB","#constructor()"],"updatePoint":{"line":37,"column":48},"line":37,"code":"    it('should allow a merge data transformation', async () => {\n      const connector = new StateDB.Connector();\n      const k1 = 'foo';\n      const v1 = 'bar';\n      const k2 = 'baz';\n      const v2 = 'qux';\n\n      expect(await connector.fetch(k1)).toBeUndefined();\n      expect(await connector.fetch(k2)).toBeUndefined();\n      await connector.save(k1, `{ \"v\": \"${v1}\"}`);\n      expect(JSON.parse(await connector.fetch(k1)).v).toBe(v1);\n\n      const transform = new PromiseDelegate<StateDB.DataTransform>();\n      const db = new StateDB({ connector, transform: transform.promise });\n      const transformation: StateDB.DataTransform = {\n        type: 'merge',\n        contents: { [k2]: v2 }\n      };\n\n      transform.resolve(transformation);\n      await transform.promise;\n      expect(await db.fetch(k1)).toBe(v1);\n      expect(await db.fetch(k2)).toBe(v2);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should emit changes when the database is updated","suites":["StateDB","#changed"],"updatePoint":{"line":64,"column":56},"line":64,"code":"    it('should emit changes when the database is updated', async () => {\n      const db = new StateDB();\n      const changes: StateDB.Change[] = [\n        { id: 'foo', type: 'save' },\n        { id: 'foo', type: 'remove' },\n        { id: 'bar', type: 'save' },\n        { id: 'bar', type: 'remove' }\n      ];\n      const recorded: StateDB.Change[] = [];\n\n      db.changed.connect((_, change) => {\n        recorded.push(change);\n      });\n\n      await db.save('foo', 0);\n      await db.remove('foo');\n      await db.save('bar', 1);\n      await db.remove('bar');\n      expect(recorded).toEqual(changes);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should empty the items in a state database","suites":["StateDB","#clear()"],"updatePoint":{"line":87,"column":50},"line":87,"code":"    it('should empty the items in a state database', async () => {\n      const connector = new StateDB.Connector();\n      const db = new StateDB({ connector });\n\n      expect((await connector.list()).ids).toHaveLength(0);\n      await db.save('foo', 'bar');\n      expect((await connector.list()).ids).toHaveLength(1);\n      await db.clear();\n      expect((await connector.list()).ids).toHaveLength(0);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should fetch a stored key","suites":["StateDB","#fetch()"],"updatePoint":{"line":100,"column":33},"line":100,"code":"    it('should fetch a stored key', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      expect(await db.fetch(key)).toBeUndefined();\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should fetch a stored namespace","suites":["StateDB","#list()"],"updatePoint":{"line":112,"column":39},"line":112,"code":"    it('should fetch a stored namespace', async () => {\n      const db = new StateDB();\n      const keys = [\n        'foo:bar',\n        'foo:baz',\n        'foo:qux',\n        'abc:def',\n        'abc:ghi',\n        'abc:jkl',\n        'foo-two:bar',\n        'foo-two:baz',\n        'foo-two:qux'\n      ];\n\n      await Promise.all(keys.map(key => db.save(key, { value: key })));\n\n      let fetched = await db.list('foo');\n      expect(fetched.ids.length).toBe(3);\n      expect(fetched.values.length).toBe(3);\n\n      let sorted = fetched.ids.sort((a, b) => a.localeCompare(b));\n      expect(sorted[0]).toBe(keys[0]);\n      expect(sorted[1]).toBe(keys[1]);\n      expect(sorted[2]).toBe(keys[2]);\n\n      fetched = await db.list('abc');\n      expect(fetched.ids.length).toBe(3);\n      expect(fetched.values.length).toBe(3);\n\n      sorted = fetched.ids.sort((a, b) => a.localeCompare(b));\n      expect(sorted[0]).toBe(keys[3]);\n      expect(sorted[1]).toBe(keys[4]);\n      expect(sorted[2]).toBe(keys[5]);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should remove a stored key","suites":["StateDB","#remove()"],"updatePoint":{"line":149,"column":34},"line":149,"code":"    it('should remove a stored key', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      expect(await db.fetch(key)).toBeUndefined();\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n      await db.remove(key);\n      expect(await db.fetch(key)).toBeUndefined();\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should save a key and a value","suites":["StateDB","#save()"],"updatePoint":{"line":163,"column":37},"line":163,"code":"    it('should save a key and a value', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"return the full contents of a state database","suites":["StateDB","#toJSON()"],"updatePoint":{"line":174,"column":52},"line":174,"code":"    it('return the full contents of a state database', async () => {\n      const db = new StateDB();\n      const contents: ReadonlyJSONObject = {\n        abc: 'def',\n        ghi: 'jkl',\n        mno: 1,\n        pqr: {\n          foo: { bar: { baz: 'qux' } }\n        }\n      };\n\n      await Promise.all(\n        Object.keys(contents).map(key => db.save(key, contents[key]))\n      );\n      const serialized = await db.toJSON();\n      expect(serialized).toEqual(contents);\n    });","file":"statedb.spec.ts","skipped":false,"dir":"packages/statedb/test"},{"name":"should construct a new status bar","suites":["@jupyterlab/statusbar","StatusBar","#constructor()"],"updatePoint":{"line":23,"column":43},"line":23,"code":"      it('should construct a new status bar', () => {\n        const statusBar = new StatusBar();\n        expect(statusBar).toBeInstanceOf(StatusBar);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should add a new status item to the status bar","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":30,"column":56},"line":30,"code":"      it('should add a new status item to the status bar', () => {\n        const item = new Widget();\n        expect(item.isAttached).toBe(false);\n        statusBar.registerStatusItem('item', { item });\n        expect(item.isAttached).toBe(true);\n        expect(statusBar.contains(item)).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should raise an error if the same key is added twice","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":38,"column":62},"line":38,"code":"      it('should raise an error if the same key is added twice', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item', { item: item1 });\n        expect(\n          statusBar.registerStatusItem.bind(statusBar, 'item', { item: item2 })\n        ).toThrowError();\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should put higher rank left items closer to the middle","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":47,"column":64},"line":47,"code":"      it('should put higher rank left items closer to the middle', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item1', {\n          item: item1,\n          align: 'left',\n          rank: 1\n        });\n        statusBar.registerStatusItem('item2', {\n          item: item2,\n          align: 'left',\n          rank: 0\n        });\n        expect(item2.node.nextSibling).toBe(item1.node);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should put higher rank right items closer to the middle","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":63,"column":65},"line":63,"code":"      it('should put higher rank right items closer to the middle', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item1', {\n          item: item1,\n          align: 'right',\n          rank: 0\n        });\n        statusBar.registerStatusItem('item2', {\n          item: item2,\n          align: 'right',\n          rank: 1\n        });\n        // Reverse order than what one might expect, as right-to-left\n        // is set in the styling of the right panel.\n        expect(item1.node.nextSibling).toBe(item2.node);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should allow insertion of status items in the middle","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":81,"column":62},"line":81,"code":"      it('should allow insertion of status items in the middle', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', {\n          item: item,\n          align: 'middle'\n        });\n        expect(item.isAttached).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should only show if isActive returns true","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":90,"column":51},"line":90,"code":"      it('should only show if isActive returns true', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', {\n          item,\n          isActive: () => false\n        });\n        expect(item.isHidden).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should update whether it is shown if activeStateChanged fires","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":99,"column":71},"line":99,"code":"      it('should update whether it is shown if activeStateChanged fires', () => {\n        const item = new Widget();\n        let active = false;\n        const isActive = () => active;\n        const activeStateChanged = new Signal<any, void>({});\n        statusBar.registerStatusItem('item', {\n          item,\n          isActive,\n          activeStateChanged\n        });\n        expect(item.isHidden).toBe(true);\n        active = true;\n        activeStateChanged.emit(void 0);\n        expect(item.isHidden).toBe(false);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should be removed from the status bar if disposed","suites":["@jupyterlab/statusbar","StatusBar","#registerStatusItem"],"updatePoint":{"line":115,"column":59},"line":115,"code":"      it('should be removed from the status bar if disposed', () => {\n        const item = new Widget();\n        const disposable = statusBar.registerStatusItem('item', { item });\n        expect(item.isVisible).toBe(true);\n        disposable.dispose();\n        expect(item.isVisible).toBe(false);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should dispose of the status bar","suites":["@jupyterlab/statusbar","StatusBar","#dispose"],"updatePoint":{"line":125,"column":42},"line":125,"code":"      it('should dispose of the status bar', () => {\n        expect(statusBar.isDisposed).toBe(false);\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should be safe to call more than once","suites":["@jupyterlab/statusbar","StatusBar","#dispose"],"updatePoint":{"line":131,"column":47},"line":131,"code":"      it('should be safe to call more than once', () => {\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should dispose of the status items added to it","suites":["@jupyterlab/statusbar","StatusBar","#dispose"],"updatePoint":{"line":138,"column":56},"line":138,"code":"      it('should dispose of the status items added to it', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', { item });\n        expect(item.isDisposed).toBe(false);\n        statusBar.dispose();\n        expect(item.isDisposed).toBe(true);\n      });","file":"statusbar.spec.ts","skipped":false,"dir":"packages/statusbar/test"},{"name":"should create a terminal widget","suites":["terminal/index","Terminal","#constructor()"],"updatePoint":{"line":80,"column":41},"line":80,"code":"      it('should create a terminal widget', () => {\n        expect(widget).toBeInstanceOf(Terminal);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should be the constructor value","suites":["terminal/index","Terminal","#session"],"updatePoint":{"line":86,"column":41},"line":86,"code":"      it('should be the constructor value', () => {\n        expect(widget.session).toBe(session);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should set the title when ready","suites":["terminal/index","Terminal","#session"],"updatePoint":{"line":90,"column":41},"line":90,"code":"      it('should set the title when ready', async () => {\n        if (session.connectionStatus !== 'connected') {\n          await testEmission(session.connectionStatusChanged, {\n            find: (_, status) => status === 'connected'\n          });\n        }\n        expect(widget.title.label).toContain(session.name);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should be 13 by default","suites":["terminal/index","Terminal","#fontSize"],"updatePoint":{"line":101,"column":33},"line":101,"code":"      it('should be 13 by default', () => {\n        expect(widget.getOption('fontSize')).toBe(13);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should trigger an update request","suites":["terminal/index","Terminal","#fontSize"],"updatePoint":{"line":105,"column":42},"line":105,"code":"      it('should trigger an update request', async () => {\n        widget.setOption('fontSize', 14);\n        expect(widget.getOption('fontSize')).toBe(14);\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should be 1000 by default","suites":["terminal/index","Terminal","#scrollback"],"updatePoint":{"line":114,"column":35},"line":114,"code":"      it('should be 1000 by default', () => {\n        expect(widget.getOption('scrollback')).toBe(1000);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should be set to inherit by default","suites":["terminal/index","Terminal","#theme"],"updatePoint":{"line":120,"column":45},"line":120,"code":"      it('should be set to inherit by default', () => {\n        expect(widget.getOption('theme')).toBe('inherit');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should be light if we change it","suites":["terminal/index","Terminal","#theme"],"updatePoint":{"line":124,"column":41},"line":124,"code":"      it('should be light if we change it', () => {\n        widget.setOption('theme', 'light');\n        expect(widget.getOption('theme')).toBe('light');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should dispose of the resources used by the widget","suites":["terminal/index","Terminal","#dispose()"],"updatePoint":{"line":131,"column":60},"line":131,"code":"      it('should dispose of the resources used by the widget', () => {\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should refresh the widget","suites":["terminal/index","Terminal","#refresh()"],"updatePoint":{"line":141,"column":35},"line":141,"code":"      it('should refresh the widget', async () => {\n        await expect(widget.refresh()).resolves.not.toThrow();\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should handle fit requests","suites":["terminal/index","Terminal","#processMessage()"],"updatePoint":{"line":147,"column":36},"line":147,"code":"      it('should handle fit requests', () => {\n        widget.processMessage(Widget.Msg.FitRequest);\n        expect(widget.methods).toContain('onFitRequest');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should post an update request","suites":["terminal/index","Terminal","#onAfterAttach()"],"updatePoint":{"line":154,"column":39},"line":154,"code":"      it('should post an update request', async () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should post an update request","suites":["terminal/index","Terminal","#onAfterShow()"],"updatePoint":{"line":163,"column":39},"line":163,"code":"      it('should post an update request', async () => {\n        widget.hide();\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        widget.methods = [];\n        widget.show();\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should trigger an update request","suites":["terminal/index","Terminal","#onResize()"],"updatePoint":{"line":176,"column":42},"line":176,"code":"      it('should trigger an update request', async () => {\n        const msg = Widget.ResizeMessage.UnknownSize;\n        MessageLoop.sendMessage(widget, msg);\n        expect(widget.methods).toContain('onResize');\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should attach the terminal","suites":["terminal/index","Terminal","#onUpdateRequest()"],"updatePoint":{"line":186,"column":36},"line":186,"code":"      it('should attach the terminal', () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n        expect(widget.node.firstElementChild!.classList).toContain(\n          'jp-Terminal-body'\n        );\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should send a resize request","suites":["terminal/index","Terminal","#onFitRequest"],"updatePoint":{"line":198,"column":38},"line":198,"code":"      it('should send a resize request', () => {\n        MessageLoop.sendMessage(widget, Widget.Msg.FitRequest);\n        expect(widget.methods).toContain('onResize');\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should focus the terminal element","suites":["terminal/index","Terminal","#onActivateRequest"],"updatePoint":{"line":205,"column":43},"line":205,"code":"      it('should focus the terminal element', () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        expect(widget.node.contains(document.activeElement)).toBe(false);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toContain('onActivateRequest');\n        expect(widget.node.contains(document.activeElement)).toBe(true);\n      });","file":"terminal.spec.ts","skipped":false,"dir":"packages/terminal/test"},{"name":"should construct a new ToC widget","suites":["@jupyterlab/toc","TableOfContents","#constructor"],"updatePoint":{"line":96,"column":43},"line":96,"code":"      it('should construct a new ToC widget', () => {\n        tocWidget = new ToC.TableOfContents({\n          docmanager: manager,\n          rendermime: new RenderMimeRegistry()\n        });\n        expect(tocWidget).toBeInstanceOf(ToC.TableOfContents);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should create a notebook generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Notebook Generator: IGenerator<NotebookPanel>"],"updatePoint":{"line":118,"column":44},"line":118,"code":"      it('should create a notebook generator', () => {\n        notebookTracker = new NotebookTracker({\n          namespace: 'notebook'\n        });\n        expect(() => {\n          notebookGenerator = ToC.createNotebookGenerator(\n            notebookTracker,\n            tocWidget,\n            NBTestUtils.defaultRenderMime().sanitizer\n          );\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should add a notebook generator to the registry","suites":["@jupyterlab/toc","TableOfContentsRegistry","Notebook Generator: IGenerator<NotebookPanel>"],"updatePoint":{"line":131,"column":57},"line":131,"code":"      it('should add a notebook generator to the registry', () => {\n        expect(() => {\n          registry.add(notebookGenerator);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should find the notebook generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Notebook Generator: IGenerator<NotebookPanel>"],"updatePoint":{"line":137,"column":44},"line":137,"code":"      it('should find the notebook generator', async () => {\n        const path = UUID.uuid4() + '.ipynb';\n        const newNotebookWidget = manager.createNew(path, 'notebook');\n        expect(newNotebookWidget).toBeInstanceOf(NotebookPanel);\n        notebookWidget = newNotebookWidget as NotebookPanel;\n        await notebookTracker.add(notebookWidget);\n        const foundNotebookGenerator = registry.find(notebookWidget);\n        expect(foundNotebookGenerator).toBeDefined();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should change current","suites":["@jupyterlab/toc","TableOfContentsRegistry","Notebook Generator: IGenerator<NotebookPanel>"],"updatePoint":{"line":147,"column":31},"line":147,"code":"      it('should change current', async () => {\n        tocWidget.current = {\n          widget: notebookWidget,\n          generator: notebookGenerator\n        };\n        expect(tocWidget.current.widget).toBeInstanceOf(NotebookPanel);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should create a markdown generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Markdown Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":163,"column":44},"line":163,"code":"      it('should create a markdown generator', () => {\n        markdownTracker = new WidgetTracker<IDocumentWidget<FileEditor>>({\n          namespace: 'markdown'\n        });\n        expect(() => {\n          markdownGenerator = ToC.createMarkdownGenerator(\n            markdownTracker,\n            tocWidget,\n            NBTestUtils.defaultRenderMime().sanitizer\n          );\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should add a markdown generator to the registry","suites":["@jupyterlab/toc","TableOfContentsRegistry","Markdown Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":176,"column":57},"line":176,"code":"      it('should add a markdown generator to the registry', () => {\n        expect(() => {\n          registry.add(markdownGenerator);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should find the markdown generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Markdown Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":182,"column":44},"line":182,"code":"      it('should find the markdown generator', async () => {\n        const path = UUID.uuid4() + '.md';\n        const newMarkdownWidget = manager.createNew(path);\n        expect(newMarkdownWidget).toBeInstanceOf(DocumentWidget);\n        markdownWidget = newMarkdownWidget as IDocumentWidget<FileEditor>;\n        await markdownTracker.add(markdownWidget);\n        const foundMarkdownGenerator = registry.find(markdownWidget);\n        expect(foundMarkdownGenerator).toBeDefined();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should change current","suites":["@jupyterlab/toc","TableOfContentsRegistry","Markdown Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":192,"column":31},"line":192,"code":"      it('should change current', async () => {\n        tocWidget.current = {\n          widget: markdownWidget,\n          generator: markdownGenerator\n        };\n        expect(tocWidget.current.widget).toBeInstanceOf(DocumentWidget);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should create a markdown generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Rendered Markdown Generator: IGenerator<MarkdownDocument>"],"updatePoint":{"line":206,"column":44},"line":206,"code":"      it('should create a markdown generator', () => {\n        markdownTracker = new WidgetTracker<MarkdownDocument>({\n          namespace: 'markdownviewer-widget'\n        });\n        expect(() => {\n          markdownGenerator = ToC.createRenderedMarkdownGenerator(\n            markdownTracker,\n            tocWidget,\n            NBTestUtils.defaultRenderMime().sanitizer\n          );\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should add a markdown generator to the registry","suites":["@jupyterlab/toc","TableOfContentsRegistry","Rendered Markdown Generator: IGenerator<MarkdownDocument>"],"updatePoint":{"line":219,"column":57},"line":219,"code":"      it('should add a markdown generator to the registry', () => {\n        expect(() => {\n          registry.add(markdownGenerator);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should find the markdown generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Rendered Markdown Generator: IGenerator<MarkdownDocument>"],"updatePoint":{"line":225,"column":44},"line":225,"code":"      it('should find the markdown generator', async () => {\n        const path = UUID.uuid4() + '.md';\n        const newMarkdownWidget = manager.createNew(path, 'Markdown Preview');\n        expect(newMarkdownWidget).toBeInstanceOf(MarkdownDocument);\n        markdownWidget = newMarkdownWidget as MarkdownDocument;\n        await markdownTracker.add(markdownWidget);\n        const foundMarkdownGenerator = registry.find(markdownWidget);\n        expect(foundMarkdownGenerator).toBeDefined();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should change current","suites":["@jupyterlab/toc","TableOfContentsRegistry","Rendered Markdown Generator: IGenerator<MarkdownDocument>"],"updatePoint":{"line":235,"column":31},"line":235,"code":"      it('should change current', async () => {\n        tocWidget.current = {\n          widget: markdownWidget,\n          generator: markdownGenerator\n        };\n        expect(tocWidget.current.widget).toBeInstanceOf(MarkdownDocument);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should create a latex generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Latex Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":251,"column":41},"line":251,"code":"      it('should create a latex generator', () => {\n        latexTracker = new WidgetTracker<IDocumentWidget<FileEditor>>({\n          namespace: 'latex'\n        });\n        expect(() => {\n          latexGenerator = ToC.createLatexGenerator(latexTracker);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should add a latex generator to the registry","suites":["@jupyterlab/toc","TableOfContentsRegistry","Latex Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":260,"column":54},"line":260,"code":"      it('should add a latex generator to the registry', () => {\n        expect(() => {\n          registry.add(latexGenerator);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should find the latex generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Latex Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":266,"column":41},"line":266,"code":"      it('should find the latex generator', async () => {\n        const path = UUID.uuid4() + '.tex';\n        const newLatexWidget = manager.createNew(path);\n        expect(newLatexWidget).toBeInstanceOf(DocumentWidget);\n        latexWidget = newLatexWidget as IDocumentWidget<FileEditor>;\n        await latexTracker.add(latexWidget);\n        const foundLatexGenerator = registry.find(latexWidget);\n        expect(foundLatexGenerator).toBeDefined();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should change current","suites":["@jupyterlab/toc","TableOfContentsRegistry","Latex Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":276,"column":31},"line":276,"code":"      it('should change current', async () => {\n        tocWidget.current = {\n          widget: latexWidget,\n          generator: latexGenerator\n        };\n        expect(tocWidget.current.widget).toBeInstanceOf(DocumentWidget);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should create a python generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Python Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":292,"column":42},"line":292,"code":"      it('should create a python generator', () => {\n        pythonTracker = new WidgetTracker<IDocumentWidget<FileEditor>>({\n          namespace: 'python'\n        });\n        expect(() => {\n          pythonGenerator = ToC.createPythonGenerator(pythonTracker);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should add a python generator to the registry","suites":["@jupyterlab/toc","TableOfContentsRegistry","Python Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":301,"column":55},"line":301,"code":"      it('should add a python generator to the registry', () => {\n        expect(() => {\n          registry.add(pythonGenerator);\n        }).not.toThrow();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should find the python generator","suites":["@jupyterlab/toc","TableOfContentsRegistry","Python Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":307,"column":42},"line":307,"code":"      it('should find the python generator', async () => {\n        const path = UUID.uuid4() + '.py';\n        const newPythonWidget = manager.createNew(path);\n        expect(newPythonWidget).toBeInstanceOf(DocumentWidget);\n        pythonWidget = newPythonWidget as IDocumentWidget<FileEditor>;\n        await pythonTracker.add(pythonWidget);\n        const foundPythonGenerator = registry.find(pythonWidget);\n        expect(foundPythonGenerator).toBeDefined();\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should change current","suites":["@jupyterlab/toc","TableOfContentsRegistry","Python Generator: IGenerator<IDocumentWidget<FileEditor>>"],"updatePoint":{"line":317,"column":31},"line":317,"code":"      it('should change current', async () => {\n        tocWidget.current = {\n          widget: pythonWidget,\n          generator: pythonGenerator\n        };\n        expect(tocWidget.current.widget).toBeInstanceOf(DocumentWidget);\n      });","file":"toc.spec.ts","skipped":false,"dir":"packages/toc/test"},{"name":"should return the instance of the EmptyTranslator","suites":["@jupyterlab/translation","BasicTranslator","#getInstance"],"updatePoint":{"line":11,"column":59},"line":11,"code":"      it('should return the instance of the EmptyTranslator', () => {\n        expect(trans.gettext('Hello!')).toBe('Hello!');\n      });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the dummy bundle gettext/__ works","suites":["@jupyterlab/translation","BasicTranslator","#dummygettext"],"updatePoint":{"line":17,"column":63},"line":17,"code":"      it('should test whether the dummy bundle gettext/__ works', () => {\n        // Shorthand method\n        expect(trans.__('Hello!')).toBe('Hello!');\n        expect(trans.__('Hello %1!', 'Joe')).toBe('Hello Joe!');\n\n        // Normal method\n        expect(trans.gettext('Hello!')).toBe('Hello!');\n        expect(trans.gettext('Hello %1!', 'Joe')).toBe('Hello Joe!');\n      });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the dummy bundle pgettext/_p works","suites":["@jupyterlab/translation","BasicTranslator","#dummypgettext"],"updatePoint":{"line":29,"column":64},"line":29,"code":"      it('should test whether the dummy bundle pgettext/_p works', () => {\n        // Shorthand method\n        expect(trans._p('Some context', 'Hello!')).toBe('Hello!');\n        expect(trans._p('Some context', 'Hello %1!', 'Joe')).toBe('Hello Joe!');\n\n        // Normal method\n        expect(trans.pgettext('Some context', 'Hello!')).toBe('Hello!');\n        expect(trans.pgettext('Some context', 'Hello %1!', 'Joe')).toBe(\n          'Hello Joe!'\n        );\n      });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the dummy bundle ngettext/_n works","suites":["@jupyterlab/translation","BasicTranslator","#dummyngettext"],"updatePoint":{"line":43,"column":64},"line":43,"code":"      it('should test whether the dummy bundle ngettext/_n works', () => {\n        // Shorthand method\n        expect(trans._n('I have %1 apple', 'I have %1 apples', 1)).toBe(\n          'I have 1 apple'\n        );\n        expect(trans._n('I have %1 apple', 'I have %1 apples', 2)).toBe(\n          'I have 2 apples'\n        );\n        expect(\n          trans._n('I have %1 apple %2', 'I have %1 apples %2', 1, 'Joe')\n        ).toBe('I have 1 apple Joe');\n        expect(\n          trans._n('I have %1 apple %2', 'I have %1 apples %2', 2, 'Joe')\n        ).toBe('I have 2 apples Joe');\n\n        // Normal method\n        expect(trans.ngettext('I have %1 apple', 'I have %1 apples', 1)).toBe(\n          'I have 1 apple'\n        );\n        expect(trans.ngettext('I have %1 apple', 'I have %1 apples', 2)).toBe(\n          'I have 2 apples'\n        );\n        expect(\n          trans.ngettext('I have %1 apple %2', 'I have %1 apples %2', 1, 'Joe')\n        ).toBe('I have 1 apple Joe');\n        expect(\n          trans.ngettext('I have %1 apple %2', 'I have %1 apples %2', 2, 'Joe')\n        ).toBe('I have 2 apples Joe');\n      });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the dummy bundle npgettext/_np works","suites":["@jupyterlab/translation","BasicTranslator","#dummynpgettext"],"updatePoint":{"line":75,"column":66},"line":75,"code":"      it('should test whether the dummy bundle npgettext/_np works', () => {\n        // Shorthand method\n        expect(\n          trans._np('Some context', 'I have %1 apple', 'I have %1 apples', 1)\n        ).toBe('I have 1 apple');\n        expect(\n          trans._np('Some context', 'I have %1 apple', 'I have %1 apples', 2)\n        ).toBe('I have 2 apples');\n        expect(\n          trans._np(\n            'Some context',\n            'I have %1 apple %2',\n            'I have %1 apples %2',\n            1,\n            'Joe'\n          )\n        ).toBe('I have 1 apple Joe');\n        expect(\n          trans._np(\n            'Some context',\n            'I have %1 apple %2',\n            'I have %1 apples %2',\n            2,\n            'Joe'\n          )\n        ).toBe('I have 2 apples Joe');\n\n        // Normal method\n        expect(\n          trans.npgettext(\n            'Some context',\n            'I have %1 apple',\n            'I have %1 apples',\n            1\n          )\n        ).toBe('I have 1 apple');\n        expect(\n          trans.npgettext(\n            'Some context',\n            'I have %1 apple',\n            'I have %1 apples',\n            2\n          )\n        ).toBe('I have 2 apples');\n        expect(\n          trans.npgettext(\n            'Some context',\n            'I have %1 apple %2',\n            'I have %1 apples %2',\n            1,\n            'Joe'\n          )\n        ).toBe('I have 1 apple Joe');\n        expect(\n          trans.npgettext(\n            'Some context',\n            'I have %1 apple %2',\n            'I have %1 apples %2',\n            2,\n            'Joe'\n          )\n        ).toBe('I have 2 apples Joe');\n      });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the dummy bundle dcnpgettext works","suites":["@jupyterlab/translation","#dummydcnpgettext"],"updatePoint":{"line":141,"column":62},"line":141,"code":"    it('should test whether the dummy bundle dcnpgettext works', () => {\n      expect(\n        trans.dcnpgettext(\n          'jupyterlab',\n          'Some context',\n          'I have %1 apple',\n          'I have %1 apples',\n          1\n        )\n      ).toBe('I have 1 apple');\n      expect(\n        trans.dcnpgettext(\n          'jupyterlab',\n          'Some context',\n          'I have %1 apple',\n          'I have %1 apples',\n          2\n        )\n      ).toBe('I have 2 apples');\n      expect(\n        trans.dcnpgettext(\n          'jupyterlab',\n          'Some context',\n          'I have %1 apple %2',\n          'I have %1 apples %2',\n          1,\n          'Joe'\n        )\n      ).toBe('I have 1 apple Joe');\n      expect(\n        trans.dcnpgettext(\n          'jupyterlab',\n          'Some context',\n          'I have %1 apple %2',\n          'I have %1 apples %2',\n          2,\n          'Joe'\n        )\n      ).toBe('I have 2 apples Joe');\n    });","file":"base.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the gettext bundle gettext/__ works","suites":["@jupyterlab/translation","Gettext","#gettext"],"updatePoint":{"line":37,"column":65},"line":37,"code":"      it('should test whether the gettext bundle gettext/__ works', () => {\n        // Shorthand method\n        expect(trans.__('Welcome')).toBe('Bienvenido');\n        expect(trans.__('Welcome %1', 'Joe')).toBe('Bienvenido Joe');\n\n        // Normal method\n        expect(trans.gettext('Welcome')).toBe('Bienvenido');\n        expect(trans.gettext('Welcome %1', 'Joe')).toBe('Bienvenido Joe');\n      });","file":"gettext.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the gettext  bundle pgettext/_p works","suites":["@jupyterlab/translation","Gettext","#pgettext"],"updatePoint":{"line":49,"column":67},"line":49,"code":"      it('should test whether the gettext  bundle pgettext/_p works', () => {\n        // Shorthand method\n        expect(trans._p('Context', 'Welcome')).toBe('Hola');\n        expect(trans._p('Context', 'Welcome %1', 'Joe')).toBe('Hola Joe');\n\n        // Normal method\n        expect(trans.pgettext('Context', 'Welcome')).toBe('Hola');\n        expect(trans.pgettext('Context', 'Welcome %1', 'Joe')).toBe('Hola Joe');\n      });","file":"gettext.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the gettext bundle ngettext/_n works","suites":["@jupyterlab/translation","Gettext","#ngettext"],"updatePoint":{"line":61,"column":66},"line":61,"code":"      it('should test whether the gettext bundle ngettext/_n works', () => {\n        // Shorthand method\n        expect(trans._n('There is %1 apple', 'There are %1 apples', 1)).toBe(\n          'Hay 1 manzana'\n        );\n        expect(trans._n('There is %1 apple', 'There are %1 apples', 2)).toBe(\n          'Hay 2 manzanas'\n        );\n        expect(\n          trans._n('There is %1 apple, %2!', 'I have %1 apples %2', 1, 'Joe')\n        ).toBe('Hay 1 manzana, Joe!');\n        expect(\n          trans._n('There is %1 apple, %2!', 'I have %1 apples %2', 2, 'Joe')\n        ).toBe('Hay 2 manzanas, Joe!');\n\n        // Normal method\n        expect(\n          trans.ngettext('There is %1 apple', 'There are %1 apples', 1)\n        ).toBe('Hay 1 manzana');\n        expect(\n          trans.ngettext('There is %1 apple', 'There are %1 apples', 2)\n        ).toBe('Hay 2 manzanas');\n        expect(\n          trans.ngettext(\n            'There is %1 apple, %2!',\n            'I have %1 apples %2',\n            1,\n            'Joe'\n          )\n        ).toBe('Hay 1 manzana, Joe!');\n        expect(\n          trans.ngettext(\n            'There is %1 apple, %2!',\n            'I have %1 apples %2',\n            2,\n            'Joe'\n          )\n        ).toBe('Hay 2 manzanas, Joe!');\n      });","file":"gettext.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should test whether the gettext  bundle pgettext/_p works","suites":["@jupyterlab/translation","Gettext","#fallbackLocale"],"updatePoint":{"line":103,"column":67},"line":103,"code":"      it('should test whether the gettext  bundle pgettext/_p works', () => {\n        trans.setLocale('es-CO');\n\n        // Shorthand method\n        expect(trans.__('Welcome')).toBe('Bienvenido pirobo');\n\n        // Normal method\n        expect(trans.gettext('Welcome')).toBe('Bienvenido pirobo');\n      });","file":"gettext.spec.ts","skipped":false,"dir":"packages/translation/test"},{"name":"should create a new iframe widget","suites":["@jupyterlab/ui-components","IFrame","#constructor()"],"updatePoint":{"line":9,"column":43},"line":9,"code":"      it('should create a new iframe widget', () => {\n        const iframe = new IFrame();\n        expect(iframe).toBeInstanceOf(IFrame);\n        expect(iframe.hasClass('jp-IFrame')).toBe(true);\n        expect(iframe.node.querySelector('iframe')).toBeTruthy();\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be sandboxed by default","suites":["@jupyterlab/ui-components","IFrame","#constructor()"],"updatePoint":{"line":16,"column":40},"line":16,"code":"      it('should be sandboxed by default', () => {\n        const iframe = new IFrame();\n        const node = iframe.node.querySelector('iframe')!;\n        expect(node.getAttribute('sandbox') !== null).toBe(true);\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be have a no-referrer policy by default","suites":["@jupyterlab/ui-components","IFrame","#constructor()"],"updatePoint":{"line":22,"column":56},"line":22,"code":"      it('should be have a no-referrer policy by default', () => {\n        const iframe = new IFrame();\n        const node = iframe.node.querySelector('iframe')!;\n        expect(node.getAttribute('referrerpolicy')).toBe('no-referrer');\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should allow sandboxing exceptions to be specified in the options","suites":["@jupyterlab/ui-components","IFrame","#constructor()"],"updatePoint":{"line":28,"column":75},"line":28,"code":"      it('should allow sandboxing exceptions to be specified in the options', () => {\n        const iframe = new IFrame({\n          sandbox: ['allow-scripts', 'allow-same-origin']\n        });\n        const node = iframe.node.querySelector('iframe')!;\n        expect(node.getAttribute('sandbox')).toBe(\n          'allow-scripts allow-same-origin'\n        );\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should allow the referrer policy to be specified in the options","suites":["@jupyterlab/ui-components","IFrame","#constructor()"],"updatePoint":{"line":38,"column":73},"line":38,"code":"      it('should allow the referrer policy to be specified in the options', () => {\n        const iframe = new IFrame({ referrerPolicy: 'unsafe-url' });\n        const node = iframe.node.querySelector('iframe')!;\n        expect(node.getAttribute('referrerpolicy')).toBe('unsafe-url');\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be the url of the iframe","suites":["@jupyterlab/ui-components","IFrame","#url"],"updatePoint":{"line":46,"column":41},"line":46,"code":"      it('should be the url of the iframe', () => {\n        const iframe = new IFrame();\n        expect(iframe.url).toBe('');\n        iframe.url = 'foo';\n        expect(iframe.url).toBe('foo');\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should set the referrer policy for the iframe.","suites":["@jupyterlab/ui-components","IFrame","#referrerPolicy"],"updatePoint":{"line":55,"column":56},"line":55,"code":"      it('should set the referrer policy for the iframe.', () => {\n        const iframe = new IFrame({ referrerPolicy: 'unsafe-url' });\n        const node = iframe.node.querySelector('iframe')!;\n        expect(iframe.referrerPolicy).toBe('unsafe-url');\n        iframe.referrerPolicy = 'origin';\n        expect(iframe.referrerPolicy).toBe('origin');\n        expect(node.getAttribute('referrerpolicy')).toBe('origin');\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should set the exceptions for the sandbox attribute.","suites":["@jupyterlab/ui-components","IFrame","#sandbox"],"updatePoint":{"line":66,"column":62},"line":66,"code":"      it('should set the exceptions for the sandbox attribute.', () => {\n        const iframe = new IFrame({\n          sandbox: ['allow-scripts', 'allow-same-origin']\n        });\n        const node = iframe.node.querySelector('iframe')!;\n        expect(iframe.sandbox).toEqual(['allow-scripts', 'allow-same-origin']);\n        iframe.sandbox = ['allow-pointer-lock'];\n        expect(iframe.sandbox).toEqual(['allow-pointer-lock']);\n        expect(node.getAttribute('sandbox')).toBe('allow-pointer-lock');\n      });","file":"iframe.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should hold a string with the raw contents of an svg","suites":["@jupyterlab/ui-components","svg import"],"updatePoint":{"line":19,"column":60},"line":19,"code":"    it('should hold a string with the raw contents of an svg', () => {\n      expect(\n        fooSvgstr.startsWith(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"`)\n      ).toBe(true);\n    });","file":"labicon.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should hold a string with the raw contents of an svg","suites":["@jupyterlab/ui-components","LabIcon","attribute .svgstr"],"updatePoint":{"line":28,"column":62},"line":28,"code":"      it('should hold a string with the raw contents of an svg', () => {\n        expect(\n          fooIcon.svgstr.startsWith(\n            `<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"`\n          )\n        ).toBe(true);\n      });","file":"labicon.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should return a disposable item","suites":["@jupyterlab/ui-components","IRankedMenu","#addItem"],"updatePoint":{"line":22,"column":41},"line":22,"code":"      it('should return a disposable item', () => {\n        const menu = new RankedMenu({ commands }) as IRankedMenu;\n\n        const item = menu.addItem({ command: id });\n\n        expect(menu.items.length).toEqual(1);\n\n        item.dispose();\n\n        expect(menu.items.length).toEqual(0);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should construct a new main menu","suites":["@jupyterlab/ui-components","RankedMenu","#constructor()"],"updatePoint":{"line":69,"column":42},"line":69,"code":"      it('should construct a new main menu', () => {\n        expect(menu).toBeInstanceOf(RankedMenu);\n        expect(menu).toBeInstanceOf(Menu);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should accept useSeparators as an option","suites":["@jupyterlab/ui-components","RankedMenu","#constructor()"],"updatePoint":{"line":74,"column":50},"line":74,"code":"      it('should accept useSeparators as an option', () => {\n        const menu1 = new RankedMenu({\n          commands,\n          includeSeparators: false\n        });\n        const menu2 = new RankedMenu({ commands, includeSeparators: true });\n        menu1.addGroup([{ command: 'run1' }, { command: 'run2' }]);\n        menu2.addGroup([{ command: 'run1' }, { command: 'run2' }]);\n\n        expect(menu1.items.length).toBe(2);\n        expect(menu2.items.length).toBe(4);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should accept rank as an option","suites":["@jupyterlab/ui-components","RankedMenu","#constructor()"],"updatePoint":{"line":87,"column":41},"line":87,"code":"      it('should accept rank as an option', () => {\n        const menu = new RankedMenu({ commands, rank: 22 });\n        expect(menu.rank).toEqual(22);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should have rank undefined by default","suites":["@jupyterlab/ui-components","RankedMenu","#constructor()"],"updatePoint":{"line":92,"column":47},"line":92,"code":"      it('should have rank undefined by default', () => {\n        const menu = new RankedMenu({ commands });\n        expect(menu.rank).toBeUndefined();\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should have a read-only rank","suites":["@jupyterlab/ui-components","RankedMenu","#rank"],"updatePoint":{"line":99,"column":38},"line":99,"code":"      it('should have a read-only rank', () => {\n        expect(() => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          menu.rank = 42;\n        }).toThrowError();\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add a new group to the menu","suites":["@jupyterlab/ui-components","RankedMenu","#addGroup()"],"updatePoint":{"line":109,"column":44},"line":109,"code":"      it('should add a new group to the menu', () => {\n        menu.addGroup([{ command: 'run1' }, { command: 'run2' }]);\n\n        const idx1 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run1'\n        );\n        const idx2 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run2'\n        );\n\n        expect(idx1 === -1).toBe(false);\n        expect(idx2 === -1).toBe(false);\n        expect(idx1 > idx2).toBe(false);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should take a rank as an option","suites":["@jupyterlab/ui-components","RankedMenu","#addGroup()"],"updatePoint":{"line":126,"column":41},"line":126,"code":"      it('should take a rank as an option', () => {\n        menu.addGroup([{ command: 'run1' }, { command: 'run2' }], 2);\n        menu.addGroup([{ command: 'run3' }, { command: 'run4' }], 1);\n\n        const idx1 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run1'\n        );\n        const idx2 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run2'\n        );\n        const idx3 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run3'\n        );\n        const idx4 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run4'\n        );\n        expect(idx3 < idx4).toBe(true);\n        expect(idx4 < idx1).toBe(true);\n        expect(idx1 < idx2).toBe(true);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should return a disposable that can be used to remove the group","suites":["@jupyterlab/ui-components","RankedMenu","#addGroup()"],"updatePoint":{"line":151,"column":73},"line":151,"code":"      it('should return a disposable that can be used to remove the group', () => {\n        const group1 = [{ command: 'run1' }, { command: 'run2' }];\n        const group2 = [{ command: 'run3' }, { command: 'run4' }];\n        const disposable = menu.addGroup(group1);\n        menu.addGroup(group2);\n        disposable.dispose();\n\n        const idx1 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run1'\n        );\n        const idx2 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run2'\n        );\n        const idx3 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run3'\n        );\n        const idx4 = ArrayExt.findFirstIndex(\n          menu.items,\n          m => m.command === 'run4'\n        );\n\n        expect(idx1).toBe(-1);\n        expect(idx2).toBe(-1);\n        expect(idx3 === -1).toBe(false);\n        expect(idx4 === -1).toBe(false);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should use the provided rank to position the item","suites":["@jupyterlab/ui-components","RankedMenu","#addItem()"],"updatePoint":{"line":183,"column":59},"line":183,"code":"      it('should use the provided rank to position the item', () => {\n        menu.addItem({ command: 'run1', rank: 1000 });\n        menu.addItem({ command: 'run2', rank: 10 });\n\n        expect(menu.getRankAt(0)).toEqual(10);\n        expect(menu.getRankAt(1)).toEqual(1000);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should append the item at the end if no rank is provided","suites":["@jupyterlab/ui-components","RankedMenu","#addItem()"],"updatePoint":{"line":191,"column":66},"line":191,"code":"      it('should append the item at the end if no rank is provided', () => {\n        menu.addItem({ command: 'run1', rank: 10 });\n\n        menu.addItem({ command: 'run3' });\n\n        expect(menu.items[1].command).toEqual('run3');\n        expect(menu.getRankAt(1)).toEqual(100);\n\n        menu.addItem({ command: 'run2', rank: 1000 });\n        // Set a rank to n-1 element if it is higher than the default\n\n        menu.addItem({ command: 'run4' });\n\n        expect(menu.items[3].command).toEqual('run4');\n        expect(menu.getRankAt(3)).toEqual(1000);\n      });","file":"menu.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should style descendant nodes for select, input and button","suites":["@jupyterlab/ui-components","Styling",".styleNode()"],"updatePoint":{"line":11,"column":68},"line":11,"code":"      it('should style descendant nodes for select, input and button', () => {\n        const vnode = h.div({}, [h.button(), h.select(), h.input()]);\n        const node = VirtualDOM.realize(vnode);\n        Styling.styleNode(node);\n        expect(node.querySelectorAll('.jp-mod-styled').length).toBe(3);\n      });","file":"styling.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should wrap a select node","suites":["@jupyterlab/ui-components","Styling",".styleNode()"],"updatePoint":{"line":18,"column":35},"line":18,"code":"      it('should wrap a select node', () => {\n        const parent = document.createElement('div');\n        const select = document.createElement('select');\n        parent.appendChild(select);\n        Styling.styleNode(parent);\n        const wrapper = parent.firstChild as HTMLElement;\n        expect(wrapper.className).toBe('jp-select-wrapper');\n        expect(select.parentElement).toBe(wrapper);\n        expect(select.className).toBe('jp-mod-styled');\n        document.body.appendChild(parent);\n        select.focus();\n        simulate(select, 'focus');\n        expect(wrapper.className).toContain('jp-mod-focused');\n        select.blur();\n        simulate(select, 'blur');\n        expect(wrapper.className).not.toContain('jp-mod-focused');\n        document.body.removeChild(parent);\n      });","file":"styling.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should style descendant nodes for the given tag","suites":["@jupyterlab/ui-components","Styling",".styleNodeByTag()"],"updatePoint":{"line":39,"column":57},"line":39,"code":"      it('should style descendant nodes for the given tag', () => {\n        const vnode = h.div({}, [h.span(), h.div({}, h.span())]);\n        const node = VirtualDOM.realize(vnode);\n        Styling.styleNodeByTag(node, 'span');\n        expect(node.querySelectorAll('.jp-mod-styled').length).toBe(2);\n      });","file":"styling.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should style the node itself","suites":["@jupyterlab/ui-components","Styling",".styleNodeByTag()"],"updatePoint":{"line":46,"column":38},"line":46,"code":"      it('should style the node itself', () => {\n        const div = document.createElement('div');\n        Styling.styleNodeByTag(div, 'div');\n        expect(div.className).toContain('jp-mod-styled');\n      });","file":"styling.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should wrap the select node","suites":["@jupyterlab/ui-components","Styling",".wrapSelect()"],"updatePoint":{"line":54,"column":37},"line":54,"code":"      it('should wrap the select node', () => {\n        const select = document.createElement('select');\n        const wrapper = Styling.wrapSelect(select);\n        expect(wrapper.className).toBe('jp-select-wrapper');\n        expect(select.parentElement).toBe(wrapper);\n        expect(select.className).toBe('jp-mod-styled');\n        document.body.appendChild(wrapper);\n        select.focus();\n        simulate(select, 'focus');\n        expect(wrapper.className).toContain('jp-mod-focused');\n        select.blur();\n        simulate(select, 'blur');\n        expect(wrapper.className).not.toContain('jp-mod-focused');\n        document.body.removeChild(wrapper);\n      });","file":"styling.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render a command","suites":["@jupyterlab/ui-components","CommandToolbarButton"],"updatePoint":{"line":43,"column":31},"line":43,"code":"    it('should render a command', async () => {\n      commands.addCommand(id, options);\n      const button = new CommandToolbarButton({\n        commands,\n        id\n      });\n\n      Widget.attach(button, document.body);\n      await framePromise();\n\n      expect(button.hasClass('jp-CommandToolbarButton')).toBe(true);\n      simulate(button.node.firstElementChild!, 'mousedown');\n      expect(options.execute).toBeCalledTimes(1);\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render the label command","suites":["@jupyterlab/ui-components","CommandToolbarButton"],"updatePoint":{"line":58,"column":39},"line":58,"code":"    it('should render the label command', async () => {\n      const label = 'This is a test label';\n      commands.addCommand(id, { ...options, label });\n      const button = new CommandToolbarButton({\n        commands,\n        id\n      });\n\n      Widget.attach(button, document.body);\n      await framePromise();\n\n      expect(button.node.textContent).toMatch(label);\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render the customized label command","suites":["@jupyterlab/ui-components","CommandToolbarButton"],"updatePoint":{"line":72,"column":50},"line":72,"code":"    it('should render the customized label command', async () => {\n      const label = 'This is a test label';\n      const buttonLabel = 'This is the button label';\n      commands.addCommand(id, { ...options, label });\n      const button = new CommandToolbarButton({\n        commands,\n        id,\n        label: buttonLabel\n      });\n\n      Widget.attach(button, document.body);\n      await framePromise();\n\n      expect(button.node.textContent).toMatch(buttonLabel);\n      expect(button.node.textContent).not.toMatch(label);\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render the icon command","suites":["@jupyterlab/ui-components","CommandToolbarButton"],"updatePoint":{"line":89,"column":38},"line":89,"code":"    it('should render the icon command', async () => {\n      const icon = jupyterIcon;\n      commands.addCommand(id, { ...options, icon });\n      const button = new CommandToolbarButton({\n        commands,\n        id\n      });\n\n      Widget.attach(button, document.body);\n      await framePromise();\n\n      expect(button.node.getElementsByTagName('svg')[0].dataset.icon).toMatch(\n        icon.name\n      );\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render the customized icon command","suites":["@jupyterlab/ui-components","CommandToolbarButton"],"updatePoint":{"line":105,"column":49},"line":105,"code":"    it('should render the customized icon command', async () => {\n      const icon = jupyterIcon;\n      const buttonIcon = blankIcon;\n      commands.addCommand(id, { ...options, icon });\n      const button = new CommandToolbarButton({\n        commands,\n        id,\n        icon: buttonIcon\n      });\n\n      Widget.attach(button, document.body);\n      await framePromise();\n\n      const iconSVG = button.node.getElementsByTagName('svg')[0];\n      expect(iconSVG.dataset.icon).toMatch(buttonIcon.name);\n      expect(iconSVG.dataset.icon).not.toMatch(icon.name);\n    });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should construct a new toolbar widget","suites":["@jupyterlab/ui-components","Toolbar","#constructor()"],"updatePoint":{"line":137,"column":47},"line":137,"code":"      it('should construct a new toolbar widget', () => {\n        const widget = new Toolbar();\n        expect(widget).toBeInstanceOf(Toolbar);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add the `jp-Toolbar` class","suites":["@jupyterlab/ui-components","Toolbar","#constructor()"],"updatePoint":{"line":142,"column":43},"line":142,"code":"      it('should add the `jp-Toolbar` class', () => {\n        const widget = new Toolbar();\n        expect(widget.hasClass('jp-Toolbar')).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should get an ordered list the toolbar item names","suites":["@jupyterlab/ui-components","Toolbar","#names()"],"updatePoint":{"line":149,"column":59},"line":149,"code":"      it('should get an ordered list the toolbar item names', () => {\n        widget.addItem('foo', new Widget());\n        widget.addItem('bar', new Widget());\n        widget.addItem('baz', new Widget());\n        expect(toArray(widget.names())).toEqual(['foo', 'bar', 'baz']);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add an item to the toolbar","suites":["@jupyterlab/ui-components","Toolbar","#addItem()"],"updatePoint":{"line":158,"column":43},"line":158,"code":"      it('should add an item to the toolbar', () => {\n        const item = new Widget();\n        expect(widget.addItem('test', item)).toBe(true);\n        expect(toArray(widget.names())).toContain('test');\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add the `jp-Toolbar-item` class to the widget","suites":["@jupyterlab/ui-components","Toolbar","#addItem()"],"updatePoint":{"line":164,"column":62},"line":164,"code":"      it('should add the `jp-Toolbar-item` class to the widget', () => {\n        const item = new Widget();\n        widget.addItem('test', item);\n        expect(item.hasClass('jp-Toolbar-item')).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should return false if the name is already used","suites":["@jupyterlab/ui-components","Toolbar","#addItem()"],"updatePoint":{"line":170,"column":57},"line":170,"code":"      it('should return false if the name is already used', () => {\n        widget.addItem('test', new Widget());\n        expect(widget.addItem('test', new Widget())).toBe(false);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should insert the item into the toolbar","suites":["@jupyterlab/ui-components","Toolbar","#insertItem()"],"updatePoint":{"line":177,"column":49},"line":177,"code":"      it('should insert the item into the toolbar', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        widget.insertItem(1, 'c', new Widget());\n        expect(toArray(widget.names())).toEqual(['a', 'c', 'b']);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should clamp the bounds","suites":["@jupyterlab/ui-components","Toolbar","#insertItem()"],"updatePoint":{"line":184,"column":33},"line":184,"code":"      it('should clamp the bounds', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        widget.insertItem(10, 'c', new Widget());\n        expect(toArray(widget.names())).toEqual(['a', 'b', 'c']);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should insert an item into the toolbar after `c`","suites":["@jupyterlab/ui-components","Toolbar","#insertAfter()"],"updatePoint":{"line":193,"column":58},"line":193,"code":"      it('should insert an item into the toolbar after `c`', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        widget.insertItem(1, 'c', new Widget());\n        widget.insertAfter('c', 'd', new Widget());\n        expect(toArray(widget.names())).toEqual(['a', 'c', 'd', 'b']);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should return false if the target item does not exist","suites":["@jupyterlab/ui-components","Toolbar","#insertAfter()"],"updatePoint":{"line":201,"column":63},"line":201,"code":"      it('should return false if the target item does not exist', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        const value = widget.insertAfter('c', 'd', new Widget());\n        expect(value).toBe(false);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should insert an item into the toolbar before `c`","suites":["@jupyterlab/ui-components","Toolbar","#insertBefore()"],"updatePoint":{"line":210,"column":59},"line":210,"code":"      it('should insert an item into the toolbar before `c`', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        widget.insertItem(1, 'c', new Widget());\n        widget.insertBefore('c', 'd', new Widget());\n        expect(toArray(widget.names())).toEqual(['a', 'd', 'c', 'b']);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should return false if the target item does not exist","suites":["@jupyterlab/ui-components","Toolbar","#insertBefore()"],"updatePoint":{"line":218,"column":63},"line":218,"code":"      it('should return false if the target item does not exist', () => {\n        widget.addItem('a', new Widget());\n        widget.addItem('b', new Widget());\n        const value = widget.insertBefore('c', 'd', new Widget());\n        expect(value).toBe(false);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should create a button","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":254,"column":32},"line":254,"code":"      it('should create a button', () => {\n        const button = new CommandToolbarButton({\n          commands,\n          id: testLogCommandId\n        });\n        expect(button).toBeInstanceOf(CommandToolbarButton);\n        button.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add main class","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":263,"column":31},"line":263,"code":"      it('should add main class', async () => {\n        const button = new CommandToolbarButton({\n          commands,\n          id: testLogCommandId\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.classList.contains('test-log-class')).toBe(true);\n        button.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add an icon with icon class and label","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":274,"column":54},"line":274,"code":"      it('should add an icon with icon class and label', async () => {\n        const button = new CommandToolbarButton({\n          commands,\n          id: testLogCommandId\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.title).toBe('Test log command caption');\n        const iconNode = buttonNode.firstChild as HTMLElement;\n        expect(iconNode.classList.contains('test-icon-class')).toBe(true);\n        button.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should apply state classes","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":287,"column":36},"line":287,"code":"      it('should apply state classes', async () => {\n        enabled = false;\n        toggled = true;\n        visible = false;\n        const button = new CommandToolbarButton({\n          commands,\n          id: testLogCommandId\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.disabled).toBe(true);\n        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);\n        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(true);\n        button.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should update state classes","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":303,"column":37},"line":303,"code":"      it('should update state classes', async () => {\n        enabled = false;\n        toggled = true;\n        visible = false;\n        const button = new CommandToolbarButton({\n          commands,\n          id: testLogCommandId\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.disabled).toBe(true);\n        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);\n        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(true);\n        enabled = true;\n        visible = true;\n        commands.notifyCommandChanged(testLogCommandId);\n        expect(buttonNode.disabled).toBe(false);\n        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);\n        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(false);\n        enabled = false;\n        visible = false;\n        button.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should use the command label if no icon class/label","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":327,"column":61},"line":327,"code":"      it('should use the command label if no icon class/label', async () => {\n        const id = 'to-be-removed';\n        const cmd = commands.addCommand(id, {\n          execute: () => {\n            return;\n          },\n          label: 'Label-only button'\n        });\n        const button = new CommandToolbarButton({\n          commands,\n          id\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.textContent).toBe('Label-only button');\n        cmd.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should update the node content on command change event","suites":["@jupyterlab/ui-components","Toolbar",".createFromCommand"],"updatePoint":{"line":345,"column":64},"line":345,"code":"      it('should update the node content on command change event', async () => {\n        const id = 'to-be-removed';\n        let iconClassValue: string = '';\n        const cmd = commands.addCommand(id, {\n          execute: () => {\n            /* no op */\n          },\n          label: 'Label-only button',\n          iconClass: () => iconClassValue ?? ''\n        });\n        const button = new CommandToolbarButton({\n          commands,\n          id\n        });\n        await render(button);\n        const buttonNode = button.node.firstChild as HTMLButtonElement;\n        expect(buttonNode.textContent).toBe('Label-only button');\n        expect(buttonNode.classList.contains(iconClassValue)).toBe(false);\n\n        iconClassValue = 'updated-icon-class';\n        commands.notifyCommandChanged(id);\n        await render(button);\n        const iconNode = buttonNode.firstChild as HTMLElement;\n        expect(iconNode.classList.contains(iconClassValue)).toBe(true);\n        cmd.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should append a node to body for the pop-up","suites":["@jupyterlab/ui-components","ReactiveToolbar","#constructor()"],"updatePoint":{"line":387,"column":53},"line":387,"code":"      it('should append a node to body for the pop-up', () => {\n        const popup = document.body.querySelector(\n          '.jp-Toolbar-responsive-popup'\n        );\n        expect(popup).toBeDefined();\n        expect(popup!.parentNode!.nodeName).toEqual('BODY');\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should insert item before the toolbar pop-up button","suites":["@jupyterlab/ui-components","ReactiveToolbar","#addItem()"],"updatePoint":{"line":397,"column":61},"line":397,"code":"      it('should insert item before the toolbar pop-up button', () => {\n        const w = new Widget();\n        toolbar.addItem('test', w);\n        expect(\n          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)\n        ).toEqual((toolbar.layout as PanelLayout).widgets.length - 2);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should insert item before the toolbar pop-up button","suites":["@jupyterlab/ui-components","ReactiveToolbar","#insertItem()"],"updatePoint":{"line":407,"column":61},"line":407,"code":"      it('should insert item before the toolbar pop-up button', () => {\n        const w = new Widget();\n        toolbar.insertItem(2, 'test', w);\n        expect(\n          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)\n        ).toEqual((toolbar.layout as PanelLayout).widgets.length - 2);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should not insert item after the toolbar pop-up button","suites":["@jupyterlab/ui-components","ReactiveToolbar","#insertAfter()"],"updatePoint":{"line":417,"column":64},"line":417,"code":"      it('should not insert item after the toolbar pop-up button', () => {\n        const w = new Widget();\n        const r = toolbar.insertAfter('toolbar-popup-opener', 'test', w);\n        expect(r).toEqual(false);\n        expect(\n          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)\n        ).toEqual(-1);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should accept no arguments","suites":["@jupyterlab/ui-components","ToolbarButton","#constructor()"],"updatePoint":{"line":430,"column":36},"line":430,"code":"      it('should accept no arguments', () => {\n        const widget = new ToolbarButton();\n        expect(widget).toBeInstanceOf(ToolbarButton);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should accept options","suites":["@jupyterlab/ui-components","ToolbarButton","#constructor()"],"updatePoint":{"line":435,"column":31},"line":435,"code":"      it('should accept options', async () => {\n        const widget = new ToolbarButton({\n          className: 'foo',\n          iconClass: 'iconFoo',\n          onClick: () => {\n            return void 0;\n          },\n          tooltip: 'bar'\n        });\n        Widget.attach(widget, document.body);\n        await framePromise();\n        const button = widget.node.firstChild as HTMLElement;\n        expect(button.classList.contains('foo')).toBe(true);\n        expect(button.querySelector('.iconFoo')).toBeDefined();\n        expect(button.title).toBe('bar');\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should dispose of the resources used by the widget","suites":["@jupyterlab/ui-components","ToolbarButton","#dispose()"],"updatePoint":{"line":454,"column":60},"line":454,"code":"      it('should dispose of the resources used by the widget', () => {\n        const button = new ToolbarButton();\n        button.dispose();\n        expect(button.isDisposed).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be safe to call more than once","suites":["@jupyterlab/ui-components","ToolbarButton","#dispose()"],"updatePoint":{"line":460,"column":47},"line":460,"code":"      it('should be safe to call more than once', () => {\n        const button = new ToolbarButton();\n        button.dispose();\n        button.dispose();\n        expect(button.isDisposed).toBe(true);\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should activate the callback","suites":["@jupyterlab/ui-components","ToolbarButton","#handleEvent()","click"],"updatePoint":{"line":470,"column":40},"line":470,"code":"        it('should activate the callback', async () => {\n          let called = false;\n          const button = new ToolbarButton({\n            onClick: () => {\n              called = true;\n            }\n          });\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(called).toBe(true);\n          button.dispose();\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"Enter should activate the callback","suites":["@jupyterlab/ui-components","ToolbarButton","#handleEvent()","keydown"],"updatePoint":{"line":485,"column":46},"line":485,"code":"        it('Enter should activate the callback', async () => {\n          let called = false;\n          const button = new ToolbarButton({\n            onClick: () => {\n              called = true;\n            }\n          });\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'keydown', {\n            key: 'Enter'\n          });\n          expect(called).toBe(true);\n          button.dispose();\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"Space should activate the callback","suites":["@jupyterlab/ui-components","ToolbarButton","#handleEvent()","keydown"],"updatePoint":{"line":500,"column":46},"line":500,"code":"        it('Space should activate the callback', async () => {\n          let called = false;\n          const button = new ToolbarButton({\n            onClick: () => {\n              called = true;\n            }\n          });\n          Widget.attach(button, document.body);\n          await framePromise();\n          simulate(button.node.firstChild as HTMLElement, 'keydown', {\n            key: ' '\n          });\n          expect(called).toBe(true);\n          button.dispose();\n        });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should add event listeners to the node","suites":["@jupyterlab/ui-components","ToolbarButton","#onAfterAttach()"],"line":519,"code":"      it.skip('should add event listeners to the node', () => {","file":"toolbar.spec.ts","skipped":true,"dir":"packages/ui-components/test"},{"name":"should remove event listeners from the node","suites":["@jupyterlab/ui-components","ToolbarButton","#onBeforeDetach()"],"line":530,"code":"      it.skip('should remove event listeners from the node', async () => {","file":"toolbar.spec.ts","skipped":true,"dir":"packages/ui-components/test"},{"name":"should update the pressed state","suites":["@jupyterlab/ui-components","ToolbarButton","#pressed()"],"updatePoint":{"line":543,"column":41},"line":543,"code":"      it('should update the pressed state', async () => {\n        const widget = new ToolbarButton({\n          icon: bugIcon,\n          tooltip: 'tooltip',\n          pressedTooltip: 'pressed tooltip',\n          pressedIcon: bugDotIcon\n        });\n        Widget.attach(widget, document.body);\n        await framePromise();\n        const button = widget.node.firstChild as HTMLElement;\n        expect(widget.pressed).toBe(false);\n        expect(button.title).toBe('tooltip');\n        expect(button.getAttribute('aria-pressed')).toEqual('false');\n        let icon = button.querySelectorAll('svg');\n        expect(icon[0].getAttribute('data-icon')).toEqual('ui-components:bug');\n        widget.pressed = true;\n        await framePromise();\n        expect(widget.pressed).toBe(true);\n        expect(button.title).toBe('pressed tooltip');\n        expect(button.getAttribute('aria-pressed')).toEqual('true');\n        icon = button.querySelectorAll('svg');\n        expect(icon[0].getAttribute('data-icon')).toEqual(\n          'ui-components:bug-dot'\n        );\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should not have the pressed state when not enabled","suites":["@jupyterlab/ui-components","ToolbarButton","#pressed()"],"updatePoint":{"line":570,"column":60},"line":570,"code":"      it('should not have the pressed state when not enabled', async () => {\n        const widget = new ToolbarButton({\n          icon: bugIcon,\n          tooltip: 'tooltip',\n          pressedTooltip: 'pressed tooltip',\n          disabledTooltip: 'disabled tooltip',\n          pressedIcon: bugDotIcon,\n          enabled: false\n        });\n        Widget.attach(widget, document.body);\n        await framePromise();\n        const button = widget.node.firstChild as HTMLElement;\n        expect(widget.pressed).toBe(false);\n        expect(button.title).toBe('disabled tooltip');\n        expect(button.getAttribute('aria-pressed')).toEqual('false');\n        widget.pressed = true;\n        await framePromise();\n        expect(widget.pressed).toBe(false);\n        expect(button.title).toBe('disabled tooltip');\n        expect(button.getAttribute('aria-pressed')).toEqual('false');\n        const icon = button.querySelectorAll('svg');\n        expect(icon[0].getAttribute('data-icon')).toEqual('ui-components:bug');\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should update the enabled state","suites":["@jupyterlab/ui-components","ToolbarButton","#enabled()"],"updatePoint":{"line":597,"column":41},"line":597,"code":"      it('should update the enabled state', async () => {\n        const widget = new ToolbarButton({\n          icon: bugIcon,\n          tooltip: 'tooltip',\n          pressedTooltip: 'pressed tooltip',\n          disabledTooltip: 'disabled tooltip',\n          pressedIcon: bugDotIcon\n        });\n        Widget.attach(widget, document.body);\n        await framePromise();\n        const button = widget.node.firstChild as HTMLElement;\n        expect(widget.enabled).toBe(true);\n        expect(widget.pressed).toBe(false);\n        expect(button.getAttribute('aria-disabled')).toEqual('false');\n\n        widget.pressed = true;\n        await framePromise();\n        expect(widget.pressed).toBe(true);\n\n        widget.enabled = false;\n        await framePromise();\n        expect(widget.enabled).toBe(false);\n        expect(widget.pressed).toBe(false);\n        expect(button.getAttribute('aria-disabled')).toEqual('true');\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should update the onClick state","suites":["@jupyterlab/ui-components","ToolbarButton","#onClick()"],"updatePoint":{"line":626,"column":41},"line":626,"code":"      it('should update the onClick state', async () => {\n        let mockCalled = false;\n        const mockOnClick = () => {\n          mockCalled = true;\n        };\n        const widget = new ToolbarButton({\n          icon: bugIcon,\n          tooltip: 'tooltip',\n          onClick: mockOnClick\n        });\n        Widget.attach(widget, document.body);\n        await framePromise();\n        simulate(widget.node.firstChild as HTMLElement, 'mousedown');\n        expect(mockCalled).toBe(true);\n\n        mockCalled = false;\n        let mockUpdatedCalled = false;\n        const mockOnClickUpdated = () => {\n          mockUpdatedCalled = true;\n        };\n        widget.onClick = mockOnClickUpdated;\n        await framePromise();\n        simulate(widget.node.firstChild as HTMLElement, 'mousedown');\n        expect(mockCalled).toBe(false);\n        expect(mockUpdatedCalled).toBe(true);\n        widget.dispose();\n      });","file":"toolbar.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should create a VDomModel","suites":["@jupyterlab/ui-components","VDomModel","#constructor()"],"updatePoint":{"line":37,"column":35},"line":37,"code":"      it('should create a VDomModel', () => {\n        const model = new VDomModel();\n        expect(model).toBeInstanceOf(VDomModel);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should create a TestModel","suites":["@jupyterlab/ui-components","VDomModel","#constructor()"],"updatePoint":{"line":42,"column":35},"line":42,"code":"      it('should create a TestModel', () => {\n        const model = new TestModel();\n        expect(model).toBeInstanceOf(TestModel);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be properly disposed","suites":["@jupyterlab/ui-components","VDomModel","#constructor()"],"updatePoint":{"line":47,"column":37},"line":47,"code":"      it('should be properly disposed', () => {\n        const model = new TestModel();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should fire the stateChanged signal on a change","suites":["@jupyterlab/ui-components","VDomModel","#stateChanged()"],"updatePoint":{"line":55,"column":57},"line":55,"code":"      it('should fire the stateChanged signal on a change', () => {\n        const model = new TestModel();\n        let changed = false;\n        model.stateChanged.connect(() => {\n          changed = true;\n        });\n        model.value = 'newvalue';\n        expect(changed).toBe(true);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should create a TestWidget","suites":["@jupyterlab/ui-components","VDomRenderer","#constructor()"],"updatePoint":{"line":69,"column":36},"line":69,"code":"      it('should create a TestWidget', () => {\n        const widget = new TestWidget(new TestModel());\n        expect(widget).toBeInstanceOf(TestWidget);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should be properly disposed","suites":["@jupyterlab/ui-components","VDomRenderer","#constructor()"],"updatePoint":{"line":74,"column":37},"line":74,"code":"      it('should be properly disposed', () => {\n        const widget = new TestWidget(new TestModel());\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should fire the stateChanged signal on a change","suites":["@jupyterlab/ui-components","VDomRenderer","#modelChanged()"],"updatePoint":{"line":82,"column":57},"line":82,"code":"      it('should fire the stateChanged signal on a change', () => {\n        const model = new TestModel();\n        const widget = new TestWidget(new TestModel());\n        let changed = false;\n        widget.modelChanged.connect(() => {\n          changed = true;\n        });\n        widget.model = model;\n        expect(changed).toBe(true);\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should render the contents after a model change","suites":["@jupyterlab/ui-components","VDomRenderer","#render()"],"updatePoint":{"line":95,"column":57},"line":95,"code":"      it('should render the contents after a model change', async () => {\n        const widget = new TestWidget(new TestModel());\n        const model = new TestModel();\n        widget.model = model;\n        model.value = 'foo';\n        await framePromise();\n        const span = widget.node.firstChild as HTMLElement;\n        expect(span.textContent).toBe('foo');\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"should work with a null model","suites":["@jupyterlab/ui-components","VDomRenderer","#noModel()"],"updatePoint":{"line":107,"column":39},"line":107,"code":"      it('should work with a null model', async () => {\n        const widget = new TestWidgetNoModel();\n        Widget.attach(widget, document.body);\n        await framePromise();\n        const span = widget.node.firstChild as HTMLElement;\n        expect(span.textContent).toBe('No model!');\n      });","file":"vdom.spec.ts","skipped":false,"dir":"packages/ui-components/test"},{"name":"Should change the title","suites":["user/menu","Menu"],"updatePoint":{"line":12,"column":31},"line":12,"code":"    it('Should change the title', async () => {\n      const commands = new CommandRegistry();\n      const user = new User();\n      const menu = new UserMenu({\n        user,\n        commands\n      });\n\n      const promiseUserChanged = signalToPromise(user.changed);\n      const promiseTitleChanged = signalToPromise(menu.title.changed);\n\n      const givenName = 'jovyan';\n      const familyName = '';\n      user.fromJSON({ ...user.toJSON(), givenName, familyName });\n\n      const [senderUserChanged] = await promiseUserChanged;\n      const [senderTitleChanged] = await promiseTitleChanged;\n\n      expect(senderUserChanged).toBe(user);\n      expect(senderTitleChanged).toBe(menu.title);\n      expect(menu.title.label).toBe(givenName);\n    });","file":"menu.spec.ts","skipped":false,"dir":"packages/user/test"},{"name":"Should create and anonymous user","suites":["user/model","User"],"updatePoint":{"line":12,"column":40},"line":12,"code":"    it('Should create and anonymous user', () => {\n      expect(user.anonymous).toBe(true);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/user/test"},{"name":"Should load the previous user","suites":["user/model","User"],"updatePoint":{"line":16,"column":37},"line":16,"code":"    it('Should load the previous user', () => {\n      const user2 = new User();\n      expect(user.username).toBe(user2.username);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/user/test"},{"name":"Should emit user changed","suites":["user/model","User"],"updatePoint":{"line":21,"column":32},"line":21,"code":"    it('Should emit user changed', async () => {\n      const promise = signalToPromise(user.changed);\n      const newName = 'jovyan';\n      user.fromJSON({\n        ...user.toJSON(),\n        givenName: newName\n      });\n\n      const [sender] = await promise;\n      expect(sender).toBe(user);\n      expect(user.givenName).toBe(newName);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/user/test"},{"name":"Should change the name","suites":["user/model","User"],"updatePoint":{"line":34,"column":30},"line":34,"code":"    it('Should change the name', async () => {\n      const promise = signalToPromise(user.changed);\n      const newName = 'jovyan';\n      user.fromJSON({\n        username: user.username,\n        givenName: newName,\n        familyName: user.familyName,\n        initials: user.initials,\n        color: user.color,\n        anonymous: user.anonymous\n      });\n      const [sender] = await promise;\n      expect(sender).toBe(user);\n      expect(user.givenName).toBe(newName);\n    });","file":"model.spec.ts","skipped":false,"dir":"packages/user/test"},{"name":"should create a session context","suites":["mock","createSimpleSessionContext()"],"updatePoint":{"line":10,"column":39},"line":10,"code":"    it('should create a session context', () => {\n      const context = Mock.createSimpleSessionContext();\n      expect(context.session!.kernel!.name).toEqual(Mock.DEFAULT_NAME);\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should accept a session model","suites":["mock","createSimpleSessionContext()"],"updatePoint":{"line":15,"column":37},"line":15,"code":"    it('should accept a session model', () => {\n      const context = Mock.createSimpleSessionContext({\n        name: 'hi',\n        path: 'foo',\n        type: 'bar',\n        kernel: { name: 'fizz' }\n      });\n      expect(context.name).toEqual('hi');\n      expect(context.path).toEqual('foo');\n      expect(context.type).toEqual('bar');\n      expect(context.session!.kernel!.name).toEqual('fizz');\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should update the kernel status","suites":["mock","updateKernelStatus()"],"updatePoint":{"line":30,"column":39},"line":30,"code":"    it('should update the kernel status', () => {\n      const context = Mock.createSimpleSessionContext();\n      let called = false;\n      context.statusChanged.connect((_, status) => {\n        if (status === 'dead') {\n          called = true;\n        }\n      });\n      Mock.updateKernelStatus(context, 'dead');\n      expect(context.session!.kernel!.status).toEqual('dead');\n      expect(called).toEqual(true);\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should emit an iopub message","suites":["mock","emitIopubMessage"],"updatePoint":{"line":45,"column":36},"line":45,"code":"    it('should emit an iopub message', () => {\n      const context = Mock.createSimpleSessionContext();\n      const source = KernelMessage.createMessage({\n        channel: 'iopub',\n        msgType: 'execute_input',\n        session: 'foo',\n        username: 'bar',\n        msgId: 'fizz',\n        content: {\n          code: 'hello, world!',\n          execution_count: 0\n        }\n      });\n      let called = false;\n      context.iopubMessage.connect((_, msg) => {\n        expect(msg).toBe(source);\n        called = true;\n      });\n      Mock.emitIopubMessage(context, source);\n      expect(called).toBe(true);\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should clone a kernel","suites":["mock","cloneKernel()"],"updatePoint":{"line":69,"column":29},"line":69,"code":"    it('should clone a kernel', () => {\n      const kernel0 = new Mock.KernelMock({});\n      const kernel1 = Mock.cloneKernel(kernel0);\n      expect(kernel0.id).toBe(kernel1.id);\n      expect(kernel0.clientId).not.toBe(kernel1.clientId);\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a mock kernel","suites":["mock","KernelMock",".constructor()"],"updatePoint":{"line":79,"column":37},"line":79,"code":"      it('should create a mock kernel', () => {\n        const kernel = new Mock.KernelMock({});\n        expect(kernel.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should take options","suites":["mock","KernelMock",".constructor()"],"updatePoint":{"line":84,"column":29},"line":84,"code":"      it('should take options', () => {\n        const kernel = new Mock.KernelMock({ model: { name: 'foo' } });\n        expect(kernel.name).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should resolve with a kernel spec","suites":["mock","KernelMock",".spec()"],"updatePoint":{"line":91,"column":43},"line":91,"code":"      it('should resolve with a kernel spec', async () => {\n        const kernel = new Mock.KernelMock({});\n        const spec = await kernel.spec;\n        expect(spec!.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","KernelMock",".dispose()"],"updatePoint":{"line":99,"column":27},"line":99,"code":"      it('should be a no-op', () => {\n        const kernel = new Mock.KernelMock({});\n        expect(() => {\n          kernel.dispose();\n        }).not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should clone the kernel","suites":["mock","KernelMock",".clone()"],"updatePoint":{"line":108,"column":33},"line":108,"code":"      it('should clone the kernel', () => {\n        const kernel0 = new Mock.KernelMock({});\n        const kernel1 = kernel0.clone();\n        expect(kernel0.id).toBe(kernel1.id);\n        expect(kernel0.clientId).not.toBe(kernel1.clientId);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should resolve with info","suites":["mock","KernelMock",".info"],"updatePoint":{"line":117,"column":34},"line":117,"code":"      it('should resolve with info', async () => {\n        const kernel = new Mock.KernelMock({});\n        const info = await kernel.info;\n        expect(info.language_info.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","KernelMock",".shutdown()"],"updatePoint":{"line":125,"column":27},"line":125,"code":"      it('should be a no-op', async () => {\n        const kernel = new Mock.KernelMock({});\n        await expect(kernel.shutdown()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should get the history info","suites":["mock","KernelMock",".requestHistory()"],"updatePoint":{"line":132,"column":37},"line":132,"code":"      it('should get the history info', async () => {\n        const kernel = new Mock.KernelMock({});\n        const reply = await kernel.requestHistory({} as any);\n        expect(reply.content.status).toBe('ok');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","KernelMock",".restart()"],"updatePoint":{"line":140,"column":27},"line":140,"code":"      it('should be a no-op', async () => {\n        const kernel = new Mock.KernelMock({});\n        await expect(kernel.restart()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should request execution","suites":["mock","KernelMock",".requestExecute()"],"updatePoint":{"line":147,"column":34},"line":147,"code":"      it('should request execution', async () => {\n        const kernel = new Mock.KernelMock({});\n        let called = false;\n        kernel.iopubMessage.connect((_, msg) => {\n          if (msg.header.msg_type === 'execute_input') {\n            called = true;\n          }\n        });\n        const future = kernel.requestExecute({ code: 'foo ' });\n        await future.done;\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new SessionConnectionMock","suites":["mock","SessionConnectionMock",".constructor()"],"updatePoint":{"line":164,"column":51},"line":164,"code":"      it('should create a new SessionConnectionMock', () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should take options","suites":["mock","SessionConnectionMock",".constructor()"],"updatePoint":{"line":169,"column":29},"line":169,"code":"      it('should take options', () => {\n        const kernel = new Mock.KernelMock({});\n        const session = new Mock.SessionConnectionMock(\n          { model: { name: 'foo' } },\n          kernel\n        );\n        expect(session.kernel).toBe(kernel);\n        expect(session.name).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionConnectionMock",".dispose()"],"updatePoint":{"line":181,"column":27},"line":181,"code":"      it('should be a no-op', () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        expect(() => {\n          session.dispose();\n        }).not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should change the kernel","suites":["mock","SessionConnectionMock",".changeKernel()"],"updatePoint":{"line":190,"column":34},"line":190,"code":"      it('should change the kernel', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        const oldId = session.kernel!.id;\n        const kernel = await session.changeKernel({ name: Mock.DEFAULT_NAME });\n        expect(kernel!.id).not.toBe(oldId);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionConnectionMock",".shutdown()"],"updatePoint":{"line":199,"column":27},"line":199,"code":"      it('should be a no-op', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should set the path","suites":["mock","SessionConnectionMock",".setPath()"],"updatePoint":{"line":206,"column":29},"line":206,"code":"      it('should set the path', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'path') {\n            called = true;\n          }\n        });\n        await session.setPath('foo');\n        expect(session.path).toBe('foo');\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should set the type","suites":["mock","SessionConnectionMock",".setType()"],"updatePoint":{"line":221,"column":29},"line":221,"code":"      it('should set the type', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'type') {\n            called = true;\n          }\n        });\n        await session.setType('foo');\n        expect(session.type).toBe('foo');\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should set the name","suites":["mock","SessionConnectionMock",".setName()"],"updatePoint":{"line":236,"column":29},"line":236,"code":"      it('should set the name', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'name') {\n            called = true;\n          }\n        });\n        await session.setName('foo');\n        expect(session.name).toBe('foo');\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new context","suites":["mock","SessionContextMock",".constructor()"],"updatePoint":{"line":253,"column":37},"line":253,"code":"      it('should create a new context', () => {\n        const context = new Mock.SessionContextMock({}, null);\n        expect(context.session!.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should accept options","suites":["mock","SessionContextMock",".constructor()"],"updatePoint":{"line":258,"column":31},"line":258,"code":"      it('should accept options', () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        const context = new Mock.SessionContextMock({ path: 'foo' }, session);\n        expect(context.session).toBe(session);\n        expect(context.path).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionContextMock",".dispose()"],"updatePoint":{"line":267,"column":27},"line":267,"code":"      it('should be a no-op', () => {\n        const context = new Mock.SessionContextMock({}, null);\n        expect(() => {\n          context.dispose();\n        }).not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionContextMock",".initialize()"],"updatePoint":{"line":276,"column":27},"line":276,"code":"      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.initialize()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionContextMock",".ready"],"updatePoint":{"line":283,"column":27},"line":283,"code":"      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.ready).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should change the kernel","suites":["mock","SessionContextMock",".changeKernel()"],"updatePoint":{"line":290,"column":34},"line":290,"code":"      it('should change the kernel', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        const oldId = context.session!.kernel!.id;\n        const kernel = await context.changeKernel({ name: Mock.DEFAULT_NAME });\n        expect(kernel!.id).not.toBe(oldId);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionContextMock",".shutdown()"],"updatePoint":{"line":299,"column":27},"line":299,"code":"      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.shutdown()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new mock","suites":["mock","ContentsManagerMock",".constructor()"],"updatePoint":{"line":308,"column":34},"line":308,"code":"      it('should create a new mock', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(manager.localPath('foo')).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new text file","suites":["mock","ContentsManagerMock",".newUntitled"],"updatePoint":{"line":315,"column":39},"line":315,"code":"      it('should create a new text file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type === 'new') {\n            called = true;\n          }\n        });\n        const contents = await manager.newUntitled();\n        expect(contents.type).toBe('file');\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new notebook","suites":["mock","ContentsManagerMock",".newUntitled"],"updatePoint":{"line":328,"column":38},"line":328,"code":"      it('should create a new notebook', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const contents = await manager.newUntitled({ type: 'notebook' });\n        expect(contents.type).toBe('notebook');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a checkpoint","suites":["mock","ContentsManagerMock",".createCheckpoint()"],"updatePoint":{"line":336,"column":36},"line":336,"code":"      it('should create a checkpoint', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        expect(checkpoint.id).toBeTruthy();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should list the checkpoints","suites":["mock","ContentsManagerMock",".listCheckpoints()"],"updatePoint":{"line":345,"column":37},"line":345,"code":"      it('should list the checkpoints', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        const checkpoints = await manager.listCheckpoints(content.path);\n        expect(checkpoints[0].id).toBe(checkpoint.id);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should delete a checkpoints","suites":["mock","ContentsManagerMock",".deleteCheckpoint"],"updatePoint":{"line":355,"column":37},"line":355,"code":"      it('should delete a checkpoints', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        await manager.deleteCheckpoint(content.path, checkpoint.id);\n        const checkpoints = await manager.listCheckpoints(content.path);\n        expect(checkpoints.length).toBe(0);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should restore the contents","suites":["mock","ContentsManagerMock",".restoreCheckpoint()"],"updatePoint":{"line":366,"column":37},"line":366,"code":"      it('should restore the contents', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        await manager.save(content.path, { content: 'foo' });\n        const checkpoint = await manager.createCheckpoint(content.path);\n        await manager.save(content.path, { content: 'bar' });\n        await manager.restoreCheckpoint(content.path, checkpoint.id);\n        const newContent = await manager.get(content.path);\n        expect(newContent.content).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should return null","suites":["mock","ContentsManagerMock",".getModelDBFactory()"],"updatePoint":{"line":379,"column":28},"line":379,"code":"      it('should return null', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(manager.getModelDBFactory('foo')).toBe(null);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should normalize a path","suites":["mock","ContentsManagerMock",".normalize()"],"updatePoint":{"line":386,"column":33},"line":386,"code":"      it('should normalize a path', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(manager.normalize('foo/bar/../baz')).toBe('foo/baz');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should get the local path of a file","suites":["mock","ContentsManagerMock",".localPath"],"updatePoint":{"line":393,"column":45},"line":393,"code":"      it('should get the local path of a file', () => {\n        const manager = new Mock.ContentsManagerMock();\n        const defaultDrive = manager.driveName('foo');\n        expect(manager.localPath(`${defaultDrive}foo/bar`)).toBe('foo/bar');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should get the file contents","suites":["mock","ContentsManagerMock",".get()"],"updatePoint":{"line":401,"column":38},"line":401,"code":"      it('should get the file contents', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        await manager.save(content.path, { content: 'foo' });\n        const newContent = await manager.get(content.path);\n        expect(newContent.content).toBe('foo');\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should get the drive name of the path","suites":["mock","ContentsManagerMock",".driveName()"],"updatePoint":{"line":411,"column":47},"line":411,"code":"      it('should get the drive name of the path', () => {\n        const manager = new Mock.ContentsManagerMock();\n        const defaultDrive = manager.driveName('foo');\n        expect(manager.driveName(`${defaultDrive}/bar`)).toBe(defaultDrive);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should rename the file","suites":["mock","ContentsManagerMock",".rename()"],"updatePoint":{"line":419,"column":32},"line":419,"code":"      it('should rename the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'rename') {\n            return;\n          }\n          expect(args.newValue!.path).toBe('foo');\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.rename(contents.path, 'foo');\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should delete the file","suites":["mock","ContentsManagerMock",".delete()"],"updatePoint":{"line":436,"column":32},"line":436,"code":"      it('should delete the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'delete') {\n            return;\n          }\n          expect(args.newValue).toBe(null);\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.delete(contents.path);\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should save the file","suites":["mock","ContentsManagerMock",".save()"],"updatePoint":{"line":453,"column":30},"line":453,"code":"      it('should save the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'save') {\n            return;\n          }\n          expect(args.newValue!.content).toBe('bar');\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.save(contents.path, { content: 'bar' });\n        expect(called).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","ContentsManagerMock",".dispose()"],"updatePoint":{"line":470,"column":27},"line":470,"code":"      it('should be a no-op', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(() => {\n          manager.dispose();\n        }).not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new session manager","suites":["mock","SessionManagerMock",".constructor()"],"updatePoint":{"line":481,"column":45},"line":481,"code":"      it('should create a new session manager', () => {\n        const manager = new Mock.SessionManagerMock();\n        expect(manager.isReady).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should start a new session","suites":["mock","SessionManagerMock",".startNew()"],"updatePoint":{"line":488,"column":36},"line":488,"code":"      it('should start a new session', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should connect to a session","suites":["mock","SessionManagerMock",".connectTo()"],"updatePoint":{"line":501,"column":37},"line":501,"code":"      it('should connect to a session', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.connectTo({\n          model: {\n            id: 'fizz',\n            path: 'foo',\n            type: 'bar',\n            name: 'baz',\n            kernel: { name: Mock.DEFAULT_NAME, id: 'fuzz' }\n          }\n        });\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should remove a running kernel","suites":["mock","SessionManagerMock",".stopIfNeeded()"],"updatePoint":{"line":517,"column":40},"line":517,"code":"      it('should remove a running kernel', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(toArray(manager.running()).length).toBe(1);\n        await manager.stopIfNeeded(session.path);\n        expect(toArray(manager.running()).length).toBe(0);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","SessionManagerMock",".refreshRunning()"],"updatePoint":{"line":532,"column":27},"line":532,"code":"      it('should be a no-op', async () => {\n        const manager = new Mock.SessionManagerMock();\n        await expect(manager.refreshRunning()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be an iterable of running sessions","suites":["mock","SessionManagerMock",".running()"],"updatePoint":{"line":539,"column":51},"line":539,"code":"      it('should be an iterable of running sessions', async () => {\n        const manager = new Mock.SessionManagerMock();\n        await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(toArray(manager.running()).length).toBe(1);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new mock","suites":["mock","KernelSpecManagerMock",".constructor"],"updatePoint":{"line":554,"column":34},"line":554,"code":"      it('should create a new mock', () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        expect(manager.isReady).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be the kernel specs","suites":["mock","KernelSpecManagerMock",".specs"],"updatePoint":{"line":561,"column":36},"line":561,"code":"      it('should be the kernel specs', () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        expect(manager.specs!.default).toBe(Mock.DEFAULT_NAME);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","KernelSpecManagerMock",".refreshSpecs()"],"updatePoint":{"line":568,"column":27},"line":568,"code":"      it('should be a no-op', async () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        await expect(manager.refreshSpecs()).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new mock","suites":["mock","ServiceManagerMock",".constructor()"],"updatePoint":{"line":577,"column":34},"line":577,"code":"      it('should create a new mock', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.isReady).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should resolve","suites":["mock","ServiceManagerMock",".ready"],"updatePoint":{"line":584,"column":24},"line":584,"code":"      it('should resolve', async () => {\n        const manager = new Mock.ServiceManagerMock();\n        await expect(manager.ready).resolves.not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a contents manager","suites":["mock","ServiceManagerMock",".contents"],"updatePoint":{"line":591,"column":38},"line":591,"code":"      it('should be a contents manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.contents.normalize).toBeTruthy();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a sessions manager","suites":["mock","ServiceManagerMock",".sessions"],"updatePoint":{"line":598,"column":38},"line":598,"code":"      it('should be a sessions manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.sessions.isReady).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a kernelspecs manager","suites":["mock","ServiceManagerMock",".kernelspecs"],"updatePoint":{"line":605,"column":41},"line":605,"code":"      it('should be a kernelspecs manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.kernelspecs.isReady).toBe(true);\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should be a no-op","suites":["mock","ServiceManagerMock",".dispose()"],"updatePoint":{"line":612,"column":27},"line":612,"code":"      it('should be a no-op', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(() => {\n          manager.dispose();\n        }).not.toThrow();\n      });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a new mock","suites":["mock","MockShellFuture"],"updatePoint":{"line":622,"column":32},"line":622,"code":"    it('should create a new mock', async () => {\n      const msg = KernelMessage.createMessage({\n        channel: 'shell',\n        msgType: 'execute_reply',\n        session: 'foo',\n        username: 'bar',\n        msgId: 'fizz',\n        content: {\n          user_expressions: {},\n          execution_count: 0,\n          status: 'ok'\n        }\n      });\n      const future = new Mock.MockShellFuture(msg);\n      const reply = await future.done;\n      expect(reply).toBe(msg);\n      future.dispose();\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a context without a kernel","suites":["mock","createFileContext()"],"updatePoint":{"line":643,"column":48},"line":643,"code":"    it('should create a context without a kernel', async () => {\n      const context = await Mock.createFileContext();\n      expect(context.sessionContext.session).toBe(null);\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should create a context with a kernel","suites":["mock","createFileContext()"],"updatePoint":{"line":648,"column":45},"line":648,"code":"    it('should create a context with a kernel', async () => {\n      const context = await Mock.createFileContext(true);\n      expect(context.sessionContext.session!.kernel!.name).toBe(\n        Mock.DEFAULT_NAME\n      );\n    });","file":"mock.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should start the server","suites":["JupyterServer"],"updatePoint":{"line":10,"column":29},"line":10,"code":"  it('should start the server', async () => {\n    jest.setTimeout(20000);\n    const server = new JupyterServer();\n    const url = await server.start();\n    await fetch(URLExt.join(url, 'api'));\n    await expect(server.shutdown()).resolves.not.toThrow();\n  });","file":"start_jupyter_server.spec.ts","skipped":false,"dir":"testutils/test"},{"name":"should accept options","suites":["JupyterServer"],"updatePoint":{"line":18,"column":27},"line":18,"code":"  it('should accept options', async () => {\n    jest.setTimeout(20000);\n    const pageConfig = { foo: 'bar', fizz: 'buzz' };\n    const configData = {\n      FakeTrait: { fake_prop: 1 },\n      OtherTrait: { other_prop: 'hello' },\n      KernelManager: {\n        shutdown_wait_time: 1.11\n      }\n    };\n    const additionalKernelSpecs = {\n      foo: {\n        argv: ['python', '-m', 'ipykernel_launcher', '-f', '{connection_file}'],\n        display_name: 'Test Python',\n        language: 'python'\n      }\n    };\n    const server = new JupyterServer();\n    const url = await server.start({\n      pageConfig,\n      configData,\n      additionalKernelSpecs\n    });\n    await fetch(URLExt.join(url, 'api'));\n    expect(PageConfig.getOption('foo')).toEqual('bar');\n    expect(PageConfig.getOption('fizz')).toEqual('buzz');\n    expect(PageConfig.getOption('__configData')).toContain('FakeTrait');\n    expect(PageConfig.getOption('__configData')).toContain('OtherTrait');\n    expect(PageConfig.getOption('__configData')).toContain('1.11');\n    expect(PageConfig.getOption('__kernelSpec_foo')).toContain('Test Python');\n    await expect(server.shutdown()).resolves.not.toThrow();\n  });","file":"start_jupyter_server.spec.ts","skipped":false,"dir":"testutils/test"}]}