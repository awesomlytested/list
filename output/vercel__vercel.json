{"repo":"vercel/vercel","url":"https://github.com/vercel/vercel","branch":"main","configs":[{"package":"preact","lang":"js","dir":"examples/preact/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"TODO","lang":"js","dir":"examples/sapper/cypress","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"vercel-monorepo","lang":"js","dir":"test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@vercel/build-utils","lang":"ts","dir":"packages/build-utils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vercel","lang":"js","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"aurelia","lang":"js","dir":"packages/cli/test/dev/fixtures/03-aurelia/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"polymer-starter-kit","lang":"js","dir":"packages/cli/test/dev/fixtures/12-polymer-node/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"hello-world","lang":"js","dir":"packages/cli/test/dev/fixtures/24-ember/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@vercel/client","lang":"ts","dir":"packages/client/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/frameworks","lang":"ts","dir":"packages/frameworks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/go","lang":"js","dir":"packages/go/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"vercel-plugin-middleware","lang":"ts","dir":"packages/middleware/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/node-bridge","lang":"js","dir":"packages/node-bridge/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/node","lang":"js","dir":"packages/node/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vercel-plugin-node","lang":"ts","dir":"packages/plugin-node/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/python","lang":"js","dir":"packages/python/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@vercel/routing-utils","lang":"js","dir":"packages/routing-utils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vercel/ruby","lang":"js","dir":"packages/ruby/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@vercel/static-config","lang":"ts","dir":"packages/static-config/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"Header renders 3 nav items","suites":["Initial Test of the Header"],"updatePoint":{"line":6,"column":34,"index":254},"line":6,"code":"  test('Header renders 3 nav items', () => {\n    const context = shallow( /*#__PURE__*/React.createElement(Header, null));\n    expect(context.find('h1').text()).toBe('Preact App');\n    expect(context.find('Link').length).toBe(3);\n  });","file":"header.test.js","skipped":false,"dir":"examples/preact/tests"},{"name":"has the correct <h1>","suites":["Sapper template app"],"updatePoint":{"line":5,"column":26,"index":113},"line":5,"code":"  it('has the correct <h1>', () => {\n    cy.contains('h1', 'Great success!');\n  });","file":"integration/spec.js","skipped":false,"dir":"examples/sapper/cypress"},{"name":"navigates to /about","suites":["Sapper template app"],"updatePoint":{"line":8,"column":25,"index":196},"line":8,"code":"  it('navigates to /about', () => {\n    cy.get('nav a').contains('about').click();\n    cy.url().should('include', '/about');\n  });","file":"integration/spec.js","skipped":false,"dir":"examples/sapper/cypress"},{"name":"navigates to /blog","suites":["Sapper template app"],"updatePoint":{"line":12,"column":24,"index":326},"line":12,"code":"  it('navigates to /blog', () => {\n    cy.get('nav a').contains('blog').click();\n    cy.url().should('include', '/blog');\n  });","file":"integration/spec.js","skipped":false,"dir":"examples/sapper/cypress"},{"name":"should remove \"Publish\" commits","suites":["changelog","filter"],"updatePoint":{"line":4,"column":39,"index":161},"line":4,"code":"    it('should remove \"Publish\" commits', async () => {\n      const commits = [{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]'\n      }, {\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Publish Stable [Nathan Rajlich]'\n      }];\n      let filteredCommits = filterLog(commits);\n      expect(filteredCommits).toEqual([{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]'\n      }]);\n    });","file":"utils/changelog/filter.test.js","skipped":false,"dir":"test"},{"name":"should remove \"Revert\" and the revertted commits","suites":["changelog","filter"],"updatePoint":{"line":27,"column":56,"index":1045},"line":27,"code":"    it('should remove \"Revert\" and the revertted commits', async () => {\n      const commits = [{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'This reverts commit 17fd88e044a807adf4ee6ed662cdb7c7556e912d.',\n        revertsHashes: ['17fd88e044a807adf4ee6ed662cdb7c7556e912d'],\n        subject: 'Revert \"[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]\"'\n      }, {\n        areas: ['frameworks', 'cli'],\n        hash: '17fd88e044a807adf4ee6ed662cdb7c7556e912d',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[frameworks][cli] Disable blank issues again [Leo Lamprecht]'\n      }, {\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'\n      }];\n      let filteredCommits = filterLog(commits);\n      expect(filteredCommits).toEqual([{\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'\n      }]);\n    });","file":"utils/changelog/filter.test.js","skipped":false,"dir":"test"},{"name":"should NOT remove \"Revert\" if the reverted commit is not in the current changelog entry","suites":["changelog","filter"],"updatePoint":{"line":56,"column":95,"index":2382},"line":56,"code":"    it('should NOT remove \"Revert\" if the reverted commit is not in the current changelog entry', async () => {\n      const commits = [{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'This reverts commit 17fd88e044a807adf4ee6ed662cdb7c7556e912d.',\n        revertsHashes: ['17fd88e044a807adf4ee6ed662cdb7c7556e912d'],\n        subject: 'Revert \"[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]\"'\n      }, {\n        areas: ['frameworks', 'cli'],\n        hash: '29a44db8d9377d7f16146817aded57ebfbcff752',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[frameworks][cli] Disable blank issues again [Leo Lamprecht]'\n      }, {\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'\n      }];\n      let filteredCommits = filterLog(commits);\n      expect(filteredCommits).toEqual([{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'This reverts commit 17fd88e044a807adf4ee6ed662cdb7c7556e912d.',\n        revertsHashes: ['17fd88e044a807adf4ee6ed662cdb7c7556e912d'],\n        subject: 'Revert \"[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]\"'\n      }, {\n        areas: ['frameworks', 'cli'],\n        hash: '29a44db8d9377d7f16146817aded57ebfbcff752',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[frameworks][cli] Disable blank issues again [Leo Lamprecht]'\n      }, {\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'\n      }]);\n    });","file":"utils/changelog/filter.test.js","skipped":false,"dir":"test"},{"name":"should group commits by area","suites":["changelog","group"],"updatePoint":{"line":23,"column":36,"index":976},"line":23,"code":"    it('should group commits by area', async () => {\n      let groupedLogLines = groupLog(commits);\n      expect(groupedLogLines).toEqual({\n        UNCATEGORIZED: ['Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'],\n        frameworks: ['[frameworks][cli] Disable blank issues again [Leo Lamprecht]'],\n        cli: ['[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]', '[frameworks][cli] Disable blank issues again [Leo Lamprecht]']\n      });\n    });","file":"utils/changelog/group.test.js","skipped":false,"dir":"test"},{"name":"should group commits by area","suites":["changelog","parse"],"updatePoint":{"line":7,"column":36,"index":601},"line":7,"code":"    it('should group commits by area', async () => {\n      childProcess.execSync.mockReturnValue(`does some work`);\n      childProcess.execSync.mockReturnValueOnce(`This reverts commit 17fd88e044a807adf4ee6ed662cdb7c7556e912d.`);\n      let commits = parseCommits(logLines);\n      expect(commits).toEqual([{\n        areas: ['cli'],\n        hash: '073f353fcf1944633bb43119c8ffcff46eea0480',\n        message: 'This reverts commit 17fd88e044a807adf4ee6ed662cdb7c7556e912d.',\n        revertsHashes: ['17fd88e044a807adf4ee6ed662cdb7c7556e912d'],\n        subject: '[cli] Add \"outDir\" to `tsconfig.json` (#6566) [Nathan Rajlich]'\n      }, {\n        areas: ['frameworks', 'cli'],\n        hash: '17fd88e044a807adf4ee6ed662cdb7c7556e912d',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: '[frameworks][cli] Disable blank issues again [Leo Lamprecht]'\n      }, {\n        areas: ['UNCATEGORIZED'],\n        hash: 'a1787c740de0d9004e11f7666b6014f820d3c523',\n        message: 'does some work',\n        revertsHashes: [],\n        subject: 'Revert \"[cli] Switch from hardlinks to symlinks in vc build\" (#7054) [Andy]'\n      }]);\n    });","file":"utils/changelog/parse.test.js","skipped":false,"dir":"test"},{"name":"should display welcome message","suites":["workspace-project App"],"updatePoint":{"line":11,"column":36},"line":11,"code":"  it('should display welcome message', () => {\n    page.navigateTo();\n    expect(page.getTitleText()).toEqual('angular app is running!');\n  });","file":"fixtures/03-zero-config-angular/e2e/src/app.e2e-spec.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create the app","suites":["AppComponent"],"updatePoint":{"line":11,"column":27},"line":11,"code":"  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  });","file":"fixtures/03-zero-config-angular/src/app/app.component.spec.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should have as title 'angular'","suites":["AppComponent"],"updatePoint":{"line":17,"column":36},"line":17,"code":"  it(`should have as title 'angular'`, () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('angular');\n  });","file":"fixtures/03-zero-config-angular/src/app/app.component.spec.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should render title","suites":["AppComponent"],"updatePoint":{"line":23,"column":25},"line":23,"code":"  it('should render title', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('.content span').textContent).toContain(\n      'angular app is running!'\n    );\n  });","file":"fixtures/03-zero-config-angular/src/app/app.component.spec.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"Should build \"\"","suites":[],"updatePoint":{"line":35,"column":31},"line":35,"code":"  it(`Should build \"${fixture}\"`, async () => {\n    await expect(\n      testDeployment(path.join(fixturesPath, fixture))\n    ).resolves.toBeDefined();\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"Should build \"/\"","suites":[],"updatePoint":{"line":58,"column":46},"line":58,"code":"      it(`Should build \"${builder}/${fixture}\"`, async () => {\n        await expect(\n          testDeployment(path.join(fixturesPath2, fixture))\n        ).resolves.toBeDefined();\n      });","file":"integration.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should clone env with Path","suites":[],"updatePoint":{"line":3,"column":30},"line":3,"code":"it('should clone env with Path', () => {\n  expect(\n    cloneEnv(\n      new Proxy(\n        {\n          foo: 'bar',\n          Path: 'baz',\n        },\n        {\n          get(target: typeof process.env, prop: string) {\n            if (prop === 'PATH') {\n              return target.PATH ?? target.Path;\n            }\n            return target[prop];\n          },\n        }\n      )\n    )\n  ).toEqual({\n    foo: 'bar',\n    PATH: 'baz',\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should clone env with PATH","suites":[],"updatePoint":{"line":27,"column":30},"line":27,"code":"it('should clone env with PATH', () => {\n  expect(\n    cloneEnv({\n      foo: 'bar',\n      PATH: 'baz',\n    })\n  ).toEqual({\n    foo: 'bar',\n    PATH: 'baz',\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not overwrite PATH when path is undefined","suites":[],"updatePoint":{"line":39,"column":52},"line":39,"code":"it('should not overwrite PATH when path is undefined', () => {\n  expect(\n    cloneEnv(\n      {\n        PATH: 'baz',\n      },\n      new Proxy(\n        {\n          Path: undefined,\n        },\n        {\n          get(target: typeof process.env, prop: string) {\n            if (prop === 'PATH') {\n              return target.PATH ?? target.Path;\n            }\n            return target[prop];\n          },\n        }\n      )\n    )\n  ).toEqual({\n    PATH: 'baz',\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should clone and merge multiple env objects","suites":[],"updatePoint":{"line":64,"column":47},"line":64,"code":"it('should clone and merge multiple env objects', () => {\n  // note: this also tests the last object doesn't overwrite `PATH` with\n  // `undefined`\n  expect(\n    cloneEnv(\n      {\n        foo: 'bar',\n      },\n      {\n        PATH: 'baz',\n      },\n      {\n        baz: 'wiz',\n      }\n    )\n  ).toEqual({\n    foo: 'bar',\n    PATH: 'baz',\n    baz: 'wiz',\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should clone the actual process.env object","suites":[],"updatePoint":{"line":86,"column":46},"line":86,"code":"it('should clone the actual process.env object', () => {\n  expect(cloneEnv(process.env).PATH).toEqual(process.env.PATH);\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should overwrite PATH with last value","suites":[],"updatePoint":{"line":90,"column":41},"line":90,"code":"it('should overwrite PATH with last value', () => {\n  expect(\n    cloneEnv(\n      new Proxy(\n        {\n          Path: 'foo',\n        },\n        {\n          get(target: typeof process.env, prop: string) {\n            if (prop === 'PATH') {\n              return target.PATH ?? target.Path;\n            }\n            return target[prop];\n          },\n        }\n      ),\n      {\n        PATH: 'bar',\n      },\n      {\n        PATH: undefined,\n      }\n    )\n  ).toEqual({\n    PATH: undefined,\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should handle process.env at any argument position","suites":[],"updatePoint":{"line":118,"column":54},"line":118,"code":"it('should handle process.env at any argument position', () => {\n  expect(\n    cloneEnv(\n      {\n        foo: 'bar',\n      },\n      new Proxy(\n        {\n          Path: 'baz',\n        },\n        {\n          get(target: typeof process.env, prop: string) {\n            if (prop === 'PATH') {\n              return target.PATH ?? target.Path;\n            }\n            return target[prop];\n          },\n        }\n      )\n    )\n  ).toEqual({\n    foo: 'bar',\n    PATH: 'baz',\n  });\n});","file":"unit.clone-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should re-create FileFsRef symlinks properly","suites":["download()"],"updatePoint":{"line":20,"column":50},"line":20,"code":"  it('should re-create FileFsRef symlinks properly', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n    const files = await glob('**', path.join(__dirname, 'symlinks'));\n    assert.equal(Object.keys(files).length, 4);\n\n    const outDir = path.join(__dirname, 'symlinks-out');\n    await fs.remove(outDir);\n\n    const files2 = await download(files, outDir);\n    assert.equal(Object.keys(files2).length, 4);\n\n    const [linkStat, linkDirStat, aStat] = await Promise.all([\n      fs.lstat(path.join(outDir, 'link.txt')),\n      fs.lstat(path.join(outDir, 'link-dir')),\n      fs.lstat(path.join(outDir, 'a.txt')),\n    ]);\n    assert(linkStat.isSymbolicLink());\n    assert(linkDirStat.isSymbolicLink());\n    assert(aStat.isFile());\n\n    const [linkDirContents, linkTextContents] = await Promise.all([\n      readlink(path.join(outDir, 'link-dir')),\n      readlink(path.join(outDir, 'link.txt')),\n    ]);\n\n    strictEqual(linkDirContents, 'dir');\n    strictEqual(linkTextContents, './a.txt');\n  });","file":"unit.download.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should re-create FileBlob symlinks properly","suites":["download()"],"updatePoint":{"line":52,"column":49},"line":52,"code":"  it('should re-create FileBlob symlinks properly', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n\n    const files = {\n      'a.txt': new FileBlob({\n        mode: 33188,\n        contentType: undefined,\n        data: 'a text',\n      }),\n      'dir/b.txt': new FileBlob({\n        mode: 33188,\n        contentType: undefined,\n        data: 'b text',\n      }),\n      'link-dir': new FileBlob({\n        mode: 41453,\n        contentType: undefined,\n        data: 'dir',\n      }),\n      'link.txt': new FileBlob({\n        mode: 41453,\n        contentType: undefined,\n        data: 'a.txt',\n      }),\n    };\n\n    strictEqual(Object.keys(files).length, 4);\n\n    const outDir = path.join(__dirname, 'symlinks-out');\n    await fs.remove(outDir);\n\n    const files2 = await download(files, outDir);\n    strictEqual(Object.keys(files2).length, 4);\n\n    const [linkStat, linkDirStat, aStat, dirStat] = await Promise.all([\n      fs.lstat(path.join(outDir, 'link.txt')),\n      fs.lstat(path.join(outDir, 'link-dir')),\n      fs.lstat(path.join(outDir, 'a.txt')),\n      fs.lstat(path.join(outDir, 'dir')),\n    ]);\n\n    assert(linkStat.isSymbolicLink());\n    assert(linkDirStat.isSymbolicLink());\n    assert(aStat.isFile());\n    assert(dirStat.isDirectory());\n\n    const [linkDirContents, linkTextContents] = await Promise.all([\n      readlink(path.join(outDir, 'link-dir')),\n      readlink(path.join(outDir, 'link.txt')),\n    ]);\n\n    strictEqual(linkDirContents, 'dir');\n    strictEqual(linkTextContents, 'a.txt');\n  });","file":"unit.download.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should download symlinks even with incorrect file","suites":["download()"],"updatePoint":{"line":110,"column":55},"line":110,"code":"  it('should download symlinks even with incorrect file', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n    const files = {\n      'dir/file.txt': new FileBlob({\n        mode: 33188,\n        contentType: undefined,\n        data: 'file text',\n      }),\n      linkdir: new FileBlob({\n        mode: 41453,\n        contentType: undefined,\n        data: 'dir',\n      }),\n      'linkdir/file.txt': new FileBlob({\n        mode: 33188,\n        contentType: undefined,\n        data: 'this file should be discarded',\n      }),\n    };\n\n    const outDir = path.join(__dirname, 'symlinks-out');\n    await fs.remove(outDir);\n    await fs.mkdirp(outDir);\n\n    await download(files, outDir);\n\n    const [dir, file, linkdir] = await Promise.all([\n      fs.lstat(path.join(outDir, 'dir')),\n      fs.lstat(path.join(outDir, 'dir/file.txt')),\n      fs.lstat(path.join(outDir, 'linkdir')),\n    ]);\n    expect(dir.isFile()).toBe(false);\n    expect(dir.isSymbolicLink()).toBe(false);\n\n    expect(file.isFile()).toBe(true);\n    expect(file.isSymbolicLink()).toBe(false);\n\n    expect(linkdir.isSymbolicLink()).toBe(true);\n\n    expect(warningMessages).toEqual([\n      'Warning: file \"linkdir/file.txt\" is within a symlinked directory \"linkdir\" and will be ignored',\n    ]);\n  });","file":"unit.download.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create empty directory entries","suites":["download()"],"updatePoint":{"line":157,"column":43},"line":157,"code":"  it('should create empty directory entries', async () => {\n    const outDir = path.join(__dirname, 'symlinks-out');\n    await fs.remove(outDir);\n    const files = {\n      'empty-dir': new FileBlob({\n        mode: 16877, // drwxr-xr-x\n        contentType: undefined,\n        data: '',\n      }),\n      dir: new FileBlob({\n        mode: 16877,\n        contentType: undefined,\n        data: '',\n      }),\n      'dir/subdir': new FileBlob({\n        mode: 16877,\n        contentType: undefined,\n        data: '',\n      }),\n      'another/subdir': new FileBlob({\n        mode: 16895, // drwxrwxrwx\n        contentType: undefined,\n        data: '',\n      }),\n    };\n\n    await download(files, outDir);\n\n    for (const [p, f] of Object.entries(files)) {\n      const stat = await fs.lstat(path.join(outDir, p));\n      expect(stat.isDirectory()).toEqual(true);\n\n      if (process.platform !== 'win32') {\n        // Don't test Windows since it doesn't support the same permissions\n        expect(stat.mode).toEqual(f.mode);\n      }\n    }\n  });","file":"unit.download.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with npm7","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":5,"column":27},"line":5,"code":"  it('should work with npm7', async () => {\n    const cwd = join(__dirname, 'fixtures', '20-npm-7');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with yarn","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":11,"column":27},"line":11,"code":"  it('should work with yarn', async () => {\n    const cwd = join(__dirname, 'fixtures', '19-yarn-v2');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with npm 6","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":17,"column":28},"line":17,"code":"  it('should work with npm 6', async () => {\n    const cwd = join(__dirname, 'fixtures', '08-yarn-npm/with-npm');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with npm workspaces","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":23,"column":37},"line":23,"code":"  it('should work with npm workspaces', async () => {\n    const cwd = join(__dirname, 'fixtures', '21-npm-workspaces/a');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, '..', 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with pnpm","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":29,"column":27},"line":29,"code":"  it('should work with pnpm', async () => {\n    const cwd = join(__dirname, 'fixtures', '22-pnpm');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should work with pnpm workspaces","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":35,"column":38},"line":35,"code":"  it('should work with pnpm workspaces', async () => {\n    const cwd = join(__dirname, 'fixtures', '23-pnpm-workspaces/c');\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, '..', 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should fallback to cwd if no lockfile found","suites":["Test `getNodeBinPath()`"],"updatePoint":{"line":41,"column":49},"line":41,"code":"  it('should fallback to cwd if no lockfile found', async () => {\n    const cwd = parse(process.cwd()).root;\n    const result = await getNodeBinPath({ cwd });\n    expect(result).toBe(join(cwd, 'node_modules', '.bin'));\n  });","file":"unit.get-node-bin-path.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return array of `node_modules/.bin` paths","suites":["getNodeBinPaths()"],"updatePoint":{"line":7,"column":54},"line":7,"code":"  it('should return array of `node_modules/.bin` paths', () => {\n    const start = join(cwd, 'foo/bar/baz');\n    const paths = getNodeBinPaths({ start, base: cwd });\n    expect(paths).toEqual([\n      join(cwd, 'foo/bar/baz/node_modules/.bin'),\n      join(cwd, 'foo/bar/node_modules/.bin'),\n      join(cwd, 'foo/node_modules/.bin'),\n      join(cwd, 'node_modules/.bin'),\n    ]);\n  });","file":"unit.get-node-bin-paths.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should support `VERCEL_` prefix","suites":["Test `getPlatformEnv()`"],"updatePoint":{"line":5,"column":37},"line":5,"code":"  it('should support `VERCEL_` prefix', () => {\n    try {\n      assert.equal(undefined, getPlatformEnv('FOO'));\n\n      process.env.VERCEL_FOO = 'bar';\n      assert.equal('bar', getPlatformEnv('FOO'));\n    } finally {\n      delete process.env.VERCEL_FOO;\n    }\n  });","file":"unit.get-platform-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should support `NOW_` prefix","suites":["Test `getPlatformEnv()`"],"updatePoint":{"line":16,"column":34},"line":16,"code":"  it('should support `NOW_` prefix', () => {\n    try {\n      assert.equal(undefined, getPlatformEnv('FOO'));\n\n      process.env.NOW_FOO = 'bar';\n      assert.equal('bar', getPlatformEnv('FOO'));\n    } finally {\n      delete process.env.NOW_FOO;\n    }\n  });","file":"unit.get-platform-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw an error if both env vars exist","suites":["Test `getPlatformEnv()`"],"updatePoint":{"line":27,"column":50},"line":27,"code":"  it('should throw an error if both env vars exist', () => {\n    let err: Error | null = null;\n    try {\n      process.env.NOW_FOO = 'bar';\n      process.env.VERCEL_FOO = 'baz';\n      getPlatformEnv('FOO');\n    } catch (_err: unknown) {\n      err = _err as Error;\n    } finally {\n      delete process.env.NOW_FOO;\n      delete process.env.VERCEL_FOO;\n    }\n    assert(err);\n    assert.equal(\n      err!.message,\n      'Both \"VERCEL_FOO\" and \"NOW_FOO\" env vars are defined. Please only define the \"VERCEL_FOO\" env var.'\n    );\n  });","file":"unit.get-platform-env.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return \"vercel-*\"","suites":["Test `getScriptName()`"],"updatePoint":{"line":5,"column":30},"line":5,"code":"  it('should return \"vercel-*\"', () => {\n    const pkg = {\n      scripts: {\n        'vercel-dev': '',\n        'vercel-build': '',\n        dev: '',\n        build: '',\n      },\n    };\n    assert.equal(\n      getScriptName(pkg, ['vercel-dev', 'now-dev', 'dev']),\n      'vercel-dev'\n    );\n    assert.equal(\n      getScriptName(pkg, ['vercel-build', 'now-build', 'build']),\n      'vercel-build'\n    );\n    assert.equal(getScriptName(pkg, ['dev']), 'dev');\n    assert.equal(getScriptName(pkg, ['build']), 'build');\n  });","file":"unit.get-script-name.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return \"now-*\"","suites":["Test `getScriptName()`"],"updatePoint":{"line":26,"column":27},"line":26,"code":"  it('should return \"now-*\"', () => {\n    const pkg = {\n      scripts: {\n        'now-dev': '',\n        'now-build': '',\n        dev: '',\n        build: '',\n      },\n    };\n    assert.equal(\n      getScriptName(pkg, ['vercel-dev', 'now-dev', 'dev']),\n      'now-dev'\n    );\n    assert.equal(\n      getScriptName(pkg, ['vercel-build', 'now-build', 'build']),\n      'now-build'\n    );\n    assert.equal(getScriptName(pkg, ['dev']), 'dev');\n    assert.equal(getScriptName(pkg, ['build']), 'build');\n  });","file":"unit.get-script-name.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return base script name","suites":["Test `getScriptName()`"],"updatePoint":{"line":47,"column":36},"line":47,"code":"  it('should return base script name', () => {\n    const pkg = {\n      scripts: {\n        dev: '',\n        build: '',\n      },\n    };\n    assert.equal(getScriptName(pkg, ['dev']), 'dev');\n    assert.equal(getScriptName(pkg, ['build']), 'build');\n  });","file":"unit.get-script-name.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return `null`","suites":["Test `getScriptName()`"],"updatePoint":{"line":58,"column":26},"line":58,"code":"  it('should return `null`', () => {\n    assert.equal(getScriptName(undefined, ['build']), null);\n    assert.equal(getScriptName({}, ['build']), null);\n    assert.equal(getScriptName({ scripts: {} }, ['build']), null);\n\n    const pkg = {\n      scripts: {\n        dev: '',\n        build: '',\n      },\n    };\n    assert.equal(getScriptName(pkg, ['vercel-dev', 'now-dev']), null);\n    assert.equal(getScriptName(pkg, ['vercel-build', 'now-build']), null);\n  });","file":"unit.get-script-name.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not return entries for empty directories by default","suites":["glob()"],"updatePoint":{"line":7,"column":64},"line":7,"code":"  it('should not return entries for empty directories by default', async () => {\n    const dir = await fs.mkdtemp(join(tmpdir(), 'build-utils-test'));\n    try {\n      await Promise.all([\n        fs.writeFile(join(dir, 'root.txt'), 'file at the root'),\n        fs.mkdirp(join(dir, 'empty-dir')),\n        fs\n          .mkdirp(join(dir, 'dir-with-file'))\n          .then(() =>\n            fs.writeFile(join(dir, 'dir-with-file/data.json'), '{\"a\":\"b\"}')\n          ),\n        fs.mkdirp(join(dir, 'another/subdir')),\n      ]);\n      const files = await glob('**', dir);\n      const fileNames = Object.keys(files).sort();\n      expect(fileNames).toHaveLength(2);\n      expect(fileNames).toEqual(['dir-with-file/data.json', 'root.txt']);\n      expect(isDirectory(files['dir-with-file/data.json'].mode)).toEqual(false);\n      expect(isDirectory(files['root.txt'].mode)).toEqual(false);\n      expect(files['dir-with-file']).toBeUndefined();\n      expect(files['another/subdir']).toBeUndefined();\n      expect(files['empty-dir']).toBeUndefined();\n    } finally {\n      await fs.remove(dir);\n    }\n  });","file":"unit.glob.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return entries for empty directories with `includeDirectories: true`","suites":["glob()"],"updatePoint":{"line":34,"column":81},"line":34,"code":"  it('should return entries for empty directories with `includeDirectories: true`', async () => {\n    const dir = await fs.mkdtemp(join(tmpdir(), 'build-utils-test'));\n    try {\n      await Promise.all([\n        fs.writeFile(join(dir, 'root.txt'), 'file at the root'),\n        fs.mkdirp(join(dir, 'empty-dir')),\n        fs\n          .mkdirp(join(dir, 'dir-with-file'))\n          .then(() =>\n            fs.writeFile(join(dir, 'dir-with-file/data.json'), '{\"a\":\"b\"}')\n          ),\n        fs.mkdirp(join(dir, 'another/subdir')),\n      ]);\n      const files = await glob('**', { cwd: dir, includeDirectories: true });\n      const fileNames = Object.keys(files).sort();\n      expect(fileNames).toHaveLength(4);\n      expect(fileNames).toEqual([\n        'another/subdir',\n        'dir-with-file/data.json',\n        'empty-dir',\n        'root.txt',\n      ]);\n      expect(isDirectory(files['another/subdir'].mode)).toEqual(true);\n      expect(isDirectory(files['empty-dir'].mode)).toEqual(true);\n      expect(isDirectory(files['dir-with-file/data.json'].mode)).toEqual(false);\n      expect(isDirectory(files['root.txt'].mode)).toEqual(false);\n      expect(files['dir-with-file']).toBeUndefined();\n    } finally {\n      await fs.remove(dir);\n    }\n  });","file":"unit.glob.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should allow for following symlinks","suites":["glob()"],"updatePoint":{"line":66,"column":41},"line":66,"code":"  it('should allow for following symlinks', async () => {\n    const rootDir = await fs.mkdtemp(join(tmpdir(), 'build-utils-test'));\n    const dir = await fs.mkdtemp(join(rootDir, 'build-utils-test'));\n    try {\n      await Promise.all([\n        fs.writeFile(join(rootDir, 'root.txt'), 'file outside of \"dir\"'),\n        fs.writeFile(join(dir, 'root.txt'), 'file at the root'),\n        fs.mkdirp(join(dir, 'empty-dir')),\n        fs\n          .mkdirp(join(dir, 'dir-with-file'))\n          .then(() =>\n            fs.writeFile(join(dir, 'dir-with-file/data.json'), '{\"a\":\"b\"}')\n          ),\n        fs.mkdirp(join(dir, 'another/subdir')),\n        fs.symlink('root.txt', join(dir, 'root-link')),\n        fs.symlink(join(dir, 'root.txt'), join(dir, 'abs-root-link')),\n        fs.symlink('dir-with-file', join(dir, 'dir-link')),\n        fs.symlink('empty-dir', join(dir, 'empty-dir-link')),\n        fs.symlink('../root.txt', join(dir, 'outside-cwd-link')),\n        fs.symlink(join(dir, '../root.txt'), join(dir, 'abs-outside-cwd-link')),\n      ]);\n      const files = await glob('**', { cwd: dir, follow: true });\n      const fileNames = Object.keys(files).sort();\n      expect(fileNames).toHaveLength(5);\n      expect(fileNames).toEqual([\n        'abs-root-link',\n        'dir-link/data.json',\n        'dir-with-file/data.json',\n        'root-link',\n        'root.txt',\n      ]);\n      for (const file of Object.values(files)) {\n        expect(isSymbolicLink(file.mode)).toEqual(false);\n      }\n    } finally {\n      await fs.remove(dir);\n    }\n  });","file":"unit.glob.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create zip file with symlinks","suites":["Lambda"],"updatePoint":{"line":11,"column":42},"line":11,"code":"  it('should create zip file with symlinks', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n    const files = await glob('**', path.join(__dirname, 'symlinks'));\n    expect(Object.keys(files)).toHaveLength(4);\n\n    const outFile = path.join(__dirname, 'symlinks.zip');\n    await fs.remove(outFile);\n\n    const outDir = path.join(__dirname, 'symlinks-out');\n    await fs.remove(outDir);\n    await fs.mkdirp(outDir);\n\n    await fs.writeFile(outFile, await createZip(files));\n    await spawnAsync('unzip', [outFile], { cwd: outDir });\n\n    const [linkStat, linkDirStat, aStat] = await Promise.all([\n      fs.lstat(path.join(outDir, 'link.txt')),\n      fs.lstat(path.join(outDir, 'link-dir')),\n      fs.lstat(path.join(outDir, 'a.txt')),\n    ]);\n    expect(linkStat.isSymbolicLink()).toEqual(true);\n    expect(linkDirStat.isSymbolicLink()).toEqual(true);\n    expect(aStat.isFile()).toEqual(true);\n  });","file":"unit.lambda.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create zip file with empty directory","suites":["Lambda"],"updatePoint":{"line":39,"column":49},"line":39,"code":"  it('should create zip file with empty directory', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n\n    const dir = await fs.mkdtemp(path.join(tmpdir(), 'create-zip-empty-dir'));\n    try {\n      const files = {\n        a: new FileBlob({\n          data: 'contents',\n          mode: MODE_FILE,\n        }),\n        empty: new FileBlob({\n          data: '',\n          mode: MODE_DIRECTORY,\n        }),\n        'b/a': new FileBlob({\n          data: 'inside dir b',\n          mode: MODE_FILE,\n        }),\n        c: new FileBlob({\n          data: '',\n          mode: MODE_DIRECTORY,\n        }),\n        'c/a': new FileBlob({\n          data: 'inside dir c',\n          mode: MODE_FILE,\n        }),\n      };\n\n      const outFile = path.join(dir, 'lambda.zip');\n\n      const outDir = path.join(dir, 'out');\n      await fs.mkdirp(outDir);\n\n      await fs.writeFile(outFile, await createZip(files));\n      await spawnAsync('unzip', [outFile], { cwd: outDir });\n\n      expect(fs.statSync(path.join(outDir, 'empty')).isDirectory()).toEqual(\n        true\n      );\n      expect(fs.statSync(path.join(outDir, 'b')).isDirectory()).toEqual(true);\n      expect(fs.statSync(path.join(outDir, 'c')).isDirectory()).toEqual(true);\n      expect(fs.readFileSync(path.join(outDir, 'a'), 'utf8')).toEqual(\n        'contents'\n      );\n      expect(fs.readFileSync(path.join(outDir, 'b/a'), 'utf8')).toEqual(\n        'inside dir b'\n      );\n      expect(fs.readFileSync(path.join(outDir, 'c/a'), 'utf8')).toEqual(\n        'inside dir c'\n      );\n      expect(fs.readdirSync(path.join(outDir, 'empty'))).toHaveLength(0);\n    } finally {\n      await fs.remove(dir);\n    }\n  });","file":"unit.lambda.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create an instance","suites":["Test `NodejsLambda`"],"updatePoint":{"line":4,"column":31},"line":4,"code":"  it('should create an instance', () => {\n    const helloSrc = 'module.exports = (req, res) => res.end(\"hi\");';\n    const lambda = new NodejsLambda({\n      files: {\n        'api/hello.js': new FileBlob({ data: helloSrc }),\n      },\n      handler: 'api/hello.js',\n      runtime: 'node14.x',\n      shouldAddHelpers: true,\n      shouldAddSourcemapSupport: false,\n    });\n    expect(lambda.handler).toEqual('api/hello.js');\n    expect(lambda.runtime).toEqual('node14.x');\n    expect(lambda.shouldAddHelpers).toEqual(true);\n    expect(lambda.shouldAddSourcemapSupport).toEqual(false);\n    expect(lambda.awsLambdaHandler).toBeUndefined();\n  });","file":"unit.nodejs-lambda.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return null when file does not exist","suites":["Test `readConfigFile()`"],"updatePoint":{"line":24,"column":49},"line":24,"code":"  it('should return null when file does not exist', async () => {\n    expect(await readConfigFile(doesnotexist)).toBeNull();\n    expect(logMessages).toEqual([]);\n  });","file":"unit.read-config-file.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return parsed object when file exists","suites":["Test `readConfigFile()`"],"updatePoint":{"line":29,"column":50},"line":29,"code":"  it('should return parsed object when file exists', async () => {\n    expect(await readConfigFile(tsconfig)).toMatchObject({\n      compilerOptions: {\n        strict: true,\n      },\n    });\n    expect(logMessages).toEqual([]);\n  });","file":"unit.read-config-file.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return parsed object when at least one file exists","suites":["Test `readConfigFile()`"],"updatePoint":{"line":38,"column":63},"line":38,"code":"  it('should return parsed object when at least one file exists', async () => {\n    const files = [doesnotexist, tsconfig];\n    expect(await readConfigFile(files)).toMatchObject({\n      compilerOptions: {\n        strict: true,\n      },\n    });\n    expect(logMessages).toEqual([]);\n  });","file":"unit.read-config-file.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return null when parse fails","suites":["Test `readConfigFile()`"],"updatePoint":{"line":48,"column":41},"line":48,"code":"  it('should return null when parse fails', async () => {\n    try {\n      await writeFile(invalid, 'borked');\n      expect(await readConfigFile(invalid)).toBeNull();\n    } finally {\n      await rm(invalid);\n    }\n    expect(logMessages.length).toBe(1);\n    expect(logMessages[0]).toMatch(\n      /^Error while parsing config file.+invalid.json/\n    );\n  });","file":"unit.read-config-file.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return parsed object when at least one file is valid","suites":["Test `readConfigFile()`"],"updatePoint":{"line":61,"column":65},"line":61,"code":"  it('should return parsed object when at least one file is valid', async () => {\n    try {\n      await writeFile(invalid, 'borked');\n      expect(await readConfigFile([invalid, tsconfig])).toMatchObject({\n        compilerOptions: {\n          strict: true,\n        },\n      });\n    } finally {\n      await rm(invalid);\n    }\n    expect(logMessages.length).toBe(1);\n    expect(logMessages[0]).toMatch(\n      /^Error while parsing config file.+invalid.json/\n    );\n  });","file":"unit.read-config-file.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not include peer dependencies when missing VERCEL_NPM_LEGACY_PEER_DEPS on node16","suites":[],"updatePoint":{"line":36,"column":91},"line":36,"code":"it('should not include peer dependencies when missing VERCEL_NPM_LEGACY_PEER_DEPS on node16', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  const meta: Meta = {};\n  const spawnOpts = getTestSpawnOpts({});\n  const nodeVersion = getNodeVersion(16);\n  await runNpmInstall(fixture, [], spawnOpts, meta, nodeVersion);\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('npm');\n  expect(args[1]).toEqual(['install', '--no-audit', '--unsafe-perm']);\n  expect(args[2]).toEqual({\n    cwd: fixture,\n    prettyCommand: 'npm install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node16","suites":[],"updatePoint":{"line":54,"column":81},"line":54,"code":"it('should include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node16', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  const meta: Meta = {};\n  const spawnOpts = getTestSpawnOpts({ VERCEL_NPM_LEGACY_PEER_DEPS: '1' });\n  const nodeVersion = getNodeVersion(16);\n  await runNpmInstall(fixture, [], spawnOpts, meta, nodeVersion);\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('npm');\n  expect(args[1]).toEqual([\n    'install',\n    '--no-audit',\n    '--unsafe-perm',\n    '--legacy-peer-deps',\n  ]);\n  expect(args[2]).toEqual({\n    cwd: fixture,\n    prettyCommand: 'npm install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node14 and npm7+","suites":[],"updatePoint":{"line":77,"column":91},"line":77,"code":"it('should include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node14 and npm7+', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  const meta: Meta = {};\n  const spawnOpts = getTestSpawnOpts({ VERCEL_NPM_LEGACY_PEER_DEPS: '1' });\n\n  const nodeVersion = getNodeVersion(14);\n  await runNpmInstall(fixture, [], spawnOpts, meta, nodeVersion);\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('npm');\n  expect(args[1]).toEqual([\n    'install',\n    '--no-audit',\n    '--unsafe-perm',\n    '--legacy-peer-deps',\n  ]);\n  expect(args[2]).toEqual({\n    cwd: fixture,\n    prettyCommand: 'npm install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node14 and npm6","suites":[],"updatePoint":{"line":101,"column":94},"line":101,"code":"it('should not include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node14 and npm6', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '14-npm-6-legacy-peer-deps');\n  const meta: Meta = {};\n  const spawnOpts = getTestSpawnOpts({ VERCEL_NPM_LEGACY_PEER_DEPS: '1' });\n\n  const nodeVersion = getNodeVersion(14);\n  await runNpmInstall(fixture, [], spawnOpts, meta, nodeVersion);\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('npm');\n  expect(args[1]).toEqual(['install', '--no-audit', '--unsafe-perm']);\n  expect(args[2]).toEqual({\n    cwd: fixture,\n    prettyCommand: 'npm install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node16 with corepack enabled","suites":[],"updatePoint":{"line":120,"column":107},"line":120,"code":"it('should not include peer dependencies when VERCEL_NPM_LEGACY_PEER_DEPS=1 on node16 with corepack enabled', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  const meta: Meta = {};\n  const spawnOpts = getTestSpawnOpts({\n    VERCEL_NPM_LEGACY_PEER_DEPS: '1',\n    ENABLE_EXPERIMENTAL_COREPACK: '1',\n  });\n  const nodeVersion = getNodeVersion(16);\n  await runNpmInstall(fixture, [], spawnOpts, meta, nodeVersion);\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('npm');\n  expect(args[1]).toEqual(['install', '--no-audit', '--unsafe-perm']);\n  expect(args[2]).toEqual({\n    cwd: fixture,\n    prettyCommand: 'npm install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should only invoke `runNpmInstall()` once per `package.json` file (serial)","suites":[],"updatePoint":{"line":141,"column":78},"line":141,"code":"it('should only invoke `runNpmInstall()` once per `package.json` file (serial)', async () => {\n  const meta: Meta = {};\n  const fixture = path.join(__dirname, 'fixtures', '02-zero-config-api');\n  const apiDir = path.join(fixture, 'api');\n\n  const run1 = await runNpmInstall(apiDir, [], undefined, meta);\n  expect(run1).toEqual(true);\n  expect(\n    (meta.runNpmInstallSet as Set<string>).has(\n      path.join(fixture, 'package.json')\n    )\n  ).toEqual(true);\n\n  const run2 = await runNpmInstall(apiDir, [], undefined, meta);\n  expect(run2).toEqual(false);\n\n  const run3 = await runNpmInstall(fixture, [], undefined, meta);\n  expect(run3).toEqual(false);\n\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('yarn');\n  expect(args[1]).toEqual(['install']);\n  expect(args[2]).toEqual({\n    cwd: apiDir,\n    prettyCommand: 'yarn install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should only invoke `runNpmInstall()` once per `package.json` file (parallel)","suites":[],"updatePoint":{"line":172,"column":80},"line":172,"code":"it('should only invoke `runNpmInstall()` once per `package.json` file (parallel)', async () => {\n  const meta: Meta = {};\n  const fixture = path.join(__dirname, 'fixtures', '02-zero-config-api');\n  const apiDir = path.join(fixture, 'api');\n  const [run1, run2, run3] = await Promise.all([\n    runNpmInstall(apiDir, [], undefined, meta),\n    runNpmInstall(apiDir, [], undefined, meta),\n    runNpmInstall(fixture, [], undefined, meta),\n  ]);\n  expect(run1).toEqual(true);\n  expect(run2).toEqual(false);\n  expect(run3).toEqual(false);\n  expect(\n    (meta.runNpmInstallSet as Set<string>).has(\n      path.join(fixture, 'package.json')\n    )\n  ).toEqual(true);\n\n  expect(spawnMock.mock.calls.length).toBe(1);\n  const args = spawnMock.mock.calls[0];\n  expect(args[0]).toEqual('yarn');\n  expect(args[1]).toEqual(['install']);\n  expect(args[2]).toEqual({\n    cwd: apiDir,\n    prettyCommand: 'yarn install',\n    stdio: 'inherit',\n    env: expect.any(Object),\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw error when install failed - yarn","suites":[],"updatePoint":{"line":202,"column":49},"line":202,"code":"it('should throw error when install failed - yarn', async () => {\n  spawnExitCode = 1;\n  const meta: Meta = {};\n  const fixture = path.join(__dirname, 'fixtures', '19-yarn-v2');\n  await expect(\n    runNpmInstall(fixture, [], undefined, meta)\n  ).rejects.toMatchObject({\n    name: 'Error',\n    message: 'Command \"yarn install\" exited with 1',\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw error when install failed - npm","suites":[],"updatePoint":{"line":214,"column":48},"line":214,"code":"it('should throw error when install failed - npm', async () => {\n  spawnExitCode = 1;\n  const meta: Meta = {};\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  await expect(\n    runNpmInstall(fixture, [], undefined, meta)\n  ).rejects.toMatchObject({\n    name: 'Error',\n    message: 'Command \"npm install\" exited with 1',\n  });\n});","file":"unit.run-npm-install.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should execute a command","suites":[],"updatePoint":{"line":3,"column":28},"line":3,"code":"it('should execute a command', async () => {\n  // should resolve (it doesn't return anything, so it resolves with \"undefined\")\n  await expect(spawnAsync('echo', ['hello'])).resolves.toBeUndefined();\n});","file":"unit.spawn-async.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw if the command exits with non-0 code","suites":[],"updatePoint":{"line":8,"column":53},"line":8,"code":"it('should throw if the command exits with non-0 code', async () => {\n  await expect(spawnAsync('find', ['unknown-file'])).rejects.toBeInstanceOf(\n    NowBuildError\n  );\n});","file":"unit.spawn-async.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return if the command exits with non-0 code and ignoreNon0Exit=true","suites":[],"updatePoint":{"line":14,"column":78},"line":14,"code":"it('should return if the command exits with non-0 code and ignoreNon0Exit=true', async () => {\n  // should resolve (it doesn't return anything, so it resolves with \"undefined\")\n  await expect(\n    spawnAsync('find', ['unknown-file'], {\n      ignoreNon0Exit: true,\n    })\n  ).resolves.toBeUndefined();\n});","file":"unit.spawn-async.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should only match supported node versions, otherwise throw an error","suites":[],"updatePoint":{"line":52,"column":71},"line":52,"code":"it('should only match supported node versions, otherwise throw an error', async () => {\n  expect(await getSupportedNodeVersion('14.x', false)).toHaveProperty(\n    'major',\n    14\n  );\n  expect(await getSupportedNodeVersion('16.x', false)).toHaveProperty(\n    'major',\n    16\n  );\n\n  const autoMessage =\n    'Please set Node.js Version to 18.x in your Project Settings to use Node.js 18.';\n  await expectBuilderError(\n    getSupportedNodeVersion('8.11.x', true),\n    autoMessage\n  );\n  await expectBuilderError(getSupportedNodeVersion('6.x', true), autoMessage);\n  await expectBuilderError(getSupportedNodeVersion('999.x', true), autoMessage);\n  await expectBuilderError(getSupportedNodeVersion('foo', true), autoMessage);\n  await expectBuilderError(getSupportedNodeVersion('=> 10', true), autoMessage);\n\n  expect(await getSupportedNodeVersion('14.x', true)).toHaveProperty(\n    'major',\n    14\n  );\n  expect(await getSupportedNodeVersion('16.x', true)).toHaveProperty(\n    'major',\n    16\n  );\n\n  const foundMessage =\n    'Please set \"engines\": { \"node\": \"18.x\" } in your `package.json` file to use Node.js 18.';\n  await expectBuilderError(\n    getSupportedNodeVersion('8.11.x', false),\n    foundMessage\n  );\n  await expectBuilderError(getSupportedNodeVersion('6.x', false), foundMessage);\n  await expectBuilderError(\n    getSupportedNodeVersion('999.x', false),\n    foundMessage\n  );\n  await expectBuilderError(getSupportedNodeVersion('foo', false), foundMessage);\n  await expectBuilderError(\n    getSupportedNodeVersion('=> 10', false),\n    foundMessage\n  );\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should match all semver ranges","suites":[],"updatePoint":{"line":100,"column":34},"line":100,"code":"it('should match all semver ranges', async () => {\n  // See https://docs.npmjs.com/files/package.json#engines\n  expect(await getSupportedNodeVersion('14.0.0')).toHaveProperty('major', 14);\n  expect(await getSupportedNodeVersion('14.x')).toHaveProperty('major', 14);\n  expect(await getSupportedNodeVersion('>=10')).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('>=10.3.0')).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('16.5.0 - 16.9.0')).toHaveProperty(\n    'major',\n    16\n  );\n  expect(await getSupportedNodeVersion('>=9.5.0 <=14.5.0')).toHaveProperty(\n    'major',\n    14\n  );\n  expect(await getSupportedNodeVersion('~14.5.0')).toHaveProperty('major', 14);\n  expect(await getSupportedNodeVersion('^14.5.0')).toHaveProperty('major', 14);\n  expect(await getSupportedNodeVersion('14.5.0 - 14.20.0')).toHaveProperty(\n    'major',\n    14\n  );\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should allow nodejs18.x","suites":[],"updatePoint":{"line":122,"column":27},"line":122,"code":"it('should allow nodejs18.x', async () => {\n  expect(getLatestNodeVersion()).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('18.x')).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('18')).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('18.1.0')).toHaveProperty('major', 18);\n  expect(await getSupportedNodeVersion('>=16')).toHaveProperty('major', 18);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should ignore node version in vercel dev getNodeVersion()","suites":[],"updatePoint":{"line":130,"column":61},"line":130,"code":"it('should ignore node version in vercel dev getNodeVersion()', async () => {\n  expect(\n    await getNodeVersion(\n      '/tmp',\n      undefined,\n      { nodeVersion: '1' },\n      { isDev: true }\n    )\n  ).toHaveProperty('runtime', 'nodejs');\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should select project setting from config when no package.json is found and fallback undefined","suites":[],"updatePoint":{"line":141,"column":98},"line":141,"code":"it('should select project setting from config when no package.json is found and fallback undefined', async () => {\n  expect(\n    await getNodeVersion('/tmp', undefined, { nodeVersion: '18.x' }, {})\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should select project setting from config when no package.json is found and fallback is null","suites":[],"updatePoint":{"line":148,"column":96},"line":148,"code":"it('should select project setting from config when no package.json is found and fallback is null', async () => {\n  expect(\n    await getNodeVersion('/tmp', null as any, { nodeVersion: '18.x' }, {})\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should select project setting from fallback when no package.json is found","suites":[],"updatePoint":{"line":155,"column":77},"line":155,"code":"it('should select project setting from fallback when no package.json is found', async () => {\n  expect(await getNodeVersion('/tmp', '18.x')).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should prefer package.json engines over project setting from config and warn","suites":[],"updatePoint":{"line":160,"column":80},"line":160,"code":"it('should prefer package.json engines over project setting from config and warn', async () => {\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node'),\n      undefined,\n      { nodeVersion: '12.x' },\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([\n    'Warning: Due to \"engines\": { \"node\": \"18.x\" } in your `package.json` file, the Node.js Version defined in your Project Settings (\"12.x\") will not apply. Learn More: http://vercel.link/node-version',\n  ]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should warn when package.json engines is exact version","suites":[],"updatePoint":{"line":174,"column":58},"line":174,"code":"it('should warn when package.json engines is exact version', async () => {\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node-exact'),\n      undefined,\n      {},\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([\n    'Warning: Detected \"engines\": { \"node\": \"18.2.0\" } in your `package.json` with major.minor.patch, but only major Node.js Version can be selected. Learn More: http://vercel.link/node-version',\n  ]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should warn when package.json engines is greater than","suites":[],"updatePoint":{"line":188,"column":57},"line":188,"code":"it('should warn when package.json engines is greater than', async () => {\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node-greaterthan'),\n      undefined,\n      {},\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([\n    'Warning: Detected \"engines\": { \"node\": \">=16\" } in your `package.json` that will automatically upgrade when a new major Node.js Version is released. Learn More: http://vercel.link/node-version',\n  ]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not warn when package.json engines matches project setting from config","suites":[],"updatePoint":{"line":202,"column":81},"line":202,"code":"it('should not warn when package.json engines matches project setting from config', async () => {\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node'),\n      undefined,\n      { nodeVersion: '18' },\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node'),\n      undefined,\n      { nodeVersion: '18.x' },\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n\n  expect(\n    await getNodeVersion(\n      path.join(__dirname, 'pkg-engine-node'),\n      undefined,\n      { nodeVersion: '<19' },\n      {}\n    )\n  ).toHaveProperty('range', '18.x');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should get latest node version","suites":[],"updatePoint":{"line":234,"column":34},"line":234,"code":"it('should get latest node version', async () => {\n  expect(getLatestNodeVersion()).toHaveProperty('major', 18);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw for discontinued versions","suites":[],"updatePoint":{"line":238,"column":42},"line":238,"code":"it('should throw for discontinued versions', async () => {\n  // Mock a future date so that Node 8 and 10 become discontinued\n  const realDateNow = Date.now.bind(global.Date);\n  global.Date.now = () => new Date('2024-02-13').getTime();\n\n  expect(getSupportedNodeVersion('8.10.x', false)).rejects.toThrow();\n  expect(getSupportedNodeVersion('8.10.x', true)).rejects.toThrow();\n  expect(getSupportedNodeVersion('10.x', false)).rejects.toThrow();\n  expect(getSupportedNodeVersion('10.x', true)).rejects.toThrow();\n  expect(getSupportedNodeVersion('12.x', false)).rejects.toThrow();\n  expect(getSupportedNodeVersion('12.x', true)).rejects.toThrow();\n  expect(getSupportedNodeVersion('14.x', false)).rejects.toThrow();\n  expect(getSupportedNodeVersion('14.x', true)).rejects.toThrow();\n  expect(getSupportedNodeVersion('16.x', false)).rejects.toThrow();\n  expect(getSupportedNodeVersion('16.x', true)).rejects.toThrow();\n\n  const discontinued = getDiscontinuedNodeVersions();\n  expect(discontinued.length).toBe(5);\n  expect(discontinued[0]).toHaveProperty('range', '16.x');\n  expect(discontinued[1]).toHaveProperty('range', '14.x');\n  expect(discontinued[2]).toHaveProperty('range', '12.x');\n  expect(discontinued[3]).toHaveProperty('range', '10.x');\n  expect(discontinued[4]).toHaveProperty('range', '8.10.x');\n\n  global.Date.now = realDateNow;\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should warn for deprecated versions, soon to be discontinued","suites":[],"updatePoint":{"line":265,"column":64},"line":265,"code":"it('should warn for deprecated versions, soon to be discontinued', async () => {\n  // Mock a future date so that Node 10 warns\n  const realDateNow = Date.now.bind(global.Date);\n  global.Date.now = () => new Date('2021-02-23').getTime();\n\n  expect(await getSupportedNodeVersion('10.x', false)).toHaveProperty(\n    'major',\n    10\n  );\n  expect(await getSupportedNodeVersion('10.x', true)).toHaveProperty(\n    'major',\n    10\n  );\n  expect(await getSupportedNodeVersion('12.x', false)).toHaveProperty(\n    'major',\n    12\n  );\n  expect(await getSupportedNodeVersion('12.x', true)).toHaveProperty(\n    'major',\n    12\n  );\n  expect(await getSupportedNodeVersion('14.x', false)).toHaveProperty(\n    'major',\n    14\n  );\n  expect(await getSupportedNodeVersion('14.x', true)).toHaveProperty(\n    'major',\n    14\n  );\n  expect(await getSupportedNodeVersion('16.x', false)).toHaveProperty(\n    'major',\n    16\n  );\n  expect(await getSupportedNodeVersion('16.x', true)).toHaveProperty(\n    'major',\n    16\n  );\n  expect(warningMessages).toStrictEqual([\n    'Error: Node.js version 10.x has reached End-of-Life. Deployments created on or after 2021-04-20 will fail to build. Please set \"engines\": { \"node\": \"18.x\" } in your `package.json` file to use Node.js 18.',\n    'Error: Node.js version 10.x has reached End-of-Life. Deployments created on or after 2021-04-20 will fail to build. Please set Node.js Version to 18.x in your Project Settings to use Node.js 18.',\n    'Error: Node.js version 12.x has reached End-of-Life. Deployments created on or after 2022-10-03 will fail to build. Please set \"engines\": { \"node\": \"18.x\" } in your `package.json` file to use Node.js 18.',\n    'Error: Node.js version 12.x has reached End-of-Life. Deployments created on or after 2022-10-03 will fail to build. Please set Node.js Version to 18.x in your Project Settings to use Node.js 18.',\n    'Error: Node.js version 14.x has reached End-of-Life. Deployments created on or after 2023-08-15 will fail to build. Please set \"engines\": { \"node\": \"18.x\" } in your `package.json` file to use Node.js 18.',\n    'Error: Node.js version 14.x has reached End-of-Life. Deployments created on or after 2023-08-15 will fail to build. Please set Node.js Version to 18.x in your Project Settings to use Node.js 18.',\n    'Error: Node.js version 16.x has reached End-of-Life. Deployments created on or after 2024-02-06 will fail to build. Please set \"engines\": { \"node\": \"18.x\" } in your `package.json` file to use Node.js 18.',\n    'Error: Node.js version 16.x has reached End-of-Life. Deployments created on or after 2024-02-06 will fail to build. Please set Node.js Version to 18.x in your Project Settings to use Node.js 18.',\n  ]);\n\n  global.Date.now = realDateNow;\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should support initialHeaders and initialStatus correctly","suites":[],"updatePoint":{"line":316,"column":61},"line":316,"code":"it('should support initialHeaders and initialStatus correctly', async () => {\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    initialHeaders: {\n      'content-type': 'application/json',\n      'x-initial': 'true',\n    },\n    initialStatus: 308,\n  });\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    initialStatus: 308,\n  });\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    initialHeaders: {\n      'content-type': 'application/json',\n      'x-initial': 'true',\n    },\n  });\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should support passQuery correctly","suites":[],"updatePoint":{"line":347,"column":38},"line":347,"code":"it('should support passQuery correctly', async () => {\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    passQuery: true,\n  });\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    passQuery: false,\n  });\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n    passQuery: undefined,\n  });\n  new Prerender({\n    expiration: 1,\n    fallback: null,\n    group: 1,\n    bypassToken: 'some-long-bypass-token-to-make-it-work',\n  });\n\n  expect(() => {\n    new Prerender({\n      expiration: 1,\n      fallback: null,\n      group: 1,\n      bypassToken: 'some-long-bypass-token-to-make-it-work',\n      // @ts-expect-error testing invalid field\n      passQuery: 'true',\n    });\n  }).toThrowError(\n    `The \\`passQuery\\` argument for \\`Prerender\\` must be a boolean.`\n  );\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should support require by path for legacy builders","suites":[],"updatePoint":{"line":390,"column":54},"line":390,"code":"it('should support require by path for legacy builders', () => {\n  const index = require('../');\n\n  const download2 = require('../fs/download.js');\n  const getWriteableDirectory2 = require('../fs/get-writable-directory.js');\n  const glob2 = require('../fs/glob.js');\n  const rename2 = require('../fs/rename.js');\n  const {\n    runNpmInstall: runNpmInstall2,\n  } = require('../fs/run-user-scripts.js');\n  const streamToBuffer2 = require('../fs/stream-to-buffer.js');\n\n  const FileBlob2 = require('../file-blob.js');\n  const FileFsRef2 = require('../file-fs-ref.js');\n  const FileRef2 = require('../file-ref.js');\n  const { Lambda: Lambda2 } = require('../lambda.js');\n\n  expect(download2).toBe(index.download);\n  expect(getWriteableDirectory2).toBe(index.getWriteableDirectory);\n  expect(glob2).toBe(index.glob);\n  expect(rename2).toBe(index.rename);\n  expect(runNpmInstall2).toBe(index.runNpmInstall);\n  expect(streamToBuffer2).toBe(index.streamToBuffer);\n\n  expect(FileBlob2).toBe(index.FileBlob);\n  expect(FileFsRef2).toBe(index.FileFsRef);\n  expect(FileRef2).toBe(index.FileRef);\n  expect(Lambda2).toBe(index.Lambda);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should have correct $PATH when running `runPackageJsonScript()` with yarn","suites":[],"updatePoint":{"line":421,"column":76},"line":420,"code":"it(\n  'should have correct $PATH when running `runPackageJsonScript()` with yarn',\n  async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on windows');\n      return;\n    }\n    if (process.platform === 'darwin') {\n      console.log('Skipping test on macOS');\n      return;\n    }\n    const fixture = path.join(__dirname, 'fixtures', '19-yarn-v2');\n    await runNpmInstall(fixture);\n    await runPackageJsonScript(fixture, 'env');\n\n    // `yarn` was failing with ENOENT before, so as long as the\n    // script was invoked at all is enough to verify the fix\n    const out = await fs.readFile(path.join(fixture, 'env.txt'), 'utf8');\n    expect(out.trim()).toBeTruthy();\n  },\n  ms('1m')\n);","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return lockfileVersion 2 with npm7","suites":[],"updatePoint":{"line":443,"column":45},"line":443,"code":"it('should return lockfileVersion 2 with npm7', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '20-npm-7');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('npm');\n  expect(result.lockfileVersion).toEqual(2);\n  expect(result.lockfilePath).toEqual(path.join(fixture, 'package-lock.json'));\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not return lockfileVersion with yarn","suites":[],"updatePoint":{"line":452,"column":47},"line":452,"code":"it('should not return lockfileVersion with yarn', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '19-yarn-v2');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('yarn');\n  expect(result.lockfileVersion).toEqual(undefined);\n  expect(result.lockfilePath).toEqual(path.join(fixture, 'yarn.lock'));\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should return lockfileVersion 1 with older versions of npm","suites":[],"updatePoint":{"line":461,"column":62},"line":461,"code":"it('should return lockfileVersion 1 with older versions of npm', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '08-yarn-npm/with-npm');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('npm');\n  expect(result.lockfileVersion).toEqual(1);\n  expect(result.lockfilePath).toEqual(path.join(fixture, 'package-lock.json'));\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should detect npm Workspaces","suites":[],"updatePoint":{"line":470,"column":32},"line":470,"code":"it('should detect npm Workspaces', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '21-npm-workspaces/a');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('npm');\n  expect(result.lockfileVersion).toEqual(2);\n  expect(result.lockfilePath).toEqual(\n    path.join(fixture, '..', 'package-lock.json')\n  );\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should detect pnpm without workspace","suites":[],"updatePoint":{"line":481,"column":40},"line":481,"code":"it('should detect pnpm without workspace', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '22-pnpm');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('pnpm');\n  expect(result.lockfileVersion).toEqual(5.3);\n  expect(result.lockfilePath).toEqual(path.join(fixture, 'pnpm-lock.yaml'));\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should detect pnpm with workspaces","suites":[],"updatePoint":{"line":490,"column":38},"line":490,"code":"it('should detect pnpm with workspaces', async () => {\n  const fixture = path.join(__dirname, 'fixtures', '23-pnpm-workspaces/c');\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('pnpm');\n  expect(result.lockfileVersion).toEqual(5.3);\n  expect(result.lockfilePath).toEqual(\n    path.join(fixture, '..', 'pnpm-lock.yaml')\n  );\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should detect package.json in nested backend","suites":[],"updatePoint":{"line":501,"column":48},"line":501,"code":"it('should detect package.json in nested backend', async () => {\n  const fixture = path.join(\n    __dirname,\n    '../../node/test/fixtures/18.1-nested-packagejson/backend'\n  );\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('pnpm');\n  // There is no lockfile but this test will pick up vercel/vercel/pnpm-lock.yaml\n  expect(result.lockfileVersion).toEqual(6);\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should detect package.json in nested frontend","suites":[],"updatePoint":{"line":513,"column":49},"line":513,"code":"it('should detect package.json in nested frontend', async () => {\n  const fixture = path.join(\n    __dirname,\n    '../../node/test/fixtures/18.1-nested-packagejson/frontend'\n  );\n  const result = await scanParentDirs(fixture);\n  expect(result.cliType).toEqual('pnpm');\n  // There is no lockfile but this test will pick up vercel/vercel/pnpm-lock.yaml\n  expect(result.lockfileVersion).toEqual(6);\n  expect(result.packageJsonPath).toEqual(path.join(fixture, 'package.json'));\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should retry npm install when peer deps invalid and npm@8 on node@16","suites":[],"updatePoint":{"line":525,"column":72},"line":525,"code":"it('should retry npm install when peer deps invalid and npm@8 on node@16', async () => {\n  const nodeMajor = Number(process.versions.node.split('.')[0]);\n  if (nodeMajor !== 16) {\n    console.log(`Skipping test on node@${nodeMajor}`);\n    return;\n  }\n  if (process.platform === 'win32') {\n    console.log('Skipping test on windows');\n    return;\n  }\n  if (process.platform === 'darwin') {\n    console.log('Skipping test on mac');\n    return;\n  }\n\n  const fixture = path.join(__dirname, 'fixtures', '15-npm-8-legacy-peer-deps');\n  const nodeVersion = { major: nodeMajor } as any;\n  await runNpmInstall(fixture, [], {}, {}, nodeVersion);\n  expect(warningMessages).toStrictEqual([\n    'Warning: Retrying \"Install Command\" with `--legacy-peer-deps` which may accept a potentially broken dependency and slow install time.',\n  ]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should rename keys of files map","suites":["rename"],"updatePoint":{"line":549,"column":37},"line":549,"code":"  it('should rename keys of files map', () => {\n    const before: Files = {};\n    const toUpper = (s: string) => s.toUpperCase();\n\n    for (let i = 97; i <= 122; i++) {\n      const key = String.fromCharCode(i);\n      before[key] = new FileBlob({ contentType: 'text/plain', data: key });\n    }\n\n    const after = rename(before, toUpper);\n    expect(Object.keys(after)).toEqual('ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''));\n  });","file":"unit.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should traverse start=\"$start\", base=\"$base\"","suites":["traverseUpDirectories()"],"line":6,"code":"  test.each(\n    isWindows\n      ? [\n          {\n            start: 'C:\\\\foo\\\\bar\\\\baz',\n            expected: ['C:\\\\foo\\\\bar\\\\baz', 'C:\\\\foo\\\\bar', 'C:\\\\foo', 'C:\\\\'],\n          },\n          {\n            start: 'C:\\\\foo\\\\..\\\\bar\\\\.\\\\baz',\n            expected: ['C:\\\\bar\\\\baz', 'C:\\\\bar', 'C:\\\\'],\n          },\n          {\n            start: 'C:\\\\foo\\\\bar\\\\baz\\\\another',\n            base: 'C:\\\\foo\\\\bar',\n            expected: [\n              'C:\\\\foo\\\\bar\\\\baz\\\\another',\n              'C:\\\\foo\\\\bar\\\\baz',\n              'C:\\\\foo\\\\bar',\n            ],\n          },\n        ]\n      : [\n          {\n            start: '/foo/bar/baz',\n            expected: ['/foo/bar/baz', '/foo/bar', '/foo', '/'],\n          },\n          {\n            start: '/foo/../bar/./baz',\n            expected: ['/bar/baz', '/bar', '/'],\n          },\n          {\n            start: '/foo/bar/baz/another',\n            base: '/foo/bar',\n            expected: ['/foo/bar/baz/another', '/foo/bar/baz', '/foo/bar'],\n          },\n        ]\n  )(\n    'should traverse start=\"$start\", base=\"$base\"',\n    ({ start, base, expected }) => {\n      expect(Array.from(traverseUpDirectories({ start, base }))).toEqual(\n        expected\n      );\n    }\n  );","file":"unit.traverse-up-directories.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not error with no use-node-version","suites":["validateNpmrc"],"updatePoint":{"line":7,"column":47},"line":7,"code":"  it('should not error with no use-node-version', async () => {\n    await expect(validateNpmrc(fixture('good'))).resolves.toBe(undefined);\n  });","file":"unit.validate-npmrc.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw when use-node-version is found","suites":["validateNpmrc"],"updatePoint":{"line":11,"column":49},"line":11,"code":"  it('should throw when use-node-version is found', async () => {\n    await expect(\n      validateNpmrc(fixture('has-use-node-version'))\n    ).rejects.toThrow('Detected unsupported');\n  });","file":"unit.validate-npmrc.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not error when use-node-version is commented out","suites":["validateNpmrc"],"updatePoint":{"line":17,"column":61},"line":17,"code":"  it('should not error when use-node-version is commented out', async () => {\n    await expect(\n      validateNpmrc(fixture('comment-use-node-version'))\n    ).resolves.toBe(undefined);\n  });","file":"unit.validate-npmrc.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw when `base` is relative","suites":["Test `walkParentDirs`"],"updatePoint":{"line":17,"column":42},"line":17,"code":"  it('should throw when `base` is relative', async () => {\n    const base = './relative';\n    const start = __dirname;\n    try {\n      await walkParentDirs({ base, start, filename });\n      fail('Expected error');\n    } catch (error) {\n      strict.deepEqual(\n        (error as Error).message,\n        'Expected \"base\" to be absolute path'\n      );\n    }\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should throw when `start` is relative","suites":["Test `walkParentDirs`"],"updatePoint":{"line":31,"column":43},"line":31,"code":"  it('should throw when `start` is relative', async () => {\n    const base = __dirname;\n    const start = './relative';\n    try {\n      await walkParentDirs({ base, start, filename });\n      fail('Expected error');\n    } catch (error) {\n      strict.deepEqual(\n        (error as Error).message,\n        'Expected \"start\" to be absolute path'\n      );\n    }\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find nested one","suites":["Test `walkParentDirs`"],"updatePoint":{"line":45,"column":28},"line":45,"code":"  it('should find nested one', async () => {\n    const base = fixture('every-directory');\n    const start = base;\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'First');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find nested two","suites":["Test `walkParentDirs`"],"updatePoint":{"line":52,"column":28},"line":52,"code":"  it('should find nested two', async () => {\n    const base = fixture('every-directory');\n    const start = join(base, 'two');\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'Second');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find nested three","suites":["Test `walkParentDirs`"],"updatePoint":{"line":59,"column":30},"line":59,"code":"  it('should find nested three', async () => {\n    const base = fixture('every-directory');\n    const start = join(base, 'two', 'three');\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'Third');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not find nested one","suites":["Test `walkParentDirs`"],"updatePoint":{"line":66,"column":32},"line":66,"code":"  it('should not find nested one', async () => {\n    const base = fixture('not-found');\n    const start = base;\n    const target = await walkParentDirs({ base, start, filename });\n    strict.deepEqual(target, null);\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not find nested two","suites":["Test `walkParentDirs`"],"updatePoint":{"line":73,"column":32},"line":73,"code":"  it('should not find nested two', async () => {\n    const base = fixture('not-found');\n    const start = join(base, 'two');\n    const target = await walkParentDirs({ base, start, filename });\n    strict.deepEqual(target, null);\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should not find nested three","suites":["Test `walkParentDirs`"],"updatePoint":{"line":80,"column":34},"line":80,"code":"  it('should not find nested three', async () => {\n    const base = fixture('not-found');\n    const start = join(base, 'two', 'three');\n    const target = await walkParentDirs({ base, start, filename });\n    strict.deepEqual(target, null);\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find only one","suites":["Test `walkParentDirs`"],"updatePoint":{"line":87,"column":26},"line":87,"code":"  it('should find only one', async () => {\n    const base = fixture('only-one');\n    const start = join(base, 'two', 'three');\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'First');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find only two","suites":["Test `walkParentDirs`"],"updatePoint":{"line":94,"column":26},"line":94,"code":"  it('should find only two', async () => {\n    const base = fixture('only-two');\n    const start = join(base, 'two', 'three');\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'Second');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should find only three","suites":["Test `walkParentDirs`"],"updatePoint":{"line":101,"column":28},"line":101,"code":"  it('should find only three', async () => {\n    const base = fixture('only-three');\n    const start = join(base, 'two', 'three');\n    const target = await walkParentDirs({ base, start, filename });\n    await assertContent(target, 'Third');\n  });","file":"unit.walk.test.ts","skipped":false,"dir":"packages/build-utils/test"},{"name":"should create the app","suites":["AppComponent"],"updatePoint":{"line":9,"column":27,"index":299},"line":9,"code":"  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  });","file":"dev/fixtures/02-angular-node/src/app/app.component.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should have as title 'angular-node'","suites":["AppComponent"],"updatePoint":{"line":14,"column":41,"index":502},"line":14,"code":"  it(`should have as title 'angular-node'`, () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('angular-node');\n  });","file":"dev/fixtures/02-angular-node/src/app/app.component.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should render title in a h1 tag","suites":["AppComponent"],"updatePoint":{"line":19,"column":37,"index":718},"line":19,"code":"  it('should render title in a h1 tag', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain('Welcome to angular-node!');\n  });","file":"dev/fixtures/02-angular-node/src/app/app.component.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should render message","suites":["Stage App Component"],"updatePoint":{"line":10,"column":27,"index":388},"line":10,"code":"  it('should render message', done => {\n    component.create(bootstrap).then(() => {\n      const view = component.element;\n      expect(view.textContent.trim()).toBe('Hello World!');\n      done();\n    }).catch(e => {\n      fail(e);\n      done();\n    });\n  });","file":"dev/fixtures/03-aurelia/test/unit/app.spec.js","skipped":false,"dir":"packages/cli/test"},{"name":"renders without crashing","suites":[],"updatePoint":{"line":4,"column":28,"index":115},"line":4,"code":"it('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render( /*#__PURE__*/React.createElement(App, null), div);\n  ReactDOM.unmountComponentAtNode(div);\n});","file":"dev/fixtures/04-create-react-app/src/App.test.js","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 02-angular-node","suites":[],"updatePoint":{"line":14,"column":34,"index":301},"line":14,"code":"test('[vercel dev] 02-angular-node', async () => {\n  if (shouldSkip('02-angular-node', '10.x')) return;\n  const directory = fixture('02-angular-node');\n  const {\n    dev,\n    port\n  } = await testFixture(directory, {\n    stdio: 'pipe'\n  }, ['--debug']);\n  let stderr = '';\n  try {\n    dev.stderr.on('data', async data => {\n      stderr += data.toString();\n    });\n\n    // start `vercel dev` detached in child_process\n    dev.unref();\n    const response = await fetchWithRetry(`http://localhost:${port}`, {\n      retries: 180,\n      status: 200\n    });\n    validateResponseHeaders(response);\n    const body = await response.text();\n    expect(body).toMatch(/Angular \\+ Node.js API/m);\n  } finally {\n    await dev.kill();\n  }\n  await sleep(5000);\n  stderr.includes('@now/build-utils@latest');\n});","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 03-aurelia","suites":[],"updatePoint":{"line":44,"column":29,"index":1091},"line":44,"code":"test('[vercel dev] 03-aurelia', testFixtureStdio('03-aurelia', async testPath => {\n  await testPath(200, '/', /Aurelia Navigation Skeleton/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 04-create-react-app","suites":[],"updatePoint":{"line":49,"column":38,"index":1272},"line":49,"code":"test('[vercel dev] 04-create-react-app', testFixtureStdio('04-create-react-app', async testPath => {\n  await testPath(200, '/', /React App/m);\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 07-hexo-node","suites":[],"updatePoint":{"line":52,"column":31,"index":1413},"line":52,"code":"test('[vercel dev] 07-hexo-node', testFixtureStdio('07-hexo-node', async testPath => {\n  await testPath(200, '/', /Hexo \\+ Node.js API/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n  await testPath(200, '/contact.html', /Contact Us/m);\n  await testPath(200, '/support', /Contact Us/m);\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 08-hugo","suites":[],"updatePoint":{"line":58,"column":26,"index":1736},"line":58,"code":"test('[vercel dev] 08-hugo', async () => {\n  if (process.platform === 'darwin') {\n    // 1. run the test without Hugo in the PATH\n    let tester = await testFixtureStdio('08-hugo', async () => {\n      throw new Error('Expected dev server to fail to be ready');\n    }, {\n      readyTimeout: 2000,\n      // Important: for the first test, we MUST deploy this app so that the\n      // framework (e.g. Hugo) will be detected by the server and associated\n      // with the project since `vc dev` doesn't do framework detection\n      skipDeploy: false\n    });\n    await expect(tester()).rejects.toThrow(new Error('Dev server timed out while waiting to be ready'));\n\n    // 2. Update PATH to find the Hugo executable installed via GH Actions\n    process.env.PATH = `${resolve(fixture('08-hugo'))}${delimiter}${process.env.PATH}`;\n\n    // 3. Rerun the test now that Hugo is in the PATH\n    tester = testFixtureStdio('08-hugo', async testPath => {\n      await testPath(200, '/', /Hugo/m);\n    }, {\n      skipDeploy: true\n    });\n    await tester();\n  } else {\n    console.log(`Skipping 08-hugo on platform ${process.platform}`);\n  }\n});","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 10-nextjs-node","suites":[],"updatePoint":{"line":86,"column":33,"index":2870},"line":86,"code":"test('[vercel dev] 10-nextjs-node', testFixtureStdio('10-nextjs-node', async testPath => {\n  await testPath(200, '/', /Next.js \\+ Node.js API/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n  await testPath(200, '/contact', /Contact Page/);\n  await testPath(200, '/support', /Contact Page/);\n  // TODO: Fix this test assertion that fails intermittently\n  // await testPath(404, '/nothing', /Custom Next 404/);\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 10a-nextjs-routes","suites":[],"updatePoint":{"line":95,"column":36,"index":3324},"line":95,"code":"test('[vercel dev] 10a-nextjs-routes', testFixtureStdio('10a-nextjs-routes', async testPath => {\n  await testPath(200, '/', /Next.js with routes/m);\n  await testPath(200, '/hello', /Hello Routes/m);\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 12-polymer-node","suites":[],"updatePoint":{"line":99,"column":34,"index":3526},"line":99,"code":"test('[vercel dev] 12-polymer-node', testFixtureStdio('12-polymer-node', async testPath => {\n  await testPath(200, '/', /Polymer \\+ Node.js API/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 13-preact-node","suites":[],"updatePoint":{"line":105,"column":33,"index":3781},"line":105,"code":"test('[vercel dev] 13-preact-node', testFixtureStdio('13-preact-node', async testPath => {\n  await testPath(200, '/', /Preact/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 14-svelte-node","suites":[],"updatePoint":{"line":111,"column":33,"index":4019},"line":111,"code":"test('[vercel dev] 14-svelte-node', testFixtureStdio('14-svelte-node', async testPath => {\n  await testPath(200, '/', /Svelte/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 16-vue-node","suites":[],"updatePoint":{"line":117,"column":30,"index":4254},"line":117,"code":"test('[vercel dev] 16-vue-node', testFixtureStdio('16-vue-node', async testPath => {\n  await testPath(200, '/', /Vue.js \\+ Node.js API/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 17-vuepress-node","suites":[],"updatePoint":{"line":123,"column":35,"index":4506},"line":123,"code":"test('[vercel dev] 17-vuepress-node', testFixtureStdio('17-vuepress-node', async testPath => {\n  await testPath(200, '/', /VuePress \\+ Node.js API/m);\n  await testPath(200, '/api/date', new RegExp(new Date().getFullYear() + ''));\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] double slashes redirect","suites":[],"updatePoint":{"line":129,"column":42,"index":4772},"line":129,"code":"test('[vercel dev] double slashes redirect', testFixtureStdio('01-node', async (_testPath, port) => {\n  {\n    const res = await fetch(`http://localhost:${port}////?foo=bar`, {\n      redirect: 'manual'\n    });\n    validateResponseHeaders(res);\n    const body = await res.text();\n    expect(res.status).toBe(301);\n    expect(res.headers.get('location')).toBe(`http://localhost:${port}/?foo=bar`);\n    expect(body).toBe('Redirecting...\\n');\n  }\n  {\n    const res = await fetch(`http://localhost:${port}///api////date.js`, {\n      method: 'POST',\n      redirect: 'manual'\n    });\n    validateResponseHeaders(res);\n    const body = await res.text();\n    expect(res.status).toBe(200);\n    expect(body.startsWith('January') || body.startsWith('February') || body.startsWith('March') || body.startsWith('April') || body.startsWith('May') || body.startsWith('June') || body.startsWith('July') || body.startsWith('August') || body.startsWith('September') || body.startsWith('October') || body.startsWith('November') || body.startsWith('December')).toBeTruthy();\n  }\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 18-marko","suites":[],"updatePoint":{"line":153,"column":27,"index":5842},"line":153,"code":"test('[vercel dev] 18-marko', testFixtureStdio('18-marko', async testPath => {\n  await testPath(200, '/', /Marko Starter/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 19-mithril","suites":[],"updatePoint":{"line":158,"column":29,"index":5998},"line":158,"code":"test('[vercel dev] 19-mithril', testFixtureStdio('19-mithril', async testPath => {\n  await testPath(200, '/', /Mithril on Vercel/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 20-riot","suites":[],"updatePoint":{"line":163,"column":26,"index":6157},"line":163,"code":"test('[vercel dev] 20-riot', testFixtureStdio('20-riot', async testPath => {\n  await testPath(200, '/', /Riot on Vercel/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 21-charge","suites":[],"updatePoint":{"line":168,"column":28,"index":6312},"line":168,"code":"test('[vercel dev] 21-charge', testFixtureStdio('21-charge', async testPath => {\n  await testPath(200, '/', /Welcome to my new Charge site/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 22-brunch","suites":[],"updatePoint":{"line":173,"column":28,"index":6484},"line":173,"code":"test('[vercel dev] 22-brunch', testFixtureStdio('22-brunch', async testPath => {\n  await testPath(200, '/', /Bon Apptit./m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 23-docusaurus","suites":[],"updatePoint":{"line":178,"column":32,"index":6643},"line":178,"code":"test('[vercel dev] 23-docusaurus', testFixtureStdio('23-docusaurus', async testPath => {\n  await testPath(200, '/', /My Site/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 24-ember","suites":[],"updatePoint":{"line":183,"column":27,"index":6796},"line":183,"code":"test('[vercel dev] 24-ember', async () => {\n  if (shouldSkip('24-ember', '>^6.14.0 || ^8.10.0 || >=9.10.0')) return;\n  const tester = testFixtureStdio('24-ember', async testPath => {\n    await testPath(200, '/', /HelloWorld/m);\n  }, {\n    skipDeploy: true\n  });\n  await tester();\n});","file":"dev/integration-3.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 25-nextjs-src-dir","suites":[],"updatePoint":{"line":11,"column":36,"index":248},"line":11,"code":"test('[vercel dev] 25-nextjs-src-dir', testFixtureStdio('25-nextjs-src-dir', async testPath => {\n  await testPath(200, '/', /Next.js \\+ Node.js API/m);\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 27-zero-config-env","suites":[],"updatePoint":{"line":14,"column":37,"index":406},"line":14,"code":"test('[vercel dev] 27-zero-config-env', testFixtureStdio('27-zero-config-env', async testPath => {\n  await testPath(200, '/api/print', /build-and-runtime/m);\n  await testPath(200, '/', /build-and-runtime/m);\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 28-vercel-json-and-ignore","suites":[],"updatePoint":{"line":20,"column":44,"index":650},"line":20,"code":"test('[vercel dev] 28-vercel-json-and-ignore', testFixtureStdio('28-vercel-json-and-ignore', async testPath => {\n  await testPath(200, '/api/one', 'One');\n  await testPath(404, '/api/two');\n  await testPath(200, '/api/three', 'One');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 30-next-image-optimization","suites":[],"updatePoint":{"line":25,"column":45,"index":890},"line":25,"code":"test('[vercel dev] 30-next-image-optimization', testFixtureStdio('30-next-image-optimization', async testPath => {\n  const toUrl = (url, w, q) => {\n    // @ts-ignore\n    const query = new URLSearchParams();\n    query.append('url', url);\n    query.append('w', w);\n    query.append('q', q);\n    return `/_next/image?${query}`;\n  };\n  const expectHeader = accept => ({\n    'content-type': accept,\n    'cache-control': 'public, max-age=0, must-revalidate'\n  });\n  const fetchOpts = accept => ({\n    method: 'GET',\n    headers: {\n      accept\n    }\n  });\n  await testPath(200, '/', /Home Page/m);\n  await testPath(200, toUrl('/test.jpg', 64, 100), null, expectHeader('image/webp'), fetchOpts('image/webp'));\n  await testPath(200, toUrl('/test.png', 64, 90), null, expectHeader('image/webp'), fetchOpts('image/webp'));\n  /*\n   * Disabled gif in https://github.com/vercel/next.js/pull/22253\n   * Eventually we should enable again when `next dev` supports it\n  await testPath(\n    200,\n    toUrl('/test.gif', 64, 80),\n    null,\n    expectHeader('image/webp'),\n    fetchOpts('image/webp')\n  );\n  */\n  /*\n   * Disabled svg in https://github.com/vercel/next.js/pull/34431\n   * We can test for 400 status since config option is not enabled.\n   */\n  await testPath(400, toUrl('/test.svg', 64, 70));\n  /* Disabled bmp because `next dev` bypasses\n   * and production will convert. Eventually\n   * we can enable once `next dev` supports it.\n  await testPath(\n    200,\n    toUrl('/test.bmp', 64, 50),\n    null,\n    expectHeader('image/bmp'),\n    fetchOpts('image/webp')\n  );\n  */\n  // animated gif should bypass: serve as-is\n  await testPath(200, toUrl('/animated.gif', 64, 60), null, expectHeader('image/gif'), fetchOpts('image/webp'));\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 40-mixed-modules","suites":[],"updatePoint":{"line":77,"column":35,"index":2606},"line":77,"code":"test('[vercel dev] 40-mixed-modules', testFixtureStdio('40-mixed-modules', async testPath => {\n  await testPath(200, '/entrypoint.js', 'mixed-modules:js');\n  await testPath(200, '/entrypoint.mjs', 'mixed-modules:mjs');\n  await testPath(200, '/entrypoint.ts', 'mixed-modules:ts');\n  await testPath(200, '/type-module-package-json/auto.js', 'mixed-modules:auto');\n  await testPath(200, '/type-module-package-json/nested/also.js', 'mixed-modules:also');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 41-tsconfig-jsx","suites":[],"updatePoint":{"line":84,"column":34,"index":3061},"line":84,"code":"test('[vercel dev] 41-tsconfig-jsx', testFixtureStdio('41-tsconfig-jsx', async testPath => {\n  await testPath(200, '/', /Solid App/m);\n  await testPath(200, '/api/test', 'working');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] 42-dynamic-esm-ext","suites":[],"updatePoint":{"line":88,"column":37,"index":3251},"line":88,"code":"test('[vercel dev] 42-dynamic-esm-ext', testFixtureStdio('42-dynamic-esm-ext', async testPath => {\n  await testPath(200, '/api/cjs/foo', 'found .js');\n  await testPath(200, '/api/esm/foo', 'found .mjs');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that returns a 200 response","suites":[],"updatePoint":{"line":92,"column":57,"index":3480},"line":92,"code":"test('[vercel dev] Middleware that returns a 200 response', testFixtureStdio('middleware-response', async testPath => {\n  await testPath(200, '/', 'hi from middleware');\n  await testPath(200, '/another', 'hi from middleware');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that has no response","suites":[],"updatePoint":{"line":96,"column":50,"index":3705},"line":96,"code":"test('[vercel dev] Middleware that has no response', testFixtureStdio('middleware-no-response', async testPath => {\n  await testPath(200, '/api/hello', 'hello from a serverless function');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that does basic rewrite","suites":[],"updatePoint":{"line":99,"column":53,"index":3902},"line":99,"code":"test('[vercel dev] Middleware that does basic rewrite', testFixtureStdio('middleware-rewrite', async testPath => {\n  await testPath(200, '/', '<h1>Index</h1>');\n  await testPath(200, '/index', '<h1>Another</h1>');\n  await testPath(200, '/another', '<h1>Another</h1>');\n  await testPath(200, '/another.html', '<h1>Another</h1>');\n  await testPath(200, '/foo', '<h1>Another</h1>');\n  // different origin\n  await testPath(200, '?to=http://example.com', /Example Domain/);\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware rewrites with same origin","suites":[],"updatePoint":{"line":108,"column":55,"index":4378},"line":108,"code":"test('[vercel dev] Middleware rewrites with same origin', async () => {\n  const directory = fixture('middleware-rewrite');\n  const {\n    dev,\n    port,\n    readyResolver\n  } = await testFixture(directory);\n  try {\n    dev.unref();\n    await readyResolver;\n    let response = await fetch(`http://localhost:${port}?to=http://localhost:${port}`);\n    validateResponseHeaders(response);\n    expect(response.status).toBe(200);\n    expect(await response.text()).toMatch(/<h1>Index<\\/h1>/);\n    response = await fetch(`http://localhost:${port}?to=http://127.0.0.1:${port}`);\n    validateResponseHeaders(response);\n    expect(response.status).toBe(200);\n    expect(await response.text()).toMatch(/<h1>Index<\\/h1>/);\n    response = await fetch(`http://localhost:${port}?to=http://[::1]:${port}`);\n    validateResponseHeaders(response);\n    expect(response.status).toBe(200);\n    expect(await response.text()).toMatch(/<h1>Index<\\/h1>/);\n  } finally {\n    await await dev.kill();\n  }\n});","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that rewrites with custom query params","suites":[],"updatePoint":{"line":134,"column":68,"index":5369},"line":134,"code":"test('[vercel dev] Middleware that rewrites with custom query params', testFixtureStdio('middleware-rewrite-query', async testPath => {\n  await testPath(200, '/?foo=bar', '{\"url\":\"/?from-middleware=true\"}');\n  await testPath(200, '/another?foo=bar', '{\"url\":\"/another?from-middleware=true\"}');\n  await testPath(200, '/api/fn?foo=bar', '{\"url\":\"/api/fn?from-middleware=true\"}');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that rewrites to 404s","suites":[],"updatePoint":{"line":139,"column":51,"index":5735},"line":139,"code":"test('[vercel dev] Middleware that rewrites to 404s', testFixtureStdio('middleware-rewrite-404', async testPath => {\n  await testPath(404, '/api/edge', /NOT_FOUND/);\n  await testPath(404, '/index.html', /NOT_FOUND/);\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware that redirects","suites":[],"updatePoint":{"line":143,"column":44,"index":5950},"line":143,"code":"test('[vercel dev] Middleware that redirects', testFixtureStdio('middleware-redirect', async testPath => {\n  await testPath(302, '/', null, {\n    location: 'https://vercel.com/'\n  });\n  await testPath(302, '/home', null, {\n    location: 'https://vercel.com/home'\n  });\n  await testPath(302, '/?foo=bar', null, {\n    location: 'https://vercel.com/?foo=bar'\n  });\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware with error in function handler","suites":[],"updatePoint":{"line":154,"column":60,"index":6333},"line":154,"code":"test('[vercel dev] Middleware with error in function handler', testFixtureStdio('middleware-error-in-handler', async testPath => {\n  await testPath(500, '/', /EDGE_FUNCTION_INVOCATION_FAILED/);\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware with error at init","suites":[],"updatePoint":{"line":157,"column":48,"index":6520},"line":157,"code":"test('[vercel dev] Middleware with error at init', testFixtureStdio('middleware-error-at-init', async testPath => {\n  await testPath(500, '/', /EDGE_FUNCTION_INVOCATION_FAILED/);\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware with an explicit 500 response","suites":[],"updatePoint":{"line":160,"column":59,"index":6715},"line":160,"code":"test('[vercel dev] Middleware with an explicit 500 response', testFixtureStdio('middleware-500-response', async testPath => {\n  await testPath(500, '/', 'Example Error');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware with `matchers` config","suites":[],"updatePoint":{"line":163,"column":52,"index":6884},"line":163,"code":"test('[vercel dev] Middleware with `matchers` config', testFixtureStdio('middleware-matchers', async testPath => {\n  await testPath(404, '/');\n  await testPath(404, '/another');\n  await testPath(200, '/about/page', '{\"pathname\":\"/about/page\",\"search\":\"\",\"fromMiddleware\":true}');\n  await testPath(200, '/dashboard/home', '{\"pathname\":\"/dashboard/home\",\"search\":\"\",\"fromMiddleware\":true}');\n  await testPath(200, '/dashboard/home?a=b', '{\"pathname\":\"/dashboard/home\",\"search\":\"?a=b\",\"fromMiddleware\":true}');\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] restarts dev process when `devCommand` setting is modified","suites":[],"updatePoint":{"line":170,"column":77,"index":7422},"line":170,"code":"test('[vercel dev] restarts dev process when `devCommand` setting is modified', testFixtureStdio('project-settings-override', async (_testPath, port) => {\n  const directory = fixture('project-settings-override');\n  const vercelJsonPath = join(directory, 'vercel.json');\n  const originalVercelJson = await fs.readJSON(vercelJsonPath);\n  try {\n    const originalResponse = await fetch(`http://localhost:${port}/index.txt`);\n    validateResponseHeaders(originalResponse);\n    const body = await originalResponse.text();\n    expect(body.trim()).toEqual('This is the original');\n    expect(originalResponse.status).toBe(200);\n    await fs.writeJSON(vercelJsonPath, {\n      devCommand: 'serve -p $PORT overridden'\n    });\n    const overriddenResponse = await fetch(`http://localhost:${port}/index.txt`);\n    validateResponseHeaders(overriddenResponse);\n    const body2 = await overriddenResponse.text();\n    expect(body2.trim()).toEqual('This is the overridden!');\n    expect(overriddenResponse.status).toBe(200);\n  } finally {\n    await fs.writeJSON(vercelJsonPath, originalVercelJson);\n  }\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vercel dev] Middleware can override request headers","suites":[],"updatePoint":{"line":194,"column":58,"index":8518},"line":194,"code":"test('[vercel dev] Middleware can override request headers', testFixtureStdio('middleware-request-headers-override', async testPath => {\n  await testPath(200, '/api/dump-headers', (actual, res) => {\n    // Headers sent to the API route.\n    const headers = JSON.parse(actual);\n\n    // Preserved headers.\n    expect(headers).toHaveProperty('x-from-client-a', 'hello from client');\n\n    // Headers added/modified by the middleware.\n    expect(headers).toHaveProperty('x-from-client-b', 'hello from middleware');\n    expect(headers).toHaveProperty('x-from-middleware-a', 'hello a!');\n    expect(headers).toHaveProperty('x-from-middleware-b', 'hello b!');\n\n    // Headers deleted by the middleware.\n    expect(headers).not.toHaveProperty('x-from-client-c');\n\n    // Internal headers should not be visible from API routes.\n    expect(headers).not.toHaveProperty('x-middleware-override-headers');\n    expect(headers).not.toHaveProperty('x-middleware-request-from-middleware-a');\n    expect(headers).not.toHaveProperty('x-middleware-request-from-middleware-b');\n\n    // Request headers should not be visible from clients.\n    const respHeaders = Object.fromEntries(res.headers.entries());\n    expect(respHeaders).not.toHaveProperty('x-middleware-override-headers');\n    expect(respHeaders).not.toHaveProperty('x-middleware-request-from-middleware-a');\n    expect(respHeaders).not.toHaveProperty('x-middleware-request-from-middleware-b');\n    expect(respHeaders).not.toHaveProperty('from-middleware-a');\n    expect(respHeaders).not.toHaveProperty('from-middleware-b');\n    expect(respHeaders).not.toHaveProperty('x-from-client-a');\n    expect(respHeaders).not.toHaveProperty('x-from-client-b');\n    expect(respHeaders).not.toHaveProperty('x-from-client-c');\n  }, /*expectedHeaders=*/{}, {\n    headers: {\n      'x-from-client-a': 'hello from client',\n      'x-from-client-b': 'hello from client',\n      'x-from-client-c': 'hello from client'\n    }\n  });\n}, {\n  skipDeploy: true\n}));","file":"dev/integration-4.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vc build] should build project with corepack and select npm@8.1.0","suites":[],"updatePoint":{"line":177,"column":72,"index":5083},"line":177,"code":"test('[vc build] should build project with corepack and select npm@8.1.0', async () => {\n  try {\n    process.env.ENABLE_EXPERIMENTAL_COREPACK = '1';\n    const directory = await setupE2EFixture('vc-build-corepack-npm');\n    const before = await exec(directory, 'npm', ['--version']);\n    const output = await execCli(binaryPath, ['build'], {\n      cwd: directory\n    });\n    expect(output.exitCode, formatOutput(output)).toBe(0);\n    expect(output.stderr).toMatch(/Build Completed/gm);\n    const after = await exec(directory, 'npm', ['--version']);\n    // Ensure global npm didn't change\n    expect(before.stdout).toBe(after.stdout);\n    // Ensure version is correct\n    expect(await fs.readFile(path.join(directory, '.vercel/output/static/index.txt'), 'utf8')).toBe('8.1.0\\n');\n    // Ensure corepack will be cached\n    const contents = fs.readdirSync(path.join(directory, '.vercel/cache/corepack'));\n    expect(contents).toEqual(['home', 'shim']);\n  } finally {\n    delete process.env.ENABLE_EXPERIMENTAL_COREPACK;\n  }\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vc build] should build project with corepack and select pnpm@7.1.0","suites":[],"updatePoint":{"line":199,"column":73,"index":6108},"line":199,"code":"test('[vc build] should build project with corepack and select pnpm@7.1.0', async () => {\n  process.env.ENABLE_EXPERIMENTAL_COREPACK = '1';\n  const directory = await setupE2EFixture('vc-build-corepack-pnpm');\n  const before = await exec(directory, 'pnpm', ['--version']);\n  const output = await execCli(binaryPath, ['build'], {\n    cwd: directory\n  });\n  expect(output.exitCode, formatOutput(output)).toBe(0);\n  expect(output.stderr).toMatch(/Build Completed/gm);\n  const after = await exec(directory, 'pnpm', ['--version']);\n  // Ensure global pnpm didn't change\n  expect(before.stdout).toBe(after.stdout);\n  // Ensure version is correct\n  expect(await fs.readFile(path.join(directory, '.vercel/output/static/index.txt'), 'utf8')).toBe('7.1.0\\n');\n  // Ensure corepack will be cached\n  const contents = fs.readdirSync(path.join(directory, '.vercel/cache/corepack'));\n  expect(contents).toEqual(['home', 'shim']);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vc build] should build project with corepack and select yarn@2.4.3","suites":[],"updatePoint":{"line":217,"column":73,"index":7026},"line":217,"code":"test('[vc build] should build project with corepack and select yarn@2.4.3', async () => {\n  process.env.ENABLE_EXPERIMENTAL_COREPACK = '1';\n  const directory = await setupE2EFixture('vc-build-corepack-yarn');\n  const before = await exec(directory, 'yarn', ['--version']);\n  const output = await execCli(binaryPath, ['build'], {\n    cwd: directory\n  });\n  expect(output.exitCode, formatOutput(output)).toBe(0);\n  expect(output.stderr).toMatch(/Build Completed/gm);\n  const after = await exec(directory, 'yarn', ['--version']);\n  // Ensure global yarn didn't change\n  expect(before.stdout).toBe(after.stdout);\n  // Ensure version is correct\n  expect(await fs.readFile(path.join(directory, '.vercel/output/static/index.txt'), 'utf8')).toBe('2.4.3\\n');\n  // Ensure corepack will be cached\n  const contents = fs.readdirSync(path.join(directory, '.vercel/cache/corepack'));\n  expect(contents).toEqual(['home', 'shim']);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vc dev] should print help from `vc develop --help`","suites":[],"updatePoint":{"line":235,"column":57,"index":7928},"line":235,"code":"test('[vc dev] should print help from `vc develop --help`', async () => {\n  const directory = await setupE2EFixture('static-deployment');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['develop', '--help'], {\n    cwd: directory\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(2);\n  expect(stdout).toMatch(/ vercel dev/gm);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"default command should deploy directory","suites":[],"updatePoint":{"line":250,"column":45,"index":8303},"line":250,"code":"test('default command should deploy directory', async () => {\n  const projectDir = await setupE2EFixture('deploy-default-with-sub-directory');\n  const target = 'output';\n  await vcLink(path.join(projectDir, target));\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  target], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  expect(stdout).toMatch(/https:\\/\\/output-.+\\.vercel\\.app/);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"default command should warn when deploying with conflicting subdirectory","suites":[],"updatePoint":{"line":269,"column":78,"index":8850},"line":269,"code":"test('default command should warn when deploying with conflicting subdirectory', async () => {\n  const projectDir = await setupE2EFixture('deploy-default-with-conflicting-sub-directory');\n  const target = 'list'; // command that conflicts with a sub directory\n\n  await vcLink(projectDir);\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  target], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  expect(stderr || '').toMatch(/Did you mean to deploy the subdirectory \"list\"\\? Use `vc --cwd list` instead./);\n  const listHeader = /No deployments found/;\n  expect(stderr || '').toMatch(listHeader); // ensure `list` command still ran\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deploy command should not warn when deploying with conflicting subdirectory and using --cwd","suites":[],"updatePoint":{"line":292,"column":97,"index":9631},"line":292,"code":"test('deploy command should not warn when deploying with conflicting subdirectory and using --cwd', async () => {\n  const projectDir = await setupE2EFixture('deploy-default-with-conflicting-sub-directory');\n  const target = 'list'; // command that conflicts with a sub directory\n\n  await vcLink(path.join(projectDir, target));\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['list', '--cwd', target], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  expect(stderr || '').not.toMatch(/Did you mean to deploy the subdirectory \"list\"\\? Use `vc --cwd list` instead./);\n  const listHeader = /No deployments found/;\n  expect(stderr || '').toMatch(listHeader); // ensure `list` command still ran\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"default command should work with --cwd option","suites":[],"updatePoint":{"line":313,"column":51,"index":10364},"line":313,"code":"test('default command should work with --cwd option', async () => {\n  const projectDir = await setupE2EFixture('deploy-default-with-conflicting-sub-directory');\n  const target = 'list'; // command that conflicts with a sub directory\n\n  await vcLink(path.join(projectDir, 'list'));\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  '--cwd', target], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const url = stdout;\n  const deploymentResult = await fetch(`${url}/README.md`);\n  const body = await deploymentResult.text();\n  expect(body).toEqual('readme contents for deploy-default-with-conflicting-sub-directory');\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow deploying a directory that was built with a target environment of \"preview\" and `--prebuilt` is used without specifying a target","suites":[],"updatePoint":{"line":336,"column":147,"index":11206},"line":336,"code":"test('should allow deploying a directory that was built with a target environment of \"preview\" and `--prebuilt` is used without specifying a target', async () => {\n  const projectDir = await setupE2EFixture('deploy-default-with-prebuilt-preview');\n  await vcLink(projectDir);\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  '--prebuilt'], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const url = stdout;\n  const deploymentResult = await fetch(`${url}/README.md`);\n  const body = await deploymentResult.text();\n  expect(body).toEqual('readme contents for deploy-default-with-prebuilt-preview');\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow deploying a directory that was prebuilt, but has no builds.json","suites":[],"updatePoint":{"line":357,"column":82,"index":11870},"line":357,"code":"test('should allow deploying a directory that was prebuilt, but has no builds.json', async () => {\n  const projectDir = await setupE2EFixture('build-output-api-raw');\n  await vcLink(projectDir);\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  '--prebuilt'], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const url = stdout;\n  const deploymentResult = await fetch(`${url}/README.md`);\n  const body = await deploymentResult.text();\n  expect(body).toEqual('readme contents for build-output-api-raw');\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deploy and not wait for completion","suites":[],"updatePoint":{"line":378,"column":47,"index":12467},"line":378,"code":"test('should deploy and not wait for completion', async () => {\n  const projectDir = await setupE2EFixture('static-deployment');\n  await vcLink(projectDir);\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [\n  // omit the default \"deploy\" command\n  '--no-wait'], {\n    cwd: projectDir\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  expect(stderr).toMatch(/Note: Deployment is still processing/);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"[vc link] with vercel.json configuration overrides should create a valid deployment","suites":[],"updatePoint":{"line":396,"column":89,"index":12972},"line":396,"code":"test('[vc link] with vercel.json configuration overrides should create a valid deployment', async () => {\n  const directory = await setupE2EFixture('vercel-json-configuration-overrides-link');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['link', '--yes'], {\n    cwd: directory\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const link = require(path.join(directory, '.vercel/project.json'));\n  const resEnv = await apiFetch(`/v4/projects/${link.projectId}`);\n  expect(resEnv.status).toBe(200);\n  const json = await resEnv.json();\n  expect(json.buildCommand).toBe('mkdir public && echo \"1\" > public/index.txt');\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deploy using only now.json with `redirects` defined","suites":[],"updatePoint":{"line":415,"column":57,"index":13623},"line":415,"code":"test('deploy using only now.json with `redirects` defined', async () => {\n  const target = await setupE2EFixture('redirects-v2');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, [target, '--yes']);\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const url = stdout;\n  const res = await fetch(`${url}/foo/bar`, {\n    redirect: 'manual'\n  });\n  const location = res.headers.get('location');\n  expect(location).toBe('https://example.com/foo/bar');\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deploy using --local-config flag v2","suites":[],"updatePoint":{"line":433,"column":41,"index":14113},"line":433,"code":"test('deploy using --local-config flag v2', async () => {\n  const target = await setupE2EFixture('local-config-v2');\n  const configPath = path.join(target, 'vercel-test.json');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['deploy', target, '--local-config', configPath, '--yes']);\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const {\n    host\n  } = new URL(stdout);\n  expect(host).toMatch(/secondary/gm);\n  const testRes = await fetch(`https://${host}/test-${contextName}.html`);\n  const testText = await testRes.text();\n  expect(testText).toBe('<h1>hello test</h1>');\n  const anotherTestRes = await fetch(`https://${host}/another-test`);\n  const anotherTestText = await anotherTestRes.text();\n  expect(anotherTestText).toBe(testText);\n  const mainRes = await fetch(`https://${host}/main-${contextName}.html`);\n  expect(mainRes.status).toBe(404);\n  const anotherMainRes = await fetch(`https://${host}/another-main`);\n  expect(anotherMainRes.status).toBe(404);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deploy fails using --local-config flag with non-existent path","suites":[],"updatePoint":{"line":460,"column":67,"index":15167},"line":460,"code":"test('deploy fails using --local-config flag with non-existent path', async () => {\n  const target = await setupE2EFixture('local-config-v2');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['deploy', target, '--local-config', 'does-not-exist.json', '--yes']);\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(1);\n  expect(stderr).toMatch(/Error: Couldn't find a project configuration file at/);\n  expect(stderr).toMatch(/does-not-exist\\.json/);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deploy using --local-config flag above target","suites":[],"updatePoint":{"line":474,"column":51,"index":15652},"line":474,"code":"test('deploy using --local-config flag above target', async () => {\n  const root = await setupE2EFixture('local-config-above-target');\n  const target = path.join(root, 'dir');\n  const {\n    exitCode,\n    stdout,\n    stderr\n  } = await execCli(binaryPath, ['deploy', target, '--local-config', './now-root.json', '--yes'], {\n    cwd: root\n  });\n  expect(exitCode, formatOutput({\n    stdout,\n    stderr\n  })).toBe(0);\n  const {\n    host\n  } = new URL(stdout);\n  const testRes = await fetch(`https://${host}/index.html`);\n  const testText = await testRes.text();\n  expect(testText).toBe('<h1>hello index</h1>');\n  const anotherTestRes = await fetch(`https://${host}/another.html`);\n  const anotherTestText = await anotherTestRes.text();\n  expect(anotherTestText).toBe('<h1>hello another</h1>');\n  expect(host).toMatch(/root-level/gm);\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Deploy `api-env` fixture and test `vercel env` command","suites":[],"updatePoint":{"line":499,"column":60,"index":16496},"line":499,"code":"test('Deploy `api-env` fixture and test `vercel env` command', async () => {\n  const target = await setupE2EFixture('api-env');\n  async function vcLink() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['link', '--yes'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvLsIsEmpty() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'ls'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    expect(stderr).toMatch(/No Environment Variables found in Project/gm);\n  }\n  async function vcEnvAddWithPrompts() {\n    const vc = execCli(binaryPath, ['env', 'add'], {\n      cwd: target\n    });\n    await waitForPrompt(vc, 'Whats the name of the variable?');\n    vc.stdin?.write('MY_NEW_ENV_VAR\\n');\n    await waitForPrompt(vc, chunk => chunk.includes('Whats the value of') && chunk.includes('MY_NEW_ENV_VAR'));\n    vc.stdin?.write('my plaintext value\\n');\n    await waitForPrompt(vc, chunk => chunk.includes('which Environments') && chunk.includes('MY_NEW_ENV_VAR'));\n    vc.stdin?.write('a\\n'); // select all\n\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvAddFromStdin() {\n    const vc = execCli(binaryPath, ['env', 'add', 'MY_STDIN_VAR', 'development'], {\n      cwd: target\n    });\n    vc.stdin?.end('{\"expect\":\"quotes\"}');\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvAddFromStdinPreview() {\n    const vc = execCli(binaryPath, ['env', 'add', 'MY_PREVIEW', 'preview'], {\n      cwd: target\n    });\n    vc.stdin?.end('preview-no-branch');\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvAddFromStdinPreviewWithBranch() {\n    const vc = execCli(binaryPath, ['env', 'add', 'MY_PREVIEW', 'preview', 'staging'], {\n      cwd: target\n    });\n    vc.stdin?.end('preview-with-branch');\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(1);\n    expect(stderr).toMatch(/does not have a connected Git repository/gm);\n  }\n  async function vcEnvLsIncludesVar() {\n    const {\n      exitCode,\n      stderr,\n      stdout\n    } = await execCli(binaryPath, ['env', 'ls'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    expect(stderr).toMatch(/Environment Variables found in Project/gm);\n    const lines = stdout.split('\\n');\n    const plaintextEnvs = lines.filter(line => line.includes('MY_NEW_ENV_VAR'));\n    expect(plaintextEnvs.length).toBe(1);\n    expect(plaintextEnvs[0]).toMatch(/Production, Preview, Development/gm);\n    const stdinEnvs = lines.filter(line => line.includes('MY_STDIN_VAR'));\n    expect(stdinEnvs.length).toBe(1);\n    expect(stdinEnvs[0]).toMatch(/Development/gm);\n    const previewEnvs = lines.filter(line => line.includes('MY_PREVIEW'));\n    expect(previewEnvs.length).toBe(1);\n    expect(previewEnvs[0]).toMatch(/Encrypted .* Preview /gm);\n  }\n\n  // we create a \"legacy\" env variable that contains a decryptable secret\n  // to check that vc env pull and vc dev work correctly with decryptable secrets\n  async function createEnvWithDecryptableSecret() {\n    console.log('creating an env variable with a decryptable secret');\n    const name = `my-secret${Math.floor(Math.random() * 10000)}`;\n    const res = await apiFetch('/v2/now/secrets', {\n      method: 'POST',\n      body: JSON.stringify({\n        name,\n        value: 'decryptable value',\n        decryptable: true\n      })\n    });\n    expect(res.status).toBe(200);\n    const json = await res.json();\n    const link = require(path.join(target, '.vercel/project.json'));\n    const resEnv = await apiFetch(`/v4/projects/${link.projectId}/env`, {\n      method: 'POST',\n      body: JSON.stringify({\n        key: 'MY_DECRYPTABLE_SECRET_ENV',\n        value: json.uid,\n        target: ['development'],\n        type: 'secret'\n      })\n    });\n    expect(resEnv.status).toBe(200);\n  }\n  async function vcEnvPull() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'pull', '-y'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    expect(stderr).toMatch(/Created .env.local file/gm);\n    const contents = fs.readFileSync(path.join(target, '.env.local'), 'utf8');\n    expect(contents).toMatch(/^# Created by Vercel CLI\\n/);\n    expect(contents).toMatch(/MY_NEW_ENV_VAR=\"my plaintext value\"/);\n    expect(contents).toMatch(/MY_STDIN_VAR=\"{\"expect\":\"quotes\"}\"/);\n    expect(contents).toMatch(/MY_DECRYPTABLE_SECRET_ENV=\"decryptable value\"/);\n    expect(contents).not.toMatch(/MY_PREVIEW/);\n  }\n  async function vcEnvPullOverwrite() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'pull'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    expect(stderr).toMatch(/Overwriting existing .env.local file/gm);\n    expect(stderr).toMatch(/Updated .env.local file/gm);\n  }\n  async function vcEnvPullConfirm() {\n    fs.writeFileSync(path.join(target, '.env.local'), 'hahaha');\n    const vc = execCli(binaryPath, ['env', 'pull'], {\n      cwd: target\n    });\n    await waitForPrompt(vc, 'Found existing file \".env.local\". Do you want to overwrite?');\n    vc.stdin?.end('y\\n');\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcDeployWithVar() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, [], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    const {\n      host\n    } = new URL(stdout);\n    const apiUrl = `https://${host}/api/get-env`;\n    const apiRes = await fetch(apiUrl);\n    expect(apiRes.status, apiUrl).toBe(200);\n    const apiJson = await apiRes.json();\n    expect(apiJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n    const homeUrl = `https://${host}`;\n    const homeRes = await fetch(homeUrl);\n    expect(homeRes.status, homeUrl).toBe(200);\n    const homeJson = await homeRes.json();\n    expect(homeJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n  }\n  async function vcDevWithEnv() {\n    const vc = execCli(binaryPath, ['dev', '--debug'], {\n      cwd: target\n    });\n    const localhost = await getLocalhost(vc);\n    const apiUrl = `${localhost[0]}/api/get-env`;\n    const apiRes = await fetch(apiUrl);\n    expect(apiRes.status).toBe(200);\n    const apiJson = await apiRes.json();\n    expect(apiJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n    expect(apiJson['MY_DECRYPTABLE_SECRET_ENV']).toBe('decryptable value');\n    const homeUrl = localhost[0];\n    const homeRes = await fetch(homeUrl);\n    const homeJson = await homeRes.json();\n    expect(homeJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n    expect(homeJson['MY_DECRYPTABLE_SECRET_ENV']).toBe('decryptable value');\n\n    // sleep before kill, otherwise the dev process doesn't clean up and exit properly\n    await sleep(100);\n    vc.kill('SIGTERM', {\n      forceKillAfterTimeout: 5000\n    });\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcDevAndFetchCloudVars() {\n    const vc = execCli(binaryPath, ['dev'], {\n      cwd: target\n    });\n    const localhost = await getLocalhost(vc);\n    const apiUrl = `${localhost[0]}/api/get-env`;\n    const apiRes = await fetch(apiUrl);\n    expect(apiRes.status).toBe(200);\n    const apiJson = await apiRes.json();\n    expect(apiJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n    expect(apiJson['MY_STDIN_VAR']).toBe('{\"expect\":\"quotes\"}');\n    expect(apiJson['MY_DECRYPTABLE_SECRET_ENV']).toBe('decryptable value');\n    const homeUrl = localhost[0];\n    const homeRes = await fetch(homeUrl);\n    const homeJson = await homeRes.json();\n    expect(homeJson['MY_NEW_ENV_VAR']).toBe('my plaintext value');\n    expect(homeJson['MY_STDIN_VAR']).toBe('{\"expect\":\"quotes\"}');\n    expect(homeJson['MY_DECRYPTABLE_SECRET_ENV']).toBe('decryptable value');\n\n    // system env vars are automatically exposed\n    expect(apiJson['VERCEL']).toBe('1');\n    expect(homeJson['VERCEL']).toBe('1');\n\n    // sleep before kill, otherwise the dev process doesn't clean up and exit properly\n    await sleep(100);\n    vc.kill('SIGTERM', {\n      forceKillAfterTimeout: 5000\n    });\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function enableAutoExposeSystemEnvs() {\n    const link = require(path.join(target, '.vercel/project.json'));\n    const res = await apiFetch(`/v2/projects/${link.projectId}`, {\n      method: 'PATCH',\n      body: JSON.stringify({\n        autoExposeSystemEnvs: true\n      })\n    });\n    expect(res.status).toBe(200);\n    if (res.status === 200) {\n      console.log(`Set autoExposeSystemEnvs=true for project ${link.projectId}`);\n    }\n  }\n  async function vcEnvPullFetchSystemVars() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'pull', '-y'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    const contents = fs.readFileSync(path.join(target, '.env.local'), 'utf8');\n    const lines = new Set(contents.split('\\n'));\n    expect(lines).toContain('VERCEL=\"1\"');\n    expect(lines).toContain('VERCEL_URL=\"\"');\n    expect(lines).toContain('VERCEL_ENV=\"development\"');\n    expect(lines).toContain('VERCEL_GIT_PROVIDER=\"\"');\n    expect(lines).toContain('VERCEL_GIT_REPO_SLUG=\"\"');\n  }\n  async function vcDevAndFetchSystemVars() {\n    const vc = execCli(binaryPath, ['dev'], {\n      cwd: target\n    });\n    const localhost = await getLocalhost(vc);\n    const apiUrl = `${localhost[0]}/api/get-env`;\n    const apiRes = await fetch(apiUrl);\n    const localhostNoProtocol = localhost[0].slice('http://'.length);\n    const apiJson = await apiRes.json();\n    expect(apiJson['VERCEL']).toBe('1');\n    expect(apiJson['VERCEL_URL']).toBe(localhostNoProtocol);\n    expect(apiJson['VERCEL_ENV']).toBe('development');\n    expect(apiJson['VERCEL_REGION']).toBe('dev1');\n    expect(apiJson['VERCEL_GIT_PROVIDER']).toBe('');\n    expect(apiJson['VERCEL_GIT_REPO_SLUG']).toBe('');\n    const homeUrl = localhost[0];\n    const homeRes = await fetch(homeUrl);\n    const homeJson = await homeRes.json();\n    expect(homeJson['VERCEL']).toBe('1');\n    expect(homeJson['VERCEL_URL']).toBe(localhostNoProtocol);\n    expect(homeJson['VERCEL_ENV']).toBe('development');\n    expect(homeJson['VERCEL_REGION']).toBe(undefined);\n    expect(homeJson['VERCEL_GIT_PROVIDER']).toBe('');\n    expect(homeJson['VERCEL_GIT_REPO_SLUG']).toBe('');\n\n    // sleep before kill, otherwise the dev process doesn't clean up and exit properly\n    await sleep(100);\n    vc.kill('SIGTERM', {\n      forceKillAfterTimeout: 5000\n    });\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvRemove() {\n    const vc = execCli(binaryPath, ['env', 'rm', '-y'], {\n      cwd: target\n    });\n    await waitForPrompt(vc, 'Whats the name of the variable?');\n    vc.stdin?.write('MY_PREVIEW\\n');\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await vc;\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  async function vcEnvRemoveWithArgs() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'rm', 'MY_STDIN_VAR', 'development', '-y'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n    const {\n      exitCode: exitCode3\n    } = await execCli(binaryPath, ['env', 'rm', 'MY_DECRYPTABLE_SECRET_ENV', 'development', '-y'], {\n      cwd: target\n    });\n    expect(exitCode3).toBe(0);\n  }\n  async function vcEnvRemoveWithNameOnly() {\n    const {\n      exitCode,\n      stdout,\n      stderr\n    } = await execCli(binaryPath, ['env', 'rm', 'MY_NEW_ENV_VAR', '-y'], {\n      cwd: target\n    });\n    expect(exitCode, formatOutput({\n      stdout,\n      stderr\n    })).toBe(0);\n  }\n  function vcEnvRemoveByName(name) {\n    return execCli(binaryPath, ['env', 'rm', name, '-y'], {\n      cwd: target\n    });\n  }\n  async function vcEnvRemoveAll() {\n    await vcEnvRemoveByName('MY_PREVIEW');\n    await vcEnvRemoveByName('MY_STDIN_VAR');\n    await vcEnvRemoveByName('MY_DECRYPTABLE_SECRET_ENV');\n    await vcEnvRemoveByName('MY_NEW_ENV_VAR');\n  }\n  try {\n    await vcEnvRemoveAll();\n    await vcLink();\n    await vcEnvLsIsEmpty();\n    await vcEnvAddWithPrompts();\n    await vcEnvAddFromStdin();\n    await vcEnvAddFromStdinPreview();\n    await vcEnvAddFromStdinPreviewWithBranch();\n    await vcEnvLsIncludesVar();\n    await createEnvWithDecryptableSecret();\n    await vcEnvPull();\n    await vcEnvPullOverwrite();\n    await vcEnvPullConfirm();\n    await vcDeployWithVar();\n    await vcDevWithEnv();\n    fs.unlinkSync(path.join(target, '.env.local'));\n    await vcDevAndFetchCloudVars();\n    await enableAutoExposeSystemEnvs();\n    await vcEnvPullFetchSystemVars();\n    fs.unlinkSync(path.join(target, '.env.local'));\n    await vcDevAndFetchSystemVars();\n    await vcEnvRemove();\n    await vcEnvRemoveWithArgs();\n    await vcEnvRemoveWithNameOnly();\n    await vcEnvLsIsEmpty();\n  } finally {\n    await vcEnvRemoveAll();\n  }\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 20 aliases by default","suites":["alias"],"updatePoint":{"line":6,"column":45,"index":256},"line":6,"code":"  it('should list up to 20 aliases by default', async () => {\n    useUser();\n    useAlias();\n    client.setArgv('alias', 'ls');\n    const exitCodePromise = alias(client);\n    await expect(exitCodePromise).resolves.toEqual(0);\n    await expect(client.stdout).toOutput('dummy-19.app');\n  });","file":"unit/commands/alias.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 2 aliases","suites":["alias"],"updatePoint":{"line":14,"column":33,"index":534},"line":14,"code":"  it('should list up to 2 aliases', async () => {\n    useUser();\n    useAlias();\n    client.setArgv('alias', 'ls', '--limit', '2');\n    const exitCodePromise = alias(client);\n    await expect(exitCodePromise).resolves.toEqual(0);\n    await expect(client.stdout).toOutput('dummy-1.app');\n  });","file":"unit/commands/alias.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should find the bad deployment","suites":["bisect"],"updatePoint":{"line":6,"column":36,"index":260},"line":6,"code":"  it('should find the bad deployment', async () => {\n    const user = useUser();\n    const now = Date.now();\n    const deployment1 = useDeployment({\n      creator: user,\n      createdAt: now\n    });\n    const deployment2 = useDeployment({\n      creator: user,\n      createdAt: now + 10000\n    });\n    const deployment3 = useDeployment({\n      creator: user,\n      createdAt: now + 20000\n    });\n\n    // also create an extra deployment before the known good deployment\n    // to make sure the bisect pool doesn't include it\n    useDeployment({\n      creator: user,\n      createdAt: now - 30000\n    });\n    const bisectPromise = bisect(client);\n    await expect(client.stderr).toOutput('Specify a URL where the bug occurs:');\n    client.stdin.write(`https://${deployment3.url}\\n`);\n    await expect(client.stderr).toOutput('Specify a URL where the bug does not occur:');\n    client.stdin.write(`https://${deployment1.url}\\n`);\n    await expect(client.stderr).toOutput('Specify the URL subpath where the bug occurs:');\n    client.stdin.write('/docs\\n');\n    await expect(client.stderr).toOutput('Bisecting');\n    await expect(client.stderr).toOutput(`Deployment URL: https://${deployment2.url}`);\n    client.stdin.write('b\\n');\n    await expect(client.stderr).toOutput(`The first bad deployment is: https://${deployment2.url}`);\n    await expect(bisectPromise).resolves.toEqual(0);\n  });","file":"unit/commands/bisect.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build with `@vercel/static`","suites":["build"],"updatePoint":{"line":16,"column":40,"index":684},"line":16,"code":"  it('should build with `@vercel/static`', async () => {\n    const cwd = fixture('static');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/static\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/static',\n        apiVersion: 2,\n        src: '**',\n        use: '@vercel/static'\n      }]\n    });\n\n    // \"static\" directory contains static files\n    const files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['index.html']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build with `@now/static`","suites":["build"],"updatePoint":{"line":39,"column":37,"index":1408},"line":39,"code":"  it('should build with `@now/static`', async () => {\n    const cwd = fixture('now-static');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@now/static',\n        apiVersion: 2,\n        src: 'www/index.html',\n        use: '@now/static'\n      }]\n    });\n    const files = await fs.readdir(join(output, 'static'));\n    expect(files).toEqual(['www']);\n    const www = await fs.readdir(join(output, 'static', 'www'));\n    expect(www).toEqual(['index.html']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build with `@vercel/node`","suites":["build"],"updatePoint":{"line":60,"column":38,"index":2129},"line":60,"code":"  it('should build with `@vercel/node`', async () => {\n    const cwd = fixture('node');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/node\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'api/es6.js',\n        config: {\n          zeroConfig: true\n        }\n      }, {\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'api/index.js',\n        config: {\n          zeroConfig: true\n        }\n      }, {\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'api/mjs.mjs',\n        config: {\n          zeroConfig: true\n        }\n      }, {\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'api/typescript.ts',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // \"static\" directory is empty\n    const hasStaticFiles = await fs.pathExists(join(output, 'static'));\n    expect(hasStaticFiles, 'Expected \".vercel/output/static\" to not exist').toEqual(false);\n\n    // \"functions/api\" directory has output Functions\n    const functions = await fs.readdir(join(output, 'functions/api'));\n    expect(functions.sort()).toEqual(['es6.func', 'index.func', 'mjs.func', 'typescript.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle symlinked static files","suites":["build"],"updatePoint":{"line":114,"column":42,"index":3722},"line":114,"code":"  it('should handle symlinked static files', async () => {\n    const cwd = fixture('static-symlink');\n    const output = join(cwd, '.vercel/output');\n\n    // try to create the symlink, if it fails (e.g. Windows), skip the test\n    try {\n      await fs.unlink(join(cwd, 'foo.html'));\n      await fs.symlink(join(cwd, 'index.html'), join(cwd, 'foo.html'));\n    } catch (e) {\n      console.log('Symlinks not available, skipping test');\n      return;\n    }\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/static\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/static',\n        apiVersion: 2,\n        src: '**',\n        use: '@vercel/static'\n      }]\n    });\n\n    // \"static\" directory contains static files\n    const files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['foo.html', 'index.html']);\n    expect((await fs.lstat(join(output, 'static', 'foo.html'))).isSymbolicLink()).toEqual(true);\n    expect((await fs.lstat(join(output, 'static', 'index.html'))).isSymbolicLink()).toEqual(false);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should normalize \"src\" path in `vercel.json`","suites":["build"],"updatePoint":{"line":148,"column":50,"index":4979},"line":148,"code":"  it('should normalize \"src\" path in `vercel.json`', async () => {\n    const cwd = fixture('normalize-src');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/node\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'server.js'\n      }]\n    });\n\n    // `config.json` includes \"route\" from `vercel.json`\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toMatchObject({\n      version: 3,\n      routes: [{\n        src: '^/(.*)$',\n        dest: '/server.js'\n      }]\n    });\n\n    // \"static\" directory is empty\n    const hasStaticFiles = await fs.pathExists(join(output, 'static'));\n    expect(hasStaticFiles, 'Expected \".vercel/output/static\" to not exist').toEqual(false);\n\n    // \"functions\" directory has output Function\n    const functions = await fs.readdir(join(output, 'functions'));\n    expect(functions.sort()).toEqual(['server.js.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build with 3rd party Builder","suites":["build"],"updatePoint":{"line":185,"column":41,"index":6194},"line":185,"code":"  it('should build with 3rd party Builder', async () => {\n    const cwd = fixture('third-party-builder');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"txt-builder\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: 'txt-builder',\n        apiVersion: 3,\n        use: 'txt-builder@0.0.0',\n        src: 'api/foo.txt',\n        config: {\n          zeroConfig: true,\n          functions: {\n            'api/*.txt': {\n              runtime: 'txt-builder@0.0.0'\n            }\n          }\n        }\n      }, {\n        require: '@vercel/static',\n        apiVersion: 2,\n        use: '@vercel/static',\n        src: '!{api/**,package.json,middleware.[jt]s}',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // \"static\" directory is empty\n    const hasStaticFiles = await fs.pathExists(join(output, 'static'));\n    expect(hasStaticFiles, 'Expected \".vercel/output/static\" to not exist').toEqual(false);\n\n    // \"functions/api\" directory has output Functions\n    const functions = await fs.readdir(join(output, 'functions/api'));\n    expect(functions.sort()).toEqual(['foo.func']);\n    const vcConfig = await fs.readJSON(join(output, 'functions/api/foo.func/.vc-config.json'));\n    expect(vcConfig).toMatchObject({\n      handler: 'api/foo.txt',\n      runtime: 'provided',\n      environment: {}\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should serialize `EdgeFunction` output in version 3 Builder","suites":["build"],"updatePoint":{"line":234,"column":65,"index":7791},"line":234,"code":"  it('should serialize `EdgeFunction` output in version 3 Builder', async () => {\n    const cwd = fixture('edge-function');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    client.setArgv('build', '--prod');\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"edge-function\" Builder was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'production',\n      builds: [{\n        require: 'edge-function',\n        apiVersion: 3,\n        use: 'edge-function@0.0.0',\n        src: 'api/edge.js',\n        config: {\n          zeroConfig: true,\n          functions: {\n            'api/*.js': {\n              runtime: 'edge-function@0.0.0'\n            }\n          }\n        }\n      }, {\n        require: '@vercel/static',\n        apiVersion: 2,\n        use: '@vercel/static',\n        src: '!{api/**,package.json,middleware.[jt]s}',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // \"static\" directory is empty\n    const hasStaticFiles = await fs.pathExists(join(output, 'static'));\n    expect(hasStaticFiles, 'Expected \".vercel/output/static\" to not exist').toEqual(false);\n\n    // \"functions/api\" directory has output Functions\n    const functions = await fs.readdir(join(output, 'functions/api'));\n    expect(functions.sort()).toEqual(['edge.func']);\n    const vcConfig = await fs.readJSON(join(output, 'functions/api/edge.func/.vc-config.json'));\n    expect(vcConfig).toMatchObject({\n      runtime: 'edge',\n      name: 'api/edge.js',\n      deploymentTarget: 'v8-worker',\n      entrypoint: 'api/edge.js'\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should pull \"preview\" env vars by default","suites":["build"],"updatePoint":{"line":285,"column":47,"index":9463},"line":285,"code":"  it('should pull \"preview\" env vars by default', async () => {\n    const cwd = fixture('static-pull');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'vercel-pull-next',\n      name: 'vercel-pull-next'\n    });\n    const envFilePath = join(cwd, '.vercel', '.env.preview.local');\n    const projectJsonPath = join(cwd, '.vercel', 'project.json');\n    const originalProjectJson = await fs.readJSON(join(cwd, '.vercel/project.json'));\n    try {\n      client.cwd = cwd;\n      client.setArgv('build', '--yes');\n      const exitCode = await build(client);\n      expect(exitCode).toEqual(0);\n      const previewEnv = await fs.readFile(envFilePath, 'utf8');\n      const envFileHasPreviewEnv = previewEnv.includes('REDIS_CONNECTION_STRING');\n      expect(envFileHasPreviewEnv).toBeTruthy();\n    } finally {\n      await fs.remove(envFilePath);\n      await fs.writeJSON(projectJsonPath, originalProjectJson, {\n        spaces: 2\n      });\n    }\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should pull \"production\" env vars with `--prod`","suites":["build"],"updatePoint":{"line":312,"column":53,"index":10454},"line":312,"code":"  it('should pull \"production\" env vars with `--prod`', async () => {\n    const cwd = fixture('static-pull');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'vercel-pull-next',\n      name: 'vercel-pull-next'\n    });\n    const envFilePath = join(cwd, '.vercel', '.env.production.local');\n    const projectJsonPath = join(cwd, '.vercel', 'project.json');\n    const originalProjectJson = await fs.readJSON(join(cwd, '.vercel/project.json'));\n    try {\n      client.cwd = cwd;\n      client.setArgv('build', '--yes', '--prod');\n      const exitCode = await build(client);\n      expect(exitCode).toEqual(0);\n      const prodEnv = await fs.readFile(envFilePath, 'utf8');\n      const envFileHasProductionEnv1 = prodEnv.includes('REDIS_CONNECTION_STRING');\n      expect(envFileHasProductionEnv1).toBeTruthy();\n      const envFileHasProductionEnv2 = prodEnv.includes('SQL_CONNECTION_STRING');\n      expect(envFileHasProductionEnv2).toBeTruthy();\n    } finally {\n      await fs.remove(envFilePath);\n      await fs.writeJSON(projectJsonPath, originalProjectJson, {\n        spaces: 2\n      });\n    }\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build root-level `middleware.js` and exclude from static files","suites":["build"],"updatePoint":{"line":341,"column":75,"index":11617},"line":341,"code":"  it('should build root-level `middleware.js` and exclude from static files', async () => {\n    const cwd = fixture('middleware');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/node\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'middleware.js',\n        config: {\n          zeroConfig: true,\n          middleware: true\n        }\n      }, {\n        require: '@vercel/static',\n        apiVersion: 2,\n        use: '@vercel/static',\n        src: '!{api/**,package.json,middleware.[jt]s}',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // `config.json` includes the \"middlewarePath\" route\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toMatchObject({\n      version: 3,\n      routes: [{\n        src: '^/.*$',\n        middlewarePath: 'middleware',\n        middlewareRawSrc: [],\n        override: true,\n        continue: true\n      }, {\n        handle: 'error'\n      }, {\n        status: 404,\n        src: '^(?!/api).*$',\n        dest: '/404.html'\n      }]\n    });\n\n    // \"static\" directory contains `index.html`, but *not* `middleware.js`\n    const staticFiles = await fs.readdir(join(output, 'static'));\n    expect(staticFiles.sort()).toEqual(['index.html']);\n\n    // \"functions\" directory contains `middleware.func`\n    const functions = await fs.readdir(join(output, 'functions'));\n    expect(functions.sort()).toEqual(['middleware.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build root-level `middleware.js` with \"Root Directory\" setting","suites":["build"],"updatePoint":{"line":399,"column":75,"index":13376},"line":399,"code":"  it('should build root-level `middleware.js` with \"Root Directory\" setting', async () => {\n    const cwd = fixture('middleware-root-directory');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/static\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'middleware.js',\n        config: {\n          zeroConfig: true,\n          middleware: true\n        }\n      }, {\n        require: '@vercel/static',\n        apiVersion: 2,\n        use: '@vercel/static',\n        src: '!{api/**,package.json,middleware.[jt]s}',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // `config.json` includes the \"middlewarePath\" route\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toMatchObject({\n      version: 3,\n      routes: [{\n        src: '^/.*$',\n        middlewarePath: 'middleware',\n        middlewareRawSrc: [],\n        override: true,\n        continue: true\n      }, {\n        handle: 'error'\n      }, {\n        status: 404,\n        src: '^(?!/api).*$',\n        dest: '/404.html'\n      }]\n    });\n\n    // \"static\" directory contains `index.html`, but *not* `middleware.js`\n    const staticFiles = await fs.readdir(join(output, 'static'));\n    expect(staticFiles.sort()).toEqual(['index.html']);\n\n    // \"functions\" directory contains `middleware.func`\n    const functions = await fs.readdir(join(output, 'functions'));\n    expect(functions.sort()).toEqual(['middleware.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build root-level `middleware.js` with \"matcher\" config","suites":["build"],"updatePoint":{"line":457,"column":67,"index":15144},"line":457,"code":"  it('should build root-level `middleware.js` with \"matcher\" config', async () => {\n    const cwd = fixture('middleware-with-matcher');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/node\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/node',\n        apiVersion: 3,\n        use: '@vercel/node',\n        src: 'middleware.js',\n        config: {\n          zeroConfig: true,\n          middleware: true\n        }\n      }, {\n        require: '@vercel/static',\n        apiVersion: 2,\n        use: '@vercel/static',\n        src: '!{api/**,package.json,middleware.[jt]s}',\n        config: {\n          zeroConfig: true\n        }\n      }]\n    });\n\n    // `config.json` includes the \"middlewarePath\" route\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toMatchObject({\n      version: 3,\n      routes: [{\n        src: '^\\\\/about(?:\\\\/((?:[^\\\\/#\\\\?]+?)(?:\\\\/(?:[^\\\\/#\\\\?]+?))*))?[\\\\/#\\\\?]?$|^\\\\/dashboard(?:\\\\/((?:[^\\\\/#\\\\?]+?)(?:\\\\/(?:[^\\\\/#\\\\?]+?))*))?[\\\\/#\\\\?]?$',\n        middlewarePath: 'middleware',\n        middlewareRawSrc: ['/about/:path*', '/dashboard/:path*'],\n        override: true,\n        continue: true\n      }, {\n        handle: 'error'\n      }, {\n        status: 404,\n        src: '^(?!/api).*$',\n        dest: '/404.html'\n      }]\n    });\n\n    // \"static\" directory contains `index.html`, but *not* `middleware.js`\n    const staticFiles = await fs.readdir(join(output, 'static'));\n    expect(staticFiles.sort()).toEqual(['index.html']);\n\n    // \"functions\" directory contains `middleware.func`\n    const functions = await fs.readdir(join(output, 'functions'));\n    expect(functions.sort()).toEqual(['middleware.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should support `--output` parameter","suites":["build"],"updatePoint":{"line":515,"column":41,"index":17058},"line":515,"code":"  it('should support `--output` parameter', async () => {\n    const cwd = fixture('static');\n    const output = await getWriteableDirectory();\n    try {\n      client.cwd = cwd;\n      client.setArgv('build', '--output', output);\n      const exitCode = await build(client);\n      expect(exitCode).toEqual(0);\n\n      // `builds.json` says that \"@vercel/static\" was run\n      const builds = await fs.readJSON(join(output, 'builds.json'));\n      expect(builds).toMatchObject({\n        target: 'preview',\n        builds: [{\n          require: '@vercel/static',\n          apiVersion: 2,\n          src: '**',\n          use: '@vercel/static'\n        }]\n      });\n\n      // \"static\" directory contains static files\n      const files = await fs.readdir(join(output, 'static'));\n      expect(files.sort()).toEqual(['index.html']);\n    } finally {\n      await fs.remove(output);\n    }\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should support Builder that doesn't export `version`","suites":["build"],"updatePoint":{"line":546,"column":58,"index":18098},"line":546,"code":"  it(\"should support Builder that doesn't export `version`\", async () => {\n    const cwd = fixture('versionless-builder');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"versionless-builder\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: 'versionless-builder',\n        src: 'package.json',\n        use: 'versionless-builder@0.0.0'\n      }]\n    });\n\n    // \"static\" directory contains static files\n    const files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['file']);\n    expect(await fs.readFile(join(output, 'static/file'), 'utf8')).toEqual('file contents');\n\n    // \"functions\" directory has output Functions\n    const functions = await fs.readdir(join(output, 'functions'));\n    expect(functions.sort()).toEqual(['withTrailingSlash.func']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should store `detectBuilders()` error in `builds.json`","suites":["build"],"updatePoint":{"line":573,"column":60,"index":19137},"line":573,"code":"  it('should store `detectBuilders()` error in `builds.json`', async () => {\n    const cwd = fixture('error-vercel-json-validation');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(1);\n\n    // Error gets printed to the terminal\n    await expect(client.stderr).toOutput('Error: Function must contain at least one property.');\n\n    // `builds.json` contains top-level \"error\" property\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds.builds).toBeUndefined();\n    expect(builds.error.code).toEqual('invalid_function');\n    expect(builds.error.message).toEqual('Function must contain at least one property.');\n\n    // `config.json` contains `version`\n    const configJson = await fs.readJSON(join(output, 'config.json'));\n    expect(configJson.version).toBe(3);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should store Builder error in `builds.json`","suites":["build"],"updatePoint":{"line":593,"column":49,"index":20020},"line":593,"code":"  it('should store Builder error in `builds.json`', async () => {\n    const cwd = fixture('node-error');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(1);\n\n    // Error gets printed to the terminal\n    await expect(client.stderr).toOutput(\"Duplicate identifier 'res'.\");\n\n    // `builds.json` contains \"error\" build\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds.builds).toHaveLength(4);\n    const errorBuilds = builds.builds.filter(b => 'error' in b);\n    expect(errorBuilds).toHaveLength(1);\n    expect(errorBuilds[0].error).toEqual({\n      name: 'Error',\n      message: expect.stringContaining('TS1005'),\n      stack: expect.stringContaining('api/typescript.ts'),\n      hideStackTrace: true,\n      code: 'NODE_TYPESCRIPT_ERROR'\n    });\n\n    // top level \"error\" also contains the same error\n    expect(builds.error).toEqual({\n      name: 'Error',\n      message: expect.stringContaining('TS1005'),\n      stack: expect.stringContaining('api/typescript.ts'),\n      hideStackTrace: true,\n      code: 'NODE_TYPESCRIPT_ERROR'\n    });\n\n    // `config.json` contains `version`\n    const configJson = await fs.readJSON(join(output, 'config.json'));\n    expect(configJson.version).toBe(3);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error when \"functions\" has runtime that emits discontinued \"nodejs12.x\"","suites":["build"],"updatePoint":{"line":629,"column":84,"index":21377},"line":629,"code":"  it('should error when \"functions\" has runtime that emits discontinued \"nodejs12.x\"', async () => {\n    if (process.platform === 'win32') {\n      console.log('Skipping test on Windows');\n      return;\n    }\n    const cwd = fixture('discontinued-nodejs12.x');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(1);\n\n    // Error gets printed to the terminal\n    await expect(client.stderr).toOutput('The Runtime \"vercel-php@0.1.0\" is using \"nodejs12.x\", which is discontinued. Please upgrade your Runtime to a more recent version or consult the author for more details.');\n\n    // `builds.json` contains \"error\" build\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    const errorBuilds = builds.builds.filter(b => 'error' in b);\n    expect(errorBuilds).toHaveLength(1);\n    expect(errorBuilds[0].error).toEqual({\n      name: 'Error',\n      message: expect.stringContaining('Please upgrade your Runtime'),\n      stack: expect.stringContaining('Please upgrade your Runtime'),\n      hideStackTrace: true,\n      code: 'NODEJS_DISCONTINUED_VERSION',\n      link: 'https://github.com/vercel/vercel/blob/main/DEVELOPING_A_RUNTIME.md#lambdaruntime'\n    });\n\n    // top level \"error\" also contains the same error\n    expect(builds.error).toEqual({\n      name: 'Error',\n      message: expect.stringContaining('Please upgrade your Runtime'),\n      stack: expect.stringContaining('Please upgrade your Runtime'),\n      hideStackTrace: true,\n      code: 'NODEJS_DISCONTINUED_VERSION',\n      link: 'https://github.com/vercel/vercel/blob/main/DEVELOPING_A_RUNTIME.md#lambdaruntime'\n    });\n\n    // `config.json` contains `version`\n    const configJson = await fs.readJSON(join(output, 'config.json'));\n    expect(configJson.version).toBe(3);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow for missing \"build\" script","suites":["build"],"updatePoint":{"line":670,"column":45,"index":23180},"line":670,"code":"  it('should allow for missing \"build\" script', async () => {\n    const cwd = fixture('static-with-pkg');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `builds.json` says that \"@vercel/static\" was run\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds).toMatchObject({\n      target: 'preview',\n      builds: [{\n        require: '@vercel/static',\n        apiVersion: 2,\n        src: '**',\n        use: '@vercel/static'\n      }]\n    });\n\n    // \"static\" directory contains static files\n    const files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['index.html', 'package.json']);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set `VERCEL_ANALYTICS_ID` environment variable","suites":["build"],"updatePoint":{"line":693,"column":59,"index":23951},"line":693,"code":"  it('should set `VERCEL_ANALYTICS_ID` environment variable', async () => {\n    const cwd = fixture('vercel-analytics');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const env = await fs.readJSON(join(output, 'static', 'env.json'));\n    expect(Object.keys(env).includes('VERCEL_ANALYTICS_ID')).toEqual(true);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should load environment variables from `.vercel/.env.preview.local`","suites":["build"],"updatePoint":{"line":702,"column":73,"index":24384},"line":702,"code":"  it('should load environment variables from `.vercel/.env.preview.local`', async () => {\n    const cwd = fixture('env-from-vc-pull');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const env = await fs.readJSON(join(output, 'static', 'env.json'));\n    expect(env['ENV_FILE']).toEqual('preview');\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should load environment variables from `.vercel/.env.production.local`","suites":["build"],"updatePoint":{"line":711,"column":76,"index":24792},"line":711,"code":"  it('should load environment variables from `.vercel/.env.production.local`', async () => {\n    const cwd = fixture('env-from-vc-pull');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    client.setArgv('build', '--prod');\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const env = await fs.readJSON(join(output, 'static', 'env.json'));\n    expect(env['ENV_FILE']).toEqual('production');\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should NOT load environment variables from `.env`","suites":["build"],"updatePoint":{"line":721,"column":55,"index":25221},"line":721,"code":"  it('should NOT load environment variables from `.env`', async () => {\n    const cwd = fixture('env-root-level');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const env = await fs.readJSON(join(output, 'static', 'env.json'));\n    // The `.env` in this fixture has `ENV_FILE=root\"`,\n    // so if that's not defined then we're good\n    expect(env['ENV_FILE']).toBeUndefined();\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should apply function configuration from \"vercel.json\" to Serverless Functions","suites":["build"],"updatePoint":{"line":732,"column":84,"index":25736},"line":732,"code":"  it('should apply function configuration from \"vercel.json\" to Serverless Functions', async () => {\n    const cwd = fixture('lambda-with-128-memory');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // \"functions/api\" directory has output Functions\n    const functions = await fs.readdir(join(output, 'functions/api'));\n    expect(functions.sort()).toEqual(['memory.func']);\n    const vcConfig = await fs.readJSON(join(output, 'functions/api/memory.func/.vc-config.json'));\n    expect(vcConfig).toMatchObject({\n      handler: 'api/memory.js',\n      memory: 128,\n      environment: {},\n      launcherType: 'Nodejs',\n      shouldAddHelpers: true,\n      shouldAddSourcemapSupport: false,\n      awsLambdaHandler: ''\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should apply project settings overrides from \"vercel.json\"","suites":["build"],"updatePoint":{"line":753,"column":64,"index":26545},"line":753,"code":"  it('should apply project settings overrides from \"vercel.json\"', async () => {\n    if (process.platform === 'win32') {\n      // this test runs a build command with `mkdir -p` which is unsupported on Windows\n      console.log('Skipping test on Windows');\n      return;\n    }\n    const cwd = fixture('project-settings-override');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // The `buildCommand` override in \"vercel.json\" outputs \"3\" to the\n    // index.txt file, so verify that that was produced in the build output\n    const contents = await fs.readFile(join(output, 'static/index.txt'), 'utf8');\n    expect(contents.trim()).toEqual('3');\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should set VERCEL_PROJECT_SETTINGS_ environment variables","suites":["build"],"updatePoint":{"line":770,"column":63,"index":27297},"line":770,"code":"  it('should set VERCEL_PROJECT_SETTINGS_ environment variables', async () => {\n    const cwd = fixture('project-settings-env-vars');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    const contents = await fs.readJSON(join(output, 'static/env.json'));\n    expect(contents).toMatchObject({\n      VERCEL_PROJECT_SETTINGS_BUILD_COMMAND: `node build.cjs`,\n      VERCEL_PROJECT_SETTINGS_INSTALL_COMMAND: '',\n      VERCEL_PROJECT_SETTINGS_OUTPUT_DIRECTORY: 'out',\n      VERCEL_PROJECT_SETTINGS_NODE_VERSION: '18.x'\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should apply \"images\" configuration from `vercel.json`","suites":["build"],"updatePoint":{"line":784,"column":60,"index":27917},"line":784,"code":"  it('should apply \"images\" configuration from `vercel.json`', async () => {\n    const cwd = fixture('images');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n\n    // `config.json` includes \"images\" from `vercel.json`\n    const configJson = await fs.readJSON(join(output, 'config.json'));\n    expect(configJson).toMatchObject({\n      images: {\n        sizes: [256, 384, 600, 1000],\n        domains: [],\n        minimumCacheTTL: 60,\n        formats: ['image/avif', 'image/webp'],\n        contentDispositionType: 'attachment'\n      }\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with invalid \"rewrites\" configuration from `vercel.json`","suites":["build"],"updatePoint":{"line":803,"column":74,"index":28575},"line":803,"code":"  it('should fail with invalid \"rewrites\" configuration from `vercel.json`', async () => {\n    const cwd = fixture('invalid-rewrites');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(1);\n    await expect(client.stderr).toOutput('Error: Invalid vercel.json - `rewrites[2]` should NOT have additional property `src`. Did you mean `source`?' + '\\n' + 'View Documentation: https://vercel.com/docs/concepts/projects/project-configuration#rewrites');\n    const builds = await fs.readJSON(join(output, 'builds.json'));\n    expect(builds.builds).toBeUndefined();\n    expect(builds.error).toEqual({\n      name: 'Error',\n      message: 'Invalid vercel.json - `rewrites[2]` should NOT have additional property `src`. Did you mean `source`?',\n      stack: expect.stringContaining('at validateConfig'),\n      hideStackTrace: true,\n      code: 'INVALID_VERCEL_CONFIG',\n      link: 'https://vercel.com/docs/concepts/projects/project-configuration#rewrites',\n      action: 'View Documentation'\n    });\n    const configJson = await fs.readJSON(join(output, 'config.json'));\n    expect(configJson.version).toBe(3);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should include crons property in build output","suites":["build"],"updatePoint":{"line":824,"column":51,"index":29749},"line":824,"code":"  it('should include crons property in build output', async () => {\n    const cwd = fixture('with-cron');\n    const output = join(cwd, '.vercel', 'output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toBe(0);\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toHaveProperty('crons', [{\n      path: '/api/cron-job',\n      schedule: '0 0 * * *'\n    }]);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should merge crons property from build output with vercel.json crons property","suites":["build"],"updatePoint":{"line":836,"column":83,"index":30217},"line":836,"code":"  it('should merge crons property from build output with vercel.json crons property', async () => {\n    const cwd = fixture('with-cron-merge');\n    const output = join(cwd, '.vercel', 'output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toBe(0);\n    const config = await fs.readJSON(join(output, 'config.json'));\n    expect(config).toHaveProperty('crons', [{\n      path: '/api/cron-job',\n      schedule: '0 0 * * *'\n    }, {\n      path: '/api/cron-job-build-output',\n      schedule: '0 0 * * *'\n    }]);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"use-classic","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":864,"column":19,"index":31404},"line":864,"code":"    it('use-classic', async function () {\n      const packageDir = join(output, 'functions/api', 'use-classic.func', 'packages', 'only-classic');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('index.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"use-main","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":869,"column":16,"index":31670},"line":869,"code":"    it('use-main', async function () {\n      const packageDir = join(output, 'functions/api', 'use-main.func', 'packages', 'only-main');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-main.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"use-module","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":874,"column":18,"index":31936},"line":874,"code":"    it('use-module', async function () {\n      const packageDir = join(output, 'functions/api', 'use-module.func', 'packages', 'only-module');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-module.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"use-browser","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":879,"column":19,"index":32209},"line":879,"code":"    it('use-browser', async function () {\n      const packageDir = join(output, 'functions/api', 'use-browser.func', 'packages', 'only-browser');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-browser.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"prefer-browser","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":884,"column":22,"index":32488},"line":884,"code":"    it('prefer-browser', async function () {\n      const packageDir = join(output, 'functions/api', 'prefer-browser.func', 'packages', 'prefer-browser');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-browser.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"prefer-main","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":889,"column":19,"index":32769},"line":889,"code":"    it('prefer-main', async function () {\n      const packageDir = join(output, 'functions/api', 'prefer-main.func', 'packages', 'prefer-main');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-main.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"prefer-module","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":894,"column":21,"index":33043},"line":894,"code":"    it('prefer-module', async function () {\n      const packageDir = join(output, 'functions/api', 'prefer-module.func', 'packages', 'prefer-module');\n      const packageDistFiles = await fs.readdir(packageDir);\n      expect(packageDistFiles).toContain('dist-module.js');\n    });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should use --local-config over default vercel.json","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":900,"column":56,"index":33364},"line":900,"code":"  it('should use --local-config over default vercel.json', async () => {\n    const cwd = fixture('local-config');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    let exitCode = await build(client);\n    delete process.env.__VERCEL_BUILD_RUNNING;\n    expect(exitCode).toEqual(0);\n    let config = await fs.readJSON(join(output, 'config.json'));\n    expect(config.routes).toContainEqual({\n      src: '^/another-main$',\n      dest: '/main.html'\n    });\n    expect(config.routes).not.toContainEqual({\n      src: '^/another-test$',\n      dest: '/test.html'\n    });\n    client.localConfigPath = 'vercel-test.json';\n    exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    config = await fs.readJSON(join(output, 'config.json'));\n    expect(config.routes).not.toContainEqual({\n      src: '^/another-main$',\n      dest: '/main.html'\n    });\n    expect(config.routes).toContainEqual({\n      src: '^/another-test$',\n      dest: '/test.html'\n    });\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build Storybook project and ignore middleware","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":929,"column":58,"index":34352},"line":929,"code":"  it('should build Storybook project and ignore middleware', async () => {\n    const cwd = fixture('storybook-with-middleware');\n    const output = join(cwd, '.vercel/output');\n    try {\n      client.cwd = cwd;\n      process.env.STORYBOOK_DISABLE_TELEMETRY = '1';\n      execSync('yarn');\n      const exitCode = await build(client);\n      expect(exitCode).toEqual(0);\n\n      // `builds.json` says that \"@vercel/static\" was run\n      const builds = await fs.readJSON(join(output, 'builds.json'));\n      expect(builds).toMatchObject({\n        target: 'preview',\n        builds: [{\n          require: '@vercel/static-build',\n          apiVersion: 2,\n          src: 'package.json',\n          use: '@vercel/static-build'\n        }]\n      });\n      const files = await fs.readdir(output);\n      // we should NOT see `functions` because that means `middleware.ts` was processed\n      expect(files.sort()).toEqual(['builds.json', 'config.json', 'static']);\n    } finally {\n      delete process.env.STORYBOOK_DISABLE_TELEMETRY;\n    }\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if .npmrc exists containing use-node-version","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":957,"column":63,"index":35387},"line":957,"code":"  it('should error if .npmrc exists containing use-node-version', async () => {\n    const cwd = fixture('npmrc-use-node-version');\n    client.cwd = cwd;\n    client.setArgv('build');\n    const exitCodePromise = build(client);\n    await expect(client.stderr).toOutput('Error: Detected unsupported');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore `.env` for static site","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":965,"column":42,"index":35725},"line":965,"code":"  it('should ignore `.env` for static site', async () => {\n    const cwd = fixture('static-env');\n    const output = join(cwd, '.vercel/output');\n    client.cwd = cwd;\n    const exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    expect(fs.existsSync(join(output, 'static', 'index.html'))).toBe(true);\n    expect(fs.existsSync(join(output, 'static', '.env'))).toBe(false);\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should build with `repo.json` link","suites":["build","should find packages with different main/module/browser keys"],"updatePoint":{"line":974,"column":40,"index":36119},"line":974,"code":"  it('should build with `repo.json` link', async () => {\n    const cwd = fixture('../../monorepo-link');\n    useUser();\n    useTeams('team_dummy');\n\n    // \"blog\" app\n    useProject({\n      ...defaultProject,\n      id: 'QmScb7GPQt6gsS',\n      name: 'monorepo-blog',\n      rootDirectory: 'blog',\n      outputDirectory: 'dist',\n      framework: null\n    });\n    let output = join(cwd, 'blog/.vercel/output');\n    client.cwd = join(cwd, 'blog');\n    client.setArgv('build', '--yes');\n    let exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    delete process.env.__VERCEL_BUILD_RUNNING;\n    let files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['index.txt']);\n    expect((await fs.readFile(join(output, 'static/index.txt'), 'utf8')).trim()).toEqual('blog');\n\n    // \"dashboard\" app\n    useProject({\n      ...defaultProject,\n      id: 'QmbKpqpiUqbcke',\n      name: 'monorepo-dashboard',\n      rootDirectory: 'dashboard',\n      outputDirectory: 'dist',\n      framework: null\n    });\n    output = join(cwd, 'dashboard/.vercel/output');\n    client.cwd = join(cwd, 'dashboard');\n    client.setArgv('build', '--yes');\n    exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    delete process.env.__VERCEL_BUILD_RUNNING;\n    files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['index.txt']);\n    expect((await fs.readFile(join(output, 'static/index.txt'), 'utf8')).trim()).toEqual('dashboard');\n\n    // \"marketing\" app\n    useProject({\n      ...defaultProject,\n      id: 'QmX6P93ChNDoZP',\n      name: 'monorepo-marketing',\n      rootDirectory: 'marketing',\n      outputDirectory: 'dist',\n      framework: null\n    });\n    output = join(cwd, 'marketing/.vercel/output');\n    client.cwd = join(cwd, 'marketing');\n    client.setArgv('build', '--yes');\n    exitCode = await build(client);\n    expect(exitCode).toEqual(0);\n    delete process.env.__VERCEL_BUILD_RUNNING;\n    files = await fs.readdir(join(output, 'static'));\n    expect(files.sort()).toEqual(['index.txt']);\n    expect((await fs.readFile(join(output, 'static/index.txt'), 'utf8')).trim()).toEqual('marketing');\n  });","file":"unit/commands/build/index.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 20 certs by default","suites":["certs"],"updatePoint":{"line":6,"column":43,"index":253},"line":6,"code":"  it('should list up to 20 certs by default', async () => {\n    useUser();\n    useCert();\n    client.setArgv('certs', 'ls');\n    const exitCodePromise = certs(client);\n    await expect(client.stdout).toOutput('dummy-19.cert');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/certs.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 2 certs if limit set to 2","suites":["certs"],"updatePoint":{"line":14,"column":49,"index":547},"line":14,"code":"  it('should list up to 2 certs if limit set to 2', async () => {\n    useUser();\n    useCert();\n    client.setArgv('certs', 'ls', '--limit', '2');\n    const exitCodePromise = certs(client);\n    await expect(client.stdout).toOutput('dummy-1.cert');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/certs.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying a single file","suites":["deploy"],"updatePoint":{"line":14,"column":43,"index":621},"line":14,"code":"  it('should reject deploying a single file', async () => {\n    client.setArgv('deploy', __filename);\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput(`Error: Support for single file deployments has been removed.\\nLearn More: https://vercel.link/no-single-file-deployments\\n`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying multiple files","suites":["deploy"],"updatePoint":{"line":20,"column":44,"index":997},"line":20,"code":"  it('should reject deploying multiple files', async () => {\n    client.setArgv('deploy', __filename, join(__dirname, 'inspect.test.ts'));\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput(`Error: Can't deploy more than one path.\\n`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying a directory that does not exist","suites":["deploy"],"updatePoint":{"line":26,"column":61,"index":1345},"line":26,"code":"  it('should reject deploying a directory that does not exist', async () => {\n    const badName = 'does-not-exist';\n    client.setArgv('deploy', badName);\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput(`Error: Could not find ${humanizePath(join(client.cwd, 'does-not-exist'))}\\n`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying when `--prebuilt` is used and `vc build` failed before Builders","suites":["deploy"],"updatePoint":{"line":33,"column":93,"index":1760},"line":33,"code":"  it('should reject deploying when `--prebuilt` is used and `vc build` failed before Builders', async () => {\n    const cwd = setupUnitFixture('build-output-api-failed-before-builds');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'build-output-api-failed-before-builds',\n      name: 'build-output-api-failed-before-builds'\n    });\n    client.setArgv('deploy', cwd, '--prebuilt');\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('> Prebuilt deployment cannot be created because `vercel build` failed with error:\\n\\nError: The build failed (top-level)\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying when `--prebuilt` is used and `vc build` failed within a Builder","suites":["deploy"],"updatePoint":{"line":47,"column":94,"index":2464},"line":47,"code":"  it('should reject deploying when `--prebuilt` is used and `vc build` failed within a Builder', async () => {\n    const cwd = setupUnitFixture('build-output-api-failed-within-build');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'build-output-api-failed-within-build',\n      name: 'build-output-api-failed-within-build'\n    });\n    client.setArgv('deploy', cwd, '--prebuilt');\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('> Prebuilt deployment cannot be created because `vercel build` failed with error:\\n\\nError: The build failed within a Builder\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying a directory that does not contain \".vercel/output\" when `--prebuilt` is used","suites":["deploy"],"updatePoint":{"line":61,"column":106,"index":3182},"line":61,"code":"  it('should reject deploying a directory that does not contain \".vercel/output\" when `--prebuilt` is used', async () => {\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      name: 'static',\n      id: 'static'\n    });\n    client.cwd = setupUnitFixture('commands/deploy/static');\n    client.setArgv('deploy', '--prebuilt');\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('Error: The \"--prebuilt\" option was used, but no prebuilt output found in \".vercel/output\". Run `vercel build` to generate a local build.\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying a directory that was built with a different target environment when `--prebuilt --prod` is used on \"preview\" output","suites":["deploy"],"updatePoint":{"line":75,"column":145,"index":3872},"line":75,"code":"  it('should reject deploying a directory that was built with a different target environment when `--prebuilt --prod` is used on \"preview\" output', async () => {\n    const cwd = setupUnitFixture('build-output-api-preview');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'build-output-api-preview',\n      name: 'build-output-api-preview'\n    });\n    client.setArgv('deploy', cwd, '--prebuilt', '--prod');\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('Error: The \"--prebuilt\" option was used with the target environment \"production\",' + ' but the prebuilt output found in \".vercel/output\" was built with target environment \"preview\".' + ' Please run `vercel --prebuilt`.\\n' + 'Learn More: https://vercel.link/prebuilt-environment-mismatch\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying a directory that was built with a different target environment when `--prebuilt` is used on \"production\" output","suites":["deploy"],"updatePoint":{"line":89,"column":141,"index":4760},"line":89,"code":"  it('should reject deploying a directory that was built with a different target environment when `--prebuilt` is used on \"production\" output', async () => {\n    const cwd = setupUnitFixture('build-output-api-production');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'build-output-api-production',\n      name: 'build-output-api-production'\n    });\n    client.setArgv('deploy', cwd, '--prebuilt');\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('Error: The \"--prebuilt\" option was used with the target environment \"preview\",' + ' but the prebuilt output found in \".vercel/output\" was built with target environment \"production\".' + ' Please run `vercel --prebuilt --prod`.\\n' + 'Learn More: https://vercel.link/prebuilt-environment-mismatch\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying \"version: 1\"","suites":["deploy"],"updatePoint":{"line":103,"column":42,"index":5555},"line":103,"code":"  it('should reject deploying \"version: 1\"', async () => {\n    client.setArgv('deploy');\n    client.localConfig = {\n      [fileNameSymbol]: 'vercel.json',\n      version: 1\n    };\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('Error: The value of the `version` property within vercel.json can only be `2`.\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject deploying \"version: {}\"","suites":["deploy"],"updatePoint":{"line":113,"column":43,"index":5966},"line":113,"code":"  it('should reject deploying \"version: {}\"', async () => {\n    client.setArgv('deploy');\n    client.localConfig = {\n      [fileNameSymbol]: 'vercel.json',\n      // @ts-ignore\n      version: {}\n    };\n    const exitCodePromise = deploy(client);\n    await expect(client.stderr).toOutput('Error: The `version` property inside your vercel.json file must be a number.\\n');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should send a tgz file when `--archive=tgz`","suites":["deploy"],"updatePoint":{"line":124,"column":49,"index":6402},"line":124,"code":"  it('should send a tgz file when `--archive=tgz`', async () => {\n    const user = useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      name: 'static',\n      id: 'static'\n    });\n    let body;\n    client.scenario.post(`/v13/deployments`, (req, res) => {\n      body = req.body;\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test'\n      });\n    });\n    client.scenario.get(`/v13/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n    client.scenario.get(`/v10/now/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n    client.cwd = setupUnitFixture('commands/deploy/static');\n    client.setArgv('deploy', '--archive=tgz');\n    const exitCode = await deploy(client);\n    expect(exitCode).toEqual(0);\n    expect(body?.files?.length).toEqual(1);\n    expect(body?.files?.[0].file).toEqual('.vercel/source.tgz');\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should pass flag to skip custom domain assignment","suites":["deploy"],"updatePoint":{"line":174,"column":55,"index":7792},"line":174,"code":"  it('should pass flag to skip custom domain assignment', async () => {\n    const user = useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      name: 'static',\n      id: 'static'\n    });\n    let body;\n    client.scenario.post(`/v13/deployments`, (req, res) => {\n      body = req.body;\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test'\n      });\n    });\n    client.scenario.get(`/v13/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n    client.cwd = setupUnitFixture('commands/deploy/static');\n    client.setArgv('deploy', '--prod', '--skip-domain');\n    const exitCode = await deploy(client);\n    expect(exitCode).toEqual(0);\n    expect(body).toMatchObject({\n      target: 'production',\n      source: 'cli',\n      autoAssignCustomDomains: false,\n      version: 2\n    });\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should upload missing files","suites":["deploy"],"updatePoint":{"line":216,"column":33,"index":8894},"line":216,"code":"  it('should upload missing files', async () => {\n    const cwd = setupUnitFixture('commands/deploy/static');\n    client.cwd = cwd;\n\n    // Add random 1mb file\n    await fs.writeFile(join(cwd, 'data'), randomBytes(bytes('1mb')));\n    const user = useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      name: 'static',\n      id: 'static'\n    });\n    let body;\n    let fileUploaded = false;\n    client.scenario.post(`/v13/deployments`, (req, res) => {\n      if (fileUploaded) {\n        body = req.body;\n        res.json({\n          creator: {\n            uid: user.id,\n            username: user.username\n          },\n          id: 'dpl_archive_test'\n        });\n      } else {\n        const sha = req.body.files[0].sha;\n        res.status(400).json({\n          error: {\n            code: 'missing_files',\n            message: 'Missing files',\n            missing: [sha]\n          }\n        });\n      }\n    });\n    client.scenario.post('/v2/files', (req, res) => {\n      // Wait for file to be finished uploading\n      req.on('data', () => {\n        // Noop\n      });\n      req.on('end', () => {\n        fileUploaded = true;\n        res.end();\n      });\n    });\n    client.scenario.get(`/v13/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n    client.scenario.get(`/v10/now/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n\n    // When stderr is not a TTY we expect 5 progress lines to be printed\n    client.stderr.isTTY = false;\n    client.setArgv('deploy', '--archive=tgz');\n    const uploadingLines = [];\n    client.stderr.on('data', data => {\n      if (data.startsWith('Uploading [')) {\n        uploadingLines.push(data);\n      }\n    });\n    client.stderr.resume();\n    const exitCode = await deploy(client);\n    expect(exitCode).toEqual(0);\n    expect(body?.files?.length).toEqual(1);\n    expect(body?.files?.[0].file).toEqual('.vercel/source.tgz');\n    expect(uploadingLines.length).toEqual(5);\n    expect(uploadingLines[0].startsWith('Uploading [--------------------]')).toEqual(true);\n    expect(uploadingLines[1].startsWith('Uploading [=====---------------]')).toEqual(true);\n    expect(uploadingLines[2].startsWith('Uploading [==========----------]')).toEqual(true);\n    expect(uploadingLines[3].startsWith('Uploading [===============-----]')).toEqual(true);\n    expect(uploadingLines[4].startsWith('Uploading [====================]')).toEqual(true);\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deploy project linked with `repo.json`","suites":["deploy"],"updatePoint":{"line":308,"column":51,"index":11768},"line":308,"code":"  it('should deploy project linked with `repo.json`', async () => {\n    const user = useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      name: 'app',\n      id: 'QmbKpqpiUqbcke'\n    });\n    let body;\n    client.scenario.post(`/v13/deployments`, (req, res) => {\n      body = req.body;\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test'\n      });\n    });\n    client.scenario.get(`/v13/deployments/dpl_archive_test`, (req, res) => {\n      res.json({\n        creator: {\n          uid: user.id,\n          username: user.username\n        },\n        id: 'dpl_archive_test',\n        readyState: 'READY',\n        aliasAssigned: true,\n        alias: []\n      });\n    });\n    const repoRoot = setupUnitFixture('commands/deploy/monorepo-static');\n    client.cwd = join(repoRoot, 'app');\n    client.setArgv('deploy');\n    const exitCode = await deploy(client);\n    expect(exitCode).toEqual(0);\n    expect(body).toMatchObject({\n      source: 'cli',\n      version: 2\n    });\n  });","file":"unit/commands/deploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 20 dns by default","suites":["dns"],"updatePoint":{"line":6,"column":41,"index":242},"line":6,"code":"  it('should list up to 20 dns by default', async () => {\n    useUser();\n    useDns();\n    client.setArgv('dns', 'ls');\n    let exitCodePromise = dns(client);\n    await expect(client.stderr).toOutput('example-19.com');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/dns.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 2 dns if limit set to 2","suites":["dns"],"updatePoint":{"line":14,"column":47,"index":528},"line":14,"code":"  it('should list up to 2 dns if limit set to 2', async () => {\n    useUser();\n    useDns();\n    client.setArgv('dns', 'ls', '--limit', 2);\n    let exitCodePromise = dns(client);\n    await expect(client.stderr).toOutput('example-2.com');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/dns.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 20 domains by default","suites":["domains"],"updatePoint":{"line":6,"column":45,"index":266},"line":6,"code":"  it('should list up to 20 domains by default', async () => {\n    useUser();\n    useDomains();\n    client.setArgv('domains', 'ls');\n    let exitCodePromise = domains(client);\n    await expect(client.stderr).toOutput('example-19.com');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/domains.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should list up to 2 domains if limit set to 2","suites":["domains"],"updatePoint":{"line":14,"column":51,"index":568},"line":14,"code":"  it('should list up to 2 domains if limit set to 2', async () => {\n    useUser();\n    useDomains();\n    client.setArgv('domains', 'ls', '--limit', '2');\n    const exitCodePromise = domains(client);\n    await expect(client.stderr).toOutput('example-1.com');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/domains.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle pulling","suites":["env","pull"],"updatePoint":{"line":12,"column":29,"index":485},"line":12,"code":"    it('should handle pulling', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--yes');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project vercel-env-pull');\n      await expect(client.stderr).toOutput('Created .env.local file and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const rawDevEnv = await fs.readFile(path.join(cwd, '.env.local'));\n\n      // check for development env value\n      const devFileHasDevEnv = rawDevEnv.toString().includes('SPECIAL_FLAG');\n      expect(devFileHasDevEnv).toBeTruthy();\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle pulling from Preview env vars","suites":["env","pull"],"updatePoint":{"line":33,"column":51,"index":1411},"line":33,"code":"    it('should handle pulling from Preview env vars', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--yes', '--environment', 'preview');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `preview` Environment Variables for Project vercel-env-pull');\n      await expect(client.stderr).toOutput('Created .env.local file and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n\n      // check for Preview env vars\n      const rawDevEnv = await fs.readFile(path.join(cwd, '.env.local'), 'utf8');\n      expect(rawDevEnv).toContain('REDIS_CONNECTION_STRING=\"redis://abc123@redis.example.com:6379\"');\n      expect(rawDevEnv).not.toContain('BRANCH_ENV_VAR=\"env var for a specific branch\"');\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle pulling from specific Git branch","suites":["env","pull"],"updatePoint":{"line":54,"column":54,"index":2435},"line":54,"code":"    it('should handle pulling from specific Git branch', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--yes', '--environment', 'preview', '--git-branch', 'feat/awesome-thing');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `preview` Environment Variables for Project vercel-env-pull');\n      await expect(client.stderr).toOutput('Created .env.local file and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n\n      // check for Preview env vars\n      const rawDevEnv = await fs.readFile(path.join(cwd, '.env.local'), 'utf8');\n      expect(rawDevEnv).toContain('REDIS_CONNECTION_STRING=\"redis://abc123@redis.example.com:6379\"');\n      expect(rawDevEnv).toContain('BRANCH_ENV_VAR=\"env var for a specific branch\"');\n      const parsed = parse(rawDevEnv);\n      const keys = Object.keys(parsed);\n      expect(keys).toHaveLength(3);\n      expect(keys[0]).toEqual('ANOTHER');\n      expect(keys[1]).toEqual('BRANCH_ENV_VAR');\n      expect(keys[2]).toEqual('REDIS_CONNECTION_STRING');\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle alternate filename","suites":["env","pull"],"updatePoint":{"line":81,"column":40,"index":3743},"line":81,"code":"    it('should handle alternate filename', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', 'other.env', '--yes');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project vercel-env-pull');\n      await expect(client.stderr).toOutput('Created other.env file');\n      await expect(client.stderr).not.toOutput('and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const rawDevEnv = await fs.readFile(path.join(cwd, 'other.env'));\n\n      // check for development env value\n      const devFileHasDevEnv = rawDevEnv.toString().includes('SPECIAL_FLAG');\n      expect(devFileHasDevEnv).toBeTruthy();\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should use given environment","suites":["env","pull"],"updatePoint":{"line":103,"column":36,"index":4716},"line":103,"code":"    it('should use given environment', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--environment', 'production');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput(`Downloading \\`production\\` Environment Variables for Project vercel-env-pull`);\n      await expect(client.stderr).toOutput('Created .env.local file and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const rawProdEnv = await fs.readFile(path.join(cwd, '.env.local'));\n\n      // check for development env value\n      const envFileHasEnv = rawProdEnv.toString().includes('REDIS_CONNECTION_STRING');\n      expect(envFileHasEnv).toBeTruthy();\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw an error when it does not recognize given environment","suites":["env","pull"],"updatePoint":{"line":124,"column":74,"index":5695},"line":124,"code":"    it('should throw an error when it does not recognize given environment', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '.env.production', '--environment', 'something-invalid');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput(`Invalid environment \\`something-invalid\\`. Valid options: <production | preview | development>`);\n      await expect(exitCodePromise).resolves.toEqual(1);\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should expose production system env variables","suites":["env","pull"],"updatePoint":{"line":139,"column":53,"index":6354},"line":139,"code":"    it('should expose production system env variables', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-env-pull',\n        name: 'vercel-env-pull',\n        autoExposeSystemEnvs: true\n      });\n      const cwd = setupUnitFixture('vercel-env-pull');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', 'other.env', '--yes');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project vercel-env-pull');\n      await expect(client.stderr).toOutput('Created other.env file');\n      await expect(client.stderr).not.toOutput('and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const rawDevEnv = await fs.readFile(path.join(cwd, 'other.env'));\n      const productionFileHasVercelEnv = rawDevEnv.toString().includes('VERCEL_ENV=\"development\"');\n      expect(productionFileHasVercelEnv).toBeTruthy();\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show a delta string","suites":["env","pull"],"updatePoint":{"line":160,"column":34,"index":7351},"line":160,"code":"    it('should show a delta string', async () => {\n      const cwd = setupUnitFixture('vercel-env-pull-delta');\n      client.cwd = cwd;\n      try {\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'env-pull-delta',\n          name: 'env-pull-delta'\n        });\n        client.setArgv('env', 'add', 'NEW_VAR');\n        const addPromise = env(client);\n        await expect(client.stderr).toOutput('Whats the value of NEW_VAR?');\n        client.stdin.write('testvalue\\n');\n        await expect(client.stderr).toOutput('Add NEW_VAR to which Environments (select multiple)?');\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\x1B[B');\n        client.stdin.write(' ');\n        client.stdin.write('\\r');\n        await expect(addPromise).resolves.toEqual(0);\n        client.setArgv('env', 'pull', '--yes');\n        const pullPromise = env(client);\n        await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project env-pull-delta');\n        await expect(client.stderr).toOutput('+ SPECIAL_FLAG (Updated)\\n+ NEW_VAR\\n- TEST\\n');\n        await expect(client.stderr).toOutput('Updated .env.local file and added it to .gitignore');\n        await expect(pullPromise).resolves.toEqual(0);\n      } finally {\n        client.setArgv('env', 'rm', 'NEW_VAR', '--yes');\n        await env(client);\n      }\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not show a delta string when it fails to read a file","suites":["env","pull"],"updatePoint":{"line":192,"column":67,"index":8814},"line":192,"code":"    it('should not show a delta string when it fails to read a file', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'env-pull-delta-corrupt',\n        name: 'env-pull-delta-corrupt'\n      });\n      const cwd = setupUnitFixture('vercel-env-pull-delta-corrupt');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--yes');\n      const pullPromise = env(client);\n      await expect(client.stderr).toOutput('Updated .env.local file and added it to .gitignore');\n      await expect(pullPromise).resolves.toEqual(0);\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show that no changes were found","suites":["env","pull"],"updatePoint":{"line":207,"column":46,"index":9394},"line":207,"code":"    it('should show that no changes were found', async () => {\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'env-pull-delta-no-changes',\n        name: 'env-pull-delta-no-changes'\n      });\n      client.cwd = setupUnitFixture('vercel-env-pull-delta-no-changes');\n      client.setArgv('env', 'pull', '--yes');\n      const pullPromise = env(client);\n      await expect(client.stderr).toOutput('> No changes found.');\n      await expect(client.stderr).toOutput('Updated .env.local file and added it to .gitignore');\n      await expect(pullPromise).resolves.toEqual(0);\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should correctly render delta string when env variable has quotes","suites":["env","pull"],"updatePoint":{"line":222,"column":73,"index":10054},"line":222,"code":"    it('should correctly render delta string when env variable has quotes', async () => {\n      const cwd = setupUnitFixture('vercel-env-pull-delta-quotes');\n      client.cwd = cwd;\n      try {\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'env-pull-delta-quotes',\n          name: 'env-pull-delta-quotes'\n        }, [...envs, {\n          type: 'encrypted',\n          id: '781dt89g8r2h789g',\n          key: 'NEW_VAR',\n          value: '\"testvalue\"',\n          target: ['development'],\n          configurationId: null,\n          updatedAt: 1557241361455,\n          createdAt: 1557241361455\n        }]);\n        client.setArgv('env', 'pull', '--yes');\n        const pullPromise = env(client);\n        await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project env-pull-delta');\n        await expect(client.stderr).toOutput('No changes found.\\n');\n        await expect(client.stderr).toOutput('Updated .env.local file and added it to .gitignore');\n        await expect(pullPromise).resolves.toEqual(0);\n      } finally {\n        client.setArgv('env', 'rm', 'NEW_VAR', '--yes');\n        await env(client);\n      }\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should correctly render delta string when local env variable has quotes","suites":["env","pull"],"updatePoint":{"line":253,"column":79,"index":11285},"line":253,"code":"    it('should correctly render delta string when local env variable has quotes', async () => {\n      const cwd = setupUnitFixture('vercel-env-pull-delta-quotes');\n      client.cwd = cwd;\n      try {\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'env-pull-delta-quotes',\n          name: 'env-pull-delta-quotes'\n        }, [...envs, {\n          type: 'encrypted',\n          id: '781dt89g8r2h789g',\n          key: 'NEW_VAR',\n          value: 'testvalue',\n          target: ['development'],\n          configurationId: null,\n          updatedAt: 1557241361455,\n          createdAt: 1557241361455\n        }]);\n        client.setArgv('env', 'pull', '.env.testquotes', '--yes');\n        const pullPromise = env(client);\n        await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project env-pull-delta');\n        await expect(client.stderr).toOutput('No changes found.\\n');\n        await expect(client.stderr).toOutput('Updated .env.testquotes file');\n        await expect(pullPromise).resolves.toEqual(0);\n      } finally {\n        client.setArgv('env', 'rm', 'NEW_VAR', '--yes');\n        await env(client);\n      }\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not update .gitignore if it contains a match","suites":["env","pull"],"updatePoint":{"line":284,"column":59,"index":12491},"line":284,"code":"    it('should not update .gitignore if it contains a match', async () => {\n      const prj = 'vercel-env-pull-with-gitignore';\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: prj,\n        name: prj\n      });\n      const cwd = setupUnitFixture(prj);\n      const gitignoreBefore = await fs.readFile(path.join(cwd, '.gitignore'), 'utf8');\n      client.cwd = cwd;\n      client.setArgv('env', 'pull', '--yes');\n      const exitCodePromise = env(client);\n      await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project ' + prj);\n      await expect(client.stderr).toOutput('Created .env.local file');\n      await expect(client.stderr).not.toOutput('and added it to .gitignore');\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const rawDevEnv = await fs.readFile(path.join(cwd, '.env.local'));\n\n      // check for development env value\n      const devFileHasDevEnv = rawDevEnv.toString().includes('SPECIAL_FLAG');\n      expect(devFileHasDevEnv).toBeTruthy();\n      const gitignoreAfter = await fs.readFile(path.join(cwd, '.gitignore'), 'utf8');\n      expect(gitignoreAfter).toBe(gitignoreBefore);\n    });","file":"unit/commands/env.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"connects an unlinked project","suites":["git","connect"],"updatePoint":{"line":11,"column":36,"index":487},"line":11,"code":"    it('connects an unlinked project', async () => {\n      const cwd = fixture('unlinked');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'unlinked',\n          name: 'unlinked'\n        });\n        client.setArgv('git', 'connect');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput('Set up');\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput('Which scope should contain your project?');\n        client.stdin.write('\\r');\n        await expect(client.stderr).toOutput('Found project');\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user/repo.git`);\n        const exitCode = await gitPromise;\n        await expect(client.stderr).toOutput('Connected GitHub repository user/repo!');\n        expect(exitCode).toEqual(0);\n        const project = await client.fetch(`/v8/projects/unlinked`);\n        expect(project.link).toMatchObject({\n          type: 'github',\n          repo: 'user/repo',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"connects an unlinked project with a remote url","suites":["git","connect"],"updatePoint":{"line":49,"column":54,"index":1960},"line":49,"code":"    it('connects an unlinked project with a remote url', async () => {\n      const cwd = fixture('unlinked');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'unlinked',\n          name: 'unlinked'\n        });\n        client.setArgv('git', 'connect', 'https://github.com/user2/repo2');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput('Set up');\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput('Which scope should contain your project?');\n        client.stdin.write('\\r');\n        await expect(client.stderr).toOutput('Found project');\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput(`Do you still want to connect https://github.com/user2/repo2?`);\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user2/repo2`);\n        const exitCode = await gitPromise;\n        await expect(client.stderr).toOutput('Connected GitHub repository user2/repo2!');\n        expect(exitCode).toEqual(0);\n        const project = await client.fetch(`/v8/projects/unlinked`);\n        expect(project.link).toMatchObject({\n          type: 'github',\n          repo: 'user2/repo2',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail when there is no git config","suites":["git","connect"],"updatePoint":{"line":89,"column":47,"index":3607},"line":89,"code":"    it('should fail when there is no git config', async () => {\n      client.cwd = fixture('no-git-config');\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'no-git-config',\n        name: 'no-git-config'\n      });\n      client.setArgv('git', 'connect', '--yes');\n      const exitCode = await git(client);\n      expect(exitCode).toEqual(1);\n      await expect(client.stderr).toOutput(`Error: No local Git repository found. Run \\`git clone <url>\\` to clone a remote Git repository first.\\n`);\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail when there is no remote url","suites":["git","connect"],"updatePoint":{"line":103,"column":47,"index":4163},"line":103,"code":"    it('should fail when there is no remote url', async () => {\n      const cwd = fixture('no-remote-url');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'no-remote-url',\n          name: 'no-remote-url'\n        });\n        client.setArgv('git', 'connect', '--yes');\n        const exitCode = await git(client);\n        expect(exitCode).toEqual(1);\n        await expect(client.stderr).toOutput(`Error: No remote URLs found in your Git config. Make sure you've configured a remote repo in your local Git config. Run \\`git remote --help\\` for more details.`);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail when the remote url is bad","suites":["git","connect"],"updatePoint":{"line":123,"column":46,"index":4981},"line":123,"code":"    it('should fail when the remote url is bad', async () => {\n      const cwd = fixture('bad-remote-url');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'bad-remote-url',\n          name: 'bad-remote-url'\n        });\n        client.setArgv('git', 'connect', '--yes');\n        const exitCode = await git(client);\n        expect(exitCode).toEqual(1);\n        await expect(client.stderr).toOutput(`Connecting Git remote: bababooey`);\n        await expect(client.stderr).toOutput(`Error: Failed to parse Git repo data from the following remote URL: bababooey\\n`);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should connect a repo to a project that is not already connected","suites":["git","connect"],"updatePoint":{"line":144,"column":72,"index":5830},"line":144,"code":"    it('should connect a repo to a project that is not already connected', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        client.setArgv('git', 'connect', '--yes');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user/repo`);\n        await expect(client.stderr).toOutput(`> Connected GitHub repository user/repo!\\n`);\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(0);\n        const project = await client.fetch(`/v8/projects/new-connection`);\n        expect(project.link).toMatchObject({\n          type: 'github',\n          repo: 'user/repo',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should replace an old connection with a new one","suites":["git","connect"],"updatePoint":{"line":176,"column":55,"index":7024},"line":176,"code":"    it('should replace an old connection with a new one', async () => {\n      const cwd = fixture('existing-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        const project = useProject({\n          ...defaultProject,\n          id: 'existing-connection',\n          name: 'existing-connection'\n        });\n        project.project.link = {\n          type: 'github',\n          repo: 'repo',\n          org: 'user',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        };\n        client.setArgv('git', 'connect', '--yes');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user2/repo2`);\n        await expect(client.stderr).toOutput(`> Connected GitHub repository user2/repo2!\\n`);\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(0);\n        const newProjectData = await client.fetch(`/v8/projects/existing-connection`);\n        expect(newProjectData.link).toMatchObject({\n          type: 'github',\n          repo: 'user2/repo2',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should exit when an already-connected repo is connected","suites":["git","connect"],"updatePoint":{"line":218,"column":63,"index":8553},"line":218,"code":"    it('should exit when an already-connected repo is connected', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        const project = useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        project.project.link = {\n          type: 'github',\n          repo: 'repo',\n          org: 'user',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        };\n        client.setArgv('git', 'connect', '--yes');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user/repo`);\n        await expect(client.stderr).toOutput(`> user/repo is already connected to your project.\\n`);\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(1);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail when it cannot find the repository","suites":["git","connect"],"updatePoint":{"line":250,"column":54,"index":9701},"line":250,"code":"    it('should fail when it cannot find the repository', async () => {\n      const cwd = fixture('invalid-repo');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'invalid-repo',\n          name: 'invalid-repo'\n        });\n        client.setArgv('git', 'connect', '--yes');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/laksfj/asdgklsadkl`);\n        await expect(client.stderr).toOutput(`Failed to connect laksfj/asdgklsadkl to project. Make sure there aren't any typos and that you have access to the repository if it's private.`);\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(1);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should connect the default option of multiple remotes","suites":["git","connect"],"updatePoint":{"line":272,"column":61,"index":10662},"line":272,"code":"    it('should connect the default option of multiple remotes', async () => {\n      const cwd = fixture('multiple-remotes');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'multiple-remotes',\n          name: 'multiple-remotes'\n        });\n        client.setArgv('git', 'connect');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput('Found multiple remote URLs.');\n        await expect(client.stderr).toOutput('Which remote do you want to connect?');\n        client.stdin.write('\\r');\n        await expect(client.stderr).toOutput('Connecting Git remote: https://github.com/user/repo.git');\n        await expect(client.stderr).toOutput('Connected GitHub repository user/repo!');\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(0);\n        const project = await client.fetch(`/v8/projects/multiple-remotes`);\n        expect(project.link).toMatchObject({\n          type: 'github',\n          repo: 'user/repo',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should disconnect a repository","suites":["git","disconnect"],"updatePoint":{"line":310,"column":38,"index":12169},"line":310,"code":"    it('should disconnect a repository', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        const project = useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        project.project.link = {\n          type: 'github',\n          repo: 'repo',\n          org: 'user',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        };\n        client.setArgv('git', 'disconnect');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Are you sure you want to disconnect user/repo from your project?`);\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput('Disconnected user/repo.');\n        const newProjectData = await client.fetch(`/v8/projects/new-connection`);\n        expect(newProjectData.link).toBeUndefined();\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(0);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail if there is no repository to disconnect","suites":["git","disconnect"],"updatePoint":{"line":345,"column":59,"index":13471},"line":345,"code":"    it('should fail if there is no repository to disconnect', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        client.setArgv('git', 'disconnect');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput('No Git repository connected. Run `vercel project connect` to connect one.');\n        const exitCode = await gitPromise;\n        expect(exitCode).toEqual(1);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should connect a given repository","suites":["git","disconnect"],"updatePoint":{"line":366,"column":41,"index":14234},"line":366,"code":"    it('should connect a given repository', async () => {\n      const cwd = fixture('no-remote-url');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'no-remote-url',\n          name: 'no-remote-url'\n        });\n        client.setArgv('git', 'connect', 'https://github.com/user2/repo2');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user2/repo2`);\n        await expect(client.stderr).toOutput(`Connected GitHub repository user2/repo2!`);\n        const newProjectData = await client.fetch(`/v8/projects/no-remote-url`);\n        expect(newProjectData.link).toMatchObject({\n          type: 'github',\n          repo: 'user2/repo2',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n        await expect(gitPromise).resolves.toEqual(0);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should prompt when it finds a repository","suites":["git","disconnect"],"updatePoint":{"line":397,"column":48,"index":15432},"line":397,"code":"    it('should prompt when it finds a repository', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        client.setArgv('git', 'connect', 'https://github.com/user2/repo2');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Found a repository in your local Git Config: https://github.com/user/repo`);\n        await expect(client.stderr).toOutput(`Do you still want to connect https://github.com/user2/repo2? [y/N]`);\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user2/repo2`);\n        await expect(client.stderr).toOutput(`Connected GitHub repository user2/repo2!`);\n        const newProjectData = await client.fetch(`/v8/projects/new-connection`);\n        expect(newProjectData.link).toMatchObject({\n          type: 'github',\n          repo: 'user2/repo2',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n        await expect(gitPromise).resolves.toEqual(0);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should prompt when it finds multiple remotes","suites":["git","disconnect"],"updatePoint":{"line":431,"column":52,"index":16912},"line":431,"code":"    it('should prompt when it finds multiple remotes', async () => {\n      const cwd = fixture('multiple-remotes');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'multiple-remotes',\n          name: 'multiple-remotes'\n        });\n        client.setArgv('git', 'connect', 'https://github.com/user3/repo3');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Found multiple Git repositories in your local Git config:\\n   origin: https://github.com/user/repo.git\\n   secondary: https://github.com/user/repo2.git`);\n        await expect(client.stderr).toOutput(`Do you still want to connect https://github.com/user3/repo3? [y/N]`);\n        client.stdin.write('y\\n');\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user3/repo3`);\n        await expect(client.stderr).toOutput(`Connected GitHub repository user3/repo3!`);\n        const newProjectData = await client.fetch(`/v8/projects/multiple-remotes`);\n        expect(newProjectData.link).toMatchObject({\n          type: 'github',\n          repo: 'user3/repo3',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n        await expect(gitPromise).resolves.toEqual(0);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should continue as normal when input matches single git remote","suites":["git","disconnect"],"updatePoint":{"line":465,"column":70,"index":18498},"line":465,"code":"    it('should continue as normal when input matches single git remote', async () => {\n      const cwd = fixture('new-connection');\n      client.cwd = cwd;\n      try {\n        await fs.rename(join(cwd, 'git'), join(cwd, '.git'));\n        useUser();\n        useTeams('team_dummy');\n        useProject({\n          ...defaultProject,\n          id: 'new-connection',\n          name: 'new-connection'\n        });\n        client.setArgv('git', 'connect', 'https://github.com/user/repo');\n        const gitPromise = git(client);\n        await expect(client.stderr).toOutput(`Connecting Git remote: https://github.com/user/repo`);\n        await expect(client.stderr).toOutput(`Connected GitHub repository user/repo!`);\n        const newProjectData = await client.fetch(`/v8/projects/new-connection`);\n        expect(newProjectData.link).toMatchObject({\n          type: 'github',\n          repo: 'user/repo',\n          repoId: 1010,\n          gitCredentialId: '',\n          sourceless: true,\n          createdAt: 1656109539791,\n          updatedAt: 1656109539791\n        });\n        await expect(gitPromise).resolves.toEqual(0);\n      } finally {\n        await fs.rename(join(cwd, '.git'), join(cwd, 'git'));\n      }\n    });","file":"unit/commands/git.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should calculate the correct line length $name","suites":["help command","calcLineLength"],"line":6,"code":"    test.each([{\n      name: 'without ansi',\n      line: ['a line without ansi'],\n      expectedLength: 19\n    }, {\n      name: 'with ansi',\n      line: [`a line with ${chalk.red('ansi')}`],\n      expectedLength: 16\n    }])('should calculate the correct line length $name', ({\n      line,\n      expectedLength\n    }) => {\n      expect(calcLineLength(line)).toBe(expectedLength);\n    });","file":"unit/commands/help.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should insert spaces between non-whitespace items only; $line","suites":["help command","lineToString"],"line":22,"code":"    test.each([{\n      line: ['a', 'b', 'c'],\n      expected: 'a b c'\n    }, {\n      line: [' ', 'a', ' ', 'b', ' ', 'c', ' '],\n      expected: ' a b c '\n    }, {\n      line: [' ', '  ', '   '],\n      expected: '      '\n    }, {\n      line: ['a', '  ', '   ', 'b', 'c'],\n      expected: 'a     b c'\n    }])('should insert spaces between non-whitespace items only; $line', ({\n      line,\n      expected\n    }) => {\n      expect(lineToString(line)).toBe(expected);\n    });","file":"unit/commands/help.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should join a list of strings using newlines","suites":["help command","outputArrayToString"],"updatePoint":{"line":42,"column":54,"index":1271},"line":42,"code":"    test('should join a list of strings using newlines', () => {\n      expect(outputArrayToString(['line 1', 'line 2', 'line 3'])).toBe('line 1\\nline 2\\nline 3');\n    });","file":"unit/commands/help.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"column width %i","suites":["help command","help output snapshots"],"line":47,"code":"    test.each([40, 80, 120])('column width %i', width => {\n      expect(help(deployCommand, {\n        columns: width\n      })).toMatchSnapshot();\n    });","file":"unit/commands/help.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not allow the `--token` flag","suites":["login"],"updatePoint":{"line":7,"column":41,"index":279},"line":7,"code":"  it('should not allow the `--token` flag', async () => {\n    client.setArgv('login', '--token', 'foo');\n    const exitCodePromise = login(client);\n    await expect(client.stderr).toOutput('Error: `--token` may not be used with the \"login\" command\\n');\n    await expect(exitCodePromise).resolves.toEqual(2);\n  });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow login via email as argument","suites":["login"],"updatePoint":{"line":13,"column":46,"index":598},"line":13,"code":"  it('should allow login via email as argument', async () => {\n    const user = useUser();\n    client.setArgv('login', user.email);\n    const exitCodePromise = login(client);\n    await expect(client.stderr).toOutput(`Success! Email authentication complete for ${user.email}`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow login via email","suites":["login","interactive"],"updatePoint":{"line":21,"column":36,"index":960},"line":21,"code":"    it('should allow login via email', async () => {\n      const user = useUser();\n      client.setArgv('login');\n      const exitCodePromise = login(client);\n      await expect(client.stderr).toOutput(`? Log in to Vercel`);\n\n      // Move down to \"Email\" option\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\r'); // Return key\n\n      await expect(client.stderr).toOutput('? Enter your email address:');\n      client.stdin.write(`${user.email}\\n`);\n      await expect(client.stderr).toOutput(`Success! Email authentication complete for ${user.email}`);\n      await expect(exitCodePromise).resolves.toEqual(0);\n    });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow the `--no-color` flag","suites":["login","interactive"],"updatePoint":{"line":38,"column":42,"index":1715},"line":38,"code":"    it('should allow the `--no-color` flag', async () => {\n      const user = useUser();\n      client.setArgv('login', '--no-color');\n      const exitCodePromise = login(client);\n      await expect(client.stderr).toOutput(`? Log in to Vercel`);\n\n      // Move down to \"Email\" option\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\x1B[B'); // Down arrow\n      client.stdin.write('\\r'); // Return key\n\n      await expect(client.stderr).toOutput('? Enter your email address:');\n      client.stdin.write(`${user.email}\\n`);\n      await expect(client.stderr).toOutput(`Success! Email authentication complete for ${user.email}`);\n      await expect(client.stderr).not.toOutput(emoji('tip'));\n      await expect(exitCodePromise).resolves.toEqual(0);\n    });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should remove emoji the `NO_COLOR` env var with 1","suites":["login","interactive","with NO_COLOR=\"1\" env var"],"updatePoint":{"line":68,"column":59,"index":2921},"line":68,"code":"      it('should remove emoji the `NO_COLOR` env var with 1', async () => {\n        client.resetOutput();\n        const user = useUser();\n        client.setArgv('login');\n        const exitCodePromise = login(client);\n        await expect(client.stderr).toOutput(`? Log in to Vercel`);\n\n        // Move down to \"Email\" option\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\r'); // Return key\n\n        await expect(client.stderr).toOutput('? Enter your email address:');\n        client.stdin.write(`${user.email}\\n`);\n        await expect(client.stderr).toOutput(`Success! Email authentication complete for ${user.email}`);\n        await expect(client.stderr).not.toOutput(emoji('tip'));\n        await expect(exitCodePromise).resolves.toEqual(0);\n      });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should remove emoji the `FORCE_COLOR` env var with 0","suites":["login","interactive","with FORCE_COLOR=\"0\" env var"],"updatePoint":{"line":100,"column":62,"index":4211},"line":100,"code":"      it('should remove emoji the `FORCE_COLOR` env var with 0', async () => {\n        client.resetOutput();\n        const user = useUser();\n        client.setArgv('login');\n        const exitCodePromise = login(client);\n        await expect(client.stderr).toOutput(`? Log in to Vercel`);\n\n        // Move down to \"Email\" option\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\x1B[B'); // Down arrow\n        client.stdin.write('\\r'); // Return key\n\n        await expect(client.stderr).toOutput('? Enter your email address:');\n        client.stdin.write(`${user.email}\\n`);\n        await expect(client.stderr).toOutput(`Success! Email authentication complete for ${user.email}`);\n        await expect(client.stderr).not.toOutput(emoji('tip'));\n        await expect(exitCodePromise).resolves.toEqual(0);\n      });","file":"unit/commands/login.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if timeout is invalid","suites":["promote"],"updatePoint":{"line":14,"column":40,"index":648},"line":14,"code":"  it('should error if timeout is invalid', async () => {\n    const {\n      cwd\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', '--yes', '--timeout', 'foo');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput('Error: Invalid timeout \"foo\"');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if invalid deployment ID","suites":["promote"],"updatePoint":{"line":24,"column":43,"index":1019},"line":24,"code":"  it('should error if invalid deployment ID', async () => {\n    const {\n      cwd\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', '????', '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput('Error: The provided argument \"????\" is not a valid deployment ID or URL');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment not found","suites":["promote"],"updatePoint":{"line":34,"column":42,"index":1420},"line":34,"code":"  it('should error if deployment not found', async () => {\n    const {\n      cwd\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', 'foo', '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput('Fetching deployment \"foo\" in ');\n    await expect(client.stderr).toOutput('Error: Error: Can\\'t find the deployment \"foo\" under the context');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show status when not promoting","suites":["promote"],"updatePoint":{"line":45,"column":43,"index":1889},"line":45,"code":"  it('should show status when not promoting', async () => {\n    const {\n      cwd\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput('Checking promotion status of vercel-promote');\n    await expect(client.stderr).toOutput('No deployment promotion in progress');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should promote by deployment id","suites":["promote"],"updatePoint":{"line":56,"column":37,"index":2330},"line":56,"code":"  it('should promote by deployment id', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-promote')} was promoted to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should promote by deployment url","suites":["promote"],"updatePoint":{"line":69,"column":38,"index":3006},"line":69,"code":"  it('should promote by deployment url', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.url, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.url}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-promote')} was promoted to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail to promote a preview deployment when user says no","suites":["promote"],"updatePoint":{"line":82,"column":67,"index":3713},"line":82,"code":"  it('should fail to promote a preview deployment when user says no', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      deploymentTarget: 'preview'\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.url);\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.url}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('? This deployment does not target production, therefore promotion will not apply\\n production environment variables. Are you sure you want to continue?');\n\n    // say \"no\" to the prompt\n    client.stdin.write('n\\n');\n    await expect(client.stderr).toOutput('Error: Canceled');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should promote a preview deployment when user says yes","suites":["promote"],"updatePoint":{"line":100,"column":60,"index":4545},"line":100,"code":"  it('should promote a preview deployment when user says yes', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      deploymentTarget: 'preview'\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.url);\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.url}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('? This deployment does not target production, therefore promotion will not apply\\n production environment variables. Are you sure you want to continue?');\n\n    // say \"yes\" to the prompt\n    client.stdin.write('y\\n');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should promote a preview deployment with --yes","suites":["promote"],"updatePoint":{"line":117,"column":52,"index":5309},"line":117,"code":"  it('should promote a preview deployment with --yes', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      deploymentTarget: 'preview'\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.url, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.url}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-promote')} was promoted to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get status while promoting","suites":["promote"],"updatePoint":{"line":132,"column":39,"index":6029},"line":132,"code":"  it('should get status while promoting', async () => {\n    const {\n      cwd,\n      previousDeployment,\n      project\n    } = initPromoteTest({\n      promotePollCount: 10\n    });\n    client.cwd = cwd;\n\n    // start the promote\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    promote(client);\n\n    // need to wait for the promote request to be accepted\n    await sleep(300);\n\n    // get the status\n    client.setArgv('promote', '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Checking promotion status of ${project.name}`);\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-promote')} was promoted to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if promote request fails","suites":["promote"],"updatePoint":{"line":156,"column":43,"index":6841},"line":156,"code":"  it('should error if promote request fails', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      promotePollCount: 10,\n      promoteStatusCode: 500\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n\n    // we need to wait a super long time because fetch will return on 500\n    await expect(client.stderr).toOutput('Response Error (500)', 20000);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if promote fails (no aliases)","suites":["promote"],"updatePoint":{"line":173,"column":48,"index":7519},"line":173,"code":"  it('should error if promote fails (no aliases)', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      promoteJobStatus: 'failed'\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`Error: Failed to remap all aliases to the requested deployment ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if promote fails (with aliases)","suites":["promote"],"updatePoint":{"line":188,"column":50,"index":8253},"line":188,"code":"  it('should error if promote fails (with aliases)', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      promoteAliases: [{\n        alias: {\n          alias: 'foo',\n          deploymentId: 'foo_123'\n        },\n        status: 'completed'\n      }, {\n        alias: {\n          alias: 'bar',\n          deploymentId: 'bar_123'\n        },\n        status: 'failed'\n      }],\n      promoteJobStatus: 'failed'\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`Error: Failed to remap all aliases to the requested deployment ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(client.stderr).toOutput(`  ${chalk.green('completed')}    foo (foo_123)`);\n    await expect(client.stderr).toOutput(`  ${chalk.red('failed')}       bar (bar_123)`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment times out","suites":["promote"],"updatePoint":{"line":218,"column":42,"index":9432},"line":218,"code":"  it('should error if deployment times out', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest({\n      promotePollCount: 10\n    });\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes', '--timeout', '1');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Promote in progress');\n    await expect(client.stderr).toOutput(`The promotion exceeded its deadline - rerun ${chalk.bold(`vercel promote ${previousDeployment.id}`)} to try again`, 10000);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should immediately exit after requesting promote","suites":["promote"],"updatePoint":{"line":233,"column":54,"index":10187},"line":233,"code":"  it('should immediately exit after requesting promote', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest();\n    client.cwd = cwd;\n    client.setArgv('promote', previousDeployment.id, '--yes', '--timeout', '0');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput(`Successfully requested promote of ${chalk.bold('vercel-promote')} to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment belongs to different team","suites":["promote"],"updatePoint":{"line":245,"column":58,"index":10848},"line":245,"code":"  it('should error if deployment belongs to different team', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initPromoteTest();\n    client.cwd = cwd;\n    previousDeployment.team = {\n      id: 'abc',\n      name: 'abc',\n      slug: 'abc'\n    };\n    client.setArgv('promote', previousDeployment.id, '--yes');\n    const exitCodePromise = promote(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Error: Deployment belongs to a different team');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/promote.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle pulling","suites":["pull"],"updatePoint":{"line":10,"column":27,"index":421},"line":10,"code":"  it('should handle pulling', async () => {\n    const cwd = setupUnitFixture('vercel-pull-next');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'vercel-pull-next',\n      name: 'vercel-pull-next'\n    });\n    client.setArgv('pull', cwd);\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project vercel-pull-next');\n    await expect(client.stderr).toOutput(`Created .vercel${path.sep}.env.development.local file`);\n    await expect(client.stderr).toOutput(`Downloaded project settings to ${cwd}${path.sep}.vercel${path.sep}project.json`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n    const rawDevEnv = await fs.readFile(path.join(cwd, '.vercel', '.env.development.local'));\n    const devFileHasDevEnv = rawDevEnv.toString().includes('SPECIAL_FLAG');\n    expect(devFileHasDevEnv).toBeTruthy();\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail with message to pull without a link and without --env","suites":["pull"],"updatePoint":{"line":29,"column":71,"index":1411},"line":29,"code":"  it('should fail with message to pull without a link and without --env', async () => {\n    client.stdin.isTTY = false;\n    const cwd = setupUnitFixture('vercel-pull-unlinked');\n    useUser();\n    useTeams('team_dummy');\n    client.setArgv('pull', cwd);\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).toOutput('Command `vercel pull` requires confirmation. Use option \"--yes\" to confirm.');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail without message to pull without a link and with --env","suites":["pull"],"updatePoint":{"line":39,"column":71,"index":1889},"line":39,"code":"  it('should fail without message to pull without a link and with --env', async () => {\n    const cwd = setupUnitFixture('vercel-pull-next');\n    useUser();\n    useTeams('team_dummy');\n    client.setArgv('pull', cwd, '--yes');\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).not.toOutput('Command `vercel pull` requires confirmation. Use option \"--yes\" to confirm.');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle pulling with env vars (headless mode)","suites":["pull"],"updatePoint":{"line":48,"column":57,"index":2330},"line":48,"code":"  it('should handle pulling with env vars (headless mode)', async () => {\n    try {\n      process.env.VERCEL_PROJECT_ID = 'vercel-pull-next';\n      process.env.VERCEL_ORG_ID = 'team_dummy';\n      const cwd = setupUnitFixture('vercel-pull-next');\n\n      // Remove the `.vercel` dir to ensure that the `pull`\n      // command creates a new one based on env vars\n      await fs.remove(path.join(cwd, '.vercel'));\n      useUser();\n      useTeams('team_dummy');\n      useProject({\n        ...defaultProject,\n        id: 'vercel-pull-next',\n        name: 'vercel-pull-next'\n      });\n      client.setArgv('pull', cwd);\n      const exitCodePromise = pull(client);\n      await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project vercel-pull-next');\n      await expect(client.stderr).toOutput(`Created .vercel${path.sep}.env.development.local file`);\n      await expect(client.stderr).toOutput(`Downloaded project settings to ${cwd}${path.sep}.vercel${path.sep}project.json`);\n      await expect(exitCodePromise).resolves.toEqual(0);\n      const config = await fs.readJSON(path.join(cwd, '.vercel/project.json'));\n      expect(config).toMatchInlineSnapshot(`\n        {\n          \"orgId\": \"team_dummy\",\n          \"projectId\": \"vercel-pull-next\",\n          \"settings\": {\n            \"createdAt\": 1555413045188,\n          },\n        }\n      `);\n    } finally {\n      delete process.env.VERCEL_PROJECT_ID;\n      delete process.env.VERCEL_ORG_ID;\n    }\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle --environment=preview flag","suites":["pull"],"updatePoint":{"line":85,"column":46,"index":3804},"line":85,"code":"  it('should handle --environment=preview flag', async () => {\n    const cwd = setupUnitFixture('vercel-pull-next');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'vercel-pull-next',\n      name: 'vercel-pull-next'\n    });\n    client.setArgv('pull', '--environment=preview', cwd);\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).toOutput('Downloading `preview` Environment Variables for Project vercel-pull-next');\n    await expect(client.stderr).toOutput(`Created .vercel${path.sep}.env.preview.local file`);\n    await expect(client.stderr).toOutput(`Downloaded project settings to ${cwd}${path.sep}.vercel${path.sep}project.json`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n    const rawPreviewEnv = await fs.readFile(path.join(cwd, '.vercel', '.env.preview.local'));\n    const previewFileHasPreviewEnv = rawPreviewEnv.toString().includes('REDIS_CONNECTION_STRING');\n    expect(previewFileHasPreviewEnv).toBeTruthy();\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle --environment=production flag","suites":["pull"],"updatePoint":{"line":104,"column":49,"index":4820},"line":104,"code":"  it('should handle --environment=production flag', async () => {\n    const cwd = setupUnitFixture('vercel-pull-next');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'vercel-pull-next',\n      name: 'vercel-pull-next'\n    });\n    client.setArgv('pull', '--environment=production', cwd);\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).toOutput('Downloading `production` Environment Variables for Project vercel-pull-next');\n    await expect(client.stderr).toOutput(`Created .vercel${path.sep}.env.production.local file`);\n    await expect(client.stderr).toOutput(`Downloaded project settings to ${cwd}${path.sep}.vercel${path.sep}project.json`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n    const rawProdEnv = await fs.readFile(path.join(cwd, '.vercel', '.env.production.local'));\n    const previewFileHasPreviewEnv1 = rawProdEnv.toString().includes('REDIS_CONNECTION_STRING');\n    expect(previewFileHasPreviewEnv1).toBeTruthy();\n    const previewFileHasPreviewEnv2 = rawProdEnv.toString().includes('SQL_CONNECTION_STRING');\n    expect(previewFileHasPreviewEnv2).toBeTruthy();\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with repo link","suites":["pull"],"updatePoint":{"line":125,"column":32,"index":5974},"line":125,"code":"  it('should work with repo link', async () => {\n    const cwd = setupUnitFixture('monorepo-link');\n    useUser();\n    useTeams('team_dummy');\n    useProject({\n      ...defaultProject,\n      id: 'QmbKpqpiUqbcke',\n      name: 'dashboard',\n      rootDirectory: 'dashboard'\n    });\n    client.cwd = path.join(cwd, 'dashboard');\n    client.setArgv('pull');\n    const exitCodePromise = pull(client);\n    await expect(client.stderr).toOutput('Downloading `development` Environment Variables for Project dashboard');\n    await expect(client.stderr).toOutput(`Created .vercel${path.sep}.env.development.local file`);\n    await expect(client.stderr).toOutput(`Downloaded project settings to ${cwd}${path.sep}dashboard${path.sep}.vercel${path.sep}project.json`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/pull.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if missing deployment url","suites":["redeploy"],"updatePoint":{"line":10,"column":44,"index":508},"line":10,"code":"  it('should error if missing deployment url', async () => {\n    client.setArgv('redeploy');\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput('Missing required deployment id or url:');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment not found","suites":["redeploy"],"updatePoint":{"line":16,"column":42,"index":790},"line":16,"code":"  it('should error if deployment not found', async () => {\n    initRedeployTest();\n    client.setArgv('redeploy', 'foo');\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput('Fetching deployment \"foo\" in ');\n    await expect(client.stderr).toOutput('Error: Can\\'t find the deployment \"foo\" under the context');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment belongs to another team","suites":["redeploy"],"updatePoint":{"line":24,"column":56,"index":1211},"line":24,"code":"  it('should error if deployment belongs to another team', async () => {\n    const {\n      fromDeployment\n    } = initRedeployTest();\n    fromDeployment.team = {\n      id: 'abc',\n      name: 'abc',\n      slug: 'abc'\n    };\n    client.setArgv('rollback', fromDeployment.id);\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${fromDeployment.id}\" in ${fromDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Error: Deployment belongs to a different team');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should redeploy an existing deployment","suites":["redeploy"],"updatePoint":{"line":39,"column":44,"index":1798},"line":39,"code":"  it('should redeploy an existing deployment', async () => {\n    const {\n      fromDeployment\n    } = initRedeployTest();\n    client.setArgv('rollback', fromDeployment.id);\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${fromDeployment.id}\" in ${fromDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Production');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should redeploy and not wait for completion","suites":["redeploy"],"updatePoint":{"line":49,"column":49,"index":2266},"line":49,"code":"  it('should redeploy and not wait for completion', async () => {\n    const {\n      fromDeployment,\n      toDeployment\n    } = initRedeployTest();\n    toDeployment.readyState = 'QUEUED';\n    client.setArgv('rollback', fromDeployment.id, '--no-wait');\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${fromDeployment.id}\" in ${fromDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Note: Deployment is still processing');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should redeploy to preview","suites":["redeploy"],"updatePoint":{"line":61,"column":32,"index":2816},"line":61,"code":"  it('should redeploy to preview', async () => {\n    const {\n      fromDeployment\n    } = initRedeployTest({\n      target: null\n    });\n    client.setArgv('rollback', fromDeployment.id);\n    const exitCodePromise = redeploy(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${fromDeployment.id}\" in ${fromDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Preview');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/redeploy.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if timeout is invalid","suites":["rollback"],"updatePoint":{"line":13,"column":40,"index":591},"line":13,"code":"  it('should error if timeout is invalid', async () => {\n    const {\n      cwd\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', '--yes', '--timeout', 'foo');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput('Error: Invalid timeout \"foo\"');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if invalid deployment ID","suites":["rollback"],"updatePoint":{"line":23,"column":43,"index":965},"line":23,"code":"  it('should error if invalid deployment ID', async () => {\n    const {\n      cwd\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', '????', '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput('Error: The provided argument \"????\" is not a valid deployment ID or URL');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment not found","suites":["rollback"],"updatePoint":{"line":33,"column":42,"index":1369},"line":33,"code":"  it('should error if deployment not found', async () => {\n    const {\n      cwd\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', 'foo', '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput('Error: Can\\'t find the deployment \"foo\" under the context');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show status when not rolling back","suites":["rollback"],"updatePoint":{"line":43,"column":46,"index":1762},"line":43,"code":"  it('should show status when not rolling back', async () => {\n    const {\n      cwd\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput('Checking rollback status of vercel-rollback');\n    await expect(client.stderr).toOutput('No deployment rollback in progress');\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should rollback by deployment id","suites":["rollback"],"updatePoint":{"line":54,"column":38,"index":2206},"line":54,"code":"  it('should rollback by deployment id', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Rollback in progress');\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-rollback')} was rolled back to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should rollback by deployment url","suites":["rollback"],"updatePoint":{"line":67,"column":39,"index":2891},"line":67,"code":"  it('should rollback by deployment url', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.url, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.url}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Rollback in progress');\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-rollback')} was rolled back to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get status while rolling back","suites":["rollback"],"updatePoint":{"line":80,"column":42,"index":3581},"line":80,"code":"  it('should get status while rolling back', async () => {\n    const {\n      cwd,\n      previousDeployment,\n      project\n    } = initRollbackTest({\n      rollbackPollCount: 10\n    });\n    client.cwd = cwd;\n\n    // start the rollback\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    rollback(client);\n\n    // need to wait for the rollback request to be accepted\n    await sleep(300);\n\n    // get the status\n    client.setArgv('rollback', '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Checking rollback status of ${project.name}`);\n    await expect(client.stderr).toOutput(`Success! ${chalk.bold('vercel-rollback')} was rolled back to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if rollback request fails","suites":["rollback"],"updatePoint":{"line":104,"column":44,"index":4405},"line":104,"code":"  it('should error if rollback request fails', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest({\n      rollbackPollCount: 10,\n      rollbackStatusCode: 500\n    });\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    // we need to wait a super long time because fetch will return on 500\n    await expect(client.stderr).toOutput('Response Error (500)', 20000);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if rollback fails (no aliases)","suites":["rollback"],"updatePoint":{"line":120,"column":49,"index":5088},"line":120,"code":"  it('should error if rollback fails (no aliases)', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest({\n      rollbackJobStatus: 'failed'\n    });\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Rollback in progress');\n    await expect(client.stderr).toOutput(`Error: Failed to remap all aliases to the requested deployment ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if rollback fails (with aliases)","suites":["rollback"],"updatePoint":{"line":135,"column":51,"index":5828},"line":135,"code":"  it('should error if rollback fails (with aliases)', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest({\n      rollbackAliases: [{\n        alias: {\n          alias: 'foo',\n          deploymentId: 'foo_123'\n        },\n        status: 'completed'\n      }, {\n        alias: {\n          alias: 'bar',\n          deploymentId: 'bar_123'\n        },\n        status: 'failed'\n      }],\n      rollbackJobStatus: 'failed'\n    });\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Rollback in progress');\n    await expect(client.stderr).toOutput(`Error: Failed to remap all aliases to the requested deployment ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(client.stderr).toOutput(`  ${chalk.green('completed')}    foo (foo_123)`);\n    await expect(client.stderr).toOutput(`  ${chalk.red('failed')}       bar (bar_123)`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment times out","suites":["rollback"],"updatePoint":{"line":165,"column":42,"index":7013},"line":165,"code":"  it('should error if deployment times out', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest({\n      rollbackPollCount: 10\n    });\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes', '--timeout', '1');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Rollback in progress');\n    await expect(client.stderr).toOutput(`The rollback exceeded its deadline - rerun ${chalk.bold(`vercel rollback ${previousDeployment.id}`)} to try again`);\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should immediately exit after requesting rollback","suites":["rollback"],"updatePoint":{"line":180,"column":55,"index":7767},"line":180,"code":"  it('should immediately exit after requesting rollback', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest();\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes', '--timeout', '0');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput(`Successfully requested rollback of ${chalk.bold('vercel-rollback')} to ${previousDeployment.url} (${previousDeployment.id})`);\n    await expect(exitCodePromise).resolves.toEqual(0);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment belongs to different team","suites":["rollback"],"updatePoint":{"line":192,"column":58,"index":8433},"line":192,"code":"  it('should error if deployment belongs to different team', async () => {\n    const {\n      cwd,\n      previousDeployment\n    } = initRollbackTest();\n    previousDeployment.team = {\n      id: 'abc',\n      name: 'abc',\n      slug: 'abc'\n    };\n    client.cwd = cwd;\n    client.setArgv('rollback', previousDeployment.id, '--yes');\n    const exitCodePromise = rollback(client);\n    await expect(client.stderr).toOutput(`Fetching deployment \"${previousDeployment.id}\" in ${previousDeployment.creator?.username}`);\n    await expect(client.stderr).toOutput('Error: Deployment belongs to a different team');\n    await expect(exitCodePromise).resolves.toEqual(1);\n  });","file":"unit/commands/rollback.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should reject invalid arguments","suites":["whoami"],"updatePoint":{"line":5,"column":37,"index":205},"line":5,"code":"  it('should reject invalid arguments', async () => {\n    client.setArgv('--invalid');\n    await expect(whoami(client)).rejects.toThrow('unknown or unexpected option: --invalid');\n  });","file":"unit/commands/whoami.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should print the Vercel username","suites":["whoami"],"updatePoint":{"line":9,"column":38,"index":392},"line":9,"code":"  it('should print the Vercel username', async () => {\n    const user = useUser();\n    const exitCode = await whoami(client);\n    expect(exitCode).toEqual(0);\n    await expect(client.stderr).toOutput(`> ${user.username}\\n`);\n  });","file":"unit/commands/whoami.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should print only the Vercel username when output is not a TTY","suites":["whoami"],"updatePoint":{"line":15,"column":68,"index":653},"line":15,"code":"  it('should print only the Vercel username when output is not a TTY', async () => {\n    const user = useUser();\n    client.stdout.isTTY = false;\n    const exitCode = await whoami(client);\n    expect(exitCode).toEqual(0);\n    await expect(client.stdout).toOutput(`${user.username}\\n`);\n  });","file":"unit/commands/whoami.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should add https to url without scheme","suites":["normalize-url"],"updatePoint":{"line":3,"column":44,"index":153},"line":3,"code":"  it('should add https to url without scheme', () => {\n    const normalizedUrl = normalizeURL('vercel.com');\n    expect(normalizedUrl).toEqual('https://vercel.com');\n  });","file":"unit/util/bisect/normalize-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not add anything to a url that starts with https","suites":["normalize-url"],"updatePoint":{"line":7,"column":61,"index":342},"line":7,"code":"  it('should not add anything to a url that starts with https', () => {\n    const normalizedUrl = normalizeURL('https://vercel.com');\n    expect(normalizedUrl).toEqual('https://vercel.com');\n  });","file":"unit/util/bisect/normalize-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should not add anything to a url that starts with http","suites":["normalize-url"],"updatePoint":{"line":11,"column":60,"index":538},"line":11,"code":"  it('should not add anything to a url that starts with http', () => {\n    const normalizedUrl = normalizeURL('http://vercel.com');\n    expect(normalizedUrl).toEqual('http://vercel.com');\n  });","file":"unit/util/bisect/normalize-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should move source to non-existent destination","suites":["merge()"],"updatePoint":{"line":7,"column":52,"index":332},"line":7,"code":"  it('should move source to non-existent destination', async () => {\n    const source = join(tmpdir(), 'src');\n    const dest = join(tmpdir(), 'dest');\n    try {\n      await mkdirp(source);\n      await writeFile(join(source, 'a.txt'), 'a');\n      await merge(source, dest);\n      const destContents = await readdir(dest);\n      expect(destContents.sort()).toEqual(['a.txt']);\n      const sourceStat = await stat(source).then(() => {}, err => err);\n      expect(isErrnoException(sourceStat) && sourceStat.code).toEqual('ENOENT');\n    } finally {\n      await Promise.all([source, dest].map(p => remove(p)));\n    }\n  });","file":"unit/util/build/merge.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should merge source into existing destination","suites":["merge()"],"updatePoint":{"line":22,"column":51,"index":949},"line":22,"code":"  it('should merge source into existing destination', async () => {\n    const source = join(tmpdir(), 'src');\n    const dest = join(tmpdir(), 'dest');\n    try {\n      await mkdirp(source);\n      await mkdirp(dest);\n      await writeFile(join(source, 'a.txt'), 'a');\n      await writeFile(join(source, 'c.txt'), 'c');\n      await writeFile(join(dest, 'b.txt'), 'b');\n      await writeFile(join(dest, 'c.txt'), 'original');\n      await merge(source, dest);\n      const destContents = await readdir(dest);\n      expect(destContents.sort()).toEqual(['a.txt', 'b.txt', 'c.txt']);\n      const sourceStat = await stat(source).then(() => {}, err => err);\n      expect(isErrnoException(sourceStat) && sourceStat.code).toEqual('ENOENT');\n      expect(await readFile(join(dest, 'c.txt'), 'utf8')).toEqual('c');\n    } finally {\n      await Promise.all([source, dest].map(p => remove(p)));\n    }\n  });","file":"unit/util/build/merge.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should overwrite dest directory when source is a file","suites":["merge()"],"updatePoint":{"line":42,"column":59,"index":1846},"line":42,"code":"  it('should overwrite dest directory when source is a file', async () => {\n    const source = join(tmpdir(), 'src');\n    const dest = join(tmpdir(), 'dest');\n    try {\n      await mkdirp(source);\n      await mkdirp(join(dest, 'a'));\n      await writeFile(join(source, 'a'), 'a');\n      await merge(source, dest);\n      const destContents = await readdir(dest);\n      expect(destContents.sort()).toEqual(['a']);\n      const sourceStat = await stat(source).then(() => {}, err => err);\n      expect(isErrnoException(sourceStat) && sourceStat.code).toEqual('ENOENT');\n      expect(await readFile(join(dest, 'a'), 'utf8')).toEqual('a');\n    } finally {\n      await Promise.all([source, dest].map(p => remove(p)));\n    }\n  });","file":"unit/util/build/merge.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"$name","suites":["sortBuilders()"],"line":3,"code":"  test.each([{\n    name: 'should sort @vercel/next from middle to beginning',\n    input: ['@vercel/node', '@vercel/next', '@vercel/python'],\n    output: ['@vercel/next', '@vercel/node', '@vercel/python']\n  }, {\n    name: 'should sort @vercel/static-build from middle to beginning',\n    input: ['@vercel/node', '@vercel/static-build', '@vercel/python'],\n    output: ['@vercel/static-build', '@vercel/node', '@vercel/python']\n  }, {\n    name: 'should sort @vercel/remix from end to beginning',\n    input: ['@vercel/python', '@vercel/node', '@vercel/remix-builder'],\n    output: ['@vercel/remix-builder', '@vercel/python', '@vercel/node']\n  }, {\n    name: 'should sort @vercel/redwood from beginning to beginning',\n    input: ['@vercel/redwood', '@vercel/python', '@vercel/ruby'],\n    output: ['@vercel/redwood', '@vercel/python', '@vercel/ruby']\n  }, {\n    name: 'should sort @vercel/hydrogen from end to beginning',\n    input: ['@vercel/python', '@vercel/hydrogen'],\n    output: ['@vercel/hydrogen', '@vercel/python']\n  }, {\n    name: 'should sort @vercel/static-build to beginning with many @vercel/node',\n    input: ['@vercel/node', '@vercel/node', '@vercel/node', '@vercel/static-build', '@vercel/node'],\n    output: ['@vercel/static-build', '@vercel/node', '@vercel/node', '@vercel/node', '@vercel/node']\n  }])('$name', ({\n    input,\n    output\n  }) => {\n    const builders = sortBuilders(input.map(use => ({\n      use\n    })));\n    expect(builders.map(b => b.use)).toEqual(output);\n  });","file":"unit/util/build/sort-builders.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respect the `HTTPS_PROXY` env var","suites":["Client","fetch()"],"updatePoint":{"line":10,"column":48,"index":338},"line":10,"code":"    it('should respect the `HTTPS_PROXY` env var', async () => {\n      let connectCount = 0;\n      const proxy = createProxy();\n      const proxyUrl = await listen(proxy);\n      proxy.on('connect', () => {\n        connectCount++;\n      });\n      try {\n        process.env.HTTPS_PROXY = proxyUrl.href;\n        client.agent = new ProxyAgent({\n          keepAlive: true\n        });\n        expect(connectCount).toEqual(0);\n        const res = await client.fetch('https://example.com/', {\n          json: false\n        });\n        expect(connectCount).toEqual(1);\n        expect(res.status).toEqual(200);\n      } finally {\n        client.agent?.destroy();\n        proxy.close();\n      }\n    });","file":"unit/util/client.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with multiple prompts","suites":["confirm()"],"updatePoint":{"line":4,"column":39,"index":170},"line":4,"code":"  it('should work with multiple prompts', async () => {\n    // true (explicit)\n    let confirmedPromise = confirm(client, 'Explictly true?', false);\n    await expect(client.stderr).toOutput('Explictly true? [y/N]');\n    client.stdin.write('yes\\n');\n    let confirmed = await confirmedPromise;\n    expect(confirmed).toEqual(true);\n\n    // false (explicit)\n    confirmedPromise = confirm(client, 'Explcitly false?', true);\n    await expect(client.stderr).toOutput('Explcitly false? [Y/n]');\n    client.stdin.write('no\\n');\n    confirmed = await confirmedPromise;\n    expect(confirmed).toEqual(false);\n\n    // true (default)\n    confirmedPromise = confirm(client, 'Default true?', true);\n    await expect(client.stderr).toOutput('Default true? [Y/n]');\n    client.stdin.write('\\n');\n    confirmed = await confirmedPromise;\n    expect(confirmed).toEqual(true);\n\n    // false (default)\n    confirmedPromise = confirm(client, 'Default false?', false);\n    await expect(client.stderr).toOutput('Default false? [y/N]');\n    client.stdin.write('\\n');\n    confirmed = await confirmedPromise;\n    expect(confirmed).toEqual(false);\n  });","file":"unit/util/confirm.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"do nothing if x-middleware-override-headers is not set","suites":["applyOverriddenHeaders"],"updatePoint":{"line":4,"column":60,"index":217},"line":4,"code":"  it('do nothing if x-middleware-override-headers is not set', async () => {\n    const reqHeaders = {\n      a: '1'\n    };\n    const respHeaders = new Headers();\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      a: '1'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"adds a new header","suites":["applyOverriddenHeaders"],"updatePoint":{"line":14,"column":23,"index":460},"line":14,"code":"  it('adds a new header', async () => {\n    const reqHeaders = {\n      a: '1'\n    };\n    const respHeaders = new Headers({\n      // Define a new header 'b' and keep the existing header 'a'\n      'x-middleware-override-headers': 'a,b',\n      'x-middleware-request-a': '1',\n      'x-middleware-request-b': '2'\n    });\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      a: '1',\n      b: '2'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"delete the header if x-middleware-request-* is undefined","suites":["applyOverriddenHeaders"],"updatePoint":{"line":30,"column":62,"index":948},"line":30,"code":"  it('delete the header if x-middleware-request-* is undefined', async () => {\n    const reqHeaders = {\n      a: '1',\n      b: '2'\n    };\n    const respHeaders = new Headers({\n      // Deletes a new header 'c' and keep the existing headers `a` and `b`\n      'x-middleware-override-headers': 'a,b,c',\n      'x-middleware-request-a': '1',\n      'x-middleware-request-b': '2'\n    });\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      a: '1',\n      b: '2'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"updates an existing header","suites":["applyOverriddenHeaders"],"updatePoint":{"line":47,"column":32,"index":1432},"line":47,"code":"  it('updates an existing header', async () => {\n    const reqHeaders = {\n      a: '1',\n      b: '2'\n    };\n    const respHeaders = new Headers({\n      // Modifies the header 'b' and keep the existing header 'a'\n      'x-middleware-override-headers': 'a,b',\n      'x-middleware-request-a': '1',\n      'x-middleware-request-b': 'modified'\n    });\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      a: '1',\n      b: 'modified'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"ignores headers listed in NONOVERRIDABLE_HEADERS","suites":["applyOverriddenHeaders"],"updatePoint":{"line":64,"column":54,"index":1940},"line":64,"code":"  it('ignores headers listed in NONOVERRIDABLE_HEADERS', async () => {\n    const reqHeaders = {\n      a: '1',\n      host: 'example.com'\n    };\n    const respHeaders = new Headers({\n      // Define a new header 'b' and 'content-length'\n      'x-middleware-override-headers': 'a,b,content-length',\n      'x-middleware-request-a': '1',\n      'x-middleware-request-b': '2',\n      'x-middleware-request-content-length': '128'\n    });\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      a: '1',\n      b: '2',\n      host: 'example.com'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"deletes an existing header","suites":["applyOverriddenHeaders"],"updatePoint":{"line":83,"column":32,"index":2507},"line":83,"code":"  it('deletes an existing header', async () => {\n    const reqHeaders = {\n      a: '1',\n      b: '2'\n    };\n    const respHeaders = new Headers({\n      // Deletes the header 'a' and keep the existing header 'b'\n      'x-middleware-override-headers': 'b',\n      'x-middleware-request-b': '2'\n    });\n    applyOverriddenHeaders(reqHeaders, respHeaders);\n    expect(reqHeaders).toStrictEqual({\n      b: '2'\n    });\n  });","file":"unit/util/dev/headers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"works with file","suites":["mime-type"],"updatePoint":{"line":3,"column":21,"index":114},"line":3,"code":"  it('works with file', async () => {\n    const type = getMimeType('file.css');\n    expect(type).toBe('text/css; charset=utf-8');\n  });","file":"unit/util/dev/mime-type.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"works with file path","suites":["mime-type"],"updatePoint":{"line":7,"column":26,"index":255},"line":7,"code":"  it('works with file path', async () => {\n    const type = getMimeType('somewhere/file.css');\n    expect(type).toBe('text/css; charset=utf-8');\n  });","file":"unit/util/dev/mime-type.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"0\" as port 0","suites":["parseListen"],"updatePoint":{"line":4,"column":32,"index":201},"line":4,"code":"  it('should parse \"0\" as port 0', () => {\n    const result = parseListen('0');\n    expect(result).toHaveLength(1);\n    expect(result[0]).toEqual(0);\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"3000\" as port 3000","suites":["parseListen"],"updatePoint":{"line":9,"column":38,"index":363},"line":9,"code":"  it('should parse \"3000\" as port 3000', () => {\n    const result = parseListen('3000');\n    expect(result).toHaveLength(1);\n    expect(result[0]).toEqual(3000);\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"0.0.0.0\" as IP address","suites":["parseListen"],"updatePoint":{"line":14,"column":42,"index":535},"line":14,"code":"  it('should parse \"0.0.0.0\" as IP address', () => {\n    const result = parseListen('0.0.0.0');\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual(3000);\n    expect(result[1]).toEqual('0.0.0.0');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"127.0.0.1:4000\" as IP address and port","suites":["parseListen"],"updatePoint":{"line":20,"column":58,"index":768},"line":20,"code":"  it('should parse \"127.0.0.1:4000\" as IP address and port', () => {\n    const result = parseListen('127.0.0.1:4000');\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual(4000);\n    expect(result[1]).toEqual('127.0.0.1');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"tcp://127.0.0.1:5000\" as IP address and port","suites":["parseListen"],"updatePoint":{"line":26,"column":64,"index":1016},"line":26,"code":"  it('should parse \"tcp://127.0.0.1:5000\" as IP address and port', () => {\n    const result = parseListen('tcp://127.0.0.1:5000');\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual(5000);\n    expect(result[1]).toEqual('127.0.0.1');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"unix:/home/user/server.sock\" as UNIX socket file","suites":["parseListen"],"updatePoint":{"line":32,"column":68,"index":1274},"line":32,"code":"  it('should parse \"unix:/home/user/server.sock\" as UNIX socket file', () => {\n    if (IS_WINDOWS) {\n      console.log('Skipping this test on Windows.');\n      return;\n    }\n    const result = parseListen('unix:/home/user/server.sock');\n    expect(result).toHaveLength(1);\n    expect(result[0]).toEqual('/home/user/server.sock');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse \"pipe:\\\\.\\pipe\\PipeName\" as UNIX pipe","suites":["parseListen"],"updatePoint":{"line":41,"column":60,"index":1602},"line":41,"code":"  it('should parse \"pipe:\\\\\\\\.\\\\pipe\\\\PipeName\" as UNIX pipe', () => {\n    if (IS_WINDOWS) {\n      console.log('Skipping this test on Windows.');\n      return;\n    }\n    const result = parseListen('pipe:\\\\\\\\.\\\\pipe\\\\PipeName');\n    expect(result).toHaveLength(1);\n    expect(result[0]).toEqual('\\\\\\\\.\\\\pipe\\\\PipeName');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail to parse \"bad://url\"","suites":["parseListen"],"updatePoint":{"line":50,"column":38,"index":1906},"line":50,"code":"  it('should fail to parse \"bad://url\"', () => {\n    let err;\n    try {\n      parseListen('bad://url');\n      throw new Error('Should not happen');\n    } catch (_err) {\n      err = _err;\n    }\n    expect(err.message).toEqual('Unknown `--listen` scheme (protocol): bad:');\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"\"$input\"  \"$output\"","suites":["replaceLocalhost"],"line":62,"code":"  test.each([{\n    input: 'http://192.168.0.1:1234',\n    output: 'http://192.168.0.1:1234'\n  }, {\n    input: 'http://127.0.0.1:4000',\n    output: 'http://127.0.0.1:4000'\n  }, {\n    input: 'http://[::1]:3001',\n    output: 'http://[::1]:3001'\n  }, {\n    input: 'http://0.0.0.0:3000',\n    output: 'http://localhost:3000'\n  }, {\n    input: 'http://[::]:3002',\n    output: 'http://localhost:3002'\n  }])('\"$input\"  \"$output\"', ({\n    input,\n    output\n  }) => {\n    expect(replaceLocalhost(input)).toEqual(output);\n  });","file":"unit/util/dev/parse-listen.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse to Map and format back to original String","suites":["parseQueryString"],"updatePoint":{"line":3,"column":60,"index":197},"line":3,"code":"  it('should parse to Map and format back to original String', async () => {\n    const querystring = '?a&a=&a&b=1&c=2&c=3&d=&d&d=&space%20bar=4&html=%3Ch1%3E';\n    const parsed = parseQueryString(querystring);\n    expect(parsed).toEqual({\n      a: [undefined, '', undefined],\n      b: ['1'],\n      c: ['2', '3'],\n      d: ['', undefined, ''],\n      'space bar': ['4'],\n      html: ['<h1>']\n    });\n    const format = formatQueryString(parsed);\n    expect(format).toEqual(querystring);\n  });","file":"unit/util/dev/parse-query-string.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with empty string","suites":["parseQueryString"],"updatePoint":{"line":17,"column":35,"index":663},"line":17,"code":"  it('should work with empty string', async () => {\n    const parsed = parseQueryString('');\n    expect(parsed).toEqual({});\n    const format = formatQueryString(parsed);\n    expect(format).toEqual(null);\n  });","file":"unit/util/dev/parse-query-string.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with question mark","suites":["parseQueryString"],"updatePoint":{"line":23,"column":36,"index":875},"line":23,"code":"  it('should work with question mark', async () => {\n    const parsed = parseQueryString('?');\n    expect(parsed).toEqual({});\n    const format = formatQueryString(parsed);\n    expect(format).toEqual(null);\n  });","file":"unit/util/dev/parse-query-string.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work without question mark","suites":["parseQueryString"],"updatePoint":{"line":29,"column":39,"index":1091},"line":29,"code":"  it('should work without question mark', async () => {\n    const parsed = parseQueryString('blarg');\n    expect(parsed).toEqual({});\n    const format = formatQueryString(parsed);\n    expect(format).toEqual(null);\n  });","file":"unit/util/dev/parse-query-string.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with undefined","suites":["parseQueryString"],"updatePoint":{"line":35,"column":32,"index":1304},"line":35,"code":"  it('should work with undefined', async () => {\n    const parsed = parseQueryString(undefined);\n    expect(parsed).toEqual({});\n    const format = formatQueryString(parsed);\n    expect(format).toEqual(null);\n  });","file":"unit/util/dev/parse-query-string.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should handle 301 redirection","suites":["devRouter"],"updatePoint":{"line":3,"column":35,"index":127},"line":3,"code":"  it('should handle 301 redirection', async () => {\n    const routesConfig = [{\n      src: '/redirect',\n      status: 301,\n      headers: {\n        Location: 'https://vercel.com'\n      }\n    }];\n    const result = await devRouter('/redirect', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/redirect',\n      continue: false,\n      status: 301,\n      headers: {\n        location: 'https://vercel.com'\n      },\n      query: {},\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: false,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match captured groups","suites":["devRouter"],"updatePoint":{"line":28,"column":34,"index":744},"line":28,"code":"  it('should match captured groups', async () => {\n    const routesConfig = [{\n      src: '/api/(.*)',\n      dest: '/endpoints/$1.js'\n    }];\n    const result = await devRouter('/api/user', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/endpoints/user.js',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match named groups","suites":["devRouter"],"updatePoint":{"line":48,"column":31,"index":1274},"line":48,"code":"  it('should match named groups', async () => {\n    const routesConfig = [{\n      src: '/user/(?<id>.+)',\n      dest: '/user.js?id=$id'\n    }];\n    const result = await devRouter('/user/123', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/user.js',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {\n        id: ['123']\n      },\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match optional named groups","suites":["devRouter"],"updatePoint":{"line":70,"column":40,"index":1835},"line":70,"code":"  it('should match optional named groups', async () => {\n    const routesConfig = [{\n      src: '/api/hello(/(?<name>[^/]+))?',\n      dest: '/api/functions/hello/index.js?name=$name'\n    }];\n    const result = await devRouter('/api/hello', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/api/functions/hello/index.js',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {\n        name: ['']\n      },\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match proxy_pass","suites":["devRouter"],"updatePoint":{"line":92,"column":29,"index":2444},"line":92,"code":"  it('should match proxy_pass', async () => {\n    const routesConfig = [{\n      src: '/proxy',\n      dest: 'https://vercel.com'\n    }];\n    const result = await devRouter('/proxy', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: 'https://vercel.com',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: false,\n      isDestUrl: true,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match `methods`","suites":["devRouter"],"updatePoint":{"line":112,"column":28,"index":2967},"line":112,"code":"  it('should match `methods`', async () => {\n    const routesConfig = [{\n      src: '/.*',\n      methods: ['POST'],\n      dest: '/post'\n    }, {\n      src: '/.*',\n      methods: ['GET'],\n      dest: '/get'\n    }];\n    let result = await devRouter('/', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/get',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[1],\n      matched_route_idx: 1,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n    result = await devRouter('/', 'POST', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/post',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match without prefix slash","suites":["devRouter"],"updatePoint":{"line":151,"column":39,"index":3918},"line":151,"code":"  it('should match without prefix slash', async () => {\n    const routesConfig = [{\n      src: 'api/(.*)',\n      dest: 'endpoints/$1.js'\n    }];\n    const result = await devRouter('/api/user', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/endpoints/user.js',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[0],\n      matched_route_idx: 0,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match with needed prefixed slash","suites":["devRouter"],"updatePoint":{"line":171,"column":45,"index":4460},"line":171,"code":"  it('should match with needed prefixed slash', async () => {\n    const routesConfig = [{\n      src: '^\\\\/([^\\\\/]+?)\\\\/comments(?:\\\\/)?$',\n      dest: '/some/dest'\n    }];\n    const result = await devRouter('/post-1/comments', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/some/dest',\n      continue: false,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: {\n        src: '^\\\\/([^\\\\/]+?)\\\\/comments(?:\\\\/)?$',\n        dest: '/some/dest'\n      },\n      matched_route_idx: 0\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match `continue: true` with fallthrough","suites":["devRouter"],"updatePoint":{"line":194,"column":52,"index":5101},"line":194,"code":"  it('should match `continue: true` with fallthrough', async () => {\n    const routesConfig = [{\n      src: '/_next/static/(?:[^/]+/pages|chunks|runtime)/.+',\n      continue: true,\n      headers: {\n        'cache-control': 'immutable,max-age=31536000'\n      }\n    }];\n    const result = await devRouter('/_next/static/chunks/0.js', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: false,\n      dest: '/_next/static/chunks/0.js',\n      continue: true,\n      isDestUrl: false,\n      phase: undefined,\n      status: undefined,\n      query: {},\n      headers: {\n        'cache-control': 'immutable,max-age=31536000'\n      }\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match `continue: true` with match","suites":["devRouter"],"updatePoint":{"line":216,"column":46,"index":5750},"line":216,"code":"  it('should match `continue: true` with match', async () => {\n    const routesConfig = [{\n      src: '/_next/static/(?:[^/]+/pages|chunks|runtime)/.+',\n      continue: true,\n      headers: {\n        'cache-control': 'immutable,max-age=31536000'\n      }\n    }, {\n      src: '/(.*)',\n      dest: '/hi'\n    }];\n    const result = await devRouter('/_next/static/chunks/0.js', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/hi',\n      continue: false,\n      status: undefined,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined,\n      query: {},\n      headers: {\n        'cache-control': 'immutable,max-age=31536000'\n      },\n      matched_route: {\n        src: '/(.*)',\n        dest: '/hi'\n      },\n      matched_route_idx: 1\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match with catch-all with prefix slash","suites":["devRouter"],"updatePoint":{"line":247,"column":51,"index":6553},"line":247,"code":"  it('should match with catch-all with prefix slash', async () => {\n    const routesConfig = [{\n      src: '/(.*)',\n      dest: '/www/$1'\n    }];\n    const result = await devRouter('/', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/www/',\n      continue: false,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: {\n        src: '/(.*)',\n        dest: '/www/$1'\n      },\n      matched_route_idx: 0\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match with catch-all with no prefix slash","suites":["devRouter"],"updatePoint":{"line":270,"column":54,"index":7112},"line":270,"code":"  it('should match with catch-all with no prefix slash', async () => {\n    const routesConfig = [{\n      src: '(.*)',\n      dest: '/www$1'\n    }];\n    const result = await devRouter('/', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: '/www/',\n      continue: false,\n      userDest: true,\n      isDestUrl: false,\n      phase: undefined,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: {\n        src: '(.*)',\n        dest: '/www$1'\n      },\n      matched_route_idx: 0\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should match `continue: true` with `dest`","suites":["devRouter"],"updatePoint":{"line":293,"column":47,"index":7660},"line":293,"code":"  it('should match `continue: true` with `dest`', async () => {\n    const routesConfig = [{\n      src: '/(.*)',\n      dest: '/www/$1',\n      continue: true\n    }, {\n      src: '^/www/(a\\\\/([^\\\\/]+?)(?:\\\\/)?)$',\n      dest: 'http://localhost:5000/$1'\n    }];\n    const result = await devRouter('/a/foo', 'GET', routesConfig);\n    expect(result).toMatchObject({\n      found: true,\n      dest: 'http://localhost:5000/a/foo',\n      continue: false,\n      status: undefined,\n      headers: {},\n      query: {},\n      matched_route: routesConfig[1],\n      matched_route_idx: 1,\n      userDest: false,\n      isDestUrl: true,\n      phase: undefined\n    });\n  });","file":"unit/util/dev/router.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx response error with fallback message","suites":["responseError()"],"updatePoint":{"line":22,"column":59,"index":826},"line":22,"code":"  it('should parse 4xx response error with fallback message', async () => {\n    handler = (_req, res) => {\n      send(res, 404, {});\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res, 'Failed to load data');\n    expect(formatted.message).toEqual('Failed to load data (404)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx response error without fallback message","suites":["responseError()"],"updatePoint":{"line":30,"column":62,"index":1148},"line":30,"code":"  it('should parse 4xx response error without fallback message', async () => {\n    handler = (_req, res) => {\n      send(res, 404, {});\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('Response Error (404)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 5xx response error without fallback message","suites":["responseError()"],"updatePoint":{"line":38,"column":62,"index":1442},"line":38,"code":"  it('should parse 5xx response error without fallback message', async () => {\n    handler = (_req, res) => {\n      send(res, 500, '');\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('Response Error (500)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx response error as correct JSON","suites":["responseError()"],"updatePoint":{"line":46,"column":53,"index":1727},"line":46,"code":"  it('should parse 4xx response error as correct JSON', async () => {\n    handler = (_req, res) => {\n      send(res, 400, {\n        error: {\n          message: 'The request is not correct'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('The request is not correct (400)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 5xx response error as HTML","suites":["responseError()"],"updatePoint":{"line":58,"column":45,"index":2098},"line":58,"code":"  it('should parse 5xx response error as HTML', async () => {\n    handler = (_req, res) => {\n      send(res, 500, 'This is a malformed error');\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res, 'Failed to process data');\n    expect(formatted.message).toEqual('Failed to process data (500)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 5xx response error with random JSON","suites":["responseError()"],"updatePoint":{"line":66,"column":54,"index":2443},"line":66,"code":"  it('should parse 5xx response error with random JSON', async () => {\n    handler = (_req, res) => {\n      send(res, 500, {\n        wrong: 'property'\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res, 'Failed to process data');\n    expect(formatted.message).toEqual('Failed to process data (500)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx error message with broken JSON","suites":["responseError()"],"updatePoint":{"line":76,"column":53,"index":2795},"line":76,"code":"  it('should parse 4xx error message with broken JSON', async () => {\n    handler = (_req, res) => {\n      send(res, 403, `32puuuh2332`);\n    };\n    const res = await fetch(url);\n    const formatted = await responseErrorMessage(res, 'Not authenticated');\n    expect(formatted).toEqual('Not authenticated (403)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx error message with proper message","suites":["responseError()"],"updatePoint":{"line":84,"column":56,"index":3117},"line":84,"code":"  it('should parse 4xx error message with proper message', async () => {\n    handler = (_req, res) => {\n      send(res, 403, {\n        error: {\n          message: 'This is a test'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseErrorMessage(res);\n    expect(formatted).toEqual('This is a test (403)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 5xx error message with proper message","suites":["responseError()"],"updatePoint":{"line":96,"column":56,"index":3474},"line":96,"code":"  it('should parse 5xx error message with proper message', async () => {\n    handler = (_req, res) => {\n      send(res, 500, {\n        error: {\n          message: 'This is a test'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseErrorMessage(res);\n    expect(formatted).toEqual('Response Error (500)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx response error with broken JSON","suites":["responseError()"],"updatePoint":{"line":108,"column":54,"index":3829},"line":108,"code":"  it('should parse 4xx response error with broken JSON', async () => {\n    handler = (_req, res) => {\n      send(res, 403, `122{\"sss\"`);\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res, 'Not authenticated');\n    expect(formatted.message).toEqual('Not authenticated (403)');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 4xx response error as correct JSON with more properties","suites":["responseError()"],"updatePoint":{"line":116,"column":74,"index":4168},"line":116,"code":"  it('should parse 4xx response error as correct JSON with more properties', async () => {\n    handler = (_req, res) => {\n      send(res, 403, {\n        error: {\n          message: 'The request is not correct',\n          additionalProperty: 'test'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('The request is not correct (403)');\n    expect(formatted.additionalProperty).toEqual('test');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 429 response error with retry header","suites":["responseError()"],"updatePoint":{"line":130,"column":55,"index":4645},"line":130,"code":"  it('should parse 429 response error with retry header', async () => {\n    handler = (_req, res) => {\n      res.setHeader('Retry-After', '20');\n      send(res, 429, {\n        error: {\n          message: 'You were rate limited'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('You were rate limited (429)');\n    expect(formatted.retryAfter).toEqual(20);\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse 429 response error without retry header","suites":["responseError()"],"updatePoint":{"line":144,"column":58,"index":5107},"line":144,"code":"  it('should parse 429 response error without retry header', async () => {\n    handler = (_req, res) => {\n      send(res, 429, {\n        error: {\n          message: 'You were rate limited'\n        }\n      });\n    };\n    const res = await fetch(url);\n    const formatted = await responseError(res);\n    expect(formatted.message).toEqual('You were rate limited (429)');\n    expect(formatted.retryAfter).toEqual(undefined);\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should JSON stringify Error","suites":["toEnumerableError()"],"updatePoint":{"line":159,"column":33,"index":5553},"line":159,"code":"  it('should JSON stringify Error', () => {\n    const err = new Error('An error');\n    const enumerable = toEnumerableError(err);\n    expect(JSON.stringify(err)).toEqual('{}');\n\n    // Delete `stack` since it makes stringify nondeterministic\n    // (due to filenames / line numbers)\n    expect(typeof enumerable.stack).toEqual('string');\n    delete enumerable.stack;\n    expect(JSON.stringify(enumerable)).toEqual('{\"name\":\"Error\",\"message\":\"An error\"}');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should JSON stringify Error with custom properties","suites":["toEnumerableError()"],"updatePoint":{"line":170,"column":56,"index":6038},"line":170,"code":"  it('should JSON stringify Error with custom properties', () => {\n    const err = new Error('An error');\n    Object.defineProperty(err, 'custom', {\n      enumerable: false,\n      value: 'value'\n    });\n    Object.defineProperty(err, 'userError', {\n      enumerable: false,\n      value: true\n    });\n    const enumerable = toEnumerableError(err);\n    expect(JSON.stringify(err)).toEqual('{}');\n\n    // Delete `stack` since it makes stringify undeterministinc\n    // (due to filenames / line numbers)\n    expect(typeof enumerable.stack).toEqual('string');\n    delete enumerable.stack;\n    expect(JSON.stringify(enumerable)).toEqual('{\"name\":\"Error\",\"message\":\"An error\",\"custom\":\"value\",\"userError\":true}');\n  });","file":"unit/util/error.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should discover files for builds deployment","suites":["staticFiles"],"updatePoint":{"line":28,"column":49,"index":1121},"line":28,"code":"  it('should discover files for builds deployment', async () => {\n    const path = 'now-json-static-no-files';\n    let files = await getStaticFiles(fixture(path));\n    files = files.sort(alpha);\n    expect(files).toHaveLength(4);\n    expect(base(files[0])).toEqual(`${path}/a.js`);\n    expect(base(files[1])).toEqual(`${path}/b.js`);\n    expect(base(files[2])).toEqual(`${path}/build/a/c.js`);\n    expect(base(files[3])).toEqual(`${path}/package.json`);\n  });","file":"unit/util/get-files.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should respect `.vercelignore` file rules","suites":["staticFiles"],"updatePoint":{"line":38,"column":47,"index":1579},"line":38,"code":"  it('should respect `.vercelignore` file rules', async () => {\n    const path = 'vercelignore';\n    let files = await getStaticFiles(fixture(path));\n    files = files.sort(alpha);\n    expect(files).toHaveLength(6);\n    expect(base(files[0])).toEqual(`${path}/.vercelignore`);\n    expect(base(files[1])).toEqual(`${path}/a.js`);\n    expect(base(files[2])).toEqual(`${path}/build/sub/a.js`);\n    expect(base(files[3])).toEqual(`${path}/build/sub/c.js`);\n    expect(base(files[4])).toEqual(`${path}/c.js`);\n    expect(base(files[5])).toEqual(`${path}/package.json`);\n  });","file":"unit/util/get-files.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw an error if next not a number","suites":["getOpts"],"updatePoint":{"line":4,"column":48,"index":202},"line":4,"code":"  it('should throw an error if next not a number', async () => {\n    const args = getArgs([`--next=oops`], {\n      '--next': Number\n    });\n    expect(() => {\n      getPaginationOpts(args);\n    }).toThrowError();\n  });","file":"unit/util/get-pagination-opts.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw an error if limit not valid","suites":["getOpts"],"updatePoint":{"line":12,"column":46,"index":419},"line":12,"code":"  it('should throw an error if limit not valid', async () => {\n    for (let limit of ['abc', '101', '1.1', '-1']) {\n      const args = getArgs([`--limit=${limit}`], {\n        '--limit': Number\n      });\n      expect(() => {\n        getPaginationOpts(args);\n      }).toThrowError();\n    }\n  });","file":"unit/util/get-pagination-opts.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with argv","suites":["getProjectName"],"updatePoint":{"line":3,"column":27,"index":128},"line":3,"code":"  it('should work with argv', () => {\n    const project = getProjectName({\n      argv: {\n        '--name': 'abc'\n      }\n    });\n    expect(project).toEqual('abc');\n  });","file":"unit/util/get-project-name.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with `vercel.json` config","suites":["getProjectName"],"updatePoint":{"line":11,"column":43,"index":315},"line":11,"code":"  it('should work with `vercel.json` config', () => {\n    const project = getProjectName({\n      argv: {},\n      nowConfig: {\n        name: 'abc'\n      }\n    });\n    expect(project).toEqual('abc');\n  });","file":"unit/util/get-project-name.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should work with a directory","suites":["getProjectName"],"updatePoint":{"line":20,"column":34,"index":510},"line":20,"code":"  it('should work with a directory', () => {\n    const project = getProjectName({\n      argv: {},\n      nowConfig: {},\n      paths: ['/tmp/aa']\n    });\n    expect(project).toEqual('aa');\n  });","file":"unit/util/get-project-name.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect update command","suites":["getUpdateCommand"],"updatePoint":{"line":3,"column":34,"index":141},"line":3,"code":"  it('should detect update command', async () => {\n    const updateCommand = await getUpdateCommand();\n    expect(updateCommand).toEqual(`pnpm i vercel@latest`);\n  });","file":"unit/util/get-update-command.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should support \"github\" URL","suites":["repoInfoToUrl()"],"updatePoint":{"line":3,"column":33,"index":145},"line":3,"code":"  it('should support \"github\" URL', () => {\n    const info = {\n      provider: 'github',\n      org: 'vercel',\n      repo: 'foo',\n      url: 'git@github.com:vercel/foo.git'\n    };\n    expect(repoInfoToUrl(info)).toEqual('https://github.com/vercel/foo');\n  });","file":"unit/util/git/repo-info-to-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should support \"gitlab\" URL","suites":["repoInfoToUrl()"],"updatePoint":{"line":12,"column":33,"index":404},"line":12,"code":"  it('should support \"gitlab\" URL', () => {\n    const info = {\n      provider: 'gitlab',\n      org: 'vercel',\n      repo: 'foo',\n      url: 'git@gitlab.com:vercel/foo.git'\n    };\n    expect(repoInfoToUrl(info)).toEqual('https://gitlab.com/vercel/foo');\n  });","file":"unit/util/git/repo-info-to-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should support \"bitbucket\" URL","suites":["repoInfoToUrl()"],"updatePoint":{"line":21,"column":36,"index":666},"line":21,"code":"  it('should support \"bitbucket\" URL', () => {\n    const info = {\n      provider: 'bitbucket',\n      org: 'vercel',\n      repo: 'foo',\n      url: 'git@bitbucket.com:vercel/foo.git'\n    };\n    expect(repoInfoToUrl(info)).toEqual('https://bitbucket.com/vercel/foo');\n  });","file":"unit/util/git/repo-info-to-url.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should guess \"mdx-deck\"","suites":["didYouMean"],"updatePoint":{"line":4,"column":29,"index":594},"line":4,"code":"  it('should guess \"mdx-deck\"', () => {\n    expect(didYouMean('md', examples, 0.7)).toEqual('mdx-deck');\n  });","file":"unit/util/init/did-you-mean.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should guess \"nodejs-koa\"","suites":["didYouMean"],"updatePoint":{"line":7,"column":31,"index":707},"line":7,"code":"  it('should guess \"nodejs-koa\"', () => {\n    expect(didYouMean('koa', examples, 0.7)).toEqual('nodejs-koa');\n  });","file":"unit/util/init/did-you-mean.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should guess \"nodejs\"","suites":["didYouMean"],"updatePoint":{"line":10,"column":27,"index":819},"line":10,"code":"  it('should guess \"nodejs\"', () => {\n    expect(didYouMean('node', examples, 0.7)).toEqual('nodejs');\n  });","file":"unit/util/init/did-you-mean.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fail to guess with bad input","suites":["didYouMean"],"updatePoint":{"line":13,"column":41,"index":942},"line":13,"code":"  it('should fail to guess with bad input', () => {\n    expect(didYouMean('12345', examples, 0.7)).toBeUndefined();\n  });","file":"unit/util/init/did-you-mean.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should detect \"\" as \\`\\`","suites":["isValidName"],"updatePoint":{"line":15,"column":51,"index":367},"line":15,"code":"    it(`should detect \"${value}\" as \\`${expected}\\``, () => {\n      expect(isValidName(value)).toEqual(expected);\n    });","file":"unit/util/is-valid-name.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should find Git repo root from root","suites":["findRepoRoot()"],"updatePoint":{"line":9,"column":41,"index":396},"line":9,"code":"  it('should find Git repo root from root', async () => {\n    const repoRoot = await findRepoRoot(client, vercelRepoRoot);\n    expect(repoRoot).toEqual(vercelRepoRoot);\n  });","file":"unit/util/link/repo.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should find Git repo root sub directory","suites":["findRepoRoot()"],"updatePoint":{"line":13,"column":45,"index":575},"line":13,"code":"  it('should find Git repo root sub directory', async () => {\n    const repoRoot = await findRepoRoot(client, __dirname);\n    expect(repoRoot).toEqual(vercelRepoRoot);\n  });","file":"unit/util/link/repo.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return `undefined` when no Git root found","suites":["findRepoRoot()"],"updatePoint":{"line":17,"column":54,"index":758},"line":17,"code":"  it('should return `undefined` when no Git root found', async () => {\n    const repoRoot = await findRepoRoot(client, tmpdir());\n    expect(repoRoot).toEqual(undefined);\n  });","file":"unit/util/link/repo.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should find Project \"$id\" for path \"$path\"","suites":["findProjectsFromPath()"],"line":48,"code":"  it.each([{\n    ids: ['root'],\n    path: '.'\n  }, {\n    ids: ['root'],\n    path: 'lib'\n  }, {\n    ids: ['root'],\n    path: 'lib'\n  }, {\n    ids: ['site'],\n    path: `apps${sep}site`\n  }, {\n    ids: ['site'],\n    path: `apps${sep}site`\n  }, {\n    ids: ['site'],\n    path: `apps${sep}site${sep}components`\n  }, {\n    ids: ['site2'],\n    path: `apps${sep}site2`\n  }, {\n    ids: ['site2'],\n    path: `apps${sep}site2${sep}inner`\n  }, {\n    ids: ['other', 'duplicate'],\n    path: `apps${sep}other`\n  }, {\n    ids: ['other', 'duplicate'],\n    path: `apps${sep}other${sep}lib`\n  }, {\n    ids: ['nested'],\n    path: `apps${sep}other${sep}nested`\n  }, {\n    ids: ['nested'],\n    path: `apps${sep}other${sep}nested${sep}foo`\n  }])('should find Project \"$id\" for path \"$path\"', ({\n    path,\n    ids\n  }) => {\n    const actual = findProjectsFromPath(projects, path);\n    expect(actual.map(a => a.id)).toEqual(ids);\n  });","file":"unit/util/link/repo.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return empty array when there are no matching Projects","suites":["findProjectsFromPath()"],"updatePoint":{"line":91,"column":67,"index":2328},"line":91,"code":"  it('should return empty array when there are no matching Projects', () => {\n    const actual = findProjectsFromPath([projects[1]], '.');\n    expect(actual).toHaveLength(0);\n  });","file":"unit/util/link/repo.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show single line box with default padding","suites":["box()"],"updatePoint":{"line":5,"column":54,"index":195},"line":5,"code":"  it('should show single line box with default padding', () => {\n    const result = box('Hello world!');\n    expect(stripAnsi(result)).toEqual(`\n\n                  \n   Hello world!   \n                  \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show single line box without padding","suites":["box()"],"updatePoint":{"line":15,"column":49,"index":461},"line":15,"code":"  it('should show single line box without padding', () => {\n    const result = box('Hello world!', {\n      padding: 0\n    });\n    expect(stripAnsi(result)).toEqual(`\n\n Hello world! \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show single line box with padding 2","suites":["box()"],"updatePoint":{"line":25,"column":48,"index":698},"line":25,"code":"  it('should show single line box with padding 2', () => {\n    const result = box('Hello world!', {\n      padding: 2\n    });\n    expect(stripAnsi(result)).toEqual(`\n\n                        \n                        \n      Hello world!      \n                        \n                        \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should show multiple lines with default padding","suites":["box()"],"updatePoint":{"line":39,"column":53,"index":1078},"line":39,"code":"  it('should show multiple lines with default padding', () => {\n    const result = box('Hello world!\\nThis is a really, really long line of text\\n\\nWow!');\n    expect(stripAnsi(result)).toEqual(`\n\n                                                \n                  Hello world!                  \n   This is a really, really long line of text   \n                                                \n                      Wow!                      \n                                                \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should ignore ansi color escape sequences","suites":["box()"],"updatePoint":{"line":52,"column":47,"index":1697},"line":52,"code":"  it('should ignore ansi color escape sequences', () => {\n    const result = box(chalk.red('This text is red'));\n    expect(stripAnsi(result)).toEqual(`\n\n                      \n   This text is red   \n                      \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should left align contents","suites":["box()"],"updatePoint":{"line":62,"column":32,"index":1981},"line":62,"code":"  it('should left align contents', () => {\n    const result = box('This is left aligned\\nThis is a really, really long line of text', {\n      textAlignment: 'left'\n    });\n    expect(stripAnsi(result)).toEqual(`\n\n                                                \n   This is left aligned                         \n   This is a really, really long line of text   \n                                                \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should right align contents","suites":["box()"],"updatePoint":{"line":75,"column":33,"index":2521},"line":75,"code":"  it('should right align contents', () => {\n    const result = box('This is right aligned\\nThis is a really, really long line of text', {\n      textAlignment: 'right'\n    });\n    expect(stripAnsi(result)).toEqual(`\n\n                                                \n                        This is right aligned   \n   This is a really, really long line of text   \n                                                \n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should slim if terminal width too small","suites":["box()"],"updatePoint":{"line":88,"column":45,"index":3075},"line":88,"code":"  it('should slim if terminal width too small', () => {\n    const result = box('This is a really, really long line of text', {\n      terminalColumns: 30\n    });\n    expect(stripAnsi(result)).toEqual(`\n\n\nThis is a really, really long line of text\n\n\n    `.trim());\n  });","file":"unit/util/output/box.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return hyperlink ANSI codes when `supportsHyperlink=true`","suites":["Output","link()"],"updatePoint":{"line":5,"column":72,"index":213},"line":5,"code":"    it('should return hyperlink ANSI codes when `supportsHyperlink=true`', () => {\n      client.output.supportsHyperlink = true;\n      const val = client.output.link('Click Here', 'https://example.com');\n      expect(val).toEqual('\\x1B]8;;https://example.com\\x07Click Here\\x1B]8;;\\x07');\n      expect(stripAnsi(val)).toEqual('Click Here');\n    });","file":"unit/util/output/create-output.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return default fallback when `supportsHyperlink=false`","suites":["Output","link()"],"updatePoint":{"line":11,"column":69,"index":558},"line":11,"code":"    it('should return default fallback when `supportsHyperlink=false`', () => {\n      client.output.supportsHyperlink = false;\n      const val = client.output.link('Click Here', 'https://example.com');\n      expect(val).toEqual('Click Here (https://example.com)');\n    });","file":"unit/util/output/create-output.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return text fallback when `supportsHyperlink=false` with `fallback: false`","suites":["Output","link()"],"updatePoint":{"line":16,"column":89,"index":851},"line":16,"code":"    it('should return text fallback when `supportsHyperlink=false` with `fallback: false`', () => {\n      client.output.supportsHyperlink = false;\n      const val = client.output.link('Click Here', 'https://example.com', {\n        fallback: false\n      });\n      expect(val).toEqual('Click Here');\n    });","file":"unit/util/output/create-output.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return fallback when `supportsHyperlink=false` with `fallback` function","suites":["Output","link()"],"updatePoint":{"line":23,"column":86,"index":1154},"line":23,"code":"    it('should return fallback when `supportsHyperlink=false` with `fallback` function', () => {\n      client.output.supportsHyperlink = false;\n      const val = client.output.link('Click Here', 'https://example.com', {\n        fallback: () => 'other'\n      });\n      expect(val).toEqual('other');\n    });","file":"unit/util/output/create-output.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"$current / $total -> \"$expected\"","suites":["progress()"],"line":3,"code":"  test.each([{\n    current: 0,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '-----'\n  }, {\n    current: 1,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '=----'\n  }, {\n    current: 2,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '==---'\n  }, {\n    current: 3,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '===--'\n  }, {\n    current: 4,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '====-'\n  }, {\n    current: 5,\n    total: 5,\n    opts: {\n      width: 5\n    },\n    expected: '====='\n  }, {\n    current: 0,\n    total: 12,\n    expected: '--------------------'\n  }, {\n    current: 1,\n    total: 12,\n    expected: '=-------------------'\n  }, {\n    current: 2,\n    total: 12,\n    expected: '===-----------------'\n  }, {\n    current: 600,\n    total: 1200,\n    expected: '==========----------'\n  }, {\n    current: 9,\n    total: 10,\n    opts: {\n      complete: '.',\n      incomplete: ' ',\n      width: 10\n    },\n    expected: '......... '\n  }, {\n    current: 10,\n    total: 10,\n    expected: '===================='\n  }, {\n    current: 11,\n    total: 10,\n    expected: null\n  }, {\n    current: -1,\n    total: 10,\n    expected: null\n  }, {\n    current: 1,\n    total: 0,\n    expected: null\n  }])('$current / $total -> \"$expected\"', ({\n    current,\n    total,\n    opts,\n    expected\n  }) => {\n    expect(progress(current, total, opts)).toEqual(expected);\n  });","file":"unit/util/output/progress.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get project and deployment","suites":["getProjectByDeployment"],"updatePoint":{"line":8,"column":39,"index":448},"line":8,"code":"  it('should get project and deployment', async () => {\n    const user = useUser();\n    const {\n      project: p\n    } = useProject({\n      ...defaultProject,\n      id: 'foo',\n      name: 'foo'\n    });\n    const d = useDeployment({\n      creator: user,\n      createdAt: Date.now(),\n      project: p\n    });\n    const {\n      deployment,\n      project\n    } = await getProjectByDeployment({\n      client,\n      deployId: d.id,\n      output: client.output\n    });\n    expect(project.id).toBe(p.id);\n    expect(deployment.id).toBe(d.id);\n  });","file":"unit/util/projects/get-project-by-deployment.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should get project and deployment associated to a team","suites":["getProjectByDeployment"],"updatePoint":{"line":33,"column":60,"index":1010},"line":33,"code":"  it('should get project and deployment associated to a team', async () => {\n    const [team] = useTeams('team_dummy');\n    const user = useUser();\n    const {\n      project: p\n    } = useProject({\n      ...defaultProject,\n      id: 'foo',\n      name: 'foo'\n    });\n    const d = useDeployment({\n      creator: {\n        id: team.id,\n        name: team.name,\n        email: user.email,\n        username: team.slug\n      },\n      createdAt: Date.now(),\n      project: p\n    });\n    client.config.currentTeam = team.id;\n    d.team = team;\n    const {\n      deployment,\n      project\n    } = await getProjectByDeployment({\n      client,\n      deployId: d.id,\n      output: client.output\n    });\n    expect(project.id).toBe(p.id);\n    expect(deployment.id).toBe(d.id);\n  });","file":"unit/util/projects/get-project-by-deployment.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should error if deployment team doesn't match current user's team","suites":["getProjectByDeployment"],"updatePoint":{"line":66,"column":71,"index":1792},"line":66,"code":"  it(\"should error if deployment team doesn't match current user's team\", async () => {\n    const [team] = useTeams('team_dummy');\n    const user = useUser();\n    const {\n      project: p\n    } = useProject({\n      ...defaultProject,\n      id: 'foo',\n      name: 'foo'\n    });\n    const d = useDeployment({\n      creator: {\n        id: team.id,\n        name: team.name,\n        email: user.email,\n        username: team.slug\n      },\n      createdAt: Date.now(),\n      project: p\n    });\n    client.config.currentTeam = team.id;\n    await expect(getProjectByDeployment({\n      client,\n      deployId: d.id,\n      output: client.output\n    })).rejects.toThrowError(\"Deployment doesn't belong to current team\");\n    client.config.currentTeam = undefined;\n    d.team = team;\n    await expect(getProjectByDeployment({\n      client,\n      deployId: d.id,\n      output: client.output\n    })).rejects.toThrowError('Deployment belongs to a different team');\n  });","file":"unit/util/projects/get-project-by-deployment.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return \".vercel\"","suites":["getVercelDirectory"],"updatePoint":{"line":5,"column":29,"index":254},"line":5,"code":"  it('should return \".vercel\"', () => {\n    const cwd = fixture('get-vercel-directory');\n    const dir = getVercelDirectory(cwd);\n    expect(basename(dir)).toEqual('.vercel');\n  });","file":"unit/util/projects/get-vercel-directory.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return \".now\"","suites":["getVercelDirectory"],"updatePoint":{"line":10,"column":26,"index":433},"line":10,"code":"  it('should return \".now\"', () => {\n    const cwd = fixture('get-vercel-directory-legacy');\n    const dir = getVercelDirectory(cwd);\n    expect(basename(dir)).toEqual('.now');\n  });","file":"unit/util/projects/get-vercel-directory.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should throw an error if both \".vercel\" and \".now\" exist","suites":["getVercelDirectory"],"updatePoint":{"line":15,"column":62,"index":652},"line":15,"code":"  it('should throw an error if both \".vercel\" and \".now\" exist', () => {\n    let err;\n    const cwd = fixture('get-vercel-directory-error');\n    try {\n      getVercelDirectory(cwd);\n      throw new Error('Should not happen');\n    } catch (_err) {\n      err = _err;\n    }\n    expect(err.message).toEqual('Both `.vercel` and `.now` directories exist. Please remove the `.now` directory.');\n  });","file":"unit/util/projects/get-vercel-directory.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse simple to host","suites":["toHost"],"updatePoint":{"line":3,"column":33,"index":109},"line":3,"code":"  it('should parse simple to host', () => {\n    expect(toHost('vercel.com')).toEqual('vercel.com');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse leading // to host","suites":["toHost"],"updatePoint":{"line":6,"column":37,"index":219},"line":6,"code":"  it('should parse leading // to host', () => {\n    expect(toHost('//zeit-logos-rnemgaicnc.now.sh')).toEqual('zeit-logos-rnemgaicnc.now.sh');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse leading http:// to host","suites":["toHost"],"updatePoint":{"line":9,"column":42,"index":372},"line":9,"code":"  it('should parse leading http:// to host', () => {\n    expect(toHost('http://zeit-logos-rnemgaicnc.now.sh')).toEqual('zeit-logos-rnemgaicnc.now.sh');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse leading https:// to host","suites":["toHost"],"updatePoint":{"line":12,"column":43,"index":531},"line":12,"code":"  it('should parse leading https:// to host', () => {\n    expect(toHost('https://zeit-logos-rnemgaicnc.now.sh')).toEqual('zeit-logos-rnemgaicnc.now.sh');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse leading https:// and path to host","suites":["toHost"],"updatePoint":{"line":15,"column":52,"index":700},"line":15,"code":"  it('should parse leading https:// and path to host', () => {\n    expect(toHost('https://zeit-logos-rnemgaicnc.now.sh/path')).toEqual('zeit-logos-rnemgaicnc.now.sh');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should parse simple and path to host","suites":["toHost"],"updatePoint":{"line":18,"column":42,"index":864},"line":18,"code":"  it('should parse simple and path to host', () => {\n    expect(toHost('vercel.com/test')).toEqual('vercel.com');\n  });","file":"unit/util/to-host.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should render message","suites":["Stage App Component"],"updatePoint":{"line":10,"column":27,"index":388},"line":10,"code":"  it('should render message', done => {\n    component.create(bootstrap).then(() => {\n      const view = component.element;\n      expect(view.textContent.trim()).toBe('Hello World!');\n      done();\n    }).catch(e => {\n      fail(e);\n      done();\n    });\n  });","file":"unit/app.spec.js","skipped":false,"dir":"packages/cli/test/dev/fixtures/03-aurelia/test"},{"name":"will display an empty deployment warning","suites":["create v2 deployment"],"updatePoint":{"line":29,"column":46},"line":29,"code":"  it('will display an empty deployment warning', async () => {\n    for await (const event of createDeployment(\n      {\n        token,\n        path: path.resolve(__dirname, 'fixtures', 'v2'),\n      },\n      {\n        name: 'now-clien-tests-v2',\n      }\n    )) {\n      if (event.type === 'warning') {\n        expect(event.payload).toEqual('READY');\n      }\n\n      if (event.type === 'ready') {\n        deployment = event.payload;\n        break;\n      }\n    }\n  });","file":"create-deployment.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will report correct file count event","suites":["create v2 deployment"],"updatePoint":{"line":50,"column":42},"line":50,"code":"  it('will report correct file count event', async () => {\n    for await (const event of createDeployment(\n      {\n        token,\n        path: path.resolve(__dirname, 'fixtures', 'v2'),\n      },\n      {\n        name: 'now-client-tests-v2',\n      }\n    )) {\n      if (event.type === 'file-count') {\n        expect(event.payload.total).toEqual(0);\n      }\n\n      if (event.type === 'ready') {\n        deployment = event.payload;\n        break;\n      }\n    }\n  });","file":"create-deployment.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will create a v2 deployment","suites":["create v2 deployment"],"updatePoint":{"line":71,"column":33},"line":71,"code":"  it('will create a v2 deployment', async () => {\n    for await (const event of createDeployment(\n      {\n        token,\n        path: path.resolve(__dirname, 'fixtures', 'v2'),\n      },\n      {\n        name: 'now-client-tests-v2',\n      }\n    )) {\n      if (event.type === 'ready') {\n        deployment = event.payload;\n        expect(deployment.readyState).toEqual('READY');\n        break;\n      }\n    }\n  });","file":"create-deployment.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will create a v2 deployment with correct file permissions","suites":["create v2 deployment"],"updatePoint":{"line":89,"column":63},"line":89,"code":"  it('will create a v2 deployment with correct file permissions', async () => {\n    let error = null;\n    for await (const event of createDeployment(\n      {\n        token,\n        path: path.resolve(__dirname, 'fixtures', 'v2-file-permissions'),\n        skipAutoDetectionConfirmation: true,\n      },\n      {\n        name: 'now-client-tests-v2',\n        projectSettings: {\n          buildCommand: null,\n          devCommand: null,\n          outputDirectory: null,\n        },\n      }\n    )) {\n      if (event.type === 'ready') {\n        deployment = event.payload;\n        break;\n      } else if (event.type === 'error') {\n        error = event.payload;\n        console.error(error.message);\n        break;\n      }\n    }\n\n    expect(error).toBe(null);\n    expect(deployment.readyState).toEqual('READY');\n\n    const url = `https://${deployment.url}/api/index.js`;\n    console.log('testing url ' + url);\n    const response = await fetch_(url);\n    const text = await response.text();\n    expect(deployment.readyState).toEqual('READY');\n    expect(text).toContain('executed bash script');\n  });","file":"create-deployment.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will create a v2 deployment and ignore files specified in .nowignore","suites":["create v2 deployment"],"updatePoint":{"line":127,"column":74},"line":127,"code":"  it('will create a v2 deployment and ignore files specified in .nowignore', async () => {\n    let error = null;\n    for await (const event of createDeployment(\n      {\n        token,\n        path: path.resolve(__dirname, 'fixtures', 'nowignore'),\n        skipAutoDetectionConfirmation: true,\n      },\n      {\n        name: 'now-client-tests-v2',\n        projectSettings: {\n          buildCommand: null,\n          devCommand: null,\n          outputDirectory: null,\n        },\n      }\n    )) {\n      if (event.type === 'ready') {\n        deployment = event.payload;\n        break;\n      } else if (event.type === 'error') {\n        error = event.payload;\n        console.error(error.message);\n        break;\n      }\n    }\n\n    expect(error).toBe(null);\n    expect(deployment.readyState).toEqual('READY');\n\n    const index = await fetch_(`https://${deployment.url}`);\n    expect(index.status).toBe(200);\n    expect(await index.text()).toBe('Hello World!');\n\n    const ignore1 = await fetch_(`https://${deployment.url}/ignore.txt`);\n    expect(ignore1.status).toBe(404);\n\n    const ignore2 = await fetch_(`https://${deployment.url}/folder/ignore.txt`);\n    expect(ignore2.status).toBe(404);\n\n    const ignore3 = await fetch_(\n      `https://${deployment.url}/node_modules/ignore.txt`\n    );\n    expect(ignore3.status).toBe(404);\n  });","file":"create-deployment.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will fali with a relative path","suites":["path handling"],"updatePoint":{"line":11,"column":36},"line":11,"code":"  it('will fali with a relative path', async () => {\n    try {\n      await createDeployment(\n        {\n          token,\n          path: './fixtures/v2/now.json',\n        },\n        {\n          name: 'now-client-tests-v2',\n        }\n      );\n    } catch (_error: unknown) {\n      const error = _error as NodeJS.ErrnoException;\n      expect(error.code).toEqual('invalid_path');\n    }\n  });","file":"paths.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"will fali with an array of relative paths","suites":["path handling"],"updatePoint":{"line":28,"column":47},"line":28,"code":"  it('will fali with an array of relative paths', async () => {\n    try {\n      await createDeployment(\n        {\n          token,\n          path: ['./fixtures/v2/now.json'],\n        },\n        {\n          name: 'now-client-tests-v2',\n        }\n      );\n    } catch (_error: unknown) {\n      const error = _error as NodeJS.ErrnoException;\n      expect(error.code).toEqual('invalid_path');\n    }\n  });","file":"paths.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should return 1 second","suites":["getPollingDelay()"],"updatePoint":{"line":4,"column":28},"line":4,"code":"  it('should return 1 second', async () => {\n    expect(getPollingDelay(0)).toBe(1000);\n    expect(getPollingDelay(1000)).toBe(1000);\n    expect(getPollingDelay(3000)).toBe(1000);\n    expect(getPollingDelay(5000)).toBe(1000);\n    expect(getPollingDelay(8000)).toBe(1000);\n    expect(getPollingDelay(9000)).toBe(1000);\n    expect(getPollingDelay(10000)).toBe(1000);\n    expect(getPollingDelay(13000)).toBe(1000);\n    expect(getPollingDelay(15000)).toBe(1000);\n  });","file":"unit.get-polling-delay.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should return 5 second","suites":["getPollingDelay()"],"updatePoint":{"line":16,"column":28},"line":16,"code":"  it('should return 5 second', async () => {\n    expect(getPollingDelay(15001)).toBe(5000);\n    expect(getPollingDelay(16000)).toBe(5000);\n    expect(getPollingDelay(23000)).toBe(5000);\n    expect(getPollingDelay(36000)).toBe(5000);\n    expect(getPollingDelay(59000)).toBe(5000);\n    expect(getPollingDelay(60000)).toBe(5000);\n  });","file":"unit.get-polling-delay.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should return 15 second","suites":["getPollingDelay()"],"updatePoint":{"line":25,"column":29},"line":25,"code":"  it('should return 15 second', async () => {\n    expect(getPollingDelay(60001)).toBe(15000);\n    expect(getPollingDelay(80000)).toBe(15000);\n    expect(getPollingDelay(100000)).toBe(15000);\n    expect(getPollingDelay(200000)).toBe(15000);\n    expect(getPollingDelay(250000)).toBe(15000);\n    expect(getPollingDelay(300000)).toBe(15000);\n  });","file":"unit.get-polling-delay.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should return 30 second","suites":["getPollingDelay()"],"updatePoint":{"line":34,"column":29},"line":34,"code":"  it('should return 30 second', async () => {\n    expect(getPollingDelay(300001)).toBe(30000);\n    expect(getPollingDelay(400000)).toBe(30000);\n    expect(getPollingDelay(1400000)).toBe(30000);\n    expect(getPollingDelay(9400000)).toBe(30000);\n    expect(getPollingDelay(99400000)).toBe(30000);\n  });","file":"unit.get-polling-delay.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should exclude files using `.nowignore` blocklist","suites":["buildFileTree()"],"updatePoint":{"line":19,"column":55},"line":19,"code":"  it('should exclude files using `.nowignore` blocklist', async () => {\n    const cwd = fixture('nowignore');\n    const { fileList, ignoreList } = await buildFileTree(\n      cwd,\n      { isDirectory: true },\n      noop\n    );\n\n    const expectedFileList = toAbsolutePaths(cwd, [\n      '.nowignore',\n      'folder',\n      'index.txt',\n    ]);\n    expect(normalizeWindowsPaths(expectedFileList).sort()).toEqual(\n      normalizeWindowsPaths(fileList).sort()\n    );\n\n    const expectedIgnoreList = [\n      'ignore.txt',\n      'folder/ignore.txt',\n      'node_modules',\n    ];\n    expect(normalizeWindowsPaths(expectedIgnoreList).sort()).toEqual(\n      normalizeWindowsPaths(ignoreList).sort()\n    );\n  });","file":"unit.utils.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should include symlinked files and directories","suites":["buildFileTree()"],"updatePoint":{"line":46,"column":52},"line":46,"code":"  it('should include symlinked files and directories', async () => {\n    const cwd = fixture('symlinks');\n\n    // Also add an empty directory to make sure it's included\n    await fs.mkdirp(join(cwd, 'empty'));\n\n    const { fileList } = await buildFileTree(cwd, { isDirectory: true }, noop);\n\n    const expectedFileList = toAbsolutePaths(cwd, [\n      'empty',\n      'folder-link',\n      'folder/text.txt',\n      'index.txt',\n      'index-link.txt',\n    ]);\n    expect(normalizeWindowsPaths(expectedFileList).sort()).toEqual(\n      normalizeWindowsPaths(fileList).sort()\n    );\n\n    const [folderLinkPath, indexLinkPath] = await Promise.all([\n      fs.lstat(join(cwd, 'folder-link')),\n      fs.lstat(join(cwd, 'index-link.txt')),\n    ]);\n    expect(folderLinkPath.isSymbolicLink());\n    expect(folderLinkPath.isDirectory());\n    expect(indexLinkPath.isSymbolicLink());\n  });","file":"unit.utils.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should include the node_modules using `.vercelignore` allowlist","suites":["buildFileTree()"],"updatePoint":{"line":74,"column":69},"line":74,"code":"  it('should include the node_modules using `.vercelignore` allowlist', async () => {\n    const cwd = fixture('vercelignore-allow-nodemodules');\n    const { fileList, ignoreList } = await buildFileTree(\n      cwd,\n      { isDirectory: true },\n      noop\n    );\n\n    const expected = toAbsolutePaths(cwd, [\n      'node_modules/one.txt',\n      'sub/node_modules/two.txt',\n      'sub/include.txt',\n      '.vercelignore',\n      'hello.txt',\n    ]);\n    expect(normalizeWindowsPaths(expected).sort()).toEqual(\n      normalizeWindowsPaths(fileList).sort()\n    );\n\n    const expectedIgnoreList = ['.env.local', 'exclude.txt'];\n    expect(normalizeWindowsPaths(expectedIgnoreList).sort()).toEqual(\n      normalizeWindowsPaths(ignoreList).sort()\n    );\n  });","file":"unit.utils.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should find root files but ignore `.vercel/output` files when prebuilt=false","suites":["buildFileTree()"],"updatePoint":{"line":99,"column":82},"line":99,"code":"  it('should find root files but ignore `.vercel/output` files when prebuilt=false', async () => {\n    const cwd = fixture('file-system-api');\n    const { fileList, ignoreList } = await buildFileTree(\n      cwd,\n      { isDirectory: true, prebuilt: false },\n      noop\n    );\n\n    const expectedFileList = toAbsolutePaths(cwd, ['foo.txt', 'sub/bar.txt']);\n    expect(normalizeWindowsPaths(expectedFileList).sort()).toEqual(\n      normalizeWindowsPaths(fileList).sort()\n    );\n\n    const expectedIgnoreList = ['.vercel'];\n    expect(normalizeWindowsPaths(expectedIgnoreList).sort()).toEqual(\n      normalizeWindowsPaths(ignoreList).sort()\n    );\n  });","file":"unit.utils.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"should find `.vercel/output` files but ignore other files when prebuilt=true","suites":["buildFileTree()"],"updatePoint":{"line":118,"column":82},"line":118,"code":"  it('should find `.vercel/output` files but ignore other files when prebuilt=true', async () => {\n    const cwd = fixture('file-system-api');\n    const { fileList, ignoreList } = await buildFileTree(\n      cwd,\n      { isDirectory: true, prebuilt: true },\n      noop\n    );\n\n    const expectedFileList = toAbsolutePaths(cwd, [\n      '.vercel/output/static/baz.txt',\n      '.vercel/output/static/sub/qux.txt',\n    ]);\n    expect(normalizeWindowsPaths(expectedFileList).sort()).toEqual(\n      normalizeWindowsPaths(fileList).sort()\n    );\n\n    const expectedIgnoreList = ['foo.txt', 'sub'];\n    expect(normalizeWindowsPaths(expectedIgnoreList).sort()).toEqual(\n      normalizeWindowsPaths(ignoreList).sort()\n    );\n  });","file":"unit.utils.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"Should read `.nowignore`","suites":["Test `getVercelIgnore()`"],"updatePoint":{"line":6,"column":30},"line":6,"code":"  it('Should read `.nowignore`', async () => {\n    const fixture = join(__dirname, 'fixtures', 'nowignore');\n    const { ig } = await getVercelIgnore(fixture);\n    assert.equal(ig.ignores('ignore.txt'), true);\n    assert.equal(ig.ignores('keep.txt'), false);\n  });","file":"vercelignore.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"Should throw an error if `.vercelignore` and `.nowignore` exist","suites":["Test `getVercelIgnore()`"],"updatePoint":{"line":13,"column":69},"line":13,"code":"  it('Should throw an error if `.vercelignore` and `.nowignore` exist', async () => {\n    let err: Error | null = null;\n    const fixture = join(__dirname, 'fixtures', 'vercelignore-and-nowignore');\n    try {\n      await getVercelIgnore(fixture);\n    } catch (_err) {\n      err = _err;\n    }\n    assert(err);\n    assert.equal(\n      err!.message,\n      'Cannot use both a `.vercelignore` and `.nowignore` file. Please delete the `.nowignore` file.'\n    );\n  });","file":"vercelignore.test.ts","skipped":false,"dir":"packages/client/tests"},{"name":"ensure there is an example for every framework","suites":["frameworks"],"updatePoint":{"line":217,"column":52},"line":217,"code":"  it('ensure there is an example for every framework', async () => {\n    const root = join(__dirname, '..', '..', '..');\n    const getExample = (name: string) => join(root, 'examples', name);\n\n    const result = frameworkList\n      .map(f => f.slug)\n      .filter(isString)\n      .filter(f => existsSync(getExample(f)) === false);\n\n    expect(result).toEqual([]);\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure schema","suites":["frameworks"],"updatePoint":{"line":229,"column":19},"line":229,"code":"  it('ensure schema', async () => {\n    const ajv = getValidator();\n\n    const result = ajv.validate(Schema, frameworkList);\n\n    if (ajv.errors) {\n      console.error(ajv.errors);\n    }\n\n    expect(result).toBe(true);\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure logo starts with url prefix","suites":["frameworks"],"updatePoint":{"line":241,"column":40},"line":241,"code":"  it('ensure logo starts with url prefix', async () => {\n    const invalid = frameworkList\n      .map(f => f.logo)\n      .filter(logo => {\n        return logo && !logo.startsWith(logoPrefix);\n      });\n\n    expect(invalid).toEqual([]);\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure darkModeLogo starts with url prefix","suites":["frameworks"],"updatePoint":{"line":251,"column":48},"line":251,"code":"  it('ensure darkModeLogo starts with url prefix', async () => {\n    const invalid = frameworkList\n      .map(f => f.darkModeLogo)\n      .filter(darkModeLogo => {\n        return darkModeLogo && !darkModeLogo.startsWith(logoPrefix);\n      });\n\n    expect(invalid).toEqual([]);\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure logo file exists in ./packages/frameworks/logos/","suites":["frameworks"],"updatePoint":{"line":261,"column":61},"line":261,"code":"  it('ensure logo file exists in ./packages/frameworks/logos/', async () => {\n    const missing = frameworkList\n      .map(f => f.logo)\n      .filter(logo => {\n        const filename = logo.slice(logoPrefix.length);\n        const filepath = join(__dirname, '..', 'logos', filename);\n        return existsSync(filepath) === false;\n      });\n\n    expect(missing).toEqual([]);\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure unique sort number","suites":["frameworks"],"updatePoint":{"line":273,"column":31},"line":273,"code":"  it('ensure unique sort number', async () => {\n    const sortNumToSlug = new Map<number, string | null>();\n    frameworkList.forEach(f => {\n      if (f.sort) {\n        const duplicateSlug = sortNumToSlug.get(f.sort);\n        expect(duplicateSlug).toStrictEqual(undefined);\n        sortNumToSlug.set(f.sort, f.slug);\n      }\n    });\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure unique slug","suites":["frameworks"],"updatePoint":{"line":284,"column":24},"line":284,"code":"  it('ensure unique slug', async () => {\n    const slugs = new Set<string>();\n    for (const { slug } of frameworkList) {\n      if (typeof slug === 'string') {\n        assert(!slugs.has(slug), `Slug \"${slug}\" is not unique`);\n        slugs.add(slug);\n      }\n    }\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"ensure all demo URLs are \"public\"","suites":["frameworks"],"updatePoint":{"line":294,"column":39},"line":294,"code":"  it('ensure all demo URLs are \"public\"', async () => {\n    await Promise.all(\n      frameworkList\n        .filter(f => typeof f.demo === 'string')\n        .map(async f => {\n          const url = new URL(f.demo!);\n          const deployment = await getDeployment(url.hostname);\n          assert.equal(\n            deployment.public,\n            true,\n            `Demo URL ${f.demo} is not \"public\"`\n          );\n        })\n    );\n  });","file":"frameworks.unit.test.ts","skipped":false,"dir":"packages/frameworks/test"},{"name":"should build ","suites":[],"updatePoint":{"line":12,"column":29,"index":412},"line":12,"code":"  it(`should build ${fixture}`, async () => {\n    await expect(testDeployment(path.join(fixturesPath, fixture))).resolves.toBeDefined();\n  });","file":"fixtures.test.js","skipped":false,"dir":"packages/go/test"},{"name":"$title","suites":["middleware matchers"],"line":4,"code":"  it.each([{\n    title: 'has catch-all route whithout matcher',\n    matcher: undefined,\n    regExps: ['^/.*$']\n  }, {\n    title: 'handles / and /index with / matcher',\n    matcher: '/',\n    regExps: ['^\\\\/[\\\\/#\\\\?]?$', '^\\\\/index[\\\\/#\\\\?]?$']\n  }, {\n    title: 'handles as many routes as provided matchers',\n    matcher: ['/about', '/posts'],\n    regExps: ['^\\\\/about[\\\\/#\\\\?]?$', '^\\\\/posts[\\\\/#\\\\?]?$']\n  }, {\n    title: 'handles /index on multiple routes',\n    matcher: ['/about/:slug', '/'],\n    regExps: ['^\\\\/about(?:\\\\/([^\\\\/#\\\\?]+?))[\\\\/#\\\\?]?$', '^\\\\/[\\\\/#\\\\?]?$', '^\\\\/index[\\\\/#\\\\?]?$']\n  }, {\n    title: 'do not duplicates /index if already present',\n    matcher: ['/about/:slug', '/index', '/'],\n    regExps: ['^\\\\/about(?:\\\\/([^\\\\/#\\\\?]+?))[\\\\/#\\\\?]?$', '^\\\\/index[\\\\/#\\\\?]?$', '^\\\\/[\\\\/#\\\\?]?$']\n  }])('$title', async ({\n    matcher,\n    regExps\n  }) => {\n    const filesystem = await prepareFilesystem({\n      'middleware.js': `\n        export default (req) => {\n          return new Response('hooked!', {\n            headers: { 'x-got-middleware': 'true' },\n          });\n        };\n\n        ${matcher ? `export const config = { matcher: ${JSON.stringify(matcher)} };` : ''}\n      `\n    });\n    const buildResult = await build({\n      ...filesystem,\n      entrypoint: 'middleware.js',\n      config: {\n        middleware: true\n      },\n      meta: {\n        skipDownload: true\n      }\n    });\n    expect(buildResult.routes).toEqual([{\n      src: regExps.join('|'),\n      middlewareRawSrc: matcher === undefined ? [] : Array.isArray(matcher) ? matcher : [matcher],\n      middlewarePath: 'middleware.js',\n      continue: true,\n      override: true\n    }]);\n  });","file":"unit/edge-handler/edge-matcher.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"should cache `**/node_modules/**`","suites":["prepareCache()"],"updatePoint":{"line":5,"column":41,"index":173},"line":5,"code":"  test('should cache `**/node_modules/**`', async () => {\n    const files = await prepareCache({\n      files: {},\n      entrypoint: '.',\n      config: {},\n      workPath: path.resolve(__dirname, '../cache-fixtures/'),\n      repoRootPath: path.resolve(__dirname, '../cache-fixtures/')\n    });\n    expect(files['foo/node_modules/file']).toBeDefined();\n    expect(files['node_modules/file']).toBeDefined();\n    expect(files['index.js']).toBeUndefined();\n  });","file":"unit/prepare-cache.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"should ignore root modules","suites":["prepareCache()"],"updatePoint":{"line":17,"column":34,"index":623},"line":17,"code":"  test('should ignore root modules', async () => {\n    const files = await prepareCache({\n      files: {},\n      entrypoint: '.',\n      config: {},\n      workPath: path.resolve(__dirname, '../cache-fixtures/foo/'),\n      repoRootPath: path.resolve(__dirname, '../cache-fixtures/foo/')\n    });\n    const file = files['node_modules/file'];\n    expect(file).toBeDefined();\n    assert(file.type === 'FileFsRef');\n    expect(file.fsPath.includes('cache-fixtures/foo/node_modules/file')).toBeTruthy();\n    expect(files['index.js']).toBeUndefined();\n  });","file":"unit/prepare-cache.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type undefined should return the original string","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":4,"column":64,"index":225},"line":4,"code":"    it('content type undefined should return the original string', () => {\n      const rawBody = 'body content';\n      const body = Buffer.from(rawBody);\n      const result = getBodyParser(body, undefined)();\n      expect(result).toBe(rawBody);\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type \"text/plain\" should return the original string","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":10,"column":67,"index":481},"line":10,"code":"    it('content type \"text/plain\" should return the original string', () => {\n      const rawBody = 'body content';\n      const body = Buffer.from(rawBody);\n      const result = getBodyParser(body, 'text/plain')();\n      expect(result).toBe(rawBody);\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type \"application/octet-stream\" should return the body buffer","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":16,"column":77,"index":750},"line":16,"code":"    it('content type \"application/octet-stream\" should return the body buffer', () => {\n      const rawBody = 'body content';\n      const body = Buffer.from(rawBody);\n      const result = getBodyParser(body, 'application/octet-stream')();\n      expect(result).toBe(body);\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type \"application/x-www-form-urlencoded\" should return the parsed query string","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":22,"column":94,"index":1047},"line":22,"code":"    it('content type \"application/x-www-form-urlencoded\" should return the parsed query string', () => {\n      const rawBody = 'foo=bar&baz=zim';\n      const body = Buffer.from(rawBody);\n      const result = getBodyParser(body, 'application/x-www-form-urlencoded')();\n      expect(result).toEqual({\n        foo: 'bar',\n        baz: 'zim'\n      });\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type \"application/json\" should return the parsed object","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":31,"column":71,"index":1380},"line":31,"code":"    it('content type \"application/json\" should return the parsed object', () => {\n      const rawBody = '{\"foo\": \"bar\", \"baz\": \"zim\"}';\n      const body = Buffer.from(rawBody);\n      const result = getBodyParser(body, 'application/json')();\n      expect(result).toEqual({\n        foo: 'bar',\n        baz: 'zim'\n      });\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"content type \"application/json\" should throw when parsing bad json","suites":["serverless-functions/helpers","getBodyParser"],"updatePoint":{"line":40,"column":74,"index":1712},"line":40,"code":"    it('content type \"application/json\" should throw when parsing bad json', () => {\n      const rawBody = 'not valid json';\n      const body = Buffer.from(rawBody);\n      expect(() => {\n        getBodyParser(body, 'application/json')();\n      }).toThrow('Invalid JSON');\n    });","file":"unit/serverless-functions/helpers.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"entrypoint=\"$entrypoint\" zeroConfig=$zeroConfig -> $expected","suites":["entrypointToOutputPath()"],"line":3,"code":"  test.each([{\n    entrypoint: 'api/foo.js',\n    zeroConfig: false,\n    expected: 'api/foo.js'\n  }, {\n    entrypoint: 'api/foo.ts',\n    zeroConfig: false,\n    expected: 'api/foo.ts'\n  }, {\n    entrypoint: 'api/foo.tsx',\n    zeroConfig: false,\n    expected: 'api/foo.tsx'\n  }, {\n    entrypoint: 'api/foo.js',\n    zeroConfig: true,\n    expected: 'api/foo'\n  }, {\n    entrypoint: 'api/foo.ts',\n    zeroConfig: true,\n    expected: 'api/foo'\n  }, {\n    entrypoint: 'api/foo.tsx',\n    zeroConfig: true,\n    expected: 'api/foo'\n  }])('entrypoint=\"$entrypoint\" zeroConfig=$zeroConfig -> $expected', ({\n    entrypoint,\n    zeroConfig,\n    expected\n  }) => {\n    expect(entrypointToOutputPath(entrypoint, zeroConfig)).toEqual(expected);\n  });","file":"unit/utils.test.ts","skipped":false,"dir":"packages/node/test"},{"name":"should match the probes against Python dev servers","suites":[],"updatePoint":{"line":13,"column":54,"index":422},"line":13,"code":"it('should match the probes against Python dev servers', async () => {\n  const fixture = path.join(fixturesPath, '00-request-path');\n  await execa('pip3', ['install', '--user', '--upgrade', 'setuptools', 'wheel'], {\n    cwd: fixture,\n    stdio: 'inherit'\n  });\n  await execa('pip3', ['install', '--user', '-r', 'requirements.txt'], {\n    cwd: fixture,\n    stdio: 'inherit'\n  });\n  const ports = new Map();\n  ports.set('/api/python.py', 8001);\n  ports.set('/api/wsgi.py', 8002);\n  ports.set('/api/asgi.py', 8003);\n  const {\n    probes\n  } = require(path.join(fixture, 'probes.json'));\n  const pythonServer = spawn('python3', ['api/python.py'], {\n    cwd: fixture,\n    stdio: 'inherit'\n  });\n  const wsgiServer = spawn('python3', ['api/wsgi.py'], {\n    cwd: fixture,\n    stdio: 'inherit'\n  });\n  const asgiServer = spawn('python3', ['api/asgi.py'], {\n    cwd: fixture,\n    stdio: 'inherit'\n  });\n  try {\n    // wait a few seconds for the dev servers to boot-up\n    await new Promise(r => setTimeout(r, 3000));\n    for (const {\n      path,\n      mustContain\n    } of probes) {\n      const port = ports.get(path.substring(0, path.indexOf('?')));\n      const res = await fetch(`http://localhost:${port}${path}`);\n      const body = await res.text();\n      assert(body.includes(mustContain), `Expected to contain \"${mustContain}\" but got \"${body}\"`);\n    }\n  } finally {\n    process.kill(pythonServer.pid);\n    process.kill(wsgiServer.pid);\n    process.kill(asgiServer.pid);\n  }\n});","file":"integration-1.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should fail to build ","suites":[],"updatePoint":{"line":25,"column":41,"index":1108},"line":25,"code":"      it(`should fail to build ${fixture}`, async () => {\n        try {\n          await testDeployment(path.join(fixturesPath, fixture));\n        } catch (err) {\n          expect(err).toBeTruthy();\n          expect(err.deployment).toBeTruthy();\n          expect(err.deployment.errorMessage).toBe(errMsg);\n        }\n      });","file":"integration-setup.js","skipped":false,"dir":"packages/python/test"},{"name":"should build ","suites":[],"updatePoint":{"line":37,"column":31,"index":1512},"line":37,"code":"    it(`should build ${fixture}`, async () => {\n      await expect(testDeployment(path.join(fixturesPath, fixture))).resolves.toBeDefined();\n    });","file":"integration-setup.js","skipped":false,"dir":"packages/python/test"},{"name":"should only match supported versions, otherwise throw an error","suites":[],"updatePoint":{"line":15,"column":66,"index":436},"line":15,"code":"it('should only match supported versions, otherwise throw an error', async () => {\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '3.9'\n  })).toHaveProperty('runtime', 'python3.9');\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should ignore minor version in vercel dev","suites":[],"updatePoint":{"line":20,"column":45,"index":617},"line":20,"code":"it('should ignore minor version in vercel dev', async () => {\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '3.9',\n    isDev: true\n  })).toHaveProperty('runtime', 'python3');\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '3.6',\n    isDev: true\n  })).toHaveProperty('runtime', 'python3');\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '999',\n    isDev: true\n  })).toHaveProperty('runtime', 'python3');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should select latest version when no Piplock detected","suites":[],"updatePoint":{"line":35,"column":57,"index":1130},"line":35,"code":"it('should select latest version when no Piplock detected', async () => {\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: undefined\n  })).toHaveProperty('runtime', 'python3.9');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should select latest version and warn when invalid Piplock detected","suites":[],"updatePoint":{"line":41,"column":71,"index":1386},"line":41,"code":"it('should select latest version and warn when invalid Piplock detected', async () => {\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '999'\n  })).toHaveProperty('runtime', 'python3.9');\n  expect(warningMessages).toStrictEqual(['Warning: Python version \"999\" detected in Pipfile.lock is invalid and will be ignored. http://vercel.link/python-version']);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should throw for discontinued versions","suites":[],"updatePoint":{"line":47,"column":42,"index":1731},"line":47,"code":"it('should throw for discontinued versions', async () => {\n  global.Date.now = () => new Date('2022-07-31').getTime();\n  expect(() => getSupportedPythonVersion({\n    pipLockPythonVersion: '3.6'\n  })).toThrow('Python version \"3.6\" detected in Pipfile.lock is discontinued and must be upgraded.');\n  expect(warningMessages).toStrictEqual([]);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"should warn for deprecated versions, soon to be discontinued","suites":[],"updatePoint":{"line":54,"column":64,"index":2098},"line":54,"code":"it('should warn for deprecated versions, soon to be discontinued', async () => {\n  global.Date.now = () => new Date('2021-07-01').getTime();\n  expect(getSupportedPythonVersion({\n    pipLockPythonVersion: '3.6'\n  })).toHaveProperty('runtime', 'python3.6');\n  expect(warningMessages).toStrictEqual(['Error: Python version \"3.6\" detected in Pipfile.lock has reached End-of-Life. Deployments created on or after 2022-07-18 will fail to build. http://vercel.link/python-version']);\n});","file":"unit.test.ts","skipped":false,"dir":"packages/python/test"},{"name":"appendRoutesToPhase `routes=null` and `newRoutes=[]`","suites":[],"updatePoint":{"line":4,"column":58,"index":186},"line":4,"code":"test('appendRoutesToPhase `routes=null` and `newRoutes=[]`', () => {\n  const routes = null;\n  const newRoutes = [];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase `routes=null` and one `newRoutes`","suites":[],"updatePoint":{"line":16,"column":59,"index":473},"line":16,"code":"test('appendRoutesToPhase `routes=null` and one `newRoutes`', () => {\n  const routes = null;\n  const newRoutes = [{\n    src: '/foo',\n    dest: '/bar'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    handle: 'filesystem'\n  }, ...newRoutes];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase `routes=[]` and `newRoutes=null`","suites":[],"updatePoint":{"line":33,"column":58,"index":842},"line":33,"code":"test('appendRoutesToPhase `routes=[]` and `newRoutes=null`', () => {\n  const routes = [];\n  const newRoutes = null;\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase `routes=[]` and `newRoutes=[]`","suites":[],"updatePoint":{"line":45,"column":56,"index":1126},"line":45,"code":"test('appendRoutesToPhase `routes=[]` and `newRoutes=[]`', () => {\n  const routes = [];\n  const newRoutes = [];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase one routes, zero newRoutes","suites":[],"updatePoint":{"line":57,"column":52,"index":1404},"line":57,"code":"test('appendRoutesToPhase one routes, zero newRoutes', () => {\n  const routes = [{\n    src: '/foo',\n    dest: '/bar'\n  }];\n  const newRoutes = [];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = routes;\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase zero routes, one newRoutes","suites":[],"updatePoint":{"line":72,"column":52,"index":1725},"line":72,"code":"test('appendRoutesToPhase zero routes, one newRoutes', () => {\n  const routes = [];\n  const newRoutes = [{\n    src: '/foo',\n    dest: '/bar'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    handle: 'filesystem'\n  }, ...newRoutes];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase two routes in phase","suites":[],"updatePoint":{"line":89,"column":45,"index":2079},"line":89,"code":"test('appendRoutesToPhase two routes in phase', () => {\n  const routes = [{\n    handle: 'filesystem'\n  }, {\n    src: '/first',\n    dest: '/one'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    handle: 'filesystem'\n  }, {\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase two routes out of phase","suites":[],"updatePoint":{"line":117,"column":49,"index":2578},"line":117,"code":"test('appendRoutesToPhase two routes out of phase', () => {\n  const routes = [{\n    handle: 'resource'\n  }, {\n    src: '/first',\n    dest: '/one'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    handle: 'resource'\n  }, {\n    src: '/first',\n    dest: '/one'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase one routes before, two routes in phase","suites":[],"updatePoint":{"line":147,"column":64,"index":3120},"line":147,"code":"test('appendRoutesToPhase one routes before, two routes in phase', () => {\n  const routes = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase one routes before, two routes in phase, two routes in different phase","suites":[],"updatePoint":{"line":181,"column":95,"index":3753},"line":181,"code":"test('appendRoutesToPhase one routes before, two routes in phase, two routes in different phase', () => {\n  const routes = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    handle: 'miss'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = 'filesystem';\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }, {\n    handle: 'miss'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase to null phase","suites":[],"updatePoint":{"line":225,"column":39,"index":4472},"line":225,"code":"test('appendRoutesToPhase to null phase', () => {\n  const routes = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = null;\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase to null phase with no handle","suites":[],"updatePoint":{"line":265,"column":54,"index":5146},"line":265,"code":"test('appendRoutesToPhase to null phase with no handle', () => {\n  const routes = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = null;\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    src: '/new',\n    dest: '/to'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase to null phase with two new routes ","suites":[],"updatePoint":{"line":295,"column":60,"index":5672},"line":295,"code":"test('appendRoutesToPhase to null phase with two new routes ', () => {\n  const routes = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  const newRoutes = [{\n    src: '/new1',\n    dest: '/to1'\n  }, {\n    src: '/new2',\n    dest: '/to2'\n  }];\n  const phase = null;\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/first',\n    dest: '/one'\n  }, {\n    src: '/second',\n    dest: '/two'\n  }, {\n    src: '/new1',\n    dest: '/to1'\n  }, {\n    src: '/new2',\n    dest: '/to2'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/third',\n    dest: '/three'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"appendRoutesToPhase to null phase `routes=[]`","suites":[],"updatePoint":{"line":341,"column":51,"index":6431},"line":341,"code":"test('appendRoutesToPhase to null phase `routes=[]`', () => {\n  const routes = [];\n  const newRoutes = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  const phase = null;\n  const actual = appendRoutesToPhase({\n    routes,\n    newRoutes,\n    phase\n  });\n  const expected = [{\n    src: '/new',\n    dest: '/to'\n  }];\n  deepEqual(actual, expected);\n});","file":"append.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should return routes null if provided routes is null","suites":["normalizeRoutes"],"updatePoint":{"line":18,"column":60,"index":770},"line":18,"code":"  test('should return routes null if provided routes is null', () => {\n    const actual = normalizeRoutes(null);\n    assert.equal(actual.routes, null);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"accepts valid routes","suites":["normalizeRoutes"],"updatePoint":{"line":22,"column":28,"index":896},"line":22,"code":"  test('accepts valid routes', () => {\n    const routes = [{\n      src: '^(?:/(?<value>en|fr))?(?<path>/.*)$',\n      locale: {\n        // @ts-expect-error `value` is not defined is this a bug or should this prop be added to the type?\n        value: '$value',\n        path: '$path',\n        default: 'en',\n        cookie: 'NEXT_LOCALE'\n      }\n    }, {\n      src: '^/(?:en/?|fr/?)$',\n      locale: {\n        redirect: {\n          en: '/en',\n          fr: '/fr'\n        }\n      }\n    }, {\n      src: '^/about$'\n    }, {\n      src: '^/about$',\n      middleware: 0\n    }, {\n      src: '^/about$',\n      middlewarePath: 'pages/_middleware'\n    }, {\n      src: '^/blog$',\n      methods: ['GET'],\n      headers: {\n        'Cache-Control': 'no-cache'\n      },\n      dest: '/blog'\n    }, {\n      src: '^/.*$',\n      middleware: 0\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '^/(?<slug>[^/]+)$',\n      dest: 'blog?slug=$slug'\n    }, {\n      handle: 'hit'\n    }, {\n      src: '^/hit-me$',\n      headers: {\n        'Cache-Control': 'max-age=20'\n      },\n      continue: true\n    }, {\n      handle: 'miss'\n    }, {\n      src: '^/missed-me$',\n      dest: '/api/missed-me',\n      check: true\n    }, {\n      src: '^/missed-me$',\n      headers: {\n        'Cache-Control': 'max-age=10'\n      },\n      continue: true,\n      important: true\n    }, {\n      handle: 'rewrite'\n    }, {\n      src: '^.*$',\n      dest: '/somewhere'\n    }, {\n      handle: 'error'\n    }, {\n      src: '^.*$',\n      dest: '/404',\n      status: 404\n    }, {\n      src: '^/hello$',\n      dest: '/another',\n      has: [{\n        type: 'header',\n        key: 'x-rewrite'\n      }, {\n        type: 'cookie',\n        key: 'loggedIn',\n        value: 'yup'\n      }, {\n        type: 'query',\n        key: 'authorized',\n        value: 'yup'\n      }, {\n        type: 'host',\n        value: 'vercel.com'\n      }],\n      missing: [{\n        type: 'header',\n        key: 'x-middleware-subrequest',\n        value: 'secret'\n      }]\n    }];\n    assertValid(routes);\n    const normalized = normalizeRoutes(routes);\n    assert.equal(normalized.error, null);\n    assert.deepStrictEqual(normalized.routes, routes);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"normalizes src","suites":["normalizeRoutes"],"updatePoint":{"line":124,"column":22,"index":3059},"line":124,"code":"  test('normalizes src', () => {\n    const expected = '^/about$';\n    const sources = [{\n      src: '/about'\n    }, {\n      src: '/about$'\n    }, {\n      src: '\\\\/about'\n    }, {\n      src: '\\\\/about$'\n    }, {\n      src: '^/about'\n    }, {\n      src: '^/about$'\n    }, {\n      src: '^\\\\/about'\n    }, {\n      src: '^\\\\/about$'\n    }];\n    assertValid(sources);\n    const normalized = normalizeRoutes(sources);\n    assert.equal(normalized.error, null);\n    assert.notEqual(normalized.routes, null);\n    if (normalized.routes) {\n      normalized.routes.forEach(route => {\n        if (isHandler(route)) {\n          assert.fail(`Normalizer returned: { handle: ${route.handle} } instead of { src: ${expected} }`);\n        } else {\n          assert.strictEqual(route.src, expected);\n        }\n      });\n    }\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"returns if null","suites":["normalizeRoutes"],"updatePoint":{"line":157,"column":23,"index":3870},"line":157,"code":"  test('returns if null', () => {\n    const input = null;\n    const {\n      error,\n      routes\n    } = normalizeRoutes(input);\n    assert.strictEqual(error, null);\n    assert.strictEqual(routes, input);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"returns if empty","suites":["normalizeRoutes"],"updatePoint":{"line":166,"column":24,"index":4081},"line":166,"code":"  test('returns if empty', () => {\n    const input = [];\n    const {\n      error,\n      routes\n    } = normalizeRoutes(input);\n    assert.strictEqual(error, null);\n    assert.strictEqual(routes, input);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if route has unknown `handle` value","suites":["normalizeRoutes"],"updatePoint":{"line":175,"column":49,"index":4315},"line":175,"code":"  test('fails if route has unknown `handle` value', () => {\n    // @ts-expect-error - intentionally passing invalid \"handle\"\n    const input = [{\n      handle: 'doesnotexist'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 0 has unknown handle value `handle: doesnotexist`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if route has additional properties with `handle` property","suites":["normalizeRoutes"],"updatePoint":{"line":186,"column":71,"index":4741},"line":186,"code":"  test('fails if route has additional properties with `handle` property', () => {\n    // @ts-expect-error - intentionally passing invalid property\n    const input = [{\n      handle: 'filesystem',\n      illegal: true\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 0 has unknown property `illegal`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if route has a duplicate `handle` value","suites":["normalizeRoutes"],"updatePoint":{"line":198,"column":53,"index":5151},"line":198,"code":"  test('fails if route has a duplicate `handle` value', () => {\n    const input = [{\n      handle: 'filesystem'\n    }, {\n      handle: 'filesystem'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 is a duplicate. Please use one `handle: filesystem` at most.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if route has a invalid regex","suites":["normalizeRoutes"],"updatePoint":{"line":210,"column":42,"index":5529},"line":210,"code":"  test('fails if route has a invalid regex', () => {\n    const input = [{\n      src: '^/(broken]$'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 0 has invalid `src` regular expression \"^/(broken]$\".');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if route does not define `handle` or `src` property","suites":["normalizeRoutes"],"updatePoint":{"line":220,"column":65,"index":5883},"line":220,"code":"  test('fails if route does not define `handle` or `src` property', () => {\n    // @ts-expect-error - intentionally passing invalid property\n    const input = [{\n      fake: 'foo'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 0 must define either `handle` or `src` property.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if over 1024 routes","suites":["normalizeRoutes"],"updatePoint":{"line":231,"column":33,"index":6258},"line":231,"code":"  test('fails if over 1024 routes', () => {\n    assertError('string', [{\n      dataPath: '',\n      keyword: 'type',\n      message: 'should be array',\n      params: {\n        type: 'array'\n      },\n      schemaPath: '#/type'\n    }]);\n    const arr = new Array(1026);\n    arr.fill(true);\n    assertError(arr, [{\n      dataPath: '',\n      keyword: 'maxItems',\n      message: 'should NOT have more than 1024 items',\n      params: {\n        limit: '1024'\n      },\n      schemaPath: '#/maxItems'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails is src is not string","suites":["normalizeRoutes"],"updatePoint":{"line":253,"column":34,"index":6764},"line":253,"code":"  test('fails is src is not string', () => {\n    assertError([{\n      src: false\n    }], [{\n      keyword: 'type',\n      dataPath: '[0].src',\n      schemaPath: '#/items/anyOf/0/properties/src/type',\n      params: {\n        type: 'string'\n      },\n      message: 'should be string'\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'src'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if dest is not string","suites":["normalizeRoutes"],"updatePoint":{"line":280,"column":35,"index":7464},"line":280,"code":"  test('fails if dest is not string', () => {\n    assertError([\n    // @ts-ignore\n    {\n      dest: false\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'dest'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if methods is not array","suites":["normalizeRoutes"],"updatePoint":{"line":309,"column":37,"index":8207},"line":309,"code":"  test('fails if methods is not array', () => {\n    assertError([\n    // @ts-ignore\n    {\n      methods: false\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'methods'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if methods is not string","suites":["normalizeRoutes"],"updatePoint":{"line":338,"column":38,"index":8957},"line":338,"code":"  test('fails if methods is not string', () => {\n    assertError([\n    // @ts-ignore\n    {\n      methods: [false]\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'methods'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if headers is not an object","suites":["normalizeRoutes"],"updatePoint":{"line":367,"column":41,"index":9712},"line":367,"code":"  test('fails if headers is not an object', () => {\n    assertError([\n    // @ts-ignore\n    {\n      headers: false\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'headers'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if header is not a string","suites":["normalizeRoutes"],"updatePoint":{"line":396,"column":39,"index":10463},"line":396,"code":"  test('fails if header is not a string', () => {\n    assertError([\n    // @ts-ignore\n    {\n      headers: {\n        test: false\n      }\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'headers'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if handle is not string","suites":["normalizeRoutes"],"updatePoint":{"line":427,"column":37,"index":11236},"line":427,"code":"  test('fails if handle is not string', () => {\n    assertError([\n    // @ts-ignore\n    {\n      handle: false\n    }], [{\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/additionalProperties',\n      params: {\n        additionalProperty: 'handle'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'type',\n      dataPath: '[0].handle',\n      schemaPath: '#/items/anyOf/1/properties/handle/type',\n      params: {\n        type: 'string'\n      },\n      message: 'should be string'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if continue is not boolean","suites":["normalizeRoutes"],"updatePoint":{"line":456,"column":40,"index":11976},"line":456,"code":"  test('fails if continue is not boolean', () => {\n    assertError([\n    // @ts-ignore\n    {\n      continue: 'false'\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'continue'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if check is not boolean","suites":["normalizeRoutes"],"updatePoint":{"line":485,"column":37,"index":12729},"line":485,"code":"  test('fails if check is not boolean', () => {\n    assertError([\n    // @ts-ignore\n    {\n      check: 'false'\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'check'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if status is not number","suites":["normalizeRoutes"],"updatePoint":{"line":514,"column":37,"index":13476},"line":514,"code":"  test('fails if status is not number', () => {\n    assertError([\n    // @ts-ignore\n    {\n      status: '404'\n    }], [{\n      keyword: 'required',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/required',\n      params: {\n        missingProperty: 'src'\n      },\n      message: \"should have required property 'src'\"\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'status'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if property does not exist","suites":["normalizeRoutes"],"updatePoint":{"line":543,"column":40,"index":14226},"line":543,"code":"  test('fails if property does not exist', () => {\n    assertError([{\n      // @ts-ignore\n      doesNotExist: false\n    }], [{\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/0/additionalProperties',\n      params: {\n        additionalProperty: 'doesNotExist'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'additionalProperties',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf/1/additionalProperties',\n      params: {\n        additionalProperty: 'doesNotExist'\n      },\n      message: 'should NOT have additional properties'\n    }, {\n      keyword: 'anyOf',\n      dataPath: '[0]',\n      schemaPath: '#/items/anyOf',\n      params: {},\n      message: 'should match some schema in anyOf'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if redirects permanent is not a boolean","suites":["normalizeRoutes"],"updatePoint":{"line":571,"column":53,"index":15036},"line":571,"code":"  test('fails if redirects permanent is not a boolean', () => {\n    assertError([{\n      source: '/foo',\n      destination: '/bar',\n      permanent: 301\n    }], [{\n      dataPath: '[0].permanent',\n      keyword: 'type',\n      message: 'should be boolean',\n      params: {\n        type: 'boolean'\n      },\n      schemaPath: '#/items/properties/permanent/type'\n    }], redirectsSchema);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if redirects statusCode is not a number","suites":["normalizeRoutes"],"updatePoint":{"line":586,"column":53,"index":15427},"line":586,"code":"  test('fails if redirects statusCode is not a number', () => {\n    assertError([{\n      source: '/foo',\n      destination: '/bar',\n      statusCode: '301'\n    }], [{\n      dataPath: '[0].statusCode',\n      keyword: 'type',\n      message: 'should be integer',\n      params: {\n        type: 'integer'\n      },\n      schemaPath: '#/items/properties/statusCode/type'\n    }], redirectsSchema);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if routes after `handle: hit` use `dest`","suites":["normalizeRoutes"],"updatePoint":{"line":601,"column":54,"index":15824},"line":601,"code":"  test('fails if routes after `handle: hit` use `dest`', () => {\n    const input = [{\n      handle: 'hit'\n    }, {\n      src: '^/user$',\n      dest: '^/api/user$'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 cannot define `dest` after `handle: hit`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if routes after `handle: hit` do not use `continue: true`","suites":["normalizeRoutes"],"updatePoint":{"line":614,"column":71,"index":16226},"line":614,"code":"  test('fails if routes after `handle: hit` do not use `continue: true`', () => {\n    const input = [{\n      handle: 'hit'\n    }, {\n      src: '^/user$',\n      headers: {\n        'Cache-Control': 'no-cache'\n      }\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 must define `continue: true` after `handle: hit`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if routes after `handle: hit` use `status","suites":["normalizeRoutes"],"updatePoint":{"line":629,"column":55,"index":16655},"line":629,"code":"  test('fails if routes after `handle: hit` use `status', () => {\n    const input = [{\n      handle: 'hit'\n    }, {\n      src: '^/(.*)$',\n      status: 404,\n      continue: true\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 cannot define `status` after `handle: hit`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if routes after `handle: miss` do not use `check: true`","suites":["normalizeRoutes"],"updatePoint":{"line":643,"column":69,"index":17071},"line":643,"code":"  test('fails if routes after `handle: miss` do not use `check: true`', () => {\n    const input = [{\n      handle: 'miss'\n    }, {\n      src: '^/user$',\n      dest: '^/api/user$'\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 must define `check: true` after `handle: miss`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"fails if routes after `handle: miss` do not use `continue: true`","suites":["normalizeRoutes"],"updatePoint":{"line":656,"column":72,"index":17481},"line":656,"code":"  test('fails if routes after `handle: miss` do not use `continue: true`', () => {\n    const input = [{\n      handle: 'miss'\n    }, {\n      src: '^/user$',\n      headers: {\n        'Cache-Control': 'no-cache'\n      }\n    }];\n    const {\n      error\n    } = normalizeRoutes(input);\n    assert.deepEqual(error?.code, 'invalid_route');\n    assert.deepEqual(error?.message, 'Route at index 1 must define `continue: true` after `handle: miss`.');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should normalize vercelConfig.routes","suites":["getTransformedRoutes"],"updatePoint":{"line":673,"column":44,"index":17946},"line":673,"code":"  test('should normalize vercelConfig.routes', () => {\n    const vercelConfig = {\n      routes: [{\n        src: '/page',\n        dest: '/page.html'\n      }]\n    };\n    const actual = getTransformedRoutes(vercelConfig);\n    const expected = normalizeRoutes(vercelConfig.routes);\n    assert.deepEqual(actual, expected);\n    assertValid(actual.routes);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should not error when routes is null and cleanUrls is true","suites":["getTransformedRoutes"],"updatePoint":{"line":685,"column":66,"index":18324},"line":685,"code":"  test('should not error when routes is null and cleanUrls is true', () => {\n    const vercelConfig = {\n      cleanUrls: true,\n      routes: null\n    };\n    // @ts-expect-error intentionally passing invalid `routes: null` here\n    const actual = getTransformedRoutes(vercelConfig);\n    assert.equal(actual.error, null);\n    assertValid(actual.routes);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should not error when has segment is used in destination","suites":["getTransformedRoutes"],"updatePoint":{"line":695,"column":64,"index":18680},"line":695,"code":"  test('should not error when has segment is used in destination', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/redirect',\n        destination: '/:url',\n        has: [{\n          type: 'query',\n          key: 'url',\n          value: '(?<url>.*)'\n        }]\n      }]\n    };\n\n    // @ts-expect-error not sure if this one is an error or not\n    const actual = getTransformedRoutes(vercelConfig);\n    assert.equal(actual.error, null);\n    assertValid(actual.routes);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when routes is defined and cleanUrls is true","suites":["getTransformedRoutes"],"updatePoint":{"line":713,"column":65,"index":19179},"line":713,"code":"  test('should error when routes is defined and cleanUrls is true', () => {\n    const vercelConfig = {\n      cleanUrls: true,\n      routes: [{\n        src: '/page',\n        dest: '/file.html'\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_mixed_routes');\n    assert.equal(error?.message, 'If `rewrites`, `redirects`, `headers`, `cleanUrls` or `trailingSlash` are used, then `routes` cannot be present.');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when redirects is invalid regex","suites":["getTransformedRoutes"],"updatePoint":{"line":730,"column":52,"index":19745},"line":730,"code":"  test('should error when redirects is invalid regex', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '^/(*.)\\\\.html$',\n        destination: '/file.html'\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_redirect');\n    assert.equal(error?.message, 'Redirect at index 0 has invalid `source` regular expression \"^/(*.)\\\\.html$\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when redirects is invalid pattern","suites":["getTransformedRoutes"],"updatePoint":{"line":746,"column":54,"index":20273},"line":746,"code":"  test('should error when redirects is invalid pattern', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/:?',\n        destination: '/file.html'\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_redirect');\n    assert.equal(error?.message, 'Redirect at index 0 has invalid `source` pattern \"/:?\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when redirects defines both permanent and statusCode","suites":["getTransformedRoutes"],"updatePoint":{"line":762,"column":73,"index":20787},"line":762,"code":"  test('should error when redirects defines both permanent and statusCode', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '^/both$',\n        destination: '/api/both',\n        permanent: false,\n        statusCode: 302\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_redirect');\n    assert.equal(error?.message, 'Redirect at index 0 cannot define both `permanent` and `statusCode` properties.');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when headers is invalid regex","suites":["getTransformedRoutes"],"updatePoint":{"line":780,"column":50,"index":21356},"line":780,"code":"  test('should error when headers is invalid regex', () => {\n    const vercelConfig = {\n      headers: [{\n        source: '^/(*.)\\\\.html$',\n        headers: [{\n          key: 'Cache-Control',\n          value: 'public, max-age=0, must-revalidate'\n        }]\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_header');\n    assert.equal(error?.message, 'Header at index 0 has invalid `source` regular expression \"^/(*.)\\\\.html$\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when headers is invalid pattern","suites":["getTransformedRoutes"],"updatePoint":{"line":799,"column":52,"index":21959},"line":799,"code":"  test('should error when headers is invalid pattern', () => {\n    const vercelConfig = {\n      headers: [{\n        source: '/:?',\n        headers: [{\n          key: 'x-hello',\n          value: 'world'\n        }]\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_header');\n    assert.equal(error?.message, 'Header at index 0 has invalid `source` pattern \"/:?\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when rewrites is invalid regex","suites":["getTransformedRoutes"],"updatePoint":{"line":818,"column":51,"index":22493},"line":818,"code":"  test('should error when rewrites is invalid regex', () => {\n    const vercelConfig = {\n      rewrites: [{\n        source: '^/(*.)\\\\.html$',\n        destination: '/file.html'\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_rewrite');\n    assert.equal(error?.message, 'Rewrite at index 0 has invalid `source` regular expression \"^/(*.)\\\\.html$\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when rewrites is invalid pattern","suites":["getTransformedRoutes"],"updatePoint":{"line":834,"column":53,"index":23017},"line":834,"code":"  test('should error when rewrites is invalid pattern', () => {\n    const vercelConfig = {\n      rewrites: [{\n        source: '/:?',\n        destination: '/file.html'\n      }]\n    };\n    const {\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.notEqual(error, null);\n    assert.equal(error?.code, 'invalid_rewrite');\n    assert.equal(error?.message, 'Rewrite at index 0 has invalid `source` pattern \"/:?\".');\n    assert.ok(error?.link);\n    assert.ok(error?.action);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should normalize all redirects before rewrites","suites":["getTransformedRoutes"],"updatePoint":{"line":850,"column":54,"index":23509},"line":850,"code":"  test('should normalize all redirects before rewrites', () => {\n    const vercelConfig = {\n      cleanUrls: true,\n      rewrites: [{\n        source: '/v1',\n        destination: '/v2/api.py'\n      }],\n      redirects: [{\n        source: '/help',\n        destination: '/support',\n        statusCode: 302\n      }, {\n        source: '/bug',\n        destination: 'https://example.com/bug',\n        statusCode: 308\n      }]\n    };\n    const {\n      error,\n      routes\n    } = getTransformedRoutes(vercelConfig);\n    const expected = [{\n      src: '^/(?:(.+)/)?index(?:\\\\.html)?/?$',\n      headers: {\n        Location: '/$1'\n      },\n      status: 308\n    }, {\n      src: '^/(.*)\\\\.html/?$',\n      headers: {\n        Location: '/$1'\n      },\n      status: 308\n    }, {\n      src: '^/help$',\n      headers: {\n        Location: '/support'\n      },\n      status: 302\n    }, {\n      src: '^/bug$',\n      headers: {\n        Location: 'https://example.com/bug'\n      },\n      status: 308\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '^/v1$',\n      dest: '/v2/api.py',\n      check: true\n    }];\n    assert.deepEqual(error, null);\n    assert.deepEqual(routes, expected);\n    assertValid(routes, routesSchema);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should validate schemas","suites":["getTransformedRoutes"],"updatePoint":{"line":906,"column":31,"index":24700},"line":906,"code":"  test('should validate schemas', () => {\n    const vercelConfig = {\n      cleanUrls: true,\n      rewrites: [{\n        source: '/page',\n        destination: '/page.html'\n      }, {\n        source: '/home',\n        destination: '/index.html'\n      }, {\n        source: '/home',\n        destination: '/another',\n        has: [{\n          type: 'header',\n          key: 'x-rewrite'\n        }, {\n          type: 'cookie',\n          key: 'loggedIn',\n          value: 'yup'\n        }, {\n          type: 'query',\n          key: 'authorized',\n          value: 'yup'\n        }, {\n          type: 'host',\n          value: 'vercel.com'\n        }]\n      }],\n      redirects: [{\n        source: '/version1',\n        destination: '/api1.py'\n      }, {\n        source: '/version2',\n        destination: '/api2.py',\n        statusCode: 302\n      }, {\n        source: '/version3',\n        destination: '/api3.py',\n        permanent: true\n      }, {\n        source: '/version4',\n        destination: '/api4.py',\n        has: [{\n          type: 'header',\n          key: 'x-redirect'\n        }, {\n          type: 'cookie',\n          key: 'loggedIn',\n          value: 'yup'\n        }, {\n          type: 'query',\n          key: 'authorized',\n          value: 'yup'\n        }, {\n          type: 'host',\n          value: 'vercel.com'\n        }],\n        permanent: false\n      }],\n      headers: [{\n        source: '/(.*)',\n        headers: [{\n          key: 'Access-Control-Allow-Origin',\n          value: '*'\n        }]\n      }, {\n        source: '/404',\n        headers: [{\n          key: 'Cache-Control',\n          value: 'max-age=300'\n        }, {\n          key: 'Set-Cookie',\n          value: 'error=404'\n        }]\n      }, {\n        source: '/add-header',\n        has: [{\n          type: 'header',\n          key: 'x-header'\n        }, {\n          type: 'cookie',\n          key: 'loggedIn',\n          value: 'yup'\n        }, {\n          type: 'query',\n          key: 'authorized',\n          value: 'yup'\n        }, {\n          type: 'host',\n          value: 'vercel.com'\n        }],\n        headers: [{\n          key: 'Cache-Control',\n          value: 'max-age=forever'\n        }]\n      }],\n      trailingSlashSchema: false\n    };\n    assertValid(vercelConfig.cleanUrls, cleanUrlsSchema);\n    assertValid(vercelConfig.rewrites, rewritesSchema);\n    assertValid(vercelConfig.redirects, redirectsSchema);\n    assertValid(vercelConfig.headers, headersSchema);\n    assertValid(vercelConfig.trailingSlashSchema, trailingSlashSchema);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should return null routes if no transformations are performed","suites":["getTransformedRoutes"],"updatePoint":{"line":1010,"column":69,"index":27256},"line":1010,"code":"  test('should return null routes if no transformations are performed', () => {\n    const vercelConfig = {\n      routes: null\n    };\n    // @ts-expect-error intentionally passing invalid `routes: null`\n    const {\n      routes\n    } = getTransformedRoutes(vercelConfig);\n    assert.equal(routes, null);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when segment is defined in `destination` but not `source`","suites":["getTransformedRoutes"],"updatePoint":{"line":1020,"column":78,"index":27574},"line":1020,"code":"  test('should error when segment is defined in `destination` but not `source`', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/iforgot/:id',\n        destination: '/:another'\n      }]\n    };\n    const {\n      routes,\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.deepEqual(routes, null);\n    assert.ok(error?.message.includes('in `destination` property but not in `source` or `has` property'), error?.message);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when segment is defined in HTTPS `destination` but not `source`","suites":["getTransformedRoutes"],"updatePoint":{"line":1034,"column":84,"index":28044},"line":1034,"code":"  test('should error when segment is defined in HTTPS `destination` but not `source`', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/iforgot/:id',\n        destination: 'https://example.com/:another'\n      }]\n    };\n    const {\n      routes,\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.deepEqual(routes, null);\n    assert.ok(error?.message.includes('in `destination` property but not in `source` or `has` property'), error?.message);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when segment is defined in `destination` query string but not `source`","suites":["getTransformedRoutes"],"updatePoint":{"line":1048,"column":91,"index":28540},"line":1048,"code":"  test('should error when segment is defined in `destination` query string but not `source`', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/iforgot/:id',\n        destination: '/api/login?id=123&name=:name'\n      }]\n    };\n    const {\n      routes,\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.deepEqual(routes, null);\n    assert.ok(error?.message.includes('in `destination` property but not in `source` or `has` property'), error?.message);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should error when segment is defined in HTTPS `destination` query string but not `source`","suites":["getTransformedRoutes"],"updatePoint":{"line":1062,"column":97,"index":29042},"line":1062,"code":"  test('should error when segment is defined in HTTPS `destination` query string but not `source`', () => {\n    const vercelConfig = {\n      redirects: [{\n        source: '/iforgot/:id',\n        destination: 'https://example.com/api/login?id=123&name=:name'\n      }]\n    };\n    const {\n      routes,\n      error\n    } = getTransformedRoutes(vercelConfig);\n    assert.deepEqual(routes, null);\n    assert.ok(error?.message.includes('in `destination` property but not in `source` or `has` property'), error?.message);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should work with content-security-policy header containing URL","suites":["getTransformedRoutes"],"updatePoint":{"line":1076,"column":70,"index":29536},"line":1076,"code":"  test('should work with content-security-policy header containing URL', () => {\n    const vercelConfig = {\n      headers: [{\n        source: '/(.*)',\n        headers: [{\n          key: 'content-security-policy',\n          value: \"default-src 'self'; script-src 'self'; img-src 'self' https://*.example.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*.examplpe.com wss://gateway.example.com; form-action 'self'\"\n        }, {\n          key: 'feature-policy',\n          value: \"accelerometer 'none'; camera 'none'; geolocation 'none'; gyroscope 'none'; magnetometer 'none'; microphone 'none'; payment 'none'; usb 'none'\"\n        }, {\n          key: 'referrer-policy',\n          value: 'strict-origin-when-cross-origin'\n        }, {\n          key: 'strict-transport-security',\n          value: 'max-age=31536000; includesubdomains; preload'\n        }, {\n          key: 'x-content-type-options',\n          value: 'nosniff'\n        }, {\n          key: 'x-frame-options',\n          value: 'sameorigin'\n        }, {\n          key: 'x-xss-protection',\n          value: '1; mode=block'\n        }]\n      }]\n    };\n    const actual = getTransformedRoutes(vercelConfig);\n    assert.deepEqual(actual.routes, [{\n      continue: true,\n      headers: {\n        'content-security-policy': \"default-src 'self'; script-src 'self'; img-src 'self' https://*.example.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*.examplpe.com wss://gateway.example.com; form-action 'self'\",\n        'feature-policy': \"accelerometer 'none'; camera 'none'; geolocation 'none'; gyroscope 'none'; magnetometer 'none'; microphone 'none'; payment 'none'; usb 'none'\",\n        'referrer-policy': 'strict-origin-when-cross-origin',\n        'strict-transport-security': 'max-age=31536000; includesubdomains; preload',\n        'x-content-type-options': 'nosniff',\n        'x-frame-options': 'sameorigin',\n        'x-xss-protection': '1; mode=block'\n      },\n      src: '^(?:/(.*))$'\n    }]);\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes simple","suites":[],"updatePoint":{"line":4,"column":24,"index":156},"line":4,"code":"test('mergeRoutes simple', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      src: '/node2',\n      dest: '/n2'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      src: '/python2',\n      dest: '/py2'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    dest: '/py2',\n    src: '/python2'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes handle filesystem user routes","suites":[],"updatePoint":{"line":58,"column":47,"index":1077},"line":58,"code":"test('mergeRoutes handle filesystem user routes', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      src: '/node2',\n      dest: '/n2'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      src: '/python2',\n      dest: '/py2'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    dest: '/py2',\n    src: '/python2'\n  }, {\n    handle: 'filesystem'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes handle filesystem build routes","suites":[],"updatePoint":{"line":116,"column":48,"index":2063},"line":116,"code":"test('mergeRoutes handle filesystem build routes', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/node2',\n      dest: '/n2'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/python2',\n      dest: '/py2'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    handle: 'filesystem'\n  }, {\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    dest: '/py2',\n    src: '/python2'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes handle filesystem both user and builds","suites":[],"updatePoint":{"line":176,"column":56,"index":3097},"line":176,"code":"test('mergeRoutes handle filesystem both user and builds', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/node2',\n      dest: '/n2'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/python2',\n      dest: '/py2'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    handle: 'filesystem'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    dest: '/py2',\n    src: '/python2'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes continue true","suites":[],"updatePoint":{"line":238,"column":31,"index":4138},"line":238,"code":"test('mergeRoutes continue true', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    src: '/user2',\n    dest: '/u2',\n    continue: true\n  }, {\n    src: '/user3',\n    dest: '/u3'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      src: '/node3',\n      dest: '/n2',\n      continue: true\n    }, {\n      src: '/node3',\n      dest: '/n3'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      src: '/python2',\n      dest: '/py2',\n      continue: true\n    }, {\n      src: '/python3',\n      dest: '/py3'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    continue: true,\n    dest: '/n2',\n    src: '/node3'\n  }, {\n    continue: true,\n    dest: '/py2',\n    src: '/python2'\n  }, {\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    continue: true,\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    dest: '/u3',\n    src: '/user3'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/n3',\n    src: '/node3'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    dest: '/py3',\n    src: '/python3'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes check true","suites":[],"updatePoint":{"line":316,"column":28,"index":5434},"line":316,"code":"test('mergeRoutes check true', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }, {\n    src: '/user3',\n    dest: '/u3'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      src: '/node3',\n      dest: '/n2',\n      check: true\n    }, {\n      src: '/node3',\n      dest: '/n3'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      src: '/python2',\n      dest: '/py2',\n      check: true\n    }, {\n      src: '/python3',\n      dest: '/py3'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    dest: '/u3',\n    src: '/user3'\n  }, {\n    check: true,\n    dest: '/n2',\n    src: '/node3'\n  }, {\n    check: true,\n    dest: '/py2',\n    src: '/python2'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/n3',\n    src: '/node3'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    dest: '/py3',\n    src: '/python3'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes check true, continue true, handle filesystem middle","suites":[],"updatePoint":{"line":392,"column":69,"index":6719},"line":392,"code":"test('mergeRoutes check true, continue true, handle filesystem middle', () => {\n  const userRoutes = [{\n    src: '/user1',\n    dest: '/u1',\n    continue: true\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '/user3',\n    dest: '/u3'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      src: '/node1',\n      dest: '/n1',\n      continue: true\n    }, {\n      src: '/node3',\n      dest: '/n2',\n      check: true\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/node3',\n      dest: '/n3'\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      src: '/python1',\n      dest: '/py1',\n      check: true\n    }, {\n      src: '/python2',\n      dest: '/py2',\n      continue: true\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '/python3',\n      dest: '/py3'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    continue: true,\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    continue: true,\n    dest: '/py2',\n    src: '/python2'\n  }, {\n    continue: true,\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    check: true,\n    dest: '/n2',\n    src: '/node3'\n  }, {\n    check: true,\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    handle: 'filesystem'\n  }, {\n    dest: '/u3',\n    src: '/user3'\n  }, {\n    dest: '/n3',\n    src: '/node3'\n  }, {\n    dest: '/py3',\n    src: '/python3'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes check true, continue true, handle filesystem top","suites":[],"updatePoint":{"line":482,"column":66,"index":8261},"line":482,"code":"test('mergeRoutes check true, continue true, handle filesystem top', () => {\n  const userRoutes = [{\n    handle: 'filesystem'\n  }, {\n    src: '/user1',\n    dest: '/u1'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      handle: 'filesystem'\n    }, {\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      src: '/node2',\n      dest: '/n2',\n      continue: true\n    }, {\n      src: '/node3',\n      dest: '/n3',\n      check: true\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      handle: 'filesystem'\n    }, {\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      src: '/python2',\n      dest: '/py2',\n      check: true\n    }, {\n      src: '/python3',\n      dest: '/py3',\n      continue: true\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    handle: 'filesystem'\n  }, {\n    continue: true,\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    continue: true,\n    dest: '/py3',\n    src: '/python3'\n  }, {\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    check: true,\n    dest: '/n3',\n    src: '/node3'\n  }, {\n    check: true,\n    dest: '/py2',\n    src: '/python2'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes multiple handle values","suites":[],"updatePoint":{"line":558,"column":40,"index":9569},"line":558,"code":"test('mergeRoutes multiple handle values', () => {\n  const userRoutes = [{\n    handle: 'filesystem'\n  }, {\n    src: '/user1',\n    dest: '/u1'\n  }, {\n    handle: 'miss'\n  }, {\n    src: '/user2',\n    dest: '/u2'\n  }, {\n    handle: 'hit'\n  }, {\n    src: '/user3',\n    dest: '/u3'\n  }];\n  const builds = [{\n    use: '@vercel/node',\n    entrypoint: 'api/home.js',\n    routes: [{\n      handle: 'filesystem'\n    }, {\n      src: '/node1',\n      dest: '/n1'\n    }, {\n      handle: 'hit'\n    }, {\n      src: '/node2',\n      dest: '/n2',\n      continue: true\n    }, {\n      handle: 'miss'\n    }, {\n      src: '/node3',\n      dest: '/n3',\n      check: true\n    }]\n  }, {\n    use: '@vercel/python',\n    entrypoint: 'api/users.py',\n    routes: [{\n      handle: 'filesystem'\n    }, {\n      src: '/python1',\n      dest: '/py1'\n    }, {\n      handle: 'hit'\n    }, {\n      src: '/python2',\n      dest: '/py2',\n      check: true\n    }, {\n      handle: 'miss'\n    }, {\n      src: '/python3',\n      dest: '/py3',\n      continue: true\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    handle: 'filesystem'\n  }, {\n    dest: '/u1',\n    src: '/user1'\n  }, {\n    dest: '/n1',\n    src: '/node1'\n  }, {\n    dest: '/py1',\n    src: '/python1'\n  }, {\n    handle: 'miss'\n  }, {\n    continue: true,\n    dest: '/py3',\n    src: '/python3'\n  }, {\n    dest: '/u2',\n    src: '/user2'\n  }, {\n    check: true,\n    dest: '/n3',\n    src: '/node3'\n  }, {\n    handle: 'hit'\n  }, {\n    continue: true,\n    dest: '/n2',\n    src: '/node2'\n  }, {\n    dest: '/u3',\n    src: '/user3'\n  }, {\n    check: true,\n    dest: '/py2',\n    src: '/python2'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes ensure `handle: error` comes last","suites":[],"updatePoint":{"line":662,"column":51,"index":11276},"line":662,"code":"test('mergeRoutes ensure `handle: error` comes last', () => {\n  const userRoutes = [];\n  const builds = [{\n    use: '@vercel/static-build',\n    entrypoint: 'packge.json',\n    routes: [{\n      src: '^/home$',\n      status: 301,\n      headers: {\n        Location: '/'\n      }\n    }]\n  }, {\n    use: '@vercel/zero-config-routes',\n    entrypoint: '/',\n    routes: [{\n      handle: 'error'\n    }, {\n      status: 404,\n      src: '^/(?!.*api).*$',\n      dest: '404.html'\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    status: 301,\n    src: '^/home$',\n    headers: {\n      Location: '/'\n    }\n  }, {\n    handle: 'error'\n  }, {\n    status: 404,\n    src: '^/(?!.*api).*$',\n    dest: '404.html'\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes ensure beforeFiles comes after redirects (continue)","suites":[],"updatePoint":{"line":704,"column":69,"index":12082},"line":704,"code":"test('mergeRoutes ensure beforeFiles comes after redirects (continue)', () => {\n  const userRoutes = [];\n  const builds = [{\n    use: '@vercel/next',\n    entrypoint: 'package.json',\n    routes: [{\n      src: '^/home$',\n      status: 301,\n      headers: {\n        Location: '/'\n      }\n    }, {\n      src: '^/hello$',\n      dest: '/somewhere',\n      continue: true,\n      override: true\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '^/404$',\n      dest: '/404',\n      status: 404,\n      check: true\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    src: '^/home$',\n    status: 301,\n    headers: {\n      Location: '/'\n    }\n  }, {\n    src: '^/hello$',\n    dest: '/somewhere',\n    continue: true,\n    override: true\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '^/404$',\n    dest: '/404',\n    status: 404,\n    check: true\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"mergeRoutes ensure beforeFiles comes after redirects (check)","suites":[],"updatePoint":{"line":754,"column":66,"index":13012},"line":754,"code":"test('mergeRoutes ensure beforeFiles comes after redirects (check)', () => {\n  const userRoutes = [];\n  const builds = [{\n    use: '@vercel/next',\n    entrypoint: 'package.json',\n    routes: [{\n      src: '^/home$',\n      status: 301,\n      headers: {\n        Location: '/'\n      }\n    }, {\n      src: '^/hello$',\n      dest: '/somewhere',\n      check: true,\n      override: true\n    }, {\n      src: '^/.*$',\n      middleware: 0\n    }, {\n      handle: 'filesystem'\n    }, {\n      src: '^/404$',\n      dest: '/404',\n      status: 404,\n      caseSensitive: true,\n      check: true\n    }]\n  }];\n  const actual = mergeRoutes({\n    userRoutes,\n    builds\n  });\n  const expected = [{\n    src: '^/home$',\n    status: 301,\n    headers: {\n      Location: '/'\n    }\n  }, {\n    src: '^/hello$',\n    dest: '/somewhere',\n    check: true,\n    override: true\n  }, {\n    src: '^/.*$',\n    middleware: 0\n  }, {\n    handle: 'filesystem'\n  }, {\n    src: '^/404$',\n    dest: '/404',\n    status: 404,\n    check: true,\n    caseSensitive: true\n  }];\n  deepStrictEqual(actual, expected);\n});","file":"merge.spec.ts","skipped":false,"dir":"packages/routing-utils/test"},{"name":"should fail to build ","suites":[],"updatePoint":{"line":21,"column":39,"index":885},"line":21,"code":"    it(`should fail to build ${fixture}`, async () => {\n      try {\n        await testDeployment(path.join(fixturesPath, fixture));\n      } catch (err) {\n        expect(err).toBeTruthy();\n        expect(err.deployment).toBeTruthy();\n        expect(err.deployment.errorMessage).toBe(errMsg);\n      }\n    });","file":"test.js","skipped":false,"dir":"packages/ruby/test"},{"name":"should build ","suites":[],"updatePoint":{"line":33,"column":29,"index":1265},"line":33,"code":"  it(`should build ${fixture}`, async () => {\n    await expect(testDeployment(path.join(fixturesPath, fixture))).resolves.toBeDefined();\n  });","file":"test.js","skipped":false,"dir":"packages/ruby/test"},{"name":"should parse config from Node.js file","suites":["getConfig()"],"updatePoint":{"line":6,"column":43},"line":6,"code":"  it('should parse config from Node.js file', () => {\n    const project = new Project();\n    const sourcePath = join(__dirname, 'fixtures/node.js');\n    const config = getConfig(project, sourcePath);\n    expect(config).toMatchInlineSnapshot(`\n      {\n        \"maxDuration\": 60,\n        \"memory\": 1024,\n        \"runtime\": \"nodejs\",\n      }\n    `);\n  });","file":"index.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should parse config from Deno file","suites":["getConfig()"],"updatePoint":{"line":19,"column":40},"line":19,"code":"  it('should parse config from Deno file', () => {\n    const project = new Project();\n    const sourcePath = join(__dirname, 'fixtures/deno.ts');\n    const config = getConfig(project, sourcePath, {\n      type: 'object',\n      properties: {\n        location: { type: 'string' },\n      },\n    } as const);\n    expect(config).toMatchInlineSnapshot(`\n      {\n        \"location\": \"https://example.com/page\",\n        \"maxDuration\": 60,\n        \"runtime\": \"deno\",\n      }\n    `);\n  });","file":"index.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should return `null` when no config was exported","suites":["getConfig()"],"updatePoint":{"line":37,"column":54},"line":37,"code":"  it('should return `null` when no config was exported', () => {\n    const project = new Project();\n    const sourcePath = join(__dirname, 'fixtures/no-config.js');\n    const config = getConfig(project, sourcePath);\n    expect(config).toBeNull();\n  });","file":"index.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should throw an error upon schema validation failure","suites":["getConfig()"],"updatePoint":{"line":44,"column":58},"line":44,"code":"  it('should throw an error upon schema validation failure', () => {\n    const project = new Project();\n    const sourcePath = join(__dirname, 'fixtures/invalid-schema.js');\n    let err;\n    try {\n      getConfig(project, sourcePath);\n    } catch (_err) {\n      err = _err;\n    }\n    expect(err.message).toEqual('Invalid data');\n  });","file":"index.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"$input","suites":["extractExportedConstValue for swc","parses successfully"],"line":28,"code":"    test.each(TEST_CASES)('$input', ({ input, identifier, expected }) => {\n      const ast = parse(input);\n      const value = extractExportedConstValue(ast, identifier);\n      expect(value).toStrictEqual(expected);\n    });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"$input","suites":["extractExportedConstValue for swc","fails with UnsupportedValueError"],"line":36,"code":"    test.each(UNSUPPORTED_VALUE_CASES)('$input', ({ input, identifier }) => {\n      const ast = parse(input);\n      expect(() => {\n        extractExportedConstValue(ast, identifier);\n      }).toThrow(UnsupportedValueError);\n    });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"$input","suites":["extractExportedConstValue for swc","returns null if the declaration is not found"],"line":45,"code":"    test.each(NO_SUCH_DECLARATION_CASES)('$input', ({ input, identifier }) => {\n      const ast = parse(input);\n      const value = extractExportedConstValue(ast, identifier);\n      expect(value).toBe(null);\n    });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should parse config from Node.js file","suites":["getConfig for swc"],"updatePoint":{"line":54,"column":43},"line":54,"code":"  it('should parse config from Node.js file', () => {\n    const ast = parseFixture('fixtures/node.js');\n    const config = getConfig(ast, BaseFunctionConfigSchema);\n    expect(config).toMatchInlineSnapshot(`\n      {\n        \"maxDuration\": 60,\n        \"memory\": 1024,\n        \"runtime\": \"nodejs\",\n      }\n    `);\n  });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should parse config from Deno file","suites":["getConfig for swc"],"updatePoint":{"line":66,"column":40},"line":66,"code":"  it('should parse config from Deno file', () => {\n    const ast = parseFixture('fixtures/deno.ts');\n    const config = getConfig(ast, {\n      type: 'object',\n      properties: {\n        location: { type: 'string' },\n      },\n    } as const);\n    expect(config).toMatchInlineSnapshot(`\n      {\n        \"location\": \"https://example.com/page\",\n        \"maxDuration\": 60,\n        \"runtime\": \"deno\",\n      }\n    `);\n  });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should return `null` when no config was exported","suites":["getConfig for swc"],"updatePoint":{"line":83,"column":54},"line":83,"code":"  it('should return `null` when no config was exported', () => {\n    const ast = parseFixture('fixtures/no-config.js');\n    const config = getConfig(ast, BaseFunctionConfigSchema);\n    expect(config).toBeNull();\n  });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"},{"name":"should throw an error upon schema validation failure","suites":["getConfig for swc"],"updatePoint":{"line":89,"column":58},"line":89,"code":"  it('should throw an error upon schema validation failure', () => {\n    const ast = parseFixture('fixtures/invalid-schema.js');\n    let err;\n    try {\n      getConfig(ast, BaseFunctionConfigSchema);\n    } catch (_err) {\n      err = _err;\n    }\n    expect(err.message).toEqual('Invalid data');\n  });","file":"swc.test.ts","skipped":false,"dir":"packages/static-config/test"}]}