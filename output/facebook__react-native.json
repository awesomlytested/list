{
    "repo": "facebook/react-native",
    "url": "https://github.com/facebook/react-native",
    "branch": "main",
    "configs": [
        {
            "package": "hermes-inspector-msggen",
            "lang": "js",
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "HelloWorld",
            "lang": "js",
            "dir": "template/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "parses simple command",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 27
            },
            "line": 8,
            "code": "test('parses simple command', () => {\n  let obj = {\n    'name': 'setBreakpointsActive',\n    'parameters': [{\n      'name': 'active',\n      'type': 'boolean',\n      'description': 'New value for breakpoints active state.'\n    }],\n    'description': 'Activates / deactivates all breakpoints on the page.'\n  };\n  let command = Command.create('Debugger', obj, false);\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpointsActive');\n  expect(command.description).toBe('Activates / deactivates all breakpoints on the page.');\n  expect(command.parameters.map(p => p.name)).toEqual(['active']);\n  expect(command.returns.length).toBe(0);\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpointsActive');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointsActiveRequest');\n  expect(command.getResponseCppType()).toBeUndefined();\n  expect(command.getForwardDecls()).toEqual(['struct SetBreakpointsActiveRequest;']);\n});",
            "file": "CommandTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses command with return",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 32
            },
            "line": 30,
            "code": "test('parses command with return', () => {\n  let obj = {\n    'name': 'setBreakpoint',\n    'parameters': [{\n      'name': 'location',\n      '$ref': 'Location',\n      'description': 'Location to set breakpoint in.'\n    }, {\n      'name': 'condition',\n      'type': 'string',\n      'optional': true,\n      'description': 'Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.'\n    }],\n    'returns': [{\n      'name': 'breakpointId',\n      '$ref': 'BreakpointId',\n      'description': 'Id of the created breakpoint for further reference.'\n    }, {\n      'name': 'actualLocation',\n      '$ref': 'Location',\n      'description': 'Location this breakpoint resolved into.'\n    }],\n    'description': 'Sets JavaScript breakpoint at a given location.'\n  };\n  let command = Command.create('Debugger', obj, false);\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpoint');\n  expect(command.description).toBe('Sets JavaScript breakpoint at a given location.');\n  expect(command.parameters.map(p => p.name)).toEqual(['location', 'condition']);\n  expect(command.returns.map(p => p.name)).toEqual(['breakpointId', 'actualLocation']);\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpoint');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointRequest');\n  expect(command.getResponseCppType()).toBe('SetBreakpointResponse');\n  expect(command.getForwardDecls()).toEqual(['struct SetBreakpointRequest;', 'struct SetBreakpointResponse;']);\n});",
            "file": "CommandTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses simple event",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 25
            },
            "line": 8,
            "code": "test('parses simple event', () => {\n  let obj = {\n    'name': 'resumed',\n    'description': 'Fired when the virtual machine resumed execution.'\n  };\n  let event = Event.create('Debugger', obj, false);\n  expect(event.domain).toBe('Debugger');\n  expect(event.name).toBe('resumed');\n  expect(event.description).toBe('Fired when the virtual machine resumed execution.');\n  expect(event.getDebuggerName()).toBe('Debugger.resumed');\n  expect(event.getCppNamespace()).toBe('debugger');\n  expect(event.getCppType()).toBe('ResumedNotification');\n  expect(event.getForwardDecls()).toEqual(['struct ResumedNotification;']);\n});",
            "file": "EventTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses event with params",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 30
            },
            "line": 22,
            "code": "test('parses event with params', () => {\n  let obj = {\n    'name': 'breakpointResolved',\n    'parameters': [{\n      'name': 'breakpointId',\n      '$ref': 'BreakpointId',\n      'description': 'Breakpoint unique identifier.'\n    }, {\n      'name': 'location',\n      '$ref': 'Location',\n      'description': 'Actual breakpoint location.'\n    }],\n    'description': 'Fired when breakpoint is resolved to an actual script and location.'\n  };\n  let event = Event.create('Debugger', obj, false);\n  expect(event.domain).toBe('Debugger');\n  expect(event.name).toBe('breakpointResolved');\n  expect(event.description).toBe('Fired when breakpoint is resolved to an actual script and location.');\n  expect(event.parameters.map(p => p.name)).toEqual(['breakpointId', 'location']);\n  expect(event.getDebuggerName()).toBe('Debugger.breakpointResolved');\n  expect(event.getCppNamespace()).toBe('debugger');\n  expect(event.getCppType()).toBe('BreakpointResolvedNotification');\n  expect(event.getForwardDecls()).toEqual(['struct BreakpointResolvedNotification;']);\n});",
            "file": "EventTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "detects cycle",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 19
            },
            "line": 31,
            "code": "test('detects cycle', () => {\n  graph.addEdge('C2', 'A1');\n  expect(() => graph.traverse(['A2'])).toThrow(/^Not a DAG/);\n});",
            "file": "GraphTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "checks for presence of root",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 33
            },
            "line": 35,
            "code": "test('checks for presence of root', () => {\n  expect(() => graph.traverse(['A1', 'NX'])).toThrow(/^No node/);\n});",
            "file": "GraphTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "traverses partial graph",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 29
            },
            "line": 38,
            "code": "test('traverses partial graph', () => {\n  let ids = graph.traverse(['B1', 'A3']); // Check that expected nodes are there\n\n  let sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A3', 'B1', 'B2', 'C1', 'C2', 'C3']); // Check that the result is topologically sorted\n\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});",
            "file": "GraphTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "traverses complete graph",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 30
            },
            "line": 51,
            "code": "test('traverses complete graph', () => {\n  let ids = graph.traverse(['A1', 'A2', 'A3']); // Check that expected nodes are there\n\n  let sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A1', 'A2', 'A3', 'B1', 'B2', 'C1', 'C2', 'C3']); // Check that the result is topologically sorted\n\n  expectOccursAfter(ids, 'A1', 'B1');\n  expectOccursAfter(ids, 'A2', 'B1');\n  expectOccursAfter(ids, 'A2', 'B2');\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});",
            "file": "GraphTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits type decl",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 21
            },
            "line": 16,
            "code": "test('emits type decl', () => {\n  let obj = {\n    'id': 'Location',\n    'type': 'object',\n    'properties': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'\n    }, {\n      'name': 'lineNumber',\n      'type': 'integer',\n      'description': 'Line number in the script (0-based).'\n    }, {\n      'name': 'columnNumber',\n      'type': 'integer',\n      'optional': true,\n      'description': 'Column number in the script (0-based).'\n    }],\n    'description': 'Location in the source code.'\n  };\n  let type = Type.create('Debugger', obj);\n  emitTypeDecl(stream, type);\n  expectCodeIsEqual(stream.get(), `\n    struct debugger::Location : public Serializable {\n      Location() = default;\n      explicit Location(const folly::dynamic &obj);\n      folly::dynamic toDynamic() const override;\n\n      runtime::ScriptId scriptId{};\n      int lineNumber{};\n      folly::Optional<int> columnNumber;\n    };\n  `);\n});",
            "file": "HeaderWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits request decl",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 24
            },
            "line": 50,
            "code": "test('emits request decl', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  let command = Command.create('Debugger', obj);\n  emitRequestDecl(stream, command);\n  expectCodeIsEqual(stream.get(), `\n    struct debugger::GetScriptSourceRequest : public Request {\n      GetScriptSourceRequest();\n      explicit GetScriptSourceRequest(const folly::dynamic &obj);\n\n      folly::dynamic toDynamic() const override;\n      void accept(RequestHandler &handler) const override;\n\n      runtime::ScriptId scriptId{};\n    };\n  `);\n});",
            "file": "HeaderWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits response decl",
            "suites": [],
            "updatePoint": {
                "line": 79,
                "column": 25
            },
            "line": 79,
            "code": "test('emits response decl', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  let command = Command.create('Debugger', obj);\n  emitResponseDecl(stream, command);\n  expectCodeIsEqual(stream.get(), `\n    struct debugger::GetScriptSourceResponse : public Response {\n      GetScriptSourceResponse() = default;\n      explicit GetScriptSourceResponse(const folly::dynamic &obj);\n      folly::dynamic toDynamic() const override;\n\n      std::string scriptSource;\n    };\n  `);\n});",
            "file": "HeaderWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits notification decl",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 29
            },
            "line": 106,
            "code": "test('emits notification decl', () => {\n  let obj = {\n    'name': 'messageAdded',\n    'parameters': [{\n      'name': 'message',\n      '$ref': 'ConsoleMessage',\n      'description': 'Console message that has been added.'\n    }],\n    'description': 'Issued when new console message is added.'\n  };\n  let event = Event.create('Console', obj);\n  emitNotificationDecl(stream, event);\n  expectCodeIsEqual(stream.get(), `\n    struct console::MessageAddedNotification : public Notification {\n      MessageAddedNotification();\n      explicit MessageAddedNotification(const folly::dynamic &obj);\n      folly::dynamic toDynamic() const override;\n\n      console::ConsoleMessage message{};\n    };\n  `);\n});",
            "file": "HeaderWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits type def",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 20
            },
            "line": 16,
            "code": "test('emits type def', () => {\n  let obj = {\n    'id': 'Location',\n    'type': 'object',\n    'properties': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'\n    }, {\n      'name': 'lineNumber',\n      'type': 'integer',\n      'description': 'Line number in the script (0-based).'\n    }, {\n      'name': 'columnNumber',\n      'type': 'integer',\n      'optional': true,\n      'description': 'Column number in the script (0-based).'\n    }],\n    'description': 'Location in the source code.'\n  };\n  let type = Type.create('Debugger', obj);\n  emitTypeDef(stream, type);\n  expectCodeIsEqual(stream.get(), `\n    debugger::Location::Location(const dynamic &obj) {\n      assign(scriptId, obj, \"scriptId\");\n      assign(lineNumber, obj, \"lineNumber\");\n      assign(columnNumber, obj, \"columnNumber\");\n    }\n\n    dynamic debugger::Location::toDynamic() const {\n      dynamic obj = dynamic::object;\n      put(obj, \"scriptId\", scriptId);\n      put(obj, \"lineNumber\", lineNumber);\n      put(obj, \"columnNumber\", columnNumber);\n      return obj;\n    }\n  `);\n});",
            "file": "ImplementationWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits request def",
            "suites": [],
            "updatePoint": {
                "line": 54,
                "column": 23
            },
            "line": 54,
            "code": "test('emits request def', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  let command = Command.create('Debugger', obj);\n  emitRequestDef(stream, command);\n  expectCodeIsEqual(stream.get(), `\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest()\n      : Request(\"Debugger.getScriptSource\") {}\n\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest(const dynamic &obj)\n        : Request(\"Debugger.getScriptSource\") {\n      assign(id, obj, \"id\");\n      assign(method, obj, \"method\");\n\n      dynamic params = obj.at(\"params\");\n      assign(scriptId, params, \"scriptId\");\n    }\n\n    dynamic debugger::GetScriptSourceRequest::toDynamic() const {\n      dynamic params = dynamic::object;\n      put(params, \"scriptId\", scriptId);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"id\", id);\n      put(obj, \"method\", method);\n      put(obj, \"params\", std::move(params));\n      return obj;\n    }\n\n    void debugger::GetScriptSourceRequest::accept(RequestHandler &handler) const {\n      handler.handle(*this);\n    }\n  `);\n});",
            "file": "ImplementationWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits response def",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 24
            },
            "line": 100,
            "code": "test('emits response def', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  let command = Command.create('Debugger', obj);\n  emitResponseDef(stream, command);\n  expectCodeIsEqual(stream.get(), `\n    debugger::GetScriptSourceResponse::GetScriptSourceResponse(const dynamic &obj) {\n      assign(id, obj, \"id\");\n\n      dynamic res = obj.at(\"result\");\n      assign(scriptSource, res, \"scriptSource\");\n    }\n\n    dynamic debugger::GetScriptSourceResponse::toDynamic() const {\n      dynamic res = dynamic::object;\n      put(res, \"scriptSource\", scriptSource);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"id\", id);\n      put(obj, \"result\", std::move(res));\n      return obj;\n    }\n  `);\n});",
            "file": "ImplementationWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "emits notification def",
            "suites": [],
            "updatePoint": {
                "line": 136,
                "column": 28
            },
            "line": 136,
            "code": "test('emits notification def', () => {\n  let obj = {\n    'name': 'messageAdded',\n    'parameters': [{\n      'name': 'message',\n      '$ref': 'ConsoleMessage',\n      'description': 'Console message that has been added.'\n    }],\n    'description': 'Issued when new console message is added.'\n  };\n  let event = Event.create('Console', obj);\n  emitNotificationDef(stream, event);\n  expectCodeIsEqual(stream.get(), `\n    console::MessageAddedNotification::MessageAddedNotification()\n        : Notification(\"Console.messageAdded\") {}\n\n    console::MessageAddedNotification::MessageAddedNotification(const dynamic &obj)\n        : Notification(\"Console.messageAdded\") {\n      assign(method, obj, \"method\");\n\n      dynamic params = obj.at(\"params\");\n      assign(message, params, \"message\");\n    }\n\n    dynamic console::MessageAddedNotification::toDynamic() const {\n      dynamic params = dynamic::object;\n      put(params, \"message\", message);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"method\", method);\n      put(obj, \"params\", std::move(params));\n      return obj;\n    }\n  `);\n});",
            "file": "ImplementationWriterTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses required primitive prop",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 36
            },
            "line": 8,
            "code": "test('parses required primitive prop', () => {\n  let obj = {\n    'name': 'lineNumber',\n    'type': 'integer',\n    'description': 'Line number in the script (0-based).'\n  };\n  let prop = Property.create('Debugger', obj);\n  expect(prop.domain).toBe('Debugger');\n  expect(prop.name).toBe('lineNumber');\n  expect(prop.type).toBe('integer');\n  expect(prop.optional).toBeUndefined();\n  expect(prop.description).toBe('Line number in the script (0-based).');\n  expect(prop.getFullCppType()).toBe('int');\n  expect(prop.getCppIdentifier()).toBe('lineNumber');\n  expect(prop.getInitializer()).toBe('{}');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses optional primitive prop",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 36
            },
            "line": 24,
            "code": "test('parses optional primitive prop', () => {\n  let obj = {\n    'name': 'samplingInterval',\n    'type': 'number',\n    'optional': true,\n    'description': 'Average sample interval in bytes.'\n  };\n  let prop = Property.create('HeapProfiler', obj);\n  expect(prop.domain).toBe('HeapProfiler');\n  expect(prop.name).toBe('samplingInterval');\n  expect(prop.type).toBe('number');\n  expect(prop.optional).toBe(true);\n  expect(prop.description).toBe('Average sample interval in bytes.');\n  expect(prop.getFullCppType()).toBe('folly::Optional<double>');\n  expect(prop.getCppIdentifier()).toBe('samplingInterval');\n  expect(prop.getInitializer()).toBe('');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses optional ref prop",
            "suites": [],
            "updatePoint": {
                "line": 41,
                "column": 30
            },
            "line": 41,
            "code": "test('parses optional ref prop', () => {\n  let obj = {\n    'name': 'exceptionDetails',\n    'optional': true,\n    '$ref': 'Runtime.ExceptionDetails',\n    'description': 'Exception details if any.'\n  };\n  let prop = Property.create('Debugger', obj);\n  expect(prop.domain).toBe('Debugger');\n  expect(prop.name).toBe('exceptionDetails');\n  expect(prop.optional).toBe(true);\n  expect(prop.$ref).toBe('Runtime.ExceptionDetails');\n  expect(prop.description).toBe('Exception details if any.');\n  expect(prop.getFullCppType()).toBe('folly::Optional<runtime::ExceptionDetails>');\n  expect(prop.getCppIdentifier()).toBe('exceptionDetails');\n  expect(prop.getInitializer()).toBe('');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses recursive ref prop",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 31
            },
            "line": 58,
            "code": "test('parses recursive ref prop', () => {\n  let obj = {\n    'name': 'parent',\n    '$ref': 'StackTrace',\n    'optional': true,\n    'recursive': true,\n    'description': 'Asynchronous JavaScript stack trace...'\n  };\n  let prop = Property.create('Runtime', obj);\n  expect(prop.domain).toBe('Runtime');\n  expect(prop.name).toBe('parent');\n  expect(prop.optional).toBe(true);\n  expect(prop.recursive).toBe(true);\n  expect(prop.$ref).toBe('StackTrace');\n  expect(prop.description).toBe('Asynchronous JavaScript stack trace...');\n  expect(prop.getFullCppType()).toBe('std::unique_ptr<runtime::StackTrace>');\n  expect(prop.getCppIdentifier()).toBe('parent');\n  expect(prop.getInitializer()).toBe('');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses optional array items prop",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 38
            },
            "line": 77,
            "code": "test('parses optional array items prop', () => {\n  let obj = {\n    'name': 'hitBreakpoints',\n    'type': 'array',\n    'optional': true,\n    'items': {\n      'type': 'string'\n    },\n    'description': 'Hit breakpoints IDs'\n  };\n  let prop = Property.create('Debugger', obj);\n  expect(prop.domain).toBe('Debugger');\n  expect(prop.name).toBe('hitBreakpoints');\n  expect(prop.type).toBe('array');\n  expect(prop.optional).toBe(true);\n  expect(prop.items).toEqual({\n    'type': 'string'\n  });\n  expect(prop.description).toBe('Hit breakpoints IDs');\n  expect(prop.getFullCppType()).toBe('folly::Optional<std::vector<std::string>>');\n  expect(prop.getCppIdentifier()).toBe('hitBreakpoints');\n  expect(prop.getInitializer()).toBe('');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses array ref prop",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 27
            },
            "line": 100,
            "code": "test('parses array ref prop', () => {\n  let obj = {\n    'name': 'domains',\n    'type': 'array',\n    'items': {\n      '$ref': 'Domain'\n    },\n    'description': 'List of supported domains.'\n  };\n  let prop = Property.create('Schema', obj);\n  expect(prop.domain).toBe('Schema');\n  expect(prop.name).toBe('domains');\n  expect(prop.type).toBe('array');\n  expect(prop.items).toEqual({\n    $ref: 'Domain'\n  });\n  expect(prop.description).toBe('List of supported domains.');\n  expect(prop.getFullCppType()).toBe('std::vector<schema::Domain>');\n  expect(prop.getCppIdentifier()).toBe('domains');\n  expect(prop.getInitializer()).toBe('');\n});",
            "file": "PropertyTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses primitive type",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 27
            },
            "line": 8,
            "code": "test('parses primitive type', () => {\n  let obj = {\n    'id': 'Timestamp',\n    'type': 'number',\n    'description': 'Number of milliseconds since epoch.'\n  };\n  let type = Type.create('Runtime', obj, false);\n  expect(type.domain).toBe('Runtime');\n  expect(type.id).toBe('Timestamp');\n  expect(type.type).toBe('number');\n  expect(type.description).toBe('Number of milliseconds since epoch.');\n  expect(type.getCppNamespace()).toBe('runtime');\n  expect(type.getCppType()).toBe('Timestamp');\n  expect(type.getForwardDecls()).toEqual(['using Timestamp = double;']);\n});",
            "file": "TypeTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "parses object type",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 24
            },
            "line": 23,
            "code": "test('parses object type', () => {\n  let obj = {\n    'id': 'Location',\n    'type': 'object',\n    'properties': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'\n    }, {\n      'name': 'lineNumber',\n      'type': 'integer',\n      'description': 'Line number in the script (0-based).'\n    }, {\n      'name': 'columnNumber',\n      'type': 'integer',\n      'optional': true,\n      'description': 'Column number in the script (0-based).'\n    }],\n    'description': 'Location in the source code.'\n  };\n  let type = Type.create('Debugger', obj, false);\n  expect(type.domain).toBe('Debugger');\n  expect(type.id).toBe('Location');\n  expect(type.type).toBe('object');\n  expect(type.properties.map(p => p.name)).toEqual(['scriptId', 'lineNumber', 'columnNumber']);\n  expect(type.description).toBe('Location in the source code.');\n  expect(type.getCppNamespace()).toBe('debugger');\n  expect(type.getCppType()).toBe('Location');\n  expect(type.getForwardDecls()).toEqual(['struct Location;']);\n});",
            "file": "TypeTest.js",
            "skipped": false,
            "dir": "ReactCommon/hermes/inspector/tools/msggen/__tests__"
        },
        {
            "name": "renders correctly",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 21
            },
            "line": 9,
            "code": "it('renders correctly', () => {\n  renderer.create( /*#__PURE__*/React.createElement(App, null));\n});",
            "file": "App-test.js",
            "skipped": false,
            "dir": "template/__tests__"
        }
    ],
    "badge": "facebook__react-native.svg"
}