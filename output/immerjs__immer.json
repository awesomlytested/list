{
    "repo": "immerjs/immer",
    "url": "https://github.com/immerjs/immer",
    "branch": "master",
    "configs": [
        {
            "package": "immer",
            "lang": "ts",
            "dir": "__tests__",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        }
    ],
    "tests": [
        {
            "name": "immer should have no dependencies",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 39
            },
            "line": 21,
            "code": "test(\"immer should have no dependencies\", () => {\n\texpect(require(\"../package.json\").dependencies).toBeUndefined()\n})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns the original state when no changes are made",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 65,
                "column": 57
            },
            "line": 65,
            "code": "\t\tit(\"returns the original state when no changes are made\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\texpect(s.aProp).toBe(\"hi\")\n\t\t\t\texpect(s.anObject.nested).toMatchObject({yummie: true})\n\t\t\t})\n\t\t\texpect(nextState).toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does structural sharing",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 73,
                "column": 29
            },
            "line": 73,
            "code": "\t\tit(\"does structural sharing\", () => {\n\t\t\tconst random = Math.random()\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.aProp = random\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.aProp).toBe(random)\n\t\t\texpect(nextState.nested).toBe(baseState.nested)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "deep change bubbles up",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 83,
                "column": 28
            },
            "line": 83,
            "code": "\t\tit(\"deep change bubbles up\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.anObject.nested.yummie = false\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.anObject).not.toBe(baseState.anObject)\n\t\t\texpect(baseState.anObject.nested.yummie).toBe(true)\n\t\t\texpect(nextState.anObject.nested.yummie).toBe(false)\n\t\t\texpect(nextState.anArray).toBe(baseState.anArray)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can add props",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 94,
                "column": 19
            },
            "line": 94,
            "code": "\t\tit(\"can add props\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.anObject.cookie = {tasty: true}\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.anObject).not.toBe(baseState.anObject)\n\t\t\texpect(nextState.anObject.nested).toBe(baseState.anObject.nested)\n\t\t\texpect(nextState.anObject.cookie).toEqual({tasty: true})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can delete props",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 104,
                "column": 22
            },
            "line": 104,
            "code": "\t\tit(\"can delete props\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\tdelete s.anObject.nested\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.anObject).not.toBe(baseState.anObject)\n\t\t\texpect(nextState.anObject.nested).toBe(undefined)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can delete props added in the producer",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 114,
                "column": 44
            },
            "line": 114,
            "code": "\t\tit(\"can delete props added in the producer\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.anObject.test = true\n\t\t\t\tdelete s.anObject.test\n\t\t\t})\n\t\t\tif (useProxies) {\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState).toEqual(baseState)\n\t\t\t} else {\n\t\t\t\t// The copy is avoided in ES5.\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t}\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can set a property that was just deleted",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 129,
                "column": 46
            },
            "line": 129,
            "code": "\t\tit(\"can set a property that was just deleted\", () => {\n\t\t\tconst baseState = {a: 1}\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\tdelete s.a\n\t\t\t\ts.a = 2\n\t\t\t})\n\t\t\texpect(nextState.a).toBe(2)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can set a property to its original value after deleting it",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 138,
                "column": 64
            },
            "line": 138,
            "code": "\t\tit(\"can set a property to its original value after deleting it\", () => {\n\t\t\tconst baseState = {a: {b: 1}}\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\tconst a = s.a\n\t\t\t\tdelete s.a\n\t\t\t\ts.a = a\n\t\t\t})\n\t\t\tif (useProxies) {\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState).toEqual(baseState)\n\t\t\t} else {\n\t\t\t\t// The copy is avoided in ES5.\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t}\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can get property descriptors",
            "suites": [
                "base functionality - "
            ],
            "updatePoint": {
                "line": 154,
                "column": 34
            },
            "line": 154,
            "code": "\t\tit(\"can get property descriptors\", () => {\n\t\t\tconst getDescriptor = Object.getOwnPropertyDescriptor\n\t\t\tconst baseState = deepFreeze([{a: 1}])\n\t\t\tproduce(baseState, arr => {\n\t\t\t\tconst obj = arr[0]\n\t\t\t\tconst desc = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\t...(useProxies && {writable: true})\n\t\t\t\t}\n\n\t\t\t\t// Known property\n\t\t\t\texpect(getDescriptor(obj, \"a\")).toMatchObject(desc)\n\t\t\t\texpect(getDescriptor(arr, 0)).toMatchObject(desc)\n\n\t\t\t\t// Deleted property\n\t\t\t\tdelete obj.a\n\t\t\t\tarr.pop()\n\t\t\t\texpect(getDescriptor(obj, \"a\")).toBeUndefined()\n\t\t\t\texpect(getDescriptor(arr, 0)).toBeUndefined()\n\n\t\t\t\t// Unknown property\n\t\t\t\texpect(getDescriptor(obj, \"b\")).toBeUndefined()\n\t\t\t\texpect(getDescriptor(arr, 100)).toBeUndefined()\n\n\t\t\t\t// Added property\n\t\t\t\tobj.b = 2\n\t\t\t\tarr[100] = 1\n\t\t\t\texpect(getDescriptor(obj, \"b\")).toBeDefined()\n\t\t\t\texpect(getDescriptor(arr, 100)).toBeDefined()\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports Array.isArray()",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 188,
                "column": 31
            },
            "line": 188,
            "code": "\t\t\tit(\"supports Array.isArray()\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(Array.isArray(s.anArray)).toBeTruthy()\n\t\t\t\t\ts.anArray.push(1)\n\t\t\t\t})\n\t\t\t\texpect(Array.isArray(nextState.anArray)).toBeTruthy()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports index access",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 196,
                "column": 28
            },
            "line": 196,
            "code": "\t\t\tit(\"supports index access\", () => {\n\t\t\t\tconst value = baseState.anArray[0]\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.anArray[0]).toBe(value)\n\t\t\t\t})\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports iteration",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 204,
                "column": 25
            },
            "line": 204,
            "code": "\t\t\tit(\"supports iteration\", () => {\n\t\t\t\tconst base = [\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t]\n\t\t\t\tconst findById = (collection, id) => {\n\t\t\t\t\tfor (const item of collection) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result[0].a).toEqual(2)\n\t\t\t\texpect(result[1].a).toEqual(2)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign an index via bracket notation",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 225,
                "column": 47
            },
            "line": 225,
            "code": "\t\t\tit(\"can assign an index via bracket notation\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.anArray[3] = true\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.anArray).not.toBe(baseState.anArray)\n\t\t\t\texpect(nextState.anArray[3]).toEqual(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use splice() to both add and remove items",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 234,
                "column": 52
            },
            "line": 234,
            "code": "\t\t\tit(\"can use splice() to both add and remove items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.anArray.splice(1, 1, \"a\", \"b\")\n\t\t\t\t})\n\t\t\t\texpect(nextState.anArray).not.toBe(baseState.anArray)\n\t\t\t\texpect(nextState.anArray[1]).toBe(\"a\")\n\t\t\t\texpect(nextState.anArray[2]).toBe(\"b\")\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can truncate via the length property",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 243,
                "column": 43
            },
            "line": 243,
            "code": "\t\t\tit(\"can truncate via the length property\", () => {\n\t\t\t\tconst baseLength = baseState.anArray.length\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.anArray.length = baseLength - 1\n\t\t\t\t})\n\t\t\t\texpect(nextState.anArray).not.toBe(baseState.anArray)\n\t\t\t\texpect(nextState.anArray.length).toBe(baseLength - 1)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can extend via the length property",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 252,
                "column": 41
            },
            "line": 252,
            "code": "\t\t\tit(\"can extend via the length property\", () => {\n\t\t\t\tconst baseLength = baseState.anArray.length\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.anArray.length = baseLength + 1\n\t\t\t\t})\n\t\t\t\texpect(nextState.anArray).not.toBe(baseState.anArray)\n\t\t\t\texpect(nextState.anArray.length).toBe(baseLength + 1)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can pop then push",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 262,
                "column": 24
            },
            "line": 262,
            "code": "\t\t\tit(\"can pop then push\", () => {\n\t\t\t\tconst nextState = produce([1, 2, 3], s => {\n\t\t\t\t\ts.pop()\n\t\t\t\t\ts.push(100)\n\t\t\t\t})\n\t\t\t\texpect(nextState).toEqual([1, 2, 100])\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can be sorted",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 270,
                "column": 20
            },
            "line": 270,
            "code": "\t\t\tit(\"can be sorted\", () => {\n\t\t\t\tconst baseState = [3, 1, 2]\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.sort()\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState).toEqual([1, 2, 3])\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports modifying nested objects",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 279,
                "column": 40
            },
            "line": 279,
            "code": "\t\t\tit(\"supports modifying nested objects\", () => {\n\t\t\t\tconst baseState = [{a: 1}, {}]\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts[0].a++\n\t\t\t\t\ts[1].a = 0\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState[0].a).toBe(2)\n\t\t\t\texpect(nextState[1].a).toBe(0)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never preserves non-numeric properties",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 290,
                "column": 45
            },
            "line": 290,
            "code": "\t\t\tit(\"never preserves non-numeric properties\", () => {\n\t\t\t\tconst baseState = []\n\t\t\t\tbaseState.x = 7\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.push(3)\n\t\t\t\t})\n\t\t\t\texpect(\"x\" in nextState).toBeFalsy()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when a non-numeric property is added",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 300,
                "column": 51
            },
            "line": 300,
            "code": "\t\t\t\tit(\"throws when a non-numeric property is added\", () => {\n\t\t\t\t\texpect(() => {\n\t\t\t\t\t\tproduce([], d => {\n\t\t\t\t\t\t\td.x = 3\n\t\t\t\t\t\t})\n\t\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when a non-numeric property is deleted",
            "suites": [
                "base functionality - ",
                "array drafts"
            ],
            "updatePoint": {
                "line": 308,
                "column": 53
            },
            "line": 308,
            "code": "\t\t\t\tit(\"throws when a non-numeric property is deleted\", () => {\n\t\t\t\t\texpect(() => {\n\t\t\t\t\t\tconst baseState = []\n\t\t\t\t\t\tbaseState.x = 7\n\t\t\t\t\t\tproduce(baseState, d => {\n\t\t\t\t\t\t\tdelete d.x\n\t\t\t\t\t\t})\n\t\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports key access",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 321,
                "column": 26
            },
            "line": 321,
            "code": "\t\t\tit(\"supports key access\", () => {\n\t\t\t\tconst value = baseState.aMap.get(\"jedi\")\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aMap.get(\"jedi\")).toEqual(value)\n\t\t\t\t})\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports key access for non-primitive keys",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 329,
                "column": 49
            },
            "line": 329,
            "code": "\t\t\tit(\"supports key access for non-primitive keys\", () => {\n\t\t\t\tconst key = {prop: \"val\"}\n\t\t\t\tconst base = new Map([[key, {id: 1, a: 1}]])\n\t\t\t\tconst value = base.get(key)\n\t\t\t\tconst nextState = produce(base, s => {\n\t\t\t\t\texpect(s.get(key)).toEqual(value)\n\t\t\t\t})\n\t\t\t\texpect(nextState).toBe(base)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports iteration",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 339,
                "column": 25
            },
            "line": 339,
            "code": "\t\t\tit(\"supports iteration\", () => {\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", {id: 1, a: 1}],\n\t\t\t\t\t[\"second\", {id: 2, a: 1}]\n\t\t\t\t])\n\t\t\t\tconst findById = (map, id) => {\n\t\t\t\t\tfor (const [, item] of map) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.get(\"first\").a).toEqual(2)\n\t\t\t\texpect(result.get(\"second\").a).toEqual(2)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'entries'",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 361,
                "column": 25
            },
            "line": 361,
            "code": "\t\t\tit(\"supports 'entries'\", () => {\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", {id: 1, a: 1}],\n\t\t\t\t\t[\"second\", {id: 2, a: 1}]\n\t\t\t\t])\n\t\t\t\tconst findById = (map, id) => {\n\t\t\t\t\tfor (const [, item] of map.entries()) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.get(\"first\").a).toEqual(2)\n\t\t\t\texpect(result.get(\"second\").a).toEqual(2)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'values'",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 383,
                "column": 24
            },
            "line": 383,
            "code": "\t\t\tit(\"supports 'values'\", () => {\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", {id: 1, a: 1}],\n\t\t\t\t\t[\"second\", {id: 2, a: 1}]\n\t\t\t\t])\n\t\t\t\tconst findById = (map, id) => {\n\t\t\t\t\tfor (const item of map.values()) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.get(\"first\").a).toEqual(2)\n\t\t\t\texpect(result.get(\"second\").a).toEqual(2)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'keys",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 405,
                "column": 21
            },
            "line": 405,
            "code": "\t\t\tit(\"supports 'keys\", () => {\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", Symbol()],\n\t\t\t\t\t[\"second\", Symbol()]\n\t\t\t\t])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\texpect([...draft.keys()]).toEqual([\"first\", \"second\"])\n\t\t\t\t\tdraft.set(\"third\", Symbol())\n\t\t\t\t\texpect([...draft.keys()]).toEqual([\"first\", \"second\", \"third\"])\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports forEach",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 417,
                "column": 23
            },
            "line": 417,
            "code": "\t\t\tit(\"supports forEach\", () => {\n\t\t\t\tconst key1 = {prop: \"val1\"}\n\t\t\t\tconst key2 = {prop: \"val2\"}\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", {id: 1, a: 1}],\n\t\t\t\t\t[\"second\", {id: 2, a: 1}],\n\t\t\t\t\t[key1, {id: 3, a: 1}],\n\t\t\t\t\t[key2, {id: 4, a: 1}]\n\t\t\t\t])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tlet sum1 = 0\n\t\t\t\t\tdraft.forEach(({a}) => {\n\t\t\t\t\t\tsum1 += a\n\t\t\t\t\t})\n\t\t\t\t\texpect(sum1).toBe(4)\n\t\t\t\t\tlet sum2 = 0\n\t\t\t\t\tdraft.get(\"first\").a = 10\n\t\t\t\t\tdraft.get(\"second\").a = 20\n\t\t\t\t\tdraft.get(key1).a = 30\n\t\t\t\t\tdraft.get(key2).a = 40\n\t\t\t\t\tdraft.forEach(({a}) => {\n\t\t\t\t\t\tsum2 += a\n\t\t\t\t\t})\n\t\t\t\t\texpect(sum2).toBe(100)\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base.get(\"first\").a).toEqual(1)\n\t\t\t\texpect(base.get(\"second\").a).toEqual(1)\n\t\t\t\texpect(base.get(key1).a).toEqual(1)\n\t\t\t\texpect(base.get(key2).a).toEqual(1)\n\t\t\t\texpect(result.get(\"first\").a).toEqual(10)\n\t\t\t\texpect(result.get(\"second\").a).toEqual(20)\n\t\t\t\texpect(result.get(key1).a).toEqual(30)\n\t\t\t\texpect(result.get(key2).a).toEqual(40)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports forEach mutation",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 453,
                "column": 32
            },
            "line": 453,
            "code": "\t\t\tit(\"supports forEach mutation\", () => {\n\t\t\t\tconst base = new Map([\n\t\t\t\t\t[\"first\", {id: 1, a: 1}],\n\t\t\t\t\t[\"second\", {id: 2, a: 1}]\n\t\t\t\t])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tdraft.forEach(item => {\n\t\t\t\t\t\titem.a = 100\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.get(\"first\").a).toEqual(100)\n\t\t\t\texpect(result.get(\"second\").a).toEqual(100)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign by key",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 468,
                "column": 24
            },
            "line": 468,
            "code": "\t\t\tit(\"can assign by key\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\t// Map.prototype.set should return the Map itself\n\t\t\t\t\tconst res = s.aMap.set(\"force\", true)\n\t\t\t\t\tif (!global.USES_BUILD) expect(res).toBe(s.aMap[DRAFT_STATE].draft_)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\t\t\texpect(nextState.aMap.get(\"force\")).toEqual(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign by a non-primitive key",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 479,
                "column": 40
            },
            "line": 479,
            "code": "\t\t\tit(\"can assign by a non-primitive key\", () => {\n\t\t\t\tconst key = {prop: \"val\"}\n\t\t\t\tconst value = {id: 1, a: 1}\n\t\t\t\tconst base = new Map([[key, value]])\n\t\t\t\tconst nextState = produce(base, s => {\n\t\t\t\t\ts.set(key, true)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(base)\n\t\t\t\texpect(base.get(key)).toEqual(value)\n\t\t\t\texpect(nextState.get(key)).toEqual(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "state stays the same if the the same item is assigned by key",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 491,
                "column": 67
            },
            "line": 491,
            "code": "\t\t\tit(\"state stays the same if the the same item is assigned by key\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.aMap.set(\"jediTotal\", 42)\n\t\t\t\t})\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t\texpect(nextState.aMap).toBe(baseState.aMap)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns 'size'",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 499,
                "column": 21
            },
            "line": 499,
            "code": "\t\t\tit(\"returns 'size'\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.aMap.set(\"newKey\", true)\n\t\t\t\t\texpect(s.aMap.size).toBe(baseState.aMap.size + 1)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\t\t\texpect(nextState.aMap.get(\"newKey\")).toEqual(true)\n\t\t\t\texpect(nextState.aMap.size).toEqual(baseState.aMap.size + 1)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use 'delete' to remove items",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 510,
                "column": 39
            },
            "line": 510,
            "code": "\t\t\tit(\"can use 'delete' to remove items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aMap.has(\"jedi\")).toBe(true)\n\t\t\t\t\texpect(s.aMap.delete(\"jedi\")).toBe(true)\n\t\t\t\t\texpect(s.aMap.has(\"jedi\")).toBe(false)\n\t\t\t\t})\n\t\t\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\t\t\texpect(nextState.aMap.size).toBe(baseState.aMap.size - 1)\n\t\t\t\texpect(baseState.aMap.has(\"jedi\")).toBe(true)\n\t\t\t\texpect(nextState.aMap.has(\"jedi\")).toBe(false)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use 'clear' to remove items",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 522,
                "column": 38
            },
            "line": 522,
            "code": "\t\t\tit(\"can use 'clear' to remove items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aMap.size).not.toBe(0)\n\t\t\t\t\ts.aMap.clear()\n\t\t\t\t\texpect(s.aMap.size).toBe(0)\n\t\t\t\t})\n\t\t\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\t\t\texpect(baseState.aMap.size).not.toBe(0)\n\t\t\t\texpect(nextState.aMap.size).toBe(0)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "support 'has'",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 533,
                "column": 20
            },
            "line": 533,
            "code": "\t\t\tit(\"support 'has'\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aMap.has(\"newKey\")).toBe(false)\n\t\t\t\t\ts.aMap.set(\"newKey\", true)\n\t\t\t\t\texpect(s.aMap.has(\"newKey\")).toBe(true)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\t\t\texpect(baseState.aMap.has(\"newKey\")).toBe(false)\n\t\t\t\texpect(nextState.aMap.has(\"newKey\")).toBe(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports nested maps",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 545,
                "column": 27
            },
            "line": 545,
            "code": "\t\t\tit(\"supports nested maps\", () => {\n\t\t\t\tconst base = new Map([[\"first\", new Map([[\"second\", {prop: \"test\"}]])]])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tdraft.get(\"first\").get(\"second\").prop = \"test1\"\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.get(\"first\")).not.toBe(base.get(\"first\"))\n\t\t\t\texpect(result.get(\"first\").get(\"second\")).not.toBe(\n\t\t\t\t\tbase.get(\"first\").get(\"second\")\n\t\t\t\t)\n\t\t\t\texpect(base.get(\"first\").get(\"second\").prop).toBe(\"test\")\n\t\t\t\texpect(result.get(\"first\").get(\"second\").prop).toBe(\"test1\")\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "treats void deletes as no-op",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 559,
                "column": 35
            },
            "line": 559,
            "code": "\t\t\tit(\"treats void deletes as no-op\", () => {\n\t\t\t\tconst base = new Map([[\"x\", 1]])\n\t\t\t\tconst next = produce(base, d => {\n\t\t\t\t\texpect(d.delete(\"y\")).toBe(false)\n\t\t\t\t})\n\t\t\t\texpect(next).toBe(base)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "revokes map proxies",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 567,
                "column": 26
            },
            "line": 567,
            "code": "\t\t\tit(\"revokes map proxies\", () => {\n\t\t\t\tlet m\n\t\t\t\tproduce(baseState, s => {\n\t\t\t\t\tm = s.aMap\n\t\t\t\t})\n\t\t\t\texpect(() => m.get(\"x\")).toThrowErrorMatchingSnapshot()\n\t\t\t\texpect(() => m.set(\"x\", 3)).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not draft map keys",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 576,
                "column": 30
            },
            "line": 576,
            "code": "\t\t\tit(\"does not draft map keys\", () => {\n\t\t\t\t// anything else would be terribly confusing\n\t\t\t\tconst key = {a: 1}\n\t\t\t\tconst map = new Map([[key, 2]])\n\t\t\t\tconst next = produce(map, d => {\n\t\t\t\t\tconst dKey = Array.from(d.keys())[0]\n\t\t\t\t\texpect(isDraft(dKey)).toBe(false)\n\t\t\t\t\texpect(dKey).toBe(key)\n\t\t\t\t\tdKey.a += 1\n\t\t\t\t\td.set(dKey, d.get(dKey) + 1)\n\t\t\t\t\td.set(key, d.get(key) + 1)\n\t\t\t\t\texpect(d.get(key)).toBe(4)\n\t\t\t\t\texpect(key.a).toBe(2)\n\t\t\t\t})\n\t\t\t\tconst entries = Array.from(next.entries())\n\t\t\t\texpect(entries).toEqual([[key, 4]])\n\t\t\t\texpect(entries[0][0]).toBe(key)\n\t\t\t\texpect(entries[0][0].a).toBe(2)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does support instanceof Map",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 596,
                "column": 34
            },
            "line": 596,
            "code": "\t\t\tit(\"does support instanceof Map\", () => {\n\t\t\t\tconst map = new Map()\n\t\t\t\tproduce(map, d => {\n\t\t\t\t\texpect(d instanceof Map).toBeTruthy()\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "handles clear correctly",
            "suites": [
                "base functionality - ",
                "map drafts"
            ],
            "updatePoint": {
                "line": 603,
                "column": 30
            },
            "line": 603,
            "code": "\t\t\tit(\"handles clear correctly\", () => {\n\t\t\t\tconst map = new Map([\n\t\t\t\t\t[\"a\", 1],\n\t\t\t\t\t[\"c\", 3]\n\t\t\t\t])\n\t\t\t\tconst next = produce(map, draft => {\n\t\t\t\t\tdraft.delete(\"a\")\n\t\t\t\t\tdraft.set(\"b\", 2)\n\t\t\t\t\tdraft.set(\"c\", 4)\n\t\t\t\t\tdraft.clear()\n\t\t\t\t})\n\t\t\t\texpect(next).toEqual(new Map())\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports iteration",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 619,
                "column": 25
            },
            "line": 619,
            "code": "\t\t\tit(\"supports iteration\", () => {\n\t\t\t\tconst base = new Set([\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t])\n\t\t\t\tconst findById = (set, id) => {\n\t\t\t\t\tfor (const item of set) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t\texpect(result).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 2},\n\t\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'entries'",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 651,
                "column": 25
            },
            "line": 651,
            "code": "\t\t\tit(\"supports 'entries'\", () => {\n\t\t\t\tconst base = new Set([\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t])\n\t\t\t\tconst findById = (set, id) => {\n\t\t\t\t\tfor (const [item1, item2] of set.entries()) {\n\t\t\t\t\t\texpect(item1).toBe(item2)\n\t\t\t\t\t\tif (item1.id === id) return item1\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t\texpect(result).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 2},\n\t\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'values'",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 684,
                "column": 24
            },
            "line": 684,
            "code": "\t\t\tit(\"supports 'values'\", () => {\n\t\t\t\tconst base = new Set([\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t])\n\t\t\t\tconst findById = (set, id) => {\n\t\t\t\t\tfor (const item of set.values()) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t\texpect(result).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 2},\n\t\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'keys'",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 716,
                "column": 22
            },
            "line": 716,
            "code": "\t\t\tit(\"supports 'keys'\", () => {\n\t\t\t\tconst base = new Set([\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t])\n\t\t\t\tconst findById = (set, id) => {\n\t\t\t\t\tfor (const item of set.keys()) {\n\t\t\t\t\t\tif (item.id === id) return item\n\t\t\t\t\t}\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tconst obj1 = findById(draft, 1)\n\t\t\t\t\tconst obj2 = findById(draft, 2)\n\t\t\t\t\tobj1.a = 2\n\t\t\t\t\tobj2.a = 2\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t\t{id: 2, a: 1}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t\texpect(result).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 2},\n\t\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports forEach with mutation after reads",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 748,
                "column": 49
            },
            "line": 748,
            "code": "\t\t\tit(\"supports forEach with mutation after reads\", () => {\n\t\t\t\tconst base = new Set([\n\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tlet sum1 = 0\n\t\t\t\t\tdraft.forEach(({a}) => {\n\t\t\t\t\t\tsum1 += a\n\t\t\t\t\t})\n\t\t\t\t\texpect(sum1).toBe(3)\n\t\t\t\t\tlet sum2 = 0\n\t\t\t\t\tdraft.forEach(item => {\n\t\t\t\t\t\titem.a += 10\n\t\t\t\t\t\tsum2 += item.a\n\t\t\t\t\t})\n\t\t\t\t\texpect(sum2).toBe(23)\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 1},\n\t\t\t\t\t\t{id: 2, a: 2}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t\texpect(result).toEqual(\n\t\t\t\t\tnew Set([\n\t\t\t\t\t\t{id: 1, a: 11},\n\t\t\t\t\t\t{id: 2, a: 12}\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "state stays the same if the same item is added",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 781,
                "column": 53
            },
            "line": 781,
            "code": "\t\t\tit(\"state stays the same if the same item is added\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.aSet.add(\"Luke\")\n\t\t\t\t})\n\t\t\t\texpect(nextState).toBe(baseState)\n\t\t\t\texpect(nextState.aSet).toBe(baseState.aSet)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can add new items",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 789,
                "column": 24
            },
            "line": 789,
            "code": "\t\t\tit(\"can add new items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\t// Set.prototype.set should return the Set itself\n\t\t\t\t\tconst res = s.aSet.add(\"force\")\n\t\t\t\t\tif (!global.USES_BUILD) expect(res).toBe(s.aSet[DRAFT_STATE].draft_)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aSet).not.toBe(baseState.aSet)\n\t\t\t\texpect(baseState.aSet.has(\"force\")).toBe(false)\n\t\t\t\texpect(nextState.aSet.has(\"force\")).toBe(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns 'size'",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 801,
                "column": 21
            },
            "line": 801,
            "code": "\t\t\tit(\"returns 'size'\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\ts.aSet.add(\"newKey\")\n\t\t\t\t\texpect(s.aSet.size).toBe(baseState.aSet.size + 1)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aSet).not.toBe(baseState.aSet)\n\t\t\t\texpect(nextState.aSet.has(\"newKey\")).toBe(true)\n\t\t\t\texpect(nextState.aSet.size).toEqual(baseState.aSet.size + 1)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use 'delete' to remove items",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 812,
                "column": 39
            },
            "line": 812,
            "code": "\t\t\tit(\"can use 'delete' to remove items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aSet.has(\"Luke\")).toBe(true)\n\t\t\t\t\texpect(s.aSet.delete(\"Luke\")).toBe(true)\n\t\t\t\t\texpect(s.aSet.delete(\"Luke\")).toBe(false)\n\t\t\t\t\texpect(s.aSet.has(\"Luke\")).toBe(false)\n\t\t\t\t})\n\t\t\t\texpect(nextState.aSet).not.toBe(baseState.aSet)\n\t\t\t\texpect(baseState.aSet.has(\"Luke\")).toBe(true)\n\t\t\t\texpect(nextState.aSet.has(\"Luke\")).toBe(false)\n\t\t\t\texpect(nextState.aSet.size).toBe(baseState.aSet.size - 1)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use 'clear' to remove items",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 825,
                "column": 38
            },
            "line": 825,
            "code": "\t\t\tit(\"can use 'clear' to remove items\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aSet.size).not.toBe(0)\n\t\t\t\t\ts.aSet.clear()\n\t\t\t\t\texpect(s.aSet.size).toBe(0)\n\t\t\t\t})\n\t\t\t\texpect(nextState.aSet).not.toBe(baseState.aSet)\n\t\t\t\texpect(baseState.aSet.size).not.toBe(0)\n\t\t\t\texpect(nextState.aSet.size).toBe(0)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports 'has'",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 836,
                "column": 21
            },
            "line": 836,
            "code": "\t\t\tit(\"supports 'has'\", () => {\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.aSet.has(\"newKey\")).toBe(false)\n\t\t\t\t\ts.aSet.add(\"newKey\")\n\t\t\t\t\texpect(s.aSet.has(\"newKey\")).toBe(true)\n\t\t\t\t})\n\t\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\t\texpect(nextState.aSet).not.toBe(baseState.aSet)\n\t\t\t\texpect(baseState.aSet.has(\"newKey\")).toBe(false)\n\t\t\t\texpect(nextState.aSet.has(\"newKey\")).toBe(true)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports nested sets",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 848,
                "column": 27
            },
            "line": 848,
            "code": "\t\t\tit(\"supports nested sets\", () => {\n\t\t\t\tconst base = new Set([new Set([\"Serenity\"])])\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tdraft.forEach(nestedItem => nestedItem.add(\"Firefly\"))\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(base).toEqual(new Set([new Set([\"Serenity\"])]))\n\t\t\t\texpect(result).toEqual(new Set([new Set([\"Serenity\", \"Firefly\"])]))\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports has / delete on elements from the original",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 858,
                "column": 58
            },
            "line": 858,
            "code": "\t\t\tit(\"supports has / delete on elements from the original\", () => {\n\t\t\t\tconst obj = {}\n\t\t\t\tconst set = new Set([obj])\n\t\t\t\tconst next = produce(set, d => {\n\t\t\t\t\texpect(d.has(obj)).toBe(true)\n\t\t\t\t\td.add(3)\n\t\t\t\t\texpect(d.has(obj)).toBe(true)\n\t\t\t\t\td.delete(obj)\n\t\t\t\t\texpect(d.has(obj)).toBe(false)\n\t\t\t\t})\n\t\t\t\texpect(next).toEqual(new Set([3]))\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "revokes sets",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 871,
                "column": 19
            },
            "line": 871,
            "code": "\t\t\tit(\"revokes sets\", () => {\n\t\t\t\tlet m\n\t\t\t\tproduce(baseState, s => {\n\t\t\t\t\tm = s.aSet\n\t\t\t\t})\n\t\t\t\texpect(() => m.has(\"x\")).toThrowErrorMatchingSnapshot()\n\t\t\t\texpect(() => m.add(\"x\")).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does support instanceof Set",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 880,
                "column": 34
            },
            "line": 880,
            "code": "\t\t\tit(\"does support instanceof Set\", () => {\n\t\t\t\tconst set = new Set()\n\t\t\t\tproduce(set, d => {\n\t\t\t\t\texpect(d instanceof Set).toBeTruthy()\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports `immerable` symbol on constructor",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 888,
                "column": 48
            },
            "line": 888,
            "code": "\t\tit(\"supports `immerable` symbol on constructor\", () => {\n\t\t\tclass One {}\n\t\t\tOne[immerable] = true\n\t\t\tconst baseState = new One()\n\t\t\tconst nextState = produce(baseState, draft => {\n\t\t\t\texpect(draft).not.toBe(baseState)\n\t\t\t\tdraft.foo = true\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.foo).toBeTruthy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "preserves symbol properties",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 900,
                "column": 33
            },
            "line": 900,
            "code": "\t\tit(\"preserves symbol properties\", () => {\n\t\t\tconst test = Symbol(\"test\")\n\t\t\tconst baseState = {[test]: true}\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\texpect(s[test]).toBeTruthy()\n\t\t\t\ts.foo = true\n\t\t\t})\n\t\t\texpect(nextState).toEqual({\n\t\t\t\t[test]: true,\n\t\t\t\tfoo: true\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "preserves non-enumerable properties",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 914,
                "column": 42
            },
            "line": 914,
            "code": "\t\t\tit(\"preserves non-enumerable properties\", () => {\n\t\t\t\tconst baseState = {}\n\t\t\t\t// Non-enumerable object property\n\t\t\t\tObject.defineProperty(baseState, \"foo\", {\n\t\t\t\t\tvalue: {a: 1},\n\t\t\t\t\tenumerable: false\n\t\t\t\t})\n\t\t\t\t// Non-enumerable primitive property\n\t\t\t\tObject.defineProperty(baseState, \"bar\", {\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tenumerable: false\n\t\t\t\t})\n\t\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\t\texpect(s.foo).toBeTruthy()\n\t\t\t\t\texpect(isEnumerable(s, \"foo\")).toBeFalsy()\n\t\t\t\t\ts.bar++\n\t\t\t\t\texpect(isEnumerable(s, \"foo\")).toBeFalsy()\n\t\t\t\t\ts.foo.a++\n\t\t\t\t\texpect(isEnumerable(s, \"foo\")).toBeFalsy()\n\t\t\t\t})\n\t\t\t\texpect(nextState.foo).toBeTruthy()\n\t\t\t\texpect(isEnumerable(nextState, \"foo\")).toBeFalsy()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can work with own computed props",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 938,
                "column": 38
            },
            "line": 938,
            "code": "\t\tit(\"can work with own computed props\", () => {\n\t\t\tconst baseState = {\n\t\t\t\tx: 1,\n\t\t\t\tget y() {\n\t\t\t\t\treturn this.x\n\t\t\t\t},\n\t\t\t\tset y(v) {\n\t\t\t\t\tthis.x = v\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\texpect(d.y).toBe(1)\n\t\t\t\td.x = 2\n\t\t\t\texpect(d.x).toBe(2)\n\t\t\t\texpect(d.y).toBe(1) // this has been copied!\n\t\t\t\td.y = 3\n\t\t\t\texpect(d.x).toBe(2)\n\t\t\t})\n\t\t\texpect(baseState.x).toBe(1)\n\t\t\texpect(baseState.y).toBe(1)\n\n\t\t\texpect(nextState.x).toBe(2)\n\t\t\texpect(nextState.y).toBe(3)\n\t\t\tif (!autoFreeze) {\n\t\t\t\tnextState.y = 4 // decoupled now!\n\t\t\t\texpect(nextState.y).toBe(4)\n\t\t\t\texpect(nextState.x).toBe(2)\n\t\t\t\texpect(Object.getOwnPropertyDescriptor(nextState, \"y\").value).toBe(4)\n\t\t\t}\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can work with class with computed props",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 970,
                "column": 45
            },
            "line": 970,
            "code": "\t\tit(\"can work with class with computed props\", () => {\n\t\t\tclass State {\n\t\t\t\t[immerable] = true\n\n\t\t\t\tx = 1\n\n\t\t\t\tset y(v) {\n\t\t\t\t\tthis.x = v\n\t\t\t\t}\n\n\t\t\t\tget y() {\n\t\t\t\t\treturn this.x\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst baseState = new State()\n\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\texpect(d.y).toBe(1)\n\t\t\t\td.y = 2\n\t\t\t\texpect(d.x).toBe(2)\n\t\t\t\texpect(d.y).toBe(2)\n\t\t\t\texpect(Object.getOwnPropertyDescriptor(d, \"y\")).toBeUndefined()\n\t\t\t})\n\t\t\texpect(baseState.x).toBe(1)\n\t\t\texpect(baseState.y).toBe(1)\n\n\t\t\texpect(nextState.x).toBe(2)\n\t\t\texpect(nextState.y).toBe(2)\n\t\t\texpect(Object.getOwnPropertyDescriptor(nextState, \"y\")).toBeUndefined()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "allows inherited computed properties",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1002,
                "column": 42
            },
            "line": 1002,
            "code": "\t\tit(\"allows inherited computed properties\", () => {\n\t\t\tconst proto = {}\n\t\t\tObject.defineProperty(proto, \"foo\", {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.bar\n\t\t\t\t},\n\t\t\t\tset(val) {\n\t\t\t\t\tthis.bar = val\n\t\t\t\t}\n\t\t\t})\n\t\t\tproto[immerable] = true\n\t\t\tconst baseState = Object.create(proto)\n\t\t\tproduce(baseState, s => {\n\t\t\t\texpect(s.bar).toBeUndefined()\n\t\t\t\ts.foo = {}\n\t\t\t\texpect(s.bar).toBeDefined()\n\t\t\t\texpect(s.foo).toBe(s.bar)\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "optimization: does not visit properties of new data structures if autofreeze is disabled and no drafts are unfinalized",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1022,
                "column": 124
            },
            "line": 1022,
            "code": "\t\tit(\"optimization: does not visit properties of new data structures if autofreeze is disabled and no drafts are unfinalized\", () => {\n\t\t\tconst newData = {}\n\t\t\tObject.defineProperty(newData, \"x\", {\n\t\t\t\tenumerable: true,\n\t\t\t\tget() {\n\t\t\t\t\tthrow new Error(\"visited!\")\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tconst run = () =>\n\t\t\t\tproduce({}, d => {\n\t\t\t\t\td.data = newData\n\t\t\t\t})\n\t\t\tif (autoFreeze) {\n\t\t\t\texpect(run).toThrow(\"visited!\")\n\t\t\t} else {\n\t\t\t\texpect(run).not.toThrow(\"visited!\")\n\t\t\t}\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "same optimization doesn't cause draft from nested producers to be unfinished",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1042,
                "column": 82
            },
            "line": 1042,
            "code": "\t\tit(\"same optimization doesn't cause draft from nested producers to be unfinished\", () => {\n\t\t\tconst base = {\n\t\t\t\ty: 1,\n\t\t\t\tchild: {\n\t\t\t\t\tx: 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst wrap = produce(draft => {\n\t\t\t\treturn {\n\t\t\t\t\twrapped: draft\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tconst res = produce(base, draft => {\n\t\t\t\tdraft.y++\n\t\t\t\tdraft.child = wrap(draft.child)\n\t\t\t\tdraft.child.wrapped.x++\n\t\t\t})\n\n\t\t\texpect(res).toEqual({\n\t\t\t\ty: 2,\n\t\t\t\tchild: {wrapped: {x: 2}}\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports a base state with multiple references to an object",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1067,
                "column": 65
            },
            "line": 1067,
            "code": "\t\tit(\"supports a base state with multiple references to an object\", () => {\n\t\t\tconst obj = {}\n\t\t\tconst res = produce({a: obj, b: obj}, d => {\n\t\t\t\t// Two drafts are created for each occurrence of an object in the base state.\n\t\t\t\texpect(d.a).not.toBe(d.b)\n\t\t\t\td.a.z = true\n\t\t\t\texpect(d.b.z).toBeUndefined()\n\t\t\t})\n\t\t\texpect(res.b).toBe(obj)\n\t\t\texpect(res.a).not.toBe(res.b)\n\t\t\texpect(res.a.z).toBeTruthy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports multiple references to any modified draft",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1081,
                "column": 56
            },
            "line": 1081,
            "code": "\t\tit(\"supports multiple references to any modified draft\", () => {\n\t\t\tconst next = produce({a: {b: 1}}, d => {\n\t\t\t\td.a.b++\n\t\t\t\td.b = d.a\n\t\t\t})\n\t\t\texpect(next.a).toBe(next.b)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can rename nested objects (no changes)",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1089,
                "column": 44
            },
            "line": 1089,
            "code": "\t\tit(\"can rename nested objects (no changes)\", () => {\n\t\t\tconst nextState = produce({obj: {}}, s => {\n\t\t\t\ts.foo = s.obj\n\t\t\t\tdelete s.obj\n\t\t\t})\n\t\t\texpect(nextState).toEqual({foo: {}})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can rename nested objects (with changes)",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1099,
                "column": 46
            },
            "line": 1099,
            "code": "\t\tit(\"can rename nested objects (with changes)\", () => {\n\t\t\tconst nextState = produce({obj: {a: 1, b: 1}}, s => {\n\t\t\t\ts.obj.a = true // change\n\t\t\t\tdelete s.obj.b // delete\n\t\t\t\ts.obj.c = true // add\n\n\t\t\t\ts.foo = s.obj\n\t\t\t\tdelete s.obj\n\t\t\t})\n\t\t\texpect(nextState).toEqual({foo: {a: true, c: true}})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can nest a draft in a new object (no changes)",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1111,
                "column": 51
            },
            "line": 1111,
            "code": "\t\tit(\"can nest a draft in a new object (no changes)\", () => {\n\t\t\tconst baseState = {obj: {}}\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.foo = {bar: s.obj}\n\t\t\t\tdelete s.obj\n\t\t\t})\n\t\t\texpect(nextState.foo.bar).toBe(baseState.obj)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can nest a modified draft in a new object",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1120,
                "column": 47
            },
            "line": 1120,
            "code": "\t\tit(\"can nest a modified draft in a new object\", () => {\n\t\t\tconst nextState = produce({obj: {a: 1, b: 1}}, s => {\n\t\t\t\ts.obj.a = true // change\n\t\t\t\tdelete s.obj.b // delete\n\t\t\t\ts.obj.c = true // add\n\n\t\t\t\ts.foo = {bar: s.obj}\n\t\t\t\tdelete s.obj\n\t\t\t})\n\t\t\texpect(nextState).toEqual({foo: {bar: {a: true, c: true}}})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports assigning undefined to an existing property",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1132,
                "column": 58
            },
            "line": 1132,
            "code": "\t\tit(\"supports assigning undefined to an existing property\", () => {\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.aProp = undefined\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.aProp).toBe(undefined)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports assigning undefined to a new property",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1140,
                "column": 52
            },
            "line": 1140,
            "code": "\t\tit(\"supports assigning undefined to a new property\", () => {\n\t\t\tconst baseState = {}\n\t\t\tconst nextState = produce(baseState, s => {\n\t\t\t\ts.aProp = undefined\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState.aProp).toBe(undefined)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "revokes the draft once produce returns",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1151,
                "column": 45
            },
            "line": 1151,
            "code": "\t\t\tit(\"revokes the draft once produce returns\", () => {\n\t\t\t\tconst expectRevoked = (fn, shouldThrow = true) => {\n\t\t\t\t\tif (shouldThrow) expect(fn).toThrowErrorMatchingSnapshot()\n\t\t\t\t\telse expect(fn).not.toThrow()\n\t\t\t\t}\n\n\t\t\t\t// Test object drafts:\n\t\t\t\tlet draft\n\t\t\t\tproduce({a: 1, b: 1}, s => {\n\t\t\t\t\tdraft = s\n\t\t\t\t\tdelete s.b\n\t\t\t\t})\n\n\t\t\t\t// Access known property on object draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft.a\n\t\t\t\t})\n\n\t\t\t\t// Assign known property on object draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft.a = true\n\t\t\t\t})\n\n\t\t\t\t// Access unknown property on object draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft.z\n\t\t\t\t}, useProxies)\n\n\t\t\t\t// Assign unknown property on object draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft.z = true\n\t\t\t\t}, useProxies)\n\n\t\t\t\t// Test array drafts:\n\t\t\t\tproduce([1, 2], s => {\n\t\t\t\t\tdraft = s\n\t\t\t\t\ts.pop()\n\t\t\t\t})\n\n\t\t\t\t// Access known index of an array draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft[0]\n\t\t\t\t})\n\n\t\t\t\t// Assign known index of an array draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft[0] = true\n\t\t\t\t})\n\n\t\t\t\t// Access unknown index of an array draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft[1]\n\t\t\t\t}, useProxies)\n\n\t\t\t\t// Assign unknown index of an array draft.\n\t\t\t\texpectRevoked(() => {\n\t\t\t\t\tdraft[1] = true\n\t\t\t\t}, useProxies)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can access a child draft that was created before the draft was modified",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1211,
                "column": 77
            },
            "line": 1211,
            "code": "\t\tit(\"can access a child draft that was created before the draft was modified\", () => {\n\t\t\tproduce({a: {}}, s => {\n\t\t\t\tconst before = s.a\n\t\t\t\ts.b = 1\n\t\t\t\texpect(s.a).toBe(before)\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should reflect all changes made in the draft immediately",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1219,
                "column": 62
            },
            "line": 1219,
            "code": "\t\tit(\"should reflect all changes made in the draft immediately\", () => {\n\t\t\tproduce(baseState, draft => {\n\t\t\t\tdraft.anArray[0] = 5\n\t\t\t\tdraft.anArray.unshift(\"test\")\n\t\t\t\tif (!global.USES_BUILD)\n\t\t\t\t\texpect(enumerableOnly(draft.anArray)).toEqual([\n\t\t\t\t\t\t\"test\",\n\t\t\t\t\t\t5,\n\t\t\t\t\t\t2,\n\t\t\t\t\t\t{c: 3},\n\t\t\t\t\t\t1\n\t\t\t\t\t])\n\t\t\t\tdraft.stuffz = \"coffee\"\n\t\t\t\texpect(draft.stuffz).toBe(\"coffee\")\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when Object.defineProperty() is used on drafts",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1237,
                "column": 60
            },
            "line": 1237,
            "code": "\t\t\tit(\"throws when Object.defineProperty() is used on drafts\", () => {\n\t\t\t\texpect(() => {\n\t\t\t\t\tproduce({}, draft => {\n\t\t\t\t\t\tObject.defineProperty(draft, \"xx\", {\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\twriteable: true,\n\t\t\t\t\t\t\tvalue: 2\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should handle constructor correctly",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1249,
                "column": 41
            },
            "line": 1249,
            "code": "\t\tit(\"should handle constructor correctly\", () => {\n\t\t\tconst baseState = {\n\t\t\t\tarr: new Array(),\n\t\t\t\tobj: new Object()\n\t\t\t}\n\t\t\tconst result = produce(baseState, draft => {\n\t\t\t\tdraft.arrConstructed = draft.arr.constructor(1)\n\t\t\t\tdraft.objConstructed = draft.obj.constructor(1)\n\t\t\t})\n\t\t\texpect(result.arrConstructed).toEqual(new Array().constructor(1))\n\t\t\texpect(result.objConstructed).toEqual(new Object().constructor(1))\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should handle equality correctly - 1",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1262,
                "column": 42
            },
            "line": 1262,
            "code": "\t\tit(\"should handle equality correctly - 1\", () => {\n\t\t\tconst baseState = {\n\t\t\t\ty: 3 / 0,\n\t\t\t\tz: NaN\n\t\t\t}\n\t\t\tconst nextState = produce(baseState, draft => {\n\t\t\t\tdraft.y = 4 / 0\n\t\t\t\tdraft.z = NaN\n\t\t\t})\n\t\t\texpect(nextState).toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should handle equality correctly - 2",
            "suites": [
                "base functionality - ",
                "set drafts"
            ],
            "updatePoint": {
                "line": 1274,
                "column": 42
            },
            "line": 1274,
            "code": "\t\tit(\"should handle equality correctly - 2\", () => {\n\t\t\tconst baseState = {\n\t\t\t\tx: -0\n\t\t\t}\n\t\t\tconst nextState = produce(baseState, draft => {\n\t\t\t\tdraft.x = +0\n\t\t\t})\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t\texpect(nextState).not.toEqual(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never affects its parent producer implicitly",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state is not a draft"
            ],
            "updatePoint": {
                "line": 1290,
                "column": 52
            },
            "line": 1290,
            "code": "\t\t\t\tit(\"never affects its parent producer implicitly\", () => {\n\t\t\t\t\tconst base = {obj: {a: 1}}\n\t\t\t\t\tconst next = produce(base, draft => {\n\t\t\t\t\t\t// Notice how `base.obj` is passed, not `draft.obj`\n\t\t\t\t\t\tconst obj2 = produce(base.obj, draft2 => {\n\t\t\t\t\t\t\tdraft2.a = 0\n\t\t\t\t\t\t})\n\t\t\t\t\t\texpect(obj2.a).toBe(0)\n\t\t\t\t\t\texpect(draft.obj.a).toBe(1) // effects should not be visible outside\n\t\t\t\t\t})\n\t\t\t\t\texpect(next).toBe(base)\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "always wraps the draft in a new draft",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state is a draft"
            ],
            "updatePoint": {
                "line": 1305,
                "column": 45
            },
            "line": 1305,
            "code": "\t\t\t\tit(\"always wraps the draft in a new draft\", () => {\n\t\t\t\t\tproduce({}, parent => {\n\t\t\t\t\t\tproduce(parent, child => {\n\t\t\t\t\t\t\texpect(child).not.toBe(parent)\n\t\t\t\t\t\t\texpect(isDraft(child)).toBeTruthy()\n\t\t\t\t\t\t\texpect(original(child)).toBe(parent)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "ensures each property is drafted",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state is a draft"
            ],
            "updatePoint": {
                "line": 1316,
                "column": 40
            },
            "line": 1316,
            "code": "\t\t\t\tit(\"ensures each property is drafted\", () => {\n\t\t\t\t\tproduce({a: {}, b: {}}, parent => {\n\t\t\t\t\t\tparent.a // Access \"a\" but not \"b\"\n\t\t\t\t\t\tproduce(parent, child => {\n\t\t\t\t\t\t\tchild.c = 1\n\t\t\t\t\t\t\texpect(isDraft(child.a)).toBeTruthy()\n\t\t\t\t\t\t\texpect(isDraft(child.b)).toBeTruthy()\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "preserves any pending changes",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state is a draft"
            ],
            "updatePoint": {
                "line": 1327,
                "column": 37
            },
            "line": 1327,
            "code": "\t\t\t\tit(\"preserves any pending changes\", () => {\n\t\t\t\t\tproduce({a: 1, b: 1, d: 1}, parent => {\n\t\t\t\t\t\tparent.b = 2\n\t\t\t\t\t\tparent.c = 2\n\t\t\t\t\t\tdelete parent.d\n\t\t\t\t\t\tproduce(parent, child => {\n\t\t\t\t\t\t\texpect(child.a).toBe(1) // unchanged\n\t\t\t\t\t\t\texpect(child.b).toBe(2) // changed\n\t\t\t\t\t\t\texpect(child.c).toBe(2) // added\n\t\t\t\t\t\t\texpect(child.d).toBeUndefined() // deleted\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "wraps unowned draft with its own draft",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1343,
                "column": 46
            },
            "line": 1343,
            "code": "\t\t\t\tit(\"wraps unowned draft with its own draft\", () => {\n\t\t\t\t\tproduce({a: {}}, parent => {\n\t\t\t\t\t\tproduce({a: parent.a}, child => {\n\t\t\t\t\t\t\texpect(child.a).not.toBe(parent.a)\n\t\t\t\t\t\t\texpect(isDraft(child.a)).toBeTruthy()\n\t\t\t\t\t\t\texpect(original(child.a)).toBe(parent.a)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns unowned draft if no changes were made",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1353,
                "column": 53
            },
            "line": 1353,
            "code": "\t\t\t\tit(\"returns unowned draft if no changes were made\", () => {\n\t\t\t\t\tproduce({a: {}}, parent => {\n\t\t\t\t\t\tconst result = produce({a: parent.a}, () => {})\n\t\t\t\t\t\texpect(result.a).toBe(parent.a)\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "clones the unowned draft when changes are made",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1360,
                "column": 54
            },
            "line": 1360,
            "code": "\t\t\t\tit(\"clones the unowned draft when changes are made\", () => {\n\t\t\t\t\tproduce({a: {}}, parent => {\n\t\t\t\t\t\tconst result = produce({a: parent.a}, child => {\n\t\t\t\t\t\t\tchild.a.b = 1\n\t\t\t\t\t\t})\n\t\t\t\t\t\texpect(result.a).not.toBe(parent.a)\n\t\t\t\t\t\texpect(result.a.b).toBe(1)\n\t\t\t\t\t\texpect(\"b\" in parent.a).toBeFalsy()\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never auto-freezes the result",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1373,
                "column": 37
            },
            "line": 1373,
            "code": "\t\t\t\tit(\"never auto-freezes the result\", () => {\n\t\t\t\t\tproduce({a: {}}, parent => {\n\t\t\t\t\t\tconst r = produce({a: parent.a}, child => {\n\t\t\t\t\t\t\tchild.b = 1 // Ensure a copy is returned.\n\t\t\t\t\t\t})\n\t\t\t\t\t\texpect(Object.isFrozen(r)).toBeFalsy()\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not finalize upvalue drafts",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1384,
                "column": 39
            },
            "line": 1384,
            "code": "\t\t\tit(\"does not finalize upvalue drafts\", () => {\n\t\t\t\tproduce({a: {}, b: {}}, parent => {\n\t\t\t\t\texpect(produce({}, () => parent)).toBe(parent)\n\t\t\t\t\tparent.x // Ensure proxy not revoked.\n\n\t\t\t\t\texpect(produce({}, () => [parent])[0]).toBe(parent)\n\t\t\t\t\tparent.x // Ensure proxy not revoked.\n\n\t\t\t\t\texpect(produce({}, () => parent.a)).toBe(parent.a)\n\t\t\t\t\tparent.a.x // Ensure proxy not revoked.\n\n\t\t\t\t\t// Modified parent test\n\t\t\t\t\tparent.c = 1\n\t\t\t\t\texpect(produce({}, () => [parent.b])[0]).toBe(parent.b)\n\t\t\t\t\tparent.b.x // Ensure proxy not revoked.\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with interweaved Immer instances",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1402,
                "column": 45
            },
            "line": 1402,
            "code": "\t\t\tit(\"works with interweaved Immer instances\", () => {\n\t\t\t\tconst options = {useProxies, autoFreeze}\n\t\t\t\tconst one = createPatchedImmer(options)\n\t\t\t\tconst two = createPatchedImmer(options)\n\n\t\t\t\tconst base = {}\n\t\t\t\tconst result = one.produce(base, s1 =>\n\t\t\t\t\ttwo.produce({s1}, s2 => {\n\t\t\t\t\t\texpect(original(s2.s1)).toBe(s1)\n\t\t\t\t\t\ts2.n = 1\n\t\t\t\t\t\ts2.s1 = one.produce({s2}, s3 => {\n\t\t\t\t\t\t\texpect(original(s3.s2)).toBe(s2)\n\t\t\t\t\t\t\texpect(original(s3.s2.s1)).toBe(s2.s1)\n\t\t\t\t\t\t\treturn s3.s2.s1\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\texpect(result.n).toBe(1)\n\t\t\t\texpect(result.s1).toBe(base)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when Object.setPrototypeOf() is used on a draft",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1425,
                "column": 61
            },
            "line": 1425,
            "code": "\t\t\tit(\"throws when Object.setPrototypeOf() is used on a draft\", () => {\n\t\t\t\tproduce({}, draft => {\n\t\t\t\t\texpect(() =>\n\t\t\t\t\t\tObject.setPrototypeOf(draft, Array)\n\t\t\t\t\t).toThrowErrorMatchingSnapshot()\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports the 'in' operator",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1433,
                "column": 32
            },
            "line": 1433,
            "code": "\t\tit(\"supports the 'in' operator\", () => {\n\t\t\tproduce(baseState, draft => {\n\t\t\t\t// Known property\n\t\t\t\texpect(\"anArray\" in draft).toBe(true)\n\t\t\t\texpect(Reflect.has(draft, \"anArray\")).toBe(true)\n\n\t\t\t\t// Unknown property\n\t\t\t\texpect(\"bla\" in draft).toBe(false)\n\t\t\t\texpect(Reflect.has(draft, \"bla\")).toBe(false)\n\n\t\t\t\t// Known index\n\t\t\t\texpect(0 in draft.anArray).toBe(true)\n\t\t\t\texpect(\"0\" in draft.anArray).toBe(true)\n\t\t\t\texpect(Reflect.has(draft.anArray, 0)).toBe(true)\n\t\t\t\texpect(Reflect.has(draft.anArray, \"0\")).toBe(true)\n\n\t\t\t\t// Unknown index\n\t\t\t\texpect(17 in draft.anArray).toBe(false)\n\t\t\t\texpect(\"17\" in draft.anArray).toBe(false)\n\t\t\t\texpect(Reflect.has(draft.anArray, 17)).toBe(false)\n\t\t\t\texpect(Reflect.has(draft.anArray, \"17\")).toBe(false)\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "'this' should not be bound anymore - 1",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1457,
                "column": 44
            },
            "line": 1457,
            "code": "\t\tit(\"'this' should not be bound anymore - 1\", () => {\n\t\t\tconst base = {x: 3}\n\t\t\tconst next1 = produce(base, function() {\n\t\t\t\texpect(this).toBe(undefined)\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "'this' should not be bound anymore - 2",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1464,
                "column": 44
            },
            "line": 1464,
            "code": "\t\tit(\"'this' should not be bound anymore - 2\", () => {\n\t\t\tconst incrementor = produce(function() {\n\t\t\t\texpect(this).toBe(undefined)\n\t\t\t})\n\t\t\tincrementor()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should be possible to use dynamic bound this",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1471,
                "column": 50
            },
            "line": 1471,
            "code": "\t\tit(\"should be possible to use dynamic bound this\", () => {\n\t\t\tconst world = {\n\t\t\t\tcounter: {count: 1},\n\t\t\t\tinc: produce(function(draft) {\n\t\t\t\t\texpect(this).toBe(world)\n\t\t\t\t\tdraft.counter.count = this.counter.count + 1\n\t\t\t\t})\n\t\t\t}\n\n\t\t\texpect(world.inc(world).counter.count).toBe(2)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "doesnt recurse into frozen structures if external data is frozen",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1483,
                "column": 70
            },
            "line": 1483,
            "code": "\t\tit(\"doesnt recurse into frozen structures if external data is frozen\", () => {\n\t\t\tconst frozen = {}\n\t\t\tObject.defineProperty(frozen, \"x\", {\n\t\t\t\tget() {\n\t\t\t\t\tthrow \"oops\"\n\t\t\t\t},\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t\tObject.freeze(frozen)\n\n\t\t\texpect(() => {\n\t\t\t\tproduce({}, d => {\n\t\t\t\t\td.x = frozen\n\t\t\t\t})\n\t\t\t}).not.toThrow()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports the spread operator",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1502,
                "column": 34
            },
            "line": 1502,
            "code": "\t\tit(\"supports the spread operator\", () => {\n\t\t\tconst base = {foo: {x: 0, y: 0}, bar: [0, 0]}\n\t\t\tconst result = produce(base, draft => {\n\t\t\t\tdraft.foo = {x: 1, ...draft.foo, y: 1}\n\t\t\t\tdraft.bar = [1, ...draft.bar, 1]\n\t\t\t})\n\t\t\texpect(result).toEqual({\n\t\t\t\tfoo: {x: 0, y: 1},\n\t\t\t\tbar: [1, 0, 0, 1]\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "processes with lodash.set",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1514,
                "column": 31
            },
            "line": 1514,
            "code": "\t\tit(\"processes with lodash.set\", () => {\n\t\t\tconst base = [{id: 1, a: 1}]\n\t\t\tconst result = produce(base, draft => {\n\t\t\t\tlodash.set(draft, \"[0].a\", 2)\n\t\t\t})\n\t\t\texpect(base[0].a).toEqual(1)\n\t\t\texpect(result[0].a).toEqual(2)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "processes with lodash.find",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1523,
                "column": 32
            },
            "line": 1523,
            "code": "\t\tit(\"processes with lodash.find\", () => {\n\t\t\tconst base = [{id: 1, a: 1}]\n\t\t\tconst result = produce(base, draft => {\n\t\t\t\tconst obj1 = lodash.find(draft, {id: 1})\n\t\t\t\tlodash.set(obj1, \"a\", 2)\n\t\t\t})\n\t\t\texpect(base[0].a).toEqual(1)\n\t\t\texpect(result[0].a).toEqual(2)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not draft external data",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1533,
                "column": 34
            },
            "line": 1533,
            "code": "\t\tit(\"does not draft external data\", () => {\n\t\t\tconst externalData = {x: 3}\n\t\t\tconst base = {}\n\t\t\tconst next = produce(base, draft => {\n\t\t\t\t// potentially, we *could* draft external data automatically, but only if those statements are not switched...\n\t\t\t\tdraft.y = externalData\n\t\t\t\tdraft.y.x += 1\n\t\t\t\texternalData.x += 1\n\t\t\t})\n\t\t\texpect(next).toEqual({y: {x: 5}})\n\t\t\texpect(externalData.x).toBe(5)\n\t\t\texpect(next.y).toBe(externalData)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not create new state unnecessary, #491",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1547,
                "column": 49
            },
            "line": 1547,
            "code": "\t\tit(\"does not create new state unnecessary, #491\", () => {\n\t\t\tconst a = {highlight: true}\n\t\t\tconst next1 = produce(a, draft => {\n\t\t\t\tdraft.highlight = false\n\t\t\t\tdraft.highlight = true\n\t\t\t})\n\t\t\t// See explanation in issue\n\t\t\texpect(next1).not.toBe(a)\n\n\t\t\tconst next2 = produce(a, draft => {\n\t\t\t\tdraft.highlight = true\n\t\t\t})\n\t\t\texpect(next2).toBe(a)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "issue #462 - frozen",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1563,
                "column": 28
            },
            "line": 1563,
            "code": "\t\t\ttest(\"issue #462 - frozen\", () => {\n\t\t\t\tvar origin = {\n\t\t\t\t\ta: {\n\t\t\t\t\t\tvalue: \"no\"\n\t\t\t\t\t},\n\t\t\t\t\tb: {\n\t\t\t\t\t\tvalue: \"no\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst next = produce(origin, draft => {\n\t\t\t\t\tdraft.a.value = \"im\"\n\t\t\t\t})\n\t\t\t\texpect(() => {\n\t\t\t\t\torigin.b.value = \"yes\"\n\t\t\t\t}).toThrowError(\n\t\t\t\t\t\"Cannot assign to read only property 'value' of object '#<Object>'\"\n\t\t\t\t)\n\t\t\t\texpect(() => {\n\t\t\t\t\tnext.b.value = \"yes\"\n\t\t\t\t}).toThrowError(\n\t\t\t\t\t\"Cannot assign to read only property 'value' of object '#<Object>'\"\n\t\t\t\t) // should throw!\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "issue #469, state not frozen",
            "suites": [
                "base functionality - ",
                "nested producers",
                "when base state contains a draft"
            ],
            "updatePoint": {
                "line": 1588,
                "column": 37
            },
            "line": 1588,
            "code": "\t\t\ttest(\"issue #469, state not frozen\", () => {\n\t\t\t\tconst project = produce(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\ttracks: [{id: 1}]\n\t\t\t\t\t},\n\t\t\t\t\t() => {}\n\t\t\t\t)\n\n\t\t\t\texpect(() => {\n\t\t\t\t\tproject.id = 2 // Does not throw error\n\t\t\t\t}).toThrowError(\"Cannot assign to read only property 'id'\")\n\n\t\t\t\texpect(() => {\n\t\t\t\t\tObject.assign(project, {id: 2}) // Uncaught TypeError: Cannot assign to read only property 'id' of object '#<Object>'\n\t\t\t\t}).toThrowError(\"Cannot assign to read only property 'id'\")\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return a new object",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1607,
                "column": 30
            },
            "line": 1607,
            "code": "\t\t\tit(\"can return a new object\", () => {\n\t\t\t\tconst base = {x: 3}\n\t\t\t\tconst res = produce(base, d => {\n\t\t\t\t\treturn {x: d.x + 1}\n\t\t\t\t})\n\t\t\t\texpect(res).not.toBe(base)\n\t\t\t\texpect(res).toEqual({x: 4})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return the draft",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1616,
                "column": 27
            },
            "line": 1616,
            "code": "\t\t\tit(\"can return the draft\", () => {\n\t\t\t\tconst base = {x: 3}\n\t\t\t\tconst res = produce(base, d => {\n\t\t\t\t\td.x = 4\n\t\t\t\t\treturn d\n\t\t\t\t})\n\t\t\t\texpect(res).not.toBe(base)\n\t\t\t\texpect(res).toEqual({x: 4})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return an unmodified child draft",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1626,
                "column": 43
            },
            "line": 1626,
            "code": "\t\t\tit(\"can return an unmodified child draft\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst res = produce(base, d => {\n\t\t\t\t\treturn d.a\n\t\t\t\t})\n\t\t\t\texpect(res).toBe(base.a)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot return a modified child draft",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1635,
                "column": 43
            },
            "line": 1635,
            "code": "\t\t\tit(\"cannot return a modified child draft\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\texpect(() => {\n\t\t\t\t\tproduce(base, d => {\n\t\t\t\t\t\td.a.b = 1\n\t\t\t\t\t\treturn d.a\n\t\t\t\t\t})\n\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return a frozen object",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1645,
                "column": 33
            },
            "line": 1645,
            "code": "\t\t\tit(\"can return a frozen object\", () => {\n\t\t\t\tconst res = deepFreeze([{x: 3}])\n\t\t\t\texpect(produce({}, () => res)).toBe(res)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return an object with two references to another object",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1650,
                "column": 65
            },
            "line": 1650,
            "code": "\t\t\tit(\"can return an object with two references to another object\", () => {\n\t\t\t\tconst next = produce({}, d => {\n\t\t\t\t\tconst obj = {}\n\t\t\t\t\treturn {obj, arr: [obj]}\n\t\t\t\t})\n\t\t\t\texpect(next.obj).toBe(next.arr[0])\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return an object with two references to an unmodified draft",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1658,
                "column": 70
            },
            "line": 1658,
            "code": "\t\t\tit(\"can return an object with two references to an unmodified draft\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, d => {\n\t\t\t\t\treturn [d.a, d.a]\n\t\t\t\t})\n\t\t\t\texpect(next[0]).toBe(base.a)\n\t\t\t\texpect(next[0]).toBe(next[1])\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot return an object that references itself",
            "suites": [
                "base functionality - ",
                "recipe functions"
            ],
            "updatePoint": {
                "line": 1667,
                "column": 53
            },
            "line": 1667,
            "code": "\t\t\tit(\"cannot return an object that references itself\", () => {\n\t\t\t\tconst res = {}\n\t\t\t\tres.self = res\n\t\t\t\texpect(() => {\n\t\t\t\t\tproduce(res, () => res.self)\n\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can modify the draft",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1677,
                "column": 27
            },
            "line": 1677,
            "code": "\t\t\tit(\"can modify the draft\", () => {\n\t\t\t\tconst base = {a: 0, b: 0}\n\t\t\t\treturn produce(base, async d => {\n\t\t\t\t\td.a = 1\n\t\t\t\t\tawait Promise.resolve()\n\t\t\t\t\td.b = 1\n\t\t\t\t}).then(res => {\n\t\t\t\t\texpect(res).not.toBe(base)\n\t\t\t\t\texpect(res).toEqual({a: 1, b: 1})\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with rejected promises",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1689,
                "column": 35
            },
            "line": 1689,
            "code": "\t\t\tit(\"works with rejected promises\", () => {\n\t\t\t\tlet draft\n\t\t\t\tconst base = {a: 0, b: 0}\n\t\t\t\tconst err = new Error(\"passed\")\n\t\t\t\treturn produce(base, d => {\n\t\t\t\t\tdraft = d\n\t\t\t\t\tdraft.b = 1\n\t\t\t\t\treturn Promise.reject(err)\n\t\t\t\t}).then(\n\t\t\t\t\t() => {\n\t\t\t\t\t\tthrow \"failed\"\n\t\t\t\t\t},\n\t\t\t\t\te => {\n\t\t\t\t\t\texpect(e).toBe(err)\n\t\t\t\t\t\tif (!isProd) expect(() => draft.a).toThrowErrorMatchingSnapshot()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports recursive produce calls after await",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1708,
                "column": 51
            },
            "line": 1708,
            "code": "\t\t\tit(\"supports recursive produce calls after await\", () => {\n\t\t\t\tconst base = {obj: {k: 1}}\n\t\t\t\treturn produce(base, d => {\n\t\t\t\t\tconst obj = d.obj\n\t\t\t\t\tdelete d.obj\n\t\t\t\t\treturn Promise.resolve().then(() => {\n\t\t\t\t\t\td.a = produce({}, d => {\n\t\t\t\t\t\t\td.b = obj // Assign a draft owned by the parent scope.\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\t// Auto-freezing is prevented when an unowned draft exists.\n\t\t\t\t\t\texpect(Object.isFrozen(d.a)).toBeFalsy()\n\n\t\t\t\t\t\t// Ensure `obj` is not revoked.\n\t\t\t\t\t\tobj.c = 1\n\t\t\t\t\t})\n\t\t\t\t}).then(res => {\n\t\t\t\t\texpect(res).not.toBe(base)\n\t\t\t\t\texpect(res).toEqual({\n\t\t\t\t\t\ta: {b: {k: 1, c: 1}}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when the draft is modified and another object is returned",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1733,
                "column": 70
            },
            "line": 1733,
            "code": "\t\tit(\"throws when the draft is modified and another object is returned\", () => {\n\t\t\tconst base = {x: 3}\n\t\t\texpect(() => {\n\t\t\t\tproduce(base, draft => {\n\t\t\t\t\tdraft.x = 4\n\t\t\t\t\treturn {x: 5}\n\t\t\t\t})\n\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should fix #117 - 1",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1743,
                "column": 25
            },
            "line": 1743,
            "code": "\t\tit(\"should fix #117 - 1\", () => {\n\t\t\tconst reducer = (state, action) =>\n\t\t\t\tproduce(state, draft => {\n\t\t\t\t\tswitch (action.type) {\n\t\t\t\t\t\tcase \"SET_STARTING_DOTS\":\n\t\t\t\t\t\t\treturn draft.availableStartingDots.map(a => a)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\tconst base = {\n\t\t\t\tavailableStartingDots: [\n\t\t\t\t\t{dots: 4, count: 1},\n\t\t\t\t\t{dots: 3, count: 2},\n\t\t\t\t\t{dots: 2, count: 3},\n\t\t\t\t\t{dots: 1, count: 4}\n\t\t\t\t]\n\t\t\t}\n\t\t\tconst next = reducer(base, {type: \"SET_STARTING_DOTS\"})\n\t\t\texpect(next).toEqual(base.availableStartingDots)\n\t\t\texpect(next).not.toBe(base.availableStartingDots)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should fix #117 - 2",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1766,
                "column": 25
            },
            "line": 1766,
            "code": "\t\tit(\"should fix #117 - 2\", () => {\n\t\t\tconst reducer = (state, action) =>\n\t\t\t\tproduce(state, draft => {\n\t\t\t\t\tswitch (action.type) {\n\t\t\t\t\t\tcase \"SET_STARTING_DOTS\":\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdots: draft.availableStartingDots.map(a => a)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\tconst base = {\n\t\t\t\tavailableStartingDots: [\n\t\t\t\t\t{dots: 4, count: 1},\n\t\t\t\t\t{dots: 3, count: 2},\n\t\t\t\t\t{dots: 2, count: 3},\n\t\t\t\t\t{dots: 1, count: 4}\n\t\t\t\t]\n\t\t\t}\n\t\t\tconst next = reducer(base, {type: \"SET_STARTING_DOTS\"})\n\t\t\texpect(next).toEqual({dots: base.availableStartingDots})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 0",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1790,
                "column": 47
            },
            "line": 1790,
            "code": "\t\tit(\"cannot always detect noop assignments - 0\", () => {\n\t\t\tconst baseState = {x: {y: 3}}\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\tconst a = d.x\n\t\t\t\td.x = a\n\t\t\t})\n\t\t\texpect(nextState).toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 1",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1799,
                "column": 47
            },
            "line": 1799,
            "code": "\t\tit(\"cannot always detect noop assignments - 1\", () => {\n\t\t\tconst baseState = {x: {y: 3}}\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\tconst a = d.x\n\t\t\t\td.x = 4\n\t\t\t\td.x = a\n\t\t\t})\n\t\t\t// Ideally, this should actually be the same instances\n\t\t\t// but this would be pretty expensive to detect,\n\t\t\t// so we don't atm\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 2",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1812,
                "column": 47
            },
            "line": 1812,
            "code": "\t\tit(\"cannot always detect noop assignments - 2\", () => {\n\t\t\tconst baseState = {x: {y: 3}}\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\tconst a = d.x\n\t\t\t\tconst stuff = a.y + 3\n\t\t\t\td.x = 4\n\t\t\t\td.x = a\n\t\t\t})\n\t\t\t// Ideally, this should actually be the same instances\n\t\t\t// but this would be pretty expensive to detect,\n\t\t\t// so we don't atm\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 3",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1826,
                "column": 47
            },
            "line": 1826,
            "code": "\t\tit(\"cannot always detect noop assignments - 3\", () => {\n\t\t\tconst baseState = {x: 3}\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\td.x = 3\n\t\t\t})\n\t\t\texpect(nextState).toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 4",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1834,
                "column": 47
            },
            "line": 1834,
            "code": "\t\tit(\"cannot always detect noop assignments - 4\", () => {\n\t\t\tconst baseState = {x: 3}\n\t\t\tconst nextState = produce(baseState, d => {\n\t\t\t\td.x = 4\n\t\t\t\td.x = 3\n\t\t\t})\n\t\t\t// Ideally, this should actually be the same instances\n\t\t\t// but this would be pretty expensive to detect,\n\t\t\t// so we don't atm\n\t\t\texpect(nextState).not.toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot always detect noop assignments - 4",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1846,
                "column": 47
            },
            "line": 1846,
            "code": "\t\tit(\"cannot always detect noop assignments - 4\", () => {\n\t\t\tconst baseState = {}\n\t\t\tconst [nextState, patches] = produceWithPatches(baseState, d => {\n\t\t\t\td.x = 4\n\t\t\t\tdelete d.x\n\t\t\t})\n\t\t\texpect(nextState).toEqual({})\n\t\t\texpect(patches).toEqual([])\n\t\t\t// This differs between ES5 and proxy, and ES5 does it better :(\n\t\t\tif (useProxies) expect(nextState).not.toBe(baseState)\n\t\t\telse expect(nextState).toBe(baseState)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot produce undefined by returning undefined",
            "suites": [
                "base functionality - ",
                "async recipe function"
            ],
            "updatePoint": {
                "line": 1859,
                "column": 53
            },
            "line": 1859,
            "code": "\t\tit(\"cannot produce undefined by returning undefined\", () => {\n\t\t\tconst base = 3\n\t\t\texpect(produce(base, () => 4)).toBe(4)\n\t\t\texpect(produce(base, () => null)).toBe(null)\n\t\t\texpect(produce(base, () => undefined)).toBe(3)\n\t\t\texpect(produce(base, () => {})).toBe(3)\n\t\t\texpect(produce(base, () => nothing)).toBe(undefined)\n\n\t\t\texpect(produce({}, () => undefined)).toEqual({})\n\t\t\texpect(produce({}, () => nothing)).toBe(undefined)\n\t\t\texpect(produce(3, () => nothing)).toBe(undefined)\n\n\t\t\texpect(produce(() => undefined)({})).toEqual({})\n\t\t\texpect(produce(() => nothing)({})).toBe(undefined)\n\t\t\texpect(produce(() => nothing)(3)).toBe(undefined)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with spread #524 - ",
            "suites": [
                "base functionality - ",
                "base state type"
            ],
            "updatePoint": {
                "line": 1915,
                "column": 37
            },
            "line": 1915,
            "code": "\tit(`works with spread #524 - ${name}`, () => {\n\t\tconst state = {\n\t\t\tlevel1: {\n\t\t\t\tlevel2: {\n\t\t\t\t\tlevel3: \"data\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst nextState = produce(state, draft => {\n\t\t\treturn {...draft}\n\t\t})\n\t\tconst nextState1 = produce(state, draft => {\n\t\t\tconst newLevel1 = produce(draft.level1, level1Draft => {\n\t\t\t\treturn {...level1Draft}\n\t\t\t})\n\t\t\tdraft.level1 = newLevel1\n\t\t})\n\n\t\tconst nextState2 = produce(state, draft => {\n\t\t\tconst newLevel1 = produce(draft.level1, level1Draft => {\n\t\t\t\treturn {...level1Draft}\n\t\t\t})\n\t\t\treturn {\n\t\t\t\tlevel1: newLevel1\n\t\t\t}\n\t\t})\n\n\t\tconst nextState3 = produce(state, draft => {\n\t\t\tconst newLevel1 = produce(draft.level1, level1Draft => {\n\t\t\t\treturn Object.assign({}, level1Draft)\n\t\t\t})\n\t\t\treturn Object.assign(draft, {\n\t\t\t\tlevel1: newLevel1\n\t\t\t})\n\t\t})\n\n\t\tconst expected = {level1: {level2: {level3: \"data\"}}}\n\t\texpect(nextState1).toEqual(expected)\n\t\texpect(nextState2).toEqual(expected)\n\t\texpect(nextState3).toEqual(expected)\n\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "Something with nested producers #522 ",
            "suites": [
                "base functionality - ",
                "base state type"
            ],
            "updatePoint": {
                "line": 1958,
                "column": 49
            },
            "line": 1958,
            "code": "\tit(`Something with nested producers #522 ${name}`, () => {\n\t\tfunction initialStateFactory() {\n\t\t\treturn {\n\t\t\t\tsubstate: {\n\t\t\t\t\tarray: [\n\t\t\t\t\t\t{id: \"id1\", value: 0},\n\t\t\t\t\t\t{id: \"id2\", value: 0}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tarray: [\n\t\t\t\t\t{id: \"id1\", value: 0},\n\t\t\t\t\t{id: \"id2\", value: 0}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\n\t\tconst globalProducer = produce(draft => {\n\t\t\tdraft.substate = subProducer(draft.substate)\n\t\t\tdraft.array = arrayProducer(draft.array)\n\t\t}, initialStateFactory())\n\n\t\tconst subProducer = produce(draftSubState => {\n\t\t\tdraftSubState.array = arrayProducer(draftSubState.array)\n\t\t})\n\n\t\tconst arrayProducer = produce(draftArray => {\n\t\t\tdraftArray[0].value += 5\n\t\t})\n\n\t\t{\n\t\t\tconst state = globalProducer(undefined)\n\t\t\texpect(state.array[0].value).toBe(5)\n\t\t\texpect(state.array.length).toBe(2)\n\t\t\texpect(state.array[1]).toMatchObject({\n\t\t\t\tid: \"id2\",\n\t\t\t\tvalue: 0\n\t\t\t})\n\t\t}\n\n\t\t{\n\t\t\tconst state = globalProducer(undefined)\n\t\t\texpect(state.substate.array[0].value).toBe(5)\n\t\t\texpect(state.substate.array.length).toBe(2)\n\t\t\texpect(state.substate.array[1]).toMatchObject({\n\t\t\t\tid: \"id2\",\n\t\t\t\tvalue: 0\n\t\t\t})\n\t\t\texpect(state.substate.array).toMatchObject(state.array)\n\t\t}\n\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns true for object drafts",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2010,
                "column": 36
            },
            "line": 2010,
            "code": "\t\tit(\"returns true for object drafts\", () => {\n\t\t\tproduce({}, state => {\n\t\t\t\texpect(isDraft(state)).toBeTruthy()\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns true for array drafts",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2015,
                "column": 35
            },
            "line": 2015,
            "code": "\t\tit(\"returns true for array drafts\", () => {\n\t\t\tproduce([], state => {\n\t\t\t\texpect(isDraft(state)).toBeTruthy()\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns true for objects nested in object drafts",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2020,
                "column": 54
            },
            "line": 2020,
            "code": "\t\tit(\"returns true for objects nested in object drafts\", () => {\n\t\t\tproduce({a: {b: {}}}, state => {\n\t\t\t\texpect(isDraft(state.a)).toBeTruthy()\n\t\t\t\texpect(isDraft(state.a.b)).toBeTruthy()\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns false for new objects added to a draft",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2026,
                "column": 52
            },
            "line": 2026,
            "code": "\t\tit(\"returns false for new objects added to a draft\", () => {\n\t\t\tproduce({}, state => {\n\t\t\t\tstate.a = {}\n\t\t\t\texpect(isDraft(state.a)).toBeFalsy()\n\t\t\t})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns false for objects returned by the producer",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2032,
                "column": 56
            },
            "line": 2032,
            "code": "\t\tit(\"returns false for objects returned by the producer\", () => {\n\t\t\tconst object = produce([], () => Object.create(null))\n\t\t\texpect(isDraft(object)).toBeFalsy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns false for arrays returned by the producer",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2036,
                "column": 55
            },
            "line": 2036,
            "code": "\t\tit(\"returns false for arrays returned by the producer\", () => {\n\t\t\tconst array = produce({}, _ => [])\n\t\t\texpect(isDraft(array)).toBeFalsy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns false for object drafts returned by the producer",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2040,
                "column": 62
            },
            "line": 2040,
            "code": "\t\tit(\"returns false for object drafts returned by the producer\", () => {\n\t\t\tconst object = produce({}, state => state)\n\t\t\texpect(isDraft(object)).toBeFalsy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns false for array drafts returned by the producer",
            "suites": [
                "isDraft - "
            ],
            "updatePoint": {
                "line": 2044,
                "column": 61
            },
            "line": 2044,
            "code": "\t\tit(\"returns false for array drafts returned by the producer\", () => {\n\t\t\tconst array = produce([], state => state)\n\t\t\texpect(isDraft(array)).toBeFalsy()\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "modify deep object",
            "suites": [
                "complex nesting map / set / object"
            ],
            "updatePoint": {
                "line": 2070,
                "column": 26
            },
            "line": 2070,
            "code": "\t\ttest(`modify deep object`, () => {\n\t\t\tconst [res, patches] = produceWithPatches(base, draft => {\n\t\t\t\tconst v = first(draft.map.get(\"set1\"))\n\t\t\t\texpect(original(v)).toBe(a)\n\t\t\t\texpect(v).toEqual(a)\n\t\t\t\texpect(v).not.toBe(a)\n\t\t\t\tv.a++\n\t\t\t})\n\t\t\texpect(res).toMatchSnapshot()\n\t\t\texpect(patches).toMatchSnapshot()\n\t\t\texpect(a.a).toBe(1)\n\t\t\texpect(base.map.get(\"set1\")).toBe(set1)\n\t\t\texpect(first(base.map.get(\"set1\"))).toBe(a)\n\t\t\texpect(res).not.toBe(base)\n\t\t\texpect(res.map).not.toBe(base.map)\n\t\t\texpect(res.map.get(\"set1\")).not.toBe(base.map.get(\"set1\"))\n\t\t\texpect(second(base.map.get(\"set1\"))).toBe(b)\n\t\t\texpect(base.map.get(\"set2\")).toBe(set2)\n\t\t\texpect(first(res.map.get(\"set1\"))).toEqual({a: 2})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "modify deep object - keep value",
            "suites": [
                "complex nesting map / set / object"
            ],
            "updatePoint": {
                "line": 2091,
                "column": 39
            },
            "line": 2091,
            "code": "\t\ttest(`modify deep object - keep value`, () => {\n\t\t\tconst [res, patches] = produceWithPatches(base, draft => {\n\t\t\t\tconst v = first(draft.map.get(\"set1\"))\n\t\t\t\texpect(original(v)).toBe(a)\n\t\t\t\texpect(v).toEqual(a)\n\t\t\t\texpect(v).not.toBe(a)\n\t\t\t\tv.a = 1 // same value\n\t\t\t})\n\t\t\texpect(a.a).toBe(1)\n\t\t\texpect(base.map.get(\"set1\")).toBe(set1)\n\t\t\texpect(first(base.map.get(\"set1\"))).toBe(a)\n\t\t\texpect(res).toBe(base)\n\t\t\texpect(res.map).toBe(base.map)\n\t\t\texpect(res.map.get(\"set1\")).toBe(base.map.get(\"set1\"))\n\t\t\texpect(first(res.map.get(\"set1\"))).toBe(a)\n\t\t\texpect(second(base.map.get(\"set1\"))).toBe(b)\n\t\t\texpect(base.map.get(\"set2\")).toBe(set2)\n\t\t\texpect(patches.length).toBe(0)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "creates a draft",
            "suites": [
                "#613"
            ],
            "updatePoint": {
                "line": 2149,
                "column": 22
            },
            "line": 2149,
            "code": "\t\t\tit(\"creates a draft\", () => {\n\t\t\t\tproduce(base, draft => {\n\t\t\t\t\texpect(draft).not.toBe(base)\n\t\t\t\t\texpect(shallowCopy(draft, true)).toEqual(base)\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "preserves the prototype",
            "suites": [
                "#613"
            ],
            "updatePoint": {
                "line": 2156,
                "column": 30
            },
            "line": 2156,
            "code": "\t\t\tit(\"preserves the prototype\", () => {\n\t\t\t\tconst proto = Object.getPrototypeOf(base)\n\t\t\t\tproduce(base, draft => {\n\t\t\t\t\texpect(Object.getPrototypeOf(draft)).toBe(proto)\n\t\t\t\t})\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns the base state when no changes are made",
            "suites": [
                "#613"
            ],
            "updatePoint": {
                "line": 2163,
                "column": 54
            },
            "line": 2163,
            "code": "\t\t\tit(\"returns the base state when no changes are made\", () => {\n\t\t\t\texpect(produce(base, () => {})).toBe(base)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns a copy when changes are made",
            "suites": [
                "#613"
            ],
            "updatePoint": {
                "line": 2167,
                "column": 43
            },
            "line": 2167,
            "code": "\t\t\tit(\"returns a copy when changes are made\", () => {\n\t\t\t\tconst random = Math.random()\n\t\t\t\tconst result = produce(base, draft => {\n\t\t\t\t\tdraft[0] = random\n\t\t\t\t})\n\t\t\t\texpect(result).not.toBe(base)\n\t\t\t\texpect(result.constructor).toBe(base.constructor)\n\t\t\t\texpect(result[0]).toBe(random)\n\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should use a method to assing a field using a getter that return a non primitive object",
            "suites": [
                "class with getters"
            ],
            "updatePoint": {
                "line": 2195,
                "column": 93
            },
            "line": 2195,
            "code": "\t\tit(\"should use a method to assing a field using a getter that return a non primitive object\", () => {\n\t\t\tconst newState = produce(state, draft => {\n\t\t\t\tdraft.syncFoo()\n\t\t\t})\n\t\t\texpect(newState.foo).toEqual(1)\n\t\t\texpect(newState.bar).toEqual({baz: 2})\n\t\t\texpect(state.bar).toEqual({baz: 1})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should use a method to assing a field using a getter that return a non primitive object",
            "suites": [
                "super class with getters"
            ],
            "updatePoint": {
                "line": 2224,
                "column": 93
            },
            "line": 2224,
            "code": "\t\tit(\"should use a method to assing a field using a getter that return a non primitive object\", () => {\n\t\t\tconst newState = produce(state, draft => {\n\t\t\t\tdraft.syncFoo()\n\t\t\t})\n\t\t\texpect(newState.foo).toEqual(1)\n\t\t\texpect(newState.bar).toEqual({baz: 2})\n\t\t\texpect(state.bar).toEqual({baz: 1})\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should define a field with a setter",
            "suites": [
                "class with setters"
            ],
            "updatePoint": {
                "line": 2247,
                "column": 41
            },
            "line": 2247,
            "code": "\t\tit(\"should define a field with a setter\", () => {\n\t\t\tconst newState3 = produce(state, d => {\n\t\t\t\td.bar = 1\n\t\t\t\texpect(d._bar).toEqual(1)\n\t\t\t})\n\t\t\texpect(newState3._bar).toEqual(1)\n\t\t\texpect(newState3.bar).toEqual(1)\n\t\t\texpect(state._bar).toEqual(0)\n\t\t\texpect(state.bar).toEqual(0)\n\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not return a copy when changes are made",
            "suites": [
                "#620"
            ],
            "updatePoint": {
                "line": 2418,
                "column": 52
            },
            "line": 2418,
            "code": "\t\t\t\tit(\"does not return a copy when changes are made\", () => {\n\t\t\t\t\texpect(() =>\n\t\t\t\t\t\tproduce(value, draft => {\n\t\t\t\t\t\t\tdraft.foo = true\n\t\t\t\t\t\t})\n\t\t\t\t\t).toThrowError(\n\t\t\t\t\t\tisProd\n\t\t\t\t\t\t\t? \"[Immer] minified error nr: 21\"\n\t\t\t\t\t\t\t: \"produce can only be called on things that are draftable\"\n\t\t\t\t\t)\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not create a draft",
            "suites": [
                "#620"
            ],
            "updatePoint": {
                "line": 2430,
                "column": 31
            },
            "line": 2430,
            "code": "\t\t\t\tit(\"does not create a draft\", () => {\n\t\t\t\t\tproduce(value, draft => {\n\t\t\t\t\t\texpect(draft).toBe(value)\n\t\t\t\t\t})\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns the base state when no changes are made",
            "suites": [
                "#620"
            ],
            "updatePoint": {
                "line": 2436,
                "column": 55
            },
            "line": 2436,
            "code": "\t\t\t\tit(\"returns the base state when no changes are made\", () => {\n\t\t\t\t\texpect(produce(value, () => {})).toBe(value)\n\t\t\t\t})",
            "file": "base.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "must be called on draft",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 29
            },
            "line": 26,
            "code": "\t\tit(\"must be called on draft\", () => {\n\t\t\texpect(() => {\n\t\t\t\tcurrent({})\n\t\t\t}).toThrowError(\n\t\t\t\tisProd\n\t\t\t\t\t? \"[Immer] minified error nr: 22 '[object Object]'. Find the full error at: https://bit.ly/3cXEKWf\"\n\t\t\t\t\t: \"[Immer] 'current' expects a draft, got: [object Object]\"\n\t\t\t)\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can handle simple arrays",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 30
            },
            "line": 36,
            "code": "\t\tit(\"can handle simple arrays\", () => {\n\t\t\tconst base = [{x: 1}]\n\t\t\tlet c\n\t\t\tconst next = produce(base, draft => {\n\t\t\t\texpect(current(draft)).toEqual(base)\n\t\t\t\tdraft[0].x++\n\t\t\t\tc = current(draft)\n\t\t\t\texpect(c).toEqual([{x: 2}])\n\t\t\t\texpect(Array.isArray(c))\n\t\t\t\tdraft[0].x++\n\t\t\t})\n\t\t\texpect(next).toEqual([{x: 3}])\n\t\t\texpect(c).toEqual([{x: 2}])\n\t\t\texpect(isDraft(c)).toBe(false)\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "won't freeze",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 18
            },
            "line": 52,
            "code": "\t\tit(\"won't freeze\", () => {\n\t\t\tconst base = {x: 1}\n\t\t\tconst next = produce(base, draft => {\n\t\t\t\tdraft.x++\n\t\t\t\texpect(Object.isFrozen(current(draft))).toBe(false)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "returns original without changes",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 38
            },
            "line": 60,
            "code": "\t\tit(\"returns original without changes\", () => {\n\t\t\tconst base = {}\n\t\t\tproduce(base, draft => {\n\t\t\t\texpect(original(draft)).toBe(base)\n\t\t\t\texpect(current(draft)).toBe(base)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can handle property additions",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 35
            },
            "line": 68,
            "code": "\t\tit(\"can handle property additions\", () => {\n\t\t\tconst base = {}\n\t\t\tproduce(base, draft => {\n\t\t\t\tdraft.x = true\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).not.toBe(base)\n\t\t\t\texpect(c).not.toBe(draft)\n\t\t\t\texpect(c).toEqual({\n\t\t\t\t\tx: true\n\t\t\t\t})\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can handle property deletions",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 35
            },
            "line": 81,
            "code": "\t\tit(\"can handle property deletions\", () => {\n\t\t\tconst base = {\n\t\t\t\tx: 1\n\t\t\t}\n\t\t\tproduce(base, draft => {\n\t\t\t\tdelete draft.x\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).not.toBe(base)\n\t\t\t\texpect(c).not.toBe(draft)\n\t\t\t\texpect(c).toEqual({})\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "won't reflect changes over time",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 37
            },
            "line": 94,
            "code": "\t\tit(\"won't reflect changes over time\", () => {\n\t\t\tconst base = {\n\t\t\t\tx: 1\n\t\t\t}\n\t\t\tproduce(base, draft => {\n\t\t\t\tdraft.x++\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).toEqual({\n\t\t\t\t\tx: 2\n\t\t\t\t})\n\t\t\t\tdraft.x++\n\t\t\t\texpect(c).toEqual({\n\t\t\t\t\tx: 2\n\t\t\t\t})\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "will find drafts inside objects",
            "suites": [],
            "updatePoint": {
                "line": 111,
                "column": 37
            },
            "line": 111,
            "code": "\t\tit(\"will find drafts inside objects\", () => {\n\t\t\tconst base = {\n\t\t\t\tx: 1,\n\t\t\t\ty: {\n\t\t\t\t\tz: 2\n\t\t\t\t},\n\t\t\t\tz: {}\n\t\t\t}\n\t\t\tproduce(base, draft => {\n\t\t\t\tdraft.y.z++\n\t\t\t\tdraft.y = {\n\t\t\t\t\tnested: draft.y\n\t\t\t\t}\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).toEqual({\n\t\t\t\t\tx: 1,\n\t\t\t\t\ty: {\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tz: 3\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tz: {}\n\t\t\t\t})\n\t\t\t\texpect(isDraft(c.y.nested)).toBe(false)\n\t\t\t\texpect(c.z).toBe(base.z)\n\t\t\t\texpect(c.y.nested).not.toBe(draft.y.nested)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "handles map - 1",
            "suites": [],
            "updatePoint": {
                "line": 140,
                "column": 21
            },
            "line": 140,
            "code": "\t\tit(\"handles map - 1\", () => {\n\t\t\tconst base = new Map([[\"a\", {x: 1}]])\n\t\t\tproduce(base, draft => {\n\t\t\t\texpect(current(draft)).toBe(base)\n\t\t\t\tdraft.delete(\"a\")\n\t\t\t\tlet c = current(draft)\n\t\t\t\texpect(current(draft)).not.toBe(base)\n\t\t\t\texpect(current(draft)).not.toBe(draft)\n\t\t\t\texpect(c).toEqual(new Map())\n\t\t\t\tconst obj = {}\n\t\t\t\tdraft.set(\"b\", obj)\n\t\t\t\texpect(c).toEqual(new Map())\n\t\t\t\texpect(current(draft)).toEqual(new Map([[\"b\", obj]]))\n\t\t\t\texpect(c).toBeInstanceOf(Map)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "handles map - 2",
            "suites": [],
            "updatePoint": {
                "line": 157,
                "column": 21
            },
            "line": 157,
            "code": "\t\tit(\"handles map - 2\", () => {\n\t\t\tconst base = new Map([[\"a\", {x: 1}]])\n\t\t\tproduce(base, draft => {\n\t\t\t\tdraft.get(\"a\").x++\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).not.toBe(base)\n\t\t\t\texpect(c).toEqual(new Map([[\"a\", {x: 2}]]))\n\t\t\t\tdraft.get(\"a\").x++\n\t\t\t\texpect(c).toEqual(new Map([[\"a\", {x: 2}]]))\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "handles set",
            "suites": [],
            "updatePoint": {
                "line": 169,
                "column": 17
            },
            "line": 169,
            "code": "\t\tit(\"handles set\", () => {\n\t\t\tconst base = new Set([1])\n\t\t\tproduce(base, draft => {\n\t\t\t\texpect(current(draft)).toBe(base)\n\t\t\t\tdraft.add(2)\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).toEqual(new Set([1, 2]))\n\t\t\t\texpect(c).not.toBe(draft)\n\t\t\t\texpect(c).not.toBe(base)\n\t\t\t\tdraft.add(3)\n\t\t\t\texpect(c).toEqual(new Set([1, 2]))\n\t\t\t\texpect(c).toBeInstanceOf(Set)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "handles simple class",
            "suites": [],
            "updatePoint": {
                "line": 184,
                "column": 26
            },
            "line": 184,
            "code": "\t\tit(\"handles simple class\", () => {\n\t\t\tclass Counter {\n\t\t\t\t[immerable] = true\n\t\t\t\tcurrent = 0\n\n\t\t\t\tinc() {\n\t\t\t\t\tthis.current++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst counter1 = new Counter()\n\t\t\tproduce(counter1, draft => {\n\t\t\t\texpect(current(draft)).toBe(counter1)\n\t\t\t\tdraft.inc()\n\t\t\t\tconst c = current(draft)\n\t\t\t\texpect(c).not.toBe(draft)\n\t\t\t\texpect(c.current).toBe(1)\n\t\t\t\tc.inc()\n\t\t\t\texpect(c.current).toBe(2)\n\t\t\t\texpect(draft.current).toBe(1)\n\t\t\t\tdraft.inc()\n\t\t\t\tdraft.inc()\n\t\t\t\texpect(c.current).toBe(2)\n\t\t\t\texpect(draft.current).toBe(3)\n\t\t\t\texpect(c).toBeInstanceOf(Counter)\n\t\t\t})\n\t\t})",
            "file": "current.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should check arguments",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 28
            },
            "line": 19,
            "code": "\t\tit(\"should check arguments\", () => {\n\t\t\texpect(() => produce()).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => produce({})).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => produce({}, {})).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => produce({}, () => {}, [])).toThrowErrorMatchingSnapshot()\n\t\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should support currying",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 29
            },
            "line": 26,
            "code": "\t\tit(\"should support currying\", () => {\n\t\t\tconst state = [{}, {}, {}]\n\t\t\tconst mapper = produce((item, index) => {\n\t\t\t\titem.index = index\n\t\t\t})\n\n\t\t\texpect(state.map(mapper)).not.toBe(state)\n\t\t\texpect(state.map(mapper)).toEqual([{index: 0}, {index: 1}, {index: 2}])\n\t\t\texpect(state).toEqual([{}, {}, {}])\n\t\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should support returning new states from curring",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 54
            },
            "line": 37,
            "code": "\t\tit(\"should support returning new states from curring\", () => {\n\t\t\tconst reducer = produce((item, index) => {\n\t\t\t\tif (!item) {\n\t\t\t\t\treturn {hello: \"world\"}\n\t\t\t\t}\n\t\t\t\titem.index = index\n\t\t\t})\n\n\t\t\texpect(reducer(undefined, 3)).toEqual({hello: \"world\"})\n\t\t\texpect(reducer({}, 3)).toEqual({index: 3})\n\t\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should support passing an initial state as second argument",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 64
            },
            "line": 49,
            "code": "\t\tit(\"should support passing an initial state as second argument\", () => {\n\t\t\tconst reducer = produce(\n\t\t\t\t(item, index) => {\n\t\t\t\t\titem.index = index\n\t\t\t\t},\n\t\t\t\t{hello: \"world\"}\n\t\t\t)\n\n\t\t\texpect(reducer(undefined, 3)).toEqual({hello: \"world\", index: 3})\n\t\t\texpect(reducer({}, 3)).toEqual({index: 3})\n\t\t\texpect(reducer()).toEqual({hello: \"world\", index: undefined})\n\t\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can has fun with change detection",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 39
            },
            "line": 62,
            "code": "\t\tit(\"can has fun with change detection\", () => {\n\t\t\tconst spread = produce(Object.assign)\n\n\t\t\tconst base = {\n\t\t\t\tx: 1,\n\t\t\t\ty: 1\n\t\t\t}\n\n\t\t\texpect({...base}).not.toBe(base)\n\t\t\texpect(spread(base, {})).toBe(base)\n\t\t\texpect(spread(base, {y: 1})).toBe(base)\n\t\t\texpect(spread(base, {...base})).toBe(base)\n\t\t\texpect(spread(base, {...base, y: 2})).not.toBe(base)\n\t\t\texpect(spread(base, {...base, y: 2})).toEqual({x: 1, y: 2})\n\t\t\texpect(spread(base, {z: 3})).toEqual({x: 1, y: 1, z: 3})\n\t\t\texpect(spread(base, {y: 1})).toBe(base)\n\t\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "support currying for produceWithPatches",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 44
            },
            "line": 81,
            "code": "\tit(\"support currying for produceWithPatches\", () => {\n\t\tconst increment = produceWithPatches((draft, delta) => {\n\t\t\tdraft.x += delta\n\t\t})\n\n\t\texpect(increment({x: 5}, 2)).toEqual([\n\t\t\t{x: 7},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [\"x\"],\n\t\t\t\t\tvalue: 7\n\t\t\t\t}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [\"x\"],\n\t\t\t\t\tvalue: 5\n\t\t\t\t}\n\t\t\t]\n\t\t])\n\t})",
            "file": "curry.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "draft.ts",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 14
            },
            "line": 15,
            "code": "test(\"draft.ts\", () => {\n\t// Tuple\n\t{\n\t\tlet val: [1, 2] = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Tuple (nested in a tuple)\n\t{\n\t\tlet val: [[1, 2]] = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Tuple (nested in two mutable arrays)\n\t{\n\t\tlet val: [1, 2][][] = _\n\t\tlet draft: typeof val = _\n\t\tval = assert(toDraft(val), draft)\n\t\tassert(fromDraft(draft), val)\n\t}\n\n\t// Tuple (nested in two readonly arrays)\n\t{\n\t\tlet val: ReadonlyArray<ReadonlyArray<[1, 2]>> = _\n\t\tlet draft: [1, 2][][] = _\n\t\tval = assert(toDraft(val), draft)\n\t}\n\n\t// Readonly tuple\n\t{\n\t\t// TODO: Uncomment this when readonly tuples are supported.\n\t\t//       More info: https://stackoverflow.com/a/53822074/2228559\n\t\t// let val: Readonly<[1, 2]> = _\n\t\t// let draft: [1, 2] = _\n\t\t// draft = assert(toDraft(val), draft)\n\t\t// val = fromDraft(draft)\n\t}\n\n\t// Mutable array\n\t{\n\t\tlet val: string[] = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Mutable array (nested in tuple)\n\t{\n\t\tlet val: [string[]] = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Readonly array\n\t{\n\t\tlet val: ReadonlyArray<string> = _\n\t\tlet draft: string[] = _\n\t\tval = assert(toDraft(val), draft)\n\t\tfromDraft(draft)\n\t}\n\n\t// Readonly array (nested in readonly object)\n\t{\n\t\tlet val: {readonly a: ReadonlyArray<string>} = _\n\t\tlet draft: {a: string[]} = _\n\t\tval = assert(toDraft(val), draft)\n\t\tfromDraft(draft)\n\t}\n\n\t// Mutable object\n\t{\n\t\tlet val: {a: 1} = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Mutable object (nested in mutable object)\n\t{\n\t\tlet val: {a: {b: 1}} = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Interface\n\t{\n\t\tinterface Foo {\n\t\t\ta: {b: number}\n\t\t}\n\t\tlet val: Foo = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Interface (nested in interface)\n\t{\n\t\tinterface Foo {\n\t\t\ta: {b: number}\n\t\t}\n\t\tinterface Bar {\n\t\t\tfoo: Foo\n\t\t}\n\t\tlet val: Bar = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Readonly object\n\t{\n\t\tlet val: {readonly a: 1} = _\n\t\tlet draft: {a: 1} = _\n\t\tval = assert(toDraft(val), draft)\n\t}\n\n\t// Readonly object (nested in tuple)\n\t{\n\t\tlet val: [{readonly a: 1}] = _\n\t\tlet draft: [{a: 1}] = _\n\t\tval = assert(toDraft(val), draft)\n\t}\n\n\t// Loose function\n\t{\n\t\tlet val: Function = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Strict function\n\t{\n\t\tlet val: () => void = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Class type (mutable)\n\t{\n\t\tclass Foo {\n\t\t\tprivate test: any\n\t\t\tconstructor(public bar: string) {}\n\t\t}\n\t\tlet val: Foo = _\n\t\t// TODO: Uncomment this when plain object types can be distinguished from class types.\n\t\t//       More info here: https://github.com/Microsoft/TypeScript/issues/29063\n\t\t// assert(toDraft(val), val)\n\t\t// assert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Class type (readonly)\n\t{\n\t\tclass Foo {\n\t\t\tprivate test: any\n\t\t\tconstructor(readonly bar: string) {}\n\t\t}\n\t\tlet val: Foo = _\n\t\t// TODO: Uncomment this when plain object types can be distinguished from class types.\n\t\t//       More info here: https://github.com/Microsoft/TypeScript/issues/29063\n\t\t// assert(toDraft(val), val)\n\t\t// assert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Map instance\n\t{\n\t\tlet val: Map<any, any> = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\n\t\t// Weak maps\n\t\tlet weak: WeakMap<any, any> = _\n\t\tassert(toDraft(weak), weak)\n\t\tassert(fromDraft(toDraft(weak)), weak)\n\t}\n\n\t// ReadonlyMap instance\n\t{\n\t\tlet val: ReadonlyMap<any, any> = _\n\t\tlet draft: Map<any, any> = _\n\t\tassert(toDraft(val), draft)\n\t}\n\n\t// Set instance\n\t{\n\t\tlet val: Set<any> = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\n\t\t// Weak sets\n\t\tlet weak: WeakSet<any> = _\n\t\tassert(toDraft(weak), weak)\n\t\tassert(fromDraft(toDraft(weak)), weak)\n\t}\n\n\t// ReadonlySet instance\n\t{\n\t\tlet val: ReadonlySet<any> = _\n\t\tlet draft: Set<any> = _\n\t\tassert(toDraft(val), draft)\n\t}\n\n\t// Promise object\n\t{\n\t\tlet val: Promise<any> = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Date instance\n\t{\n\t\tlet val: Date = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// RegExp instance\n\t{\n\t\tlet val: RegExp = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Boxed primitive\n\t{\n\t\tlet val: Boolean = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// String literal\n\t{\n\t\tlet val: string = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Any\n\t{\n\t\tlet val: any = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Never\n\t{\n\t\tlet val: never = _ as never\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Unknown\n\t{\n\t\tlet val: unknown = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Numeral\n\t{\n\t\tlet val: 1 = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Union of numerals\n\t{\n\t\tlet val: 1 | 2 | 3 = _\n\t\tassert(toDraft(val), val)\n\t\tassert(fromDraft(toDraft(val)), val)\n\t}\n\n\t// Union of tuple, array, object\n\t{\n\t\tlet val: [0] | ReadonlyArray<string> | Readonly<{a: 1}> = _\n\t\tlet draft: [0] | string[] | {a: 1} = _\n\t\tval = assert(toDraft(val), draft)\n\t}\n\n\t// Generic type\n\t{\n\t\t// NOTE: \"extends any\" only helps a little.\n\t\tconst $ = <T extends any>(val: ReadonlyArray<T>) => {\n\t\t\tlet draft: Draft<typeof val> = _\n\t\t\tassert(toDraft(val), draft)\n\t\t\t// $ExpectError: [ts] Argument of type 'DraftArray<T>' is not assignable to parameter of type 'Draft<T>'. [2345]\n\t\t\t// assert(fromDraft(draft), draft)\n\t\t}\n\t}\n\n\texpect(true).toBe(true)\n})",
            "file": "draft.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "castDraft",
            "suites": [],
            "updatePoint": {
                "line": 305,
                "column": 15
            },
            "line": 305,
            "code": "test(\"castDraft\", () => {\n\ttype Todo = {readonly done: boolean}\n\n\ttype State = {\n\t\treadonly finishedTodos: ReadonlyArray<Todo>\n\t\treadonly unfinishedTodos: ReadonlyArray<Todo>\n\t}\n\n\tfunction markAllFinished(state: State) {\n\t\tproduce(state, draft => {\n\t\t\tdraft.finishedTodos = castDraft(state.unfinishedTodos)\n\t\t})\n\t}\n})",
            "file": "draft.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#505 original",
            "suites": [],
            "updatePoint": {
                "line": 320,
                "column": 19
            },
            "line": 320,
            "code": "test(\"#505 original\", () => {\n\tconst baseState = {users: [{name: \"Richie\"}] as const}\n\tconst nextState = produce(baseState, draftState => {\n\t\toriginal(draftState.users) === baseState.users\n\t})\n})",
            "file": "draft.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "castDraft preserves a value",
            "suites": [],
            "updatePoint": {
                "line": 327,
                "column": 33
            },
            "line": 327,
            "code": "test(\"castDraft preserves a value\", () => {\n\tconst x = {}\n\texpect(castDraft(x)).toBe(x)\n})",
            "file": "draft.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#512 createDraft creates a draft",
            "suites": [],
            "updatePoint": {
                "line": 332,
                "column": 38
            },
            "line": 332,
            "code": "test(\"#512 createDraft creates a draft\", () => {\n\tconst x = {y: 1}\n\tassert(x, _ as Draft<{y: number}>)\n})",
            "file": "draft.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "empty stub test",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 21
            },
            "line": 13,
            "code": "test(\"empty stub test\", () => {\n\texpect(true).toBe(true)\n})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign set value",
            "suites": [
                "map set - es5"
            ],
            "updatePoint": {
                "line": 18,
                "column": 27
            },
            "line": 18,
            "code": "\ttest(\"can assign set value\", () => {\n\t\tsetUseProxies(false)\n\n\t\tconst baseState = new Map([[\"x\", 1]])\n\t\tdebugger\n\t\tconst nextState = produce(baseState, s => {\n\t\t\ts.set(\"x\", 2)\n\t\t})\n\t\texpect(baseState.get(\"x\")).toEqual(1)\n\t\texpect(nextState).not.toBe(baseState)\n\t\texpect(nextState.get(\"x\")).toEqual(2)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign by key",
            "suites": [
                "map set - es5"
            ],
            "updatePoint": {
                "line": 31,
                "column": 24
            },
            "line": 31,
            "code": "\ttest(\"can assign by key\", () => {\n\t\tsetUseProxies(false)\n\n\t\tconst baseState = new Map([[\"x\", {a: 1}]])\n\t\tconst nextState = produce(baseState, s => {\n\t\t\ts.get(\"x\")!.a++\n\t\t})\n\t\texpect(nextState.get(\"x\")!.a).toEqual(2)\n\t\texpect(baseState.get(\"x\")!.a).toEqual(1)\n\t\texpect(nextState).not.toBe(baseState)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign set value",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 45,
                "column": 27
            },
            "line": 45,
            "code": "\ttest(\"can assign set value\", () => {\n\t\tsetUseProxies(true)\n\n\t\tconst baseState = new Map([[\"x\", 1]])\n\t\tconst nextState = produce(baseState, s => {\n\t\t\ts.set(\"x\", 2)\n\t\t})\n\t\texpect(baseState.get(\"x\")).toEqual(1)\n\t\texpect(nextState).not.toBe(baseState)\n\t\texpect(nextState.get(\"x\")).toEqual(2)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign by key",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 57,
                "column": 24
            },
            "line": 57,
            "code": "\ttest(\"can assign by key\", () => {\n\t\tsetUseProxies(true)\n\n\t\tconst baseState = new Map([[\"x\", {a: 1}]])\n\t\tconst nextState = produce(baseState, s => {\n\t\t\ts.get(\"x\")!.a++\n\t\t})\n\t\texpect(nextState.get(\"x\")!.a).toEqual(2)\n\t\texpect(baseState.get(\"x\")!.a).toEqual(1)\n\t\texpect(nextState).not.toBe(baseState)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "deep change bubbles up",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 69,
                "column": 29
            },
            "line": 69,
            "code": "\ttest(\"deep change bubbles up\", () => {\n\t\tsetUseProxies(true)\n\n\t\tconst baseState = createBaseState()\n\t\tconst nextState = produce(baseState, s => {\n\t\t\ts.anObject.nested.yummie = false\n\t\t})\n\t\texpect(nextState).not.toBe(baseState)\n\t\texpect(nextState.anObject).not.toBe(baseState.anObject)\n\t\texpect(baseState.anObject.nested.yummie).toBe(true)\n\t\texpect(nextState.anObject.nested.yummie).toBe(false)\n\t\texpect(nextState.anArray).toBe(baseState.anArray)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can assign by key",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 83,
                "column": 22
            },
            "line": 83,
            "code": "\tit(\"can assign by key\", () => {\n\t\tsetUseProxies(true)\n\t\tconst baseState = createBaseState()\n\n\t\tconst nextState = produce(baseState, s => {\n\t\t\t// Map.prototype.set should return the Map itself\n\t\t\tconst res = s.aMap.set(\"force\", true)\n\t\t\t// @ts-ignore\n\t\t\tif (!global.USES_BUILD)\n\t\t\t\texpect(res).toBe((s.aMap as any)[DRAFT_STATE].draft_)\n\t\t})\n\t\texpect(nextState).not.toBe(baseState)\n\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\texpect(nextState.aMap.get(\"force\")).toEqual(true)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can use 'delete' to remove items",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 99,
                "column": 37
            },
            "line": 99,
            "code": "\tit(\"can use 'delete' to remove items\", () => {\n\t\tconst baseState = createBaseState()\n\n\t\tconst nextState = produce(baseState, s => {\n\t\t\texpect(s.aMap.has(\"jedi\")).toBe(true)\n\t\t\texpect(s.aMap.delete(\"jedi\")).toBe(true)\n\t\t\texpect(s.aMap.has(\"jedi\")).toBe(false)\n\t\t})\n\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\texpect(nextState.aMap.size).toBe(baseState.aMap.size - 1)\n\t\texpect(baseState.aMap.has(\"jedi\")).toBe(true)\n\t\texpect(nextState.aMap.has(\"jedi\")).toBe(false)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "support 'has'",
            "suites": [
                "map set - proxy"
            ],
            "updatePoint": {
                "line": 113,
                "column": 18
            },
            "line": 113,
            "code": "\tit(\"support 'has'\", () => {\n\t\tconst baseState = createBaseState()\n\n\t\tconst nextState = produce(baseState, s => {\n\t\t\texpect(s.aMap.has(\"newKey\")).toBe(false)\n\t\t\ts.aMap.set(\"newKey\", true)\n\t\t\texpect(s.aMap.has(\"newKey\")).toBe(true)\n\t\t})\n\t\texpect(nextState).not.toBe(baseState)\n\t\texpect(nextState.aMap).not.toBe(baseState.aMap)\n\t\texpect(baseState.aMap.has(\"newKey\")).toBe(false)\n\t\texpect(nextState.aMap.has(\"newKey\")).toBe(true)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "bla",
            "suites": [
                "#768"
            ],
            "updatePoint": {
                "line": 170,
                "column": 10
            },
            "line": 170,
            "code": "\ttest(\"bla\", () => {\n\t\t// Set up conditions to produce the error\n\t\tconst errorProducingPatch = [\n\t\t\t{\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [\"stock\"],\n\t\t\t\tvalue: new Stock(200)\n\t\t\t}\n\t\t] as Patch[]\n\n\t\t// Start with modified state\n\t\tconst state = {\n\t\t\tstock: new Stock(100)\n\t\t}\n\n\t\texpect(state.stock.price).toEqual(100)\n\t\texpect(state.stock[immerable]).toBeTruthy()\n\t\t// Use patch to \"replace\" stocks\n\t\tdebugger\n\t\tconst resetState: State = applyPatches(state, errorProducingPatch)\n\t\texpect(state.stock.price).toEqual(100)\n\t\texpect(resetState.stock.price).toEqual(200)\n\t\texpect(resetState.stock[immerable]).toBeTruthy()\n\n\t\t// Problems come in when resetState is modified\n\t\tconst updatedState = produce(resetState, draft => {\n\t\t\tdraft.stock.pushPrice(300)\n\t\t})\n\t\texpect(state.stock.price).toEqual(100)\n\t\texpect(updatedState.stock.price).toEqual(300)\n\t\texpect(updatedState.stock[immerable]).toBeTruthy()\n\t\texpect(resetState.stock.price).toEqual(200)\n\t})",
            "file": "empty.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never freezes the base state",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 34
            },
            "line": 23,
            "code": "\t\tit(\"never freezes the base state\", () => {\n\t\t\tconst base = {arr: [1], obj: {a: 1}}\n\t\t\tconst next = produce(base, draft => {\n\t\t\t\tdraft.arr.push(1)\n\t\t\t})\n\t\t\texpect(isFrozen(base)).toBeFalsy()\n\t\t\texpect(isFrozen(base.arr)).toBeFalsy()\n\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\texpect(isFrozen(next.arr)).toBeTruthy()\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "freezes reused base state",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 31
            },
            "line": 34,
            "code": "\t\tit(\"freezes reused base state\", () => {\n\t\t\tconst base = {arr: [1], obj: {a: 1}}\n\t\t\tconst next = produce(base, draft => {\n\t\t\t\tdraft.arr.push(1)\n\t\t\t})\n\t\t\texpect(next.obj).toBe(base.obj)\n\t\t\texpect(isFrozen(next.obj)).toBeTruthy()\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "the root draft is mutated (and no error is thrown)",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 44,
                "column": 57
            },
            "line": 44,
            "code": "\t\t\tit(\"the root draft is mutated (and no error is thrown)\", () => {\n\t\t\t\tconst base = {}\n\t\t\t\tconst next = produce(base, draft => {\n\t\t\t\t\tdraft.a = 1\n\t\t\t\t})\n\t\t\t\texpect(next).not.toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a nested draft is mutated (and no error is thrown)",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 53,
                "column": 57
            },
            "line": 53,
            "code": "\t\t\tit(\"a nested draft is mutated (and no error is thrown)\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, draft => {\n\t\t\t\t\tdraft.a.b = 1\n\t\t\t\t})\n\t\t\t\texpect(next).not.toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a new object replaces the entire draft",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 63,
                "column": 45
            },
            "line": 63,
            "code": "\t\t\tit(\"a new object replaces the entire draft\", () => {\n\t\t\t\tconst obj = {a: {b: {}}}\n\t\t\t\tconst next = produce({}, () => obj)\n\t\t\t\texpect(next).toBe(obj)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a.b)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a new object is added to the root draft",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 72,
                "column": 46
            },
            "line": 72,
            "code": "\t\t\tit(\"a new object is added to the root draft\", () => {\n\t\t\t\tconst base = {}\n\t\t\t\tconst next = produce(base, draft => {\n\t\t\t\t\tdraft.a = {b: []}\n\t\t\t\t})\n\t\t\t\texpect(next).not.toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.b)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a new object is added to a nested draft",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 83,
                "column": 46
            },
            "line": 83,
            "code": "\t\t\tit(\"a new object is added to a nested draft\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, draft => {\n\t\t\t\t\tdraft.a.b = {c: {}}\n\t\t\t\t})\n\t\t\t\texpect(next).not.toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a.b)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a.b.c)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a nested draft is returned",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 95,
                "column": 33
            },
            "line": 95,
            "code": "\t\t\tit(\"a nested draft is returned\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, draft => draft.a)\n\t\t\t\texpect(next).toBe(base.a)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "the base state is returned",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 102,
                "column": 33
            },
            "line": 102,
            "code": "\t\t\tit(\"the base state is returned\", () => {\n\t\t\t\tconst base = {}\n\t\t\t\tconst next = produce(base, () => base)\n\t\t\t\texpect(next).toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "the producer is a no-op",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 109,
                "column": 30
            },
            "line": 109,
            "code": "\t\t\tit(\"the producer is a no-op\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, () => {})\n\t\t\t\texpect(next).toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "the root draft is returned",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 117,
                "column": 33
            },
            "line": 117,
            "code": "\t\t\tit(\"the root draft is returned\", () => {\n\t\t\t\tconst base = {a: {}}\n\t\t\t\tconst next = produce(base, draft => draft)\n\t\t\t\texpect(next).toBe(base)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "a new object replaces a primitive base",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 125,
                "column": 45
            },
            "line": 125,
            "code": "\t\t\tit(\"a new object replaces a primitive base\", () => {\n\t\t\t\tconst obj = {a: {}}\n\t\t\t\tconst next = produce(null, () => obj)\n\t\t\t\texpect(next).toBe(obj)\n\t\t\t\texpect(isFrozen(next)).toBeTruthy()\n\t\t\t\texpect(isFrozen(next.a)).toBeTruthy()\n\t\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can handle already frozen trees",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 134,
                "column": 37
            },
            "line": 134,
            "code": "\t\tit(\"can handle already frozen trees\", () => {\n\t\t\tconst a = []\n\t\t\tconst b = {a: a}\n\t\t\tObject.freeze(a)\n\t\t\tObject.freeze(b)\n\t\t\tconst n = produce(b, draft => {\n\t\t\t\tdraft.c = true\n\t\t\t\tdraft.a.push(3)\n\t\t\t})\n\t\t\texpect(n).toEqual({c: true, a: [3]})\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "will freeze maps",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 146,
                "column": 22
            },
            "line": 146,
            "code": "\t\tit(\"will freeze maps\", () => {\n\t\t\tconst base = new Map()\n\n\t\t\tconst res = produce(base, draft => {\n\t\t\t\tdraft.set(\"a\", 1)\n\t\t\t})\n\t\t\texpect(() => res.set(\"b\", 2)).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => res.clear()).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => res.delete(\"b\")).toThrowErrorMatchingSnapshot()\n\n\t\t\t// In draft, still editable\n\t\t\texpect(produce(res, d => void d.set(\"a\", 2))).not.toBe(res)\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "will freeze sets",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 160,
                "column": 22
            },
            "line": 160,
            "code": "\t\tit(\"will freeze sets\", () => {\n\t\t\tconst base = new Set()\n\t\t\tconst res = produce(base, draft => {\n\t\t\t\tbase.add(1)\n\t\t\t})\n\t\t\texpect(() => base.add(2)).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => base.delete(1)).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => base.clear()).toThrowErrorMatchingSnapshot()\n\n\t\t\t// In draft, still editable\n\t\t\texpect(produce(res, d => void d.add(2))).not.toBe(res)\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "Map#get() of frozen object will became draftable",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 173,
                "column": 54
            },
            "line": 173,
            "code": "\t\tit(\"Map#get() of frozen object will became draftable\", () => {\n\t\t\tconst base = {\n\t\t\t\tmap: new Map([\n\t\t\t\t\t[\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t[\"a\", true],\n\t\t\t\t\t\t\t[\"b\", true],\n\t\t\t\t\t\t\t[\"c\", true]\n\t\t\t\t\t\t])\n\t\t\t\t\t],\n\t\t\t\t\t[\"b\", new Map([[\"a\", true]])],\n\t\t\t\t\t[\"c\", new Map([[\"a\", true]])]\n\t\t\t\t])\n\t\t\t}\n\n\t\t\t// This will freeze maps\n\t\t\tconst frozen = produce(base, draft => {})\n\n\t\t\t// https://github.com/immerjs/immer/issues/472\n\t\t\tproduce(frozen, draft => {\n\t\t\t\t;[\"b\", \"c\"].forEach(other => {\n\t\t\t\t\tconst m = draft.map.get(other)\n\n\t\t\t\t\tm.delete(\"a\")\n\t\t\t\t})\n\t\t\t})\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never freezes non-enumerable fields #590",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 202,
                "column": 46
            },
            "line": 202,
            "code": "\t\tit(\"never freezes non-enumerable fields #590\", () => {\n\t\t\tconst component = {}\n\t\t\tObject.defineProperty(component, \"state\", {\n\t\t\t\tvalue: {x: 1},\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\n\t\t\tconst state = {\n\t\t\t\tx: 1\n\t\t\t}\n\n\t\t\tconst state2 = produce(state, draft => {\n\t\t\t\tdraft.ref = component\n\t\t\t})\n\n\t\t\texpect(() => {\n\t\t\t\tstate2.ref.state.x++\n\t\t\t}).not.toThrow()\n\t\t\texpect(state2.ref.state.x).toBe(2)\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "never freezes symbolic fields #590",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 225,
                "column": 40
            },
            "line": 225,
            "code": "\t\tit(\"never freezes symbolic fields #590\", () => {\n\t\t\tconst component = {}\n\t\t\tconst symbol = Symbol(\"test\")\n\t\t\tObject.defineProperty(component, symbol, {\n\t\t\t\tvalue: {x: 1},\n\t\t\t\tenumerable: true,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\n\t\t\tconst state = {\n\t\t\t\tx: 1\n\t\t\t}\n\n\t\t\tconst state2 = produce(state, draft => {\n\t\t\t\tdraft.ref = component\n\t\t\t})\n\n\t\t\texpect(() => {\n\t\t\t\tstate2.ref[symbol].x++\n\t\t\t}).not.toThrow()\n\t\t\texpect(state2.ref[symbol].x).toBe(2)\n\t\t})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "freeze - shallow",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 251,
                "column": 22
            },
            "line": 251,
            "code": "test(\"freeze - shallow\", () => {\n\tconst obj1 = {hello: {world: true}}\n\tconst res = freeze(obj1)\n\n\texpect(res).toBe(obj1)\n\texpect(Object.isFrozen(res)).toBe(true)\n\texpect(Object.isFrozen(res.hello)).toBe(false)\n})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "freeze - deep",
            "suites": [
                "the result is always auto-frozen when"
            ],
            "updatePoint": {
                "line": 260,
                "column": 19
            },
            "line": 260,
            "code": "test(\"freeze - deep\", () => {\n\tconst obj1 = {hello: {world: true}}\n\tconst res = freeze(obj1, true)\n\n\texpect(res).toBe(obj1)\n\texpect(Object.isFrozen(res)).toBe(true)\n\texpect(Object.isFrozen(res.hello)).toBe(true)\n})",
            "file": "frozen.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "types are ok",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 18
            },
            "line": 6,
            "code": "test(\"types are ok\", () => {\n\t// array in tuple\n\t{\n\t\tlet val = _ as Immutable<[string[], 1]>\n\t\tassert(val, _ as readonly [ReadonlyArray<string>, 1])\n\t}\n\n\t// tuple in array\n\t{\n\t\tlet val = _ as Immutable<[string, 1][]>\n\t\tassert(val, _ as ReadonlyArray<readonly [string, 1]>)\n\t}\n\n\t// tuple in tuple\n\t{\n\t\tlet val = _ as Immutable<[[string, 1], 1]>\n\t\tassert(val, _ as readonly [readonly [string, 1], 1])\n\t}\n\n\t// array in array\n\t{\n\t\tlet val = _ as Immutable<string[][]>\n\t\tassert(val, _ as ReadonlyArray<ReadonlyArray<string>>)\n\t}\n\n\t// tuple in object\n\t{\n\t\tlet val = _ as Immutable<{a: [string, 1]}>\n\t\tassert(val, _ as {readonly a: readonly [string, 1]})\n\t}\n\n\t// object in tuple\n\t{\n\t\tlet val = _ as Immutable<[{a: string}, 1]>\n\t\tassert(val, _ as readonly [{readonly a: string}, 1])\n\t}\n\n\t// array in object\n\t{\n\t\tlet val = _ as Immutable<{a: string[]}>\n\t\tassert(val, _ as {readonly a: ReadonlyArray<string>})\n\t}\n\n\t// object in array\n\t{\n\t\tlet val = _ as Immutable<Array<{a: string}>>\n\t\tassert(val, _ as ReadonlyArray<{readonly a: string}>)\n\t}\n\n\t// object in object\n\t{\n\t\tlet val = _ as Immutable<{a: {b: string}}>\n\t\tassert(val, _ as {readonly a: {readonly b: string}})\n\t}\n\n\t// Map\n\t{\n\t\tlet val = _ as Immutable<Map<string, string>>\n\t\tassert(val, _ as ReadonlyMap<string, string>)\n\t}\n\n\t// Already immutable Map\n\t{\n\t\tlet val = _ as Immutable<ReadonlyMap<string, string>>\n\t\tassert(val, _ as ReadonlyMap<string, string>)\n\t}\n\n\t// object in Map\n\t{\n\t\tlet val = _ as Immutable<Map<{a: string}, {b: string}>>\n\t\tassert(val, _ as ReadonlyMap<{readonly a: string}, {readonly b: string}>)\n\t}\n\n\t// Set\n\t{\n\t\tlet val = _ as Immutable<Set<string>>\n\t\tassert(val, _ as ReadonlySet<string>)\n\t}\n\n\t// Already immutable Set\n\t{\n\t\tlet val = _ as Immutable<ReadonlySet<string>>\n\t\tassert(val, _ as ReadonlySet<string>)\n\t}\n\n\t// object in Set\n\t{\n\t\tlet val = _ as Immutable<Set<{a: string}>>\n\t\tassert(val, _ as ReadonlySet<{readonly a: string}>)\n\t}\n\n\texpect(true).toBe(true)\n})",
            "file": "immutable.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#381 produce immutable state",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 34
            },
            "line": 100,
            "code": "test(\"#381 produce immutable state\", () => {\n\tconst someState = {\n\t\ttodos: [\n\t\t\t{\n\t\t\t\tdone: false\n\t\t\t}\n\t\t]\n\t}\n\n\tconst immutable = castImmutable(produce(someState, _draft => {}))\n\tassert(\n\t\timmutable,\n\t\t_ as {readonly todos: ReadonlyArray<{readonly done: boolean}>}\n\t)\n})",
            "file": "immutable.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "castImmutable preserves a value",
            "suites": [],
            "updatePoint": {
                "line": 116,
                "column": 37
            },
            "line": 116,
            "code": "test(\"castImmutable preserves a value\", () => {\n\tconst x = {}\n\texpect(castImmutable(x)).toBe(x)\n})",
            "file": "immutable.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should check arguments",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 28
            },
            "line": 24,
            "code": "\t\tit(\"should check arguments\", () => {\n\t\t\texpect(() => createDraft(3)).toThrowErrorMatchingSnapshot()\n\t\t\tconst buf = Buffer.from([])\n\t\t\texpect(() => createDraft(buf)).toThrowErrorMatchingSnapshot()\n\t\t\texpect(() => finishDraft({})).toThrowErrorMatchingSnapshot()\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should support manual drafts",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 34
            },
            "line": 31,
            "code": "\t\tit(\"should support manual drafts\", () => {\n\t\t\tconst state = [{}, {}, {}]\n\n\t\t\tconst draft = createDraft(state)\n\t\t\tdraft.forEach((item, index) => {\n\t\t\t\titem.index = index\n\t\t\t})\n\n\t\t\tconst result = finishDraft(draft)\n\n\t\t\texpect(result).not.toBe(state)\n\t\t\texpect(result).toEqual([{index: 0}, {index: 1}, {index: 2}])\n\t\t\texpect(state).toEqual([{}, {}, {}])\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot modify after finish",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 33
            },
            "line": 47,
            "code": "\t\t\tit(\"cannot modify after finish\", () => {\n\t\t\t\tconst state = {a: 1}\n\n\t\t\t\tconst draft = createDraft(state)\n\t\t\t\tdraft.a = 2\n\t\t\t\texpect(finishDraft(draft)).toEqual({a: 2})\n\t\t\t\texpect(() => {\n\t\t\t\t\tdraft.a = 3\n\t\t\t\t}).toThrowErrorMatchingSnapshot()\n\t\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should support patches drafts",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 35
            },
            "line": 58,
            "code": "\t\tit(\"should support patches drafts\", () => {\n\t\t\tconst state = {a: 1}\n\n\t\t\tconst draft = createDraft(state)\n\t\t\tdraft.a = 2\n\t\t\tdraft.b = 3\n\n\t\t\tconst listener = jest.fn()\n\t\t\tconst result = finishDraft(draft, listener)\n\n\t\t\texpect(result).not.toBe(state)\n\t\t\texpect(result).toEqual({a: 2, b: 3})\n\t\t\texpect(listener.mock.calls).toMatchSnapshot()\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should handle multiple create draft calls",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 47
            },
            "line": 73,
            "code": "\t\tit(\"should handle multiple create draft calls\", () => {\n\t\t\tconst state = {a: 1}\n\n\t\t\tconst draft = createDraft(state)\n\t\t\tdraft.a = 2\n\n\t\t\tconst draft2 = createDraft(state)\n\t\t\tdraft2.b = 3\n\n\t\t\tconst result = finishDraft(draft)\n\n\t\t\texpect(result).not.toBe(state)\n\t\t\texpect(result).toEqual({a: 2})\n\n\t\t\tdraft2.a = 4\n\t\t\tconst result2 = finishDraft(draft2)\n\t\t\texpect(result2).not.toBe(result)\n\t\t\texpect(result2).toEqual({a: 4, b: 3})\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "combines with produce - 1",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 31
            },
            "line": 93,
            "code": "\t\tit(\"combines with produce - 1\", () => {\n\t\t\tconst state = {a: 1}\n\n\t\t\tconst draft = createDraft(state)\n\t\t\tdraft.a = 2\n\t\t\tconst res1 = produce(draft, d => {\n\t\t\t\td.b = 3\n\t\t\t})\n\t\t\tdraft.b = 4\n\t\t\tconst res2 = finishDraft(draft)\n\t\t\texpect(res1).toEqual({a: 2, b: 3})\n\t\t\texpect(res2).toEqual({a: 2, b: 4})\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "combines with produce - 2",
            "suites": [],
            "updatePoint": {
                "line": 107,
                "column": 31
            },
            "line": 107,
            "code": "\t\tit(\"combines with produce - 2\", () => {\n\t\t\tconst state = {a: 1}\n\n\t\t\tconst res1 = produce(state, draft => {\n\t\t\t\tdraft.b = 3\n\t\t\t\tconst draft2 = createDraft(draft)\n\t\t\t\tdraft.c = 4\n\t\t\t\tdraft2.d = 5\n\t\t\t\tconst res2 = finishDraft(draft2)\n\t\t\t\texpect(res2).toEqual({\n\t\t\t\t\ta: 1,\n\t\t\t\t\tb: 3,\n\t\t\t\t\td: 5\n\t\t\t\t})\n\t\t\t\tdraft.d = 2\n\t\t\t})\n\t\t\texpect(res1).toEqual({\n\t\t\t\ta: 1,\n\t\t\t\tb: 3,\n\t\t\t\tc: 4,\n\t\t\t\td: 2\n\t\t\t})\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should not finish drafts from produce",
            "suites": [],
            "updatePoint": {
                "line": 132,
                "column": 44
            },
            "line": 132,
            "code": "\t\t\tit(\"should not finish drafts from produce\", () => {\n\t\t\t\tproduce({x: 1}, draft => {\n\t\t\t\t\texpect(() => finishDraft(draft)).toThrowErrorMatchingSnapshot()\n\t\t\t\t})\n\t\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should not finish twice",
            "suites": [],
            "updatePoint": {
                "line": 138,
                "column": 29
            },
            "line": 138,
            "code": "\t\tit(\"should not finish twice\", () => {\n\t\t\tconst draft = createDraft({a: 1})\n\t\t\tdraft.a++\n\t\t\tfinishDraft(draft)\n\t\t\texpect(() => finishDraft(draft)).toThrowErrorMatchingSnapshot()\n\t\t})",
            "file": "manual.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#472 ",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 13
            },
            "line": 47,
            "code": "\t\ttest(\"#472 \", () => {\n\t\t\tconst project = produce(new Map(), draft => {\n\t\t\t\tdraft.set(\"bar1\", {blocked: false})\n\t\t\t\tdraft.set(\"bar2\", {blocked: false})\n\t\t\t})\n\n\t\t\t// Read before write -- no error\n\t\t\tproduce(project, draft => {\n\t\t\t\tconst bar1 = draft.get(\"bar1\")\n\t\t\t\tconst bar2 = draft.get(\"bar2\")\n\t\t\t\tbar1.blocked = true\n\t\t\t\tbar2.blocked = true\n\t\t\t})\n\n\t\t\t// Read/write interleaved -- error\n\t\t\tproduce(project, draft => {\n\t\t\t\tconst bar1 = draft.get(\"bar1\")\n\t\t\t\tbar1.blocked = true\n\t\t\t\tconst bar2 = draft.get(\"bar2\")\n\t\t\t\tbar2.blocked = true // TypeError: \"blocked\" is read-only\n\t\t\t})\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#466 - setNoPatches",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 27
            },
            "line": 70,
            "code": "\t\ttest(\"#466 - setNoPatches\", () => {\n\t\t\tconst obj = {\n\t\t\t\tset: new Set()\n\t\t\t}\n\n\t\t\tconst result = produceWithPatches(obj, draft => {\n\t\t\t\tdraft.set.add(\"abc\")\n\t\t\t})\n\t\t\texpect(result).toEqual([\n\t\t\t\t{set: new Set([\"abc\"])},\n\t\t\t\t[{op: \"add\", path: [\"set\", 0], value: \"abc\"}],\n\t\t\t\t[{op: \"remove\", path: [\"set\", 0], value: \"abc\"}]\n\t\t\t])\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#466 - mapChangeBug ",
            "suites": [],
            "updatePoint": {
                "line": 85,
                "column": 28
            },
            "line": 85,
            "code": "\t\ttest(\"#466 - mapChangeBug \", () => {\n\t\t\tconst obj = {\n\t\t\t\tmap: new Map([\n\t\t\t\t\t[\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t[\"b\", true],\n\t\t\t\t\t\t\t[\"c\", true],\n\t\t\t\t\t\t\t[\"d\", true]\n\t\t\t\t\t\t])\n\t\t\t\t\t],\n\t\t\t\t\t[\"b\", new Map([[\"a\", true]])],\n\t\t\t\t\t[\"c\", new Map([[\"a\", true]])],\n\t\t\t\t\t[\"d\", new Map([[\"a\", true]])]\n\t\t\t\t])\n\t\t\t}\n\t\t\tconst result = produceWithPatches(obj, draft => {\n\t\t\t\tconst aMap = draft.map.get(\"a\")\n\t\t\t\taMap.forEach((_, other) => {\n\t\t\t\t\tconst otherMap = draft.map.get(other)\n\t\t\t\t\totherMap.delete(\"a\")\n\t\t\t\t})\n\t\t\t})\n\t\t\texpect(result).toEqual([\n\t\t\t\t{\n\t\t\t\t\tmap: new Map([\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t\t[\"b\", true],\n\t\t\t\t\t\t\t\t[\"c\", true],\n\t\t\t\t\t\t\t\t[\"d\", true]\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t],\n\t\t\t\t\t\t[\"b\", new Map()],\n\t\t\t\t\t\t[\"c\", new Map()],\n\t\t\t\t\t\t[\"d\", new Map()]\n\t\t\t\t\t])\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"remove\",\n\t\t\t\t\t\tpath: [\"map\", \"b\", \"a\"]\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"remove\",\n\t\t\t\t\t\tpath: [\"map\", \"c\", \"a\"]\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"remove\",\n\t\t\t\t\t\tpath: [\"map\", \"d\", \"a\"]\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"add\",\n\t\t\t\t\t\tpath: [\"map\", \"b\", \"a\"],\n\t\t\t\t\t\tvalue: true\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"add\",\n\t\t\t\t\t\tpath: [\"map\", \"c\", \"a\"],\n\t\t\t\t\t\tvalue: true\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\top: \"add\",\n\t\t\t\t\t\tpath: [\"map\", \"d\", \"a\"],\n\t\t\t\t\t\tvalue: true\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t])\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#466 - mapChangeBug2 ",
            "suites": [],
            "updatePoint": {
                "line": 158,
                "column": 29
            },
            "line": 158,
            "code": "\t\ttest(\"#466 - mapChangeBug2 \", () => {\n\t\t\tconst obj = {\n\t\t\t\tmap: new Map([\n\t\t\t\t\t[\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t[\"b\", true],\n\t\t\t\t\t\t\t[\"c\", true],\n\t\t\t\t\t\t\t[\"d\", true]\n\t\t\t\t\t\t])\n\t\t\t\t\t],\n\t\t\t\t\t[\"b\", new Map([[\"a\", true]])],\n\t\t\t\t\t[\"c\", new Map([[\"a\", true]])],\n\t\t\t\t\t[\"d\", new Map([[\"a\", true]])]\n\t\t\t\t])\n\t\t\t}\n\t\t\tconst obj1 = produce(obj, draft => {})\n\t\t\tconst [result, p, ip] = produceWithPatches(obj1, draft => {\n\t\t\t\tconst aMap = draft.map.get(\"a\")\n\t\t\t\taMap.forEach((_, other) => {\n\t\t\t\t\tconst otherMap = draft.map.get(other)\n\t\t\t\t\totherMap.delete(\"a\")\n\t\t\t\t})\n\t\t\t})\n\t\t\texpect(result).toEqual({\n\t\t\t\tmap: new Map([\n\t\t\t\t\t[\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t[\"b\", true],\n\t\t\t\t\t\t\t[\"c\", true],\n\t\t\t\t\t\t\t[\"d\", true]\n\t\t\t\t\t\t])\n\t\t\t\t\t],\n\t\t\t\t\t[\"b\", new Map([])],\n\t\t\t\t\t[\"c\", new Map([])],\n\t\t\t\t\t[\"d\", new Map([])]\n\t\t\t\t])\n\t\t\t})\n\t\t\texpect(p).toEqual([\n\t\t\t\t{\n\t\t\t\t\top: \"remove\",\n\t\t\t\t\tpath: [\"map\", \"b\", \"a\"]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\top: \"remove\",\n\t\t\t\t\tpath: [\"map\", \"c\", \"a\"]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\top: \"remove\",\n\t\t\t\t\tpath: [\"map\", \"d\", \"a\"]\n\t\t\t\t}\n\t\t\t])\n\t\t\texpect(ip).toEqual([\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"map\", \"b\", \"a\"],\n\t\t\t\t\tvalue: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"map\", \"c\", \"a\"],\n\t\t\t\t\tvalue: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"map\", \"d\", \"a\"],\n\t\t\t\t\tvalue: true\n\t\t\t\t}\n\t\t\t])\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#586",
            "suites": [],
            "updatePoint": {
                "line": 230,
                "column": 12
            },
            "line": 230,
            "code": "\t\ttest(\"#586\", () => {\n\t\t\tconst base = new Set([1, 2])\n\t\t\tconst set = produce(base, draftSet => {\n\t\t\t\tdebugger\n\t\t\t\texpect(Array.from(draftSet)).toEqual([1, 2])\n\t\t\t\tdraftSet.add(3)\n\t\t\t})\n\t\t\texpect(Array.from(set).sort()).toEqual([1, 2, 3])\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#627 - new map key with value=undefined",
            "suites": [],
            "updatePoint": {
                "line": 240,
                "column": 47
            },
            "line": 240,
            "code": "\t\ttest(\"#627 - new map key with value=undefined\", () => {\n\t\t\tconst map = new Map()\n\t\t\tconst map1 = produce(map, draft => {\n\t\t\t\tdraft.set(\"key\", undefined)\n\t\t\t})\n\t\t\texpect(map1.has(\"key\")).toBe(true)\n\t\t\texpect(map1.get(\"key\")).toBe(undefined)\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#663 - clear map",
            "suites": [],
            "updatePoint": {
                "line": 249,
                "column": 24
            },
            "line": 249,
            "code": "\t\ttest(\"#663 - clear map\", () => {\n\t\t\tconst map = new Map([\n\t\t\t\t[\"a\", \"b\"],\n\t\t\t\t[\"b\", \"c\"]\n\t\t\t])\n\t\t\tconst result = produceWithPatches(map, draft => {\n\t\t\t\tdraft.clear()\n\t\t\t})\n\n\t\t\texpect(result).toEqual([\n\t\t\t\tnew Map(),\n\t\t\t\t[\n\t\t\t\t\t{op: \"remove\", path: [\"a\"]},\n\t\t\t\t\t{op: \"remove\", path: [\"b\"]}\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t{op: \"add\", path: [\"a\"], value: \"b\"},\n\t\t\t\t\t{op: \"add\", path: [\"b\"], value: \"c\"}\n\t\t\t\t]\n\t\t\t])\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#680 - Clearing empty Set&Map should be noop",
            "suites": [],
            "updatePoint": {
                "line": 271,
                "column": 52
            },
            "line": 271,
            "code": "\t\ttest(\"#680 - Clearing empty Set&Map should be noop\", () => {\n\t\t\tconst map = new Map()\n\t\t\tlet result = produce(map, draft => {\n\t\t\t\tdraft.clear()\n\t\t\t})\n\t\t\texpect(result).toBe(map)\n\n\t\t\tconst set = new Set()\n\t\t\tresult = produce(set, draft => {\n\t\t\t\tdraft.clear()\n\t\t\t})\n\t\t\texpect(result).toBe(set)\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#692 - idempotent plugin loading",
            "suites": [],
            "updatePoint": {
                "line": 285,
                "column": 40
            },
            "line": 285,
            "code": "\t\ttest(\"#692 - idempotent plugin loading\", () => {\n\t\t\tlet mapType1\n\t\t\tproduce(new Map(), draft => {\n\t\t\t\tmapType1 = draft.constructor\n\t\t\t})\n\n\t\t\tenableMapSet()\n\t\t\tlet mapType2\n\t\t\tproduce(new Map(), draft => {\n\t\t\t\tmapType2 = draft.constructor\n\t\t\t})\n\t\t\texpect(mapType1).toBe(mapType2)\n\t\t})",
            "file": "map-set.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should return the original without modifications",
            "suites": [
                "null functionality"
            ],
            "updatePoint": {
                "line": 7,
                "column": 53
            },
            "line": 7,
            "code": "\tit(\"should return the original without modifications\", () => {\n\t\tconst nextState = produce(baseState, () => {})\n\t\texpect(nextState).toBe(baseState)\n\t})",
            "file": "null.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should return the original from the draft",
            "suites": [
                "original"
            ],
            "updatePoint": {
                "line": 14,
                "column": 46
            },
            "line": 14,
            "code": "\tit(\"should return the original from the draft\", () => {\n\t\tsetUseProxies(true)\n\n\t\tproduce(baseState, draftState => {\n\t\t\texpect(original(draftState)).toBe(baseState)\n\t\t\texpect(original(draftState.a)).toBe(baseState.a)\n\t\t\texpect(original(draftState.b)).toBe(baseState.b)\n\t\t})\n\n\t\tsetUseProxies(false)\n\n\t\tproduce(baseState, draftState => {\n\t\t\texpect(original(draftState)).toBe(baseState)\n\t\t\texpect(original(draftState.a)).toBe(baseState.a)\n\t\t\texpect(original(draftState.b)).toBe(baseState.b)\n\t\t})\n\t})",
            "file": "original.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should return the original from the proxy",
            "suites": [
                "original"
            ],
            "updatePoint": {
                "line": 32,
                "column": 46
            },
            "line": 32,
            "code": "\tit(\"should return the original from the proxy\", () => {\n\t\tproduce(baseState, draftState => {\n\t\t\texpect(original(draftState)).toBe(baseState)\n\t\t\texpect(original(draftState.a)).toBe(baseState.a)\n\t\t\texpect(original(draftState.b)).toBe(baseState.b)\n\t\t})\n\t})",
            "file": "original.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should throw undefined for new values on the draft",
            "suites": [
                "original"
            ],
            "updatePoint": {
                "line": 40,
                "column": 55
            },
            "line": 40,
            "code": "\tit(\"should throw undefined for new values on the draft\", () => {\n\t\tproduce(baseState, draftState => {\n\t\t\tdraftState.c = {}\n\t\t\tdraftState.d = 3\n\t\t\texpect(() => original(draftState.c)).toThrowErrorMatchingInlineSnapshot(\n\t\t\t\tisProd\n\t\t\t\t\t? `\"[Immer] minified error nr: 23 '[object Object]'. Find the full error at: https://bit.ly/3cXEKWf\"`\n\t\t\t\t\t: `\"[Immer] 'original' expects a draft, got: [object Object]\"`\n\t\t\t)\n\t\t\texpect(() => original(draftState.d)).toThrowErrorMatchingInlineSnapshot(\n\t\t\t\tisProd\n\t\t\t\t\t? `\"[Immer] minified error nr: 23 '3'. Find the full error at: https://bit.ly/3cXEKWf\"`\n\t\t\t\t\t: `\"[Immer] 'original' expects a draft, got: 3\"`\n\t\t\t)\n\t\t})\n\t})",
            "file": "original.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "should return undefined for an object that is not proxied",
            "suites": [
                "original"
            ],
            "updatePoint": {
                "line": 57,
                "column": 62
            },
            "line": 57,
            "code": "\tit(\"should return undefined for an object that is not proxied\", () => {\n\t\texpect(() => original({})).toThrowErrorMatchingInlineSnapshot(\n\t\t\tisProd\n\t\t\t\t? `\"[Immer] minified error nr: 23 '[object Object]'. Find the full error at: https://bit.ly/3cXEKWf\"`\n\t\t\t\t: `\"[Immer] 'original' expects a draft, got: [object Object]\"`\n\t\t)\n\t\texpect(() => original(3)).toThrowErrorMatchingInlineSnapshot(\n\t\t\tisProd\n\t\t\t\t? `\"[Immer] minified error nr: 23 '3'. Find the full error at: https://bit.ly/3cXEKWf\"`\n\t\t\t\t: `\"[Immer] 'original' expects a draft, got: 3\"`\n\t\t)\n\t})",
            "file": "original.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "produces the correct patches",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 36
            },
            "line": 29,
            "code": "\t\ttest(\"produces the correct patches\", () => {\n\t\t\texpect(recordedPatches).toEqual(patches)\n\t\t\tif (inversePathes) expect(recordedInversePatches).toEqual(inversePathes)\n\t\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "patches are replayable",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 30
            },
            "line": 34,
            "code": "\t\ttest(\"patches are replayable\", () => {\n\t\t\texpect(applyPatches(base, recordedPatches)).toEqual(res)\n\t\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "patches can be reversed",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 31
            },
            "line": 38,
            "code": "\t\ttest(\"patches can be reversed\", () => {\n\t\t\texpect(applyPatches(res, recordedInversePatches)).toEqual(base)\n\t\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "ES5 and Proxy implementation yield same result",
            "suites": [
                "es5"
            ],
            "updatePoint": {
                "line": 53,
                "column": 54
            },
            "line": 53,
            "code": "\t\ttest(\"ES5 and Proxy implementation yield same result\", () => {\n\t\t\texpect(resultEs5).toEqual(resultProxies)\n\t\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "mutates the base state when it is a draft",
            "suites": [
                "applyPatches"
            ],
            "updatePoint": {
                "line": 62,
                "column": 46
            },
            "line": 62,
            "code": "\tit(\"mutates the base state when it is a draft\", () => {\n\t\tproduce({a: 1}, draft => {\n\t\t\tconst result = applyPatches(draft, [\n\t\t\t\t{op: \"replace\", path: [\"a\"], value: 2}\n\t\t\t])\n\t\t\texpect(result).toBe(draft)\n\t\t\texpect(draft.a).toBe(2)\n\t\t})\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "produces a copy of the base state when not a draft",
            "suites": [
                "applyPatches"
            ],
            "updatePoint": {
                "line": 71,
                "column": 55
            },
            "line": 71,
            "code": "\tit(\"produces a copy of the base state when not a draft\", () => {\n\t\tconst base = {a: 1}\n\t\tconst result = applyPatches(base, [{op: \"replace\", path: [\"a\"], value: 2}])\n\t\texpect(result).not.toBe(base)\n\t\texpect(result.a).toBe(2)\n\t\texpect(base.a).toBe(1)\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when `op` is not \"add\", \"replace\", nor \"remove\"",
            "suites": [
                "applyPatches"
            ],
            "updatePoint": {
                "line": 78,
                "column": 59
            },
            "line": 78,
            "code": "\tit('throws when `op` is not \"add\", \"replace\", nor \"remove\"', () => {\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"copy\", from: [0], path: [1]}\n\t\t\tapplyPatches([2], [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "throws when `path` cannot be resolved",
            "suites": [
                "applyPatches"
            ],
            "updatePoint": {
                "line": 84,
                "column": 42
            },
            "line": 84,
            "code": "\tit(\"throws when `path` cannot be resolved\", () => {\n\t\t// missing parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\n\t\t// missing grand-parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\", \"c\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "applied patches cannot be modified",
            "suites": [
                "applyPatches"
            ],
            "updatePoint": {
                "line": 97,
                "column": 39
            },
            "line": 97,
            "code": "\tit(\"applied patches cannot be modified\", () => {\n\t\t// see also: https://github.com/immerjs/immer/issues/411\n\t\tconst s0 = {\n\t\t\titems: [1]\n\t\t}\n\n\t\tconst [s1, p1] = produceWithPatches(s0, draft => {\n\t\t\tdraft.items = []\n\t\t})\n\n\t\tconst replaceValueBefore = p1[0].value.slice()\n\n\t\tconst [s2, p2] = produceWithPatches(s1, draft => {\n\t\t\tdraft.items.push(2)\n\t\t})\n\n\t\tapplyPatches(s0, [...p1, ...p2])\n\n\t\tconst replaceValueAfter = p1[0].value.slice()\n\n\t\texpect(replaceValueAfter).toStrictEqual(replaceValueBefore)\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "appends to array when last part of path is '-'",
            "suites": [
                "arrays - append"
            ],
            "updatePoint": {
                "line": 724,
                "column": 53
            },
            "line": 724,
            "code": "\ttest(\"appends to array when last part of path is '-'\", () => {\n\t\tconst state = {\n\t\t\tlist: [1, 2, 3]\n\t\t}\n\t\tconst patch = {\n\t\t\top: \"add\",\n\t\t\tvalue: 4,\n\t\t\tpath: [\"list\", \"-\"]\n\t\t}\n\t\texpect(applyPatches(state, [patch])).toEqual({\n\t\t\tlist: [1, 2, 3, 4]\n\t\t})\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "valid result",
            "suites": [
                "change then delete property"
            ],
            "updatePoint": {
                "line": 975,
                "column": 19
            },
            "line": 975,
            "code": "\ttest(\"valid result\", () => {\n\t\texpect(res).toEqual({})\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "replaying patches with interweaved replacements should work correctly",
            "suites": [
                "change then delete property"
            ],
            "updatePoint": {
                "line": 980,
                "column": 75
            },
            "line": 980,
            "code": "test(\"replaying patches with interweaved replacements should work correctly\", () => {\n\tconst patches = []\n\tconst s0 = {x: 1}\n\n\tconst s1 = produce(\n\t\ts0,\n\t\tdraft => {\n\t\t\tdraft.x = 2\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s2 = produce(\n\t\ts1,\n\t\tdraft => {\n\t\t\treturn {x: 0}\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s3 = produce(\n\t\ts2,\n\t\tdraft => {\n\t\t\tdraft.x--\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\texpect(s3).toEqual({x: -1}) // correct result\n\texpect(applyPatches(s0, patches)).toEqual({x: -1}) // correct replay\n\n\t// manual replay on a draft should also be correct\n\texpect(\n\t\tproduce(s0, draft => {\n\t\t\treturn applyPatches(draft, patches)\n\t\t})\n\t).toEqual({x: -1})\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "es5",
            "suites": [
                "#468"
            ],
            "updatePoint": {
                "line": 1054,
                "column": 10
            },
            "line": 1054,
            "code": "\ttest(\"es5\", () => {\n\t\tsetUseProxies(false)\n\t\trun()\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "proxy",
            "suites": [
                "#468"
            ],
            "updatePoint": {
                "line": 1059,
                "column": 12
            },
            "line": 1059,
            "code": "\ttest(\"proxy\", () => {\n\t\tsetUseProxies(true)\n\t\trun()\n\t})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#521",
            "suites": [
                "#468"
            ],
            "updatePoint": {
                "line": 1065,
                "column": 10
            },
            "line": 1065,
            "code": "test(\"#521\", () => {\n\tconst state = new Map()\n\n\tconst [nextState, patches] = produceWithPatches(state, draft => {\n\t\tdraft.set(\"hello\", new Set([\"world\"]))\n\t})\n\n\tlet patchedState = applyPatches(state, patches)\n\texpect(patchedState).toEqual(nextState)\n\n\tconst [nextStateV2, patchesV2] = produceWithPatches(nextState, draft => {\n\t\tdraft.get(\"hello\").add(\"immer\")\n\t})\n\n\texpect(applyPatches(nextState, patchesV2)).toEqual(\n\t\tnew Map([[\"hello\", new Set([\"world\", \"immer\"])]])\n\t)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#559 patches works in a nested reducer with proxies",
            "suites": [
                "#468"
            ],
            "updatePoint": {
                "line": 1084,
                "column": 57
            },
            "line": 1084,
            "code": "test(\"#559 patches works in a nested reducer with proxies\", () => {\n\tsetUseProxies(true)\n\n\tconst state = {\n\t\tx: 1,\n\t\tsub: {\n\t\t\ty: [{a: 0}, {a: 1}]\n\t\t}\n\t}\n\n\tconst changes = []\n\tconst inverseChanges = []\n\n\tconst newState = produce(state, draft => {\n\t\tdraft.sub = produce(\n\t\t\tdraft.sub,\n\t\t\tdraft => {\n\t\t\t\tdraft.y.pop()\n\t\t\t},\n\t\t\t(patches, inversePatches) => {\n\t\t\t\texpect(isDraft(inversePatches[0].value)).toBeFalsy()\n\t\t\t\texpect(inversePatches[0].value).toMatchObject({a: 1})\n\t\t\t\tchanges.push(...patches)\n\t\t\t\tinverseChanges.push(...inversePatches)\n\t\t\t}\n\t\t)\n\t})\n\n\tconst reversedSubState = applyPatches(newState.sub, inverseChanges)\n\n\texpect(reversedSubState).toMatchObject(state.sub)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#676 patching Date objects",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1142,
                "column": 32
            },
            "line": 1142,
            "code": "test(\"#676 patching Date objects\", () => {\n\tclass Test {\n\t\tconstructor() {\n\t\t\tthis.test = true\n\t\t}\n\t\tperform() {\n\t\t\treturn \"tested!\"\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches({}, function(draft) {\n\t\tdraft.date = new Date(\"2020-11-10T08:08:08.003Z\")\n\t\tdraft.test = new Test()\n\t})\n\n\texpect(nextState.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(nextState.test.perform()).toBe(\"tested!\")\n\n\tconst rebuilt = applyPatches({}, patches)\n\texpect(rebuilt.date).toBeInstanceOf(Date)\n\texpect(rebuilt.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(rebuilt.date).toEqual(new Date(\"2020-11-10T08:08:08.003Z\"))\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "do not allow __proto__ polution - 738",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1170,
                "column": 43
            },
            "line": 1170,
            "code": "test(\"do not allow __proto__ polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "do not allow __proto__ polution using arrays - 738",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1188,
                "column": 56
            },
            "line": 1188,
            "code": "test(\"do not allow __proto__ polution using arrays - 738\", () => {\n\tconst obj = {}\n\tconst ar = []\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(\n\t\t\t[],\n\t\t\t[{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}]\n\t\t)\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "do not allow prototype polution - 738",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1212,
                "column": 43
            },
            "line": 1212,
            "code": "test(\"do not allow prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(Object, [\n\t\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "do not allow constructor polution - 738",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1230,
                "column": 45
            },
            "line": 1230,
            "code": "test(\"do not allow constructor polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\tconst t = {}\n\tapplyPatches(t, [{op: \"replace\", path: [\"constructor\"], value: \"yes\"}])\n\texpect(typeof t.constructor).toBe(\"function\")\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "do not allow constructor.prototype polution - 738",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1242,
                "column": 55
            },
            "line": 1242,
            "code": "test(\"do not allow constructor.prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"constructor\", \"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "maps can store __proto__, prototype and constructor props",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1260,
                "column": 63
            },
            "line": 1260,
            "code": "test(\"maps can store __proto__, prototype and constructor props\", () => {\n\tconst obj = {}\n\tconst map = new Map()\n\tmap.set(\"__proto__\", {})\n\tmap.set(\"constructor\", {})\n\tmap.set(\"prototype\", {})\n\tconst newMap = applyPatches(map, [\n\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"constructor\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t])\n\texpect(newMap.get(\"__proto__\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"constructor\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"prototype\").polluted).toBe(\"yes\")\n\texpect(obj.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "CVE-2020-28477 (https://snyk.io/vuln/SNYK-JS-IMMER-1019369) follow up",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1277,
                "column": 75
            },
            "line": 1277,
            "code": "test(\"CVE-2020-28477 (https://snyk.io/vuln/SNYK-JS-IMMER-1019369) follow up\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [[\"__proto__\"], \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#648 assigning object to itself should not change patches",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1295,
                "column": 63
            },
            "line": 1295,
            "code": "test(\"#648 assigning object to itself should not change patches\", () => {\n\tconst input = {\n\t\tobj: {\n\t\t\tvalue: 200\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches(input, draft => {\n\t\tdraft.obj.value = 1\n\t\tdraft.obj = draft.obj\n\t})\n\n\texpect(patches).toEqual([\n\t\t{\n\t\t\top: \"replace\",\n\t\t\tpath: [\"obj\", \"value\"],\n\t\t\tvalue: 1\n\t\t}\n\t])\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#791 patch for  nothing is stored as undefined",
            "suites": [
                "#588"
            ],
            "updatePoint": {
                "line": 1316,
                "column": 52
            },
            "line": 1316,
            "code": "test(\"#791 patch for  nothing is stored as undefined\", () => {\n\tconst [newState, patches] = produceWithPatches({abc: 123}, draft => nothing)\n\texpect(patches).toEqual([{op: \"replace\", path: [], value: undefined}])\n\n\texpect(applyPatches({}, patches)).toEqual(undefined)\n})",
            "file": "patch.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "error when using ES5",
            "suites": [
                "ES5 plugins should throw if no proxies are available"
            ],
            "updatePoint": {
                "line": 16,
                "column": 27
            },
            "line": 16,
            "code": "\ttest(\"error when using ES5\", () => {\n\t\texpect(() => {\n\t\t\tproduce({}, function() {})\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})",
            "file": "plugins.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "error when using Maps",
            "suites": [
                "ES5 plugins should throw if no proxies are available"
            ],
            "updatePoint": {
                "line": 23,
                "column": 27
            },
            "line": 23,
            "code": "test(\"error when using Maps\", () => {\n\texpect(() => {\n\t\tproduce(new Map(), function() {})\n\t}).toThrowErrorMatchingSnapshot()\n})",
            "file": "plugins.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "error when using patches - 1",
            "suites": [
                "ES5 plugins should throw if no proxies are available"
            ],
            "updatePoint": {
                "line": 29,
                "column": 34
            },
            "line": 29,
            "code": "test(\"error when using patches - 1\", () => {\n\texpect(() => {\n\t\tproduce(\n\t\t\t{},\n\t\t\tfunction() {},\n\t\t\tfunction() {}\n\t\t)\n\t}).toThrowErrorMatchingSnapshot()\n})",
            "file": "plugins.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "error when using patches - 2",
            "suites": [
                "ES5 plugins should throw if no proxies are available"
            ],
            "updatePoint": {
                "line": 39,
                "column": 34
            },
            "line": 39,
            "code": "test(\"error when using patches - 2\", () => {\n\texpect(() => {\n\t\tproduceWithPatches({}, function() {})\n\t}).toThrowErrorMatchingSnapshot()\n})",
            "file": "plugins.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "error when using patches - 3",
            "suites": [
                "ES5 plugins should throw if no proxies are available"
            ],
            "updatePoint": {
                "line": 45,
                "column": 34
            },
            "line": 45,
            "code": "test(\"error when using patches - 3\", () => {\n\texpect(() => {\n\t\tapplyPatches({}, [])\n\t}).toThrowErrorMatchingSnapshot()\n})",
            "file": "plugins.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "NOTHING",
            "suites": [
                "Symbol"
            ],
            "updatePoint": {
                "line": 23,
                "column": 15
            },
            "line": 23,
            "code": "\t\ttest(\"NOTHING\", () => {\n\t\t\tconst value = common.NOTHING\n\t\t\texpect(value).toBeTruthy()\n\t\t\texpect(typeof value).toBe(\"object\")\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "DRAFTABLE",
            "suites": [
                "Symbol"
            ],
            "updatePoint": {
                "line": 28,
                "column": 17
            },
            "line": 28,
            "code": "\t\ttest(\"DRAFTABLE\", () => {\n\t\t\tconst value = common.DRAFTABLE\n\t\t\texpect(typeof value).toBe(\"string\")\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "DRAFT_STATE",
            "suites": [
                "Symbol"
            ],
            "updatePoint": {
                "line": 32,
                "column": 19
            },
            "line": 32,
            "code": "\t\ttest(\"DRAFT_STATE\", () => {\n\t\t\tconst value = common.DRAFT_STATE\n\t\t\texpect(typeof value).toBe(\"string\")\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "includes symbol keys",
            "suites": [
                "Reflect.ownKeys"
            ],
            "updatePoint": {
                "line": 43,
                "column": 26
            },
            "line": 43,
            "code": "\t\tit(\"includes symbol keys\", () => {\n\t\t\tconst s = SymbolConstructor()\n\t\t\tconst obj = {[s]: 1, b: 1}\n\t\t\texpect(ownKeys(obj)).toEqual([\"b\", s])\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "includes non-enumerable keys",
            "suites": [
                "Reflect.ownKeys"
            ],
            "updatePoint": {
                "line": 49,
                "column": 34
            },
            "line": 49,
            "code": "\t\tit(\"includes non-enumerable keys\", () => {\n\t\t\tconst obj = {a: 1}\n\t\t\tObject.defineProperty(obj, \"b\", {value: 1})\n\t\t\texpect(ownKeys(obj)).toEqual([\"a\", \"b\"])\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "gets symbolic and nonsymbolic properties",
            "suites": [
                "Object.getOwnPropertyDescriptors"
            ],
            "updatePoint": {
                "line": 61,
                "column": 46
            },
            "line": 61,
            "code": "\t\tit(\"gets symbolic and nonsymbolic properties\", () => {\n\t\t\texpect(\n\t\t\t\tObject.getOwnPropertyDescriptors({\n\t\t\t\t\tx: 1,\n\t\t\t\t\t[testSymbol]: 2\n\t\t\t\t})\n\t\t\t).toEqual({\n\t\t\t\tx: {\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true\n\t\t\t\t},\n\t\t\t\t[testSymbol]: {\n\t\t\t\t\tvalue: 2,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true\n\t\t\t\t}\n\t\t\t})\n\t\t})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "suppress jest warning",
            "suites": [
                "Object.getOwnPropertyDescriptors"
            ],
            "updatePoint": {
                "line": 84,
                "column": 27
            },
            "line": 84,
            "code": "test(\"suppress jest warning\", () => {\n\texpect(true).toBe(true)\n})",
            "file": "polyfills.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can update readonly state via standard api",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 46
            },
            "line": 50,
            "code": "it(\"can update readonly state via standard api\", () => {\n\tconst newState = produce(state, draft => {\n\t\tdraft.num++\n\t\tdraft.foo = \"bar\"\n\t\tdraft.bar = \"foo\"\n\t\tdraft.baz.x++\n\t\tdraft.baz.y++\n\t\tdraft.arr[0].value = \"foo\"\n\t\tdraft.arr.push({value: \"asf\"})\n\t\tdraft.arr2[0].value = \"foo\"\n\t\tdraft.arr2.push({value: \"asf\"})\n\t})\n\tassert(newState, _ as State)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can infer state type from default state",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 43
            },
            "line": 66,
            "code": "it(\"can infer state type from default state\", () => {\n\ttype State = {readonly a: number}\n\ttype Recipe = (state?: State | undefined) => State\n\n\tlet foo = produce((_: any) => {}, _ as State)\n\tassert(foo, _ as Recipe)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can infer state type from recipe function",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 45
            },
            "line": 74,
            "code": "it(\"can infer state type from recipe function\", () => {\n\ttype A = {readonly a: string}\n\ttype B = {readonly b: string}\n\ttype State = A | B\n\ttype Recipe = (state: State) => State\n\n\tlet foo = produce((draft: State) => {\n\t\tassert(draft, _ as State)\n\t\tif (Math.random() > 0.5) return {a: \"test\"}\n\t\telse return {b: \"boe\"}\n\t})\n\tconst x = foo({a: \"\"})\n\tconst y = foo({b: \"\"})\n\tassert(foo, _ as Recipe)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can infer state type from recipe function with arguments",
            "suites": [],
            "updatePoint": {
                "line": 90,
                "column": 60
            },
            "line": 90,
            "code": "it(\"can infer state type from recipe function with arguments\", () => {\n\ttype State = {readonly a: string} | {readonly b: string}\n\ttype Recipe = (state: State, x: number) => State\n\n\tlet foo = produce<State, [number]>((draft, x) => {\n\t\tassert(draft, _ as Draft<State>)\n\t\tassert(x, _ as number)\n\t})\n\tassert(foo, _ as Recipe)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can infer state type from recipe function with arguments and initial state",
            "suites": [],
            "updatePoint": {
                "line": 101,
                "column": 78
            },
            "line": 101,
            "code": "it(\"can infer state type from recipe function with arguments and initial state\", () => {\n\ttype State = {readonly a: string} | {readonly b: string}\n\ttype Recipe = (state: State | undefined, x: number) => State\n\n\tlet foo = produce((draft: Draft<State>, x: number) => {}, _ as State)\n\tassert(foo, _ as Recipe)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "cannot infer state type when the function type and default state are missing",
            "suites": [],
            "updatePoint": {
                "line": 109,
                "column": 80
            },
            "line": 109,
            "code": "it(\"cannot infer state type when the function type and default state are missing\", () => {\n\ttype Recipe = <S extends any>(state: S) => S\n\tconst foo = produce((_: any) => {})\n\t// @ts-expect-error\n\tassert(foo, _ as Recipe)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can update readonly state via curried api",
            "suites": [],
            "updatePoint": {
                "line": 116,
                "column": 45
            },
            "line": 116,
            "code": "it(\"can update readonly state via curried api\", () => {\n\tconst newState = produce((draft: Draft<State>) => {\n\t\tdraft.num++\n\t\tdraft.foo = \"bar\"\n\t\tdraft.bar = \"foo\"\n\t\tdraft.baz.x++\n\t\tdraft.baz.y++\n\t\tdraft.arr[0].value = \"foo\"\n\t\tdraft.arr.push({value: \"asf\"})\n\t\tdraft.arr2[0].value = \"foo\"\n\t\tdraft.arr2.push({value: \"asf\"})\n\t})(state)\n\texpect(newState).not.toBe(state)\n\texpect(newState).toEqual(expectedState)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can update use the non-default export",
            "suites": [],
            "updatePoint": {
                "line": 132,
                "column": 41
            },
            "line": 132,
            "code": "it(\"can update use the non-default export\", () => {\n\tconst newState = produce2((draft: Draft<State>) => {\n\t\tdraft.num++\n\t\tdraft.foo = \"bar\"\n\t\tdraft.bar = \"foo\"\n\t\tdraft.baz.x++\n\t\tdraft.baz.y++\n\t\tdraft.arr[0].value = \"foo\"\n\t\tdraft.arr.push({value: \"asf\"})\n\t\tdraft.arr2[0].value = \"foo\"\n\t\tdraft.arr2.push({value: \"asf\"})\n\t})(state)\n\texpect(newState).not.toBe(state)\n\texpect(newState).toEqual(expectedState)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can apply patches",
            "suites": [],
            "updatePoint": {
                "line": 148,
                "column": 21
            },
            "line": 148,
            "code": "it(\"can apply patches\", () => {\n\tlet patches: Patch[] = []\n\tproduce(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x++\n\t\t},\n\t\tp => {\n\t\t\tpatches = p\n\t\t}\n\t)\n\n\texpect(applyPatches({}, patches)).toEqual({x: 4})\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports rest parameters",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 164,
                "column": 29
            },
            "line": 164,
            "code": "\tit(\"supports rest parameters\", () => {\n\t\ttype State = {readonly a: 1}\n\n\t\t// No initial state:\n\t\t{\n\t\t\ttype Recipe = (state: State, a: number, b: number) => State\n\t\t\tlet foo = produce((s: State, a: number, b: number) => {})\n\t\t\tassert(foo, _ as Recipe)\n\t\t\tfoo(_ as State, 1, 2)\n\t\t}\n\n\t\t// Using argument parameters:\n\t\t{\n\t\t\ttype Recipe = (state: Immutable<State>, ...rest: number[]) => Draft<State>\n\t\t\tlet woo = produce((state: Draft<State>, ...args: number[]) => {})\n\t\t\tassert(woo, _ as Recipe)\n\t\t\twoo(_ as State, 1, 2)\n\t\t}\n\n\t\t// With initial state:\n\t\t{\n\t\t\ttype Recipe = (state?: State | undefined, ...rest: number[]) => State\n\t\t\tlet bar = produce((state: Draft<State>, ...args: number[]) => {},\n\t\t\t_ as State)\n\t\t\tassert(bar, _ as Recipe)\n\t\t\tbar(_ as State, 1, 2)\n\t\t\tbar(_ as State)\n\t\t\tbar()\n\t\t}\n\n\t\t// When args is a tuple:\n\t\t{\n\t\t\ttype Recipe = (\n\t\t\t\tstate: State | undefined,\n\t\t\t\tfirst: string,\n\t\t\t\t...rest: number[]\n\t\t\t) => State\n\t\t\tlet tup = produce(\n\t\t\t\t(state: Draft<State>, ...args: [string, ...number[]]) => {},\n\t\t\t\t_ as State\n\t\t\t)\n\t\t\tassert(tup, _ as Recipe)\n\t\t\ttup({a: 1}, \"\", 2)\n\t\t\ttup(undefined, \"\", 2)\n\t\t}\n\t})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can be passed a readonly array",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 211,
                "column": 35
            },
            "line": 211,
            "code": "\tit(\"can be passed a readonly array\", () => {\n\t\t// No initial state:\n\t\t{\n\t\t\tlet foo = produce((state: string[]) => {})\n\t\t\tassert(foo, _ as (state: readonly string[]) => string[])\n\t\t\tfoo([] as ReadonlyArray<string>)\n\t\t}\n\n\t\t// With initial state:\n\t\t{\n\t\t\tlet bar = produce(() => {}, [] as ReadonlyArray<string>)\n\t\t\tassert(\n\t\t\t\tbar,\n\t\t\t\t_ as (state?: readonly string[] | undefined) => readonly string[]\n\t\t\t)\n\t\t\tbar([] as ReadonlyArray<string>)\n\t\t\tbar(undefined)\n\t\t\tbar()\n\t\t}\n\t})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with return type of: number",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 233,
                "column": 37
            },
            "line": 233,
            "code": "it(\"works with return type of: number\", () => {\n\tlet base = {a: 0} as {a: number}\n\t{\n\t\tif (Math.random() === 100) {\n\t\t\t// @ts-expect-error, this return accidentally a number, this is probably a dev error!\n\t\t\tlet result = produce(base, draft => draft.a++)\n\t\t}\n\t}\n\t{\n\t\tlet result = produce(base, draft => void draft.a++)\n\t\tassert(result, _ as {a: number})\n\t}\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return an object type that is identical to the base type",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 247,
                "column": 64
            },
            "line": 247,
            "code": "it(\"can return an object type that is identical to the base type\", () => {\n\tlet base = {a: 0} as {a: number}\n\tlet result = produce(base, draft => {\n\t\treturn draft.a < 0 ? {a: 0} : undefined\n\t})\n\tassert(result, _ as {a: number})\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can NOT return an object type that is _not_ assignable to the base type",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 255,
                "column": 75
            },
            "line": 255,
            "code": "it(\"can NOT return an object type that is _not_ assignable to the base type\", () => {\n\tlet base = {a: 0} as {a: number}\n\t// @ts-expect-error\n\tlet result = produce(base, draft => {\n\t\treturn draft.a < 0 ? {a: true} : undefined\n\t})\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "does not enforce immutability at the type level",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 263,
                "column": 51
            },
            "line": 263,
            "code": "it(\"does not enforce immutability at the type level\", () => {\n\tlet result = produce([] as any[], draft => {\n\t\tdraft.push(1)\n\t})\n\tassert(result, _ as any[])\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can produce an undefined value",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 270,
                "column": 34
            },
            "line": 270,
            "code": "it(\"can produce an undefined value\", () => {\n\ttype State = {readonly a: number} | undefined\n\tconst base = {a: 0} as State\n\n\t// Return only nothing.\n\tlet result = produce(base, _ => nothing)\n\tassert(result, _ as State)\n\n\t// Return maybe nothing.\n\tlet result2 = produce(base, draft => {\n\t\tif (draft?.a ?? 0 > 0) return nothing\n\t})\n\tassert(result2, _ as State)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return the draft itself",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 285,
                "column": 31
            },
            "line": 285,
            "code": "it(\"can return the draft itself\", () => {\n\tlet base = _ as {readonly a: number}\n\tlet result = produce(base, draft => draft)\n\n\tassert(result, _ as {readonly a: number})\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can return a promise",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 292,
                "column": 24
            },
            "line": 292,
            "code": "it(\"can return a promise\", () => {\n\ttype Base = {readonly a: number}\n\tlet base = {a: 0} as Base\n\n\t// Return a promise only.\n\tlet res1 = produce(base, draft => {\n\t\treturn Promise.resolve(draft)\n\t})\n\tassert(res1, _ as Promise<Base>)\n\n\t// Return a promise or undefined.\n\tlet res2 = produce(base, draft => {\n\t\treturn Promise.resolve()\n\t})\n\tassert(res2, _ as Promise<Base>)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with `void` hack",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 309,
                "column": 26
            },
            "line": 309,
            "code": "it(\"works with `void` hack\", () => {\n\tlet base = {a: 0} as {readonly a: number}\n\tlet copy = produce(base, s => void s.a++)\n\tassert(copy, base)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with generic parameters",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 315,
                "column": 33
            },
            "line": 315,
            "code": "it(\"works with generic parameters\", () => {\n\tlet insert = <T>(array: readonly T[], index: number, elem: T) => {\n\t\t// Need explicit cast on draft as T[] is wider than readonly T[]\n\t\treturn produce(array, (draft: T[]) => {\n\t\t\tdraft.push(elem)\n\t\t\tdraft.splice(index, 0, elem)\n\t\t\tdraft.concat([elem])\n\t\t})\n\t}\n\tlet val: {readonly a: ReadonlyArray<number>} = {a: []} as any\n\tlet arr: ReadonlyArray<typeof val> = [] as any\n\tinsert(arr, 0, val)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can work with non-readonly base types",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 329,
                "column": 41
            },
            "line": 329,
            "code": "it(\"can work with non-readonly base types\", () => {\n\tconst state = {\n\t\tprice: 10,\n\t\ttodos: [\n\t\t\t{\n\t\t\t\ttitle: \"test\",\n\t\t\t\tdone: false\n\t\t\t}\n\t\t]\n\t}\n\ttype State = typeof state\n\n\tconst newState = produce(state, draft => {\n\t\tdraft.price += 5\n\t\tdraft.todos.push({\n\t\t\ttitle: \"hi\",\n\t\t\tdone: true\n\t\t})\n\t})\n\tassert(newState, _ as State)\n\n\tconst reducer = (draft: State) => {\n\t\tdraft.price += 5\n\t\tdraft.todos.push({\n\t\t\ttitle: \"hi\",\n\t\t\tdone: true\n\t\t})\n\t}\n\n\t// base case for with-initial-state\n\tconst newState4 = produce(reducer, state)(state)\n\tassert(newState4, _ as State)\n\t// no argument case, in that case, immutable version recipe first arg will be inferred\n\tconst newState5 = produce(reducer, state)()\n\tassert(newState5, _ as State)\n\t// we can force the return type of the reducer by casting the initial state\n\tconst newState3 = produce(reducer, state as State)()\n\tassert(newState3, _ as State)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can work with readonly base types",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 369,
                "column": 37
            },
            "line": 369,
            "code": "it(\"can work with readonly base types\", () => {\n\ttype State = {\n\t\treadonly price: number\n\t\treadonly todos: readonly {\n\t\t\treadonly title: string\n\t\t\treadonly done: boolean\n\t\t}[]\n\t}\n\n\tconst state: State = {\n\t\tprice: 10,\n\t\ttodos: [\n\t\t\t{\n\t\t\t\ttitle: \"test\",\n\t\t\t\tdone: false\n\t\t\t}\n\t\t]\n\t}\n\n\tconst newState = produce(state, draft => {\n\t\tdraft.price + 5\n\t\tdraft.todos.push({\n\t\t\ttitle: \"hi\",\n\t\t\tdone: true\n\t\t})\n\t})\n\tassert(newState, _ as State)\n\tassert(newState, _ as Immutable<State>) // cause that is the same!\n\n\tconst reducer = (draft: Draft<State>) => {\n\t\tdraft.price += 5\n\t\tdraft.todos.push({\n\t\t\ttitle: \"hi\",\n\t\t\tdone: true\n\t\t})\n\t}\n\tconst newState2: State = produce(reducer)(state)\n\tassert(newState2, _ as State)\n\n\t// base case for with-initial-state\n\tconst newState4 = produce(reducer, state)(state)\n\tassert(newState4, _ as State)\n\t// no argument case, in that case, immutable version recipe first arg will be inferred\n\tconst newState5 = produce(reducer, state)()\n\tassert(newState5, _ as State)\n\t// we can force the return type of the reducer by casting initial argument\n\tconst newState3 = produce(reducer, state as State)()\n\tassert(newState3, _ as State)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with generic array",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 419,
                "column": 28
            },
            "line": 419,
            "code": "it(\"works with generic array\", () => {\n\tconst append = <T>(queue: T[], item: T) =>\n\t\t// T[] is needed here v. Too bad.\n\t\tproduce(queue, (queueDraft: T[]) => {\n\t\t\tqueueDraft.push(item)\n\t\t})\n\n\tconst queueBefore = [1, 2, 3]\n\n\tconst queueAfter = append(queueBefore, 4)\n\n\texpect(queueAfter).toEqual([1, 2, 3, 4])\n\texpect(queueBefore).toEqual([1, 2, 3])\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with Map and Set",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 434,
                "column": 26
            },
            "line": 434,
            "code": "it(\"works with Map and Set\", () => {\n\tconst m = new Map([[\"a\", {x: 1}]])\n\tconst s = new Set([{x: 2}])\n\n\tconst res1 = produce(m, draft => {\n\t\tassert(draft, _ as Map<string, {x: number}>)\n\t})\n\tassert(res1, _ as Map<string, {x: number}>)\n\n\tconst res2 = produce(s, draft => {\n\t\tassert(draft, _ as Set<{x: number}>)\n\t})\n\tassert(res2, _ as Set<{x: number}>)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with readonly Map and Set",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 449,
                "column": 35
            },
            "line": 449,
            "code": "it(\"works with readonly Map and Set\", () => {\n\ttype S = {readonly x: number}\n\tconst m: ReadonlyMap<string, S> = new Map([[\"a\", {x: 1}]])\n\tconst s: ReadonlySet<S> = new Set([{x: 2}])\n\n\tconst res1 = produce(m, (draft: Draft<Map<string, S>>) => {\n\t\tassert(draft, _ as Map<string, {x: number}>)\n\t})\n\tassert(res1, _ as ReadonlyMap<string, {readonly x: number}>)\n\n\tconst res2 = produce(s, (draft: Draft<Set<S>>) => {\n\t\tassert(draft, _ as Set<{x: number}>)\n\t})\n\tassert(res2, _ as ReadonlySet<{readonly x: number}>)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with ReadonlyMap and ReadonlySet",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 465,
                "column": 42
            },
            "line": 465,
            "code": "it(\"works with ReadonlyMap and ReadonlySet\", () => {\n\ttype S = {readonly x: number}\n\tconst m: ReadonlyMap<string, S> = new Map([[\"a\", {x: 1}]])\n\tconst s: ReadonlySet<S> = new Set([{x: 2}])\n\n\tconst res1 = produce(m, (draft: Draft<Map<string, S>>) => {\n\t\tassert(draft, _ as Map<string, {x: number}>)\n\t})\n\tassert(res1, _ as ReadonlyMap<string, {readonly x: number}>)\n\n\tconst res2 = produce(s, (draft: Draft<Set<S>>) => {\n\t\tassert(draft, _ as Set<{x: number}>)\n\t})\n\tassert(res2, _ as ReadonlySet<{readonly x: number}>)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "shows error in production if called incorrectly",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 481,
                "column": 51
            },
            "line": 481,
            "code": "it(\"shows error in production if called incorrectly\", () => {\n\texpect(() => {\n\t\tdebugger\n\t\tproduce(null as any)\n\t}).toThrow(\n\t\t(global as any).USES_BUILD\n\t\t\t? \"[Immer] minified error nr: 6\"\n\t\t\t: \"[Immer] The first or second argument to `produce` must be a function\"\n\t)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#749 types Immer",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 492,
                "column": 20
            },
            "line": 492,
            "code": "it(\"#749 types Immer\", () => {\n\tconst t = {\n\t\tx: 3\n\t}\n\n\tconst immer = new Immer()\n\tconst z = immer.produce(t, d => {\n\t\td.x++\n\t\t// @ts-expect-error\n\t\td.y = 0\n\t})\n\texpect(z.x).toBe(4)\n\t// @ts-expect-error\n\texpect(z.z).toBeUndefined()\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "infers draft, #720",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 508,
                "column": 22
            },
            "line": 508,
            "code": "it(\"infers draft, #720\", () => {\n\tfunction nextNumberCalculator(fn: (base: number) => number) {\n\t\t// noop\n\t}\n\n\tconst res2 = nextNumberCalculator(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tlet x: string = draft\n\t\t\treturn draft + 1\n\t\t})\n\t)\n\n\tconst res = nextNumberCalculator(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tlet x: string = draft\n\t\t\t// return draft + 1;\n\t\t\treturn undefined\n\t\t})\n\t)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "infers draft, #720 - 2",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 531,
                "column": 26
            },
            "line": 531,
            "code": "it(\"infers draft, #720 - 2\", () => {\n\tfunction useState<S>(\n\t\tinitialState: S | (() => S)\n\t): [S, Dispatch<SetStateAction<S>>] {\n\t\treturn [initialState, function() {}] as any\n\t}\n\ttype Dispatch<A> = (value: A) => void\n\ttype SetStateAction<S> = S | ((prevState: S) => S)\n\n\tconst [n, setN] = useState({x: 3})\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tdraft.y = 4\n\t\t\tdraft.x = 5\n\t\t\treturn draft\n\t\t})\n\t)\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tdraft.y = 4\n\t\t\tdraft.x = 5\n\t\t\t// return draft + 1;\n\t\t\treturn undefined\n\t\t})\n\t)\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\treturn {y: 3} as const\n\t\t})\n\t)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "infers draft, #720 - 3",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 568,
                "column": 26
            },
            "line": 568,
            "code": "it(\"infers draft, #720 - 3\", () => {\n\tfunction useState<S>(\n\t\tinitialState: S | (() => S)\n\t): [S, Dispatch<SetStateAction<S>>] {\n\t\treturn [initialState, function() {}] as any\n\t}\n\ttype Dispatch<A> = (value: A) => void\n\ttype SetStateAction<S> = S | ((prevState: S) => S)\n\n\tconst [n, setN] = useState({x: 3} as {readonly x: number})\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tdraft.y = 4\n\t\t\tdraft.x = 5\n\t\t\treturn draft\n\t\t})\n\t)\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\t// @ts-expect-error\n\t\t\tdraft.y = 4\n\t\t\tdraft.x = 5\n\t\t\t// return draft + 1;\n\t\t\treturn undefined\n\t\t})\n\t)\n\n\tsetN(\n\t\tproduce(draft => {\n\t\t\treturn {y: 3} as const\n\t\t})\n\t)\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "infers curried",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 605,
                "column": 18
            },
            "line": 605,
            "code": "it(\"infers curried\", () => {\n\ttype Todo = {title: string}\n\t{\n\t\tconst fn = produce((draft: Todo) => {\n\t\t\tlet x: string = draft.title\n\t\t})\n\n\t\tfn({title: \"test\"})\n\t\t// @ts-expect-error\n\t\tfn(3)\n\t}\n\t{\n\t\tconst fn = produce((draft: Todo) => {\n\t\t\tlet x: string = draft.title\n\t\t\treturn draft\n\t\t})\n\n\t\tfn({title: \"test\"})\n\t\t// @ts-expect-error\n\t\tfn(3)\n\t}\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "infers async curried",
            "suites": [
                "curried producer"
            ],
            "updatePoint": {
                "line": 628,
                "column": 24
            },
            "line": 628,
            "code": "it(\"infers async curried\", async () => {\n\ttype Todo = {title: string}\n\t{\n\t\tconst fn = produce(async (draft: Todo) => {\n\t\t\tlet x: string = draft.title\n\t\t})\n\n\t\tconst res = await fn({title: \"test\"})\n\t\t// @ts-expect-error\n\t\tfn(3)\n\t\tassert(res, _ as Todo)\n\t}\n\t{\n\t\tconst fn = produce(async (draft: Todo) => {\n\t\t\tlet x: string = draft.title\n\t\t\treturn draft\n\t\t})\n\n\t\tconst res = await fn({title: \"test\"})\n\t\t// @ts-expect-error\n\t\tfn(3)\n\t\tassert(res, _ as Todo)\n\t}\n})",
            "file": "produce.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 13,
                "column": 10
            },
            "line": 13,
            "code": "\tit(\"works\", () => {\n\t\tconst baseState = [\n\t\t\t{\n\t\t\t\ttodo: \"Learn typescript\",\n\t\t\t\tdone: true\n\t\t\t},\n\t\t\t{\n\t\t\t\ttodo: \"Try immer\",\n\t\t\t\tdone: false\n\t\t\t}\n\t\t]\n\n\t\tconst nextState = produce(baseState, draft => {\n\t\t\tdraft.push({todo: \"Tweet about it\"})\n\t\t\tdraft[1].done = true\n\t\t})\n\n\t\t// the new item is only added to the next state,\n\t\t// base state is unmodified\n\t\texpect(baseState.length).toBe(2)\n\t\texpect(nextState.length).toBe(3)\n\n\t\t// same for the changed 'done' prop\n\t\texpect(baseState[1].done).toBe(false)\n\t\texpect(nextState[1].done).toBe(true)\n\n\t\t// unchanged data is structurally shared\n\t\texpect(nextState[0]).toBe(baseState[0])\n\t\t// changed data not (dh)\n\t\texpect(nextState[1]).not.toBe(baseState[1])\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "patches",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 45,
                "column": 12
            },
            "line": 45,
            "code": "\tit(\"patches\", () => {\n\t\tlet state = {\n\t\t\tname: \"Micheal\",\n\t\t\tage: 32\n\t\t}\n\n\t\t// Let's assume the user is in a wizard, and we don't know whether\n\t\t// his changes should be updated\n\t\tlet fork = state\n\t\t// all the changes the user made in the wizard\n\t\tlet changes = []\n\t\t// all the inverse patches\n\t\tlet inverseChanges = []\n\n\t\tfork = produce(\n\t\t\tfork,\n\t\t\tdraft => {\n\t\t\t\tdraft.age = 33\n\t\t\t},\n\t\t\t// The third argument to produce is a callback to which the patches will be fed\n\t\t\t(patches, inversePatches) => {\n\t\t\t\tchanges.push(...patches)\n\t\t\t\tinverseChanges.push(...inversePatches)\n\t\t\t}\n\t\t)\n\n\t\t// In the mean time, our original state is updated as well, as changes come in from the server\n\t\tstate = produce(state, draft => {\n\t\t\tdraft.name = \"Michel\"\n\t\t})\n\n\t\t// When the wizard finishes (successfully) we can replay the changes made in the fork onto the *new* state!\n\t\tstate = applyPatches(state, changes)\n\n\t\t// state now contains the changes from both code paths!\n\t\texpect(state).toEqual({\n\t\t\tname: \"Michel\",\n\t\t\tage: 33\n\t\t})\n\n\t\t// Even after finishing the wizard, the user might change his mind...\n\t\tstate = applyPatches(state, inverseChanges)\n\t\texpect(state).toEqual({\n\t\t\tname: \"Michel\",\n\t\t\tage: 32\n\t\t})\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can update set",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 93,
                "column": 19
            },
            "line": 93,
            "code": "\tit(\"can update set\", () => {\n\t\tconst state = {\n\t\t\ttitle: \"hello\",\n\t\t\ttokenSet: new Set()\n\t\t}\n\n\t\tconst nextState = produce(state, draft => {\n\t\t\tdraft.title = draft.title.toUpperCase()\n\t\t\tdraft.tokenSet.add(\"c1342\")\n\t\t})\n\n\t\texpect(state).toEqual({title: \"hello\", tokenSet: new Set()})\n\t\texpect(nextState).toEqual({\n\t\t\ttitle: \"HELLO\",\n\t\t\ttokenSet: new Set([\"c1342\"])\n\t\t})\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "can deep update map",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 111,
                "column": 24
            },
            "line": 111,
            "code": "\tit(\"can deep update map\", () => {\n\t\tconst state = {\n\t\t\tusers: new Map([[\"michel\", {name: \"miche\", age: 27}]])\n\t\t}\n\n\t\tconst nextState = produce(state, draft => {\n\t\t\tdraft.users.get(\"michel\").name = \"michel\"\n\t\t})\n\n\t\texpect(state).toEqual({\n\t\t\tusers: new Map([[\"michel\", {name: \"miche\", age: 27}]])\n\t\t})\n\t\texpect(nextState).toEqual({\n\t\t\tusers: new Map([[\"michel\", {name: \"michel\", age: 27}]])\n\t\t})\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "supports immerable",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 128,
                "column": 23
            },
            "line": 128,
            "code": "\tit(\"supports immerable\", () => {\n\t\tclass Clock {\n\t\t\tconstructor(hours = 0, minutes = 0) {\n\t\t\t\tthis.hours = hours\n\t\t\t\tthis.minutes = minutes\n\t\t\t}\n\n\t\t\tincrement(hours, minutes = 0) {\n\t\t\t\treturn produce(this, d => {\n\t\t\t\t\td.hours += hours\n\t\t\t\t\td.minutes += minutes\n\t\t\t\t})\n\t\t\t}\n\n\t\t\ttoString() {\n\t\t\t\treturn `${(\"\" + this.hours).padStart(2, 0)}:${(\n\t\t\t\t\t\"\" + this.minutes\n\t\t\t\t).padStart(2, 0)}`\n\t\t\t}\n\t\t}\n\t\tClock[immerable] = true\n\n\t\tconst midnight = new Clock()\n\t\tconst lunch = midnight.increment(12, 30)\n\n\t\texpect(midnight).not.toBe(lunch)\n\t\texpect(lunch).toBeInstanceOf(Clock)\n\t\texpect(midnight.toString()).toBe(\"00:00\")\n\t\texpect(lunch.toString()).toBe(\"12:30\")\n\n\t\tconst diner = lunch.increment(6)\n\n\t\texpect(diner).not.toBe(lunch)\n\t\texpect(lunch).toBeInstanceOf(Clock)\n\t\texpect(diner.toString()).toBe(\"18:30\")\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "produceWithPatches",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 165,
                "column": 25
            },
            "line": 165,
            "code": "\ttest(\"produceWithPatches\", () => {\n\t\tconst result = produceWithPatches(\n\t\t\t{\n\t\t\t\tage: 33\n\t\t\t},\n\t\t\tdraft => {\n\t\t\t\tdraft.age++\n\t\t\t}\n\t\t)\n\t\texpect(result).toEqual([\n\t\t\t{\n\t\t\t\tage: 34\n\t\t\t},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [\"age\"],\n\t\t\t\t\tvalue: 34\n\t\t\t\t}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [\"age\"],\n\t\t\t\t\tvalue: 33\n\t\t\t\t}\n\t\t\t]\n\t\t])\n\t})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "Producers can update Maps",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 196,
                "column": 31
            },
            "line": 196,
            "code": "test(\"Producers can update Maps\", () => {\n\tsetAutoFreeze(true)\n\tconst usersById_v1 = new Map()\n\n\tconst usersById_v2 = produce(usersById_v1, draft => {\n\t\t// Modifying a map results in a new map\n\t\tdraft.set(\"michel\", {name: \"Michel Weststrate\", country: \"NL\"})\n\t})\n\n\tconst usersById_v3 = produce(usersById_v2, draft => {\n\t\t// Making a change deep inside a map, results in a new map as well!\n\t\tdraft.get(\"michel\").country = \"UK\"\n\t\tdebugger\n\t})\n\n\t// We got a new map each time!\n\texpect(usersById_v2).not.toBe(usersById_v1)\n\texpect(usersById_v3).not.toBe(usersById_v2)\n\t// With different content obviously\n\texpect(usersById_v1).toMatchInlineSnapshot(`Map {}`)\n\texpect(usersById_v2).toMatchInlineSnapshot(`\n\t\tMap {\n\t\t  \"michel\" => Object {\n\t\t    \"country\": \"NL\",\n\t\t    \"name\": \"Michel Weststrate\",\n\t\t  },\n\t\t}\n\t`)\n\texpect(usersById_v3).toMatchInlineSnapshot(`\n\t\tMap {\n\t\t  \"michel\" => Object {\n\t\t    \"country\": \"UK\",\n\t\t    \"name\": \"Michel Weststrate\",\n\t\t  },\n\t\t}\n\t`)\n\t// The old one was never modified\n\texpect(usersById_v1.size).toBe(0)\n\t// And trying to change a Map outside a producers is going to: NO!\n\texpect(() => usersById_v3.clear()).toThrowErrorMatchingSnapshot()\n})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "clock class",
            "suites": [
                "readme example"
            ],
            "updatePoint": {
                "line": 238,
                "column": 17
            },
            "line": 238,
            "code": "test(\"clock class\", () => {\n\tclass Clock {\n\t\t[immerable] = true\n\n\t\tconstructor(hour, minute) {\n\t\t\tthis.hour = hour\n\t\t\tthis.minute = minute\n\t\t}\n\n\t\tget time() {\n\t\t\treturn `${this.hour}:${this.minute}`\n\t\t}\n\n\t\ttick() {\n\t\t\treturn produce(this, draft => {\n\t\t\t\tdraft.minute++\n\t\t\t})\n\t\t}\n\t}\n\n\tconst clock1 = new Clock(12, 10)\n\tconst clock2 = clock1.tick()\n\texpect(clock1.time).toEqual(\"12:10\") // 12:10\n\texpect(clock2.time).toEqual(\"12:11\") // 12:11\n\texpect(clock2).toBeInstanceOf(Clock)\n})",
            "file": "readme.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#470 works with Redux combine reducers",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 43
            },
            "line": 68,
            "code": "\tit(\"#470 works with Redux combine reducers\", () => {\n\t\tassert(\n\t\t\tstore.getState().counterReducer,\n\t\t\t_ as {\n\t\t\t\tcounter: number\n\t\t\t}\n\t\t)\n\t\tassert(\n\t\t\tcurriedStore.getState().counterReducer,\n\t\t\t_ as {\n\t\t\t\tcounter: number\n\t\t\t}\n\t\t)\n\t})",
            "file": "redux.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#470 works with Redux combine readonly reducers",
            "suites": [],
            "updatePoint": {
                "line": 149,
                "column": 53
            },
            "line": 149,
            "code": "\t\tit(\"#470 works with Redux combine readonly reducers\", () => {\n\t\t\tassert(\n\t\t\t\tstore.getState().counterReducer,\n\t\t\t\t_ as {\n\t\t\t\t\treadonly counter: number\n\t\t\t\t}\n\t\t\t)\n\t\t\tassert(\n\t\t\t\tcurriedStore.getState().counterReducer,\n\t\t\t\t_ as {\n\t\t\t\t\treadonly counter: number\n\t\t\t\t}\n\t\t\t)\n\t\t})",
            "file": "redux.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with inferred curried reducer",
            "suites": [],
            "updatePoint": {
                "line": 166,
                "column": 39
            },
            "line": 166,
            "code": "it(\"works with inferred curried reducer\", () => {\n\ttype State = {\n\t\tcount: number\n\t}\n\n\ttype Action = {\n\t\ttype: \"inc\"\n\t\tcount: number\n\t}\n\n\tconst defaultState = {\n\t\tcount: 3\n\t}\n\n\tconst store = redux.createStore(\n\t\tproduce((state: State, action: Action) => {\n\t\t\tif (action.type === \"inc\") state.count += action.count\n\t\t\t// @ts-expect-error\n\t\t\tstate.count2\n\t\t}, defaultState)\n\t)\n\n\tassert(store.getState(), _ as State)\n\tstore.dispatch({\n\t\ttype: \"inc\",\n\t\tcount: 2\n\t})\n\n\tstore.dispatch({\n\t\t// @ts-expect-error\n\t\ttype: \"inc2\",\n\t\tcount: 2\n\t})\n})",
            "file": "redux.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "works with inferred curried reducer - readonly",
            "suites": [],
            "updatePoint": {
                "line": 201,
                "column": 50
            },
            "line": 201,
            "code": "it(\"works with inferred curried reducer - readonly\", () => {\n\ttype State = {\n\t\treadonly count: number\n\t}\n\n\ttype Action = {\n\t\treadonly type: \"inc\"\n\t\treadonly count: number\n\t}\n\n\tconst defaultState: State = {\n\t\tcount: 3\n\t}\n\n\tconst store = redux.createStore(\n\t\tproduce((state: Draft<State>, action: Action) => {\n\t\t\tif (action.type === \"inc\") state.count += action.count\n\t\t\t// @ts-expect-error\n\t\t\tstate.count2\n\t\t}, defaultState)\n\t)\n\n\tassert(store.getState(), _ as State)\n\tstore.dispatch({\n\t\ttype: \"inc\",\n\t\tcount: 2\n\t})\n\n\tstore.dispatch({\n\t\t// @ts-expect-error\n\t\ttype: \"inc2\",\n\t\tcount: 2\n\t})\n})",
            "file": "redux.ts",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#604 freeze inside class",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 41,
                "column": 32
            },
            "line": 41,
            "code": "\t\ttest(\"#604 freeze inside class\", () => {\n\t\t\tclass Thing {\n\t\t\t\t[immerable] = true\n\n\t\t\t\tconstructor({x}) {\n\t\t\t\t\tthis._data = {x}\n\t\t\t\t}\n\n\t\t\t\tget x() {\n\t\t\t\t\treturn this._data.x\n\t\t\t\t}\n\n\t\t\t\tset x(x) {\n\t\t\t\t\tthis._data.x = x\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet i = 1\n\t\t\tlet item = new Thing({x: i})\n\t\t\tlet item0 = item\n\n\t\t\tconst bump = () => {\n\t\t\t\titem = produce(item, draft => {\n\t\t\t\t\t// uncomment this to make things work\n\t\t\t\t\t//draft._data\n\t\t\t\t\tdraft.x = ++i\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tbump()\n\t\t\tbump()\n\n\t\t\texpect(i).toBe(3)\n\t\t\texpect(item._data).toEqual({\n\t\t\t\tx: 3\n\t\t\t})\n\t\t\texpect(item0._data).toEqual({\n\t\t\t\tx: 1\n\t\t\t})\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#646 setting undefined field to undefined should not create new result",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 82,
                "column": 78
            },
            "line": 82,
            "code": "\t\ttest(\"#646 setting undefined field to undefined should not create new result\", () => {\n\t\t\tconst foo = {\n\t\t\t\tbar: undefined\n\t\t\t}\n\t\t\tconst foo2 = produce(foo, draft => {\n\t\t\t\tdraft.bar = undefined\n\t\t\t})\n\t\t\texpect(foo2).toBe(foo)\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#646 - 2 setting undefined field to undefined should not create new result",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 92,
                "column": 82
            },
            "line": 92,
            "code": "\t\ttest(\"#646 - 2 setting undefined field to undefined should not create new result\", () => {\n\t\t\tconst foo = {}\n\t\t\tconst foo2 = produce(foo, draft => {\n\t\t\t\tdraft.bar = undefined\n\t\t\t})\n\t\t\texpect(foo2).not.toBe(foo)\n\t\t\texpect(foo).toEqual({})\n\t\t\texpect(foo2).toEqual({bar: undefined})\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#638 - out of range assignments",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 102,
                "column": 39
            },
            "line": 102,
            "code": "\t\ttest(\"#638 - out of range assignments\", () => {\n\t\t\tconst state = []\n\n\t\t\tconst state1 = produce(state, draft => {\n\t\t\t\tdraft[2] = \"v2\"\n\t\t\t})\n\n\t\t\texpect(state1.length).toBe(3)\n\t\t\texpect(state1).toEqual([undefined, undefined, \"v2\"])\n\n\t\t\tconst state2 = produce(state1, draft => {\n\t\t\t\tdraft[1] = \"v1\"\n\t\t\t})\n\n\t\t\texpect(state2.length).toBe(3)\n\t\t\texpect(state2).toEqual([undefined, \"v1\", \"v2\"])\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#628 set removal hangs",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 120,
                "column": 30
            },
            "line": 120,
            "code": "\t\ttest(\"#628 set removal hangs\", () => {\n\t\t\tlet arr = []\n\t\t\tlet set = new Set([arr])\n\n\t\t\tlet result = produce(set, draft1 => {\n\t\t\t\tproduce(draft1, draft2 => {\n\t\t\t\t\tdraft2.delete(arr)\n\t\t\t\t})\n\t\t\t})\n\t\t\texpect(result).toEqual(new Set([[]])) // N.B. this outcome doesn't seem not correct, but then again,\n\t\t\t// double produce without return looks iffy as well, so not sure what the expected outcome in the\n\t\t\t// original report was\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#628 - 2 set removal hangs",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 134,
                "column": 34
            },
            "line": 134,
            "code": "\t\ttest(\"#628 - 2 set removal hangs\", () => {\n\t\t\tlet arr = []\n\t\t\tlet set = new Set([arr])\n\n\t\t\tlet result = produce(set, draft2 => {\n\t\t\t\tdraft2.delete(arr)\n\t\t\t})\n\t\t\texpect(result).toEqual(new Set())\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#650 - changes with overridden arr.slice() fail",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 144,
                "column": 55
            },
            "line": 144,
            "code": "\t\ttest(\"#650 - changes with overridden arr.slice() fail\", () => {\n\t\t\tconst data = {\n\t\t\t\tfoo: [\n\t\t\t\t\t{\n\t\t\t\t\t\tisActive: false\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t\t// That's roughly what seamless-immutable does\n\t\t\tdata.foo.slice = (...args) =>\n\t\t\t\tObject.freeze(Array.prototype.slice.call(data.foo, ...args))\n\n\t\t\tconst newData = produce(data, draft => {\n\t\t\t\tdraft.foo[0].isActive = true\n\t\t\t})\n\t\t\texpect(newData.foo[0].isActive).toBe(true)\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 162,
                "column": 41
            },
            "line": 162,
            "code": "\t\ttest(\"#659 no reconciliation after read\", () => {\n\t\t\tconst bar = {}\n\t\t\tconst foo = {bar}\n\n\t\t\tconst next = produce(foo, draft => {\n\t\t\t\tdraft.bar\n\t\t\t\tdraft.bar = bar\n\t\t\t})\n\t\t\texpect(next).toBe(foo)\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read - 2",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 173,
                "column": 45
            },
            "line": 173,
            "code": "\t\ttest(\"#659 no reconciliation after read - 2\", () => {\n\t\t\tconst bar = {}\n\t\t\tconst foo = {bar}\n\n\t\t\tconst next = produce(foo, draft => {\n\t\t\t\tconst subDraft = draft.bar\n\t\t\t\tdraft.bar = bar\n\t\t\t\tsubDraft.x = 3 // this subDraft is not part of the end result, so ignore\n\t\t\t})\n\n\t\t\texpect(next).toEqual(foo)\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read - 3",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 186,
                "column": 45
            },
            "line": 186,
            "code": "\t\ttest(\"#659 no reconciliation after read - 3\", () => {\n\t\t\tconst bar = {}\n\t\t\tconst foo = {bar}\n\n\t\t\tconst next = produce(foo, draft => {\n\t\t\t\tconst subDraft = draft.bar\n\t\t\t\tsubDraft.x = 3 // this subDraft is not part of the end result, so ignore\n\t\t\t\tdraft.bar = bar\n\t\t\t})\n\t\t\texpect(next).toEqual(foo)\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read - 4",
            "suites": [
                "regressions "
            ],
            "line": 200,
            "code": "\t\ttest.skip(\"#659 no reconciliation after read - 4\", () => {",
            "file": "regressions.js",
            "skipped": true,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read - 5",
            "suites": [
                "regressions "
            ],
            "line": 215,
            "code": "\t\ttest.skip(\"#659 no reconciliation after read - 5\", () => {",
            "file": "regressions.js",
            "skipped": true,
            "dir": "__tests__"
        },
        {
            "name": "#659 no reconciliation after read - 6",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 227,
                "column": 45
            },
            "line": 227,
            "code": "\t\ttest(\"#659 no reconciliation after read - 6\", () => {\n\t\t\tconst bar = {}\n\t\t\tconst foo = {bar}\n\n\t\t\tconst next = produce(foo, draft => {\n\t\t\t\tconst subDraft = draft.bar\n\t\t\t\tsubDraft.x = 3 // this subDraft is not part of the end result, so ignore\n\t\t\t\tdraft.bar = bar\n\t\t\t\tdraft.bar = subDraft\n\t\t\t})\n\t\t\texpect(next).not.toBe(foo)\n\t\t\texpect(next).toEqual({\n\t\t\t\tbar: {x: 3}\n\t\t\t})\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        },
        {
            "name": "#807 new undefined member not stored",
            "suites": [
                "regressions "
            ],
            "updatePoint": {
                "line": 243,
                "column": 44
            },
            "line": 243,
            "code": "\t\ttest(\"#807 new undefined member not stored\", () => {\n\t\t\tconst state = {}\n\t\t\tconst newState = produce(state, draft => {\n\t\t\t\tdraft.baz = undefined\n\t\t\t})\n\t\t\texpect(state).not.toBe(newState)\n\t\t\texpect(Object.hasOwnProperty.call(newState, \"baz\")).toBe(true)\n\t\t\texpect(newState).toEqual({\n\t\t\t\tbaz: undefined\n\t\t\t})\n\t\t})",
            "file": "regressions.js",
            "skipped": false,
            "dir": "__tests__"
        }
    ],
    "badge": "immerjs__immer.svg"
}