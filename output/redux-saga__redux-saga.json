{"repo":"redux-saga/redux-saga","url":"https://github.com/redux-saga/redux-saga","branch":"master","configs":[{"package":"babel-plugin-redux-saga","lang":"js","dir":"packages/babel-plugin-redux-saga/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@redux-saga/core","lang":"js","dir":"packages/core/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@redux-saga/testing-utils","lang":"js","dir":"packages/testing-utils/__tests__","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"action channel","suites":[],"updatePoint":{"line":6,"column":20},"line":6,"code":"test('action channel', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* saga() {\n    const chan = yield actionChannel('ACTION');\n\n    while (true) {\n      const {\n        payload\n      } = yield take(chan);\n      actual.push(payload);\n      yield Promise.resolve(); // block\n    }\n  }\n\n  const taskP = middleware.run(saga).toPromise();\n\n  for (var i = 0; i < 3; i++) {\n    store.dispatch({\n      type: 'ACTION',\n      payload: i + 1\n    });\n  }\n\n  store.dispatch(END);\n  return taskP.then(() => {\n    // Sagas must take consecutive actions dispatched synchronously on an action channel even if it performs blocking calls\n    expect(actual).toEqual([1, 2, 3]);\n  });\n});","file":"channel-recipes.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"error check when constructing actionChannels","suites":[],"updatePoint":{"line":38,"column":50},"line":38,"code":"test('error check when constructing actionChannels', () => {\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err.message).toMatchInlineSnapshot(`\"actionChannel(pattern,...): argument pattern is not valid\"`);\n    }\n  });\n  applyMiddleware(middleware)(createStore)(() => {});\n\n  function* saga() {\n    yield actionChannel(['ACTION', undefined]);\n  }\n\n  const promise = middleware.run(saga).toPromise();\n  return expect(promise).rejects.toThrow('argument pattern is not valid');\n});","file":"channel-recipes.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"action channel generator","suites":[],"updatePoint":{"line":53,"column":30},"line":53,"code":"test('action channel generator', () => {\n  function* saga() {\n    const chan = yield actionChannel('ACTION');\n\n    while (true) {\n      const {\n        payload\n      } = yield take(chan);\n      yield Promise.resolve(); // block\n    }\n  }\n\n  let gen = saga();\n  let chan = actionChannel('ACTION');\n  expect(gen.next().value).toEqual(chan);\n  const mockChannel = channel();\n  expect(gen.next(mockChannel).value).toEqual(take(mockChannel));\n});","file":"channel-recipes.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"action channel generator with buffers","suites":[],"updatePoint":{"line":71,"column":43},"line":71,"code":"test('action channel generator with buffers', () => {\n  function* saga() {\n    const buffer = yield call(buffers.dropping, 1);\n    const chan = yield actionChannel('ACTION', buffer);\n\n    while (true) {\n      const {\n        payload\n      } = yield take(chan);\n      yield Promise.resolve(); // block\n    }\n  }\n\n  let gen = saga();\n  expect(gen.next().value).toEqual(call(buffers.dropping, 1));\n  let buffer = buffers.dropping(1);\n  let chan = actionChannel('ACTION', buffer);\n  expect(gen.next(buffer).value).toEqual(chan);\n  const mockChannel = channel();\n  expect(gen.next(mockChannel).value).toEqual(take(mockChannel));\n});","file":"channel-recipes.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"channel: watcher + max workers","suites":[],"updatePoint":{"line":92,"column":36},"line":92,"code":"test('channel: watcher + max workers', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* saga() {\n    const chan = channel();\n\n    try {\n      for (var i = 0; i < 3; i++) {\n        yield fork(worker, i + 1, chan);\n      }\n\n      while (true) {\n        const {\n          payload\n        } = yield take('ACTION');\n        yield put(chan, payload);\n      }\n    } finally {\n      chan.close();\n    }\n  }\n\n  function* worker(idx, chan) {\n    let count = 0;\n\n    while (true) {\n      actual.push([idx, yield take(chan)]); // 1st worker will 'sleep' after taking 2 messages on the 1st round\n\n      if (idx === 1 && ++count === 2) {\n        yield Promise.resolve();\n      }\n    }\n  }\n\n  const taskP = middleware.run(saga).toPromise();\n\n  for (var i = 0; i < 10; i++) {\n    store.dispatch({\n      type: 'ACTION',\n      payload: i + 1,\n      round: 1\n    });\n  }\n\n  store.dispatch(END);\n  return taskP.then(() => {\n    // Saga must dispatch to free workers via channel\n    expect(actual).toEqual([[1, 1], [2, 2], [3, 3], [1, 4], [2, 5], [3, 6], [2, 7], [3, 8], [2, 9], [3, 10]]);\n  });\n});","file":"channel-recipes.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"Unbuffered channel","suites":[],"updatePoint":{"line":6,"column":24},"line":6,"code":"test('Unbuffered channel', () => {\n  let chan = channel(buffers.none());\n  let actual = [];\n\n  const logger = () => ac => actual.push(ac);\n\n  try {\n    chan.put(undefined);\n  } catch (e) {\n    // channel should reject undefined messages\n    expect(/provided with an undefined/.test(e.message)).toBe(true);\n  }\n\n  chan = channel(buffers.none());\n  chan.take(logger(), eq(1));\n  const cb = logger();\n  chan.take(cb, eq(1));\n  chan.put(1); // channel must notify takers\n\n  expect(actual).toEqual([1]);\n  cb.cancel();\n  chan.put(1); // channel must discard cancelled takes\n\n  expect(actual).toEqual([1]);\n  actual = [];\n  chan.take(logger());\n  chan.take(logger());\n  chan.close(); // closing a channel must resolve all takers with END\n\n  expect(actual).toEqual([END, END]);\n  actual = [];\n  chan.take(logger()); // closed channel must resolve new takers with END\n\n  expect(actual).toEqual([END]);\n  chan.put('action-after-end'); // channel must reject messages after being closed\n\n  expect(actual).toEqual([END]);\n});","file":"channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"buffered channel","suites":[],"updatePoint":{"line":44,"column":22},"line":44,"code":"test('buffered channel', () => {\n  const buffer = [];\n  const spyBuffer = {\n    isEmpty: () => !buffer.length,\n    put: it => buffer.push(it),\n    take: () => buffer.shift()\n  };\n  let chan = channel(spyBuffer);\n  let log = [];\n\n  const taker = () => {\n    const _taker = ac => {\n      _taker.called = true;\n      log.push(ac);\n    };\n\n    _taker.called = false;\n    return _taker;\n  };\n\n  var t1 = taker();\n  chan.take(t1); // channel must queue pending takers if there are no buffered messages\n\n  expect([t1.called, log, buffer]).toEqual([false, [], []]);\n  const t2 = taker();\n  chan.take(t2);\n  chan.put(1); // channel must resolve the oldest pending taker with a new message\n\n  expect([t1.called, t2.called, log, buffer]).toEqual([true, false, [1], []]);\n  chan.put(2);\n  chan.put(3);\n  chan.put(4); // channel must buffer new messages if there are no takers\n\n  expect([buffer, t2.called, log]).toEqual([[3, 4], true, [1, 2]]);\n  const t3 = taker();\n  chan.take(t3); // channel must resolve new takers if there are buffered messages\n\n  expect([t3.called, buffer, log]).toEqual([true, [4], [1, 2, 3]]);\n  chan.close(); // closing an already closed channel should be noop\n\n  chan.close();\n  chan.put('hi');\n  chan.put('I said hi'); // putting on an already closed channel should be noop\n\n  expect(buffer).toEqual([4]);\n  chan.take(taker()); // closed channel must resolve new takers with any buffered message\n\n  expect([log, buffer]).toEqual([[1, 2, 3, 4], []]);\n  chan.take(taker()); // closed channel must resolve new takers with END if there are no buffered message\n\n  expect(log).toEqual([1, 2, 3, 4, END]);\n});","file":"channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"event channel","suites":[],"updatePoint":{"line":96,"column":19},"line":96,"code":"test('event channel', () => {\n  let unsubscribeErr;\n\n  try {\n    eventChannel(() => {});\n  } catch (err) {\n    unsubscribeErr = err;\n  } // eventChannel should throw if subscriber does not return a function to unsubscribe\n\n\n  expect(unsubscribeErr.message).toBe('in eventChannel: subscribe should return a function to unsubscribe');\n  const em = mitt();\n  let chan = eventChannel(emit => {\n    em.on('*', emit);\n    return () => em.off('*', emit);\n  });\n  let actual = [];\n  chan.take(ac => actual.push(ac));\n  em.emit('action-1'); // eventChannel must notify takers on a new action\n\n  expect(actual).toEqual(['action-1']);\n  em.emit('action-1'); // eventChannel must notify takers only once\n\n  expect(actual).toEqual(['action-1']);\n  actual = [];\n  chan.take(ac => actual.push(ac), ac => ac === 'action-xxx');\n  chan.close(); // eventChannel must notify all pending takers on END\n\n  expect(actual).toEqual([END]);\n  actual = [];\n  chan.take(ac => actual.push(ac), ac => ac === 'action-yyy'); // eventChannel must notify all new takers if closed\n\n  expect(actual).toEqual([END]);\n});","file":"channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"unsubscribe event channel","suites":[],"updatePoint":{"line":130,"column":31},"line":130,"code":"test('unsubscribe event channel', done => {\n  let unsubscribed = false;\n  let chan = eventChannel(() => () => {\n    unsubscribed = true;\n  });\n  chan.close(); // eventChannel should call unsubscribe when channel is closed\n\n  expect(unsubscribed).toBe(true);\n  unsubscribed = false;\n  chan = eventChannel(emitter => {\n    emitter(END);\n    return () => {\n      unsubscribed = true;\n    };\n  }); // eventChannel should call unsubscribe when END event is emitted synchronously\n\n  expect(unsubscribed).toBe(true);\n  unsubscribed = false;\n  chan = eventChannel(emitter => {\n    setTimeout(() => emitter(END), 0);\n    return () => {\n      unsubscribed = true;\n    };\n  });\n  chan.take(input => {\n    // should emit END event\n    expect(input).toBe(END); // eventChannel should call unsubscribe when END event is emitted asynchronously\n\n    expect(unsubscribed).toBe(true);\n    done();\n  });\n});","file":"channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"expanding buffer","suites":[],"updatePoint":{"line":162,"column":22},"line":162,"code":"test('expanding buffer', () => {\n  let chan = channel(buffers.expanding(2));\n  chan.put('action-1');\n  chan.put('action-2');\n  chan.put('action-3');\n  let actual;\n  chan.flush(items => actual = items.length);\n  let expected = 3; // expanding buffer should be able to buffer more items than its initial limit\n\n  expect(actual).toBe(expected);\n});","file":"channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga parallel effects handling","suites":[],"updatePoint":{"line":7,"column":36},"line":7,"code":"test('saga parallel effects handling', () => {\n  let actual;\n  const def = deferred();\n  let cpsCb = {};\n\n  const cps = (val, cb) => cpsCb = {\n    val,\n    cb\n  };\n\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    actual = yield io.all([def.promise, io.cps(cps, 2), io.take('action')]);\n  }\n\n  const task = middleware.run(genFn);\n  Promise.resolve(1).then(() => def.resolve(1)).then(() => cpsCb.cb(null, cpsCb.val)).then(() => store.dispatch({\n    type: 'action'\n  }));\n  const expected = [1, 2, {\n    type: 'action'\n  }];\n  return task.toPromise().then(() => {\n    // saga must fulfill parallel effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/all.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga empty array","suites":[],"updatePoint":{"line":36,"column":22},"line":36,"code":"test('saga empty array', () => {\n  let actual;\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    actual = yield io.all([]);\n  }\n\n  const expected = [];\n  const task = middleware.run(genFn);\n  return task.toPromise().then(() => {\n    // saga must fulfill empty parallel effects with an empty array\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/all.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga parallel effect: handling errors","suites":[],"updatePoint":{"line":52,"column":43},"line":52,"code":"test('saga parallel effect: handling errors', () => {\n  let actual;\n  const defs = arrayOfDeferred(2);\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  Promise.resolve(1).then(() => defs[0].reject('error')).then(() => defs[1].resolve(1));\n\n  function* genFn() {\n    try {\n      actual = yield io.all([defs[0].promise, defs[1].promise]);\n    } catch (err) {\n      actual = [err];\n    }\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['error'];\n  return task.toPromise().then(() => {\n    // saga must catch the first error in parallel effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/all.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga parallel effect: handling END","suites":[],"updatePoint":{"line":74,"column":40},"line":74,"code":"test('saga parallel effect: handling END', () => {\n  let actual;\n  const def = deferred();\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    try {\n      actual = yield io.all([def.promise, io.take('action')]);\n    } finally {\n      actual = 'end';\n    }\n  }\n\n  const task = middleware.run(genFn);\n  Promise.resolve(1).then(() => def.resolve(1)).then(() => store.dispatch(END));\n  return task.toPromise().then(() => {\n    // saga must end Parallel Effect if one of the effects resolve with END\n    expect(actual).toEqual('end');\n  });\n});","file":"interpreter/all.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga parallel effect: named effects","suites":[],"updatePoint":{"line":95,"column":41},"line":95,"code":"test('saga parallel effect: named effects', () => {\n  let actual;\n  const def = deferred();\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    actual = yield io.all({\n      ac: io.take('action'),\n      prom: def.promise\n    });\n  }\n\n  const task = middleware.run(genFn);\n  Promise.resolve(1).then(() => def.resolve(1)).then(() => store.dispatch({\n    type: 'action'\n  }));\n  const expected = {\n    ac: {\n      type: 'action'\n    },\n    prom: 1\n  };\n  return task.toPromise().then(() => {\n    // saga must handle parallel named effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/all.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga iteration","suites":[],"updatePoint":{"line":19,"column":20},"line":19,"code":"test('saga iteration', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    actual.push(yield 1);\n    actual.push(yield 2);\n    return 3;\n  }\n\n  const task = middleware.run(genFn); // saga should return a promise of the iterator result\n\n  expect(is.promise(task.toPromise())).toBe(true);\n  return task.toPromise().then(res => {\n    // saga's iterator should return false from isRunning()\n    expect(task.isRunning()).toBe(false); // saga returned promise should resolve with the iterator return value\n\n    expect(res).toBe(3); // saga should collect yielded values from the iterator\n\n    expect(actual).toEqual([1, 2]);\n  });\n});","file":"interpreter/base.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga error handling","suites":[],"updatePoint":{"line":42,"column":25},"line":42,"code":"test('saga error handling', () => {\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err.message).toBe('test-error');\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function fnThrow() {\n    throw new Error('test-error');\n  }\n  /*\n    throw\n  */\n\n\n  function* genThrow() {\n    fnThrow();\n  }\n\n  const task1 = middleware.run(genThrow);\n  const promise1 = task1.toPromise().then(() => {\n    throw new Error('saga must return a rejected promise if generator throws an uncaught error');\n  }, (err // saga must return a rejected promise if generator throws an uncaught error\n  ) => {\n    expect(err.message).toBe('test-error');\n  });\n  /*\n    try + catch + finally\n  */\n\n  let actual = [];\n\n  function* genFinally() {\n    try {\n      fnThrow();\n      actual.push('unreachable');\n    } catch (error) {\n      actual.push('caught-' + error.message);\n    } finally {\n      actual.push('finally');\n    }\n  }\n\n  const task = middleware.run(genFinally);\n  const promise2 = task.toPromise().then(() => {\n    // saga must route to catch/finally blocks in the generator\n    expect(actual).toEqual(['caught-test-error', 'finally']);\n  });\n  return Promise.all([promise1, promise2]);\n});","file":"interpreter/base.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga output handling","suites":[],"updatePoint":{"line":93,"column":26},"line":93,"code":"test('saga output handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return state;\n  };\n\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function* genFn(arg) {\n    yield io.put({\n      type: arg\n    });\n    yield io.put({\n      type: 2\n    });\n  }\n\n  const task = middleware.run(genFn, 'arg');\n  const expected = ['arg', 2];\n  return task.toPromise().then(() => {\n    // saga must handle generator output\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/base.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga yielded falsy values","suites":[],"updatePoint":{"line":125,"column":31},"line":125,"code":"test('saga yielded falsy values', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    actual.push(yield false);\n    actual.push(yield undefined);\n    actual.push(yield null);\n    actual.push(yield '');\n    actual.push(yield 0);\n    actual.push(yield NaN);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [false, undefined, null, '', 0, NaN];\n  return task.toPromise().then(() => {\n    expect(isNaN(last(expected))).toBe(true); // saga must inject back yielded falsy values\n\n    expect(dropRight(1, actual)).toEqual(dropRight(1, expected));\n  });\n});","file":"interpreter/base.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga handles call effects and resume with the resolved values","suites":[],"updatePoint":{"line":4,"column":67},"line":4,"code":"test('saga handles call effects and resume with the resolved values', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  class C {\n    constructor(val) {\n      this.val = val;\n    }\n\n    method() {\n      return Promise.resolve(this.val);\n    }\n\n  }\n\n  const inst1 = new C(1);\n  const inst2 = new C(2);\n  const inst3 = new C(3);\n  const inst4 = new C(4);\n  const inst5 = new C(5);\n  const inst6 = new C(6);\n  const eight = Symbol(8);\n\n  function* subGen(io, arg) {\n    yield Promise.resolve(null);\n    return arg;\n  }\n\n  function identity(arg) {\n    return arg;\n  }\n\n  function* genFn() {\n    actual.push(yield io.call([inst1, inst1.method]));\n    actual.push(yield io.call([inst2, 'method']));\n    actual.push(yield io.apply(inst3, inst3.method));\n    actual.push(yield io.apply(inst4, 'method'));\n    actual.push(yield io.call({\n      context: inst5,\n      fn: inst5.method\n    }));\n    actual.push(yield io.call({\n      context: inst6,\n      fn: 'method'\n    }));\n    actual.push(yield io.call(subGen, io, 7));\n    actual.push(yield io.call(identity, eight));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [1, 2, 3, 4, 5, 6, 7, eight];\n  return task.toPromise().then(() => {\n    // saga must fulfill declarative call effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/call.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga handles call effects and throw the rejected values inside the generator","suites":[],"updatePoint":{"line":61,"column":82},"line":61,"code":"test('saga handles call effects and throw the rejected values inside the generator', () => {\n  let actual = [];\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return {};\n  };\n\n  const middleware = sagaMiddleware();\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function fail(msg) {\n    return Promise.reject(msg);\n  }\n\n  function* genFnParent() {\n    try {\n      yield io.put({\n        type: 'start'\n      });\n      yield io.call(fail, 'failure');\n      yield io.put({\n        type: 'success'\n      });\n    } catch (e) {\n      yield io.put({\n        type: e\n      });\n    }\n  }\n\n  const task = middleware.run(genFnParent);\n  const expected = ['start', 'failure'];\n  return task.toPromise().then(() => {\n    // saga dispatches appropriate actions\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/call.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga handles call's synchronous failures and throws in the calling generator (1)","suites":[],"updatePoint":{"line":104,"column":86},"line":104,"code":"test(\"saga handles call's synchronous failures and throws in the calling generator (1)\", () => {\n  let actual = [];\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return {};\n  };\n\n  const middleware = sagaMiddleware();\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function fail(message) {\n    throw new Error(message);\n  }\n\n  function* genFnChild() {\n    try {\n      yield io.put({\n        type: 'startChild'\n      });\n      yield io.call(fail, 'child error');\n      yield io.put({\n        type: 'success child'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure child'\n      });\n    }\n  }\n\n  function* genFnParent() {\n    try {\n      yield io.put({\n        type: 'start parent'\n      });\n      yield io.call(genFnChild);\n      yield io.put({\n        type: 'success parent'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure parent'\n      });\n    }\n  }\n\n  const task = middleware.run(genFnParent);\n  const expected = ['start parent', 'startChild', 'failure child', 'success parent'];\n  return task.toPromise().then(() => {\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/call.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga handles call's synchronous failures and throws in the calling generator (2)","suites":[],"updatePoint":{"line":162,"column":86},"line":162,"code":"test(\"saga handles call's synchronous failures and throws in the calling generator (2)\", () => {\n  let actual = [];\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return {};\n  };\n\n  const middleware = sagaMiddleware();\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function fail(message) {\n    throw new Error(message);\n  }\n\n  function* genFnChild() {\n    try {\n      yield io.put({\n        type: 'startChild'\n      });\n      yield io.call(fail, 'child error');\n      yield io.put({\n        type: 'success child'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure child'\n      });\n      throw e;\n    }\n  }\n\n  function* genFnParent() {\n    try {\n      yield io.put({\n        type: 'start parent'\n      });\n      yield io.call(genFnChild);\n      yield io.put({\n        type: 'success parent'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure parent'\n      });\n    }\n  }\n\n  const task = middleware.run(genFnParent);\n  const expected = ['start parent', 'startChild', 'failure child', 'failure parent'];\n  return task.toPromise().then(() => {\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/call.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga handles call's synchronous failures and throws in the calling generator (2)","suites":[],"updatePoint":{"line":221,"column":86},"line":221,"code":"test(\"saga handles call's synchronous failures and throws in the calling generator (2)\", () => {\n  let actual = [];\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return {};\n  };\n\n  const middleware = sagaMiddleware();\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function* genFnChild() {\n    throw 'child error';\n  }\n\n  function* genFnParent() {\n    try {\n      yield io.put({\n        type: 'start parent'\n      });\n      yield io.call(genFnChild);\n      yield io.put({\n        type: 'success parent'\n      });\n    } catch (e) {\n      yield io.put({\n        type: e\n      });\n      yield io.put({\n        type: 'failure parent'\n      });\n    }\n  }\n\n  const task = middleware.run(genFnParent);\n  const expected = ['start parent', 'child error', 'failure parent'];\n  return task.toPromise().then(() => {\n    // saga should bubble synchronous call errors parent\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/call.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: call effect","suites":[],"updatePoint":{"line":7,"column":36},"line":7,"code":"test('saga cancellation: call effect', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let startDef = deferred();\n  let cancelDef = deferred();\n  let subroutineDef = deferred();\n  Promise.resolve(1).then(() => startDef.resolve('start')).then(() => cancelDef.resolve('cancel')).then(() => subroutineDef.resolve('subroutine'));\n\n  function* main() {\n    actual.push(yield startDef.promise);\n\n    try {\n      actual.push(yield io.call(subroutine));\n    } finally {\n      if (yield io.cancelled()) actual.push('cancelled');\n    }\n  }\n\n  function* subroutine() {\n    actual.push(yield 'subroutine start');\n\n    try {\n      actual.push(yield subroutineDef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(v => {\n    actual.push(v);\n    task.cancel();\n  });\n  const expected = ['start', 'subroutine start', 'cancel', 'subroutine cancelled', 'cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled call effect must throw exception inside called subroutine\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: forked children","suites":[],"updatePoint":{"line":47,"column":40},"line":47,"code":"test('saga cancellation: forked children', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let cancelDef = deferred();\n  const rootDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const neverDef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(() => childAdef.resolve('childA resolve')).then(() => rootDef.resolve('root resolve')).then(() => defs[0].resolve('leaf 0 resolve')).then(() => childBdef.resolve('childB resolve')) //\n  .then(() => cancelDef.resolve('cancel')).then(() => defs[3].resolve('leaf 3 resolve')).then(() => defs[2].resolve('leaf 2 resolve')).then(() => defs[1].resolve('leaf 1 resolve'));\n\n  function* main() {\n    try {\n      yield io.fork(childA);\n      actual.push(yield rootDef.promise);\n      yield io.fork(childB);\n      yield neverDef.promise;\n    } finally {\n      if (yield io.cancelled()) actual.push('main cancelled');\n    }\n  }\n\n  function* childA() {\n    try {\n      yield io.fork(leaf, 0);\n      actual.push(yield childAdef.promise);\n      yield io.fork(leaf, 1);\n      yield neverDef.promise;\n    } finally {\n      if (yield io.cancelled()) actual.push('childA cancelled');\n    }\n  }\n\n  function* childB() {\n    try {\n      yield io.fork(leaf, 2);\n      actual.push(yield childBdef.promise);\n      yield io.fork(leaf, 3);\n      yield neverDef.promise;\n    } finally {\n      if (yield io.cancelled()) actual.push('childB cancelled');\n    }\n  }\n\n  function* leaf(idx) {\n    try {\n      actual.push(yield defs[idx].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(`leaf ${idx} cancelled`);\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(() => task.cancel());\n  const expected = ['childA resolve', 'root resolve', 'leaf 0 resolve', 'childB resolve',\n  /* cancel */\n  'main cancelled', 'childA cancelled', 'leaf 1 cancelled', 'childB cancelled', 'leaf 2 cancelled', 'leaf 3 cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled main task must cancel all forked sub-tasks\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: take effect","suites":[],"updatePoint":{"line":111,"column":36},"line":111,"code":"test('saga cancellation: take effect', () => {\n  let actual = [];\n  let startDef = deferred();\n  let cancelDef = deferred();\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* main() {\n    actual.push(yield startDef.promise);\n\n    try {\n      actual.push(yield io.take('action'));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(v => {\n    actual.push(v);\n    task.cancel();\n  });\n  Promise.resolve(1).then(() => startDef.resolve('start')).then(() => cancelDef.resolve('cancel')).then(() => store.dispatch({\n    type: 'action'\n  }));\n  const expected = ['start', 'cancel', 'cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled take effect must stop waiting for action\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: join effect (joining from a different task)","suites":[],"updatePoint":{"line":142,"column":68},"line":142,"code":"test('saga cancellation: join effect (joining from a different task)', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let cancelDef = deferred();\n  let subroutineDef = deferred();\n  Promise.resolve(1).then(() => cancelDef.resolve('cancel')).then(() => subroutineDef.resolve('subroutine'));\n\n  function* main() {\n    actual.push('start');\n    let task = yield io.fork(subroutine);\n    yield io.fork(callerOfJoiner1, task);\n    yield io.fork(joiner2, task);\n    actual.push(yield cancelDef.promise);\n    yield io.cancel(task);\n  }\n\n  function* subroutine() {\n    actual.push('subroutine start');\n\n    try {\n      actual.push(yield subroutineDef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine cancelled');\n    }\n  }\n\n  function* callerOfJoiner1(task) {\n    try {\n      actual.push(yield io.all([io.call(joiner1, task), new Promise(() => {})]));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'caller of joiner1 cancelled');\n    }\n  }\n\n  function* joiner1(task) {\n    actual.push('joiner1 start');\n\n    try {\n      actual.push(yield io.join(task));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'joiner1 cancelled');\n    }\n  }\n\n  function* joiner2(task) {\n    actual.push('joiner2 start');\n\n    try {\n      actual.push(yield io.join(task));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'joiner2 cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  /**\n    Breaking change in 10.0:\n  **/\n\n  const expected = ['start', 'subroutine start', 'joiner1 start', 'joiner2 start', 'cancel', 'subroutine cancelled', 'joiner1 cancelled', 'caller of joiner1 cancelled', 'joiner2 cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled task must cancel foreing joiners\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: join effect (join from the same task's parent)","suites":[],"updatePoint":{"line":208,"column":71},"line":208,"code":"test(\"saga cancellation: join effect (join from the same task's parent)\", () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let startDef = deferred();\n  let cancelDef = deferred();\n  let subroutineDef = deferred();\n  Promise.resolve(1).then(() => startDef.resolve('start')).then(() => cancelDef.resolve('cancel')).then(() => subroutineDef.resolve('subroutine'));\n\n  function* main() {\n    actual.push(yield startDef.promise);\n    let task = yield io.fork(subroutine);\n\n    try {\n      actual.push(yield io.join(task));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'cancelled');\n    }\n  }\n\n  function* subroutine() {\n    actual.push(yield 'subroutine start');\n\n    try {\n      actual.push(yield subroutineDef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(v => {\n    actual.push(v);\n    task.cancel();\n  });\n  /**\n    Breaking change in 10.0: Since now attached forks are cancelled when their parent is cancelled\n    cancellation of main will trigger in order: 1. cancel parent (main) 2. then cancel children (subroutine)\n     Join cancellation has the following semantics: cancellation of a task triggers cancellation of all its\n    joiners (similar to promise1.then(promise2): promise2 depends on promise1, if promise1 os cancelled,\n    then so promise2 must be cancelled).\n     In the present test, main is joining on of its proper children, so this would cause an endless loop, but\n    since cancellation is noop on an already terminated task the deadlock wont happen\n  **/\n\n  const expected = ['start', 'subroutine start', 'cancel', 'cancelled', 'subroutine cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled routine must cancel proper joiners\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: parallel effect","suites":[],"updatePoint":{"line":259,"column":40},"line":259,"code":"test('saga cancellation: parallel effect', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let startDef = deferred();\n  let cancelDef = deferred();\n  let subroutineDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => startDef.resolve('start')).then(() => subroutineDefs[0].resolve('subroutine 1')).then(() => cancelDef.resolve('cancel')).then(() => subroutineDefs[1].resolve('subroutine 2'));\n\n  function* main() {\n    actual.push(yield startDef.promise);\n\n    try {\n      actual.push(yield io.all([io.call(subroutine1), io.call(subroutine2)]));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'cancelled');\n    }\n  }\n\n  function* subroutine1() {\n    actual.push(yield 'subroutine 1 start');\n\n    try {\n      actual.push(yield subroutineDefs[0].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine 1 cancelled');\n    }\n  }\n\n  function* subroutine2() {\n    actual.push(yield 'subroutine 2 start');\n\n    try {\n      actual.push(yield subroutineDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine 2 cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(v => {\n    actual.push(v);\n    task.cancel();\n  });\n  const expected = ['start', 'subroutine 1 start', 'subroutine 2 start', 'subroutine 1', 'cancel', 'subroutine 2 cancelled', 'cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled parallel effect must cancel all sub-effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: race effect","suites":[],"updatePoint":{"line":309,"column":36},"line":309,"code":"test('saga cancellation: race effect', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let startDef = deferred();\n  let cancelDef = deferred();\n  let subroutineDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => startDef.resolve('start')).then(() => cancelDef.resolve('cancel')).then(() => subroutineDefs[0].resolve('subroutine 1')).then(() => subroutineDefs[1].resolve('subroutine 2'));\n\n  function* main() {\n    actual.push(yield startDef.promise);\n\n    try {\n      actual.push(yield io.race({\n        subroutine1: io.call(subroutine1),\n        subroutine2: io.call(subroutine2)\n      }));\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'cancelled');\n    }\n  }\n\n  function* subroutine1() {\n    actual.push(yield 'subroutine 1 start');\n\n    try {\n      actual.push(yield subroutineDefs[0].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine cancelled');\n    }\n  }\n\n  function* subroutine2() {\n    actual.push(yield 'subroutine 2 start');\n\n    try {\n      actual.push(yield subroutineDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subroutine cancelled');\n    }\n  }\n\n  const task = middleware.run(main);\n  cancelDef.promise.then(v => {\n    actual.push(v);\n    task.cancel();\n  });\n  const expected = ['start', 'subroutine 1 start', 'subroutine 2 start', 'cancel', 'subroutine cancelled', 'subroutine cancelled', 'cancelled'];\n  return task.toPromise().then(() => {\n    // cancelled race effect must cancel all sub-effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: automatic parallel effect cancellation","suites":[],"updatePoint":{"line":362,"column":63},"line":362,"code":"test('saga cancellation: automatic parallel effect cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let subtask1Defs = arrayOfDeferred(2),\n      subtask2Defs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => subtask1Defs[0].resolve('subtask_1')).then(() => subtask2Defs[0].resolve('subtask_2')).then(() => subtask1Defs[1].reject('subtask_1 rejection')).then(() => subtask2Defs[1].resolve('subtask_2_2'));\n\n  function* subtask1() {\n    actual.push(yield subtask1Defs[0].promise);\n    actual.push(yield subtask1Defs[1].promise);\n  }\n\n  function* subtask2() {\n    try {\n      actual.push(yield subtask2Defs[0].promise);\n      actual.push(yield subtask2Defs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subtask 2 cancelled');\n    }\n  }\n\n  function* genFn() {\n    try {\n      yield io.all([io.call(subtask1), io.call(subtask2)]);\n    } catch (e) {\n      actual.push(yield `caught ${e}`);\n    }\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['subtask_1', 'subtask_2', 'subtask 2 cancelled', 'caught subtask_1 rejection'];\n  return task.toPromise().then(() => {\n    // saga must cancel parallel sub-effects on rejection\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: automatic race competitor cancellation","suites":[],"updatePoint":{"line":399,"column":63},"line":399,"code":"test('saga cancellation: automatic race competitor cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let winnerSubtaskDefs = arrayOfDeferred(2),\n      loserSubtaskDefs = arrayOfDeferred(2),\n      parallelSubtaskDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => winnerSubtaskDefs[0].resolve('winner_1')).then(() => loserSubtaskDefs[0].resolve('loser_1')).then(() => parallelSubtaskDefs[0].resolve('parallel_1')).then(() => winnerSubtaskDefs[1].resolve('winner_2')).then(() => loserSubtaskDefs[1].resolve('loser_2')).then(() => parallelSubtaskDefs[1].resolve('parallel_2'));\n\n  function* winnerSubtask() {\n    try {\n      actual.push(yield winnerSubtaskDefs[0].promise);\n      actual.push(yield winnerSubtaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'winner subtask cancelled');\n    }\n  }\n\n  function* loserSubtask() {\n    try {\n      actual.push(yield loserSubtaskDefs[0].promise);\n      actual.push(yield loserSubtaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'loser subtask cancelled');\n    }\n  }\n\n  function* parallelSubtask() {\n    try {\n      actual.push(yield parallelSubtaskDefs[0].promise);\n      actual.push(yield parallelSubtaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'parallel subtask cancelled');\n    }\n  }\n\n  function* genFn() {\n    yield io.all([io.race({\n      winner: io.call(winnerSubtask),\n      loser: io.call(loserSubtask)\n    }), io.call(parallelSubtask)]);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['winner_1', 'loser_1', 'parallel_1', 'winner_2', 'loser subtask cancelled', 'parallel_2'];\n  return task.toPromise().then(() => {\n    // saga must cancel race competitors except for the winner\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation:  manual task cancellation","suites":[],"updatePoint":{"line":449,"column":50},"line":449,"code":"test('saga cancellation:  manual task cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let signIn = deferred(),\n      signOut = deferred(),\n      expires = arrayOfDeferred(3);\n  Promise.resolve(1).then(() => signIn.resolve('signIn')).then(() => expires[0].resolve('expire_1')).then(() => expires[1].resolve('expire_2')).then(() => signOut.resolve('signOut')).then(() => expires[2].resolve('expire_3'));\n\n  function* subtask() {\n    try {\n      for (var i = 0; i < expires.length; i++) {\n        actual.push(yield expires[i].promise);\n      }\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'task cancelled');\n    }\n  }\n\n  function* genFn() {\n    actual.push(yield signIn.promise);\n    const task = yield io.fork(subtask);\n    actual.push(yield signOut.promise);\n    yield io.cancel(task);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['signIn', 'expire_1', 'expire_2', 'signOut', 'task cancelled'];\n  return task.toPromise().then(() => {\n    // saga must cancel forked tasks\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: nested task cancellation","suites":[],"updatePoint":{"line":482,"column":49},"line":482,"code":"test('saga cancellation: nested task cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let start = deferred(),\n      stop = deferred(),\n      subtaskDefs = arrayOfDeferred(2),\n      nestedTask1Defs = arrayOfDeferred(2),\n      nestedTask2Defs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => start.resolve('start')).then(() => subtaskDefs[0].resolve('subtask_1')).then(() => nestedTask1Defs[0].resolve('nested_task_1_1')).then(() => nestedTask2Defs[0].resolve('nested_task_2_1')).then(() => stop.resolve('stop')).then(() => nestedTask1Defs[1].resolve('nested_task_1_2')).then(() => nestedTask2Defs[1].resolve('nested_task_2_2')).then(() => subtaskDefs[1].resolve('subtask_2'));\n\n  function* nestedTask1() {\n    try {\n      actual.push(yield nestedTask1Defs[0].promise);\n      actual.push(yield nestedTask1Defs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'nested task 1 cancelled');\n    }\n  }\n\n  function* nestedTask2() {\n    try {\n      actual.push(yield nestedTask2Defs[0].promise);\n      actual.push(yield nestedTask2Defs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'nested task 2 cancelled');\n    }\n  }\n\n  function* subtask() {\n    try {\n      actual.push(yield subtaskDefs[0].promise);\n      yield io.all([io.call(nestedTask1), io.call(nestedTask2)]);\n      actual.push(yield subtaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subtask cancelled');\n    }\n  }\n\n  function* genFn() {\n    actual.push(yield start.promise);\n    const task = yield io.fork(subtask);\n    actual.push(yield stop.promise);\n    yield io.cancel(task);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['start', 'subtask_1', 'nested_task_1_1', 'nested_task_2_1', 'stop', 'nested task 1 cancelled', 'nested task 2 cancelled', 'subtask cancelled'];\n  return task.toPromise().then(() => {\n    // saga must cancel forked task and its nested subtask\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cancellation: nested forked task cancellation","suites":[],"updatePoint":{"line":535,"column":56},"line":535,"code":"test('saga cancellation: nested forked task cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let start = deferred(),\n      stop = deferred(),\n      subtaskDefs = arrayOfDeferred(2),\n      nestedTaskDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => start.resolve('start')).then(() => subtaskDefs[0].resolve('subtask_1')).then(() => nestedTaskDefs[0].resolve('nested_task_1')).then(() => stop.resolve('stop')) //\n  .then(() => nestedTaskDefs[1].resolve('nested_task_2')).then(() => subtaskDefs[1].resolve('subtask_2'));\n\n  function* nestedTask() {\n    try {\n      actual.push(yield nestedTaskDefs[0].promise);\n      actual.push(yield nestedTaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'nested task cancelled');\n    }\n  }\n\n  function* subtask() {\n    try {\n      actual.push(yield subtaskDefs[0].promise);\n      yield io.fork(nestedTask);\n      actual.push(yield subtaskDefs[1].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(yield 'subtask cancelled');\n    }\n  }\n\n  function* genFn() {\n    actual.push(yield start.promise);\n    const task = yield io.fork(subtask);\n    actual.push(yield stop.promise);\n    yield io.cancel(task);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['start', 'subtask_1', 'nested_task_1', 'stop', 'subtask cancelled', 'nested task cancelled'];\n  return task.toPromise().then(() => {\n    // saga must cancel forked task and its forked nested subtask\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"cancel should be able to cancel multiple tasks","suites":[],"updatePoint":{"line":579,"column":52},"line":579,"code":"test('cancel should be able to cancel multiple tasks', () => {\n  const defs = arrayOfDeferred(3);\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* worker(i) {\n    try {\n      yield defs[i].promise;\n    } finally {\n      if (yield io.cancelled()) {\n        actual.push(i);\n      }\n    }\n  }\n\n  function* genFn() {\n    const t1 = yield io.fork(worker, 0);\n    const t2 = yield io.fork(worker, 1);\n    const t3 = yield io.fork(worker, 2);\n    yield io.cancel([t1, t2, t3]);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [0, 1, 2];\n  return task.toPromise().then(() => {\n    // it must be possible to cancel multiple tasks at once\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"cancel should support for self cancellation","suites":[],"updatePoint":{"line":609,"column":49},"line":609,"code":"test('cancel should support for self cancellation', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* worker() {\n    try {\n      yield io.cancel();\n    } finally {\n      if (yield io.cancelled()) {\n        actual.push('self cancellation');\n      }\n    }\n  }\n\n  function* genFn() {\n    yield io.fork(worker);\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['self cancellation'];\n  return task.toPromise().then(() => {\n    // it must be possible to trigger self cancellation\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should bubble an exception thrown during cancellation","suites":[],"updatePoint":{"line":635,"column":59},"line":635,"code":"test('should bubble an exception thrown during cancellation', () => {\n  const expectedError = new Error('child error');\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err).toBe(expectedError);\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* child() {\n    try {\n      yield io.delay(1000);\n    } finally {\n      // eslint-disable-next-line no-unsafe-finally\n      throw expectedError;\n    }\n  }\n\n  function* worker() {\n    const taskA = yield io.fork(child);\n    yield io.delay(100);\n    yield io.cancel(taskA);\n  }\n\n  return expect(middleware.run(worker).toPromise()).rejects.toBe(expectedError);\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"task should end in cancelled state when joining cancelled child","suites":[],"updatePoint":{"line":661,"column":69},"line":661,"code":"test('task should end in cancelled state when joining cancelled child', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* child() {\n    yield io.delay(0);\n    yield io.cancel();\n  }\n\n  function* parent() {\n    yield io.join(yield io.fork(child));\n  }\n\n  const task = middleware.run(parent);\n  return task.toPromise().then(() => {\n    expect(task.isCancelled()).toBe(true);\n    expect(task.isRunning()).toBe(false);\n    expect(task.isAborted()).toBe(false);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"task should end in cancelled state when parent gets cancelled","suites":[],"updatePoint":{"line":681,"column":67},"line":681,"code":"test('task should end in cancelled state when parent gets cancelled', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let task;\n\n  function* child() {\n    // just block\n    yield new Promise(() => {});\n  }\n\n  function* parent() {\n    task = yield io.fork(child);\n  }\n\n  function* worker() {\n    const parentTask = yield io.fork(parent);\n    yield io.delay(0);\n    yield io.cancel(parentTask);\n  }\n\n  return middleware.run(worker).toPromise().then(() => {\n    expect(task.isCancelled()).toBe(true);\n    expect(task.isRunning()).toBe(false);\n    expect(task.isAborted()).toBe(false);\n  });\n});","file":"interpreter/cancellation.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga create channel for store actions","suites":[],"updatePoint":{"line":4,"column":43},"line":4,"code":"test('saga create channel for store actions', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    const chan = yield io.actionChannel('action');\n\n    for (var i = 0; i < 10; i++) {\n      yield Promise.resolve(1);\n      const {\n        payload\n      } = yield io.take(chan);\n      actual.push(payload);\n    }\n  }\n\n  const task = middleware.run(genFn);\n\n  for (var i = 0; i < 10; i++) {\n    store.dispatch({\n      type: 'action',\n      payload: i + 1\n    });\n  }\n\n  return task.toPromise().then(() => {\n    // saga must queue dispatched actions\n    expect(actual).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  });\n});","file":"interpreter/channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga create channel for store actions (with buffer)","suites":[],"updatePoint":{"line":35,"column":57},"line":35,"code":"test('saga create channel for store actions (with buffer)', () => {\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const buffer = buffers.expanding();\n\n  function* genFn() {\n    // TODO: this might mean that we do not close / flush channels when sagas ends\n    // should we clean them up automatically? or is it user's responsibility?\n    let chan = yield io.actionChannel('action', buffer);\n    return chan;\n  }\n\n  const task = middleware.run(genFn);\n  Promise.resolve().then(() => {\n    for (var i = 0; i < 10; i++) {\n      store.dispatch({\n        type: 'action',\n        payload: i + 1\n      });\n    }\n  });\n  return task.toPromise().then(() => {\n    // saga must queue dispatched actions\n    expect(buffer.flush().map(item => item.payload)).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  });\n});","file":"interpreter/channel.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga must handle context in dynamic scoping manner","suites":[],"updatePoint":{"line":4,"column":56},"line":4,"code":"test('saga must handle context in dynamic scoping manner', () => {\n  let actual = [];\n  const context = {\n    a: 1\n  };\n  const middleware = sagaMiddleware({\n    context\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    actual.push(yield io.getContext('a'));\n    yield io.setContext({\n      b: 2\n    });\n    yield io.fork(function* () {\n      actual.push(yield io.getContext('a'));\n      actual.push(yield io.getContext('b'));\n      yield io.setContext({\n        c: 3\n      });\n      actual.push(yield io.getContext('c'));\n    });\n    actual.push(yield io.getContext('c'));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [1, 1, 2, 3, undefined];\n  return task.toPromise().then(() => {\n    // saga must handle context in dynamic scoping manner\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/context.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cps call handling","suites":[],"updatePoint":{"line":4,"column":28},"line":4,"code":"test('saga cps call handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    try {\n      yield io.cps(cb => {\n        actual.push('call 1');\n        cb('err');\n      });\n      actual.push('call 2');\n    } catch (err) {\n      actual.push('call ' + err);\n    }\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['call 1', 'call err'];\n  return task.toPromise().then(() => {\n    // saga must fulfill cps call effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cps.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga synchronous cps failures handling","suites":[],"updatePoint":{"line":28,"column":44},"line":28,"code":"test('saga synchronous cps failures handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, action) => {\n    if (pastStoreCreation) {\n      actual.push(action.type);\n    }\n\n    return {};\n  };\n\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n\n  function* genFnChild() {\n    try {\n      yield io.put({\n        type: 'startChild'\n      });\n      yield io.cps(() => {\n        throw new Error('child error'); //cb(null, \"Ok\")\n      });\n      yield io.put({\n        type: 'success child'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure child'\n      });\n    }\n  }\n\n  function* genFnParent() {\n    try {\n      yield io.put({\n        type: 'start parent'\n      });\n      yield io.call(genFnChild);\n      yield io.put({\n        type: 'success parent'\n      });\n    } catch (e) {\n      yield io.put({\n        type: 'failure parent'\n      });\n    }\n  }\n\n  const task = middleware.run(genFnParent);\n  const expected = ['start parent', 'startChild', 'failure child', 'success parent'];\n  return task.toPromise().then(() => {\n    // saga should inject call error into generator\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/cps.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga cps cancellation handling","suites":[],"updatePoint":{"line":85,"column":36},"line":85,"code":"test('saga cps cancellation handling', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let cancelled = false;\n\n  const cpsFn = cb => {\n    cb.cancel = () => {\n      cancelled = true;\n    };\n  };\n\n  function* genFn() {\n    const task = yield io.fork(function* () {\n      yield io.cps(cpsFn);\n    });\n    yield io.cancel(task);\n  }\n\n  const task = middleware.run(genFn);\n  return task.toPromise().then(() => {\n    // saga should call cancellation function on callback\n    expect(cancelled).toBe(true);\n  });\n});","file":"interpreter/cps.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"effectMiddlewares - single","suites":[],"updatePoint":{"line":4,"column":32},"line":4,"code":"test('effectMiddlewares - single', () => {\n  let actual = [];\n\n  function rootReducer(state, action) {\n    return action;\n  }\n\n  const effectMiddleware = next => effect => {\n    if (effect === apiCall) {\n      Promise.resolve().then(() => next('injected value'));\n      return;\n    }\n\n    return next(effect);\n  };\n\n  const middleware = sagaMiddleware({\n    effectMiddlewares: [effectMiddleware]\n  });\n  const store = createStore(rootReducer, {}, applyMiddleware(middleware));\n  const apiCall = call(() => new Promise(() => {}));\n\n  function* root() {\n    actual.push(yield all([call(fnA), apiCall]));\n  }\n\n  function* fnA() {\n    const result = [];\n    result.push((yield take('ACTION-1')).val);\n    result.push((yield take('ACTION-2')).val);\n    return result;\n  }\n\n  const task = middleware.run(root);\n  Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION-1',\n    val: 1\n  })).then(() => store.dispatch({\n    type: 'ACTION-2',\n    val: 2\n  }));\n  const expected = [[[1, 2], 'injected value']];\n  return task.toPromise().then(() => {\n    // effectMiddleware must be able to intercept and resolve effect in a custom way\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/effectMiddlewares.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"effectMiddlewares - multiple","suites":[],"updatePoint":{"line":51,"column":34},"line":51,"code":"test('effectMiddlewares - multiple', () => {\n  let actual = [];\n\n  function rootReducer(state, action) {\n    return action;\n  }\n\n  const effectMiddleware1 = next => effect => {\n    actual.push('middleware1 received', effect);\n\n    if (effect === apiCall1) {\n      Promise.resolve().then(() => next('middleware1 injected value'));\n      return;\n    }\n\n    actual.push('middleware1 passed trough', effect);\n    return next(effect);\n  };\n\n  const effectMiddleware2 = next => effect => {\n    actual.push('middleware2 received', effect);\n\n    if (effect === apiCall2) {\n      Promise.resolve().then(() => next('middleware2 injected value'));\n      return;\n    }\n\n    actual.push('middleware2 passed trough', effect);\n    return next(effect);\n  };\n\n  const middleware = sagaMiddleware({\n    effectMiddlewares: [effectMiddleware1, effectMiddleware2]\n  });\n  createStore(rootReducer, {}, applyMiddleware(middleware));\n  const apiCall1 = call(() => new Promise(() => {}));\n  const apiCall2 = call(() => new Promise(() => {}));\n  const callA = call(fnA);\n\n  function* root() {\n    actual.push(\"effect's result is\", yield apiCall1);\n    actual.push(\"effect's result is\", yield callA);\n    actual.push(\"effect's result is\", yield apiCall2);\n  }\n\n  function* fnA() {\n    return 'fnA result';\n  }\n\n  const task = middleware.run(root);\n  const expected = ['middleware1 received', apiCall1, 'middleware2 received', 'middleware1 injected value', 'middleware2 passed trough', 'middleware1 injected value', \"effect's result is\", 'middleware1 injected value', 'middleware1 received', callA, 'middleware1 passed trough', callA, 'middleware2 received', callA, 'middleware2 passed trough', callA, \"effect's result is\", 'fnA result', 'middleware1 received', apiCall2, 'middleware1 passed trough', apiCall2, 'middleware2 received', apiCall2, \"effect's result is\", 'middleware2 injected value'];\n  return task.toPromise().then(() => {\n    // multiple effectMiddlewares must create a chain\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/effectMiddlewares.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"effectMiddlewares - nested task","suites":[],"updatePoint":{"line":107,"column":37},"line":107,"code":"test('effectMiddlewares - nested task', () => {\n  let actual = [];\n\n  function rootReducer(state, action) {\n    return action;\n  }\n\n  const effectMiddleware = next => effect => {\n    if (effect === apiCall) {\n      Promise.resolve().then(() => next('injected value'));\n      return;\n    }\n\n    return next(effect);\n  };\n\n  const middleware = sagaMiddleware({\n    effectMiddlewares: [effectMiddleware]\n  });\n  const store = createStore(rootReducer, {}, applyMiddleware(middleware));\n  const apiCall = call(() => new Promise(() => {}));\n\n  function* root() {\n    actual.push(yield call(fnA));\n  }\n\n  function* fnA() {\n    actual.push((yield take('ACTION-1')).val);\n    actual.push((yield take('ACTION-2')).val);\n    actual.push(yield apiCall);\n    return 'result';\n  }\n\n  const task = middleware.run(root);\n  Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION-1',\n    val: 1\n  })).then(() => store.dispatch({\n    type: 'ACTION-2',\n    val: 2\n  }));\n  const expected = [1, 2, 'injected value', 'result'];\n  return task.toPromise().then(() => {\n    // effectMiddleware must be able to intercept effects from non-root sagas\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/effectMiddlewares.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga flush handling","suites":[],"updatePoint":{"line":4,"column":25},"line":4,"code":"test('saga flush handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    const chan = yield io.call(channel);\n    actual.push(yield io.flush(chan));\n    yield io.put(chan, 1);\n    yield io.put(chan, 2);\n    yield io.put(chan, 3);\n    actual.push(yield io.flush(chan));\n    yield io.put(chan, 4);\n    yield io.put(chan, 5);\n    chan.close();\n    actual.push(yield io.flush(chan));\n    actual.push(yield io.flush(chan));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [[], [1, 2, 3], [4, 5], END];\n  return task.toPromise().then(() => {\n    // saga must handle generator flushes\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/flush.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should not interpret returned effect. fork(() => effectCreator())","suites":[],"updatePoint":{"line":4,"column":71},"line":4,"code":"test('should not interpret returned effect. fork(() => effectCreator())', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  const fn = () => null;\n\n  function* genFn() {\n    const task = yield io.fork(() => io.call(fn));\n    return task.toPromise();\n  }\n\n  return middleware.run(genFn).toPromise().then(actual => {\n    expect(actual).toEqual(io.call(fn));\n  });\n});","file":"interpreter/fork.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should not interpret returned effect. yield fork(takeEvery, 'pattern', fn)","suites":[],"updatePoint":{"line":19,"column":80},"line":19,"code":"test(\"should not interpret returned effect. yield fork(takeEvery, 'pattern', fn)\", () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  const fn = () => null;\n\n  function* genFn() {\n    const task = yield io.fork(io.takeEvery, 'pattern', fn);\n    return task.toPromise();\n  }\n\n  return middleware.run(genFn).toPromise().then(actual => {\n    expect(actual).toEqual(io.takeEvery('pattern', fn));\n  });\n});","file":"interpreter/fork.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should interpret returned promise. fork(() => promise)","suites":[],"updatePoint":{"line":34,"column":60},"line":34,"code":"test('should interpret returned promise. fork(() => promise)', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    const task = yield io.fork(() => Promise.resolve('a'));\n    return task.toPromise();\n  }\n\n  return middleware.run(genFn).toPromise().then(actual => {\n    expect(actual).toEqual('a');\n  });\n});","file":"interpreter/fork.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should handle promise that resolves undefined properly. fork(() => Promise.resolve(undefined))","suites":[],"updatePoint":{"line":47,"column":100},"line":47,"code":"test('should handle promise that resolves undefined properly. fork(() => Promise.resolve(undefined))', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    const task = yield io.fork(() => Promise.resolve(undefined));\n    return task.toPromise();\n  }\n\n  return middleware.run(genFn).toPromise().then(actual => {\n    expect(actual).toEqual(undefined);\n  });\n});","file":"interpreter/fork.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"should interpret returned iterator. fork(() => iterator)","suites":[],"updatePoint":{"line":60,"column":62},"line":60,"code":"test('should interpret returned iterator. fork(() => iterator)', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    const task = yield io.fork(function* () {\n      yield 1;\n      return 'b';\n    });\n    return task.toPromise();\n  }\n\n  return middleware.run(genFn).toPromise().then(actual => {\n    expect(actual).toEqual('b');\n  });\n});","file":"interpreter/fork.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga fork handling: generators","suites":[],"updatePoint":{"line":7,"column":36},"line":7,"code":"test('saga fork handling: generators', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  let task, task2;\n\n  function* subGen(arg) {\n    yield Promise.resolve(1);\n    return arg;\n  }\n\n  class C {\n    constructor(val) {\n      this.val = val;\n    }\n\n    *gen() {\n      return this.val;\n    }\n\n  }\n\n  const inst = new C(2);\n\n  function* genFn() {\n    task = yield io.fork(subGen, 1);\n    task2 = yield io.fork([inst, inst.gen]);\n  }\n\n  const mainTask = middleware.run(genFn);\n  return mainTask.toPromise().then(() => {\n    // fork result must include the name of the forked generator function\n    expect(task.meta.name).toBe('subGen'); // fork result must include the promise of the task result\n\n    expect(is.promise(task.toPromise())).toBe(true);\n    return Promise.all([// fork result must resolve with the return value of the forked task\n    task.toPromise(), // fork must also handle generators defined as instance methods\n    task2.toPromise()]);\n  }).then(res => {\n    expect(res).toEqual([1, 2]);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga join handling : generators","suites":[],"updatePoint":{"line":48,"column":37},"line":48,"code":"test('saga join handling : generators', () => {\n  let actual = [];\n  const defs = arrayOfDeferred(2);\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* subGen(arg) {\n    yield defs[1].promise; // will be resolved after the action-1\n\n    return arg;\n  }\n\n  function* genFn() {\n    const task = yield io.fork(subGen, 1);\n    actual.push(yield defs[0].promise);\n    actual.push(yield io.take('action-1'));\n    actual.push(yield io.join(task));\n  }\n\n  const task = middleware.run(genFn);\n  Promise.resolve(1).then(() => defs[0].resolve(true)).then(() => store.dispatch({\n    type: 'action-1'\n  })).then(() => defs[1].resolve(2)); // the result of the fork will be resolved the last\n  // saga must not block and miss the 2 precedent effects\n\n  const expected = [true, {\n    type: 'action-1'\n  }, 1];\n  return task.toPromise().then(() => {\n    // saga must not block on forked tasks, but block on joined tasks\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga fork/join handling : functions","suites":[],"updatePoint":{"line":81,"column":41},"line":81,"code":"test('saga fork/join handling : functions', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const defs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => defs[0].resolve(true)).then(() => defs[1].resolve(2));\n\n  function api() {\n    return defs[1].promise;\n  }\n\n  function syncFn() {\n    return 'sync';\n  }\n\n  function* genFn() {\n    const task = yield io.fork(api);\n    const syncTask = yield io.fork(syncFn);\n    actual.push(yield defs[0].promise);\n    actual.push(yield io.join(task));\n    actual.push(yield io.join(syncTask));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [true, 2, 'sync'];\n  return task.toPromise().then(() => {\n    // saga must not block on forked tasks, but block on joined tasks\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga fork wait for attached children","suites":[],"updatePoint":{"line":111,"column":42},"line":111,"code":"test('saga fork wait for attached children', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const rootDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(childAdef.resolve).then(rootDef.resolve).then(defs[0].resolve).then(childBdef.resolve).then(defs[2].resolve).then(defs[3].resolve).then(defs[1].resolve);\n\n  function* root() {\n    yield io.fork(childA);\n    yield rootDef.promise;\n    yield io.fork(childB);\n  }\n\n  function* childA() {\n    yield io.fork(leaf, 0);\n    yield childAdef.promise;\n    yield io.fork(leaf, 1);\n  }\n\n  function* childB() {\n    yield io.fork(leaf, 2);\n    yield childBdef.promise;\n    yield io.fork(leaf, 3);\n  }\n\n  function* leaf(idx) {\n    yield defs[idx].promise;\n    actual.push(idx);\n  }\n\n  const task = middleware.run(root);\n  return task.toPromise().then(() => {\n    // parent task must wait for all forked tasks before terminating\n    expect(actual).toEqual([0, 2, 3, 1]);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga auto cancel forks on error","suites":[],"updatePoint":{"line":150,"column":37},"line":150,"code":"test('saga auto cancel forks on error', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(() => childAdef.resolve('childA resolved')).then(() => defs[0].resolve('leaf 1 resolved')).then(() => childBdef.resolve('childB resolved')).then(() => defs[1].resolve('leaf 2 resolved')).then(() => mainDef.reject('main error')) //\n  .then(() => defs[2].resolve('leaf 3 resolved')).then(() => defs[3].resolve('leaf 4 resolved'));\n\n  function* root() {\n    try {\n      actual.push(yield io.call(main));\n    } catch (e) {\n      actual.push('root caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      yield io.fork(childA);\n      yield io.fork(childB);\n      actual.push(yield mainDef.promise);\n    } catch (e) {\n      actual.push(e);\n      throw e;\n    } finally {\n      if (yield io.cancelled()) actual.push('main cancelled');\n    }\n  }\n\n  function* childA() {\n    try {\n      yield io.fork(leaf, 0);\n      actual.push(yield childAdef.promise);\n      yield io.fork(leaf, 1);\n    } finally {\n      if (yield io.cancelled()) actual.push('childA cancelled');\n    }\n  }\n\n  function* childB() {\n    try {\n      yield io.fork(leaf, 2);\n      yield io.fork(leaf, 3);\n      actual.push(yield childBdef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push('childB cancelled');\n    }\n  }\n\n  function* leaf(idx) {\n    try {\n      actual.push(yield defs[idx].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(`leaf ${idx + 1} cancelled`);\n    }\n  }\n\n  const task = middleware.run(root);\n  const expected = ['childA resolved', 'leaf 1 resolved', 'childB resolved', 'leaf 2 resolved', 'main error', 'leaf 3 cancelled', 'leaf 4 cancelled', 'root caught main error'];\n  return task.toPromise().then(() => {\n    // parent task must cancel all forked tasks when it aborts\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga auto cancel forks on main cancelled","suites":[],"updatePoint":{"line":217,"column":46},"line":217,"code":"test('saga auto cancel forks on main cancelled', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const actual = [];\n  const rootDef = deferred();\n  const mainDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(() => childAdef.resolve('childA resolved')).then(() => defs[0].resolve('leaf 1 resolved')).then(() => childBdef.resolve('childB resolved')).then(() => defs[1].resolve('leaf 2 resolved')).then(() => rootDef.resolve('root resolved')).then(() => mainDef.resolve('main resolved')).then(() => defs[2].resolve('leaf 3 resolved')).then(() => defs[3].resolve('leaf 4 resolved'));\n\n  function* root() {\n    try {\n      const task = yield io.fork(main);\n      actual.push(yield rootDef.promise);\n      yield io.cancel(task);\n    } catch (e) {\n      actual.push('root caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      yield io.fork(childA);\n      yield io.fork(childB);\n      actual.push(yield mainDef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push('main cancelled');\n    }\n  }\n\n  function* childA() {\n    try {\n      yield io.fork(leaf, 0);\n      actual.push(yield childAdef.promise);\n      yield io.fork(leaf, 1);\n    } finally {\n      if (yield io.cancelled()) actual.push('childA cancelled');\n    }\n  }\n\n  function* childB() {\n    try {\n      yield io.fork(leaf, 2);\n      yield io.fork(leaf, 3);\n      actual.push(yield childBdef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push('childB cancelled');\n    }\n  }\n\n  function* leaf(idx) {\n    try {\n      actual.push(yield defs[idx].promise);\n    } finally {\n      if (yield io.cancelled()) actual.push(`leaf ${idx + 1} cancelled`);\n    }\n  }\n\n  const task = middleware.run(root);\n  const expected = ['childA resolved', 'leaf 1 resolved', 'childB resolved', 'leaf 2 resolved', 'root resolved', 'main cancelled', 'leaf 3 cancelled', 'leaf 4 cancelled'];\n  return task.toPromise().then(() => {\n    // parent task must cancel all forked tasks when it's cancelled\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga auto cancel forks if a child aborts","suites":[],"updatePoint":{"line":283,"column":46},"line":283,"code":"test('saga auto cancel forks if a child aborts', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(() => childAdef.resolve('childA resolved')).then(() => defs[0].resolve('leaf 1 resolved')).then(() => childBdef.resolve('childB resolved')).then(() => defs[1].resolve('leaf 2 resolved')).then(() => mainDef.resolve('main resolved')).then(() => defs[2].reject('leaf 3 error')).then(() => defs[3].resolve('leaf 4 resolved'));\n\n  function* root() {\n    try {\n      actual.push(yield io.call(main));\n    } catch (e) {\n      actual.push('root caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      yield io.fork(childA);\n      yield io.fork(childB);\n      actual.push(yield mainDef.promise);\n      return 'main returned';\n    } finally {\n      if (yield io.cancelled()) actual.push('main cancelled');\n    }\n  }\n\n  function* childA() {\n    try {\n      yield io.fork(leaf, 0);\n      actual.push(yield childAdef.promise);\n      yield io.fork(leaf, 1);\n    } finally {\n      if (yield io.cancelled()) actual.push('childA cancelled');\n    }\n  }\n\n  function* childB() {\n    try {\n      yield io.fork(leaf, 2);\n      yield io.fork(leaf, 3);\n      actual.push(yield childBdef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push('childB cancelled');\n    }\n  }\n\n  function* leaf(idx) {\n    try {\n      actual.push(yield defs[idx].promise);\n    } catch (e) {\n      actual.push(e);\n      throw e;\n    } finally {\n      if (yield io.cancelled()) actual.push(`leaf ${idx + 1} cancelled`);\n    }\n  }\n\n  const task = middleware.run(root);\n  const expected = ['childA resolved', 'leaf 1 resolved', 'childB resolved', 'leaf 2 resolved', 'main resolved', 'leaf 3 error', 'leaf 4 cancelled', 'root caught leaf 3 error'];\n  return task.toPromise().then(() => {\n    // parent task must cancel all forked tasks when it aborts\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga auto cancel parent + forks if a child aborts","suites":[],"updatePoint":{"line":350,"column":55},"line":350,"code":"test('saga auto cancel parent + forks if a child aborts', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainDef = deferred();\n  const childAdef = deferred();\n  const childBdef = deferred();\n  const defs = arrayOfDeferred(4);\n  Promise.resolve().then(() => childAdef.resolve('childA resolved')).then(() => defs[0].resolve('leaf 1 resolved')).then(() => childBdef.resolve('childB resolved')).then(() => defs[1].resolve('leaf 2 resolved')).then(() => defs[2].reject('leaf 3 error')).then(() => mainDef.resolve('main resolved')).then(() => defs[3].resolve('leaf 4 resolved'));\n\n  function* root() {\n    try {\n      actual.push(yield io.call(main));\n    } catch (e) {\n      actual.push('root caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      yield io.fork(childA);\n      yield io.fork(childB);\n      actual.push(yield mainDef.promise);\n      return 'main returned';\n    } catch (e) {\n      actual.push(e);\n      throw e;\n    } finally {\n      if (yield io.cancelled()) actual.push('main cancelled');\n    }\n  }\n\n  function* childA() {\n    try {\n      yield io.fork(leaf, 0);\n      actual.push(yield childAdef.promise);\n      yield io.fork(leaf, 1);\n    } finally {\n      if (yield io.cancelled()) actual.push('childA cancelled');\n    }\n  }\n\n  function* childB() {\n    try {\n      yield io.fork(leaf, 2);\n      yield io.fork(leaf, 3);\n      actual.push(yield childBdef.promise);\n    } finally {\n      if (yield io.cancelled()) actual.push('childB cancelled');\n    }\n  }\n\n  function* leaf(idx) {\n    try {\n      actual.push(yield defs[idx].promise);\n    } catch (e) {\n      actual.push(e);\n      throw e;\n    } finally {\n      if (yield io.cancelled()) actual.push(`leaf ${idx + 1} cancelled`);\n    }\n  }\n\n  const task = middleware.run(root);\n  const expected = ['childA resolved', 'leaf 1 resolved', 'childB resolved', 'leaf 2 resolved', 'leaf 3 error', 'leaf 4 cancelled', 'main cancelled', 'root caught leaf 3 error'];\n  return task.toPromise().then(() => {\n    // parent task must cancel all forked tasks when it aborts\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"joining multiple tasks","suites":[],"updatePoint":{"line":420,"column":28},"line":420,"code":"test('joining multiple tasks', () => {\n  const defs = arrayOfDeferred(3);\n  let actual;\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* worker(i) {\n    return yield defs[i].promise;\n  }\n\n  function* genFn() {\n    const task1 = yield io.fork(worker, 0);\n    const task2 = yield io.fork(worker, 1);\n    const task3 = yield io.fork(worker, 2);\n    actual = yield io.join([task1, task2, task3]);\n  }\n\n  const mainTask = middleware.run(genFn);\n  Promise.resolve().then(() => defs[0].resolve(1)).then(() => defs[2].resolve(3)).then(() => defs[1].resolve(2));\n  const expected = [1, 2, 3];\n  return mainTask.toPromise().then(() => {\n    // it must be possible to join on multiple tasks\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkjoin.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga sync fork failures: functions","suites":[],"updatePoint":{"line":4,"column":40},"line":4,"code":"test('saga sync fork failures: functions', () => {\n  let actual = [];\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err).toBe('immediatelyFailingFork');\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware)); // NOTE: we'll be forking a function not a Generator\n\n  function immediatelyFailingFork() {\n    throw 'immediatelyFailingFork';\n  }\n\n  function* genParent() {\n    try {\n      actual.push('start parent');\n      yield io.fork(immediatelyFailingFork);\n      actual.push('success parent');\n    } catch (e) {\n      actual.push('parent caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      actual.push('start main');\n      yield io.call(genParent);\n      actual.push('success main');\n    } catch (e) {\n      actual.push('main caught ' + e);\n    }\n  }\n\n  const task = middleware.run(main);\n  const expected = ['start main', 'start parent', 'main caught immediatelyFailingFork'];\n  return task.toPromise().then(() => {\n    // saga should fails the parent if a forked function fails synchronously\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkJoinErrors.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga sync fork failures: functions/error bubbling","suites":[],"updatePoint":{"line":44,"column":55},"line":44,"code":"test('saga sync fork failures: functions/error bubbling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err.message).toMatchInlineSnapshot(`\"immediatelyFailingFork\"`);\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware)); // NOTE: we'll be forking a function not a Generator\n\n  function immediatelyFailingFork() {\n    throw new Error('immediatelyFailingFork');\n  }\n\n  function* genParent() {\n    try {\n      actual.push('start parent');\n      yield io.fork(immediatelyFailingFork);\n      actual.push('success parent');\n    } catch (e) {\n      actual.push('parent caught ' + e.message);\n    }\n  }\n\n  function* main() {\n    try {\n      actual.push('start main');\n      yield io.fork(genParent);\n      actual.push('success main');\n    } catch (e) {\n      actual.push('main caught ' + e.message);\n    }\n  }\n\n  const task = middleware.run(main);\n  const expected = ['start main', 'start parent', 'uncaught immediatelyFailingFork'];\n  return task.toPromise().catch(err => {\n    actual.push('uncaught ' + err.message);\n  }).then(() => {\n    // saga should propagate errors up to the root of fork tree\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkJoinErrors.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga fork's failures: generators","suites":[],"updatePoint":{"line":86,"column":38},"line":86,"code":"test(\"saga fork's failures: generators\", () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genChild() {\n    throw 'gen error';\n  }\n\n  function* genParent() {\n    try {\n      actual.push('start parent');\n      yield io.fork(genChild);\n      actual.push('success parent');\n    } catch (e) {\n      actual.push('parent caught ' + e);\n    }\n  }\n\n  function* main() {\n    try {\n      actual.push('start main');\n      yield io.call(genParent);\n      actual.push('success main');\n    } catch (e) {\n      actual.push('main caught ' + e);\n    }\n  }\n\n  const task = middleware.run(main);\n  const expected = ['start main', 'start parent', 'main caught gen error'];\n  return task.toPromise().then(() => {\n    // saga should fails the parent if a forked generator fails synchronously\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkJoinErrors.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga sync fork failures: spawns (detached forks)","suites":[],"updatePoint":{"line":122,"column":54},"line":122,"code":"test('saga sync fork failures: spawns (detached forks)', () => {\n  let actual = [];\n  const middleware = sagaMiddleware({\n    onError: err => {\n      expect(err.message).toBe('gen error');\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genChild() {\n    throw new Error('gen error');\n  }\n\n  function* main() {\n    try {\n      actual.push('start main');\n      const task = yield io.spawn(genChild);\n      actual.push('spawn ' + task.meta.name);\n      actual.push('success parent');\n    } catch (e) {\n      actual.push('main caught ' + e.message);\n    }\n  }\n\n  const task = middleware.run(main);\n  const expected = ['start main', 'spawn genChild', 'success parent'];\n  return task.toPromise().then(() => {\n    // saga should not fail a parent with errors from detached forks (using spawn)\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/forkJoinErrors.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga detached forks failures","suites":[],"updatePoint":{"line":153,"column":34},"line":153,"code":"test('saga detached forks failures', done => {\n  const actual = [];\n  const middleware = sagaMiddleware({\n    onError: err => actual.push(err)\n  });\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const ACTION_TYPE = 'ACTION_TYPE';\n  const ACTION_TYPE2 = 'ACTION_TYPE2';\n  const failError = new Error('fail error');\n\n  function willFail(ac) {\n    if (!ac.fail) {\n      actual.push(ac.i);\n      return;\n    }\n\n    throw failError;\n  }\n\n  const wontFail = ac => actual.push(ac.i);\n\n  function* saga() {\n    yield detach(io.takeEvery(ACTION_TYPE, willFail));\n    yield io.takeEvery(ACTION_TYPE2, wontFail);\n  }\n\n  middleware.run(saga).toPromise().catch(err => done.fail(err));\n  const expected = [0, 1, 2, failError, 4];\n  return Promise.resolve().then(() => store.dispatch({\n    type: ACTION_TYPE,\n    i: 0\n  })).then(() => store.dispatch({\n    type: ACTION_TYPE,\n    i: 1\n  })).then(() => store.dispatch({\n    type: ACTION_TYPE,\n    i: 2\n  })).then(() => store.dispatch({\n    type: ACTION_TYPE,\n    i: 3,\n    fail: true\n  })).then(() => store.dispatch({\n    type: ACTION_TYPE2,\n    i: 4\n  })).then(() => {\n    // saga should not fail a parent with errors from detached fork\n    expect(actual).toEqual(expected);\n    done();\n  });\n});","file":"interpreter/forkJoinErrors.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga nested iterator handling","suites":[],"updatePoint":{"line":5,"column":35},"line":5,"code":"test('saga nested iterator handling', () => {\n  let actual = [];\n  let defs = arrayOfDeferred(3);\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* child() {\n    actual.push(yield defs[0].promise);\n    actual.push(yield io.take('action-1'));\n    actual.push(yield defs[1].promise);\n    actual.push(yield io.take('action-2'));\n    actual.push(yield defs[2].promise);\n    actual.push(yield io.take('action-3'));\n    actual.push(yield Promise.reject('child error'));\n  }\n\n  function* main() {\n    try {\n      yield child();\n    } catch (e) {\n      actual.push('caught ' + e);\n    }\n  }\n\n  const expected = [1, {\n    type: 'action-1'\n  }, 2, {\n    type: 'action-2'\n  }, 3, {\n    type: 'action-3'\n  }, 'caught child error'];\n  const task = middleware.run(main);\n  Promise.resolve(1).then(() => defs[0].resolve(1)).then(() => store.dispatch({\n    type: 'action-1'\n  })).then(() => defs[1].resolve(2)).then(() => store.dispatch({\n    type: 'action-2'\n  })).then(() => defs[2].resolve(3)).then(() => store.dispatch({\n    type: 'action-3'\n  }));\n  return task.toPromise().then(() => {\n    // saga must fulfill nested iterator effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/iterators.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga onError is optional (the default is console.error)","suites":[],"updatePoint":{"line":5,"column":61},"line":5,"code":"test('saga onError is optional (the default is console.error)', () => {\n  let consoleError = console.error;\n  console.error = jest.fn();\n\n  const restoreConsoleError = () => console.error = consoleError;\n\n  const expectedError = new Error('child error');\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* child() {\n    throw expectedError;\n  }\n\n  function* main() {\n    yield io.call(child);\n  }\n\n  const task = middleware.run(main);\n  return task.toPromise().catch(err => {\n    // saga does not blow up without onError\n    expect(err).toBe(expectedError);\n    expect(console.error.mock.calls).toMatchInlineSnapshot(`\nArray [\n  Array [\n    [Error: child error],\n  ],\n  Array [\n    \"The above error occurred in task child\n    created by main\n\",\n  ],\n]\n`);\n  }).then(restoreConsoleError, restoreConsoleError);\n});","file":"interpreter/onerror.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga onError is called for uncaught error (thrown Error instance)","suites":[],"updatePoint":{"line":41,"column":71},"line":41,"code":"test('saga onError is called for uncaught error (thrown Error instance)', () => {\n  const middleware = sagaMiddleware({\n    onError: err => {\n      actual = err;\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const expectedError = new Error('child error');\n  let actual;\n\n  function* child() {\n    throw expectedError;\n  }\n\n  function* main() {\n    yield io.call(child);\n  }\n\n  const task = middleware.run(main);\n  return task.toPromise().catch(() => {\n    // saga passes thrown Error instance in onError handler\n    expect(actual).toBe(expectedError);\n  });\n});","file":"interpreter/onerror.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga onError is called for uncaught error (thrown primitive)","suites":[],"updatePoint":{"line":65,"column":66},"line":65,"code":"test('saga onError is called for uncaught error (thrown primitive)', () => {\n  const middleware = sagaMiddleware({\n    onError: err => {\n      actual = err;\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  const expectedError = new Error('child error');\n  let actual;\n\n  function* child() {\n    throw expectedError;\n  }\n\n  function* main() {\n    yield io.call(child);\n  }\n\n  const task = middleware.run(main);\n  return task.toPromise().catch(() => {\n    // saga passes thrown primitive in onError handler\n    expect(actual).toBe(expectedError);\n  });\n});","file":"interpreter/onerror.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga onError is not called for caught errors","suites":[],"updatePoint":{"line":89,"column":50},"line":89,"code":"test('saga onError is not called for caught errors', () => {\n  const expectedError = new Error('child error');\n  let actual;\n  let caught;\n  const middleware = sagaMiddleware({\n    onError: err => {\n      actual = err;\n    }\n  });\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* child() {\n    throw expectedError;\n  }\n\n  function* main() {\n    try {\n      yield io.call(child);\n    } catch (err) {\n      caught = err;\n    }\n  }\n\n  const task = middleware.run(main);\n  return task.toPromise().then(() => {\n    // saga must not call onError\n    expect(actual).toBe(undefined); // parent must catch error\n\n    expect(caught).toBe(expectedError);\n  });\n});","file":"interpreter/onerror.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga native promise handling","suites":[],"updatePoint":{"line":3,"column":34},"line":3,"code":"test('saga native promise handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    try {\n      actual.push(yield Promise.resolve(1));\n      actual.push(yield Promise.reject('error'));\n    } catch (e) {\n      actual.push('caught ' + e);\n    }\n  }\n\n  const task = middleware.run(genFn);\n  return task.toPromise().then(() => {\n    // saga should handle promise resolved/rejected values\n    expect(actual).toEqual([1, 'caught error']);\n  });\n});","file":"interpreter/promise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga native promise handling: undefined errors","suites":[],"updatePoint":{"line":23,"column":52},"line":23,"code":"test('saga native promise handling: undefined errors', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* genFn() {\n    try {\n      actual.push(yield Promise.reject());\n    } catch (e) {\n      actual.push('caught ' + e);\n    }\n  }\n\n  const task = middleware.run(genFn);\n  return task.toPromise().then(() => {\n    // saga should throw if Promise rejected with an undefined error\n    expect(actual).toEqual(['caught undefined']);\n  });\n});","file":"interpreter/promise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga put handling","suites":[],"updatePoint":{"line":14,"column":23},"line":14,"code":"test('saga put handling', () => {\n  let actual = [];\n\n  const spy = () => next => action => {\n    actual.push(action.type);\n    next(action);\n  };\n\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(spy, sagaMiddleware)(createStore)(() => {});\n\n  function* genFn(arg) {\n    yield io.put({\n      type: arg\n    });\n    yield io.put({\n      type: 2\n    });\n  }\n\n  const task = sagaMiddleware.run(genFn, 'arg');\n  const expected = ['arg', 2];\n  return task.toPromise().then(() => {\n    // saga must handle generator puts\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga put in a channel","suites":[],"updatePoint":{"line":41,"column":27},"line":41,"code":"test('saga put in a channel', () => {\n  const buffer = [];\n  const spyBuffer = {\n    isEmpty: () => !buffer.length,\n    put: it => buffer.push(it),\n    take: () => buffer.shift()\n  };\n  const chan = channel(spyBuffer);\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(sagaMiddleware)(createStore)(() => {});\n\n  function* genFn(arg) {\n    yield io.put(chan, arg);\n    yield io.put(chan, 2);\n  }\n\n  const task = sagaMiddleware.run(genFn, 'arg');\n  const expected = ['arg', 2];\n  return task.toPromise().then(() => {\n    // saga must handle puts on a given channel\n    expect(buffer).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga async put's response handling","suites":[],"updatePoint":{"line":64,"column":40},"line":64,"code":"test(\"saga async put's response handling\", () => {\n  let actual = [];\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(thunk, sagaMiddleware)(createStore)(() => {});\n\n  function* genFn(arg) {\n    actual.push(yield io.putResolve(Promise.resolve(arg)));\n    actual.push(yield io.putResolve(Promise.resolve(2)));\n  }\n\n  const task = sagaMiddleware.run(genFn, 'arg');\n  const expected = ['arg', 2];\n  return task.toPromise().then(() => {\n    // saga must handle async responses of generator put effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga error put's response handling","suites":[],"updatePoint":{"line":81,"column":40},"line":81,"code":"test(\"saga error put's response handling\", () => {\n  let actual = [];\n  const error = new Error('error');\n\n  const reducer = (state, action) => {\n    if (action.error) {\n      throw error;\n    }\n\n    return state;\n  };\n\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(sagaMiddleware)(createStore)(reducer);\n\n  function* genFn(arg) {\n    try {\n      yield io.put({\n        type: arg,\n        error: true\n      });\n    } catch (err) {\n      actual.push(err);\n    }\n  }\n\n  const task = sagaMiddleware.run(genFn, 'arg');\n  const expected = [error];\n  return task.toPromise().then(() => {\n    // saga should bubble thrown errors of generator put effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga error putResolve's response handling","suites":[],"updatePoint":{"line":114,"column":47},"line":114,"code":"test(\"saga error putResolve's response handling\", () => {\n  let actual = [];\n\n  const reducer = state => state;\n\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(thunk, sagaMiddleware)(createStore)(reducer);\n\n  function* genFn(arg) {\n    try {\n      actual.push(yield io.putResolve(Promise.reject(new Error('error ' + arg))));\n    } catch (err) {\n      actual.push(err.message);\n    }\n  }\n\n  const task = sagaMiddleware.run(genFn, 'arg');\n  const expected = ['error arg'];\n  return task.toPromise().then(() => {\n    // saga must bubble thrown errors of generator putResolve effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga nested puts handling","suites":[],"updatePoint":{"line":137,"column":31},"line":137,"code":"test('saga nested puts handling', () => {\n  let actual = [];\n  const sagaMiddleware = createSagaMiddleware();\n  applyMiddleware(sagaMiddleware)(createStore)(() => {});\n\n  function* genA() {\n    yield io.put({\n      type: 'a'\n    });\n    actual.push('put a');\n  }\n\n  function* genB() {\n    yield io.take('a');\n    yield io.put({\n      type: 'b'\n    });\n    actual.push('put b');\n  }\n\n  function* root() {\n    yield io.fork(genB); // forks genB first to be ready to take before genA starts putting\n\n    yield io.fork(genA);\n  }\n\n  const expected = ['put a', 'put b'];\n  return sagaMiddleware.run(root).toPromise().then(() => {\n    // saga must order nested puts by executing them after the outer puts complete\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"puts emitted while dispatching saga need not to cause stack overflow","suites":[],"updatePoint":{"line":169,"column":74},"line":169,"code":"test('puts emitted while dispatching saga need not to cause stack overflow', () => {\n  function* root() {\n    yield io.put({\n      type: 'put a lot of actions'\n    });\n    yield io.delay(0);\n  }\n\n  const reducer = (state, action) => action.type;\n\n  const chan = stdChannel();\n  const rawPut = chan.put;\n\n  chan.put = () => {\n    for (let i = 0; i < 32768; i++) {\n      rawPut({\n        type: 'test'\n      });\n    }\n  };\n\n  const sagaMiddleware = createSagaMiddleware({\n    channel: chan\n  });\n  createStore(reducer, applyMiddleware(sagaMiddleware));\n  const task = sagaMiddleware.run(root);\n  return task.toPromise().then(() => {\n    // this saga needs to run without stack overflow\n    expect(true).toBe(true);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"puts emitted directly after creating a task (caused by another put) should not be missed by that task","suites":[],"updatePoint":{"line":200,"column":107},"line":200,"code":"test('puts emitted directly after creating a task (caused by another put) should not be missed by that task', () => {\n  const actual = [];\n\n  const rootReducer = (state, action) => {\n    return {\n      callSubscriber: action.callSubscriber\n    };\n  };\n\n  const sagaMiddleware = createSagaMiddleware();\n  const store = createStore(rootReducer, undefined, applyMiddleware(sagaMiddleware));\n  const saga = sagaMiddleware.run(function* () {\n    yield io.take('a');\n    yield io.put({\n      type: 'b',\n      callSubscriber: true\n    });\n    yield io.take('c');\n    yield io.fork(function* () {\n      yield io.take('do not miss');\n      actual.push(\"didn't get missed\");\n    });\n  });\n  store.subscribe(() => {\n    if (store.getState().callSubscriber) {\n      store.dispatch({\n        type: 'c'\n      });\n      store.dispatch({\n        type: 'do not miss'\n      });\n    }\n  });\n  store.dispatch({\n    type: 'a'\n  });\n  const expected = [\"didn't get missed\"];\n  return saga.toPromise().then(() => {\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"END should reach tasks created after it gets dispatched","suites":[],"updatePoint":{"line":241,"column":61},"line":241,"code":"test('END should reach tasks created after it gets dispatched', () => {\n  const actual = [];\n\n  const rootReducer = () => ({});\n\n  const sagaMiddleware = createSagaMiddleware();\n  const store = createStore(rootReducer, undefined, applyMiddleware(sagaMiddleware));\n\n  function* subTask() {\n    try {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        actual.push('subTask taking END');\n        yield io.take('NEXT');\n        actual.push('should not get here');\n      }\n    } finally {\n      actual.push('auto ended');\n    }\n  }\n\n  const def = deferred();\n  const rootSaga = sagaMiddleware.run(function* () {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      yield io.take('START');\n      actual.push('start taken');\n      yield def.promise;\n      actual.push('non-take effect resolved');\n      yield io.fork(subTask);\n      actual.push('subTask forked');\n    }\n  });\n  Promise.resolve().then(() => {\n    store.dispatch({\n      type: 'START'\n    });\n    store.dispatch(END);\n  }).then(() => {\n    def.resolve();\n    store.dispatch({\n      type: 'NEXT'\n    });\n    store.dispatch({\n      type: 'START'\n    });\n  });\n  const expected = ['start taken', 'non-take effect resolved', 'subTask taking END', 'auto ended', 'subTask forked'];\n  return rootSaga.toPromise().then(() => {\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/put.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga race between effects handling","suites":[],"updatePoint":{"line":6,"column":40},"line":6,"code":"test('saga race between effects handling', () => {\n  let resultOfRace = 'initial';\n  const timeout = deferred();\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    resultOfRace = yield io.race({\n      event: io.take('action'),\n      timeout: timeout.promise\n    });\n  }\n\n  const task = middleware.run(genFn);\n  const expected = {\n    timeout: 1\n  };\n  return Promise.resolve().then(() => timeout.resolve(1)).then(() => store.dispatch({\n    type: 'action'\n  })).then(() => task.toPromise()).then(() => {\n    // saga must fulfill race between effects\n    expect(resultOfRace).toEqual(expected);\n  });\n});","file":"interpreter/race.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga race between array of effects handling","suites":[],"updatePoint":{"line":30,"column":49},"line":30,"code":"test('saga race between array of effects handling', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const timeout = deferred();\n\n  function* genFn() {\n    actual.push(yield io.race([io.take('action'), timeout.promise]));\n  }\n\n  const task = middleware.run(genFn); // eslint-disable-next-line no-sparse-arrays\n\n  const expected = [[, 1]];\n  return Promise.resolve().then(() => timeout.resolve(1)).then(() => store.dispatch({\n    type: 'action'\n  })).then(() => task.toPromise()).then(() => {\n    // saga must fulfill race between array of effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/race.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga race between effects: handle END","suites":[],"updatePoint":{"line":50,"column":43},"line":50,"code":"test('saga race between effects: handle END', () => {\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const timeout = deferred();\n  let resultOfRace = 'initial';\n  let called = false;\n\n  function* genFn() {\n    called = true;\n    resultOfRace = yield io.race({\n      event: io.take('action'),\n      task: timeout.promise\n    });\n  }\n\n  const task = middleware.run(genFn);\n  return Promise.resolve().then(() => store.dispatch(END)).then(() => timeout.resolve(1)).then(() => task.toPromise()).then(() => {\n    // should run saga\n    expect(called).toBe(true); // saga must end Race Effect if one of the effects resolve with END\n\n    expect(resultOfRace).toBe('initial');\n  });\n});","file":"interpreter/race.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga race between sync effects","suites":[],"updatePoint":{"line":73,"column":36},"line":73,"code":"test('saga race between sync effects', () => {\n  let actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    const xChan = yield io.actionChannel('x');\n    const yChan = yield io.actionChannel('y');\n    yield io.take('start');\n    yield io.race({\n      x: io.take(xChan),\n      y: io.take(yChan)\n    });\n    yield Promise.resolve(); // waiting for next tick\n\n    actual.push(yield io.flush(xChan), yield io.flush(yChan));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [[], [{\n    type: 'y'\n  }]];\n  return Promise.resolve().then(() => store.dispatch({\n    type: 'x'\n  })).then(() => store.dispatch({\n    type: 'y'\n  })).then(() => store.dispatch({\n    type: 'start'\n  })).then(() => {\n    return task.toPromise();\n  }).then(() => {\n    // saga must not run effects when already completed\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/race.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga race cancelling joined tasks","suites":[],"updatePoint":{"line":108,"column":39},"line":108,"code":"test('saga race cancelling joined tasks', () => {\n  const middleware = sagaMiddleware();\n  applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    yield io.race({\n      join: io.join([yield io.fork(function* () {\n        yield io.delay(10);\n      }), yield io.fork(function* () {\n        yield io.delay(100);\n      })]),\n      timeout: io.delay(50)\n    });\n  }\n\n  const task = middleware.run(genFn);\n  return Promise.resolve().then(() => task.toPromise());\n});","file":"interpreter/race.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga select/getState handling","suites":[],"updatePoint":{"line":5,"column":35},"line":5,"code":"test('saga select/getState handling', () => {\n  let actual = [];\n  const initialState = {\n    counter: 0,\n    arr: [1, 2]\n  };\n\n  const counterSelector = s => s.counter;\n\n  const arrSelector = (s, idx) => s.arr[idx];\n\n  const def = deferred();\n\n  const rootReducer = (state, action) => {\n    if (action.type === 'inc') {\n      return { ...state,\n        counter: state.counter + 1\n      };\n    }\n\n    return state;\n  };\n\n  const middleware = sagaMiddleware();\n  const store = createStore(rootReducer, initialState, applyMiddleware(middleware));\n\n  function* genFn() {\n    actual.push((yield io.select()).counter);\n    actual.push(yield io.select(counterSelector));\n    actual.push(yield io.select(arrSelector, 1));\n    yield def.promise;\n    actual.push((yield io.select()).counter);\n    actual.push(yield io.select(counterSelector));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [0, 0, 2, 1, 1];\n  return Promise.resolve().then(() => {\n    def.resolve();\n    store.dispatch({\n      type: 'inc'\n    });\n  }).then(() => {\n    return task.toPromise();\n  }).then(() => {\n    // should resolve getState and select effects\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/select.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga take from default channel","suites":[],"updatePoint":{"line":5,"column":36},"line":5,"code":"test('saga take from default channel', () => {\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const typeSymbol = Symbol('action-symbol');\n  let actual = [];\n\n  function* genFn() {\n    try {\n      actual.push(yield io.take()); // take all actions\n\n      actual.push(yield io.take('action-1')); // take only actions of type 'action-1'\n\n      actual.push(yield io.take(['action-2', 'action-2222'])); // take either type\n\n      actual.push(yield io.take(a => a.isAction)); // take if match predicate\n\n      actual.push(yield io.take(['action-3', a => a.isMixedWithPredicate])); // take if match any from the mixed array\n\n      actual.push(yield io.take(['action-3', a => a.isMixedWithPredicate])); // take if match any from the mixed array\n\n      actual.push(yield io.take(typeSymbol)); // take only actions of a Symbol type\n\n      actual.push(yield io.take('never-happening-action')); //  should get END\n      // TODO: never-happening-action replaced with such case is not working\n      // END is not handled properly on channels?\n      // const chan = channel()\n      // actual.push( yield io.take(chan) ) //  should get END\n    } finally {\n      actual.push('auto ended');\n    }\n  }\n\n  const taskP = middleware.run(genFn).toPromise();\n  const expected = [{\n    type: 'action-*'\n  }, {\n    type: 'action-1'\n  }, {\n    type: 'action-2'\n  }, {\n    type: '',\n    isAction: true\n  }, {\n    type: '',\n    isMixedWithPredicate: true\n  }, {\n    type: 'action-3'\n  }, {\n    type: typeSymbol\n  }, 'auto ended'];\n  const scenarioP = Promise.resolve(1).then(() => store.dispatch({\n    type: 'action-*'\n  })).then(() => store.dispatch({\n    type: 'action-1'\n  })).then(() => store.dispatch({\n    type: 'action-2'\n  })).then(() => store.dispatch({\n    type: 'unnoticeable-action'\n  })).then(() => store.dispatch({\n    type: '',\n    isAction: true\n  })).then(() => store.dispatch({\n    type: '',\n    isMixedWithPredicate: true\n  })).then(() => store.dispatch({\n    type: 'action-3'\n  })).then(() => store.dispatch({\n    type: typeSymbol\n  })).then(() => store.dispatch({ ...END,\n    timestamp: Date.now()\n  })) // see #316\n  .then(() => {\n    // saga must fulfill take Effects from default channel\n    expect(actual).toEqual(expected);\n  });\n  return Promise.all([taskP, scenarioP]);\n});","file":"interpreter/take.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga take from provided channel","suites":[],"updatePoint":{"line":82,"column":37},"line":82,"code":"test('saga take from provided channel', () => {\n  const chan = channel();\n  let actual = [];\n  const middleware = sagaMiddleware();\n  applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    actual.push(yield io.takeMaybe(chan));\n    actual.push(yield io.takeMaybe(chan));\n    actual.push(yield io.takeMaybe(chan));\n    actual.push(yield io.takeMaybe(chan));\n    actual.push(yield io.takeMaybe(chan));\n    actual.push(yield io.takeMaybe(chan));\n  }\n\n  const task = middleware.run(genFn);\n  const expected = [1, 2, 3, 4, END, END];\n  return Promise.resolve().then(() => chan.put(1)).then(() => chan.put(2)).then(() => chan.put(3)).then(() => chan.put(4)).then(() => chan.close()).then(() => task.toPromise()).then(() => {\n    // saga must fulfill take Effects from a provided channel\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/take.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga take from eventChannel","suites":[],"updatePoint":{"line":104,"column":33},"line":104,"code":"test('saga take from eventChannel', () => {\n  const em = mitt();\n  const error = new Error('ERROR');\n  const chan = eventChannel(emit => {\n    em.on('*', emit);\n    return () => em.off('*', emit);\n  });\n  let actual = [];\n  const middleware = sagaMiddleware();\n  applyMiddleware(middleware)(createStore)(() => {});\n\n  function* genFn() {\n    try {\n      actual.push(yield io.take(chan));\n      actual.push(yield io.take(chan));\n      actual.push(yield io.take(chan));\n    } catch (e) {\n      actual.push('in-catch-block');\n      actual.push(e);\n    }\n  }\n\n  const task = middleware.run(genFn);\n  const expected = ['action-1', 'action-2', 'in-catch-block', error];\n  return Promise.resolve().then(() => em.emit('action-1')).then(() => em.emit('action-2')).then(() => em.emit(error)).then(() => em.emit('action-after-error')).then(() => task.toPromise()).then(() => {\n    // saga must take payloads from the eventChannel, and errors from eventChannel will make the saga jump to the catch block\n    expect(actual).toEqual(expected);\n  });\n});","file":"interpreter/take.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous sequential takes","suites":[],"updatePoint":{"line":6,"column":34},"line":6,"code":"test('synchronous sequential takes', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* fnA() {\n    actual.push(yield take('a1'));\n    actual.push(yield take('a3'));\n  }\n\n  function* fnB() {\n    actual.push(yield take('a2'));\n  }\n\n  function* root() {\n    yield fork(fnA);\n    yield fork(fnB);\n  }\n\n  store.dispatch({\n    type: 'a1'\n  });\n  store.dispatch({\n    type: 'a2'\n  });\n  store.dispatch({\n    type: 'a3'\n  });\n  return Promise.resolve().then(() => {\n    // Sagas must take consecutive actions dispatched synchronously\n    expect(actual).toEqual([{\n      type: 'a1'\n    }, {\n      type: 'a2'\n    }, {\n      type: 'a3'\n    }]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous concurrent takes","suites":[],"updatePoint":{"line":46,"column":34},"line":46,"code":"test('synchronous concurrent takes', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n  /**\n    If a1 wins, then a2 cancellation means it will not take the next 'a2' action,\n    dispatched immediately by the store after 'a1'; so the 2n take('a2') should take it\n  **/\n\n  function* root() {\n    actual.push(yield race({\n      a1: take('a1'),\n      a2: take('a2')\n    }));\n    actual.push(yield take('a2'));\n  }\n\n  store.dispatch({\n    type: 'a1'\n  });\n  store.dispatch({\n    type: 'a2'\n  });\n  return Promise.resolve().then(() => {\n    // In concurrent takes only the winner must take an action\n    expect(actual).toEqual([{\n      a1: {\n        type: 'a1'\n      }\n    }, {\n      type: 'a2'\n    }]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous parallel takes","suites":[],"updatePoint":{"line":81,"column":32},"line":81,"code":"test('synchronous parallel takes', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* root() {\n    actual.push(yield all([take('a1'), take('a2')]));\n  }\n\n  store.dispatch({\n    type: 'a1'\n  });\n  store.dispatch({\n    type: 'a2'\n  });\n  return Promise.resolve().then(() => {\n    // Saga must resolve once all parallel actions dispatched\n    expect(actual).toEqual([[{\n      type: 'a1'\n    }, {\n      type: 'a2'\n    }]]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous parallel + concurrent takes","suites":[],"updatePoint":{"line":106,"column":45},"line":106,"code":"test('synchronous parallel + concurrent takes', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* root() {\n    actual.push(yield all([race({\n      a1: take('a1'),\n      a2: take('a2')\n    }), take('a2')]));\n  }\n\n  store.dispatch({\n    type: 'a1'\n  });\n  store.dispatch({\n    type: 'a2'\n  });\n  return Promise.resolve().then(() => {\n    // Saga must resolve once all parallel actions dispatched\n    expect(actual).toEqual([[{\n      a1: {\n        type: 'a1'\n      }\n    }, {\n      type: 'a2'\n    }]]);\n  });\n}); //see https://github.com/reactjs/redux/issues/1240","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"startup actions","suites":[],"updatePoint":{"line":137,"column":21},"line":137,"code":"test('startup actions', () => {\n  const actual = [];\n\n  function reducer(state, action) {\n    if (action.type === 'a') actual.push(action.payload);\n    return true;\n  }\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n  middleware.run(fnA);\n  middleware.run(fnB);\n  /*\n    Saga starts dispatching actions immediately after being started\n    But since sagas are started immediately by the saga middleware\n    It means saga will dispatch actions while the store creation\n    is still running (applyMiddleware has not yet returned)\n  */\n\n  function* fnB() {\n    yield put({\n      type: 'a',\n      payload: 1\n    });\n    yield put({\n      type: 'a',\n      payload: 2\n    });\n    yield put({\n      type: 'a',\n      payload: 3\n    });\n  }\n\n  function* fnA() {\n    actual.push('fnA-' + (yield take('a')).payload);\n  }\n\n  return Promise.resolve().then(() => {\n    // Saga must be able to dispatch startup actions\n    expect(actual).toEqual([1, 'fnA-1', 2, 3]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous takes + puts","suites":[],"updatePoint":{"line":180,"column":30},"line":180,"code":"test('synchronous takes + puts', () => {\n  const actual = [];\n\n  function reducer(state, action) {\n    if (action.type === 'a') actual.push(action.payload);\n    return true;\n  }\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n  middleware.run(root);\n\n  function* root() {\n    yield take('a');\n    yield put({\n      type: 'a',\n      payload: 'ack-1'\n    });\n    yield take('a');\n    yield put({\n      type: 'a',\n      payload: 'ack-2'\n    });\n  }\n\n  store.dispatch({\n    type: 'a',\n    payload: 1\n  });\n  store.dispatch({\n    type: 'a',\n    payload: 2\n  });\n  return Promise.resolve().then(() => {\n    // Sagas must be able to interleave takes and puts without losing actions\n    expect(actual).toEqual([1, 'ack-1', 2, 'ack-2']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"synchronous takes (from a channel) + puts (to the store)","suites":[],"updatePoint":{"line":218,"column":62},"line":218,"code":"test('synchronous takes (from a channel) + puts (to the store)', () => {\n  const actual = [];\n  const chan = channel();\n\n  function reducer(state, action) {\n    if (action.type === 'a') actual.push(action.payload);\n    return true;\n  }\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n  middleware.run(root);\n\n  function* root() {\n    actual.push((yield take(chan, 'a')).payload);\n    yield put({\n      type: 'a',\n      payload: 'ack-1'\n    });\n    actual.push((yield take(chan, 'a')).payload);\n    yield put({\n      type: 'a',\n      payload: 'ack-2'\n    });\n    yield take('never-happening-action');\n  }\n\n  chan.put({\n    type: 'a',\n    payload: 1\n  });\n  chan.put({\n    type: 'a',\n    payload: 2\n  });\n  chan.close();\n  return Promise.resolve().then(() => {\n    // Sagas must be able to interleave takes (from a channel) and puts (to the store) without losing actions\n    expect(actual).toEqual([1, 'ack-1', 2, 'ack-2']);\n  });\n}); // see #50","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga put/take handling","suites":[],"updatePoint":{"line":260,"column":34},"line":260,"code":"test('inter-saga put/take handling', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n  middleware.run(root);\n\n  function* fnA() {\n    while (true) {\n      let {\n        payload\n      } = yield take('a');\n      yield fork(someAction, payload);\n    }\n  }\n\n  function* fnB() {\n    yield put({\n      type: 'a',\n      payload: 1\n    });\n    yield put({\n      type: 'a',\n      payload: 2\n    });\n    yield put({\n      type: 'a',\n      payload: 3\n    });\n  }\n\n  function* someAction(payload) {\n    actual.push(payload);\n  }\n\n  function* root() {\n    yield all([fork(fnA), fork(fnB)]);\n  }\n\n  return Promise.resolve().then(() => {\n    // Sagas must take actions from each other\n    expect(actual).toEqual([1, 2, 3]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga put/take handling (via buffered channel)","suites":[],"updatePoint":{"line":303,"column":57},"line":303,"code":"test('inter-saga put/take handling (via buffered channel)', () => {\n  const actual = [];\n  const chan = channel();\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n\n  function* fnA() {\n    while (true) {\n      let action = yield take(chan);\n      yield call(someAction, action);\n    }\n  }\n\n  function* fnB() {\n    yield put(chan, 1);\n    yield put(chan, 2);\n    yield put(chan, 3);\n    yield call(chan.close);\n  }\n\n  function* someAction(action) {\n    actual.push(action);\n    yield Promise.resolve();\n  }\n\n  function* root() {\n    yield all([fork(fnA), fork(fnB)]);\n  }\n\n  return middleware.run(root).toPromise().then(() => {\n    // Sagas must take actions from each other (via buffered channel)\n    expect(actual).toEqual([1, 2, 3]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga send/acknowledge handling","suites":[],"updatePoint":{"line":337,"column":42},"line":337,"code":"test('inter-saga send/acknowledge handling', () => {\n  const actual = [];\n\n  const push = ({\n    type\n  }) => actual.push(type);\n\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n  middleware.run(root);\n\n  function* fnA() {\n    push(yield take('msg-1'));\n    yield put({\n      type: 'ack-1'\n    });\n    push(yield take('msg-2'));\n    yield put({\n      type: 'ack-2'\n    });\n  }\n\n  function* fnB() {\n    yield put({\n      type: 'msg-1'\n    });\n    push(yield take('ack-1'));\n    yield put({\n      type: 'msg-2'\n    });\n    push(yield take('ack-2'));\n  }\n\n  function* root() {\n    yield all([fork(fnA), fork(fnB)]);\n  }\n\n  return Promise.resolve().then(() => {\n    // Sagas must take actions from each other in the right order\n    expect(actual).toEqual(['msg-1', 'ack-1', 'msg-2', 'ack-2']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga send/acknowledge handling (via unbuffered channel)","suites":[],"updatePoint":{"line":379,"column":67},"line":379,"code":"test('inter-saga send/acknowledge handling (via unbuffered channel)', () => {\n  const actual = []; // non buffered channel must behave like the store\n\n  const chan = channel(buffers.none());\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n  middleware.run(root);\n\n  function* fnA() {\n    actual.push(yield take(chan));\n    yield put(chan, 'ack-1');\n    actual.push(yield take(chan));\n    yield put(chan, 'ack-2');\n  }\n\n  function* fnB() {\n    yield put(chan, 'msg-1');\n    actual.push(yield take(chan));\n    yield put(chan, 'msg-2');\n    actual.push(yield take(chan));\n  }\n\n  function* root() {\n    yield fork(fnA);\n    yield fork(fnB);\n  }\n\n  return Promise.resolve().then(() => {\n    // Sagas must take actions from each other (via unbuffered channel) in the right order\n    expect(actual).toEqual(['msg-1', 'ack-1', 'msg-2', 'ack-2']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga send/acknowledge handling (via buffered channel)","suites":[],"updatePoint":{"line":411,"column":65},"line":411,"code":"test('inter-saga send/acknowledge handling (via buffered channel)', () => {\n  const actual = [];\n  const chan = channel();\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n\n  function* fnA() {\n    actual.push(yield take(chan));\n    yield put(chan, 'ack-1');\n    yield Promise.resolve();\n    actual.push(yield take(chan));\n    yield put(chan, 'ack-2');\n  }\n\n  function* fnB() {\n    yield put(chan, 'msg-1');\n    yield Promise.resolve();\n    actual.push(yield take(chan));\n    yield put(chan, 'msg-2');\n    yield Promise.resolve();\n    actual.push(yield take(chan));\n  }\n\n  function* root() {\n    yield fork(fnB);\n    yield fork(fnA);\n  }\n\n  return middleware.run(root).toPromise().then(() => {\n    // Sagas must take actions from each other (via buffered channel) in the right order\n    expect(actual).toEqual(['msg-1', 'ack-1', 'msg-2', 'ack-2']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga fork/take back from forked child 1","suites":[],"updatePoint":{"line":444,"column":51},"line":444,"code":"test('inter-saga fork/take back from forked child 1', () => {\n  const actual = [];\n  const chan = channel();\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n\n  function* root() {\n    yield all([takeEvery('TEST', takeTest1), takeEvery('TEST2', takeTest2)]);\n  }\n\n  let testCounter = 0;\n\n  function* takeTest1(action) {\n    if (testCounter === 0) {\n      actual.push(1);\n      testCounter++;\n      yield put({\n        type: 'TEST2'\n      });\n    } else {\n      actual.push(++testCounter);\n    }\n  }\n\n  function* takeTest2(action) {\n    yield all([fork(forkedPut1), fork(forkedPut2)]);\n  }\n\n  function* forkedPut1() {\n    yield put({\n      type: 'TEST'\n    });\n  }\n\n  function* forkedPut2() {\n    yield put({\n      type: 'TEST'\n    });\n  }\n\n  const task = middleware.run(root);\n  store.dispatch({\n    type: 'TEST'\n  });\n  store.dispatch(END);\n  return task.toPromise().then(() => {\n    // Sagas must take actions from each forked childs doing Sync puts\n    expect(actual).toEqual([1, 2, 3]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"deeply nested forks/puts","suites":[],"updatePoint":{"line":494,"column":30},"line":494,"code":"test('deeply nested forks/puts', () => {\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n\n  function* s1() {\n    yield fork(s2);\n    actual.push(yield take('a2'));\n  }\n\n  function* s2() {\n    yield fork(s3);\n    actual.push(yield take('a3'));\n    yield put({\n      type: 'a2'\n    });\n  }\n\n  function* s3() {\n    yield put({\n      type: 'a3'\n    });\n  }\n\n  middleware.run(s1); // must schedule deeply nested forks/puts\n\n  expect(actual).toEqual([{\n    type: 'a3'\n  }, {\n    type: 'a2'\n  }]);\n}); // #413","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"inter-saga fork/take back from forked child 2","suites":[],"updatePoint":{"line":527,"column":51},"line":527,"code":"test('inter-saga fork/take back from forked child 2', () => {\n  const actual = [];\n  const chan = channel();\n  const middleware = sagaMiddleware();\n  const store = createStore(() => {}, applyMiddleware(middleware));\n  let first = true;\n\n  function* root() {\n    yield takeEvery('PING', ackWorker);\n  }\n\n  function* ackWorker(action) {\n    if (first) {\n      first = false;\n      yield put({\n        type: 'PING',\n        val: action.val + 1\n      });\n      yield take(`ACK-${action.val + 1}`);\n    }\n\n    yield put({\n      type: `ACK-${action.val}`\n    });\n    actual.push(1);\n  }\n\n  const task = middleware.run(root);\n  store.dispatch({\n    type: 'PING',\n    val: 0\n  });\n  store.dispatch(END);\n  return task.toPromise().then(() => {\n    // Sagas must take actions from each forked childs doing Sync puts\n    expect(actual).toEqual([1, 1]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"put causing sync dispatch response in store subscriber","suites":[],"updatePoint":{"line":565,"column":60},"line":565,"code":"test('put causing sync dispatch response in store subscriber', () => {\n  const reducer = (state, action) => action.type;\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n  const actual = [];\n  middleware.run(root);\n  store.subscribe(() => {\n    if (store.getState() === 'c') store.dispatch({\n      type: 'b',\n      test: true\n    });\n  });\n  store.dispatch({\n    type: 'a',\n    test: true\n  });\n\n  function* root() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const {\n        a,\n        b\n      } = yield race({\n        a: take('a'),\n        b: take('b')\n      });\n      actual.push(a ? a.type : b.type);\n\n      if (a) {\n        yield put({\n          type: 'c',\n          test: true\n        });\n        continue;\n      }\n\n      yield put({\n        type: 'd',\n        test: true\n      });\n    }\n  }\n\n  return Promise.resolve().then(() => {\n    // Sagas can't miss actions dispatched by store subscribers during put handling\n    expect(actual).toEqual(['a', 'b']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"action dispatched in root saga should get scheduled and taken by a \"sibling\" take","suites":[],"updatePoint":{"line":615,"column":87},"line":615,"code":"test('action dispatched in root saga should get scheduled and taken by a \"sibling\" take', () => {\n  const reducer = (state, action) => {\n    if (!state) return [];\n    return state.concat(action.type);\n  };\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n\n  function* root() {\n    yield all([put({\n      type: 'FIRST'\n    }), takeEvery('FIRST', function* () {\n      yield put({\n        type: 'SECOND'\n      });\n    })]);\n  }\n\n  middleware.run(root);\n  return Promise.resolve().then(() => {\n    expect(store.getState()).toEqual(['FIRST', 'SECOND']);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"action dispatched synchronously in forked task should be taken a following sync take","suites":[],"updatePoint":{"line":639,"column":90},"line":639,"code":"test('action dispatched synchronously in forked task should be taken a following sync take', () => {\n  const actual = [];\n\n  const reducer = (state, action) => action.type;\n\n  const middleware = sagaMiddleware();\n  const store = createStore(reducer, applyMiddleware(middleware));\n\n  function* root() {\n    // force async, otherwise sync root startup prevents this from being tested appropriately\n    // as the scheduler is in suspended state because of it\n    yield delay(10);\n    yield fork(function* () {\n      yield put({\n        type: 'A',\n        payload: 'foo'\n      });\n    });\n    actual.push(yield take('A'));\n  }\n\n  return middleware.run(root).toPromise().then(() => {\n    expect(actual).toEqual([{\n      type: 'A',\n      payload: 'foo'\n    }]);\n  });\n});","file":"interpreter/takeSync.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"middleware output","suites":[],"updatePoint":{"line":5,"column":23},"line":5,"code":"test('middleware output', () => {\n  const middleware = sagaMiddleware(); // middleware factory must return a function to handle {getState, dispatch}\n\n  expect(typeof middleware).toBe('function'); // middleware returned function must take exactly 1 argument\n\n  expect(middleware.length).toBe(1);\n  const nextHandler = middleware({}); // next handler must return a function to handle action\n\n  expect(typeof nextHandler).toBe('function'); // next handler must take exactly 1 argument\n\n  expect(nextHandler.length).toBe(1);\n  const actionHandler = nextHandler(); // next handler must return a function to handle action\n\n  expect(typeof actionHandler).toBe('function'); // action handler must take exactly 1 argument\n\n  expect(actionHandler.length).toBe(1);\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"middleware's action handler output","suites":[],"updatePoint":{"line":22,"column":40},"line":22,"code":"test(\"middleware's action handler output\", () => {\n  const action = {};\n  const actionHandler = sagaMiddleware()({})(action => action); // action handler must return the result of the next argument\n\n  expect(actionHandler(action)).toBe(action);\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"middleware.run","suites":[],"updatePoint":{"line":28,"column":20},"line":28,"code":"test('middleware.run', () => {\n  let actual;\n\n  function* saga(...args) {\n    actual = args;\n  }\n\n  const middleware = sagaMiddleware();\n\n  try {\n    middleware.run(function* () {});\n  } catch (e) {\n    // middleware.run must throw an Error when executed before the middleware is connected to a Store\n    expect(e instanceof Error).toBe(true);\n  }\n\n  createStore(() => {}, applyMiddleware(middleware));\n  const task = middleware.run(saga, 'argument'); // middleware.run must return a Task Object\n\n  expect(is.task(task)).toBe(true);\n  const expected = ['argument']; // middleware must run the Saga and provides it with the given arguments\n\n  expect(actual).toEqual(expected);\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"middleware options","suites":[],"updatePoint":{"line":52,"column":24},"line":52,"code":"test('middleware options', () => {\n  try {\n    sagaMiddleware({\n      onError: 42\n    });\n  } catch (e) {\n    // middleware factory must raise an error if `options.onError` is not a function\n    expect(e.message).toBe('options.onError passed to the Saga middleware is not a function!');\n  }\n\n  const err = new Error('test');\n\n  function* saga() {\n    throw err;\n  }\n\n  let actual;\n  const expected = err;\n  const options = {\n    onError: err => actual = err\n  };\n  const middleware = sagaMiddleware(options);\n  createStore(() => {}, applyMiddleware(middleware));\n  middleware.run(saga); // `options.onError` is called appropriately\n\n  expect(actual).toBe(expected);\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"enhance channel.put with an emitter","suites":[],"updatePoint":{"line":79,"column":41},"line":79,"code":"test('enhance channel.put with an emitter', () => {\n  const actual = [];\n  const channel = stdChannel();\n  const rawPut = channel.put;\n\n  channel.put = action => {\n    if (action.type === 'batch') {\n      action.batch.forEach(rawPut);\n      return;\n    }\n\n    rawPut(action);\n  };\n\n  function* saga() {\n    yield takeEvery(ac => ac.from !== 'saga', function* ({\n      type\n    }) {\n      actual.push({\n        saga: true,\n        got: type\n      });\n      yield put({\n        type: `pong_${type}`,\n        from: 'saga'\n      });\n    });\n    yield takeEvery(ac => ac.from === 'saga', ({\n      type\n    }) => {\n      actual.push({\n        saga: true,\n        got: type\n      });\n    });\n  }\n\n  let pastStoreCreation = false;\n\n  const rootReducer = (state, {\n    type\n  }) => {\n    if (pastStoreCreation) {\n      actual.push({\n        reducer: true,\n        got: type\n      });\n    }\n\n    return {};\n  };\n\n  const middleware = sagaMiddleware({\n    channel\n  });\n  const store = createStore(rootReducer, {}, applyMiddleware(middleware));\n  pastStoreCreation = true;\n  middleware.run(saga);\n  store.dispatch({\n    type: 'a'\n  });\n  store.dispatch({\n    type: 'batch',\n    batch: [{\n      type: 'b'\n    }, {\n      type: 'c'\n    }]\n  });\n  store.dispatch({\n    type: 'd'\n  }); // saga must be able to take actions emitted by middleware's custom emitter\n\n  const expected = [{\n    reducer: true,\n    got: 'a'\n  }, {\n    saga: true,\n    got: 'a'\n  }, {\n    reducer: true,\n    got: 'pong_a'\n  }, {\n    saga: true,\n    got: 'pong_a'\n  }, {\n    reducer: true,\n    got: 'batch'\n  }, {\n    saga: true,\n    got: 'b'\n  }, {\n    reducer: true,\n    got: 'pong_b'\n  }, {\n    saga: true,\n    got: 'pong_b'\n  }, {\n    saga: true,\n    got: 'c'\n  }, {\n    reducer: true,\n    got: 'pong_c'\n  }, {\n    saga: true,\n    got: 'pong_c'\n  }, {\n    reducer: true,\n    got: 'd'\n  }, {\n    saga: true,\n    got: 'd'\n  }, {\n    reducer: true,\n    got: 'pong_d'\n  }, {\n    saga: true,\n    got: 'pong_d'\n  }];\n  expect(actual).toEqual(expected);\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"middleware.run saga arguments validation","suites":[],"updatePoint":{"line":200,"column":46},"line":200,"code":"test('middleware.run saga arguments validation', () => {\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  expect(() => middleware.run({})).toThrow('saga argument must be a Generator function');\n  expect(() => middleware.run(function* saga() {})).not.toThrow();\n});","file":"middleware.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga middleware monitoring","suites":[],"updatePoint":{"line":53,"column":32},"line":53,"code":"test('saga middleware monitoring', async () => {\n  let ids = [];\n  let effects = {};\n  let actions = [];\n  const storeAction = {\n    type: 'STORE_ACTION'\n  };\n  const sagaAction = {\n    type: 'SAGA_ACTION'\n  };\n  const apiDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => apiDefs[0].resolve('api1')).then(() => apiDefs[1].resolve('api2'));\n\n  function api(idx) {\n    return apiDefs[idx].promise;\n  }\n\n  function* child() {\n    yield io.call(api, 1);\n    yield io.put(sagaAction);\n    throw 'child error';\n  }\n\n  function* main() {\n    try {\n      yield io.call(api, 0);\n      yield io.race({\n        action: io.take('action'),\n        call: io.call(child)\n      });\n    } catch (e) {\n      void 0;\n    }\n  }\n\n  const sagaMonitor = createSagaMonitor(ids, effects, actions);\n  const sagaMiddleware = createSagaMiddleware({\n    sagaMonitor\n  });\n  const store = createStore(() => ({}), applyMiddleware(sagaMiddleware));\n  store.dispatch(storeAction);\n  const task = sagaMiddleware.run(main);\n  await task.toPromise();\n  const expectedEffects = {\n    [ids[0]]: {\n      saga: main,\n      args: [],\n      result: task\n    },\n    [ids[1]]: {\n      parentEffectId: ids[0],\n      label: '',\n      effect: io.call(api, 0),\n      result: 'api1'\n    },\n    [ids[2]]: {\n      parentEffectId: ids[0],\n      label: '',\n      effect: io.race({\n        action: io.take('action'),\n        call: io.call(child)\n      }),\n      error: 'child error'\n    },\n    [ids[3]]: {\n      parentEffectId: ids[2],\n      label: 'action',\n      effect: io.take('action'),\n      cancelled: true\n    },\n    [ids[4]]: {\n      parentEffectId: ids[2],\n      label: 'call',\n      effect: io.call(child),\n      error: 'child error'\n    },\n    [ids[5]]: {\n      parentEffectId: ids[4],\n      label: '',\n      effect: io.call(api, 1),\n      result: 'api2'\n    },\n    [ids[6]]: {\n      parentEffectId: ids[4],\n      label: '',\n      effect: io.put(sagaAction),\n      result: sagaAction\n    }\n  }; // sagaMiddleware must notify the saga monitor of Effect creation and resolution\n\n  expect(effects).toEqual(expectedEffects); // sagaMiddleware must notify the saga monitor of dispatched actions\n\n  expect(actions).toEqual([storeAction, sagaAction]);\n});","file":"monitoring.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"runSaga monitoring","suites":[],"updatePoint":{"line":147,"column":24},"line":147,"code":"test('runSaga monitoring', async () => {\n  let ids = [];\n  let effects = {};\n  let actions = [];\n  const sagaMonitor = createSagaMonitor(ids, effects, actions);\n  const channel = stdChannel();\n\n  const dispatch = action => {\n    sagaMonitor.actionDispatched(action);\n    return action;\n  };\n\n  const storeAction = {\n    type: 'STORE_ACTION'\n  };\n  const sagaAction = {\n    type: 'SAGA_ACTION'\n  };\n  const apiDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => apiDefs[0].resolve('api1')).then(() => apiDefs[1].resolve('api2'));\n\n  function api(idx) {\n    return apiDefs[idx].promise;\n  }\n\n  function* child() {\n    yield io.call(api, 1);\n    yield io.put(sagaAction);\n    throw 'child error';\n  }\n\n  function* main() {\n    try {\n      yield io.call(api, 0);\n      yield io.race({\n        action: io.take('action'),\n        call: io.call(child)\n      });\n    } catch (e) {\n      void 0;\n    }\n  }\n\n  const task = runSaga({\n    channel,\n    dispatch,\n    sagaMonitor\n  }, main);\n  dispatch(storeAction);\n  await task.toPromise();\n  const expectedEffects = {\n    [ids[0]]: {\n      saga: main,\n      args: [],\n      result: task\n    },\n    [ids[1]]: {\n      parentEffectId: ids[0],\n      label: '',\n      effect: io.call(api, 0),\n      result: 'api1'\n    },\n    [ids[2]]: {\n      parentEffectId: ids[0],\n      label: '',\n      effect: io.race({\n        action: io.take('action'),\n        call: io.call(child)\n      }),\n      error: 'child error'\n    },\n    [ids[3]]: {\n      parentEffectId: ids[2],\n      label: 'action',\n      effect: io.take('action'),\n      cancelled: true\n    },\n    [ids[4]]: {\n      parentEffectId: ids[2],\n      label: 'call',\n      effect: io.call(child),\n      error: 'child error'\n    },\n    [ids[5]]: {\n      parentEffectId: ids[4],\n      label: '',\n      effect: io.call(api, 1),\n      result: 'api2'\n    },\n    [ids[6]]: {\n      parentEffectId: ids[4],\n      label: '',\n      effect: io.put(sagaAction),\n      result: sagaAction\n    }\n  }; // runSaga must notify the saga monitor of Effect creation and resolution\n\n  expect(effects).toEqual(expectedEffects);\n  const expectedActions = [storeAction, sagaAction]; // runSaga must notify the saga monitor of dispatched actions\n\n  expect(actions).toEqual(expectedActions);\n});","file":"monitoring.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"saga monitors without all functions","suites":[],"updatePoint":{"line":249,"column":41},"line":249,"code":"test('saga monitors without all functions', async () => {\n  const storeAction = {\n    type: 'STORE_ACTION'\n  };\n  const sagaAction = {\n    type: 'SAGA_ACTION'\n  };\n  const apiDefs = arrayOfDeferred(2);\n  Promise.resolve(1).then(() => apiDefs[0].resolve('api1')).then(() => apiDefs[1].resolve('api2'));\n\n  function api(idx) {\n    return apiDefs[idx].promise;\n  }\n\n  function* child() {\n    yield io.call(api, 1);\n    yield io.put(sagaAction);\n    throw 'child error';\n  }\n\n  function* main() {\n    try {\n      yield io.call(api, 0);\n      yield io.race({\n        action: io.take('action'),\n        call: io.call(child)\n      });\n    } catch (e) {\n      void 0;\n    }\n\n    return 'success';\n  } // let's create an empty object\n\n\n  const sagaMonitor = {};\n  const sagaMiddleware = createSagaMiddleware({\n    sagaMonitor\n  });\n  const store = createStore(() => ({}), applyMiddleware(sagaMiddleware));\n  store.dispatch(storeAction);\n  const task = sagaMiddleware.run(main); // given noops to fulfill the monitor interface we have survived\n\n  const taskResult = await task.toPromise();\n  expect(taskResult).toBe('success');\n});","file":"monitoring.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"runSaga","suites":[],"updatePoint":{"line":17,"column":13},"line":17,"code":"test('runSaga', () => {\n  let actual = [];\n\n  function reducer(state, action) {\n    return action;\n  }\n\n  const store = storeLike(reducer, {});\n\n  const typeSelector = a => a.type;\n\n  const task = runSaga(store, root);\n\n  function* root() {\n    yield all([fork(fnA), fork(fnB)]);\n  }\n\n  function* fnA() {\n    actual.push(yield take('ACTION-1'));\n    actual.push(yield select(typeSelector));\n    actual.push(yield take('ACTION-2'));\n    actual.push(yield select(typeSelector));\n    yield put({\n      type: 'ACTION-3'\n    });\n  }\n\n  function* fnB() {\n    actual.push(yield take('ACTION-3'));\n    actual.push(yield select(typeSelector));\n  }\n\n  Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION-1'\n  })).then(() => store.dispatch({\n    type: 'ACTION-2'\n  }));\n  const expected = [{\n    type: 'ACTION-1'\n  }, 'ACTION-1', {\n    type: 'ACTION-2'\n  }, 'ACTION-2', {\n    type: 'ACTION-3'\n  }, 'ACTION-3'];\n  return task.toPromise().then(() => {\n    // runSaga must connect the provided iterator to the store, and run it\n    expect(actual).toEqual(expected);\n  });\n});","file":"runSaga.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: sync actions","suites":[],"updatePoint":{"line":5,"column":28},"line":5,"code":"test('debounce: sync actions', () => {\n  let called = 0;\n  const delayMs = 33;\n  const largeDelayMs = delayMs + 100;\n  const actual = [];\n  const expected = [[1, 'c']];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n\n  function* saga() {\n    const task = yield debounce(delayMs, 'ACTION', fnToCall);\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* fnToCall(action) {\n    called++;\n    actual.push([called, action.payload]);\n  }\n\n  return Promise.resolve().then(() => {\n    store.dispatch({\n      type: 'ACTION',\n      payload: 'a'\n    });\n    store.dispatch({\n      type: 'ACTION',\n      payload: 'b'\n    });\n    store.dispatch({\n      type: 'ACTION',\n      payload: 'c'\n    });\n  }).then(() => delayP(largeDelayMs)).then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })).then(() => {\n    // should debounce sync actions and pass the lastest action to a worker\n    expect(actual).toEqual(expected);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: async actions","suites":[],"updatePoint":{"line":46,"column":29},"line":46,"code":"test('debounce: async actions', () => {\n  let called = 0;\n  const delayMs = 30;\n  const smallDelayMs = delayMs - 10;\n  const largeDelayMs = delayMs + 10;\n  const actual = [];\n  const expected = [[1, 'c'], [2, 'd']];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n\n  function* saga() {\n    const task = yield debounce(delayMs, 'ACTION', fnToCall);\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* fnToCall(action) {\n    called++;\n    actual.push([called, action.payload]);\n  }\n\n  return Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'a'\n  })).then(() => delayP(smallDelayMs)).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'b'\n  })).then(() => delayP(smallDelayMs)).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'c'\n  })).then(() => delayP(largeDelayMs)).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'd'\n  })).then(() => delayP(largeDelayMs)).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'e'\n  })).then(() => delayP(smallDelayMs)).then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })).then(() => {\n    // should debounce async actions and pass the lastest action to a worker\n    expect(actual).toEqual(expected);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: cancelled","suites":[],"updatePoint":{"line":90,"column":25},"line":90,"code":"test('debounce: cancelled', () => {\n  let called = 0;\n  const delayMs = 30;\n  const smallDelayMs = delayMs - 10;\n  const actual = [];\n  const expected = [];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n\n  function* saga() {\n    const task = yield debounce(delayMs, 'ACTION', fnToCall);\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* fnToCall(action) {\n    called++;\n    actual.push([called, action.payload]);\n  }\n\n  return Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 'a'\n  })).then(() => delayP(smallDelayMs)).then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })).then(() => {\n    // should not call a worker if cancelled before debounce limit is reached\n    expect(actual).toEqual(expected);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: channel","suites":[],"updatePoint":{"line":121,"column":23},"line":121,"code":"test('debounce: channel', () => {\n  let called = 0;\n  const delayMs = 30;\n  const largeDelayMs = delayMs + 10;\n  const customChannel = channel();\n  const actual = [];\n  const expected = [[1, 'c']];\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n\n  function* saga() {\n    const task = yield debounce(delayMs, customChannel, fnToCall);\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* fnToCall(dataFromChannel) {\n    called++;\n    actual.push([called, dataFromChannel]);\n  }\n\n  return Promise.resolve().then(() => {\n    customChannel.put('a');\n    customChannel.put('b');\n    customChannel.put('c');\n  }).then(() => delayP(largeDelayMs)).then(() => {\n    customChannel.put('d');\n  }).then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })).then(() => {\n    // should debounce actions from channel and pass the lastest action to a worker\n    expect(actual).toEqual(expected);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: channel END","suites":[],"updatePoint":{"line":156,"column":27},"line":156,"code":"test('debounce: channel END', () => {\n  let called = 0;\n  const delayMs = 30;\n  const smallDelayMs = delayMs - 10;\n  const customChannel = channel();\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield debounce(delayMs, customChannel, fnToCall);\n  }\n\n  function* fnToCall() {\n    called++;\n  }\n\n  return Promise.resolve().then(() => delayP(smallDelayMs)).then(() => customChannel.put(END)).then(() => {\n    // should finish debounce task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(0);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: pattern END","suites":[],"updatePoint":{"line":181,"column":27},"line":181,"code":"test('debounce: pattern END', () => {\n  let called = 0;\n  const delayMs = 30;\n  const smallDelayMs = delayMs - 10;\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield debounce(delayMs, 'ACTION', fnToCall);\n  }\n\n  function* fnToCall() {\n    called++;\n  }\n\n  return Promise.resolve().then(() => delayP(smallDelayMs)).then(() => store.dispatch(END)).then(() => {\n    // should finish debounce task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(0);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"debounce: pattern END during race","suites":[],"updatePoint":{"line":205,"column":39},"line":205,"code":"test('debounce: pattern END during race', () => {\n  let called = 0;\n  const delayMs = 30;\n  const largeDelayMs = delayMs + 10;\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield debounce(delayMs, 'ACTION', fnToCall);\n  }\n\n  function* fnToCall() {\n    called++;\n  }\n\n  return Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION'\n  })).then(() => store.dispatch(END)).then(() => delayP(largeDelayMs)).then(() => store.dispatch({\n    type: 'ACTION'\n  })).then(() => delayP(largeDelayMs)).then(() => {\n    // should interrupt race on END\n    expect(called).toBe(0); // should finish debounce task on END\n\n    expect(task.isRunning()).toBe(false);\n  });\n});","file":"sagaHelpers/debounce.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"delay","suites":[],"updatePoint":{"line":5,"column":11},"line":5,"code":"test('delay', async () => {\n  const actual = [];\n  const myVal = 'myValue';\n  const expected = [true, myVal];\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n  middleware.run(saga);\n\n  function* saga() {\n    actual.push(yield delay(1));\n    actual.push(yield delay(1, myVal));\n  }\n\n  await delayP(100);\n  expect(actual).toEqual(expected);\n});","file":"sagaHelpers/delay.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"retry failing","suites":[],"updatePoint":{"line":4,"column":19},"line":4,"code":"test('retry failing', () => {\n  let called = 0;\n  const delayMs = 0;\n  const errorMessage = 'failed';\n  const actual = [];\n  const expected = [['a', 1], ['a', 2], ['a', 3]];\n  let error;\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* saga() {\n    try {\n      yield retry(3, delayMs, fnToCall, 'a');\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  function* fnToCall(arg1) {\n    called++;\n    actual.push([arg1, called]);\n    throw new Error(errorMessage);\n  }\n\n  return middleware.run(saga).toPromise().then(() => {\n    // should retry only for the defined number of times\n    expect(actual).toEqual(expected); // should rethrow Error if failed more than the defined number of times\n\n    expect(error.message).toBe(errorMessage);\n  });\n});","file":"sagaHelpers/retry.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"retry without failing","suites":[],"updatePoint":{"line":35,"column":27},"line":35,"code":"test('retry without failing', () => {\n  let called = false;\n  const delayMs = 0;\n  const returnedValue = 42;\n  let result;\n  const middleware = sagaMiddleware();\n  createStore(() => ({}), {}, applyMiddleware(middleware));\n\n  function* saga() {\n    result = yield retry(3, delayMs, fnToCall);\n  }\n\n  function* fnToCall() {\n    if (called === false) {\n      called = true;\n      throw new Error();\n    }\n\n    return returnedValue;\n  }\n\n  return middleware.run(saga).toPromise().then(() => {\n    // should return a result of called function\n    expect(result).toBe(returnedValue);\n  });\n});","file":"sagaHelpers/retry.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeEvery","suites":[],"updatePoint":{"line":4,"column":15},"line":4,"code":"test('takeEvery', () => {\n  const loop = 10;\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  const mainTask = middleware.run(root);\n\n  function* root() {\n    const task = yield takeEvery('ACTION', worker, 'a1', 'a2');\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* worker(arg1, arg2, action) {\n    actual.push([arg1, arg2, action.payload]);\n  }\n\n  const inputTask = Promise.resolve().then(() => {\n    for (let i = 1; i <= loop / 2; i++) store.dispatch({\n      type: 'ACTION',\n      payload: i\n    });\n  }) // the watcher should be cancelled after this\n  // no further task should be forked after this\n  .then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })).then(() => {\n    for (let i = loop / 2 + 1; i <= loop; i++) store.dispatch({\n      type: 'ACTION',\n      payload: i\n    });\n  });\n  return Promise.all([mainTask.toPromise(), inputTask]).then(() => {\n    // takeEvery must fork a worker on each action\n    expect(actual).toEqual([['a1', 'a2', 1], ['a1', 'a2', 2], ['a1', 'a2', 3], ['a1', 'a2', 4], ['a1', 'a2', 5]]);\n  });\n});","file":"sagaHelpers/takeEvery.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeEvery: pattern END","suites":[],"updatePoint":{"line":41,"column":28},"line":41,"code":"test('takeEvery: pattern END', () => {\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainTask = middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield takeEvery('ACTION', fnToCall);\n  }\n\n  let called = false;\n\n  function* fnToCall() {\n    called = true;\n  }\n\n  store.dispatch(END);\n  store.dispatch({\n    type: 'ACTION'\n  });\n  return mainTask.toPromise().then(() => {\n    // should finish takeEvery task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(false);\n  });\n});","file":"sagaHelpers/takeEvery.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeLatest","suites":[],"updatePoint":{"line":5,"column":16},"line":5,"code":"test('takeLatest', () => {\n  const defs = arrayOfDeferred(4);\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* root() {\n    const task = yield takeLatest('ACTION', worker, 'a1', 'a2');\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* worker(arg1, arg2, action) {\n    const idx = action.payload - 1;\n    const response = yield defs[idx].promise;\n    actual.push([arg1, arg2, response]);\n  }\n\n  return Promise.resolve().then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 1\n  })).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 2\n  })).then(() => defs[0].resolve('w-1')).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 3\n  })).then(() => defs[1].resolve('w-2')).then(() => defs[2].resolve('w-3')).then(() => {\n    store.dispatch({\n      type: 'ACTION',\n      payload: 4\n    });\n    /*\n    We immediately cancel the watcher after firing the action\n    The watcher should be cancelled after this\n    no further task should be forked\n    the last forked task should also be cancelled\n    */\n\n    store.dispatch({\n      type: 'CANCEL_WATCHER'\n    });\n  }).then(() => defs[3].resolve('w-4')).then(() => {\n    // this one should be ignored by the watcher\n    store.dispatch({\n      type: 'ACTION',\n      payload: 5\n    });\n  }).then(() => {\n    // takeLatest must cancel current task before forking a new task\n    expect(actual).toEqual([['a1', 'a2', 'w-3']]);\n  });\n});","file":"sagaHelpers/takeLatest.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeLatest: pattern END","suites":[],"updatePoint":{"line":59,"column":29},"line":59,"code":"test('takeLatest: pattern END', () => {\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainTask = middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield takeLatest('ACTION', fnToCall);\n  }\n\n  let called = false;\n\n  function* fnToCall() {\n    called = true;\n  }\n\n  store.dispatch(END);\n  store.dispatch({\n    type: 'ACTION'\n  });\n  store.dispatch({\n    type: 'ACTION'\n  });\n  return mainTask.toPromise().then(() => {\n    // should finish takeLatest task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(false);\n  });\n});","file":"sagaHelpers/takeLatest.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeLeading","suites":[],"updatePoint":{"line":5,"column":17},"line":5,"code":"test('takeLeading', () => {\n  const defs = arrayOfDeferred(4);\n  const actual = [];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* root() {\n    const task = yield takeLeading('ACTION', worker, 'a1', 'a2');\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* worker(arg1, arg2, action) {\n    const idx = action.payload - 1;\n    const response = yield defs[idx].promise;\n    actual.push([arg1, arg2, response]);\n  }\n\n  return Promise.resolve(1).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 1\n  })).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 2\n  })).then(() => defs[1].resolve('w-2')).then(() => defs[0].resolve('w-1')).then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 3\n  })).then(() => defs[2].resolve('w-3')).then(() => {\n    store.dispatch({\n      type: 'ACTION',\n      payload: 4\n    });\n    /*\n    We immediately cancel the watcher after firing the action\n    The watcher should be cancelled after this\n    no further task should be forked\n    the last forked task should also be cancelled\n    */\n\n    store.dispatch({\n      type: 'CANCEL_WATCHER'\n    });\n  }).then(() => defs[3].resolve('w-4')).then(() => {\n    // this one should be ignored by the watcher\n    store.dispatch({\n      type: 'ACTION',\n      payload: 5\n    });\n  }).then(() => {\n    // takeLeading must ignore new action and keep running task until the completion\n    expect(actual).toEqual([['a1', 'a2', 'w-1'], ['a1', 'a2', 'w-3']]);\n  });\n});","file":"sagaHelpers/takeLeading.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"takeLeading: pattern END","suites":[],"updatePoint":{"line":59,"column":30},"line":59,"code":"test('takeLeading: pattern END', () => {\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainTask = middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield takeLeading('ACTION', fnToCall);\n  }\n\n  let called = false;\n\n  function* fnToCall() {\n    called = true;\n  }\n\n  store.dispatch(END);\n  store.dispatch({\n    type: 'ACTION'\n  });\n  return mainTask.toPromise().then(() => {\n    // should finish takeLeading task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(false);\n  });\n});","file":"sagaHelpers/takeLeading.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"throttle","suites":[],"updatePoint":{"line":5,"column":14},"line":5,"code":"test('throttle', () => {\n  jest.useFakeTimers();\n  const actual = [];\n  const expected = [['a1', 'a2', 0], ['a1', 'a2', 10], ['a1', 'a2', 20], ['a1', 'a2', 30], ['a1', 'a2', 34]];\n  const middleware = sagaMiddleware();\n  const store = applyMiddleware(middleware)(createStore)(() => {});\n  middleware.run(root);\n\n  function* root() {\n    const task = yield throttle(100, 'ACTION', worker, 'a1', 'a2');\n    yield take('CANCEL_WATCHER');\n    yield cancel(task);\n  }\n\n  function* worker(arg1, arg2, {\n    payload\n  }) {\n    actual.push([arg1, arg2, payload]);\n  }\n\n  const dispatchedActions = [];\n\n  for (let i = 0; i < 35; i++) {\n    dispatchedActions.push(delayP(i * 10).then(() => store.dispatch({\n      type: 'ACTION',\n      payload: i\n    })).then(() => jest.advanceTimersByTime(10)) // next tick\n    );\n  }\n\n  Promise.resolve().then(() => jest.advanceTimersByTime(1)) // just start for the smallest tick\n  .then(() => jest.advanceTimersByTime(10)); // tick past first delay\n\n  return dispatchedActions[34] // wait so trailing dispatch gets processed\n  .then(() => jest.advanceTimersByTime(100)).then(() => store.dispatch({\n    type: 'CANCEL_WATCHER'\n  })) // shouldn't be processed cause of getting canceled\n  .then(() => store.dispatch({\n    type: 'ACTION',\n    payload: 40\n  })).then(() => {\n    // throttle must ignore incoming actions during throttling interval\n    expect(actual).toEqual(expected);\n    jest.useRealTimers();\n  }).catch(err => {\n    jest.useRealTimers();\n    throw err;\n  });\n});","file":"sagaHelpers/throttle.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"throttle: pattern END","suites":[],"updatePoint":{"line":54,"column":27},"line":54,"code":"test('throttle: pattern END', () => {\n  const delayMs = 20;\n  const middleware = sagaMiddleware();\n  const store = createStore(() => ({}), {}, applyMiddleware(middleware));\n  const mainTask = middleware.run(saga);\n  let task;\n\n  function* saga() {\n    task = yield throttle(delayMs, 'ACTION', fnToCall);\n  }\n\n  let called = false;\n\n  function* fnToCall() {\n    called = true;\n  }\n\n  store.dispatch(END);\n  return mainTask.toPromise().then(() => store.dispatch({\n    type: 'ACTION'\n  })).then(() => delayP(2 * delayMs)).then(() => {\n    // should finish throttle task on END\n    expect(task.isRunning()).toBe(false); // should not call function if finished with END\n\n    expect(called).toBe(false);\n  });\n});","file":"sagaHelpers/throttle.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"scheduler executes all recursively triggered tasks in order","suites":[],"updatePoint":{"line":2,"column":65},"line":2,"code":"test('scheduler executes all recursively triggered tasks in order', () => {\n  const actual = [];\n  asap(() => {\n    actual.push('1');\n    asap(() => {\n      actual.push('2');\n    });\n    asap(() => {\n      actual.push('3');\n    });\n  });\n  expect(actual).toEqual(['1', '2', '3']);\n});","file":"scheduler.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"scheduler when suspended queues up and executes all tasks on flush","suites":[],"updatePoint":{"line":15,"column":72},"line":15,"code":"test('scheduler when suspended queues up and executes all tasks on flush', () => {\n  const actual = [];\n  immediately(() => {\n    asap(() => {\n      actual.push('1');\n      asap(() => {\n        actual.push('2');\n      });\n      asap(() => {\n        actual.push('3');\n      });\n    });\n  });\n  expect(actual).toEqual(['1', '2', '3']);\n});","file":"scheduler.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() of an already completed task","suites":[],"updatePoint":{"line":15,"column":54},"line":15,"code":"test('calling toPromise() of an already completed task', () => {\n  const result = 'result-of-saga';\n  const task = simpleRunSaga(function* saga() {\n    return result;\n  });\n  expect(task.isRunning()).toBe(false);\n  return expect(task.toPromise()).resolves.toBe(result);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() before a task completes","suites":[],"updatePoint":{"line":23,"column":49},"line":23,"code":"test('calling toPromise() before a task completes', () => {\n  const result = 'result-of-saga';\n  const task = simpleRunSaga(function* saga() {\n    yield delay(10);\n    return result;\n  });\n  expect(task.isRunning()).toBe(true);\n  return expect(task.toPromise()).resolves.toBe(result);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() of an already aborted task","suites":[],"updatePoint":{"line":32,"column":52},"line":32,"code":"test('calling toPromise() of an already aborted task', () => {\n  const error = new Error('test-error');\n  const task = simpleRunSaga(function* saga() {\n    throw error;\n  });\n  expect(task.isRunning()).toBe(false);\n  return expect(task.toPromise()).rejects.toBe(error);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() before a task aborts","suites":[],"updatePoint":{"line":40,"column":46},"line":40,"code":"test('calling toPromise() before a task aborts', () => {\n  const error = new Error('test-error');\n  const task = simpleRunSaga(function* saga() {\n    yield delay(10);\n    throw error;\n  });\n  expect(task.isRunning()).toBe(true);\n  return expect(task.toPromise()).rejects.toBe(error);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() of an already cancelled task","suites":[],"updatePoint":{"line":49,"column":54},"line":49,"code":"test('calling toPromise() of an already cancelled task', async () => {\n  let child;\n  simpleRunSaga(function* saga() {\n    child = yield fork(function* child() {\n      yield delay(10000);\n    });\n    yield cancel(child);\n  });\n  expect(child.isRunning()).toBe(false);\n  return expect(child.toPromise()).resolves.toBe(TASK_CANCEL);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"calling toPromise() of before a task gets cancelled","suites":[],"updatePoint":{"line":60,"column":57},"line":60,"code":"test('calling toPromise() of before a task gets cancelled', async () => {\n  let child;\n  simpleRunSaga(function* saga() {\n    child = yield fork(function* child() {\n      yield delay(10000);\n    });\n    yield delay(10);\n    yield cancel(child);\n  });\n  expect(child.isRunning()).toBe(true);\n  return expect(child.toPromise()).resolves.toBe(TASK_CANCEL);\n});","file":"taskToPromise.js","skipped":false,"dir":"packages/core/__tests__"},{"name":"it should allow to \"clone\" the generator","suites":[],"updatePoint":{"line":2,"column":46},"line":2,"code":"test('it should allow to \"clone\" the generator', () => {\n  const genFunc = function* (num1, num2) {\n    yield num1 * num2;\n    const num3 = yield;\n    const add = num1 + num2;\n\n    if (num3 > add) {\n      yield num3 - add;\n    } else if (num3 === add) {\n      yield 'you win';\n    } else {\n      yield add - num3;\n    }\n  };\n\n  const cloneableGen = cloneableGenerator(genFunc)(2, 3);\n  expect(cloneableGen.next()).toEqual({\n    value: 6,\n    done: false\n  });\n  expect(cloneableGen.next()).toEqual({\n    value: undefined,\n    done: false\n  });\n  const cloneElseIf = cloneableGen.clone();\n  const cloneElse = cloneElseIf.clone();\n  expect(cloneableGen.next(13)).toEqual({\n    value: 8,\n    done: false\n  });\n  expect(cloneableGen.next()).toEqual({\n    value: undefined,\n    done: true\n  });\n  expect(cloneElseIf.next(5)).toEqual({\n    value: 'you win',\n    done: false\n  });\n  expect(cloneElseIf.next()).toEqual({\n    value: undefined,\n    done: true\n  });\n  expect(cloneElse.next(2)).toEqual({\n    value: 3,\n    done: false\n  });\n  const cloneReturn = cloneElse.clone();\n  const cloneThrow = cloneElse.clone();\n  expect(cloneElse.next()).toEqual({\n    value: undefined,\n    done: true\n  });\n  expect(cloneReturn.return('toto')).toEqual({\n    value: 'toto',\n    done: true\n  });\n  expect(() => cloneThrow.throw('throws an exception')).toThrow();\n});","file":"cloneableGenerator.js","skipped":false,"dir":"packages/testing-utils/__tests__"},{"name":"should allow to use createMockTask for testing purposes","suites":[],"updatePoint":{"line":3,"column":61},"line":3,"code":"test('should allow to use createMockTask for testing purposes', () => {\n  function* sagaToRun() {}\n\n  function* rootSaga() {\n    const task = yield fork(sagaToRun);\n    yield cancel(task);\n  }\n\n  const taskMock = createMockTask();\n  const generator = rootSaga();\n  expect(generator.next().value).toEqual(fork(sagaToRun));\n  expect(generator.next(taskMock).value).toEqual(cancel(taskMock));\n});","file":"createMockTask.js","skipped":false,"dir":"packages/testing-utils/__tests__"}]}