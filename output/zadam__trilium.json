{
    "repo": "zadam/trilium",
    "url": "https://github.com/zadam/trilium",
    "branch": "master",
    "configs": [
        {
            "package": "trilium",
            "lang": "js",
            "dir": "spec",
            "framework": "jasmine",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "simple lexing",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 4,
            "updatePoint": {
                "line": 4,
                "column": 19
            },
            "code": "  it(\"simple lexing\", () => {\n    expect(lex(\"hello world\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"world\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "use quotes to keep words together",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 7,
            "updatePoint": {
                "line": 7,
                "column": 39
            },
            "code": "  it(\"use quotes to keep words together\", () => {\n    expect(lex(\"'hello world' my friend\").fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n    expect(lex('\"hello world\" my friend').fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n    expect(lex('`hello world` my friend').fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "you can use different quotes and other special characters inside quotes",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 12,
            "updatePoint": {
                "line": 12,
                "column": 77
            },
            "code": "  it(\"you can use different quotes and other special characters inside quotes\", () => {\n    expect(lex(\"'i can use \\\" or ` or #~=*' without problem\").fulltextTokens.map(t => t.token)).toEqual([\"i can use \\\" or ` or #~=*\", \"without\", \"problem\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "I can use backslash to escape quotes",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 15,
            "updatePoint": {
                "line": 15,
                "column": 42
            },
            "code": "  it(\"I can use backslash to escape quotes\", () => {\n    expect(lex(\"hello \\\\\\\"world\\\\\\\"\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", '\"world\"']);\n    expect(lex(\"hello \\\\\\'world\\\\\\'\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"'world'\"]);\n    expect(lex(\"hello \\\\\\`world\\\\\\`\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", '`world`']);\n    expect(lex('\"hello \\\\\\\"world\\\\\\\"').fulltextTokens.map(t => t.token)).toEqual(['hello \"world\"']);\n    expect(lex(\"'hello \\\\\\'world\\\\\\''\").fulltextTokens.map(t => t.token)).toEqual([\"hello 'world'\"]);\n    expect(lex(\"`hello \\\\\\`world\\\\\\``\").fulltextTokens.map(t => t.token)).toEqual([\"hello `world`\"]);\n    expect(lex(\"\\\\#token\").fulltextTokens.map(t => t.token)).toEqual([\"#token\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "quote inside a word does not have a special meaning",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 57
            },
            "code": "  it(\"quote inside a word does not have a special meaning\", () => {\n    const lexResult = lex(\"d'Artagnan is dead #hero = d'Artagnan\");\n    expect(lexResult.fulltextTokens.map(t => t.token)).toEqual([\"d'artagnan\", \"is\", \"dead\"]);\n    expect(lexResult.expressionTokens.map(t => t.token)).toEqual(['#hero', '=', \"d'artagnan\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "if quote is not ended then it's just one long token",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 29,
            "updatePoint": {
                "line": 29,
                "column": 57
            },
            "code": "  it(\"if quote is not ended then it's just one long token\", () => {\n    expect(lex(\"'unfinished quote\").fulltextTokens.map(t => t.token)).toEqual([\"unfinished quote\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "parenthesis and symbols in fulltext section are just normal characters",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 32,
            "updatePoint": {
                "line": 32,
                "column": 76
            },
            "code": "  it(\"parenthesis and symbols in fulltext section are just normal characters\", () => {\n    expect(lex(\"what's u=p <b(r*t)h>\").fulltextTokens.map(t => t.token)).toEqual([\"what's\", \"u=p\", \"<b(r*t)h>\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "operator characters in expressions are separate tokens",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 35,
            "updatePoint": {
                "line": 35,
                "column": 60
            },
            "code": "  it(\"operator characters in expressions are separate tokens\", () => {\n    expect(lex(\"# abc+=-def**-+d\").expressionTokens.map(t => t.token)).toEqual([\"#\", \"abc\", \"+=-\", \"def\", \"**-+\", \"d\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "escaping special characters",
            "suites": [
                "Lexer fulltext"
            ],
            "line": 38,
            "updatePoint": {
                "line": 38,
                "column": 33
            },
            "code": "  it(\"escaping special characters\", () => {\n    expect(lex(\"hello \\\\#\\\\~\\\\'\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"#~'\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple attribute existence",
            "suites": [
                "Lexer expression"
            ],
            "line": 43,
            "updatePoint": {
                "line": 43,
                "column": 32
            },
            "code": "  it(\"simple attribute existence\", () => {\n    expect(lex(\"#label ~relation\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"~relation\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label operators",
            "suites": [
                "Lexer expression"
            ],
            "line": 46,
            "updatePoint": {
                "line": 46,
                "column": 28
            },
            "code": "  it(\"simple label operators\", () => {\n    expect(lex(\"#label*=*text\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"*=*\", \"text\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label operator with in quotes",
            "suites": [
                "Lexer expression"
            ],
            "line": 49,
            "updatePoint": {
                "line": 49,
                "column": 42
            },
            "code": "  it(\"simple label operator with in quotes\", () => {\n    expect(lex(\"#label*=*'text'\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"*=*\",\n      inQuotes: false,\n      startIndex: 6,\n      endIndex: 8\n    }, {\n      token: \"text\",\n      inQuotes: true,\n      startIndex: 10,\n      endIndex: 13\n    }]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label operator with param without quotes",
            "suites": [
                "Lexer expression"
            ],
            "line": 67,
            "updatePoint": {
                "line": 67,
                "column": 53
            },
            "code": "  it(\"simple label operator with param without quotes\", () => {\n    expect(lex(\"#label*=*text\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"*=*\",\n      inQuotes: false,\n      startIndex: 6,\n      endIndex: 8\n    }, {\n      token: \"text\",\n      inQuotes: false,\n      startIndex: 9,\n      endIndex: 12\n    }]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label operator with empty string param",
            "suites": [
                "Lexer expression"
            ],
            "line": 85,
            "updatePoint": {
                "line": 85,
                "column": 51
            },
            "code": "  it(\"simple label operator with empty string param\", () => {\n    expect(lex(\"#label = ''\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"=\",\n      inQuotes: false,\n      startIndex: 7,\n      endIndex: 7\n    }, // weird case for empty strings which ends up with endIndex < startIndex :-(\n    {\n      token: \"\",\n      inQuotes: true,\n      startIndex: 10,\n      endIndex: 9\n    }]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "note. prefix also separates fulltext from expression",
            "suites": [
                "Lexer expression"
            ],
            "line": 104,
            "updatePoint": {
                "line": 104,
                "column": 58
            },
            "code": "  it(\"note. prefix also separates fulltext from expression\", () => {\n    expect(lex(`hello fulltext note.labels.capital = Prague`).expressionTokens.map(t => t.token)).toEqual([\"note\", \".\", \"labels\", \".\", \"capital\", \"=\", \"prague\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "note. prefix in quotes will note start expression",
            "suites": [
                "Lexer expression"
            ],
            "line": 107,
            "updatePoint": {
                "line": 107,
                "column": 55
            },
            "code": "  it(\"note. prefix in quotes will note start expression\", () => {\n    expect(lex(`hello fulltext \"note.txt\"`).expressionTokens.map(t => t.token)).toEqual([]);\n    expect(lex(`hello fulltext \"note.txt\"`).fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"fulltext\", \"note.txt\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "complex expressions with and, or and parenthesis",
            "suites": [
                "Lexer expression"
            ],
            "line": 111,
            "updatePoint": {
                "line": 111,
                "column": 54
            },
            "code": "  it(\"complex expressions with and, or and parenthesis\", () => {\n    expect(lex(`# (#label=text OR #second=text) AND ~relation`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"(\", \"#label\", \"=\", \"text\", \"or\", \"#second\", \"=\", \"text\", \")\", \"and\", \"~relation\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "dot separated properties",
            "suites": [
                "Lexer expression"
            ],
            "line": 114,
            "updatePoint": {
                "line": 114,
                "column": 30
            },
            "code": "  it(\"dot separated properties\", () => {\n    expect(lex(`# ~author.title = 'Hugh Howey' AND note.'book title' = 'Silo'`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"~author\", \".\", \"title\", \"=\", \"hugh howey\", \"and\", \"note\", \".\", \"book title\", \"=\", \"silo\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "negation of label and relation",
            "suites": [
                "Lexer expression"
            ],
            "line": 117,
            "updatePoint": {
                "line": 117,
                "column": 36
            },
            "code": "  it(\"negation of label and relation\", () => {\n    expect(lex(`#!capital ~!neighbor`).expressionTokens.map(t => t.token)).toEqual([\"#!capital\", \"~!neighbor\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "negation of sub-expression",
            "suites": [
                "Lexer expression"
            ],
            "line": 120,
            "updatePoint": {
                "line": 120,
                "column": 32
            },
            "code": "  it(\"negation of sub-expression\", () => {\n    expect(lex(`# not(#capital) and note.noteId != \"root\"`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"not\", \"(\", \"#capital\", \")\", \"and\", \"note\", \".\", \"noteid\", \"!=\", \"root\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "concatenated attributes",
            "suites": [
                "Lexer invalid queries and edge cases"
            ],
            "line": 125,
            "updatePoint": {
                "line": 125,
                "column": 29
            },
            "code": "  it(\"concatenated attributes\", () => {\n    expect(lex(\"#label~relation\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"~relation\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trailing escape \\",
            "suites": [
                "Lexer invalid queries and edge cases"
            ],
            "line": 128,
            "updatePoint": {
                "line": 128,
                "column": 24
            },
            "code": "  it(\"trailing escape \\\\\", () => {\n    expect(lex('abc \\\\').fulltextTokens.map(t => t.token)).toEqual([\"abc\", \"\\\\\"]);\n  });",
            "file": "search/lexer.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles parens",
            "suites": [
                "Parens handler"
            ],
            "line": 4,
            "updatePoint": {
                "line": 4,
                "column": 20
            },
            "code": "  it(\"handles parens\", () => {\n    const input = [\"(\", \"hello\", \")\", \"and\", \"(\", \"(\", \"pick\", \"one\", \")\", \"and\", \"another\", \")\"].map(token => ({\n      token\n    }));\n    expect(handleParens(input)).toEqual([[{\n      token: \"hello\"\n    }], {\n      token: \"and\"\n    }, [[{\n      token: \"pick\"\n    }, {\n      token: \"one\"\n    }], {\n      token: \"and\"\n    }, {\n      token: \"another\"\n    }]]);\n  });",
            "file": "search/parens.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fulltext parser without content",
            "suites": [
                "Parser"
            ],
            "line": 29,
            "updatePoint": {
                "line": 29,
                "column": 37
            },
            "code": "  it(\"fulltext parser without content\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\", \"hi\"]),\n      expressionTokens: [],\n      searchContext: new SearchContext({\n        includeNoteContent: false,\n        excludeArchived: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    expect(rootExp.subExpressions[0].constructor.name).toEqual(\"PropertyComparisonExp\");\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    expect(rootExp.subExpressions[1].subExpressions[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(rootExp.subExpressions[1].subExpressions[0].tokens).toEqual([\"hello\", \"hi\"]);\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fulltext parser with content",
            "suites": [
                "Parser"
            ],
            "line": 44,
            "updatePoint": {
                "line": 44,
                "column": 34
            },
            "code": "  it(\"fulltext parser with content\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\", \"hi\"]),\n      expressionTokens: [],\n      searchContext: new SearchContext({\n        includeNoteContent: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const subs = rootExp.subExpressions[1].subExpressions;\n    expect(subs[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(subs[0].tokens).toEqual([\"hello\", \"hi\"]);\n    expect(subs[1].constructor.name).toEqual(\"NoteContentProtectedFulltextExp\");\n    expect(subs[1].tokens).toEqual([\"hello\", \"hi\"]);\n    expect(subs[2].constructor.name).toEqual(\"NoteContentUnprotectedFulltextExp\");\n    expect(subs[2].tokens).toEqual([\"hello\", \"hi\"]);\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label comparison",
            "suites": [
                "Parser"
            ],
            "line": 63,
            "updatePoint": {
                "line": 63,
                "column": 29
            },
            "code": "  it(\"simple label comparison\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#mylabel\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(rootExp.subExpressions[1].attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].attributeName).toEqual(\"mylabel\");\n    expect(rootExp.subExpressions[1].comparator).toBeTruthy();\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple attribute negation",
            "suites": [
                "Parser"
            ],
            "line": 76,
            "updatePoint": {
                "line": 76,
                "column": 31
            },
            "code": "  it(\"simple attribute negation\", () => {\n    let rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#!mylabel\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"NotExp\");\n    expect(rootExp.subExpressions[1].subExpression.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(rootExp.subExpressions[1].subExpression.attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].subExpression.attributeName).toEqual(\"mylabel\");\n    rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"~!myrelation\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"NotExp\");\n    expect(rootExp.subExpressions[1].subExpression.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(rootExp.subExpressions[1].subExpression.attributeType).toEqual(\"relation\");\n    expect(rootExp.subExpressions[1].subExpression.attributeName).toEqual(\"myrelation\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label AND",
            "suites": [
                "Parser"
            ],
            "line": 100,
            "updatePoint": {
                "line": 100,
                "column": 22
            },
            "code": "  it(\"simple label AND\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"and\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext(true)\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label AND without explicit AND",
            "suites": [
                "Parser"
            ],
            "line": 115,
            "updatePoint": {
                "line": 115,
                "column": 43
            },
            "code": "  it(\"simple label AND without explicit AND\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple label OR",
            "suites": [
                "Parser"
            ],
            "line": 130,
            "updatePoint": {
                "line": 130,
                "column": 21
            },
            "code": "  it(\"simple label OR\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"or\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fulltext and simple label",
            "suites": [
                "Parser"
            ],
            "line": 145,
            "updatePoint": {
                "line": 145,
                "column": 31
            },
            "code": "  it(\"fulltext and simple label\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\"]),\n      expressionTokens: tokens([\"#mylabel\", \"=\", \"text\"]),\n      searchContext: new SearchContext({\n        excludeArchived: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub, thirdSub] = rootExp.subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"PropertyComparisonExp\");\n    expect(firstSub.propertyName).toEqual('isArchived');\n    expect(secondSub.constructor.name).toEqual(\"OrExp\");\n    expect(secondSub.subExpressions[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(secondSub.subExpressions[0].tokens).toEqual([\"hello\"]);\n    expect(thirdSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(thirdSub.attributeName).toEqual(\"mylabel\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "label sub-expression",
            "suites": [
                "Parser"
            ],
            "line": 163,
            "updatePoint": {
                "line": 163,
                "column": 26
            },
            "code": "  it(\"label sub-expression\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"or\", [\"#second\", \"=\", \"text\", \"and\", \"#third\", \"=\", \"text\"]]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"AndExp\");\n    const [firstSubSub, secondSubSub] = secondSub.subExpressions;\n    expect(firstSubSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSubSub.attributeName).toEqual(\"second\");\n    expect(secondSubSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSubSub.attributeName).toEqual(\"third\");\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "incomplete comparison",
            "suites": [
                "Invalid expressions"
            ],
            "line": 184,
            "updatePoint": {
                "line": 184,
                "column": 27
            },
            "code": "  it(\"incomplete comparison\", () => {\n    const searchContext = new SearchContext();\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual('Misplaced or incomplete expression \"=\"');\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "comparison between labels is impossible",
            "suites": [
                "Invalid expressions"
            ],
            "line": 193,
            "updatePoint": {
                "line": 193,
                "column": 45
            },
            "code": "  it(\"comparison between labels is impossible\", () => {\n    let searchContext = new SearchContext();\n    searchContext.originalQuery = \"#first = #second\";\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"#second\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual(`Error near token \"#second\" in \"#first = #second\", it's possible to compare with constant only.`);\n    searchContext = new SearchContext();\n    searchContext.originalQuery = \"#first = note.relations.second\";\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"note\", \".\", \"relations\", \"second\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual(`Error near token \"note\" in \"#first = note.relations.second\", it's possible to compare with constant only.`);\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: [{\n        token: \"#first\",\n        inQuotes: false\n      }, {\n        token: \"=\",\n        inQuotes: false\n      }, {\n        token: \"#second\",\n        inQuotes: true\n      }],\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(rootExp.subExpressions[1].attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].attributeName).toEqual(\"first\");\n    expect(rootExp.subExpressions[1].comparator).toBeTruthy();\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searching by relation without note property",
            "suites": [
                "Invalid expressions"
            ],
            "line": 231,
            "updatePoint": {
                "line": 231,
                "column": 49
            },
            "code": "  it(\"searching by relation without note property\", () => {\n    const searchContext = new SearchContext();\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"~first\", \"=\", \"text\", \"-\", \"abc\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual('Relation can be compared only with property, e.g. ~relation.title=hello in \"\"');\n  });",
            "file": "search/parser.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple path match",
            "suites": [
                "Search"
            ],
            "line": 35,
            "updatePoint": {
                "line": 35,
                "column": 23
            },
            "code": "  it(\"simple path match\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('europe austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normal search looks also at attributes",
            "suites": [
                "Search"
            ],
            "line": 42,
            "updatePoint": {
                "line": 42,
                "column": 44
            },
            "code": "  it(\"normal search looks also at attributes\", () => {\n    const austria = note(\"Austria\");\n    const vienna = note(\"Vienna\");\n    rootNote.child(austria.relation('capital', vienna)).child(vienna.label('inhabitants', '1888776'));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('capital', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('inhabitants', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Vienna\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normal search looks also at type and mime",
            "suites": [
                "Search"
            ],
            "line": 54,
            "updatePoint": {
                "line": 54,
                "column": 47
            },
            "code": "  it(\"normal search looks also at type and mime\", () => {\n    rootNote.child(note(\"Effective Java\", {\n      type: 'book',\n      mime: ''\n    })).child(note(\"Hello World.java\", {\n      type: 'code',\n      mime: 'text/x-java'\n    }));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('book', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Effective Java\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('text', searchContext); // should match mime\n\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Hello World.java\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('java', searchContext);\n    expect(searchResults.length).toEqual(2);\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only end leafs are results",
            "suites": [
                "Search"
            ],
            "line": 73,
            "updatePoint": {
                "line": 73,
                "column": 32
            },
            "code": "  it(\"only end leafs are results\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only end leafs are results",
            "suites": [
                "Search"
            ],
            "line": 80,
            "updatePoint": {
                "line": 80,
                "column": 32
            },
            "code": "  it(\"only end leafs are results\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('Vienna', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "label comparison with short syntax",
            "suites": [
                "Search"
            ],
            "line": 87,
            "updatePoint": {
                "line": 87,
                "column": 40
            },
            "code": "  it(\"label comparison with short syntax\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')).child(note(\"Czech Republic\").label('capital', 'Prague')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#capital=Vienna', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy(); // case sensitivity:\n\n    searchResults = searchService.findResultsWithQuery('#CAPITAL=VIENNA', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#caPItal=vienNa', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "label comparison with full syntax",
            "suites": [
                "Search"
            ],
            "line": 101,
            "updatePoint": {
                "line": 101,
                "column": 39
            },
            "code": "  it(\"label comparison with full syntax\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')).child(note(\"Czech Republic\").label('capital', 'Prague')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.labels.capital=Prague', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "numeric label comparison",
            "suites": [
                "Search"
            ],
            "line": 108,
            "updatePoint": {
                "line": 108,
                "column": 30
            },
            "code": "  it(\"numeric label comparison\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('population', '8859000')).child(note(\"Czech Republic\").label('population', '10650000')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('#country #population >= 10000000', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inherited label comparison",
            "suites": [
                "Search"
            ],
            "line": 115,
            "updatePoint": {
                "line": 115,
                "column": 32
            },
            "code": "  it(\"inherited label comparison\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\")).child(note(\"Czech Republic\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('austria #country', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "numeric label comparison fallback to string comparison",
            "suites": [
                "Search"
            ],
            "line": 122,
            "updatePoint": {
                "line": 122,
                "column": 60
            },
            "code": "  it(\"numeric label comparison fallback to string comparison\", () => {\n    // dates should not be coerced into numbers which would then give wrong numbers\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('established', '1955-07-27')).child(note(\"Czech Republic\").label('established', '1993-01-01')).child(note(\"Hungary\").label('established', '1920-06-04')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#established <= \"1955-01-01\"', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Hungary\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#established > \"1955-01-01\"', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "smart date comparisons",
            "suites": [
                "Search"
            ],
            "line": 134,
            "updatePoint": {
                "line": 134,
                "column": 28
            },
            "code": "  it(\"smart date comparisons\", () => {\n    // dates should not be coerced into numbers which would then give wrong numbers\n    rootNote.child(note(\"My note\", {\n      dateCreated: dateUtils.localNowDateTime()\n    }).label('year', new Date().getFullYear().toString()).label('month', dateUtils.localNowDate().substr(0, 7)).label('date', dateUtils.localNowDate()).label('dateTime', dateUtils.localNowDateTime()));\n    const searchContext = new SearchContext();\n\n    function test(query, expectedResultCount) {\n      const searchResults = searchService.findResultsWithQuery(query, searchContext);\n      expect(searchResults.length).toEqual(expectedResultCount);\n\n      if (expectedResultCount === 1) {\n        expect(findNoteByTitle(searchResults, \"My note\")).toBeTruthy();\n      }\n    }\n\n    test(\"#year = YEAR\", 1);\n    test(\"#year = 'YEAR'\", 0);\n    test(\"#year >= YEAR\", 1);\n    test(\"#year <= YEAR\", 1);\n    test(\"#year < YEAR+1\", 1);\n    test(\"#year < YEAR + 1\", 1);\n    test(\"#year < year + 1\", 1);\n    test(\"#year > YEAR+1\", 0);\n    test(\"#month = MONTH\", 1);\n    test(\"#month = month\", 1);\n    test(\"#month = 'MONTH'\", 0);\n    test(\"note.dateCreated =* month\", 2);\n    test(\"#date = TODAY\", 1);\n    test(\"#date = today\", 1);\n    test(\"#date = 'today'\", 0);\n    test(\"#date > TODAY\", 0);\n    test(\"#date > TODAY-1\", 1);\n    test(\"#date > TODAY - 1\", 1);\n    test(\"#date < TODAY+1\", 1);\n    test(\"#date < TODAY + 1\", 1);\n    test(\"#date < 'TODAY + 1'\", 1);\n    test(\"#dateTime <= NOW+10\", 1);\n    test(\"#dateTime <= NOW + 10\", 1);\n    test(\"#dateTime < NOW-10\", 0);\n    test(\"#dateTime >= NOW-10\", 1);\n    test(\"#dateTime < NOW-10\", 0);\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "logical or",
            "suites": [
                "Search"
            ],
            "line": 177,
            "updatePoint": {
                "line": 177,
                "column": 16
            },
            "code": "  it(\"logical or\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('languageFamily', 'germanic')).child(note(\"Czech Republic\").label('languageFamily', 'slavic')).child(note(\"Hungary\").label('languageFamily', 'finnougric')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('#languageFamily = slavic OR #languageFamily = germanic', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fuzzy attribute search",
            "suites": [
                "Search"
            ],
            "line": 185,
            "updatePoint": {
                "line": 185,
                "column": 28
            },
            "code": "  it(\"fuzzy attribute search\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('languageFamily', 'germanic')).child(note(\"Czech Republic\").label('languageFamily', 'slavic')));\n    let searchContext = new SearchContext({\n      fuzzyAttributeSearch: false\n    });\n    let searchResults = searchService.findResultsWithQuery('#language', searchContext);\n    expect(searchResults.length).toEqual(0);\n    searchResults = searchService.findResultsWithQuery('#languageFamily=ger', searchContext);\n    expect(searchResults.length).toEqual(0);\n    searchContext = new SearchContext({\n      fuzzyAttributeSearch: true\n    });\n    searchResults = searchService.findResultsWithQuery('#language', searchContext);\n    expect(searchResults.length).toEqual(2);\n    searchResults = searchService.findResultsWithQuery('#languageFamily=ger', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by note property",
            "suites": [
                "Search"
            ],
            "line": 203,
            "updatePoint": {
                "line": 203,
                "column": 29
            },
            "code": "  it(\"filter by note property\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('# note.title =* czech', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by note's parent",
            "suites": [
                "Search"
            ],
            "line": 210,
            "updatePoint": {
                "line": 210,
                "column": 29
            },
            "code": "  it(\"filter by note's parent\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\").child(note(\"Prague\")))).child(note(\"Asia\").child(note('Taiwan')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Asia', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Taiwan\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.parents.parents.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Prague\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by note's ancestor",
            "suites": [
                "Search"
            ],
            "line": 224,
            "updatePoint": {
                "line": 224,
                "column": 31
            },
            "code": "  it(\"filter by note's ancestor\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\").child(note(\"Prague\").label('city')))).child(note(\"Asia\").child(note('Taiwan').child(note('Taipei').label('city'))));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#city AND note.ancestors.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Prague\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#city AND note.ancestors.title = Asia', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Taipei\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by note's child",
            "suites": [
                "Search"
            ],
            "line": 234,
            "updatePoint": {
                "line": 234,
                "column": 28
            },
            "code": "  it(\"filter by note's child\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").child(note(\"Vienna\"))).child(note(\"Czech Republic\").child(note(\"Prague\")))).child(note(\"Oceania\").child(note('Australia')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.children.title =* Aust', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Oceania\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.children.title =* Aust AND note.children.title *= republic', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.children.children.title = Prague', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by relation's note properties using short syntax",
            "suites": [
                "Search"
            ],
            "line": 248,
            "updatePoint": {
                "line": 248,
                "column": 61
            },
            "code": "  it(\"filter by relation's note properties using short syntax\", () => {\n    const austria = note(\"Austria\");\n    const portugal = note(\"Portugal\");\n    rootNote.child(note(\"Europe\").child(austria).child(note(\"Czech Republic\").relation('neighbor', austria.note)).child(portugal).child(note(\"Spain\").relation('neighbor', portugal.note)));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# ~neighbor.title = Austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# ~neighbor.title = Portugal', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Spain\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by relation's note properties using long syntax",
            "suites": [
                "Search"
            ],
            "line": 260,
            "updatePoint": {
                "line": 260,
                "column": 60
            },
            "code": "  it(\"filter by relation's note properties using long syntax\", () => {\n    const austria = note(\"Austria\");\n    const portugal = note(\"Portugal\");\n    rootNote.child(note(\"Europe\").child(austria).child(note(\"Czech Republic\").relation('neighbor', austria.note)).child(portugal).child(note(\"Spain\").relation('neighbor', portugal.note)));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.title = Austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filter by multiple level relation",
            "suites": [
                "Search"
            ],
            "line": 269,
            "updatePoint": {
                "line": 269,
                "column": 39
            },
            "code": "  it(\"filter by multiple level relation\", () => {\n    const austria = note(\"Austria\");\n    const slovakia = note(\"Slovakia\");\n    const italy = note(\"Italy\");\n    const ukraine = note(\"Ukraine\");\n    rootNote.child(note(\"Europe\").child(austria.relation('neighbor', italy.note).relation('neighbor', slovakia.note)).child(note(\"Czech Republic\").relation('neighbor', austria.note).relation('neighbor', slovakia.note)).child(slovakia.relation('neighbor', ukraine.note)).child(ukraine));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.relations.neighbor.title = Italy', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.relations.neighbor.title = Ukraine', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "test note properties",
            "suites": [
                "Search"
            ],
            "line": 284,
            "updatePoint": {
                "line": 284,
                "column": 26
            },
            "code": "  it(\"test note properties\", () => {\n    const austria = note(\"Austria\");\n    austria.relation('myself', austria.note);\n    austria.label('capital', 'Vienna');\n    austria.label('population', '8859000');\n    rootNote.child(note(\"Asia\")).child(note(\"Europe\").child(austria.child(note(\"Vienna\")).child(note(\"Sebastian Kurz\")))).child(note(\"Mozart\").child(austria));\n    austria.note.isProtected = false;\n    austria.note.dateCreated = '2020-05-14 12:11:42.001+0200';\n    austria.note.dateModified = '2020-05-14 13:11:42.001+0200';\n    austria.note.utcDateCreated = '2020-05-14 10:11:42.001Z';\n    austria.note.utcDateModified = '2020-05-14 11:11:42.001Z';\n    austria.note.contentLength = 1001;\n    const searchContext = new SearchContext();\n\n    function test(propertyName, value, expectedResultCount) {\n      const searchResults = searchService.findResultsWithQuery(`# note.${propertyName} = ${value}`, searchContext);\n      expect(searchResults.length).toEqual(expectedResultCount);\n    }\n\n    test(\"type\", \"text\", 7);\n    test(\"TYPE\", \"TEXT\", 7);\n    test(\"type\", \"code\", 0);\n    test(\"mime\", \"text/html\", 6);\n    test(\"mime\", \"application/json\", 0);\n    test(\"isProtected\", \"false\", 7);\n    test(\"isProtected\", \"FALSE\", 7);\n    test(\"isProtected\", \"true\", 0);\n    test(\"isProtected\", \"TRUE\", 0);\n    test(\"dateCreated\", \"'2020-05-14 12:11:42.001+0200'\", 1);\n    test(\"dateCreated\", \"wrong\", 0);\n    test(\"dateModified\", \"'2020-05-14 13:11:42.001+0200'\", 1);\n    test(\"dateModified\", \"wrong\", 0);\n    test(\"utcDateCreated\", \"'2020-05-14 10:11:42.001Z'\", 1);\n    test(\"utcDateCreated\", \"wrong\", 0);\n    test(\"utcDateModified\", \"'2020-05-14 11:11:42.001Z'\", 1);\n    test(\"utcDateModified\", \"wrong\", 0);\n    test(\"parentCount\", \"2\", 1);\n    test(\"parentCount\", \"3\", 0);\n    test(\"childrenCount\", \"2\", 1);\n    test(\"childrenCount\", \"10\", 0);\n    test(\"attributeCount\", \"3\", 1);\n    test(\"attributeCount\", \"4\", 0);\n    test(\"labelCount\", \"2\", 1);\n    test(\"labelCount\", \"3\", 0);\n    test(\"relationCount\", \"1\", 1);\n    test(\"relationCount\", \"2\", 0);\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "test order by",
            "suites": [
                "Search"
            ],
            "line": 331,
            "updatePoint": {
                "line": 331,
                "column": 19
            },
            "code": "  it(\"test order by\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    const austria = note(\"Austria\").label(\"capital\", \"Vienna\");\n    const ukraine = note(\"Ukraine\").label(\"capital\", \"Kiev\");\n    rootNote.child(note(\"Europe\").child(ukraine).child(slovakia).child(austria).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.title', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Slovakia\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Ukraine\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Slovakia\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Ukraine\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Austria\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital DESC', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Ukraine\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Slovakia\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital DESC limit 2', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy #capital DESC limit 1', searchContext);\n    expect(searchResults.length).toEqual(1);\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy #capital DESC limit 1000', searchContext);\n    expect(searchResults.length).toEqual(4);\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "test not(...)",
            "suites": [
                "Search"
            ],
            "line": 365,
            "updatePoint": {
                "line": 365,
                "column": 19
            },
            "code": "  it(\"test not(...)\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Europe\").child(slovakia).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# not(#capital) and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Europe\");\n    searchResults = searchService.findResultsWithQuery('#!capital and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Europe\");\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "test note.text *=* something",
            "suites": [
                "Search"
            ],
            "line": 377,
            "updatePoint": {
                "line": 377,
                "column": 34
            },
            "code": "  it(\"test note.text *=* something\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Europe\").child(slovakia).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.text *=* vaki and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Slovakia\");\n  });",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "test that fulltext does not match archived notes",
            "suites": [
                "Search"
            ],
            "line": 386,
            "updatePoint": {
                "line": 386,
                "column": 54
            },
            "code": "  it(\"test that fulltext does not match archived notes\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Reddit\").label('archived', '', true).child(note('Post X')).child(note('Post Y'))).child(note('Reddit is bad'));\n    const searchContext = new SearchContext({\n      excludeArchived: true\n    });\n    let searchResults = searchService.findResultsWithQuery('reddit', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Reddit is bad\");\n  }); // FIXME: test what happens when we order without any filter criteria",
            "file": "search/search.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simple title extraction",
            "suites": [
                "Value extractor"
            ],
            "line": 16,
            "updatePoint": {
                "line": 16,
                "column": 29
            },
            "code": "  it(\"simple title extraction\", async () => {\n    const europe = note(\"Europe\").note;\n    const valueExtractor = new ValueExtractor(dsc, [\"note\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(europe)).toEqual(\"Europe\");\n  });",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "label extraction",
            "suites": [
                "Value extractor"
            ],
            "line": 22,
            "updatePoint": {
                "line": 22,
                "column": 22
            },
            "code": "  it(\"label extraction\", async () => {\n    const austria = note(\"Austria\").label(\"Capital\", \"Vienna\").note;\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria)).toEqual(\"Vienna\");\n    valueExtractor = new ValueExtractor(dsc, [\"#capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria)).toEqual(\"Vienna\");\n  });",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "parent/child property extraction",
            "suites": [
                "Value extractor"
            ],
            "line": 31,
            "updatePoint": {
                "line": 31,
                "column": 38
            },
            "code": "  it(\"parent/child property extraction\", async () => {\n    const vienna = note(\"Vienna\");\n    const europe = note(\"Europe\").child(note(\"Austria\").child(vienna));\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"children\", \"children\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(europe.note)).toEqual(\"Vienna\");\n    valueExtractor = new ValueExtractor(dsc, [\"note\", \"parents\", \"parents\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(vienna.note)).toEqual(\"Europe\");\n  });",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "extract through relation",
            "suites": [
                "Value extractor"
            ],
            "line": 41,
            "updatePoint": {
                "line": 41,
                "column": 30
            },
            "code": "  it(\"extract through relation\", async () => {\n    const czechRepublic = note(\"Czech Republic\").label(\"capital\", \"Prague\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    const austria = note(\"Austria\").relation('neighbor', czechRepublic.note).relation('neighbor', slovakia.note);\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"relations\", \"neighbor\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria.note)).toEqual(\"Prague\");\n    valueExtractor = new ValueExtractor(dsc, [\"~neighbor\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria.note)).toEqual(\"Prague\");\n  });",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "each path must start with \"note\" (or label/relation)",
            "suites": [
                "Invalid value extractor property path"
            ],
            "line": 54,
            "updatePoint": {
                "line": 54,
                "column": 58
            },
            "code": "  it('each path must start with \"note\" (or label/relation)', () => expect(new ValueExtractor(dsc, [\"neighbor\"]).validate()).toBeTruthy());",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "extra path element after terminal label",
            "suites": [
                "Invalid value extractor property path"
            ],
            "line": 55,
            "updatePoint": {
                "line": 55,
                "column": 45
            },
            "code": "  it(\"extra path element after terminal label\", () => expect(new ValueExtractor(dsc, [\"~neighbor\", \"labels\", \"capital\", \"noteId\"]).validate()).toBeTruthy());",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "extra path element after terminal title",
            "suites": [
                "Invalid value extractor property path"
            ],
            "line": 56,
            "updatePoint": {
                "line": 56,
                "column": 45
            },
            "code": "  it(\"extra path element after terminal title\", () => expect(new ValueExtractor(dsc, [\"note\", \"title\", \"isProtected\"]).validate()).toBeTruthy());",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "relation name and note property is missing",
            "suites": [
                "Invalid value extractor property path"
            ],
            "line": 57,
            "updatePoint": {
                "line": 57,
                "column": 48
            },
            "code": "  it(\"relation name and note property is missing\", () => expect(new ValueExtractor(dsc, [\"note\", \"relations\"]).validate()).toBeTruthy());",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "relation is specified but target note property is not specified",
            "suites": [
                "Invalid value extractor property path"
            ],
            "line": 58,
            "updatePoint": {
                "line": 58,
                "column": 69
            },
            "code": "  it(\"relation is specified but target note property is not specified\", () => expect(new ValueExtractor(dsc, [\"note\", \"relations\", \"myrel\"]).validate()).toBeTruthy());",
            "file": "search/value_extractor.spec.js",
            "skipped": false,
            "dir": "spec"
        }
    ],
    "badge": "zadam__trilium.svg"
}